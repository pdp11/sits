%ABSAD=1

;THIS IS THE WAY RUG LOOKS WHEN IT IS IN CORE (WHEN IT ISN'T CLOBBERED)

;THE SYMBOL TABLE EXTENDS DOWN TOWARDS CSTBL
;IT MEETS RUGS SYMBOLS AT RUGFNT (WHERE RUG BEGINS)
;AND CONTINUES TO O.BSYM

;RUGS STACK SITS ABOVE THAT FOLLOWED BY 
;ITS COPY OF THE USERS REGISTERS AND
;THE BREAKPOINT TABLES

;NOW COMES THE BODY OF RUG

;THE CONSOLE PROGRAM AND ABSOLUTE LOADER ARE IN HERE SOMEWHERE

;AND LAST OF ALL THE RESIDENT PORTION OF RUG SITS AT THE VERY TOP
;DEFINE A BUNCH OF FLAGS


	.IF1
	.MACRO SETF TEXT,FLG
	.PRINT "TEXT
FLG'="
	.TTYMAC FLAG
	FLG==FLAG
	.ENDM
	.ENDM

	SETF ^\0=>GUY45, 1=>LOGO45, 2=>TV20, 3=>OTHER\,COMPUTER
	.IFZ COMPUTER
	.TITLE RUG FOR GUY'S LOGO 11/45
	TEN11==0
	FMH==1
	HCOR==160000
	CSTBL==30000
	F.HD==0
	DM11==0
	KL11==0
	M.HD==1
	FPTR==1
	M1145==1
	FPP==1
	DCSPD==10
	.ENDC
	.IFZ COMPUTER-1
	.TITLE RUG FOR THE LOGO 11/45
	TEN11==1
	FMH==1
	HCOR==160000
	CSTBL==30000
	F.HD==0
	DM11==0
	KL11==0
	M.HD==1
	FPTR==1
	M1145==1
	FPP==1
	DCSPD==30
	.ENDC

	.IFZ COMPUTER-2
	.TITLE RUG FOR THE TV 11/20
	TEN11==0
	FMH==0
	HCOR==60000
	CSTBL==20000
	F.HD==1
	DM11==0
	KL11==0
	M.HD==0
	FPTR==0
	M1145==0
	FPP==0
	DCSPD==0
	.ENDC
	.IFZ COMPUTER-3
	.TITLE RUG FOR SOMETHING OR OTHER
	SETF ^\1=>FIXED DISK, 0=>NONE\,F.HD
	SETF ^\1=>DM11, 0=>NONE\,DM11
	SETF ^\1=>USE FIRST KL11, 0=>USE CONSOLE TTY\,KL11
	SETF ^\1=>MOVING DISK, 0=>NONE\,M.HD
	SETF ^\1=>FAST READER, 0=>CONSOLE READER\,FPTR
	SETF ^\1=>FLOATING POINT, 0=>MONE\,FPP
	SETF ^\1=>11/45, 0=>11/20\,M1145
	SETF ^\CORE SIZE IN BYTES\,HCOR
	SETF ^\ADDRESS OF BOTTOM OF SYMBOL TABLE\,CSTBL
	SETF ^\0=>TRACK DUMP 1=>FILE DUMP\,FMH
	SETF ^\DC11 SPEED SET (0, 10 , 20 OR 30)\,DCSPD
	SETF ^\TEN/11 INTERFACE\,TEN11
	.ENDC
	.MACRO PFLAG NAME,VAL
	.PRINT /NAME'='VAL
/
	.ENDM
	PFLAG TEN11,\TEN11
	PFLAG F.HD,\F.HD
	PFLAG DM11,\DM11
	PFLAG KL11,\KL11
	PFLAG M.HD,\M.HD
	PFLAG FPTR,\FPTR
	PFLAG FPP,\FPP
	PFLAG M1145,\M1145
	PFLAG HCOR,\HCOR
	PFLAG CSTBL,\CSTBL
	PFLAG FILE DUMP,\FMH
	.ENDC

M1140==0
M40FPU==0	;11/40 FLOATING POINT UNIT OPTION

.IFZ	M1145
RUGFNT	=	HCOR-22000
.ENDC
.IFNZ	M1145
RUGFNT	=	HCOR-40000
.ENDC
;RUG SYMBOLIC DEBUGGER
;RUG NEEDS THESE DISK BLOCKS RESERVED ON THE FIXED HEAD DISK
;THE SAME BLOCKS NEEDED ON THE MOVING HEAD DISK
;0,4-23, AND 54-217


.MACR	MVAD	AAX,BBX
	BBX==<<<AAX/400>&377>/14>*20-<<<AAX/400&377>/14>*14>+<AAX/400>&377
.ENDM
.MACR	MVADD	AAX,BBX,CCX
.IFGE	AAX&17+BBX&17-14
	CCX==AAX+BBX+4
.IFF
	CCX==AAX+BBX
.ENDC
.ENDM
.MACR	MVBAD AAX,BBX		;CONVERT BLOCK NUMBER TO MOVING DISK ADDRESS
	BBX==<<2*AAX>/14*20>+<2*AAX>-<<2*AAX>/14*14>
.ENDM

R0	=	%0	; REGISTER
R1	=	%1	;  NAMING
R2	=	%2	;   CONVENTIONS
R3	=	%3
R4	=	%4
R5	=	%5
R6	=	%6
R7	=	%7
SP	=	%6
PC	=	%7
PSW	=	177776		;STATUS REGISTER

.XCREF	R0,R1,R2,R3,R4,R5,R6,R7,SP,PC

O.BPT	==	10		;NUMBER OF BREAKPOINTS
O.BKP	==	O.BPT+O.BPT-2	;NUMBER OF BREAKPOINTS-1 MULT. BY 2
O.STM	==	340		;PRIORITY MASK - STATUS REGISTER
O.TBT	==	20		;T-BIT MASK - STATUS REGISTER

.IFZ	KL11
O.RDB	=	177562	;R DATA BUFFER
O.RCSR	=	177560	;R C/SR
O.TDB	=	177566	;T DATA BUFFER
O.TCSR	=	177564	;T C/SR
.ENDC

TTP50	=	100060
.IFNZ	KL11
O.RDB	=	176502
O.RCSR	=	176500
O.TDB	=	176506
O.TCSR	=	176504
.ENDC

DAE	=	177470
DAR	=	177466	;DISC ADDRESS (WORDS)
CMA	=	177464	;CURRENT MEMORY LOC-2
WC	=	177462	;-WORDCOUNT (WORDS)
DCS	=	177460	;DISC CNTL AND STATUS

CKSM	==	%0
ADRS	==	%1
BCOUNT	==	%2
BYTE	==	%3

L.CKSM==%0
L.ADR==%1
L.BC==%2
L.BYT==%3
L.PTR==%5

L.SR=177570
L.DEV=DEVICE
;THESE ARE RUGS CRUMBLING DISK ADDRESSES

INVRG	=	4000	;WHERE 'INVIOLATE COPY OF RUG STARTS ON DISC
INVRGL	=	<HCOR-RUGFNT>/2	;LENTH OF INVIOLATE COPY OF RUG

.IFZ FMH
SPRG	=	INVRG+INVRGL	;WHERE SWAPPING PROGRAM STARTS
.IFF
SPRG	=	54000
.ENDC

SPRGL	=	<RUGST/2>&77777	;LENTH OF SWAPPING PROGRAM ON DISC
SPRGLE	=	<HCOR/2>&77777	;ROUNDED OFF LENTH JUST FOR NICENESS OF ADRESSES
SSTBL	=	SPRG+SPRGLE	;WHERE SWAPPING SYMBOL TABLE STARTS
SSTBLL	=	<<RUGST-CSTBL>/2>&77777	;LENTH OF SWAPPING SYMBOL TABLE
					;INCLUDES VOLATILE COPY OF RUG
SSTBUL	=	<RUGFNT-CSTBL>/2	;THIS IS LENGTH OF USER'S SYMBOL TABLE
SSTBLE	=	<<HCOR-CSTBL>/2>&77777	;LENTH OF SYMBOL TABLE IN ROUNDER NUMBERS
;SSTBLL IS FROM CSTBL TO
;END OF DEBUGGER SO EVERYTHING SWAPPED
TRKS	=	SSTBL+SSTBLE	;WHERE TRACKS ON FIXED HEAD DISC START
TRKL	=	SPRGLE+SSTBLE-INVRGL	;LENTH OF TRACKS

.IFNZ	F.HD	
	DSKBSZ	=	40			;DISK BLOCK SIZE
	SSTBLB	=	SSTBL+<SSTBUL&<-DSKBSZ>>;LAST BLOCK OF
.ENDC						;SYMBOL TABLE
.IFZ	F.HD
	MVAD	SPRGL,MSPRGL
	MVAD	SPRGLE,MSPGLE
	MVAD	SSTBLL,MSSTLL
	MVAD	SSTBLE,MSSTLE
	MVAD	INVRGL,MVIRGL
.IFZ FMH
	LOWAD	=	250	;LOWEST DAR OF MOVING HEAD DISK
	MVADD	LOWAD,MVIRGL,SPRG
	MVADD	SPRG,MSPGLE,SSTBL
	MVADD	SSTBL,MSSTLE,TRKS
.IFF
	MVBAD	4,LOWAD
	MVBAD	54,SPRG		;START OF CORE IMAGE
	MVBAD	144,SSTBL	;START OF SYMBOLS
	DSKBSZ	=	400	;SIZE OF MOVING DISK SECTORS
	MVAD	<SSTBUL&<-DSKBSZ>>,SSTBLB	;LAST BLOCK OF SYMBOL TABLE
	MVADD	SSTBLB,SSTBL,SSTBLB		
.ENDC
.ENDC
	MVFO2	=	SSTBUL&<DSKBSZ-1>	;HOW FAR SYMBOL TABLE EXTENDS INTO LAST BLOCK
	MVAD	TRKL,MTRKL

.IFNZ	M.HD
MTL	=	MTRKL
RKDS	=	177400
RKCS	=	177404
RKWC	=	177406
RKBA	=	177410
RKDA	=	177412
.ENDC

EOT	==	66
TTP50	=	100060
BUF3	=	1000
BUF3B	=	2000

DMCSR	=	175000
MASK	=	377
BMASK	=	777
DNTTYP	==	176	;THE NULL CHAR


.IFNZ	M1145
THHCOR	=	0	;0, 1, 2 OR 3
LHHCOR	=	160000
STACKR	=	-4
SSR0	=	177572
SSR3	=	172516
XTCR	=	TRKS
;START OF EXTRA CORE ON DISK
.XTCR	=	<XTCR_-2>&37777	;LOCATION ON DISK SHIFTED TO ADD IN 16 BIT QUANTITIES
COR	=	<<THHCOR_13.>&60000>+<<LHHCOR_-3>&17777>
.XTCRL	=	COR-<SPRGLE_-2>&67777	;LENTH OF CORE MORE THAN 28K
THXTCL	=	<.XTCR_14.>&3	;TOP HALF OF PROPERLY SHIFTER EXTRA CORE LENTH
LHXTCL	=	<.XTCR_2>
.TRKS	=	.XTCR+.XTCRL

THTRKS	=	<.TRKS_14.>&3
LHTRKS	=	.TRKS_-2
KIDR0=172300	;CAN BE REMOVED BY REPLACING WHERE THEY ARE USED ***
SIDR0=172200
UIDR0=177600
KDDR0=172320
SDDR0=172220
UDDR0=177620
KIAR0=172340
SIAR0=172240
UIAR0=177640
KDAR0=172360
SDAR0=172260
UDAR0=177660
.ENDC
;TOP AND LOW HALF OF HIGHEST CORE LOC
KILCHR=23	;OCTAL 23 IS ^S
;THESE MACROS ALLOW EASY CALLING OF MULTIPLY AND DIVIDE ROUTINES
;MLTPLY A,B,C DOES C_A*B, DIVIDE A,B,C,D DOES C_A/B AND D_REMAINDER
;MLTPLY SCRTCH,R4,SCRTCH  OR  DIVIDE SCRTCH,R4,SCRTCH,R4  ASSEMBLE NO OVERHEAD

.MACRO	MLTPLY A,B,C
.IF DIF	A,SCRTCH
	MOV	A,SCRTCH
.ENDC
.IF DIF	B,R4
	MOV B,R4
.ENDC
	JSR	PC,MULT
.IF DIF	C,SCRTCH
	MOV SCRTCH,C
.ENDC
.ENDM

.MACRO	DIVIDE A,B,C,D
.IF DIF	A,SCRTCH
	MOV	A,SCRTCH
.ENDC
.IF DIF	B,R4
	MOV	B,R4
.ENDC
	JSR	PC,DIVD0
.IF DIF	C,SCRTCH
	MOV	SCRTCH,C
.ENDC
.IF DIF	D,R4
	MOV	R4,D
.ENDC
.ENDM
;THIS IS THE SYMBOL TABLE WHICH RUG SITS ON

.=RUGFNT			;RUG'S SYMBOLS REQUIRE 56 BYTES



	BR RGO	;THIS SPECIAL "SYMBOL" MUST ALWAYS BE HERE!!
	BR LOGO
	0
	.RAD50 /%%%/
	.RAD50 /DUM/
	0
	.RAD50 /%%%/
	.RAD50 /DUM/
	0
	.RAD50 /%%%/
	.RAD50 /DUM/
	0
	.RAD50 /%%%/
	.RAD50 /DUM/
	0
	.RAD50 /%%%/
	.RAD50 /DUM/
	0
	.RAD50 /%%%/
	.RAD50 /DUM/
	0
	.RAD50 /%%%/
	.RAD50 /DUM/
	0
	.RAD50 /%%%/
	.RAD50 /DUM/
	0
	.RAD50	/.GO/
	0
ADRES:	1		;USER STARTING ADDRESS, SHOULD BE ODD AT FIRST
	.RAD50	/.B /
	0
	14
	.RAD50	/.M /
	0
	11
	.RAD50	/.P /
	0
	10
	.RAD50	/.C /
	0
	14+O.BPT
	.RAD50	/..B/
	0
O.SYME:	RUGFNT
	.RAD50	/.  /
	0
DOT:	0
	177777		;HALF KILLED SYMBOL FLAG
DOTFLG:	74
O.BSYM==.		;BEGINNING OF SYMBOL TABLE (HIGHEST ADDRESS)

RGO:	JMP O.ODT
LOGO:	JMP STLOGO

.=.+400			;THIS IS RUG'S STACK

O.UR0:	0	;USER R0
USERR0=O.UR0
	0	;     R1
	0	;     R2
	0	;     R3
	0	;     R4
	0	;     R5
USP:	0	;USER SP
UPC:	0
O.PRI:	7	;RUG PRIORITY
O.MSK:	-1	;MASK
	0	;LOW LIMIT
	160000	;HIGH LIMIT
;
; BREAK POINT LISTS, ADR1 = ADDRESS OF BREAKPOINT,CT = COUNT,
;   UIN = CONTENTS
;
O.ADR1:	
.	=	.+O.BKP+2
O.CT:	
.	=	.+O.BKP+2
O.UIN:	
.	=	.+O.BKP+2
.IFNZ	M1145
O.BPM:	;DESREG VALUE WHEN BPTS SET
.	=	.+O.BKP+2
.ENDC
;THIS IS THE MIGHTY RUG

VERN:	%FNAM2		;RUG VERSION NUMBER
O.ODT:
	MOVB	#O.STM,PSW
	MOV	#O.UR0,SP
	JMP O.DCD

BEGRUG:	MOV	#O.UR0,SP
	JSR PC,REINIT
	CLR RESTFL
	CLR INPFL
.IFNZ	F.HD
	JSR	5,FDISK
	0	;DAE
	INVRG	;DAR
	RUGFNT	;CMA
	-INVRGL	;WC
	3	;DCS
.ENDC

.IFZ	F.HD
	JSR	5,MDISK
	LOWAD
	RUGFNT
	-INVRGL
	3
.ENDC
	JSR	PC,DSTBL
	BR	O.ODT
ADR1:	0	;FIRST ADDRESS OF INSTRUCTION IN @DOT, OR DOT
ADR2:	0	;SECOND, OR FIRST, OR DOT
ADR1F:	.BYTE 0	;0, OR 1 IF ADR1 IS A REGISTER
ADR2F:	.BYTE 0	;0, OR 1 IF ADR2 IS A REGISTER
OPENF:	.BYTE 0	;NONZERO IF LOCATION @DOT IS OPEN
.EVEN
REGFLG:	0	;ONE IF DOT IS A REGISTER (OR .B, .C, .M, .P, ..B OR .)
BYTWRD:	1	;ZERO IF EXAMINING IN BYTE MODE, 1 IF WORD

;PROCESS /, OPEN A LOCATION

SLASH:	CLRB	OPENF	;CLOSE LOC IF OPEN, BUT DON'T DEPOSIT ANY ARG
	CLR	REGFLG
	TST	R2
	BEQ	SLASH3	;NO ARGUMENT TYPED
	TSTB	REGINF
	BEQ	SLASH2	;ARG NOT A REGISTER
	CMP	#43,R4
	BLT	SLAERR	;INVALID REGISTER NUMBER
	MOV	R4,DOT
	INC	REGFLG
SLASH1:	JMP	OPENW

SLAERR:	JMP	O.ERR

SLASH2:	MOV	R4,DOT
	BIT	#1,R4
	BEQ	SLASH1
	JSR	5,TYPE
	.BYTE	'/,0	;TYPE A BACKSLASH
	JMP	OPENB	;ODD LOCATION SO OPEN BYTE

SLASH3:	JSR	PC,SAVDOT	;STORE DOT IN RING BUFFER
	CMP	#GOINST,TEMPMD
	BEQ	SLASH4	;TEMP MODE IS I, SO 2ND ADDRESS IS MEANINGFUL
	CMP	#GOINST,PERMMD
	BNE	TAB1	;NOT IN I MODE, SO DO TAB
SLASH4:	MOV	ADR2,DOT	;OPEN SECOND ADDRESS
	MOVB	ADR2F,REGFLG	;LEFT BYTE ALWAYS ZERO
	JMP	TYOPEN

;PROCESS \, OPEN A BYTE

BACKSL:	CLRB	OPENF
	TST	R2
	BEQ	TYOPEN	;NO ARGUMENT TYPED
	CLR	REGFLG
	TSTB	REGINF
	BEQ	BACKS1	;NOT A REGISTER
	CMP	#43,R4
	BLT	SLAERR	;INVALID REGISTER NUMBER
	INC	REGFLG
BACKS1:	MOV	R4,DOT
	JMP	OPENB
;PROCESS CARRIAGE RETURN

CRETN:	JSR	PC,UPDATE
	JSR	PC,CLOSE
	JMP	O.DCD2

;PROCESS LINEFEED

LINEFD:	JSR	PC,CLOSE
	TST	BYTWRD
	BEQ	LINEF3
	TST 	REGFLG
	BNE	LINEF3	;A REGISTER OR .B, .C, ETC.
	CMP	#GOINST,TEMPMD
	BNE	LINEF2	;NOT IN INSTRUCTION MODE
	ADD	LENGTH,DOT
LINEF2:	INC	DOT
LINEF3:	INC	DOT
TYOPEN:	JSR	PC,CRLF
	MOV	DOT,R0	;NUMBER TO TYPE
	JSR	R5,SYMBAD
	TST	BYTWRD
	BEQ	TYOPN1	;IN BYTE MODE
	TST	REGFLG
	BNE	TYOPN2
	BIT	#1,DOT
	BNE	TYOPN1	;DOT IS ODD
TYOPN2:	JSR	R5,TYPE
	.BYTE	'/,0
	JMP	OPENW

TYOPN1:	JSR	R5,TYPE
	.BYTE	'\,0
	JMP	OPENB

;PROCESS TAB

TAB:	JSR	PC,SAVD0	;CLOSE, STORE DOT IN RING BUFFER
TAB1:	MOV	@WDINC,DOT
	CLR	REGFLG
	BR	TYOPEN

;PROCESS _ (BACKARROW)

BACKAR:	JSR	PC,SAVD0	;CLOSE, STORE DOT IN RING BUFFER
	MOV 	ADR1,DOT
	MOVB	ADR1F,REGFLG	;LEFT BYTE ALWAYS ZERO
	BR	TYOPEN

;PROCESS ^ (UPARROW)

UPARR:	JSR	PC,CLOSE
	TST	REGFLG
	BEQ	UPARR1	;DOT IS NOT A REGISTER
	TST	DOT
	BEQ	UPARR3	;DO NOT GO UP FROM R0
	BR	UPARR2

UPARR1:	SUB	BYTWRD,DOT
UPARR2:	DEC 	DOT
UPARR3:	BR	TYOPEN
;PROCESS <, RETURN TO OLD SEQUENCE OF LOCATIONS

OLDSEQ:	JSR	PC,UPDATE
	JSR	PC,CLOSE
	MOV	@RINGPT,DOT	;RESTORE DOT FROM RING BUFFER
	CMP	RINGPT,#RINGBF
	BHI	GETD1
	MOV	#RINGBF+20,RINGPT
GETD1:	SUB	#2,RINGPT
	CLR	REGFLG	;CLEARS C ALSO
	ROLB	RINGRF
	ADC	REGFLG
	TST	REGFLG
	BEQ	GETD2
	INC	RINGRF
GETD2:	JMP	TYOPEN

SAVD0:	JSR	PC,CLOSE
SAVDOT:	CMP	RINGPT,#RINGBF+20-2	;SAVE DOT AND REGFLG IN RING BUFFER
	BLO	SAVD1
	MOV	#RINGBF-2,RINGPT
SAVD1:	ADD	#2,RINGPT
	MOV	DOT,@RINGPT
	TST	REGFLG	;CLEARS C
	BEQ	SAVD2
	SEC	;DOT IS REGISTER, SO SET C
SAVD2:	RORB	RINGRF	;BIT 7 IS REGFLG FOR ENTRY @RINGPT
	RTS	PC

RINGBF:	.REPT	8	;RING BUFFER OF OPENED LOCATIONS FOR < COMMAND
	0
.ENDR
RINGPT:	RINGBF-2	;RING BUFFER POINTER
RINGRF:	0	;RIGHT BYTE IS REGISTER FLAGS FOR RING BUFFER
;CLOSE THE LOCATION @DOT

CLOSE:	TSTB	OPENF
	BEQ	CLOSE5	;NO LOCATION OPEN
	CLRB	OPENF
	TST	R2
	BEQ	CLOSE5	;NO ARGUMENT TYPED
	TST	BYTWRD
	BEQ	CLOSEB	;CLOSE BYTE
	MOV	LENTYI,R2
	TST	REGFLG
	BEQ	CLOSE2
	CLR	R2	;REGISTERS ARE ONLY 1 WORD
CLOSE2:	MOV	R2,LENGTH
	ASR	R2
	MOV	#VAL,R3
.IFZ	M1145
	MOV	WDINC,R0
CLOSE3:	MOV	(R3)+,(R0)+	;DEPOSIT WORD
.ENDC
.IFNZ	M1145
	MOV	#WDINC,R0
CLOSE3:	BIT	#1,(R0)
	BNE	OPENER	;TO GETERR, BECAUSE NXM OR SLE
	MOV	(R3)+,@(R0)+	;DEPOSIT WORD
.ENDC
	DEC	R2
	BMI	CLOSE4	;DONE DEPOSITING
	BR	CLOSE3	;DO ANOTHER WORD

CLOSEB:	MOV	DOT,R2	;CLOSE A BYTE
	BIC	#177776,R2	;GET LOW BIT
	BIC	REGFLG,R2	;EXAMINE ONLY LOW BYTE OF REGISTERS
	ADD	WDINC,R2
	MOVB	VAL,@R2	;DEPOSIT THE BYTE
CLOSE4:	TST	REGFLG
	BNE	CLOSE5	;DO NOT WRITE OUT REGISTERS
	JSR	PC,WRTWRD	;WRITE IT OUT
CLOSE5:	RTS	PC
;OPEN A BYTE OR WORD, AS DESCRIBED BY DOT AND REGFLG
;SET BYTWRD ACCORDING TO WHETHER OPENB OR OPENW WAS CALLED

OPENB:	CLR	BYTWRD
	BR	OPEN1

OPENW:	MOV	#1,BYTWRD
OPEN1:	TST	REGFLG
	BEQ	OPEN3	;NOT A REGISTER
	MOV	DOT,R4	;OPEN A REGISTER
	ASL	R4
.IFNZ M1145
	CMP	R4,#12		;R6 AND R7 ARE KEPT SEPERATLY
	BLE	OPEN0
	ADD	#USERR0,R4
	BR	OPEN.0
OPEN0:	ADD	WCHREG,R4
OPEN.0:
.IFF
	ADD	#USERR0,R4
.ENDC
	MOV	R4,WDINC
;SECOND OR THIRD WORD OF REGISTERS ARE NEVER REFERENCED, SO NO NEED TO SET UP
	BR	OPEN4	;HAVE WORDS READY

OPEN3:	MOV	DOT,R0	;SET UP GETWRD CALL
	MOV	#NXMER,4
	MOV	#340,6
	JSR	PC,GETWRD
.IFNZ	M1145
	BIT	#1,WDINC
	BEQ	OPEN4
OPENER:	JMP	GETERR	;NXM OR SLE
.ENDC
OPEN4:	INCB	OPENF
	JSR	PC,TYP3SP
	MOV	@WDINC,R0	;PICK UP WORD
OPEN5:	CLR	LENGTH
	TST	BYTWRD
	BNE	OPEN7	;NOT BYTE MODE
	TST	REGFLG
	BNE	OPEN6	;CAN'T EXAMINE LEFT BYTE OF REGISTERS
	BIT	#1,DOT
	BEQ	OPEN6
	SWAB	R0	;WANT LEFT BYTE
OPEN6:	BIC	#177400,R0	;MASK OFF LEFT BYTE
OPEN7:	MOV	R0,CURVAL
	JMP	@TEMPMD

GONUM:	JSR 	5,TYPNUM	;TYPE OUT NUMBER
	BR	GOSYM1

GOSYM:	JSR	5,SYMBL2	;PRINT AS SYMBOL EVEN IF IN $$A MODE
GOSYM1:	JSR	PC,TYP3SP
	JMP	O.DCD3	;DONE
GOINST:	TST	REGFLG	;INSTRUCTION MODE TYPEOUT
	BNE	GONUM	;NO I MODE FOR REGISTERS
	TST	BYTWRD
	BEQ	GONUM	;NOR WITH BYTE MODE
	MOV	DOT,CURADR
	MOV	DOT,ADR1
	MOV	DOT,ADR2
	CLR	ADR1F	;CLEARS REG FLAG FOR ADR2 ALSO
	JSR	PC,EXINST
	BR	GOSYM1	;OK
	MOV	CURVAL,R0	;DID NOT FIND AN INSTRUCTION
	BR	GONUM

PERMAF:	.BYTE	0	;NONZERO = TYPE ADDRS ABSOLUTE, ZERO = RELATIVE
TEMPAF:	.BYTE	0	;TEMP COPY OF PERMAF

PERMDF:	.BYTE	0	;NONZERO = TYPE NUMBERS DECIMAL, ZERO = OCTAL
TEMPDF:	.BYTE	0	;TEMP COPY OF PERMDF

PERMMD:	GOINST	;C, I, S, R50 OR ASCII TYPEOUT MODE
TEMPMD:	GOINST	;TEMP COPY OF PERMMD

UPDATE:	MOVB	PERMAF,TEMPAF	;ABSOLUTE FLAG
	MOVB	PERMDF,TEMPDF	;DECIMAL FLAG
	MOV	PERMMD,TEMPMD	;TYPEOUT MODE
	RTS	PC
SETCMD:	JSR	PC,SETMOD	;SET CONSTANTS MODE
	GONUM

SETIMD:	JSR	PC,SETMOD	;SET INSTRUCTION MODE
	GOINST

SETSMD:	JSR	PC,SETMOD	;SET SYMBOLIC MODE
	GOSYM

SETR51:	MOV	R2,R3	;SHIFT ARG SINCE NO ALT MODE
	MOV	R4,R5
SETR50:	JSR	PC,SETMOD	;SET RADIX-50 MODE
	GOR50

SETASD:	MOV	R2,R3
	MOV	R4,R5
SETASC:	JSR	PC,SETMOD	;SET ASCII MODE
	GOASC

SETMOD:	CMP	R1,#2*<N1ALC+N0ALC>+O.LGDR
	BLO	SETMD1	;ZERO OR ONE ALT MODE
	MOV	@(SP),PERMMD	;TWO ALT MODES, SET MODE PERMANENTLY
SETMD1:	MOV	@(SP)+,TEMPMD
SETMD2:	TST	R3
	BEQ	SETMD3	;NO ARGUMENT
	MOV	R5,CURVAL	;TYPE ARG IN NEW MODE
	BR	SETMD4

SETMD3:	TSTB	OPENF
	BEQ	O.DCD2	;NO LOCATION OPEN
SETMD4:	JSR	PC,TYP3SP
	MOV	CURVAL,R0
	BR	OPEN7	;RETYPE VALUE

S2ALTA:	INCB	PERMAF	;ABSOLUTE ADDRESSES
S1ALTA:	INCB	TEMPAF
	BR	SETMD2

S2ALTR:	CLRB	PERMAF	;RELATIVE ADDRESSES
S1ALTR:	CLRB	TEMPAF
	BR	SETMD2

S2ALTD:	INCB	PERMDF	;DECIMAL NUMBERS
S1ALTD:	INCB	TEMPDF
	BR	SETMD2

S2ALTO:	CLRB	PERMDF	;OCTAL NUMBERS
S1ALTO:	CLRB	TEMPDF
	BR	SETMD2

;                  <UNDEF SYM><:>   DEFINE SYM AS CURRENT LOCATION
; <EXPR><ARITH OPR><UNDEF SYM><:>   DEFINE SYM AS EXPR
; <EXPR>    <,>    <UNDEF SYM><:>   DEFINE SYM AS EXPR
; <EXPR>    <,>  <DEFINED SYM><:>   RE-DEFINE SYM AS EXPR

;EVAL GOT UNDEFINED SYMBOL
ECOLON:	CMP	#COLONE,(SP)+	;RETRIEVE CALL TO EVAL
	BEQ	COLONE	;IT WAS COLON COMMAND, SO ALREADY HAVE VALUE
	TST	R2
	BNE	COLON0
	MOV	DOT,R4
	MOV	REGFLG,REGINF
COLON0:	MOV	R4,DEFNV
	MOV	REGINF,-(SP)
	BR	COLONE

COLON:	MOV	R4,DEFNV	;PROCESS COLON COMMAND
	CMPB	#',,@PARSEP
	BNE	DCDERR	;COMMA MUST SEPARATE VALUE FROM SYMBOL
	MOV	REGINF,-(SP)
	INC	PARSEP	;PASS OVER COMMA
	JSR	PC,EVAL	;GET THE SYMBOL
COLONE:	CMP	#':,R0
	BNE	DCDERR	;COLON MUST TERMINATE SYMBOL
	TST	NOTNUM
	BEQ	DCDERR	;CANNOT DEFINE NULL OR A NUMBER
	JSR	PC,O.SYLL	;GET SYMBOL'S VALUE IN R4
	BNE	DEFN2	;FOUND
DEFN1:	SUB #6,O.SYME	;USYMB TABLE 2WDS RAD50 PLUS ONE OF VALUE
	MOV O.SYL,(R1)
	MOV O.SYL+2,2(R1)
	MOV	O.FLGS,R4
	CMP	#1,R3	;SEE IF TIME FOR NEW FLAG WORD
	BNE	DEFN2		;NO 
	CLR	(R4)
	CLR	-(R4)		;YES, INITIALIZE IT
DEFN2:	MOV	O.FLGS,R4
	MOV	#0,4(R1)
DEFNV=.-4	;VALUE DEFINED
	TST	(SP)+		;CHECK REGISTER FLAG
	BEQ	DEFN3
	BIS	R3,(R4)
	BR	DEFN4
DEFN3:	BIC	R3,(R4)
DEFN4:	BIC	R3,-(R4)
	JSR	PC,TYP3SP
	BR	O.DCD3	;HAVE TO CLRB IBUFF FOR NON-COMMA MODES

;PROCESS FOO^K, HALF KILLING DEFINED SYMBOL

HKILL:	MOV	O.FLGS,R4
	MOV	O.BIT,R3
	BEQ	DCDERR
	XOR	R3,-(R4)
	BR	O.DCD

RESART:	MOVB	#O.STM,PSW	;SET STATUS
	MOV	#O.UR0,SP	;INIT STACK
	DECB	RESTFL		;1=START RUG
	BEQ	O.DCD		;2=START TRACK 0 (LOGO)
	CLRB	RESTFL
	JMP	STLOGO		;START LOGO

;COMMAND DECODER, TOP LEVEL, MAY CLOBBER R0 - R5

O.ERR==.
DCDERR:	CLRB	TBUFF
	MOV	#TBUFF,TNPNTR
	MOV	#O.UR0,SP	;RESET STACK
	JSR	5,TYPE	;GET HERE FROM FATAL ERRORS
	.ASCIZ	/?  /
	.EVEN
	BR	O.DCD3

O.DCD:	CLRB	OPENF	;MAKE NO LOCATION OPEN
O.DCD2:	JSR	PC,CRLF	;TYPE CR, LF, STAR
	JSR	5,TYPE
	.ASCIZ	/*/
	.EVEN
O.DCD3:	CLR	SSFLAG	;SINGLE STEP MODE FLAG
	JSR	PC,INPUT	;GET A NEW COMMAND
	MOV	#IBUFF,PARSEP	;INITIALIZE PARSING POINTER
	JSR	PC,EVAL	;MAKE SOME SENSE OF INPUT
	MOV	#0,R1
SALTF==.-2	;SAVED ALTF FROM "INPUT", = 0, 1, 2
	CMP	#2,R1
	BLO	DCDERR	;TOO MANY ALTMODES
	ASL	R1
	MOV	ALTTAB(R1),R1
	DEC	SINPTR	;UNDO LAST INC
	MOVB	@#0,R0	;PICK UP COMMAND CHAR
SINPTR==.-2	;SAVED INPNTR
	CLRB	IBUFF
DCD3:	TSTB	(R1)	;SEARCH FOR COMMAND
	BEQ	DCDERR	;UNKNOWN COMMAND
	CMPB	R0,(R1)+
	BNE	DCD3	;KEEP LOOKING
	SUB	#ALT+1-<O.LGDR/2&77777>,R1
	ASL	R1
	MOV	R2,R3	;R2 SAVED IN R3, R4 IN R5 FOR 2 ALTMODE ROUTINES
	MOV	R4,R5	;THIS SHOULD BE DISCARDED ***
	JMP	@(R1)+	;DISPATCH TO PROPER ROUTINE

ALTTAB:	NOALT
	ALT
	TWOALT
;PROCESS =, TYPE ARG OR CURRENT VALUE

EQUAL:	TST	R2
	BEQ	EQUAL1	;NO ARG, USE CURVAL
	MOV	R4,CURVAL	;ARG, SET CURVAL TO IT
	TSTB	REGINF
	BEQ	EQUAL1
	JSR	5,TYPE
	.ASCIZ	/%/
	.EVEN
EQUAL1:	MOV	CURVAL,R0
	JSR	5,TYPNUM
EQUAL2:	JSR	PC,TYP3SP
	BR	O.DCD3

;PROCESS ^V, TYPE VERSION NUMBER

VERS:	JSR	R5,TYPE
	.ASCIZ	/ RUG /
	.EVEN
	MOV	VERN,R0
	JSR	R5,TYPDEC
.IFNZ	M1145
	MOV	#43106,R0	;ASCII F F
	BIT	#1,SVSSR0
	BEQ	VERS1
	MOV	#47040,R0	;ASCII N SPACE
VERS1:	MOV	R0,SONOFF
	JSR	5,TYPE
MODE:	.ASCII	\P0 SEG O\
SONOFF:	.ASCII	\FF\
	0
.ENDC
	BR	EQUAL2
ERROR:	BR	O.ERR

;PROCESS ], PRINT CURRENT VALUE AS RADIX-50

GOR50:	MOV	R0,AINST
	CLR	AINST+2
	JSR	5,TYPE
	.BYTE	'&
	.BYTE	'/
	.BYTE	0
	.EVEN
	MOVB	#40,BLANK
	JSR	R5,TYP50A
GOR50A:	JSR	5,TYPE
	.BYTE	'/
	.BYTE	0
	JMP	GOSYM1

;PROCESS [, PRINT CURRENT VALUE AS ASCII

GOASC:	BIS	#100200,R0	;SO DON'T HAVE ZEROS
	MOV	R0,GOASCI
	JSR	5,TYPE
	.BYTE	'"
	.BYTE	'/
GOASCI:	0
	.BYTE	0
	.EVEN
	BR	GOR50A

;SINGLE STEP MODE PROCESSOR
SSTP:	TSTB	O.P
	BLT	ERROR	;ILLEGAL TO PROCEED
	MOV	R2,R3
	MOV	R4,R5
	CLR	R2
SSTEP:	TST	R3
	BGT	SSTP1
	MOV	#1,R5	;ASSUME SINGLE STEP
SSTP1:	TST	R5
	BEQ	ERROR	;ZERO STEPS?
	CLR	R3
	MOVB	O.P,#0
PP=.-2
	MOV	R5,COUNT
	INC	SSFLAG
	JMP	PR1
;B HANDLER - SET AND REMOVE BREAKPOINTS

O.BKPT:	MOV	#-1,R0
	TST	R3
	BEQ	O.ERR1	;FOR NOW THAT COMMAND IS MEANINGLESS
	ASR	R5		;GET ONE BIT TO CARRY
	BCS	O.ERR1		;BADNESS IF ODD ADDRESS
	ASL	R5		;RESTORE ONE BIT
	JSR	PC,DELT1	;R3 IS NOT 0 
;THIS IS SO NO TWO BPTS ON SAME ADDRESS PROBABLY A LOSS
	MOV	#O.ADR1,R4
O.SET:	CMP	R0,(R4)+		;IS THIS CELL FREE?
	BEQ	O.SET1		;JUMP IF YES
	CMP	R4,#O.BKP+O.ADR1+2	;ARE WE AT THE END OF OUR ROPE
	BLO	O.SET

O.SET1:	MOV	R5,-(R4)		;SET BREAKPOINT
.IFNZ	M1145
	MOV	MODE,O.BPM-O.ADR1(R4)	;SAVE MAP STATE
	CMPB	#'P,MODE
	BEQ	O.DCDB
	MOVB	#'I,O.BPM+1-O.ADR1(R4)	;SET MAP TO I SPACE
.ENDC
O.DCDB:	JMP	O.DCD		;RETURN

;$$B HANDLER DELETE BKPT AT 1500 BY 1500$$B, $$B REMOVES ALL
DELT:	CLR	R3
DELT1:	MOV	#-1,R0
	MOV	#O.BKP+2,R4
DBLOOP:	TST	R3			;IF R3 ZERO, DELETE ALL
	BEQ	NOTST
	CMP	R5,O.ADR1-2(R4)
	BNE	DB1			;ONLY REMOVE BKPT AT THAT ADDRESS
NOTST:	MOV	R0,O.ADR1-2(R4)
	MOV	#BPT,O.UIN-2(R4)	;RESET CONTENTS OF TABLE
	CLR	O.CT-2(R4)		;CLEAR COUNT
DB1:	DEC	R4
.IFNZ M1145+M1140
	SOB	R4,DBLOOP
.IFF
	DEC	R4
	BGT	DBLOOP
.ENDC

DELDON:	RTS	PC
DELTB:	JSR	PC,DELT1
	BR	O.DCDB
O.ERR1:	JMP	O.ERR

; SEARCHES - $MSK   HAS THE MASK
;		$MSK+2 HAS THE FWA
;		$MSK+4 HAS THE LWA

NOTWDS:	MOV	#-1,EFFSR
	BR	O.WDS
O.EFF:	MOV	#1,EFFSR
	BR	O.WDS
O.WSCH:	CLR	EFFSR		;SET WORD SEARCH
O.WDS:	CLR	REGFLG
	TST	R3		;CHECK FOR OBJECT FOUND
	BEQ	O.ERR1		;ERROR IF NO OBJECT
	MOV	#1,BYTWRD	;SET WORD MODE
	MOV	O.MSK+2,R2	;SET ORIGIN
	MOV	R2,DISP
	BIC	#CSTBL-1,DISP
	SUB	DISP,R2
	JSR	PC,INP1
	MOV	O.MSK,R4	;SET MASK
	COM	R4
O.WDS2:	CMP	R2,#CSTBL
	BLO	CS1
	JSR	PC,INP
CS1:	MOV	R2,R0
	ADD	DISP,R0
	CMP	R0,O.MSK+4	;IS THE SEARCH ALL DONE?
	BHI	INSB		;YES
	MOV	@R2,R0		;GET OBJECT
	TST	EFFSR		;NO
	BGT	O.EFF1		;BRANCH IF EFFECTIVE SEARCH
	MOV	R0,-(SP)
	MOV	R5,R3		;EXCLUSIVE OR
	BIC	R5,R0		; IS DONE
	BIC	(SP)+,R3		;  IN A VERY
	BIS	R0,R3		;    FANCY MANNER HERE
	BIC	R4,R3		;AND RESULT WITH MASK
	BNE	WRD1
	TST	EFFSR
	BNE	O.WDS4
	BR	O.WDS3
WRD1:	TST	EFFSR
	BEQ	O.WDS4
O.WDS3:	MOV	R4,-(SP)	;REGISTERS R2,R4, AND R5 ARE SAFE
	MOV	R2,-(SP)
	JSR	PC,CRLF
	MOV	R2,R0		;GET READY TO TYPE
	ADD	DISP,R0
	JSR	5,SYMBAD	;  TYPE ADDRESS
	JSR	R5,TYPE
	.BYTE	'/,0
	JSR	PC,TYP3SP
	MOV	(SP),R2
	MOV	@R2,R0		;GET CONTENTS
	JSR	5,TYPNUM	;TYPE CONTENTS
	MOV	(SP)+,R2
	MOV	(SP)+,R4	; RESTORE R4
O.WDS4:	TSTB	O.RCSR
	BMI	O.ERR1
	TST	(R2)+		;INCREMENT TO NEXT CELL AND
	BR	O.WDS2		;    RETURN
O.EFF1:	CMP	R0,R5		; IS (X)=K?
	BEQ	O.WDS3		;TYPE IF EQUAL
	MOV	R0,R3		;(X) TO R3
	ADD	R2,R3		;(X)+X
	INC	R3
	INC	R3		;(X)+X+2
	CMP	R3,R5		;IS (X)+X+2=K?
	BEQ	O.WDS3		;BRANCH IF EQUAL
	TST	R0
	BEQ	O.WDS4	;NOT A BRANCH INST
	BIT	#70000,R0
	BNE	O.WDS4	;ALSO NOT A BRANCH INST
	MOVB	R0,R0
	INC	R0
	ASL	R0
	ADD	R2,R0		;ADD PC
	ADD	DISP,R0
	CMP	R0,R5		;IS THE RESULT A PROPER REL. BRANCH?
	BNE	O.WDS4
	BR	O.WDS3

INSB:	JMP	O.DCD
EFFSR:	0
DISP:	0


INP:	CLR	R2
	ADD	#CSTBL,DISP
INP1:	MOV	DISP,R0
	CLC
	ROR	R0
.IFZ	F.HD
	MOV	R0,MDSAV
	JSR	PC,MDCNVT
	MOV	#SPRG,MDSAV+2
	JSR	PC,MDADD
	MOV	MDSAV,INPDAR
.ENDC
.IFNZ F.HD
	ADD	#SPRG,R0
	MOV	R0,INPDAR
	JSR	5,FDISK
	0	;DAE
.ENDC
.IFZ	F.HD
	JSR	5,MDISK
.ENDC
INPDAR:	0
	0	;CMA
	-CSTBL/2	;WC
	5	;DCS
	RTS	PC

NXMER:
	.IFNZ M1145
	BIT #1,SSR0
	BEQ NXMER1
	JSR PC,SEGRES	;RESTORE SEG REGISTERS IF SEG WAS ENABLED
	.ENDC
NXMER1:	MOV	#O.UR0,R6
	JSR	R5,TYPE
	.ASCIZ	/NXM/
	.EVEN
	JMP	O.ERR
; PROCESS G, START UP USER'S PROGRAM

O.GO:	TST	R3		;WAS ARGUMENT TYPED?
	BNE	GO2
GO22:	MOV	ADRES,R5
GO2:	ASR	R5		;CHECK LOW ORDER BIT
	BCS	.ERR1		;ERROR IF ODD NUMBER
	ASL	R5		;RESTORE WORD
	MOV	R5,UPC		;SET UP NEW PC
;NOW PUT THE BPT VECTOR INTO USER'S CORE
.IFNZ	M1145
	MOV	MODE,#0
SAVMOD=.-2
	MOV	#"KI,R0
	JSR	PC,CHMODE	;CHANGE TO KERNAL MODE
.ENDC
	MOV	#14,R0		;BPT VECTOR LOCATION
	JSR	PC,GETWRD
.IFZ	M1145
	MOV	WDINC,R1
	MOV	#O.BRK,(R1)+
	MOV	#O.STM,(R1)
.IFF
	MOV	#WDINC,R1
	MOV	#O.BRK,@(R1)+
	MOV	#O.STM,@(R1)+	;+ 2ND TIME TO SAVE WORD IN ADRESS MODE
.ENDC
	JSR	PC,WRTWRD
.IFNZ M1145
	MOV	SAVMOD,R0
	JSR	PC,CHMODE
.ENDC
GO1:	BIC	#O.TBT,O.UST	;BOTH T-BIT FLAGS
	JSR	5,O.RSB		;RESTORE BREAKPOINTS
O.GO2:	MOVB	#-1,O.P		;CLEAR PROCEED
	MOVB	#O.STM,PSW	;SET HIGH PRIORITY
	JSR	5,O.RSTT	;RESTORE TELETYPE
.IFNZ	M1145
	MOV	MODE,#0
SAVMOD=.-2
	MOV	#"KI,R0
	JSR	PC,CHMODE	;CHANGE TO KERNAL MODE
.ENDC
	SUB	#4,USP		;LIKE PUSHING TWO THINGS ON STACK
	MOV	USP,R0
.IFNZ M1145
	MOV	R0,SAVKR6
	MOV	#KIDR0+20,DESREG	;SO PUSH GOES INTO DATA SPACE
.ENDC
	JSR	PC,GETWRD
.IFZ	M1145
	MOV	WDINC,R1
	MOV	UPC,(R1)+
	MOV	O.UST,(R1)
.IFF
	MOV	#WDINC,R1
	MOV	UPC,@(R1)+
	MOV	O.UST,@(R1)+
.ENDC
	JSR	PC,WRTWRD
.IFNZ	DM11
	JSR	PC,DM1LOS
.ENDC
	MOV	#O.UR0,SP
	MOV	(SP)+,SAVR0
	MOV	(SP)+,SAVR1
.IFNZ	F.HD
	MOV	#DCS,R1
.IFF
	MOV	#RKCS,R1
.ENDC
	MOV	#SAVDCS,R0
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	MOV	(SP)+,R5
.IFNZ	M1145
	MOV	#KIDR0,DESREG	;RESTORE TO KI
	MOV	SAVSR6,-(SP)	;RESTORE SUPERVISOR R6
	BIS	#10000,PSW	;SET PREV MODE TO SUP
	MTPI	R6
	MOV	SAVUR6,-(SP)
	BIS	#30000,PSW	;SET MODE TO USER
	MTPI	R6
	MOV	#ALTR0,SP
	BIS	#4000,PSW	;CHANGE TO REGISTER SET 1
	MOV	(SP)+,R0
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R4
	MOV	(SP)+,R5
	BIC	#4000,PSW	;CHANGE BACK
	MOV	#USP,SP
.ENDC
	JSR	PC,DSTBL
.IFNZ	F.HD
	CLR	CMA
	CLR	DAE
	MOV	#SPRG,DAR
	MOV	#-SPRGL,WC
.IFF
	CLR	RKBA
	MOV	#SPRG,RKDA
	MOV	#-SPRGL,RKWC
.ENDC
	MOV	(SP),SP
	MOV	#4,(R1)
	JMP	GOGO


; PROCESS P - PROCEED (ONLY ALLOWED AFTER A BREAKPOINT)

.ERR1:	JMP	O.ERR
O.PROC:	MOVB	O.P,R0
	TSTB	R0		;CHECK LEGALITY OF PROCEED
	BLT	.ERR1		;NOT LEGAL
	TST	R3		;WAS COUNT SPECIFIED?
	BNE	PR.0		;NO
	MOV	#1,R5
PR.0:	MOV	R5,O.CT(R0)	;YES, PUT AWAY COUNT
PR0:	INCB	O.T		;SET RESTART TBIT

PR1:	BIS	#O.TBT,O.UST	;SET T-BIT
	BR	O.GO2


O.TBIT:	DEC	COUNT
	BLE	SSDN	;DONE SINGLE STEPPING
O.TBI1:	BIT	#4000,O.RCSR	;IS CHAR COMING IN?
	BNE	O.TBI1
	TSTB	O.RCSR	;TEST FOR KILCHR DURING MULTIPLE 
	BPL	PR1
	CMPB	#KILCHR,O.RDB
	BNE	PR1
SSDN:	MOVB	PP,O.P
	MOV	UPC,R5
	MOV	R5,DOT
	MOV	#"SS,BBMES
	BR	BB

; BREAKPOINT HANDLER
; A TRT BREAKPOINT CAUSES O.BRK TO BE ENTERED,
; WHICH SAVES VARIOUS ODDS AND ENDS, FINDS OUT
; IF THE BREAKPOINT WAS LEGAL, AND GIVES CONTROL
; TO THE COMMAND DECODER.

BREAK:	MOVB	#O.STM,PSW
	MOV	#UPC,SP
	MOV	O.UPC,(SP)
	MOV	O.USP,-(SP)
.IFNZ	M1145
	MOV	(SP),SAVKR6	;KERNEL MODE STACK POINTER
.ENDC
	MOV	R5,-(SP)
	MOV	R4,-(SP)
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	SAVR1,-(SP)
	MOV	SAVR0,-(SP)
.IFNZ	M1145
	BIS	#10000,PSW	;SET TO SUP MODE
	MFPI	R6
	MOV	(SP)+,SAVSR6
	BIS	#30000,PSW	;PREVIOUS MODE USER MODE
	MFPI	R6
	MOV	(SP)+,SAVUR6
	MOV	@R6AD,USP	;SET CORRECT P STACK VALUE
	MOV	#ALTR0,SP
	BIS	#4000,PSW	;SAVE REGISTER SET 1
	MOV	R0,(SP)+
	MOV	R1,(SP)+
	MOV	R2,(SP)+
	MOV	R3,(SP)+
	MOV	R4,(SP)+
	MOV	R5,(SP)+
	BIC	#4000,PSW
	MOV	#O.UR0,SP
.ENDC

	JSR	5,O.SVTT	;SAVE TTY
.IFNZ M1145
	MOV	SAVMOD,R0
	JSR	PC,CHMODE	;RESET MODE
.ENDC
	TSTB	RESTFL
	BEQ	BRK1
	DECB	RESTFL
	BEQ	BREK.1
	CLRB	RESTFL
	JMP	STLOGO		;START LOGO
BREK.1:	CLRB	O.T
	CLRB	SSFLAG
	JSR	R5,O.REM
	JMP	O.DCD
BRK1:	TSTB	SSFLAG		;CHECK FOR T-BIT SET BY ^N
	BNE	O.TBIT		;JUMP IF SET
	TSTB	O.T		;CHECK FOR T-BIT SET BY $P
	BEQ	O.BK2
	CLRB	O.T
	JMP	GO1		;CONTINUE USER PROGRAM
;RUG USED TO SWAP OUT HIGH CORE HERE
O.BK2:	JSR	5,O.REM		;REMOVE BREAKPOINTS
O.BK3:	MOV	UPC,R5	;GET PC, IT POINTS TO THE TRT
	SUB	#2,R5	;CAN'T TST -(R5) BECAUSE COULD BE RANDOM
	MOV	#O.BKP,R4	;GET A COUNTER
O.B1:	CMP	R5,O.ADR1(R4)	;COMPARE WITH LIST
	BEQ	O.B2		;JUMP IF FOUND
	SUB	#2,R4	;CAN'T TEST. IT GETS NEG
	BGE	O.B1	;RE-LOOP UNTIL FOUND
BADEN:	MOV	#"BE,BBMES
	CLRB	O.P	;TO ALLOW RESTART AFTER BAD ENTRY
BB:	MOV	R5,R0
	BIC	#O.TBT,O.UST	;CLEAR OUT ANY POSSIBLE FAKE T-BIT
	JSR 	PC,CRLF
	JSR	5,TYPE
BBMES:	.ASCIZ	/BE;/
	.EVEN
	BR	O.B3		; OR CONTINUE

O.B2:
.IFNZ	M1145
	MOV	O.BPM(R4),R0	;RESTORE MODE OF BREAKPOINT
	JSR	PC,CHMODE
.ENDC

	MOV	R5,UPC	;WANT DECREMENTED PC
	MOVB	R4,O.P	;ALLOW PROCEED
	DEC	O.CT(R4)
	BLE	O.B5
	JMP	PR0

O.B5:	MOV	#1,O.CT(R4)	;RESET COUNT TO 1
	MOVB	R4,R0
	ADD	#140,R0
	ASR	R0
	MOVB	R0,BPTNM
	JSR	PC,CRLF
	JSR	5,TYPE
BPTNM==.+1
	.ASCIZ	/B ;/
	.EVEN
	MOV	#1,BYTWRD		;SET WORD MODE
	MOVB	O.P,R4
	MOV	O.ADR1(R4),R0	;GET ADDRESS OF BREAK
O.B3:	MOV	R0,CURADR
	JSR	PC,GETWRD
	MOV	CURADR,R0	;ARG FOR SYMBOL IN R0
	JSR	5,SYMBOL	;LOOK UP SYMBOL, TYPE IT AND ANY OFFSET
	JSR	5,TYPE
	.ASCIZ	/>/
	.EVEN
	CLR	LENGTH
	MOV	@WDINC,R0
	JSR	PC,EXINST
	BR	O.B4
	JMP	O.ERR		;NO INSTUCTION FOUND
O.B4:	JMP	O.DCD		;GO TO DECODER


.IFNZ	DM11
DM1LOS:	MOV	#TTP50,O.SYL
	CLR	O.SYL+2
	JSR	PC,O.SYLL
	BEQ	DMLO.1
DMLOSS:	MOV	DMCSR+6,R3
	ADD	#200,R3
	MOV	R4,R0
	JSR	PC,GETWRD
	MOV	R3,@WDINC
	JSR	PC,WRTWRD
DMLO.1:	RTS	PC
.ENDC
.IFZ	M1145

;GET WORDS FROM DISK AROUND LOCATION IN R0

GETWRD:	CMP	R0,#RUGST		;READ WHAT IN CORE IF THAT HIGH
	BLO	GTWRD1
	MOV	#GWTBL,R1		;THINGS IN THIS TABLE
GW2:	TST	(R1)			;ARE STORED BY RUG
	BEQ	GW1
	CMP	R0,(R1)+
	BNE	GW2
	ADD	#GWTBL2-GWTBL-2,R1	;POINT TO SAVE AREA AND R1 INCREMENTED EXTRA
	MOV	@R1,R0
GW1:	MOV	#BUF3,WDINC
	MOV	(R0),BUF3		;PUT THREE WORDS WHERE THE USER CAN GET THEM
	CLR	BUF3+2
	CLR	BUF3+4
	MOV	#1,IOREG		;SET SWITCH
	MOV	R0,ADRSG
	RTS	PC
GTWRD1:	CLR	IOREG			;SET SWITCH
	CLC
	ROR	R0			;WORD ADDRESS
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R0,R1
	BIC	#MASK,R1		;GET NEAREST BLOCK BOUNDARY
	MOV	R0,R2
	SUB	R1,R2			;OFFSET FROM BLOCK BOUNDARY
	ASL	R2
	ADD	#BUF3,R2		;IT SHOULD BE HERE SOON
	MOV	R2,WDINC
	ADD	#3,R0
	CMP	R0,#HCOR/2-1		;WILL THERE BE NXM IF 3 WDS?
	BLO	GTWRD2
	MOV	#HCOR/2-1,R0
GTWRD2:
.IFNZ	F.HD
	MOV	R1,ADRSG
	ADD	#SPRG,ADRSG		;DISK ADDRESS TO START TRANSFER FROM
.ENDC
.IFZ	F.HD
	MOV	R1,MDSAV
	JSR	PC,MDCNVT
	MOV	#SPRG,MDSAV+2
	JSR	PC,MDADD
	MOV	MDSAV,ADRSG
.ENDC
	SUB	R0,R1			;NEGATIVE OFFSET FROM BLOCK BOUNDARY TO END
	BIC	#MASK,R1		;OF 3 WORDS (UNROUNDED WC)
	MOV	R1,WDCNT
	MOV	#5,GWFUN
	MOV	(SP)+,R2
	MOV	(SP)+,R1
GWDSK:
.IFNZ	F.HD
	JSR	5,FDISK
	0	;DAE
.ENDC
.IFZ	F.HD
	JSR	5,MDISK
.ENDC
ADRSG:	0	;DAR
	BUF3	;CMA
WDCNT:	0	;WC
GWFUN:	0	;DCS
STH4:	RTS	PC

WDINC:	0	;POINTER TO WORD IN CORE (11/45 NEEDS THREE SUCH)

WRTWRD:	TST	IOREG
	BEQ	WRTW1
	CLR	IOREG
	MOV	BUF3,@ADRSG
	RTS	PC
WRTW1:	MOV	#3,GWFUN
	BR	GWDSK
.ENDC


ZZERO:	CLR	0
.IFNZ	F.HD
	JSR	5,FDISK
	400	;DAE
.ENDC
.IFZ	F.HD
	JSR	5,MDISK
.ENDC
	SPRG	;DAR
	0	;CMA
	-SPRGL	;WC
.IFNZ	F.HD
	3	;DCS
.ENDC
.IFZ	F.HD
	4003	;RKCS WITH INC INHIBIT ON
.ENDC
	RTS	PC


ZEROAL:	MOV	#RUGFNT,O.SYME
ZERO:	JSR	PC,ZZERO
	JMP	O.DCD


IOREG:	0
GWTBL:	PSW	;TABLE OF I/O REGISTERS SAVED IN RUG
.IFNZ	DM11
	DMCSR
.ENDC
.IFNZ	M1145
	STACKR
	SSR0
	SSR3
.ENDC
.IFNZ	F.HD
	DCS
	WC
	CMA
	DAR
	DAE
.ENDC
.IFZ	F.HD
	RKCS
	RKWC
	RKBA
	RKDA
.ENDC
	0

GWTBL2:	O.UST	;AND WHERE THEY'RE SAVED
.IFNZ	DM11
	SAVDM
.ENDC
.IFNZ	M1145
	SAVSLR
	SVSSR0
	SVSSR3
.ENDC
	SAVDCS
	SAVWC
	SAVCMA
	SAVDAR
.IFNZ	F.HD
	SAVDAE
.ENDC
.IFNZ	M1145
;THIS ROUTINE GETS A VIRTUAL ADDRESS IN R0 AND RETURNS
;A PHSICAL ADDRESS IN R2 AND R3. R1 IS FLAG. <=0 IS OK IF NOT-NXM

CNVVP:	CLR	SEGLE
	MOV	R0,-(SP)
	MOV	DESREG,R3
	BEQ	PHYSMOD
	BIT	#1,SVSSR0	;BIT IN SSR0 PREDOMINATES OVER NON-PHYS MODE SELECTION
	BEQ	SEGOFF
	MOV	R0,R1
	ASH	#-12.,R1	;ASF*2
	BIC	#177761,R1
	ADD	R3,R1		;NOW CHECK IF D SPACE IS DISABLED
	BIT	#20,R3		;IS IT IN D SPACE?
	BEQ	CNVV.1
	ASH	#-6,R3
	INC	R3
	BIC	#177771,R3
	CMP	R3,#4
	BLE	CNVV.0
	MOV	#1,R3		;R3 IS MASK TO TEST SRR3
CNVV.0:	BIT	R3,SVSSR3	;IS D SPACE DISABLED
	BNE	CNVV.1
	SUB	#20,R1		;NOW R1 HAS PROPER DESCRIPTOR REG
CNVV.1:	MOV	40(R1),R3	;R3 HAS SAR
	CLR R2
	ASHC	#6,R2	;NOW SAF LINED UP WITH BLOCK NUMBER
;MAY NEED TO MASK OFF TOP BITS AFTER ASHC ***
	BIC	#160000,R0	;TOP 3 BITS ONLY FOR WHICH SEGREG
	ADD	R0,R3
	ADC	R2	;BLOCK # RIGHT JUSTIF. ADC CLEARS CARRY
	ASH	#-6,R0
	MOV	(R1),R1	;HAS CONTENTS OF DESCRIPTOR REG
	SWAB	R1
	BIT	#4000,R1
	BNE	DWNBLK
	BIC	#177600,R1
	CMP	R0,R1
	BGT	SLE
HAVPA:	CLR	R1
	CMP R2,#3	;IS IT AN I/O REG?
	BNE HAVPA1	;NO
	CMP R3,#160000	;MAYBE
	BHIS HAVPA2	;YES
HAVPA1:	TST R2	;ARE WE IN RUG'S CORE
	BNE HAVPAR	;NOPE
	CMP R3,#160000	;ABOVE RUG?
	BHIS HAVPAR
	CMP R3,#RUGST	;MAYBE
	BLO HAVPAR	;NO, INDICATE THAT IT IS REAL CORE, NOT ON DISK
HAVPA2:	COM	R1	;MEANING IO REG OR RESIDENT PORTION OF RUG
HAVPAR:	MOV	(SP)+,R0
	RTS	PC
DWNBLK:	BIC	#177600,R1
	CMP	R0,R1
	BGE	HAVPA
SLE:	INC	(PC)+
SEGLE:	0	;NONZERO = SEG LENGTH ERROR
;FALL INTO NXM
NXM:	INC	R1	;NOW R1 HAS TO BE POSITIVE
	BR	HAVPAR
PHYSMOD:	MOV	R0,R3
	MOV	THPHYM,R2
	BR	HAVPA
SEGOFF:	MOV R0,R3
	CLR R2	;WITH SEGMENTATION OFF, ALL ADDRESS ARE IN THE LOWER 28K
	CMP R3,#160000	;UNLESS THEY ARE I/O REGISTERS
	BLO HAVPA
	MOV #3,R2	;IN WHICH CASE THEY ARE IN THE TOP 4K
	BR HAVPA

DESREG:	0	;ADDRESS OF DESCRIPTOR REG 0 OF THAT MODE
;OR CONTAINS 0 IF IN PHYSICAL MODE
SVSTSG:	MOV R0,-(SP)
	MOV #172300,R0	;POINTER TO SEGMENTATION REGISTERS
	MOV #SEGSAV,R1	;PLACE TO SAVE THEM
	MOV #40,R4	;HOW MANY TO SAVE
SVSTS0:	MOV (R0)+,(R1)+
	SOB R4,SVSTS0
	MOV #172300,R0	;NOW SET THEM UP
	CLR R1
	MOV #10,R4	;4 AT A TIME
SVSTS1:	MOV R1,60(R0)	;PAR
	MOV R1,40(R0)	;PAR
	MOV #77606,20(R0)	;PDR
	MOV #77606,(R0)+	;PDR
	ADD #200,R1
	SOB R4,SVSTS1
	MOV R2,172342
	MOV R2,172362
	MOV #7600,172356
	MOV #7600,172376
	BIS #1,SSR0	;TURN ON SEGMENTATION
	MOV (SP)+,R0
	RTS PC

SEGRES:	MOV R0,-(SP)	;RESTORE SEGMENTATION REGISTERS
	BIC #1,SSR0	;DISABLE SEGMENTATION
	MOV #172300,R0
	MOV #SEGSAV,R1
	MOV #40,R4
SEGRE1:	MOV (R1)+,(R0)+
	SOB R4,SEGRE1
	MOV (SP)+,R0
	RTS PC
SEGSAV:	.BLKW 40

GHCOR:	MOV R3,-(SP)
	ASHC #-6,R2
	MOV R3,R2
	JSR PC,SVSTSG
	MOV (SP)+,R3
	BIC #177700,R3
	ADD #20000,R3
	MOV R2,IOREG
	MOV R3,GADAR
	MOV #BUF3,R2
	MOV #3,R1
	MOV #WDINC,R0
	MOV 4,-(SP)
	MOV #GHCRNX,4
GHCOR1:	MOV R2,(R0)+
	MOV (R3)+,(R2)+
	SOB R1,GHCOR1
	MOV (SP)+,4
	JSR PC,SEGRES
	JMP GDONE2
GHCRNX:	INC -2(R0)			;MAKE IT ODD
WRHCNX:	RTI				;AND IGNORE IT

GETWRD:	BIC	#1,R0			;SET TO WORD BOUNDARY
	MOV	R0,VADR			;VIRTUAL ADDRESS
	CLR	IOREG
	CLR	TWOFLG
	MOV	R1,-(SP)
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	R4,-(SP)
	JSR	PC,CNVVP		;PHYSICAL ADDRESS IN R2,R3
	TST	R1
	BLT	GETCOR			;ITS AN I/O REGISTER
	BEQ	GTDSK			;ITS LEGAL CORE
	TST	SEGLE
	BEQ	NX
	JMP	SLERR			;NOT ALLOWED TO HAVE ERRORS ON FIRST WORD
NX:	JMP	NXMER

GETCOR:	INC	IOREG			;IT'S AN I/O REGISTER
	MOV	#GWTBL,R1
GW2:	TST	@R1
	BEQ	GW1
	CMP	R0,(R1)+
	BNE	GW2
	ADD	#GWTBL2-GWTBL-2,R1
	MOV	@R1,R3			;POINT TO SAVE AREA
GW1:	MOV	#WDINC,R1
	MOV	#3,R0
GW3:	MOV	R3,(R1)+
	ADD	#2,R3
	SOB	R0,GW3
	BR	GDONE2

;GET THREE WORDS FROM DISK OR WHEREEVER
GTDSK:	TST	R2
	BNE	GHCOR			;JUST LOOK IN CORE
	CMP	R3,#160000
	BHIS	GHCOR			;JUST LOOK AT CORE
	MOV	#3,R1
	JSR	PC,GDSK			;TURN VADR INTO DISK ADDRESS
	MOV	ADAR,GADAR
.IFNZ	F.HD
	MOV	ADAE,GADAE
.ENDC
	MOV	AWDCNT,GWDCNT		;SAVE THE COMPUTED DISK REGISTERS
	MOV	#BUF3,WDINC
	ADD	AWDINC,WDINC		;NOW POINTS INTO BUFFER
GDLOP:	DEC	R1
	BEQ	NODIF			;ALL THREE WORDS IN ONE TRANSFER
	JSR	PC,GDSK			;DO VADR+2 OR VADR+4 (IF SECOND TIME THROUGH)
	BLT	NXMER2			;VADR+2 OR VADR+4 IS NXM
	CMP	GADAR,ADAR
.IFZ	F.HD
	BEQ	GDLOP			;SAME TRANSFER AS PREVIOUS
.ENDC
.IFNZ	F.HD
	BNE	TWOGET			;TWO TRANSFERS NECESSARY
	CMP	GADAE,ADAE
	BEQ	GDLOP			;SAME AS PREVIOUS TRANSFER
.ENDC
TWOGET:	INC	TWOFLG
	DEC	R1
	BEQ	LASTD			;ONLY ONE WORD TO GO
	MOV	#BUF3B,R1		;TWO WORDS ON NEXT DISK SECTOR
	ADD	AWDINC,R1
	MOV	R1,WDINC+2		;VADR+2 AND VADR+4 IN OTHER BUFFER
	TST	(R1)+
	BR	LASTD2			;NOW STORE THE DISK TRANSFER INFO

NODIF:	MOV	WDINC,R1		;ALL 3 WORDS ARE TOGETHER
	TST	(R1)+
	MOV	R1,WDINC+2		;POINTS TO SECOND WORD
	TST	(R1)+
	MOV	R1,WDINC+4		;TO THIRD WORD
	BR	GDONE1			;FIDDLE THE DISK

LASTD:	MOV	WDINC,R1		;ONLY VADR+4 IN SECOND BUFFER
	TST	(R1)+
	MOV	R1,WDINC+2		;VADR+2 IN FIRST BUFFER
	MOV	#BUF3B,R1
	ADD	AWDINC,R1		;VADR+4 IN SECOND BUFFER
LASTD2:	MOV	R1,WDINC+4
	MOV	ADAR,GADAR2		;INFO FOR SECOND TRANSFER
.IFNZ	F.HD
	MOV	ADAE,GADAE2
.ENDC
	MOV	AWDCNT,GWDCN2
GDONE1:	MOV	#5,R1
	JSR	PC,GDISK		;DO THE TRANSFER(S)
GDONE2:	MOV	(SP)+,R4
	MOV	(SP)+,R2
	MOV	(SP)+,R3
	MOV	(SP)+,R1
	RTS	PC

WRTWRD:	MOV	IOREG,R2
	BEQ	WRTW1
	CLR	IOREG
	CMP	#1,R2			;IS JUST AN I/O REGISTER?
	BEQ	WRTW2			;YES, DONE
	JSR	PC,SVSTSG
	MOV	GADAR,R3
	MOV	#BUF3,R2
	MOV	4,-(SP)
	MOV	#WRHCNX,4
	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+
	MOV	(R2)+,(R3)+
	MOV	(SP)+,4
	JSR	PC,SEGRES
WRTW2:	RTS	PC
WRTW1:	MOV	#3,R1			;FALL INTO GDISK

GDISK:	MOV	R1,GFUN
	JSR	PC,GDSK1
	TST	TWOFLG
	BEQ	GDSKD
	MOV	R1,GFUN2
GDSK2:
.IFNZ	F.HD
	JSR	5,FDISK
GADAE2:	0
.ENDC
.IFZ	F.HD
	JSR	5,MDISK
.ENDC
GADAR2:	0
	BUF3B
GWDCN2:	0
GFUN2:	0
GDSKD:	RTS	PC

GDSK1:
.IFNZ	F.HD
	JSR	5,FDISK
GADAE:	0
.ENDC
.IFZ	F.HD
	JSR	5,MDISK
.ENDC
GADAR:	0
	BUF3	;CMA
GWDCNT:	0
GFUN:	0
	RTS	PC
NXMER2:	NEG	R1
	ASL	R1
	MOV	#1,WDINC(R1)		;INDICATE NXM
	MOV	#1,WDINC+2(R1)		;CAN'T HAVE THIS EITHER
	BR	GDONE1

TWOFLG:	0

WDINC:	0				;POINTER TO FIRST WORD
	0				;POINTER TO NEXT
	0				;THESE POINTERS ARE ODD IF NXMS OR SLES
	0				;FOR NXMER2 KLUDGE

;PHYSICAL ADDRESS IN R0

;IN R1 IS 3 2 OR 1 DEPENDING ON WHICH TIME THROUGH LOOP
;ADDRESS IN R3 AND R2

GDSK:	MOV	VADR,R0			;VIRTUAL ADDRESS
	MOV	R1,-(SP)
	NEG	R1
	ADD	#3,R1
	ASL	R1
	ADD	R1,R0			;GET ACTUAL ADDRESS
	JSR	PC,CNVVP		;MAKE A PHYSICAL ADDRESS
	TST	R1
	BNE	GDNXM			;NXM
	TST	R2
	BNE	GDNXM
	MOV	R3,R1			;R2 SHOULD BE ZERO
	BIC	#BMASK,R3
	MOV	R1,R0
	SUB	R3,R0			;OFFSET INTO DISK BLOCK
	MOV	R0,AWDINC		;SAVE IT
	CLC
	ROR	R3			;MAKE IT A WORD ADDRESS
.IFNZ	F.HD
	ADD	#SPRG,R3		;OFFSET INTO SWAP TRACK
	ADC	R2
	MOV	R2,ADAE
	MOV	R3,ADAR
.ENDC
.IFZ	F.HD
	MOV	R3,MDSAV
	JSR	PC,MDCNVT
	MOV	#SPRG,MDSAV+2
	JSR	PC,MDADD
	MOV	MDSAV,ADAR
.ENDC
	MOV	#-400,AWDCNT
	MOV	(SP)+,R1
	RTS	PC
ADAR:	0
.IFNZ	F.HD
ADAE:	0
.ENDC
AWDINC:	0
AWDCNT:	0
VADR:	0	;VIRTUAL ADDRESS

GDNXM:	MOV	(SP)+,R1
	SUB	#3,R1	;SO WILL BE NEG AND NO INFO LOST
	RTS	PC
;CHANGE MODES. CHOICE OF P, KI, KD, SI, SD, UI OR UD
;FOR PHYSICAL MODE OR KERNEL INSTRUCTION, ETC.
;TYPE $$M  THEN IT ASKS MODE? THEN TYPE ONE OF CHOICES ABOVE
;THIS SETS UP DESREG TO BE PROPER ADDRESS OF DESCRIPTOR REG
;FOR THAT MODE, DATAMF SIGNALS WHETHER IT'S DATA SPACE

CHNGMD:	JSR	5,TYPE
	.ASCIZ	/ODE /
	.EVEN
	JSR	PC,GET1UC
	MOV	R0,-(SP)
	JSR	PC,GET1UC
	SWAB	R0
	BIS	(SP)+,R0
	JSR	PC,CHMODE
MODE.1:	JMP	O.DCD


CHMODE:	MOV	R1,-(SP)
	MOV	#CHNGL,R1	;CHANGE MODE TO (R0)
CHNG1:	CMP	R0,(R1)+
	BEQ	CHNG2		;GOT LEGAL NEW MODE
	CMP	#CHNGL+20.,R1
	BHI	CHNG1
	CMP	R0,#"R0
	BNE	CHMO.1
	MOV	#O.UR0,#O.UR0	;CHANGE TO REGISTER SET 0
WCHREG=.-2
	BR	CHNG4
CHMO.1:	CMP	R0,#"R1
	BNE	CHMO.2
	MOV	#ALTR0,WCHREG	;CHANGE TO REGISTER SET 0
	BR	CHNG4
CHMO.2:	JMP	O.ERR		;NOT A LEGAL MODE

CHNG2:	MOV	R0,MODE
	MOV	CHDREG-CHNGL-2(R1),DESREG
	CLR	R1
	MOVB	R0,R1
	SUB	#121,R1
	BGT	CHNG3
	CLR	R1
CHNG3:	ADD	#SAVKR6,R1
	MOV	USP,@R6AD
	MOV	R1,R6AD
	MOV	(R1),USP
	SWAB	R0
	MOV	R0,THPHYM
	BIC	#177774,THPHYM	;0-3 IN P MODE, ELSE IRRELEVANT
CHNG4:	MOV	(SP)+,R1
	RTS	PC


KMODE:	MOV	#'K,R1
	BR	MODE.2
UMODE:	MOV	#'U,R1
MODE.2:	JSR	PC,GET1UC
	SWAB	R0
	BIS	R1,R0		;MODE IS NOW IN R0
	JSR	PC,CHMODE
	BR	MODE.1

CHNGL:	.ASCII	\P0\
	.ASCII	\P1\
	.ASCII	\P2\
	.ASCII	\P3\
	.ASCII	\KI\
	.ASCII	\KD\
	.ASCII	\SI\
	.ASCII	\SD\
	.ASCII	\UI\
	.ASCII	\UD\

SAVKR6:	0	;SAVED KERNEL, SUP, USER R6'S
SAVSR6:	0
SAVUR6:	0
R6AD:	SAVKR6	;POINTER TO CURRENT SAVED R6


ALTR0:	0	;SAVE ALTERNATE REGISTER SET HERE
ALTR1:	0
ALTR2:	0
ALTR3:	0
ALTR4:	0
ALTR5:	0


THPHYM:	0	;BITS 17 & 16 OF PHYS MODE ADDRESS, = 0-3

CHDREG:	0	;DESCRIPTOR REGISTER FOR EACH MODE
	0
	0
	0
	KIDR0
	KIDR0+20
	SIDR0
	SIDR0+20
	UIDR0
	UIDR0+20
.ENDC
; RESTORE BREAKPOINTS 0-7

O.RSB:	MOV	#O.BKP,R4	;RESTORE ALL BREAKPOINTS
O.RS1:	MOV	O.ADR1(R4),R0
	CMP	R0,#-1
	BEQ	O.RS2
.IFNZ	M1145
	MOV	R0,R1
	MOV	O.BPM(R4),R0
	JSR	PC,CHMODE
	MOV	R1,R0
.ENDC
	JSR	PC,GETWRD
	MOV	@WDINC,O.UIN(R4)
	MOV	#3,@WDINC
	JSR	PC,WRTWRD
O.RS2:	DEC	R4
	DEC	R4
	BGE	O.RS1		;RE-LOOP UNTIL DONE
	RTS	R5		;THEN QUIT

;SAVE TELETYPE STATUS

O.SVTT:	MOVB	O.RCSR,O.CSR1	;SAVE R C/SR
	MOVB	O.TCSR,O.CSR2	;SAVE T C/SR
	CLRB	O.RCSR		;CLEAR ENABLE AND MAINTENANCE BITS
	CLRB	O.TCSR		;IN BOTH C/SR
	RTS	R5
; RESTORE TELETYPE STATUS

O.RSTT:	TST	O.T
	BNE	RSTT
	TST	SSFLAG
	BNE	RSTT
	JSR	PC,CRLF
RSTT:	TSTB	O.TCSR		;WAIT READY
	BPL	.-4		;  ON PRINTER
	BIT	#4000,O.RCSR	;CHECK BUSY FLAG
	BEQ	O.RSE1		;SKIP READY LOOP IF NOT BUSY
	TSTB	O.RCSR		;WAIT READY
	BPL	.-4		;    ON READER
O.RSE1:	MOVB	O.CSR1,O.RCSR	;RESTORE
	MOVB	O.CSR2,O.TCSR	;  THE STATUS REGISTERS
	RTS	R5

;REMOVE BREAKPOINTS 0-7, IN THE OPPOSITE ORDER OF SETTING

O.REM:	CLR	R4		;REMOVE ALL BREAKPOINTS
O.R1:	MOV	O.ADR1(R4),R0
	CMP	R0,#-1
	BEQ	O.R2
.IFNZ	M1145
	MOV	R0,R1
	MOV	O.BPM(R4),R0
	JSR	PC,CHMODE
	MOV	R1,R0
.ENDC
	JSR	PC,GETWRD
	MOV	O.UIN(R4),@WDINC
	JSR	PC,WRTWRD
O.R2:	TST	(R4)+
	CMP	R4,#O.BKP
	BLE	O.R1		;RE-LOOP UNTIL DONE
	RTS	R5		;THEN QUIT
;TYPE OUT NUMBER IN R0, OCTAL OR SIGNED DECIMAL AS PER TEMPDF
;PURELY OCTAL TYPEOUT CAN JSR TO TYPOCT, DECIMAL TO TYPDEC

TYPNUM:	TSTB	TEMPDF
	BNE	TYPDEC	;DECIMAL
TYPOCT:	MOV	#NUMBUF+7,R3	;OCTAL
TYPOC1:	MOV	R0,R4
	BIC	#177770,R4
	ADD	#'0,R4	;GET CHARACTER
	MOVB	R4,-(R3)	;STORE IT
	ASR	R0
	ASR	R0
	ASR	R0	;SHIFT IN NEXT OCTAL DIGIT
	BIC	#160000,R0	;MASK OFF SIGN BITS
	BNE	TYPOC1
TYPOC2:	MOV	#DNTTYP,R4
	MOVB	R4,-(R3)	;FILL IN REST OF BUFFER
TYPOC3:	CMP	#NUMBUF,R3	;END TEST
	BNE	TYPOC2
	JSR	5,TYPE
NUMBUF:	0	;MAX IS 7 CHARACTERS (-XXXXX.)
	0
	0
	0
	RTS	5

TYPDEC:	MOV	#NUMBUF+7,R3
	MOVB	#'.,-(R3)
	MOV	R0,-(SP)
	BPL	TYPDE1
	NEG	R0
TYPDE1:
	MOV	R0,SCRTCH	;DIVIDEND
TYPDE2:	DIVIDE	SCRTCH,#12,SCRTCH,R4
	ADD	#'0,R4	;ABS REMAINDER
	MOVB	R4,-(R3)
	TST	SCRTCH	;QUOTIENT
	BNE	TYPDE2
	MOV	(SP)+,R0
	BPL	TYPOC3
	MOVB	#'-,-(R3)
	BR	TYPOC3
;INSTRUCTION INPUT (IN...) AND OUTPUT (EX...) ROUTINES
; R0 UNKNOWN VALUE ARG TO EXINST; ALSO A SCRATCH REGISTER
; R1 FIRST SYMBOL WORD FROM INSN SYMBOL TABLE (RADIX-50)
; R2 SECOND SYMBOL WORD
; R3 INDEX TO MASKS AND SERVICE ROUTINES TABLES
; R4 INSN VALUE TABLE POINTER
; R5 INSN SYMBOL TABLE POINTER

;INPUT THE INSN WHOSE SYMBOL IS IN R50SYL+0,+2

ININST:	CLR	R3	;INITIALIZE POINTERS
	MOV	#INVALS,R4
	MOV	#INSYMS,R5
	CLR	INBYTE
ININ1:	JSR	PC,INNEXT
	BR	ININ3	;NO SUCH INSN
	TST	(R4)+
	CMP	R50SYL,R1
	BNE	ININ1	;FIRST SYMBOL WORDS UNEQUAL
	CMP	R50SYL+2,R2
	BEQ	ININ2	;FOUND
	TST	#0
INBYTE=.-2	;NONZERO IF THIS INSN HAS A BYTE MODE
	BEQ	ININ1
	CMP	R50SYL+2,#2*50*50	;RADIX-50 B FOR BYTE MODE
	BNE	ININ1
	BIS	#100000,VAL	;INSN IS IN BYTE MODE
ININ2:	ADD	-(R4),VAL	;PICK UP VALUE
	CLR	LENTYI
	JMP	@ININ4(R3)	;DISPATCH TO SERVICE ROUTINE

ININ3:	JMP	EVALS3	;NO SUCH INSN

ININ4:	INHALT	;INSN INPUT DISPATCH TABLE
	INRTS
.IIF NZ M1145,INEMT	;FOR SPL
	INCL
.IIF NZ M1140+M1145,INEMT	;FOR MARK
	INJMP
	INBR
	INEMT	;FOR EMT, TRAP
.IIF NZ FPP,INASH
.IIF NZ FPP,INSTF
.IIF NZ M1140+M1145,INSOB
	INJSR
.IIF NZ M1140+M1145,INASH
	INADD
;OUTPUT THE INSN WHOSE VALUE IS IN R0

EXINST:	MOV	R0,EXIN2
	CLR	R3	;INITIALIZE POINTERS
	MOV	#INVALS,R4
	MOV	#INSYMS,R5
	CLR	INBYTE
EXIN1:	JSR	PC,INNEXT
	BR	EXIN4	;NO SUCH INSN
	MOV	#0,R0
EXIN2=.-2	;SAVED ARGUMENT VALUE
	BIC	MASKS(R3),R0	;CLEAR NON-OP-CODE BITS
	CMP	(R4)+,R0
	BEQ	EXIN3	;FOUND
	TST	INBYTE
	BEQ	EXIN1	;NOT A BYTE MODE INSN
	BIC	#100000,R0
	CMP	-2(R4),R0
	BNE	EXIN1	;KEEP LOOKING
	MOV	#2*50*50,R2	;RADIX-50 B FOR BYTE MODE
EXIN3:	MOV	R3,-(SP)	;SAVE DISPATCH INDEX
	MOV	R1,AINST
	MOV	R2,AINST+2
	JSR	5,TYPE50	;TYPE INSN OP CODE
	JSR	PC,TYP3SP
	MOV	EXIN2,R0	;RESTORE VALUE
	MOV	(SP)+,R3	;RESTORE DISPATCH INDEX
	JMP	@EXIN5(R3)	;DISPATCH TO SERVICE ROUTINE

EXIN4:	ADD	#2,(SP)	;NO SUCH INSN
	RTS	PC	;SKIP-RETURN

EXIN5:	EXHALT	;INSN OUTPUT DISPATCH TABLE
	EXRTS
.IIF NZ M1145,EXEMT	;FOR SPL
	EXCL
.IIF NZ M1140+M1145,EXEMT	;FOR MARK
	EXJMP
	EXBR
	EXEMT	;FOR EMT, TRAP
.IIF NZ FPP,EXASH
.IIF NZ FPP,EXSTF
.IIF NZ M1140+M1145,EXSOB
	EXJSR
.IIF NZ M1140+M1145,EXASH
	EXADD
;PICK UP NEXT INSN FROM INSN TABLES, FOR ININST OR EXINST
;THIS ROUTINE UPDATES R3 & R5, BUT CALLING ROUTINE MUST DO R4

INNEX0:	ADD	(R5)+,PC	;GOES TO INNEX1, INNEX2 OR INNEX5
INNEX1:	TST	(R3)+	;UPDATE MASK AND DISPATCH INDEX
	CLR	INBYTE	;RESET BYTE MODE FLAG
	BR	INNEXT

INNEX2:	INC	INBYTE	;NEXT INSN(S) HAVE A BYTE MODE
INNEXT:	TSTB	1(R5)	;ENTRY POINT
	BEQ	INNEX0	;UPDATE POINTERS, FLAGS
	MOV	(R5)+,R1	;FIRST SYMBOL WORD
	CLR	R2
	TST	(R5)
	BPL	INNEX4	;BR IF SYMBOL IS ONLY 1 WORD LONG
	MOV	(R5)+,R2	;SECOND SYMBOL WORD
	BIC	#100000,R2	;CLEAR SECOND-WORD FLAG
.IFNZ M40FPU+FPP
	ROR	R2
	BCC	INNEX3
	BIS	#40000,R2	;FDIV, STEXP & LDEXP NEED HIGH BIT ON
INNEX3:	ASL	R2
.ENDC
INNEX4:	ADD	#2,(SP)	;SKIP-RETURN IF HAVE INSN
INNEX5:	RTS	PC	;NO SKIP IF AT END OF INSNS

;IN INSYMS TABLE,
;INNEX1-INNEX1 => UPDATE MASK & DISPATCH LOCATION INDEX
;INNEX2-INNEX1 => SET BYTE MODE FLAG FOR NEXT INSNS
;INNEX5-INNEX1 => END OF SYMBOL TABLE

MASKS:	0	;ONES IN NON-OP-CODE BITS
	7
.IIF NZ M1145,7
	17
.IIF NZ M1140+M1145,77
	77
	377
	377
.IIF NZ FPP,377
.IIF NZ FPP,377
.IIF NZ M1140+M1145,777
	777
.IIF NZ M1140+M1145,777
	7777
;INSN INPUT SERVICE ROUTINES

INRTS:	JSR	PC,REEVAL	;GET A GENERAL REGISTER
;REGINF NOT TESTED TO ALLOW SINGLE NUMERAL, LIKE RTS 5
	BIT	#177770,R4
	BNE	ABORT3	;INVALID REGISTER NUMBER
INRTS1:	ADD	R4,VAL
INHALT:	RTS	PC

.IFNZ FPP+M1140+M1145
INASH:	JSR PC,INSSDD	;GET SOURCE
	CMPB #',,@PARSEP
	BNE ABORT3	;COMA MUST BE SEPERATOR
	INC PARSEP
	JSR PC,REEVAL	;GET REGISTER
	TSTB REGINF
	BEQ ABORT3	;NOT A REGISTER
	BITB #200,VAL+1
	BEQ .INAS1	;FPP INSTRUCTION REGS < 4
	BIT #4,R4
	BNE ABORT3	;ILLEGAL REGISTER
.INAS1:	CMPB #162,VAL+1
	BNE .INAOK	;IS IT A DIVIDE?
	BIT #1,R4
	BNE ABORT3	;REG MUST BE EVEN
.INAOK:	SWAB R4
	ASR R4		;PUT REGISTER IN PROPER FIELD
	ASR R4
	ADD R4,VAL
	RTS PC
.ENDC

.IFNZ FPP
INSTF:	JSR	PC,INRTS
	BIT	#4,R4
	BNE	ABORT3	;INVALID FPP REGISTER NUMBER
	BR	INADD1
.ENDC

INJSR:	JSR	PC,INRTS
	BR	INADD1

INADD:	JSR	PC,INSSDD
INADD1:	JSR	PC,INSHOV
INJMP:	JMP	INSSDD	;WHICH DOES RTS FOR US

INSHOV:	MOVB	VAL,R4	;SHOVE NEW FIELD IN VAL LEFT 6 BITS
	CLRB	VAL
	SWAB	R4
	ROR	R4
	ROR	R4
	ADD	R4,VAL
	CMPB	#',,@PARSEP	;COMMA MUST SEPARATE FIELDS
	BNE	ABORT3
	INC	PARSEP	;PASS OVER COMMA
	RTS	PC

.IFNZ M1140+M1145
INSOB:	JSR	PC,INRTS
	JSR	PC,INSHOV
	JSR	PC,REEVAL
	TSTB	REGINF
	BNE	ABORT3	;NO SOB TO A REGISTER
	NEG	R4
	ADD	CURADR,R4
	ASR	R4
	INC	R4
	BIT	#177700,R4
	BEQ	INRTS1	;OK
	BR	ABORT3	;OFFSET OUT OF RANGE
.ENDC
INBR:	JSR	PC,REEVAL
	TSTB	REGINF
	BNE	ABORT3	;NO BR TO A REGISTER
	BIT #1,R4
	BNE ABORT3	;NO ODD ADDRESS
	SUB	CURADR,R4
	ASR	R4
	ADD	#200-1,R4
	BIT	#177400,R4
	BNE	ABORT3	;OFFSET OUT OF RANGE
	SUB	#200,R4
	BIC 	#177400,R4
	BR	INRTS1

INEMT:	MOV	MASKS(R3),INEMT1
	JSR	PC,REEVAL
	TSTB	REGINF
	BNE	ABORT3	;ARG CANNOT BE REGISTER QUANTITY
	MOV	#0,R3
INEMT1=.-2	;MASK OF NON-OP-CODE BITS
	COM	R3
	BIT	R3,R4
	BEQ	INRTS1
ABORT3:	JMP	DCDERR	;ARG TOO LARGE FOR FIELD

INCL1:	BISB	INCL5-1(R1),VAL
INCL2:	INC	PARSEP	;GO TO NEXT CHAR
INCL:	CLR R0
	MOVB	@PARSEP,R0	;ENTRY POINT, PICK UP CHAR
	CMP	#40,R0
	BEQ	INCL2	;IGNORE SPACES
	CLR	R1
INCL3:	INC	R1
	CMPB	INCL4-1(R1),R0
	BEQ	INCL1	;CHAR MATCHES
	BIT	#4,R1
	BEQ	INCL3	;KEEP LOOKING
	RTS	PC	;GOT TO TERMINATOR CHAR

INCL4:	.BYTE	'C,'V,'Z,'N
INCL5:	.BYTE	1,2,4,10

;INSN OUTPUT SERVICE ROUTINES

EXCL:	CLR	R1
EXCL1:	INC	R1
	BITB	INCL5-1(R1),R0
	BEQ	EXCL3
	MOVB	INCL4-1(R1),EXCL2
	JSR	5,TYPE
EXCL2:	0
EXCL3:	BIT	#4,R1
	BEQ	EXCL1
	RTS	PC
EXRTS:	BIC	#177770,R0
	BISB	#1,REGINF
EXRTS1:	JSR	5,SYMBL0
EXHALT:	RTS	PC	;SAVE A WORD IF MAKE SYMBOL USE PC, NOT R5 ***

.IFNZ FPP+M1140+M1145

EXASH:	JSR PC,EXSSDD	;PRINT SOURCE OPERAND
	JSR 5,TYPE
	',
	MOV EXIN2,R0	;GET INSTRUCTION
	BIT #100000,R0
	BEQ EXAS1
	BIC #400,R0	;FPP INSTRUCTIONS HAVE SMALL REG NUMBERS
EXAS1:	ROL R0
	ROL R0
	SWAB R0		;GET THE DESTINATION REGISTER
	BR EXRTS	;GO PRINT IT
.ENDC

.IFNZ FPP
EXSTF:	BIC	#400,R0	;ONLY 2 BITS IN AC FIELD
.ENDC
EXJSR:	ROL	R0
	ROL	R0
	SWAB	R0
	JSR	PC,EXRTS
	BR	EXADD1

EXADD:	ROL	R0
	ROL	R0
	SWAB	R0
	JSR	PC,EXSSDD
EXADD1:	JSR	5,TYPE
	',
EXJMP:	MOV	EXIN2,R0
	JMP	EXSSDD	;WHICH DOES RTS FOR US

.IFNZ M1140+M1145
EXSOB:	ROL	R0
	ROL	R0
	SWAB	R0
	JSR	PC,EXRTS
	JSR	5,TYPE
	',
	MOV	EXIN2,R1
	BIC	#177700,R1
	DEC	R1
	ASL	R1
	MOV	CURADR,R0
	SUB	R1,R0
	BR	EXBR1
.ENDC

EXBR:	MOVB	R0,R0	;EXTEND SIGN
	INC	R0
	ASL	R0
	ADD	CURADR,R0
EXBR1:	CLRB	REGINF
	BR	EXRTS1

EXEMT:	MOV	MASKS(R3),R1
	COM	R1
	BIC	R1,R0
	JSR	5,TYPNUM
	RTS	PC	;SAVE A WORD IF MAKE TYPNUM USE PC, NOT R5 ***
;TYPE LOW 6 BITS OF R0 AS SOURCE OR DESTINATION FIELD

EXSSDD:	MOV	R0,R5
	BIC	#177707,R0	;ADDRESSING MODE
	BIC	#177770,R5	;REGISTER
	ASR	R0
	ASR	R0
	CMP	#7,R5
	BNE	EXSD1
	INC	R0	;REGISTER IS PC
EXSD1:	MOVB	EXSDM(R0),-(SP)	;PICK UP BYTE OF CONTROL BITS
	BIT	#200,(SP)
	BEQ	EXSD2
	JSR	5,TYPE
	'@
EXSD2:	BIT	#100,(SP)
	BEQ	EXSD3
	JSR	5,TYPE
	'#
EXSD3:	BIT	#60,(SP)
	BEQ	EXSD7
	ADD	#2,LENGTH	;GET NEXT WORD OF INSTRUCTION
	MOV	LENGTH,R0
.IFZ	M1145
	ADD	WDINC,R0
	MOV	(R0),R0
.ENDC
.IFNZ	M1145
	ADD	#WDINC,R0
	BIT	#1,@R0
	BNE	GETERR	;BR IF WORD FLAGGED AS NOT ACCESSIBLE
	MOV	@(R0),R0
.ENDC
	BIT	#40,(SP)
	BNE	EXSD4
	ADD	CURADR,R0
	ADD	LENGTH,R0
	ADD	#2,R0
EXSD4:	MOV	SYMTOL,EXSD6
	BIT	#20,(SP)
	BNE	EXSD5
	CLR	SYMTOL	;SYMBOL MUST MATCH EXACTLY
EXSD5:	CLRB	REGINF
	JSR	5,SYMBL0
	MOV	#0,SYMTOL
EXSD6=.-4	;SAVED SYMBOL TYPER'S OFFSET TOLERANCE
EXSD7:	BIT	#10,(SP)
	BEQ	EXSD8
	JSR	5,TYPE
	'-
EXSD8:	BIT	#4,(SP)
	BEQ	EXSD9
	JSR	5,TYPE
	'(
EXSD9:	BIT	#2,(SP)
	BEQ	EXSD10
	MOV	R5,R0	;REGISTER
	BISB	#1,REGINF
	JSR	5,SYMBL0
EXSD10:	BIT	#4,(SP)
	BEQ	EXSD11
	JSR	5,TYPE
	')
EXSD11:	BIT	#1,(SP)+	;FINALLY DONE WITH MAGIC BITS
	BEQ	EXSD12
	JSR	5,TYPE
	'+
EXSD12:	RTS	PC
.IFNZ	M1145
GETERR:	TSTB	1(R0)	;DECODE ERROR AS SLE OR NXM
	BEQ	NXMRR
SLERR:	JSR	5,TYPE
	.ASCIZ	/SLE/
	.EVEN
	JMP	DCDERR

NXMRR:	JMP NXMER
.ENDC

CURADR:	0	;CURRENT ADDRESS FOR INSTRUCTION TO SEEM LOCATED AT
;( = DOT OR BPT LOCATION)

;SOURCE OR DESTINATION FIELD CONSISTS OF ...
; <@> <#> <X,N,A> <-> <(> <R> <)> <+>
;WHERE EACH FIELD MAY ALSO BE NULL
;FOLLOWING TABLE OF MAGIC BITS CODES OPTIONS FOR EACH ADDRESSING MODE
;200 BIT ON SAYS TYPE AN @, 100 BIT SAYS TYPE A #, ETC.
;BOTH ( AND ) ARE SPECIFIED BY 4 BIT, AND 60 BITS SAY ...
;00 => NULL
;01 => NEXT WORD + CURADR + LENGTH + 2
;10 => NEXT WORD, WITH OFFSET TOLERANCE = 0
;11 => NEXT WORD

EXSDM:	.BYTE	002	;0R	R MODE
	.BYTE	002	;07	=0R
	.BYTE	006	;1R	(R)
	.BYTE	006	;17	=1R
	.BYTE	007	;2R	(R)+
	.BYTE	160	;27	#N
	.BYTE	207	;3R	@(R)+
	.BYTE	360	;37	@#A
	.BYTE	016	;4R	-(R)
	.BYTE	016	;47	=4R
	.BYTE	216	;5R	@-(R)
	.BYTE	216	;57	=5R
	.BYTE	046	;6R	X(R)
	.BYTE	020	;67	A
	.BYTE	246	;7R	@X(R)
	.BYTE	220	;77	@A
;PARSE A TYPED-IN SOURCE OR DESTINATION FIELD, PUTTING RESULT IN
;LOW 6 BITS OF VAL, AND ANY MORE INSN WORDS IN VAL+2 OR +4

INSSDD:	JSR	PC,REEVAL
	TST	R2
	BNE	INSD1	;ARG BEFORE @ MUST BE NULL
	CMP	#'@,R0
	BNE	INSD1	;TERMINATOR NOT @
	BIS	#10,VAL	;@ SEEN, DEFERRED MODE
	INC	PARSEP
	JSR	PC,REEVAL
INSD1:	TSTB	REGINF
	BNE	MOD0	;REGISTER MODE, RN, 0R
	TST	R2
	BNE	INSD2	;PARSED STRING IS NOT NULL
	CMP	#'(,R0
	BEQ	INSD3	;(RN) OR (RN)+
	CMP	#'#,R0
	BNE	ABORT1	;NO SUCH MODE
	BIS	#27,VAL	;IMMEDIATE MODE, #N, 27
	INC	PARSEP
	JSR	PC,REEVAL
	TSTB	REGINF
	BNE	ABORT1	;NO #RN MODE
	JSR	PC,INCLEN
	BR	INSD2A

INSD2:	CMP	#'(,R0
	BEQ	INSD4	;X(RN) OR -(RN)
	BIS	#67,VAL	;ABSOLUTE MODE, A, 67
	JSR	PC,INCLEN
	MOV	LENTYI,R1
	TST	(R1)+
	ADD	DOT,R1
	SUB	R1,R4
INSD2A:	MOV	R4,(R3)
	RTS	PC

INSD3:	INC	PARSEP
	JSR	PC,INREG
	CMPB	#'+,@PARSEP
	BNE	MOD1	;(RN), WHICH SHOULD BE LIKE @RN
	BIS	#20,VAL	;AUTOINCREMENT MODE, (RN)+, 2R
	BR	INREGA	;INC PARSEP AND RTS

MOD1:	BIT	#10,VAL
	BNE	MOD7F	;@(RN), WHICH SHOULD BE LIKE @0(RN)
	BIS	#10,VAL
	RTS	PC
INSD4:	CMP	#1,R2
	BNE	MOD6	;INDEX MODE, X(RN), 6R
	MOV	PARSEP,R2
	CMPB	#'-,-(R2)	;IS THE ONE PARSED CHAR - ?
	BNE	MOD6	;NO, THIS ALSO MEANS INDEX MODE
	BIS	#40,VAL	;AUTODECREMENT MODE, -(RN), 4R
	BR	MOD6A

MOD6:	JSR	PC,INCLEN
	MOV	R4,(R3)
	BIS	#60,VAL
MOD6A:	INC	PARSEP
INREG:	JSR	PC,REEVAL	;PARSE A REGISTER VALUE
	TSTB	REGINF
	BEQ	ABORT1	;MUST BE REGISTER
	CMP	#'),R0
	BNE	ABORT1	;TERMINATOR MUST BE )
INREGA:	INC	PARSEP	;PASS OVER ) (OR + OF (RN)+ MODE)
MOD0:	BIT	#177770,R4
	BNE	ABORT1	;INVALID REGISTER NUMBER
	BIS	R4,VAL	;DEPOSIT REGISTER NUMBER
	RTS	PC

MOD7F:	BIS	#70,VAL	;FUDGE @(RN) INTO @0(RN)
	JSR	PC,INCLEN
	CLR	(R3)
	RTS	PC

INCLEN:	ADD	#2,LENTYI	;INSTRUCTION IS ANOTHER WORD LONG
	MOV	#VAL,R3
	ADD	LENTYI,R3	;MAKE R3 POINT TO CURRENT WORD
	RTS	PC

ABORT1:	JMP	O.ERR	;FATAL ERROR IN INSSDD

VAL:	0	;TYPED-IN INSTRUCTION GETS ASSEMBLED HERE
	0
	0
LENTYI:	0	;LENGTH OF INSTRUCTION IN VAL, -2 BYTES
;INSN SYMBOL TABLE -- 1ST WORD IS JUST RADIX-50
;2ND WORD, IF NOT NULL, IS RADIX-50 PLUS 100000,
;UNLESS IT IS V OR XP -- THEN IT IS RADIX-50 PLUS 1
;LEFT BYTE ZERO INDICATES CONTROL WORD, AS NOTED

INSYMS:
	031064	;\HAL\
	176400	;\T  \+100000
	107761	;\WAI\  < 0 OK SINCE AFTER A 2-WD INSN
	176400	;\T  \+100000
	071651	;\RTI\
	007424	;\BPT\
	035254	;\IOT\
	070533	;\RES\
	121140	;\ET \+100000
.IFNZ M1140+M1145
	071664	;\RTT\
.ENDC
	054750	;\NOP\
.IFNZ FPP
	011663	;\CFC\
	111300	;\C  \+100000
	073634	;\SET\
	122600	;\F  \+100000
	073634	;\SET\
	134100	;\I  \+100000
	073634	;\SET\
	114400	;\D  \+100000
	073634	;\SET\
	145400	;\L  \+100000
.ENDC
	0	;CHANGE TO MASK = 7, RTS SERVICE ROUTINE
	071663	;\RTS\
.IFNZ M40FPU
	022654	;\FAD\
	114400	;\D  \+100000
	024215	;\FSU\
	106200	;\B  \+100000
	023635	;\FMU\
	145400	;\L  \+100000
	023051	;\FDI\
	104601	;\V  \+ ONLY 1 SINCE ALREADY NEGATIVE
.ENDC
.IFNZ M1145
	0	;KEEP MASK = 7, CHANGE TO EMT SERVICE ROUTINE
	074514	;\SPL\
.ENDC
	0	;CHANGE TO MASK = 17, CL SERVICE ROUTINE
	012240	;\CL \
	073610	;\SE \
	0	;CHANGE TO MASK = 77, EMT OR JMP SERVICE ROUTINE
.IFNZ M1140+M1145
	050572	;\MAR\
	142300	;\K  \+100000
	0	;KEEP MASK = 77, CHANGE TO JMP SERVICE ROUTINE
	051100	;\MFP\
	134100	;\I  \+100000
	052160	;\MTP\
	134100	;\I  \+100000
	075224	;\SXT\
.ENDC
.IFNZ M1145
	051100	;\MFP\
	114400	;\D  \+100000
	052160	;\MTP\
	114400	;\D  \+100000
.ENDC
	040230	;\JMP\
	075131	;\SWA\
	106200	;\B  \+100000
.IFNZ FPP
	045646	;\LDF\
	163370	;\PS \+100000
	074746	;\STF\
	163370	;\PS \+100000
	074763	;\STS\
	176400	;\T  \+100000
	012262	;\CLR\
	122600	;\F  \+100000
	012262	;\CLR\
	114400	;\D  \+100000
	100014	;\TST\  < 0 OK SINCE AFTER A 2-WD INSN
	122600	;\F  \+100000
	100014	;\TST\  < 0 OK SINCE AFTER A 2-WD INSN
	114400	;\D  \+100000
	003243	;\ABS\
	122600	;\F  \+100000
	003243	;\ABS\
	114400	;\D  \+100000
	054117	;\NEG\
	122600	;\F  \+100000
	054117	;\NEG\
	114400	;\D  \+100000
.ENDC
	INNEX2-INNEX1	;SET BYTE MODE FLAG
	100014	;\TST\  FIRST SINCE THE WORD IS NEGATIVE
	012262	;\CLR\
	012445	;\COM\
	035163	;\INC\
	014713	;\DEC\
	054117	;\NEG\
	003343	;\ADC\
	073423	;\SBC\
	071352	;\ROR\
	071344	;\ROL\
	004512	;\ASR\
	004504	;\ASL\
	0	;CHANGE TO MASK = 377, BR SERVICE ROUTINE
	007520	;\BR \
	007265	;\BNE\
	006531	;\BEQ\
	006635	;\BGE\
	007164	;\BLT\
	006654	;\BGT\
	007145	;\BLE\
	007414	;\BPL\
	007221	;\BMI\
	006711	;\BHI\
	007157	;\BLO\
	173300	;\S  \+100000
	007763	;\BVC\
	010003	;\BVS\
	006373	;\BCC\
	006711	;\BHI\
	173300	;\S  \+100000
	006413	;\BCS\
	007157	;\BLO\
	0	;KEEP MASK = 377, CHANGE TO EMT SERVICE ROUTINE
	020534	;\EMT\
	077721	;\TRA\
	162000	;\P  \+100000
.IFNZ FPP
	0	;KEEP MASK = 377, CHANGE TO ASH SERVICE ROUTINE
	052224	;\MUL\
	122600	;\F  \+100000
	052224	;\MUL\
	114400	;\D  \+100000
	051634	;\MOD\
	122600	;\F  \+100000
	051634	;\MOD\
	114400	;\D  \+100000
	003344	;\ADD\
	122600	;\F  \+100000
	003344	;\ADD\
	114400	;\D  \+100000
	045646	;\LDF\
	045644	;\LDD\
	075012	;\SUB\
	122600	;\F  \+100000
	075012	;\SUB\
	114400	;\D  \+100000
	012330	;\CMP\
	122600	;\F  \+100000
	012330	;\CMP\
	114400	;\D  \+100000
	015176	;\DIV\
	122600	;\F  \+100000
	015176	;\DIV\
	114400	;\D  \+100000
	045645	;\LDE\
	114201	;\XP \+ ONLY 1 SINCE ALREADY NEGATIVE
	045643	;\LDC\
	134460	;\IF \+100000
	045643	;\LDC\
	134340	;\ID \+100000
	045643	;\LDC\
	145760	;\LF \+100000
	045643	;\LDC\
	145640	;\LD \+100000
	045643	;\LDC\
	114760	;\DF \+100000
	045643	;\LDC\
	123040	;\FD \+100000
	0		;KEEP MASK 377, CHANGE TO STF SERVICE ROUTINE
	074746	;\STF\
	074744	;\STD\
	074745	;\STE\
	114201	;\XP \+ ONLY 1 SINCE ALREADY NEGATIVE
	074743	;\STC\
	123350	;\FI \+100000
	074743	;\STC\
	123540	;\FL \+100000
	074743	;\STC\
	115150	;\DI \+100000
	074743	;\STC\
	115340	;\DL \+100000
	074743	;\STC\
	123040	;\FD \+100000
	074743	;\STC\
	114760	;\DF \+100000
.ENDC
	0	;CHANGE TO MASK = 777, SOB OR JSR SERVICE ROUTINE
.IFNZ M1140+M1145
	074432	;\SOB\
	0	;KEEP MASK = 777, CHANGE TO JSR SERVICE ROUTINE
	114152	;\XOR\ OK SINCE AFTER 0
.ENDC
	040612	;\JSR\
.IFNZ M1140+M1145
	0	;KEEP MASK 777,CHANGE TO ASH SERVICE ROUTINE
	052224	;\MUL\
	015176	;\DIV\
	004500	;\ASH\
	004500	;\ASH\
	111300	;\C  \+100000
.ENDC
	0	;CHANGE TO MASK = 7777, ADD SERVICE ROUTINE
	003344	;\ADD\
	075012	;\SUB\
	INNEX2-INNEX1	;SET BYTE MODE FLAG
	051656	;\MOV\
	012330	;\CMP\
	006774	;\BIT\
	006753	;\BIC\
	006773	;\BIS\
	INNEX5-INNEX1	;END OF SYMBOL TABLE
;INSN VALUE TABLE

INVALS:	0	;HALT
	1	;WAIT
	2	;RTI
	3	;BPT
	4	;IOT
	5	;RESET
.IFNZ M1140+M1145
	6	;RTT
.ENDC
	240	;NOP
.IFNZ FPP
	170000	;CFCC
	170001	;SETF
	170002	;SETI
	170011	;SETD
	170012	;SETL
.ENDC

	200	;RTS
.IFNZ M40FPU
	75000	;FADD
	75010	;FSUB
	75020	;FMUL
	75030	;FDIV
.ENDC

.IFNZ M1145
	230	;SPL
.ENDC

	240	;CL
	260	;SE

.IFNZ M1140+M1145
	6400	;MARK
	6500	;MFPI
	6600	;MTPI
	6700	;SXT
.ENDC
.IFNZ M1145
	106500	;MFPD
	106600	;MTPD
.ENDC
	100	;JMP
	300	;SWAB
.IFNZ FPP
	170100	;LDFPS
	170200	;STFPS
	170300	;STST
	170400	;CLRF
	170400	;CLRD
	170500	;TSTF
	170500	;TSTD
	170600	;ABSF
	170600	;ABSD
	170700	;NEGF
	170700	;NEGD
.ENDC
	5700	;TST(B)
	5000	;CLR(B)
	5100	;COM(B)
	5200	;INC(B)
	5300	;DEC(B)
	5400	;NEG(B)
	5500	;ADC(B)
	5600	;SBC(B)
	6000	;ROR(B)
	6100	;ROL(B)
	6200	;ASR(B)
	6300	;ASL(B)

	400	;BR
	1000	;BNE
	1400	;BEQ
	2000	;BGE
	2400	;BLT
	3000	;BGT
	3400	;BLE
	100000	;BPL
	100400	;BMI
	101000	;BHI
	101400	;BLOS
	102000	;BVC
	102400	;BVS
	103000	;BCC
	103000	;BHIS
	103400	;BCS
	103400	;BLO
	104000	;EMT
	104400	;TRAP
.IFNZ FPP
	171000	;MULF
	171000	;MULD
	171400	;MODF
	171400	;MODD
	172000	;ADDF
	172000	;ADDD
	172400	;LDF
	172400	;LDD
	173000	;SUBF
	173000	;SUBD
	173400	;CMPF
	173400	;CMPD
	174400	;DIVF
	174400	;DIVD
	176400	;LDEXP
	177000	;LDCIF
	177000	;LDCID
	177000	;LDCLF
	177000	;LDCLD
	177400	;LDCDF
	177400	;LDCFD
	174000	;STF
	174000	;STD
	175000	;STEXP
	175400	;STCFI
	175400	;STCFL
	175400	;STCDI
	175400	;STCDL
	176000	;STCFD
	176000	;STCDF
.ENDC

.IFNZ M1140+M1145
	77000	;SOB
	74000	;XOR
.ENDC
	4000	;JSR
.IFNZ M1140+M1145
	70000	;MUL
	71000	;DIV
	72000	;ASH
	73000	;ASHC
.ENDC

	60000	;ADD
	160000	;SUB
	10000	;MOV(B)
	20000	;CMP(B)
	30000	;BIT(B)
	40000	;BIC(B)
	50000	;BIS(B)
SYMBAD:	MOVB	REGFLG,REGINF
	JSR	R5,SYMBOL
	CLRB	REGINF
	RTS	R5

;# IS IN R0
SYMBL0:	MOV	R0,ADR2	;ENTRY FROM INSN DECODER, SO UPDATE ADDRESS
	MOVB	REGINF,ADR2F
SYMBOL:	TSTB	TEMPAF	;NORMAL ENTRY TO TYPE A SYMBOL
	BNE	SYMABS	;TYPE ADDRESSES AS ABSOLUTE
SYMBL2:	MOV	R0,SAVSYM
	CLR	R2
	CLR	AINST
	MOV	#O.BSYM,R1
	CLR	R3
SYMLOP:	ASL	R3
	BNE	SYMBL1
	TST	-(R1)
	MOV	R1,R4	;R4 CONTAINS ADDRSS
	TST	-(R1)
	INC	R3
SYMBL1:	SUB	#6,R1
	MOV	#0,R0	;GET BACK INITIAL ARG
SAVSYM=.-2
	CMP	R1,O.SYME
	BLO	SYMLPE
	SUB	4(R1),R0
	BLO	SYMLOP
	CMP	R0,#200	;SHOULD MAYBE BE 300 OR 400, AND INFINITE IF $S TYPED ***
SYMTOL=.-2	;HOW CLOSE SYMBOL MUST MATCH TO GET TYPED SYM+OFFSET
	BHI	SYMLOP
	CMP	R2,4(R1)	;FINDING LARGEST SYMBOL NOT > #
	BHI	SYMLOP
	BIT	R3,-2(R4)
	BNE	SYMLOP		;HALF KILLED
	TSTB	REGINF		;SYMBOL'S REG FLAG MUST BE SAME AS VALUE'S
	BNE	SYMBL3
	BIT	R3,(R4)
	BNE	SYMLOP
	BR	SYMBL4
SYMBL3:	BIT	R3,(R4)
	BEQ	SYMLOP
SYMBL4:	MOV	4(R1),R2	;REPLACE OLD LARGEST
	MOV	(R1),AINST
	MOV	2(R1),AINST+2
	BR	SYMLOP

SYMLPE:	SUB	R2,R0	;WANT TO TYPE FOO + NUMBER
	MOV	R0,-(SP)	;SAVE NUMBER
	TST	AINST	;IF ZERO NO SYMBOL FOUND
	BEQ	.SYMPE
	JSR	5,TYPE50
	TST	(SP)
	BNE	SYP
	TST	(SP)+
	RTS	5

SYP:	JSR	5,TYPE
	.ASCIZ	/+/
	.EVEN
SYMPE1:	MOV	(SP)+,R0
	JMP	TYPNUM

SYMABS:	MOV	R0,-(SP)
.SYMPE:	TSTB	REGINF
	BEQ	SYMPE1
	JSR	5,TYPE
	.ASCIZ	/%/
	.EVEN
	BR	SYMPE1
CRLF:	JSR	5,TYPE
	.BYTE	15
	.BYTE	12
	.BYTE	177
	.BYTE	177
	.BYTE	177
.IFNZ	KL11
	.BYTE	177
	.BYTE	177
	.BYTE	177	;6 NULLS FOR TIMING
.ENDC
	.BYTE	0
	.EVEN
	RTS	PC

O.SYLL:	BIC	#1,DOTFLG	;MAKE DOTFLG AGREE WITH REGFLG
	ADD	REGFLG,DOTFLG
	MOV	#O.BSYM,R1	;LOOK UP SYMBOL
	CLR	R3
O.SLL2:	ASL	R3
	BNE	O.SLL3
	TST	-(R1)
	MOV	R1,O.FLGS
	TST	-(R1)	;SKIP OVER HALF KILLED FLAGS BY -2
	INC	R3
O.SLL3:	SUB	#6,R1
	CMP	R1,O.SYME
	BLO	O.SLL1
	CMP (R1),O.SYL
	BNE O.SLL2
	CMP 2(R1),O.SYL+2
	BNE O.SLL2
	MOV #1,R2
	MOV 4(R1),R4	;VALUE TO R4
	MOV R3,O.BIT
	RTS PC
O.SLL1:	CLR O.BIT
	RTS PC

SAVDEC:	0	;DECIMAL NUMBER BEING ACCUMULATED
O.FLGS:	0
O.BIT:	0
;THIS ROUTINE TAKES CHAR FROM TTY AND STORES IT IN BUFFER.  HANDLES
;RUBOUT, QUOTE CHARACTERS (&,",') AND SETS DONEF WHEN A COMMAND CHAR
;OR ANYTHING FOLLOWING ALTMODE(S) IS READ.  CONVERTS LOWER CASE TO UPPER.
;IN MAY BE CALLED WHENEVER USER MIGHT BE TYPING AND RUG NOT LISTENING.
;ONLY NON-QUOTABLE CHARS: NULL (0), RUBOUT (177), AND ALTMODE (175) BECOMES ESCAPE (33)

INCHK:	TSTB	O.RCSR	;CHECK FOR TTY INPUT
	BPL	INCHKR
	JSR	PC,READCH	;ITS THERE SO GET IT
	MOVB	R0,@TNPNTR	;PUT IT IN BUFFER
	CMP	TNPNTR,#TBUFFE-1
	BHIS	INCK2
	INC	TNPNTR
INCK2:	CLRB	@TNPNTR
INCHKR:	RTS	PC	;NO INPUT

IN:	MOV	R1,-(SP)
	MOV	#QUOTFL,R1
	JSR	PC,TYPCHS
	TSTB	R0
	BEQ	INRET	;DON'T STORE NULLS
	CMP	#177,R0
	BEQ	RUBOUT
	CMP	#175,R0
	BNE	NOT175
	MOV	#33,R0	;ALTMODE CONVERTED TO ESCAPE
NOT175:	TST	(R1)	;QUOTE MODE?
	BEQ	NOTQT
	SUB	#401,(R1)	;DECREMENT BOTH BYTES OF QUOTFL
	TSTB	(R1)	;IS RIGHT BYTE ZERO YET (GOT ENOUGH CHARS?)
	BNE	STORE	;NO
	CLR	(R1)	;FINISHED, CLEAR FLAG
	BR	STORE

NOTQT:	MOV	#QTBL,R2	;TABLE OF CHARS CAUSING QUOTE MODE (&,",')
NOTQTL:	TSTB	(R2)
	BEQ	NOTQ	;DONE SEARCHING TABLE
	CMPB	R0,(R2)+
	BNE	NOTQTL
	ADD	#177400-QTBL,R2	;LOADS R2 WITH -1,,N, WHERE N =
		;NUMBER OF CHARS TO FOLLOW
	MOV	R2,(R1)	;PLACE IT IN QUOTFL
NOTQ:	CMP	#140,R0
	BHIS	CHKALT	;NOT LOWER CASE
	CMP	#172,R0
	BLO	CHKALT	;TOO BIG FOR LETTER
	SUB	#40,R0	;CONVERT TO UPPER CASE
CHKALT:	CMP	#33,R0	;ALT NOT A COMMAND,
	BEQ	ESCAPE	;HANDLED ON THIS LEVEL INSTEAD
	TSTB	ALTF	;IS THIS A CHAR FOLLOWING ALTMODE(S)?
	BEQ	NOTALT
	INCB	DONEF	;DONE WHEN READ ANY CHAR FOLLOWING ALTMODES
NOTALT:	MOV	#NOALT,R1
NTALTL:	TSTB	(R1)	;SEARCH COMMAND TABLE FOR CHAR
	BEQ	STORE	;FELL OFF END OF TABLE
	CMPB	R0,(R1)+
	BNE	NTALTL
	INCB	DONEF	;GOT CHAR IN TABLE
	BR	STORE
ESCAPE:	INCB	ALTF
STORE:	CMP	INPNTR,#IBUFFE-1
	BHIS	INRET	;ALREADY AT END OF BUFFER
	MOVB	R0,@INPNTR	;STORE CHAR
	INC	INPNTR
INRET:	CLRB	@INPNTR	;SO STRING ENDED WITH 0 BYTE
	MOV	(SP)+,R1
	RTS	PC	;R0 CONTAINS CHAR TO BE ECHOED

RUBOUT:	CMP	INPNTR,#IBUFF	;RUBBING PAST BEGINNING?
	BLOS	INRET1		;YES, IGNORE AND ECHO BELL
	DEC	INPNTR
	MOVB	@INPNTR,R0
	JSR	PC,TYPCH	;ECHO RUBBED CAHR
	TST	(R1)
	BEQ	RUB1
	ADD	#401,(R1)	;INCREMENT BOTH BYTES OF QUOTFL
	TSTB	1(R1)		;IS LEFT BYTE ZERO YET?
	BNE	INRET
	CLR	(R1)		;RUBBED PAST &, ", OR ' -- CLEAR QUOTFL
	BR	INRET
RUB1:	CMP	#33,R0
	BNE	INRET
	DECB	ALTF		;RUBBED OUT AN ALTMODE
	BR	INRET
INRET1:	JSR	R5,TYPE
	.ASCIZ	/  ?/
	.EVEN
	BR	INRET

QTBL:	.BYTE	''		;TABLE OF QUOTING CHARS, TAKING 1, 2, 3 ARGS
	.BYTE	'"
	.BYTE	'&
	.BYTE	0

QUOTFL:	0	;WHEN SET, LEFT BYTE = -1, RIGHT BYTE = # OF
		;QUOTED CHARS TO FOLLOW SO RUBOUT OR ENOUGH CHARS
		;WILL EXIT FROM QUOTE MODE
ALTF:	.BYTE	0	;INC-ED WHEN ALTMODE READ
DONEF:	.BYTE	0	;INC-ED WHEN CHAR READ FOLLOWING ALTMODE(S),
		;OR CHAR IN NOALT TABLE

READCH:	TSTB	O.RCSR
	BPL	READCH	;WAIT FOR TTY INPUT
READCI:	MOVB	O.RDB,R0	;GET CHAR
	CLRB	O.RDB	;CLEAR FLAGS

	BIC	#177600,R0
	CMPB	#KILCHR,R0
	BEQ	READBK
	RTS	PC
READBK:	MOV	#O.UR0,SP
	MOV	#KILCHR,R0
	CLRB	OPENF
	JSR	PC,TYPCH
	JMP	DCDERR
;TYPE A STRING R5 POINTS TO AND ENDED BY 0

TYPE:	MOV	R0,-(SP)
TYPE1:	MOVB	(R5)+,R0
	BEQ	TYPR
	JSR	PC,TYPCH
	JSR	PC,INCHK
	BR	TYPE1

TYPR:	TSTB	(R5)+	;GET ON EVEN ADDRESS
	BIC	#1,R5
	MOV	(SP)+,R0
	RTS	R5	;SINCE ARGUMENTS FOLLOW CALL, USE R5, NOT PC

;THIS ROUTINE ECHOES ANYTHING TYPED WHILE RUG NOT REALLY
;LISTENING, THEN GETS REST OF COMMAND UNTIL COMMAND CHAR SEEN.

INPUT:	MOV	#TBUFF,R1
	MOV	#IBUFF,INPNTR
	CLR	ALTF		;INITIALIZE IN
INPUT1:	MOVB	(R1)+,R0
	BEQ	INPUT3		;END OF STRING MARKED WITH ZERO BYTE
	JSR	PC,IN		;PROCESS CHARS THAT HAVE BEEN STORED
	TSTB	DONEF
	BEQ	INPUT1		;COMMAND NOT FOUND
	MOV	#TBUFF,R0
INPUT2:	MOVB	(R1)+,(R0)+	;PACK DOWN INPUT BUFFER
	BNE	INPUT2
	DEC	R0
	MOV	R0,TNPNTR
	BR	INPUTR

INPUT3:	MOV	#TBUFF,TNPNTR	;BUFFER IS NOW EMPTY
	CLRB	TBUFF
INPUT4:	JSR	PC,READCH
	JSR	PC,IN		;GET NEW CHAR
	TSTB	DONEF
	BEQ	INPUT4

INPUTR:	MOV	INPNTR,SINPTR	;SAVE RESULTS FOR COMMAND DECODER
	MOVB	ALTF,SALTF
	RTS	PC	;BUT DON'T CALL "IN" UNTIL IBUFF ALL PROCESSED

TNPNTR:	TBUFF
INPNTR:	IBUFF	;POINTER INTO IBUFF
IBUFF:	.BLKW	30	;BYTES ARE SUCCESSIVE CHARACTERS TYPED IN
IBUFFE==.
TBUFF:	0
	.BLKW	30-1
TBUFFE==.
;TYPE CHAR IN R0, MAKE CONTROL CHARS ^CHAR,
;ALTMODE BECOMES $, TABS ARE 3 SPACES

GET1UC:	MOVB	TBUFF,R0	;SEE IF ANY IN BUFFER
	BEQ	GTUC2
	MOV	R1,-(SP)
	MOV	#TBUFF-1,R1	;SHIFT BUFFER DOWN
GTUC1:	CMPB	(R1)+,(R1)+
	MOVB	(R1),-(R1)
	BNE	GTUC1
	MOV	R1,TNPNTR
	MOV	(SP)+,R1
	BR	GTUC3
GTUC2:	JSR	PC,READCH
GTUC3:	CMP	#140,R0
	BGE	TYPCHS
	CMP	R0,#173
	BGE	TYPCHS
	SUB	#40,R0
TYPCHS:	CMP	#12,R0	;ENTRY HERE SUPPRESSES TYPING OF CR AND LF
	BEQ	TYPCH5
	CMP	#15,R0
	BEQ	TYPCH5
TYPCH:	MOV	R0,-(SP)
TYPCHW:	TSTB	O.TCSR	;WAIT FOR TTO
	BPL	TYPCHW
	BIC	#200,R0	;TAKE OUT 200 BIT (PARITY)
	CMPB	#7,R0
	BEQ	TYPCH3	;BELL, DON'T CONVERT TO ^G
	CMPB	#12,R0
	BEQ	TYPCH3	;LF, DON'T CONVERT TO ^J
	CMPB	#15,R0
	BEQ	TYPCH3	;CR, DON'T CONVERT TO ^M
	CMPB	#DNTTYP,R0
	BEQ	TYPCH4	;CHAR CODE TO SUPPRESS
	CMPB	#11,R0
	BNE	TYPCH1
	JSR	PC,TYP3SP	;TAB BECOMES 3 SPACES
	BR	TYPCH4

TYPCH1:	CMPB	#33,R0
	BEQ	TYPCH2
	CMPB	#175,R0
	BNE	TYPC2A		;ESCAPE BECOME ALTMOE ALSO
TYPCH2:	MOV	#'$,R0		;ALTMODE BECOMES $
TYPC2A:	CMPB	#40,R0
	BLOS	TYPCH3
	MOV	#'^,O.TDB	;CONTROL CHAR
	BIS	#100,R0
	JSR	PC,TYPCH
	BR	TYPCH4

TYPCH3:	MOV	R0,O.TDB
TYPCH4:	MOV	(SP)+,R0
TYPCH5:	RTS	PC

TYP3SP:	JSR	5,TYPE	;TYPE 3 SPACES
	.ASCIZ	/   /
	.EVEN
	RTS	PC
;RADDIX-50 CODE
;R-50	CHAR	ASCII
;0	BLANK	DNTTYP OR 40
;1-32	A-Z	101-132
;33	$	44
;34	.	56
;35	%	45
;36-47	0-9	60-71

R50TAB:
BLANK:	.BYTE	DNTTYP	;SPACE OR DNTTYP
	.BYTE	'A,'B,'C,'D,'E,'F,'G,'H,'I,'J,'K,'L,'M
	.BYTE	'N,'O,'P,'Q,'R,'S,'T,'U,'V,'W,'X,'Y,'Z
	.BYTE	'$,'.,'%
	.BYTE	'0,'1,'2,'3,'4,'5,'6,'7,'8,'9

;CONVERT ASCII CHAR IN R0 TO RADIX-50
;CLOBBERS R1 BUT SETS N IF NOT RADIX-50
ASCR50:	CLR	R1
ASCR51:	INC	R1	;WON'T MATCH WITH BLANK
	CMPB	R50TAB(R1),R0
	BEQ	ASCR52	;FOUND CHAR
	CMP	#47,R1
	BNE	ASCR51	;KEEP LOOKING
	NEG	R1	;NOT RADIX-50, RETURN NEGATIVE VALUE
ASCR52:	MOV	R1,R0
	RTS	PC

;TYPES AINST AND AINST+2, WHICH ARE RADIX-50
TYPE50:	MOVB	#DNTTYP,BLANK	;ZEROS BECOME DNTTYP
TYP50A:	MOV	#BUFF,R3
	MOV	AINST,R1
	JSR	5,UNPACK
	MOV	AINST+2,R1
	BEQ	TYP50B
	JSR	5,UNPACK
TYP50B:	CLRB	(R3)+
	INC	R3
	BIC	#1,R3
	MOV	#205,(R3)	;205 IS RTS R5 -- MAKE IT RTS PC? ***
	JSR	5,TYPE

BUFF:	0	;WHEN MAXIMALLY FULL, HAS 6 BYTES OF DATA,
	0	;ONE ZERO BYTE, ONE WASTED BYTE, AND
	0	;RTS 5
	0
	0

AINST:	0	;ARG TO TYPE50, USUALLY RADIX-50 FOR DECODED INSN
	0
;THIS ROUTINE CONVERTS RAD50 TO ASCII
;NUMB GIVEN AND RETURNED IN R0

FIFASC:	TST	R0	;BUM -- CAN USE R50TAB ***
	BNE	FIFNO
	MOVB	BLANK,R0	;EITHER SPACE OR DNTTYP
	BR	NUTHNG

FIFNO:	CMP	#33,R0
	BLT	NUMB
	BEQ	DOLR
	ADD	#56,R0	;LETTER, 57+11+11=101
NUMB:	ADD	#11,R0	;PERIOD AND NUMBERS ARE +22
DOLR:	ADD	#11,R0	;DOLLAR SIGN (ALT MODE)
NUTHNG:	RTS	5

;THIS ROUTINE TAKES THREE CHARS IN R1
;RETURNS 3 ASCII, AND DEPOSITS WHERE R3 POINTS

UNPACK:	MOV	#3100,R2
	JSR	5,SUBLOP
	MOVB	R0,(R3)+
	MOV	#50,R2
	JSR	5,SUBLOP
	MOVB	R0,(R3)+
	MOV	R1,R0
	JSR	5,FIFASC
	MOVB	R0,(R3)+
	RTS	5

SUBLOP:	CLR	R0
SUBLP1:	CMP	R2,R1
	BHI	FIFASC
	SUB	R2,R1
	INC	R0
	BR	SUBLP1
REEVAL:	MOV VAL,-(SP)		;RECURSIVE ENTRY POINT TO EVAL
	JSR PC,EVAL0
	MOV (SP)+,VAL
	RTS PC
;EVAL EVALUATES A STRING POINTED TO BY PARSEP, INCLUDING
;NUMBERS, SYMBOLS, QUOTED CHARS, SPACE=+, -, * AND ! (DIVIDE).
;IT SETS LENTYI, REGINF, UNDEFS, RETURNS TERMINATOR IN R0,
;ARG FLAG (0 IF NO ARG) IN R2, AND VALUE IN BOTH R4 AND VAL+0,+2,+4.
;RADIX-50 OF AN UNDEFINED SYMBOL IS IN R50SYL+0,+2.
;EVAL EITHER RTS PC'S OR ABORTS TO RUG'S TOP LEVEL.

EVAL:	CLR	LENTYI
	CLR	NOINST
EVAL0:	CLRB	REGINF
	CLRB	UNDEFS	;UNDEFINED SYMBOL FLAG
	CLR	ARGFLG
	CLR	VAL1
	CLR	VAL2
	MOV	#'+*401,OPER1	;SET OPER1 AND OPER2 TO +
;AT EVAL1, RUG HAS VAL1 OPER1 VAL2 OPER2 AND IS LOOKING FOR NEXT VALUE, VAL
EVAL1:	CLR	VAL
	CLR	DECIMF
	CLR	NOTNUM
	CLR	OCTVAL
	CLR	DECVAL
	CLR	R50SYL
	CLR	R50SYL+2
	MOV	#R50SYL-2,R50LOC
	MOV	#3100,R50NUM
	MOV	PARSEP,SPARSE
	MOVB	@PARSEP,R0	;LOOK AT FIRST CHAR OF SYLLABLE
	CMP	#'',R0
	BEQ	SQUOT	;SINGLE QUOTE
	CMP	#'",R0
	BEQ	DQUOT	;DOUBLE QUOTE
	CMP	#'&,R0
	BEQ	AMPER	;AMPERSAND
EVAL2:	MOVB	@PARSEP,R0
	JSR	PC,ASCR50	;CONVERT TO RADIX-50
	BMI	EVAL4	;NOT RADIX-50, END OF SYLLABLE
	CMP	#35,R0	;IS CHAR % IN RADIX-50?
	BEQ	PERCNT	;YES
	JSR	PC,INR50
	MOVB	@PARSEP,R0	;PICK UP CHAR AGAIN
	CMP	#'.,R0
	BEQ	DCMLPT	;PERIOD MAY BE A DECIMAL POINT
	SUB	#'0,R0
	BMI	ALPHA	;$ IS SYMBOL CONSTITUENT, LIKE A-Z
	CMP	#9,R0
	BLO	ALPHA	;A-Z
	MOV	#OCTVAL,R1	;CHAR IS A DIGIT
	ASL	(R1)	;MAYBE THIS AND CHKOP COULD USE R2 INSTEAD ***
	ASL	(R1)
	ASL	(R1)
	ADD	R0,(R1)+	;+ IS LIKE MOV #DECVAL,R1
	ASL	(R1)
	ADD	(R1),R0
	ASL	(R1)
	ASL	(R1)
	ADD	R0,(R1)
EVAL3:	INC	PARSEP	;DONE WITH THIS CHAR
	BR	EVAL2	;PICK UP NEXT CHAR

PERCNT:	BISB	#1,REGINF
	BR	EVAL3

DCMLPT:	INC	DECIMF
	BR	EVAL3

ALPHA:	INC	NOTNUM
	BR	EVAL3

OCTVAL:	0	;ACCUMULATED OCTAL NUMBER
DECVAL:	0	;DECIMAL, MUST BE AT OCTVAL+2
OPER1:	.BYTE	0	;FIRST ARITHMETIC OPERATOR
OPER2:	.BYTE	0	;SECOND
PARSEP:	0	;PARSING POINTER INTO IBUFF
REGINF:	.BYTE	0	;0, OR 1 IF TYPED-IN STRING IS A REGISTER
;REGINF BISB-ED WHEN % READ OR IF O.FLGS SAYS TO,
;AND TURNED OFF WHEN EVAL EXITS IF INSN PARSED
UNDEFS:	.BYTE	0	;NONZERO IF UNDEFINED SYMBOL READ
VAL1:	0	;TEMPORARY VALUES IN PARSING
VAL2:	0
;ACCUMULATE THE RADIX-50 SYMBOL
INR50:	CMP	#3100,R50NUM	;ABOUT TO DO FIRST CHAR IN WORD?
	BNE	INR50A	;NO
	TST	R50SYL+2	;ALREADY HAVE 6 CHARS?
	BNE	INR50B	;YES, IGNORE EXTRA CHARS
	ADD	#2,R50LOC
INR50A:	ADD	#3100,@#R50SYL-2	;ADD 3100, 50, OR 1 * CHAR INTO SYMBOL
R50NUM==.-4
R50LOC==.-2
	DEC	R0
	BNE	INR50A
	MOV	R50NUM,R0	;THIS MAGIC CYCLES THRU 3100, 50, 1, 3100, ...
	ASR	R0
	ADD	R50NUM,R0
	ASR	R0
	RORB	R0
	MOVB	R0,R0	;SIGN EXTEND IF R50NUM WAS 1
	ASR	R0
	BIC	#174626,R0	;LEAVE ONLY BITS IN 3100+50+1
	MOV	R0,R50NUM
INR50B:	RTS	PC

R50SYL:	0	;TWO WORDS OF RADIX-50 CHARACTERS READ BY EVAL
	0	;C1 C2 C3 C4 BECOMES C1*50*50+C2*50+C3 IN R50SYL,
		;AND C4*50*50 IN R50SYL+2
O.SYL==R50SYL

DQUOT:	INC	PARSEP	;GO ON TO NEXT CHAR
	MOVB	@PARSEP,VAL
	SWAB	VAL
SQUOT:	INC	PARSEP
	MOVB	@PARSEP,VAL
SQUOT1:	INC	PARSEP
	BR	EVAL5	;HAVE VALUE

AMPER:	INC	PARSEP
	MOVB	@PARSEP,R0
	JSR	PC,ASCR50
	BMI	ABORT2	;NOT RADIX-50
	JSR	PC,INR50
	CMP	#3100,R50NUM
	BNE	AMPER	;HAVEN'T GOT 3 CHARS YET
	MOV	R50SYL,VAL
	BR	SQUOT1

ABORT2:	JMP	DCDERR	;FATAL ERROR IN EVAL
EVAL4:	CMP	#34*50*50,R50SYL	;END OF SYLLABLE
	BEQ	EVALS	;SYLLABLE IS JUST .
	TST	#0
NOTNUM==.-2	;NONZERO SAYS A-Z OR $ SEEN, SO SYLLABLE IS NOT A NUMBER
	BNE	EVALS	;DO SYMBOL LOOK-UP
	MOV	OCTVAL,VAL
	TST	#0
DECIMF==.-2	;NONZERO SAYS . SEEN, SO NUMBER IS DECIMAL
	BEQ	EVAL5	;HAVE VALUE
	MOV	DECVAL,VAL
EVAL5:	SUB	PARSEP,#0	;HAVE VALUE OF NEW SYLLABLE
SPARSE==.-2	;SAVED PARSEP AT START OF SYLLABLE
	SUB	SPARSE,ARGFLG	;INCREASE ARGFLG IF NON-NULL SYLLABLE
	MOVB	OPER2,R0
	JSR	PC,CHKOP
	JMP	@EVAL5A(R1)

EVAL5A:	OP2PM	;OPER2 IS A SPACE
	OP2PM	;+
	OP2PM	;-
	OP2T	;*
	OP2D	;!

OP2T:	MLTPLY	VAL2,VAL,VAL2	;VAL2 _ VAL2 * VAL
	BR	OP2PM2

OP2D:	DIVIDE	VAL2,VAL,VAL2,R4	;VAL2 _ VAL2 / VAL
	BR	OP2PM2

OP2PM:	CMPB	#'-,OPER1	;OPER2 IS + OR -, SO DO OPER1
	BNE	OP2PM1
	NEG	VAL2
OP2PM1:	ADD	VAL2,VAL1
	MOV	VAL,VAL2
	MOVB	R0,OPER1
OP2PM2:	MOVB	@PARSEP,R0
	JSR	PC,CHKOP
	BMI	EVAL6	;NOT A KNOWN OPERATOR
	BEQ	OP2PM3	;BR IF OP IS ONLY A SPACE
	INC	ARGFLG	;LEGAL OPERATOR IMPLIES AN ARG
OP2PM3:	MOVB	R0,OPER2
	INC	PARSEP
	JMP	EVAL1	;GO GET ANOTHER NEW SYLLABLE

EVAL6:	MOVB	OPER1,R0	;CLEAN UP AND EXIT
	JSR	PC,CHKOP
	JMP	@EVAL6A(R1)

EVAL6A:	OP1P
	OP1P
	OP1M
;OPER1 CAN NEVER BE * OR !

OP1P:	ADD	VAL2,VAL1
	BR	OP1M1

OP1M:	SUB	VAL2,VAL1
OP1M1:	MOV	VAL1,VAL
;IF ININST IS MADE TO RETURN 1ST WORD IN R4, AND 2ND AND 3RD IN VAL+2 AND VAL+4, THEN OTHER THINGS
;ARRIVING AT EVAL5 CAN EASILY HAVE VALUE IN R4 AND A FEW WORDS CAN BE BUMMED OUT ***
EVAL7:	MOVB	@PARSEP,R0	;PICK UP TERMINATOR
	MOV	#0,R2
ARGFLG==.-2	;ZERO IF NO ARGUMENT
;ARGFLG IS # CHARS PARSED, BUT NOT SPACES OR CHARS IN UNDEFINED SYMBOL
	MOV	VAL,R4
	TSTB	UNDEFS
	BEQ	CHKOP3	;RTS
	JMP	ECOLON	;UNDEFINED SYMBOL, SO BETTER BE COLON COMMAND
;EVALUATE SYMBOL
EVALS:	JSR	PC,O.SYLL	;CAN JUST PUT O.SYLL HERE AFTER ITS CALL IN DEFN GOES AWAY ***
	BEQ	EVALS2	;NOT FOUND, MAYBE AN INSTRUCTION
	BIT	R3,@O.FLGS	;TEST FOR REGISTER
	BEQ	EVALS1
	BISB	#1,REGINF	;REGISTER
EVALS1:	MOV	R4,VAL
	BR	EVAL5	;HAVE VALUE

EVALS2:	TST	#0
NOINST==.-2	;NONZERO IF WITHIN AN INSTRUCTION PARSE
	BNE	EVALS4	;DON'T PARSE SYLLABLE AS INSTRUCTION
	MOV	DOT,CURADR
	MOV	REGINF,-(SP)
	MOV	VAL1,-(SP)
	MOV	VAL2,-(SP)
	MOV	OPER1,-(SP)
	INC	NOINST
	JSR	PC,ININST	;ONLY CALL
	CLR	NOINST
	MOV	(SP)+,OPER1
	MOV	(SP)+,VAL2
	MOV	(SP)+,VAL1
	MOV	(SP)+,REGINF
	JMP	EVAL5	;HAVE VALUE

EVALS3:	TST	(SP)+		;UNDO ININST CALL
	MOV	(SP)+,OPER1
	MOV	(SP)+,VAL2
	MOV	(SP)+,VAL1
	MOV	(SP)+,REGINF
EVALS4:	INCB	UNDEFS	;UNDEFINED
	BR	EVAL6


;CHECK ARITHMETIC OPERATOR IN R0
CHKOP:	CLR	R1
CHKOP1:	CMPB	CHKOPT(R1),R0
	BEQ	CHKOP2	;FOUND IT
	INC	R1
	TSTB	CHKOPT(R1)
	BNE	CHKOP1	;NOT FINISHED SEARCHING
	NEG	R1	;NEGATIVE IF NOT A LEGAL OP,
CHKOP2:	ASL	R1	;OTHERWISE A USEFUL INDEX QUANTITY
CHKOP3:	RTS	PC

CHKOPT:	.BYTE	40,'+,'-,'*,'!,0
SCRTCH:	0

MULT:	MOV	R0,-(SP)	;SCRTCH _ SCRTCH * R4
	MOV	R1,-(SP)
	CLR	R0
MULT1:	CLC
	ROR	R4
	BCC	NOAD
	ADD	SCRTCH,R0
NOAD:	ASL	SCRTCH
	TST	R4
	BEQ	DIVD2
	BR	MULT1

SIGNF:	0
DIVD0:	MOV	R0,-(SP)	;SCRTCH _ SCRTCH / R4
	MOV	R1,-(SP)
	CLR	SIGNF
	MOV	#1,R1
	CLR	R0
	TST	R4
	BEQ	DIVD2	;/0 YEILDS 0
	BGT	DIVD3
	NEG	R4
	COM	SIGNF
DIVD3:	TST	SCRTCH
	BGE	DIVD4
	NEG	SCRTCH
	COM	SIGNF
DIVD4:	ASL	R1
	ASL	R4
	BPL	DIVD4
SHFTDN:	CLC
	ROR	R1
	BEQ	DIVD5
	ROR	R4	;CARRY CAN'T BE 1 AT THIS PT.
	CMP	R4,SCRTCH
	BHI	SHFTDN
	ADD	R1,R0
	SUB	R4,SCRTCH
	BR	SHFTDN

DIVD5:	MOV	SCRTCH,R4	;ABS VALUE OF REMAINDER
	TST	SIGNF
	BGE	DIVD2
	NEG	R0
DIVD2:	MOV	R0,SCRTCH
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	PC

;ABOVE ARE CRETINOUS MULTIPLY AND DIVIDE ROUTINES FOR EAE-LESS LOSERS
;MAYBE EVENTUALLY I'LL REWRITE THEM
;DIVIDE NEEDS TO BE FAST FOR /13 IN DISK ADDRESS CALCULATIONS
DADRS	=	30000
CADRS	=	1000
;READ IN COMPLETE BLOCK WITH BEGINNING AND END
;POINTS FUDGED TO MAKE DAR AND WC HAPPY
;TRANSFER CORE TO CORE
;WRITE OUT COMPLETE BLOCK

;ADRS=%1 DON'T CLOBBER IT

OUTBLK:	MOV	ADRSS,R0
	CLC
	ROR	R0
	MOV	R0,R3
	BIC	#MASK,R3
	MOV	R3,OUTDAR
;R3 HAS DAR ADRESS
;R0 IS WHAT I WISH IT COULD BE
	SUB	R0,R3
	MOV	R1,R2
	CLC
	ROR	R2
	SUB	R2,R3
	BIC	#MASK,R3
	MOV	R3,OUTWC
.IFNZ	F.HD
	ADD	#SPRG,OUTDAR
.ENDC
.IFZ	F.HD
	MOV	OUTDAR,MDSAV
	JSR	PC,MDCNVT
	MOV	#SPRG,MDSAV+2
	JSR	PC,MDADD
	MOV	MDSAV,OUTDAR
.ENDC
	MOV	#5,OUTFN
	JSR	PC,OUTBD
	MOV	ADRSS,R2
	BIC	#177000,R2
	MOV	R2,R3
	BIC	#177776,R2
	ADD	#CADRS,R2
	ADD	#DADRS,R3
TRASF:	MOVB	(R2)+,(R3)+
	CMP	R2,R1
	BLT	TRASF
	MOV	#3,OUTFN
;FALL INTO OUTBD
OUTBD:
.IFNZ	F.HD
	JSR	5,FDISK
	0	;DAE
OUTDAR:	0
	DADRS
OUTWC:	0
OUTFN:	0
.ENDC
.IFZ	F.HD
	JSR	5,MDISK
OUTDAR:	0
	DADRS
OUTWC:	0
OUTFN:	0
.ENDC
	RTS	PC
STBLK:	MOV	#4,R2
SBLK:	JSR	PC,ACK
STBLK1:	JSR	PC,XREAD
	DECB	BYTE
	BNE	STBLK1
GTONE:	JSR	PC,XREAD
	MOV	#5,BCOUNT
	CLR	CKSM
	JSR	PC,XGWORD
	SUB	BCOUNT,WORD
	CMP	BCOUNT,WORD
	BEQ	JMPBLK
	MOV	WORD,BCOUNT
	JSR	PC,XGWORD
	MOV	WORD,ADRSS
	MOV	#CADRS,ADRS
	ROR	WORD
	ADC	ADRS	;SO WILL BE ODD IF ODD, ETC

LDDATA:	JSR	PC,XGWORD
	TST	BCOUNT
	BGT	LDLP
	BLT	CHECKS
	MOVB	WORD,(ADRS)+
CHECKS:	INCB	CKSM
	BNE	BAD
	RTS	PC
LDLP:	MOVB	WORD,(ADRS)+
	MOVB	WORD+1,(ADRS)+
	BR	LDDATA
ADRSS:	0

JMPBLK:	JSR	PC,XGWORD
	MOV	WORD,ADRS
	JSR	PC,XGWORD
	INCB	CKSM
	BNE	BAD
	JSR	PC,ACKOK
	INC	CKSM	;SO NONZERO
	RTS	PC

BAD:	MOV	#6,R2	;TELL 10 NOT OK
	BR	SBLK

ACKOK:	MOV	#4,R2
ACK:	.IFNZ TEN11
	TST TEN11S
	BNE ACKT
.ENDC
	TSTB	TSCR
	BPL	ACK
	MOV	R2,TBUF
	RTS	PC
.IFNZ TEN11
ACKT:	TST TENCHR
	BNE ACKT
	MOV R2,TENCHR
	RTS PC
.ENDC
PSTRT:	MOV	#L.READ,L.PTR
	JSR	PC,PBLOCK
	TSTB	L.CKSM
	BNE	L.DUN
	JSR	PC,OUTBLK
	BR	PSTRT

PBLOCK:	CLR	CKSM
	JSR	PC,L.READ
	CMP	L.BYT,#EOT
	BNE	PBLK2
	HALT
PBLK2:	DECB	L.BYT	;CHECK FOR +1 (START OF BLOCK)
	BNE	PBLOCK
	JSR	PC,L.READ

	JSR	PC,L.GWRD
	MOV	R4,L.BC
	SUB	#4,L.BC
	CMP	#2,L.BC
	BEQ	PJUMP
	JSR	PC,L.GWRD
	MOV	R4,ADRSS
	MOV	#CADRS,L.ADR
	ROR	R4
	ADC	L.ADR

PLDATA:	JSR	PC,L.READ
	BGE	PLD1
	TSTB	L.CKSM
	BNE	CKSMER
	RTS	PC
PLD1:	MOVB	L.BYT,(L.ADR)+
	BR	PLDATA
CKSMER:	JSR	5,TYPE
	.ASCIZ	/C!/
	.EVEN
	HALT
	BR	PBLOCK

PJUMP:	JSR	PC,L.GWRD
	JSR	PC,L.READ
	TSTB	CKSM
	BNE	CKSMER
	INC	CKSM
	MOV	R4,ADRES
	RTS	PC

L.DUN:	JSR	PC,REINIT
	JSR	PC,L.LD2
	BR	DUN4
	.STITLE	PDP11 CONSOLE
	TKS=	O.RCSR
	TKB=	O.RDB
	TPS=	O.TCSR
	TPB=	O.TDB
	RCSR=	174000
	RBUF=	174002
	TSCR=	174004
	TBUF=	174006
;ROUTINES TO GET FILES FROM STRANGE PLACES

STARTZ:	JSR	PC,ZZERO
START:	MOV	#RUGFNT,RELOC
.IFNZ M1145
	MOV	#"KI,R0		;CHANGE TO KERNAL I MODE
	JSR	PC,CHMODE
.ENDC
.IFNZ FMH
	JSR	PC,GETFN	;GET FILE NAME AND DEVICE
	BEQ	STAR.1
	JMP	LOADF		;GET FILE FROM DISK
STAR.1:	CMPB	#'P,DPODEV
	BEQ	PSTRT
.IIF NZ TEN11,CLR TEN11S
	CMPB	#'T,DPODEV
.IFF
	JSR	PC,GET1UC
	CMP	#'P,R0
	BEQ	PSTRT
.IIF NZ TEN11,CLR TEN11S
	CMP	#'T,R0
.ENDC
	BEQ	STARTT
.IFNZ TEN11
	.IIF NZ FMH,CMPB #'M,DPODEV
	.IIF Z  FMH,CMP #'M,R0
	BEQ .+6
.ENDC
	JMP	O.ERR
.IFNZ TEN11
TENCNT==200
TENCHR==TENCNT+4
TENBUF==TENCHR+4
	CLR TENCNT
	CLR TENCHR
	MOV #TENBUF,TENPNT
	MOV PC,(PC)+	
TEN11S:	0
.ENDC
STARTT:	CLR	R0
	MOV	#DCSPD+1,RCSR
	MOV	#DCSPD+1,TSCR	;INITIALIZE THE LINES
	MOV	#ABUF,R3
.IFNZ TEN11
	MOVB #'N,NCHAR		;INITIALIZE IT
	TST TEN11S		;LOADING THROUGH THE 10-11
	BEQ .+10		;SKIP IT
	MOVB #'M,NCHAR		;CHANGE IT TO MLODER.
.ENDC
.IFNZ FMH
	MOV	R3,R4
STAT.1:	TSTB	(R4)+
	BNE	STAT.1
	CLRB	(R4)
	MOVB	#15,-(R4)
.ENDC
	JSR	PC,SEND		;LOGIN TO PDP-10
	JSR	PC,CNSL.1	;LET USER TYPE FILE NAME
SBLKAG:	JSR	PC,STBLK1	;SO DON'T SEND EXTRA 4
SBLKG2:	TSTB	R0
	BNE	DUN3		;MEANS JUMP BLOCK AND FINISHED
	JSR	PC,OUTBLK	;WRITE OUT ON DISK
	JSR	PC,STBLK	;ACK WITH A 4, THEN READ ANOTHER BLOCK
	BR	SBLKG2
DUN3:	MOV	R1,ADRES
	CLR	R4
	JSR	R5,ACN
	5
	CLR	R0
	JSR	PC,XSTBLK	;NOW LOAD SYMBOLS INTO CORE, WITH ACKNOWLEDGES
DUN4:	JSR	PC,DSTBL
	JSR	PC,REINIT
	JMP	O.DCD

ABUF:	.BYTE	32	;^Z
	.ASCII	/:LOGINPDP11:/
NCHAR:	.ASCII /NLODER/
DPONAM:	.ASCIZ	/DAZZEL/	;DEFAULT FILE NAME
	.EVEN
	.BLKW	6
SEND:	JSR	PC,OUT10	;SEND CONTROL-Z
	JSR	PC,WAIT10	;WAIT FOR SYSTEM TO RESPOND
	JSR	PC,WAIT10
SEND3:	JSR	PC,OUT10	;SEND REST OF BUFFER
	TSTB	(R3)
	BNE	SEND3
	RTS	PC

OUT10:	TSTB	TSCR
	BPL	OUT10
	MOVB	(R3)+,TBUF
	RTS	PC

WAIT10:	TSTB	RCSR	;TIMING THING
	BPL	WAIT10
	MOVB	RBUF,R1
	RTS	PC
.IFNZ	FPP
;QUICK HACK TO EXAMINE FPP AC CONTENTS -- SHOULD BE REWRITTEN OR REPLACED ***
FPPACS:	TST	R2	;TYPE AN FPP AC
	BEQ	FPPERR	;NO ARG
	CMP	#6,R5
	BLE	FPPERR	;BAD ARG
	BIC #7,FPPAC
	BIS	R5,FPPAC	;SET LDD TO GET FROM FPP REGISTER
	STFPS	@#FPPST
	SETD		;SELECT DOUBLE PRECISION
	STD	0,@#FPPSV0
FPPAC:	LDD	R0,R0	;THIS IS MODIFIED BY CODE ABOVE
	STD	0,@#FPPVAL
	LDD	@#FPPSV0,0
	LDFPS	#0	;RESTORE STATUS
FPPST==.-2
	JSR	PC,TYP3SP
	MOV	FPPVAL,R0
	JSR	5,TYPNUM
	JSR	PC,TYP3SP
	MOV	FPPVAL+2,R0
	JSR	5,TYPNUM
	JSR	PC,TYP3SP
	MOV	FPPVAL+4,R0
	JSR	5,TYPNUM
	JSR	PC,TYP3SP
	MOV	FPPVAL+6,R0
	JSR	5,TYPNUM
FPPACR:	JMP	EQUAL2

FPPERR:	JMP DCDERR


FPPSTR:	TST	R2	;PROCESS N$$F
	BEQ	FPPERR
	CMP	#6,R5
	BLE	FPPERR
	JSR	PC,TYP3SP
	BIC	#7,FSTAC
	BIS	R5,FSTAC
	STFPS	@#FPPST
	SETD
	STD	0,@#FPPSV0
	CLRF	FPPVAL
	MOV	#FPPVAL,R3
.FST1:	JSR	PC,EVAL
	TST	R2
	BEQ	.FST2
	MOV	R4,(R3)+
	CMP	R3,#FPPVAL+10
	BLT	.FST1
.FST2:	LDD	FPPVAL,R0
	TSTB	R5
	BEQ	.FST3
FSTAC:	STD	R0,R0
	LDD	FPPSV0,R0
.FST3:	LDFPS	@#FPPST
	BR	FPPACR

FPPSV0:	.BLKW	4
FPPVAL:	.BLKW	4
.ENDC
O.LGDR:

;FOLLOWING COMMANDS PRECEEDED BY ALT
	O.GO	;  G  GO TO ADDRESS K
	O.WSCH	;  W  SEARCH WORD
	O.EFF	;  E  SEARCH EFFECTIVE ADDRESS
	O.BKPT	;  B  BREAKPOINTS
	O.PROC	;  P  PROCEED
	SETCMD
	SETSMD
	SETIMD
	SETR50
	SETASC
	S1ALTO
	S1ALTD
	NOTWDS
	S1ALTA
	S1ALTR
	STARTZ	;ZERO CORE AND LOAD
	START	;DON'T ZERO CORE BUT LOAD
.IIF NZ FMH,	DUMPC	;DUMP IN ABSOLUTE LOADER FORMAT
	ZERO	;ZEROS CORE
	BEGRUG  ;$^D  DUMPS CURRRENT RUG ON INVIOLATE COPY
	BOOT	;$^U  GETS AN INVIOLATE COPY OF RUG
.IFNZ	FPP
	FPPACS
.ENDC
SSFLAG: 	0	;NEED IT ANYWAY AND HAVE TO KILL A LOCATION HERE
;FOLOWING COMMANDS DON'T NEED ALT
	EQUAL	; = PRINTS CURRENT VALUE
	COLON	; : DEFINES SYM
	SLASH	;  /    OPEN WORD
	BACKSL	;  \    OPEN BYTE
	BACKAR	; BACKARROW,  OPEN FIRST ADDRESS
	CRETN	;  CARRIAGE RETURN    CLOSE
	LINEFD	;  <LF>  MODIFY, CLOSE, OPEN NEXT
	OLDSEQ	;  <  RETURN TO OLD SEQUENCE AND OPEN
	UPARR	;  ^  OPEN PREVIOUS
	SETR51	; ] PRINT CURRENT VAL AS RAD50 CHARS
	SETASD	; [ PRINT AS ASCII
	HKILL	; ^K HALF KILL
.IIF Z FMH,	DUMP	;N^D
.IIF Z FMH,	UNSAVE	;N^U
.IIF NZ FMH,	DELET	;^Q
	SSTP	;^N SINGLE STEP
	GOADR	;^A
	TAB	;TAB
	VERS	;TYPE OUT VERSION #
LENGTH:	0	;JUST NEED SPACE THERE FOR NOW (!), LENGTH OF INSN IN DOT, -2 BYTES
	SETCMD	;CHANGE TO CONSTANTS MODE
	SETSMD	;CHANGE TO SYMBOL MODE
	SETIMD	;INSTRUCTION MODE
	SETR50	;RADIX-50 MODE
	SETASC	;ASCII MODE
	S2ALTO	;OCTAL MODE
	S2ALTD	;DECIMAL MODE
	S2ALTA	;INHIBIT TYPING OUT ADDRESSES SYMBOLICALLY
	S2ALTR	;REVERSE ACTION OF $$A
	DELTB	;DELETE BREAKPOINT(S)
	ZEROAL	;ZERO CORE AND SYMBOL TABLE
.IFNZ	M1145
	CHNGMD
	KMODE
	UMODE
.ENDC
.IFNZ	M.HD
.IFZ FMH
	BKUP	;COPY DRIVE 1 TO 0
	GBK	;COPY DRIVE 0 TO 1
	WCHECK	;WRITE CHECK TO SEE IF BOTH DRIVES SAME
.ENDC
.ENDC
.IFNZ FPP
	FPPSTR
.ENDC

O.LGL	=	.-O.LGDR	;LGL MUST EQUAL 2X CHLGT ALWAYS
;
O.LGCH:
;FOLLOWING COMMANDS PRECEEDED BY ALT
ALT:	.BYTE	'G	;  G
	.BYTE	'W	;  W
	.BYTE	'E	;  E
	.BYTE	'B	;  B
	.BYTE	'P	;  P
	.BYTE	'C
	.BYTE	'S
	.BYTE	'I
	.BYTE	']
	.BYTE	'[
	.BYTE	'O
	.BYTE	'D
	.BYTE	'N
	.BYTE	'A
	.BYTE	'R
	.BYTE	'L	;LOAD
	.BYTE	12.	; ^L DON'T ZERO CORE
.IIF NZ FMH,	.BYTE	'Y	;DUMP
	.BYTE	'Z	;ZERO CORE
	.BYTE	4	;^D  SAVE RUG
 	.BYTE	21.	;^U
.IFNZ	FPP
	.BYTE	'F
.ENDC
	.BYTE 0
N1ALC==.-O.LGCH	;NUMBER OF ONE-ALTMODE COMMANDS
NOALT:	.BYTE	'=	;  =
	.BYTE	':	;  :
	.BYTE	'/	;  /
	.BYTE	'\	;  \
	.BYTE	'_	;  BACKARROW
	.BYTE	15	;  CARRIAGE RETURN
	.BYTE	12	;  <LF>
	.BYTE	'<	;  <
	.BYTE	'^	;  ^
	.BYTE	']	; ]
	.BYTE	'[	; [
	.BYTE	13	;^K
.IIF Z FMH,	.BYTE	4	;^D
.IIF Z  FMH,	.BYTE	25	;^U
.IIF NZ FMH,	.BYTE	21	;^Q
	.BYTE	16	;^N
	.BYTE	1	;^A CHANGE GO ADRESS
	.BYTE	11	;TAB
	.BYTE	26	;^V
	.BYTE	0
N0ALC==.-O.LGCH-N1ALC	;NUMBER OF ZERO-ALTMODE COMMANDS
TWOALT:	.BYTE	'C
	.BYTE	'S
	.BYTE	'I
	.BYTE	']
	.BYTE	'[
	.BYTE	'O
	.BYTE	'D
	.BYTE	'A
	.BYTE	'R
	.BYTE	'B
	.BYTE	'Z
.IFNZ	M1145
	.BYTE	'M
	.BYTE	'K
	.BYTE	'U
.ENDC
.IFNZ	M.HD
.IFZ FMH
	.BYTE	4
	.BYTE	21.	;^U
	.BYTE	3	;WRITE CHECK
.ENDC
.ENDC
.IFNZ FPP
	.BYTE 'F
.ENDC
	.BYTE	0
O.CLGT	=	.-O.LGCH		;TABLE LENGTH
.EVEN
CURVAL:	0	;CURRENT VALUE
COUNT:	0
O.T:	.BYTE	0	;  T-BIT FLAG
O.P:	.BYTE	0	;-1 IF NO PROCEED ALLOWED
			;0-7 IF PCEED ALLOWED
	.EVEN
O.CSR1:	.BYTE	0	;SAVE CELL - R C/SR
O.CSR2:	.BYTE	0	;SAVE CELL - T C/SR
	.EVEN
.IFNZ FMH

;THESE ARE THE RUG FILES HANDLEING ROUTINES
;THEY WORK (?) ON LOGO FILE STRUCTURES

;ROUTINE FOR $Y DUMPS CORE INTO FILE IN ABSOLUTE LODER FORMAT

BITAB=2000		;BIT-TABLE GOES HERE
DIRIN=4000	;READ DIRECTORY INTO HERE
DIROUT=6000	;WRITE DIRECTORY FROM HERE
ABSBUF=12000	;ABS FORMATER PUTS STUFF HERE (USES 110000 BYTES)
ABSEND=ABSBUF+102000	;LEAVE ROOM FOR CKSUM
ROOTBK=46		;BLOCK NUMBER OF ROOT DIRECTORY



DPNAM:	.BLKW	10.
DUMPC:	MOV	O.SYME,R0
	MOV	#CSTBL,R2	;ZERO UNUSED PART FOR SMALLER DUMP
	SUB	R2,R0		;COMPUTE WORD COUNT
	ASR	R0
DUMP.1:	CLR	(R2)+
	SOB	R0,DUMP.1
	JSR	PC,FNDFIL	;SEARCH DIRECTORY FOR FILE
	BEQ	DUMP.3		;IT DOESN'T EXIST
	JSR	PC,DELETE	;GET RID OF IT
DUMP.3:	JSR	PC,WRITE	;WRITE IT
DUMP3A:	BIS	#200,DPNAM
	JSR	PC,FINDEN	;WRITE OUT REST OF DIR
	JSR	PC,WTDIR	;WRITE DIRECTORY
	JSR	PC,WTBITS	;WRITE BIT TABLE
DUMP.4:	JSR	R5,SYSDSK	;RELOAD SYMBOL TABLE
.IIF NZ F.HD,	0
	SSTBL
	CSTBL
	-SSTBUL
	5
DUMP.5:	MOV	#O.UR0,SP
	JSR	PC,REINIT
	JMP	O.DCD

;SEARCH DIRECTORIES FOR FILE


FNDFIL:	JSR	PC,DSTBL	;DUMP SYMBOL TABLE
	JSR	PC,GETFN	;GET THE DRIVE AND FILE NAME
	BNE	FNDF.2
FNDF.3:	JSR	R5,TYPE
	.ASCIZ	/BAD DEVICE/
	.EVEN
	BR DUMP.4
FNDF.2:	JSR	PC,RDBITS	;READ BIT-TABLE AND ROOT DIR (BLK 46)
	MOV	#'.,DPNAM	;NAME OF RUGS DIRECTORY
	JSR	PC,RDDIR
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	#DPONAM,R0
	MOV	#DPNAM,R1
FNDF.1:	MOVB	(R0)+,(R1)+
	BNE	FNDF.1
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	JMP	FIND.0		;FIND IT

;GETS FILE NAME UP TO 10. CHARS INTO DPONAM
;ALSO SETS UP DRIVE INFO
;SEZ IF NOT DISK DEVICE

GETFN:	JSR	PC,TYP3SP
	MOV	#DPNAM,R4
	MOV	#22,R5
GETN.1:	JSR	PC,GET1UC
	CMP	#15,R0		;CR-RTN IS END OF NAME
	BEQ	GETN.2
	CMP	#12,R0
	BEQ	GETN.2
	CMP	#177,R0
	BEQ	GETFN		;RUBOUT CHARACTER
	CMPB	#':,R0		;DEVICE NAME?
	BNE	GETN.4
	CMP	#DPNAM+1,R4
	BNE	GETFN
	MOVB	DPNAM,#'F
DPODEV==.-2
	BR	GETFN
GETN.4:	MOVB	R0,(R4)+	;STORE CHAR
	SOB	R5,GETN.1
GETN.2:	JSR	PC,CRLF
	CLRB	(R4)
	CMP	R4,#DPNAM
	BEQ	GETN.5		;USE DEFAULT NAME
	MOV	#DPNAM,R4
	MOV	#DPONAM,R0
GETN.7:	MOVB	(R4)+,(R0)+
	BNE	GETN.7
GETN.5:	MOV	DPODEV,R0
	CMPB	#'P,R0
	BEQ	GETN.6
	CMPB	#'T,R0
	BEQ	GETN.6
.IFNZ TEN11
	CMPB	#'M,R0
	BEQ	GETN.6
.ENDC
.IIF Z F.HD,	BR	GTDR.3
	CMPB	#'F,R0
	BNE	GTDR.3
	MOV	#FXWRT,WCHDSK
	RTS	PC
GTDR.3:
.IIF Z M.HD,	BR	FNDF.3
	MOV	#MVWRT,WCHDSK
	BIC #177600,R0
	SUB	#'0,R0
	BLT	FNDF.3
	CMP #3,R0	;DISK 3 IS THE LAST VALID DISK NOW
	BLT FNDF.3
	ASH #13.,R0
	MOV R0,WCHPLT
	CLZ
GETN.6:	RTS 	PC
;DELETES FILE BEING POINTED AT AFTER ASKING

DELETE:	JSR	R5,TYPE
	.ASCIZ	/FILE EXISTS DELETE?/
	.EVEN
DELE.3:	JSR	PC,GET1UC
	CMPB	R0,#'Y
	BEQ	DELE.4		;HE CHANGED HIS MIND AGAIN
DELE.2:	JMP	DUMP.4
DELE.4:	JSR	PC,CRLF
DELE.1:	JSR	PC,RDDISC
	BEQ	GETN.6		;NO MORE DISCRIPTOR SO RETURN
	MOV	BLKINC,R5	;TURN BLK# INTO BIT TO BE CLEARED
	CLR	R4
	DIV	#20,R4		;WORD NUMBER IN R4
	MOV	#1,R0		;BIT NUMBER IN R5
	ASH	R5,R0
	ASL	R4
	BIC	R0,BITAB+2(R4)
	BR	DELE.1


DELET:	JSR	PC,FNDFIL	;GET NAME
	BEQ	DELERR
	JSR	R5,TYPE
	.ASCIZ	/SURE?/
	.EVEN
	JSR	PC,DELE.3	;DELETE IT
	JMP	DUMP3A
DELERR:	JMP	LODFER
;WRITES OUT FILE GIVEN TO IT A BLOCK AT A TIME BY SUBROUTINE
;WRITES DISCRIPTOR WHERE R1 POINTS
;CLOBERS REGS 2,3,4,5

WRIT.0:	JSR	R5,TYPE
	.ASCIZ	/ENTRY TO LARGE/
	.EVEN
	BR	DELE.2

WRITE:	MOV	R0,-(SP)
	CLRB	(R1)+
	BIC	#1,R1		;GET TO WORD BOUNDARY
	MOV	R1,-(SP)	;SAVE FOR LEGNTH CALCULATION
	CLR	(R1)+		;SPACE FOR LEGNTH AND FLAGS
	TST	NDIRSW
	BEQ	WRIT.4
	MOV	#-1,(R1)+	;VERSION NUMBER
	CLR	(R1)+		;EOF WORDS
	CLR	(R1)+
	MOV	#-1,(R1)+	;DATE AND TIME
	MOV	#-1,(R1)+	
WRIT.4:	MOV	#DPNAM,R3	;PUT NAME IN DISCRIPTOR
WRIT.1:	MOVB	(R3)+,(R1)+
	BNE	WRIT.1		;LOAD NAME
	DEC	R1
	BISB	#200,-1(R1)	;LAST CHAR HAS 200 BIT SET
	MOV	#-1,BLKINC
	MOV	#-1,OLDINC	;INITIALIZE BLK POINTERS
	CLR	WTTYP		;FOR WTDISC
	CLR	#0
EOFPG=.-2
	CLR	#0
EOFBT=.-2
	JSR	PC,GETFIL	;GET BLOCKS OF FILE (R0)
WRIT.2:	JSR	PC,@(SP)+	;CO-ROUTINE
	BEQ	WRIT.3		;NO MORE TO WRITE
	JSR	PC,WTDISC	;WRITE BLOCK (RO) POINTS AT
	ADD	#2000,R0
	BR	WRIT.2
WRIT.3:	CLRB	(R1)		;NEW DIRECTORIES HAVE ODD LEGNTHS
	TST	NDIRSW
	BNE	WRIT.5		;NEW FILES HAVE DATE AND TIME ELSEWHERE
	INC R1
	BIC	#1,R1		;GET WORD BOUNDARY
	MOV	#-1,(R1)+
	MOV	#-1,(R1)+	;FILES END WITH 2 WORDS OF -1
WRIT.5:	MOV	R1,R3
	MOV	(SP)+,R2	;BEGINNING OF ENTRY
	MOV	(SP)+,R0
	SUB	R2,R3
	TST	NDIRSW
	BNE	WRIT.6
	ASR	R3		;COMPUTED LEGNTH
	BIT	#177700,R3
	BNE	WRIT.0		;LEGNTH TOO LONG
	ADD	#200,R3
	MOVB	R3,(R2)		;STORE LEGNTH AND TYPE
	RTS	PC
WRIT.6:	BIT	#177400,R3
	BNE	WRIT.0
	BIS	#102000,R3	;FILE ENTRY TYPE
	MOV	R3,(R2)
	MOV	EOFPG,4(R2)
	MOV	EOFBT,6(R2)
	INC R1			;LENGTH IS ODD, MAYBE
	BIC #1,R1		;BUT WORD BOUNDARY NEVER IS!
	RTS	PC
;GETFIL INITIALIZES ABSDMP AND GIVBLK AND SETS UP CO-ROUTINE LINKAGE


GETFIL:	CLR	FILEND		;FOR SHAKBF
	MOV	#SPRG,SHKDAR
	MOV	#ABSBUF+2000,SHKCMA
	MOV	#-40000,SHKWC
	MOV	#ABSBUF+2000,ABSDIS	;FOR ABSDMP
	JSR	PC,SHAKBF	;SET UP BUFFER
	MOV	(SP),-(SP)	;SET UP CO-ROUTINE LINKAGE
	MOV	#GETF.1,2(SP)
	BR	GIVBLK		;RETURN

GETF.1:				;COMES BACK TO HERE FOR MORE
.IFNZ F.HD
	MOV	#SPRG+40000,SHKDAR
.IFF
MVAD	40000,SPRGM		;CONVERT TO SPECIAL MOVING DAR
MVADD	SPRG,SPRGM,SPRGM
	MOV	#SPRGM,SHKDAR
.ENDC
	MOV	#ABSEND-SPRGL-SPRGL+100000,SHKCMA
	MOV	#-SPRGL+40000,SHKWC
	MOV	#ABSEND-SPRGL-SPRGL,ABSDIS
	JSR	PC,SHAKBF
	MOV	ADRES,R5
	JSR	PC,LSTFRM	;SET UP SPECIAL FRAME
	MOV	#GETF.2,2(SP)
	BR	GIVBLK		;RETURN

;COMES BACK HERE FOR MORE

GETF.2:	MOV	#SSTBL,SHKDAR	;DO SYMBOL TABLE NOW
	MOV	#ABSEND-SSTBUL-SSTBUL,SHKCMA
	MOV	#-SSTBUL,SHKWC
	MOV	#ABSEND-SSTBUL-SSTBUL-CSTBL,ABSDIS
	JSR	PC,SHAKBF
	MOV	O.SYME,R5
	JSR	PC,LSTFRM
	ADD	#1777,FILEND	;MAKE SURE LAST BLOCK IS WRITTEN
	MOV	#GETF.3,2(SP)
	BR	GIVBLK
GETF.3:	MOV	(SP)+,(SP)	;DESTROY CO-ROUTINE LINKAGE
	SEZ
	RTS	PC


;CO-ROUTINE PUTS POINTER TO BLOCK IN R0
;WHEN IT RUNS OUT IT ASKS GETFIL FOR MORE


GIVB.0:	MOV	(SP)+,R0
	JSR	PC,@(SP)+	;RETURN TO WRITE
GIVBLK:	MOV	R0,-(SP)
	ADD	#2000,R0	;CHECK IF ANOTHER BLK IS IN BUFFER
	CMP	R0,#0
FILEND=.-2
	BLOS	GIVB.0
	MOV	(SP)+,R0
	JMP	@2(SP)		;GO TO GETFIL FOR MORE BLOCKS
;SETS UP BUFFER, MOVING LEFTOVERS TO BOTTOM AND CRUNCHING
;WHATEVER IS NECESSARY


SHAKBF:	MOV	R1,-(SP)
	MOV	FILEND,R3
	BIC	#1777,R3
	MOV	#ABSBUF,R2
SHAK.1:	CMP	R3,FILEND	;GET LEFTOVERS
	BHIS	SHAK.2
	MOVB	(R3)+,(R2)+
	BR	SHAK.1
SHAK.2:	JSR	R5,SYSDSK
.IIF NZ F.HD,	0
SHKDAR:	0
SHKCMA:	0
SHKWC:	0
	5
	MOV	SHKCMA,R1
	JSR	PC,ABSDMP	;CHANGE TO ABS LODER FORMAT
	MOV	R2,FILEND	;SAVE END OF BUFFER
	MOV	#ABSBUF,R0
	MOV	(SP)+,R1
	RTS	PC
;TAKES CORE BETWEEN (R1) AND (ABSEND)
;PACKES IT IN ABSOLUTE LODER FORMAT BEGINING AT (R2)
;(ABSDIS) IS CROCK SINCE ROOM MUST BE LEFT FOR 6 BYTES BEFORE 1ST FRAME
;R0 IS CHECKSUM
;R1 IS POINTER IN CORE
;R2 IS POINTER IN PACKED CORE
;R3 IS BYTE COUNT (BEGINNING OF FRAME)
;R4 IS USED FOR SUMMING CHECKSUM
;R5 IS SCRATCH


ABSDMP:	CLR	R4
	CLR	ABSEND	;ZERO MAKES SURE LODER WILL STOP
ABSD.1:	CMP	#ABSEND,R1
	BLOS	ABSDUN	;DO LAST FRAME NOW
	TSTB	(R1)+	;FIND NON-ZERO BYTE
	BEQ	ABSD.1
	DEC	R1
ABSD.2:	MOV	R2,R3	;SAVE ADDRESS OF FRAME FOR BC
	MOV	#1,R0
	MOVB	R0,(R2)+
	CLRB	(R2)+
	CMPB	(R2)+,(R2)+	;SAVE SPACE FOR BC
	MOV	R1,R5		;COMPUTE AND STORE ADDRESS
	SUB	#0,R5
ABSDIS=.-2
	MOVB	R5,(R2)+
	ADD	R5,R0
	SWAB	R5
	MOVB	R5,(R2)+
ABSD.3:	MOVB	-1(R2),R4	;COMES HERE WHEN FINDS SOME BUT NOT 
	ADD	R4,R0		;ENOUGH ZEROS
ABSD.4:	MOVB	(R1)+,R4
	ADD	R4,R0
	MOVB	R4,(R2)+	;STORE BYTE AND UPDATE CKSUM
	BNE	ABSD.4
	MOV	#7,R5		;FOUND ZERO CHECK FOR 7 MORE
ABSD.5:	CMP	#ABSEND,R1
	BLOS	ABSD.6		;END OF CORE
	MOVB	(R1)+,(R2)+
	BNE	ABSD.3		;NOT ENOUGH 0'S CONTINUE FRAME
	SOB	R5,ABSD.5
ABSD.6:	TSTB	-(R2)		;BACK UP POINTER
	BEQ	ABSD.6
	INC	R2		;IT NOW POINTS JUST PAST LAST BYTE
ABSD.7:	MOV	R2,R5		;COMPUTE AND STORE BYTE COUNT
	SUB	R3,R5
	ADD	R5,R0
	CMPB	(R3)+,(R3)+	;R3 NOW HAS ADD. TO PUT BC
	MOVB	R5,(R3)+
	SWAB	R5
	ADD	R5,R0
	MOVB	R5,(R3)
	NEG	R0		;COMPUTE AND STORE CHECKSUM
	MOVB	R0,(R2)+
	BR	ABSD.1		;GO DO MORE FRAMES

ABSDUN:	RTS	PC

;SETS UP LAST FRAME IN BUFFER
;R5 IS ADDRESS FOR FRAME

LSTFRM:	MOVB	#1,(R2)+
	CLRB	(R2)+
	MOVB	#6,(R2)+
	CLRB	(R2)+
	MOV	#7,R4		;CHECKSUM
	ADD	R5,R4
	MOVB	R5,(R2)+
	SWAB	R5
	ADD	R5,R4
	MOVB	R5,(R2)+
	NEG	R4
	MOVB	R4,(R2)+
	MOV	R2,FILEND	;UPDATE END OF BUFFER
	RTS	PC
;WRITES DISCRIPTOR AND SENDS BLK OFF TO DISK
;BLKINC AND OLDINC POINT TO DISK BLOCKS
;WTTYP AND WTCNT ARE BYTE FLAGS FOR WRITING THE DISCRIPTORS
;(R1) IS WHERE DISCRIPTOR IS PLACED
;IT ALSO FINDS FREE BLOCK TO WRITE ON, CHANGING THE BIT TABLE
;CLOBBERS REGS 3,4,5


WDIS.0:	JSR	R5,TYPE
	.ASCIZ	/DISK FULL?/
	.EVEN
WDIS00:	JMP	DUMP.4

WTDISC:	INC	BLKINC
	MOV	BLKINC,R5
	CMP	R5,BITAB
	BGE	WDIS.0		;THAT IS AN ILLEGAL BLOCK
	CLR	R4
	DIV	#20,R4		;FIND BIT IN TABLE
	MOV	#1,R3
	ASH	R5,R3
	ASL	R4
	BIT	R3,BITAB+2(R4)	;SEARCH TABLE FROM BEGINNING
	BNE	WTDISC
	ADD	#2000,EOFBT
	CMP	EOFBT,#20000
	BLT	WDIS.9
	CLR	EOFBT		;COMPUTE LEGNTH OF FILE
	INC	EOFPG
WDIS.9:	BIS	R3,BITAB+2(R4)	;SET WRITTEN ON BIT
	MOV	BLKINC,R5
	SUB	OLDINC,R5	;COMPUTE DISP FROM LAST BLOCK
	TSTB	#0
WTTYP=.-2
WTCNT=.-1
	BEQ	WDIS.1		;START NEW DISCRIPTOR
	DEC	R5
	BNE	WDIS.6		;SKIPPED SOME BLOCKS
	INCB	WTCNT
	BITB	#0,WTCNT	;MASK IS 3 OR 6 BITS
WTMASK=.-4
	BNE	WDIS.2		;START MULTIPLE GET DISCRIPTOR
	INCB	0(R1)		;CHANGE PREVIOUS DISCRIPTOR
WTBACK=.-2
	BR	WDIS.5
WDIS.1:	DEC	R5		;# BLKS TO BE SKIPPED
	BNE	WDIS.6		;DO A SKIP DISCRIPTOR
WDIS.2:	MOV	#100,WTTYP	;SET TYP AND CNT FLAGS
	MOV	#340,WTMASK	;HALF AS MUCH BECAUSE OF RON
WDIS.3:	MOV	#-1,WTBACK
WDIS.4:	MOVB	WTTYP,(R1)+	;WRITE DISCRIPTOR
WDIS.5:	MOV	BLKINC,#0	;SAVE BLK #
OLDINC=.-2
WDISRT:	JMP	WTBLK		;WRITE IT AND RETURN
WDIS.6:	CMP	R5,#7		;LARGE OR SMALL SKIP
	BGT	WDIS.7
	MOV	#300,WTTYP	;SMALL SKIP
	MOV	#370,WTMASK
	ASH	#3,R5
	MOV	#-1,WTBACK
	ADD	WTTYP,R5
WDIS6A:	MOVB	R5,(R1)+	;WRITE DISCRIPTOR
	BR	WDIS.5
WDIS.7:	CMP	R5,#77		;SKIP OR SET ADDRESS
	BGT	WDIS.8
	CLR	WTTYP		;SKIP AND GET 1
	BR	WDIS6A
WDIS.8:	MOV	#200,WTTYP	;THREE BYTE DISCRIPTOR
	MOV	#300,WTMASK
	MOV	#-3,WTBACK
	MOVB	WTTYP,(R1)+	;WRITE 1ST BYTE
	MOVB	BLKINC,(R1)+	;2ND BYTE
	MOVB	BLKINC+1,(R1)+	;LAST BYTE
	BR	WDIS.5
;READS DISC POINTED TO BY R2
;LOOKS AT BLKNT FIRST FOR PREVIOUSLY READ DISC
;IF (R3) =0 CHECKS FFLAG AND SEZ


RDDISC:	INC	BLKINC
	TSTB	BLKNT
	BEQ	RDIS.1
	DECB	BLKNT		;STILL BLOCKS LEFT FROM LAST DISCRIPTOR
	BR	RDSKIQ		;FOUND BLOCK
RDIS.1:	TST	R3
	BGT	RDIS.3
	TST	FFLAG		;NO MORE LEFT
	BLE	RDIS.2		;NOT A FILE
	ADD	#4,R2
RDIS.2:	MOV	R2,R0		;FOR FINDEN
	SEZ
	RTS	PC		;NO BLOCKS FOUND
RDIS.3:	DEC	R3
	MOVB	(R2)+,R4
	BEQ	RDIS.1		;NO-OP DISCRIPTOR
	MOVB	R4,#0
BLKNT=.-2
	BIC	#177700,BLKNT	;GET 1ST FIELD
	BIC	#177477,R4	;LEAVE ONLY TYPE FIELD
	ASH	#-5,R4
	ADD	R4,PC
	BR	RDSKIP
	BR	RDBNCH		;READ A BUNCH
	BR	RDSETA


	MOV	BLKNT,R4	;SKIP N1 AND GET N2+1
	BICB	#70,BLKNT
	ASH	#-3,R4
	ADD	R4,BLKINC	;SKIP SOME
	RTS	PC


RDBNCH:	BIT	#40,BLKNT
	BNE	RDIS.1		;HOLE IN FILE DISCRIPTOR
	BR	RDSKIQ		;GET A BUNCH DISCRIPTOR


RDSKIP:	ADD	BLKNT,BLKINC	;SKIP N1 AND GET 1
	CLR	BLKNT
RDSKIQ:	CLZ
	RTS	PC


RDSETA:	SUB	#2,R3
	BLT	RDSETB		;WHERE'S THE REST OF THIS DISCRIPTOR?
	MOVB	(R2)+,BLKINC
	MOVB	(R2)+,BLKINC+1	;SET THE BLOCK #
	BR	RDSKIQ
RDSETB:	JSR	R5,TYPE
	.ASCIZ	/BAD DISCRIPTOR?/
	.EVEN
RDSETC:	JMP	WDIS00
;FIND ENTRY WITH NAME IN DPNAME ELSE FIND WHERE IT SHOULD GO
;WRITE FROM DIRIN TO DIROUT AS YOU GO
;FIND.0 ENTRY INITIALIZES A NEW DIR SEARCH AND SKIPS HEADER
;USES	ENDBLK	END OF DIRECTORY
;	R0	START OF CURRENT ENTRY
;	R1	POINTER IN OUTPUT
;	R2	POINTER IN INPUT
;	R3	LENGTH OF CURRENT ENTRY
;CLOBBERS R4,R5

FIND10:	BIC	#177400,R3	;LEGNTH IN BYTES
	INC	R3
	ASR	R3
	CLR	FFLAG		;DATE AND TIME ARE NOW AT BEGINNING OF DISC
	TST	(R2)+		;SKIP VERSION NUMBER OR DIRID
	ROL	R4
	BCC	.+6
	ADD	#10,R2		;SKIP EOF DATE AND TIME
	BR	FIND11

FINDEN:	CLR	BLKNT		;INIT RDDISC
	MOV	#-1,BLKINC
	BR	FIND.7		;CHECK FOR END OF DIRECTORY
FIND.1:	MOV	R0,R2
	MOV	(R2)+,R3	;GET LENGTH IN WORDS
	MOV	R3,R4		;KLUGE TO FIND IF THIS IS A FILE
	TST	NDIRSW
	BNE	FIND10		;NEW STYLE DIRECTORY
	BIC	#177700,R3
	BIC	#177400,R4
	ASH	#-7,R4
	SBC	R4		;ITS POSITIVE IF FILE ENTRY
	MOV	R4,#0
FFLAG=.-2
FIND11:	MOV	#DPNAM,R4
FIND.2:	TSTB	(R4)		;ZERO MEANS IT ENDED
	BMI	FIND.6		;IF 200 BIT SET SKIP ALL ENTRIES
	BEQ	FIND.5		;ENTRY WOULD BE HERE
	MOVB	(R2),R5
	BPL	FIND.4		;LAST CHAR IN NAME HAS BIT SET
	BIC	#200,R5
	CMPB	(R4)+,R5
	BLT	FIND.5		;ENTRY WOULD BE HERE
	BGT	FIND.6		;WRITE OUT ENTRY AND CONTINUE SEARCH
	TSTB	(R4)		;LOOK TO SEE IF DPNAM IS DONE ALSO
	BNE	FIND.6		;NOPE SO WRITE ENTRY AND CONTINUE
	TST	FFLAG
	BLE	FIND3A
	SUB	#2,R3		;FILES END WITH 2 WORDS OF -1
FIND3A:	INC	R2		;NAMES MATCH
FIND.3:	ASL	R3		;RDDISC WANTS BYTE COUNT
	SUB	R2,R3
	ADD	R0,R3		;NUMBER OF BYTES LEFT IN ENTRY
	CLZ
	RTS	PC
FIND.4:	CMPB	(R4)+,(R2)+
	BEQ	FIND.2		;CONTINUE COMPARE
	BGT	FIND.6		;WRITE ENTRY AND CONTINUE
FIND.5:	SEZ			;ENTRY WOULD BE HERE
	RTS	PC
FIND.0:	TST	NDIRSW
	BNE	FIND.8		;NEW STYLE DIRECTORIES
	MOV	R0,ENDBLK
	SUB	1776(R0),ENDBLK	;COMPUTE ADDRESS OF LAST WORD
	ADD	#2000,ENDBLK
	MOV	(R0),R3
	BIC	#177700,R3	;GET THE HEADER LENGTH IN WORDS
FIND.9:	CLR	BLKNT		;NOW SKIP THE HEADER
	MOV	#-1,BLKINC
FIND.6:	MOV	(R0)+,(R1)+	;WRITE ENTRY AND LOOK AT NEXT
	SOB	R3,FIND.6
FIND.7:	CMP	R0,#0
ENDBLK=.-2
	BLO	FIND.1		;CONTINUE
	BR	FIND.5		;END OF DIR SO IT GOES HERE

FIND.8:	MOV	6(R0),ENDBLK
	ADD	R0,ENDBLK		;MAKE IT ABSOLUTE
	MOV	(R0),R3			;LEGNTH OF SELF ENTRY
	INC R3
	BIC	#177401,R3		;SKIP SELF AND PARENT ENTRIES
	MOV	R0,R4
	ADD	R3,R4
	ADD	(R4),R3			;LEGNTH OF PARENT ENTRY
	INC R3
	BIC	#177401,R3
	ASR	R3			;WORD COUNT
	BR	FIND.9			;SKIP THEM BOTH
;SEARCHES OLD DIR TO FIND NEW AND PUTS IT IN DIRIN
;SETS UP ALL RELEVENT POINTERS

RDDIR:	JSR	PC,FIND.0	;FIND ENTRY WITH THAT NAME (DPNAM)
	BEQ	RDIR.2		;NOT FOUND
	JSR	PC,RDDISC
	BEQ	RDIR.2		;NO DISCRIPTOR
RDIR.1:	MOV	#DIRIN,R0
	MOV	#DIROUT,R1
	MOV	BLKINC,#0	;SAVE BLK #
DIRBLK=.-2
	BR	RDBLK
RDIR.2:	JSR	R5,TYPE
	.ASCIZ	/DIRECTORY NOT FOUND/
	.EVEN
RDIR.3:	JMP	RDSETC


;WRITES OUT DIR IN DIROUT 

WTDIR:	CLR	(R1)		;LOGO WANTS ZERO AT END
	MOV	DIRBLK,BLKINC
	MOV	#DIROUT,R0
	SUB	R0,R1		;FIND LEGNTH
	TST	NDIRSW
	BNE	WDIR.3		;NEW STYLE DIRECTORIES
	CMP	R1,#1774
	BGE	WDIR.1
	NEG	R1
	ADD	#2000,R1
	MOV	R1,1776(R0)	;STORE BLK LEGNTH IN LAST WORD
	BR	WTBLK
WDIR.1:	JSR	R5,TYPE
	.ASCIZ	/DIRECTORY FULL?/
	.EVEN
WDIR.2:	BR	RDIR.3
WDIR.3:	CMP	R1,#2000
	BGE	WDIR.1
	MOV	R1,6(R0)
	BR	WTBLK;WRITE OUT BIT TABLE

WTBITS:	MOV	BITBLK,BLKINC
	MOV	#BITAB,R0
	BR	WTBLK		;DOES RTS PC



;READS BIT-TABLE INTO BITAB AND THEN READS ROOT DIR

RDBITS:	MOV	#ROOTBK,BLKINC	;READ ROOT
	JSR	PC,RDIR.1
	MOV	DIRIN,#0
NDIRSW=.-2
	BIC	#173777,NDIRSW
	MOV	#DPNAM,R4
	MOV	#"BI,(R4)+
	MOV	#"TS,(R4)+
	CLR	(R4)		;LOOK FOR BITS IN ROOT DIR
	JSR	PC,FIND.0
	BEQ	RBIT.1		;IT SHOULD BE THERE!?
	JSR	PC,RDDISC
	BEQ	RBIT.1		;IT SHOULD HAVE A DISCRIPTOR!?
	MOV	#BITAB,R0
	MOV	BLKINC,#0	;SAVE BLK #
BITBLK=.-2
	JSR	PC,RDBLK	;GO GET IT
	MOV	#ROOTBK,BLKINC
	BR	RDIR.1
RBIT.1:	JSR	R5,TYPE
	.ASCIZ	/BITS NOT FOUND?/
	.EVEN
RBIT.2:	BR	WDIR.2
;READS/WRITES THE DISK BLOCK # (BLKINC)  TO/FROM BUFFER ADDRESS IN R0
;CLOBBERS NO REGS

RDBLK:	MOV	#5,FICS
	BR	WTBL.0
WTBLK:	MOV	#3,FICS
WTBL.0:	MOV	R0,FIBA
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	CLR	R0
	MOV	#0,R1		;COMPUTE DISK ADDRESS
BLKINC=.-2
	CMP	WCHDSK,#FXWRT	;USE DIFFERENT MAPS FROM BLK# TO DA
	BEQ	WTBL.2
	ASL	R1
	DIV	#14,R0
	ASH	#4,R0
	ADD	R0,R1
	ADD	#20000,R1	;WHICH PLATTER
WCHPLT=.-2
WTBL.1:	MOV	R1,FIDA
	JSR	PC,@#MVWRT	;DO TRANSFER
WCHDSK=.-2
FIDA:	0
FIBA:	0
FIWC:	-1000
FICS:	0
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RTS	PC

WTBL.2:	ASHC	#11,R0		;2**10. BYTES PER BLOCK
	MOV	R0,FIDE
	BR	WTBL.1
FIDE:	0			;FIXED DAE


;DISK READ/WRITE ROUTINE SELECTS DISK AND LOADS REGS


FXWRT:	MOV	#400,DCS	;POWER CLEAR (IN CASE THIS IS A RETRY)
	MOV	#"FD,MVDS.2	;R/W ON FIXED DISK
	MOV	#DAE,R0
	MOV	FIDE,(R0)
	BR	MVDS.0
MVWRT:	MOV	#1,RKCS		;CONTROL RESET IN CASE THIS IS A RETRY
	MOV	#RKDA+2,R0	;R/W ON MOVING DISK
	MOV	#"MD,MVDS.2
MVDS.0:	MOV	(SP),R1	;ADDRESS OF ARGUMENTS
	MOV	(R1)+,-(R0)	;DAR
	MOV	(R1)+,-(R0)	;CMA
	MOV	(R1)+,-(R0)	;WC
	MOV	(R1)+,-(R0)	;DCS
MVDS.1:	TSTB	(R0)
	BPL	MVDS.1
	TST	(R0)
	BPL	MVDS.3
	JSR	R5,TYPE
MVDS.2:	.ASCIZ	/FD ERR? /
	.EVEN
	JMP	@WCHDSK
MVDS.3:	TST (SP)+		;POP ARGUMENTS ADDRESS
	JMP	(R1)
;THIS ROUTINE R/W ON THE SYSTEM DEVICE
;CALLED BY USE OF R5 AND CLOBBERS R4


SYSDSK:	MOV R3,-(SP)
SYSD.3:
.IFNZ F.HD
	MOV	#DAE,R3
	MOV	(R5)+,(R3)	;DAE
.IFF
	MOV	#RKDA+2,R3
.ENDC
	MOV	(R5)+,-(R3)	;DAR
	MOV	(R5)+,-(R3)	;CMA
	MOV	(R5)+,-(R3)	;WC
	MOV	(R5)+,-(R3)	;DCS
SYSD.1:	TSTB	(R3)
	BPL	SYSD.1
	TST	(R3)
	BMI	SYSD.2
	MOV (SP)+,R3
	RTS	R5
SYSD.2:
.IIF NZ F.HD,	SUB	#12,R5
.IIF Z  F.HD,	SUB	#10,R5
	MOV	R0,-(SP)
	JSR	R5,TYPE
	.ASCIZ	/SD ERR? /
	.EVEN
	MOV	(SP)+,R0
.IIF NZ F.HD,	MOV #400,DCS	;POWER CLEAR
.IIF Z  F.HD,	MOV #1,RKCS	;CONTROL RESET
	BR	SYSD.3
;LOADS A FILE AND SYMBOL TABLE IN ABSOLUTE LOADER FORMAT 
;FROM DISK TO RUG SWAP AREA (RUG'S $L COMMAND)


LOADF:	JSR	PC,FNDF.2	;$L COMMAND ENDS UP HERE
	JSR	PC,LODFIL
	BR	LODF.0

LODFIL:	BNE	LODF.1		;ALSO CALLED BY LOGO BOOT
LODFER:	JSR	R5,TYPE
	.ASCIZ	/FILE NOT FOUND?/
	.EVEN
LODF.0:	JMP	DUMP.4
LODF.1:	CLR	0		;ZERO SWAP AREA ON DISK
	MOV	R2,LODR2	;SAVE FOR LODBLK AND RDDISC
	MOV	R3,LODR3
	JSR	R5,SYSDSK
.IIF NZ F.HD,	400		;DISABLE AUTOINCREMENT
	SPRG
	0
	-SPRGL
.IFNZ F.HD
	3
.IFF
	4003
.ENDC
	MOV	#RUGFNT,O.SYME
	JSR	R5,SYSDSK	;ZERO SYMBOL TABLE
.IIF NZ F.HD,	400
	SSTBL
	0
	-<SSTBUL&<-DSKBSZ>>
.IFNZ F.HD
	3
.IFF
	4003
.ENDC
.IFNZ MVFO2
	JSR	R5,SYSDSK
.IIF NZ F.HD,	0
	SSTBLB
	DIROUT
	-DSKBSZ
	5
	MOV	#MVFO2,R0	;ZERO THIS MANY WORDS
	MOV	#DIROUT,R2
LODF.3:	CLR	(R2)+
	SOB	R0,LODF.3
	JSR	R5,SYSDSK
.IIF NZ F.HD,	0
	SSTBLB
	DIROUT
	-DSKBSZ
	3
.ENDC

	MOV	#BITAB+2000,R0	;SO LODBYT WILL GET A BLOCK
	MOV	#SPRG,SWAPST
	JSR	PC,ABSLOD	;LOAD THE PROGRMA
	MOV	R4,ADRES	
.IFNZ F.HD
	MOV	#SSTBL-<CSTBL/2>,SWAPST
.IFF
MVAD	<CSTBL/2>,MVFOO
MVFO1==SSTBL-MVFOO
.IFL <SSTBL&17>-<MVFOO&17>
MVFO1=MVFO1-4
.ENDC

	MOV	#MVFO1,SWAPST	;ABSLOD WILL ADD CSTBL TO THIS TO GET THE DISK ADDRESS
.ENDC

	JSR	PC,ABSLOD	;GET THE SYMBOL TABLE
	MOV	R4,O.SYME
	RTS	PC
;LOADS FRAMES INTO CORE
;R0 IS POINTER IN DISK BLOCK (0 - 2000)
;R1 IS POINTER IN CORE (ABSBUF - AS FAR AS NECESSARY)
;R2 IS SCRATCH
;R3 IS WHERE LODBYT AND LODWRD RETURN VALUES
;R4 IS BYTE COUNT
;R5 IS CHECKSUM


ABSLOD:	JSR	PC,LODBYT	;READ FRAMES UNTIL END FRAME IS FOUND
	CMPB	#1,R3
	BNE	ABSLOD		;LOOK FOR BYTE = OO1
	MOV	R3,R5		;CHECKSUM
	JSR	PC,LODBYT	;SKIP BYTE OF ZERO
	JSR	PC,LODWRD	;GET BYTE COUNT
	MOV	R3,R4
	JSR	PC,LODWRD	;GET ADDRESS
	SUB	#6,R4		;ALREADY HAVE 6 BYTES
	BNE	LOD.3
	MOV	R3,R4
	JSR	PC,LODBYT
	TSTB	R5
	BNE	LODERR		;CHECKSUM ON LAST FRAME TOO BAD
	RTS	PC		;LAST FRAME HAS LENGTH 6
LOD.3:	MOV	#ABSBUF,R1
	MOV	R3,-(SP)	;SAVE START ADDRESS OF FRAME
	CLC
	ROR	(SP)		;MAKE IT A WORD ADDRESS


.IFNZ F.HD			;COMPUTE DAR
	CLR	LOD.9-2		;EXTENSION ADDRESS
	ADD	#SPRG,(SP)
SWAPST=.-2
	ADC	LOD.9-2

.IFF
	BIC	#377,(SP)
	MOV	(SP),MDSAV
	JSR	PC,MDCNVT
	MOV	#SPRG,MDSAV+2
SWAPST=.-4
	JSR	PC,MDADD
	MOV	MDSAV,(SP)
.ENDC
	BIC #-<DSKBSZ*2>,R3
.IFNZ F.HD
	BIC	#DSKBSZ-1,(SP)	;MAKE IT BLOCK ADDRESS
	MOV	LOD.9-2,LOD3A-2	;EXTENSION ADDRESS
.ENDC
	ADD	R3,R1		;WHERE TO START PUTTING BYTES
	MOV	(SP),LOD3A	;DAR
	JSR	R5,SYSDSK	;READ A BLOCK
.IIF NZ F.HD,	0
LOD3A:	0
	ABSBUF
	-DSKBSZ
	5
LOD.4:	JSR	PC,LODBYT
	MOVB	R3,(R1)+	;PUT BYTE IN BUFFER
	SOB	R4,LOD.4
	JSR	PC,LODBYT	;GET THE CHECKSUM
	TSTB	R5
	BEQ	LOD.5		;IT CHECKS
LODERR:	JSR	R5,TYPE
	.ASCIZ	/CHECKSUM ERROR?/
	.EVEN
LOD.ER:	JMP	LODF.0		;ABORT
LOD.5:	MOV #-DSKBSZ,LOD10
.IIF NZ F.HD,	MOV LOD3A-2,LOD.9-2
	CMP #ABSBUF+<DSKBSZ*2>,R1	;IS IT MORE THAN ONE BLOCK ORTH?
	BHIS LOD.8	;NO
	MOV R1,R2	;THE FIRST BYTE NOT WRITTEN
	SUB #ABSBUF,R2	;CHANGE TO POSITIVE BYTE COUNT
	CLC
	ROR R2		;NOW, POSITIVE WORD COUNT
	BIC #DSKBSZ-1,R2	;ROUNDED DOWN, GIVES OFFSET TO START OF LAST BLOCK
	MOV R2,R3	;COPY TO FART AROUND WITH
	ADD #DSKBSZ,R3	;COUNT OF THE WHOLE ABSBUF, ROUNDED
	MOV R3,LOD10	;TO RITE OUT ABSBUF
	NEG LOD10
	ASL R3		;BYTE COUNT OF WHOLE BUFFER
	ADD #ABSBUF,R3	;POINTS PAST LAST REAL BYTE IN BUFFER
		;NOTE THAT SOME OF THE BUFFER GETS FILLED IN BELOW
		;SO FAR WE JUST HAVE FROM ABSBUF TO (R1)-1 REAL BYTES

.IFNZ F.HD
	MOV LOD.9-2,LOD.6-2
	MOV	(SP),R5
	ADD	R2,R5		;READ BLOCK AT END FROM DISK
	ADC	LOD.6-2
.IFF
	MOV	R2,MDSAV	;CONVERT WC TO DISC ADDRESS
	JSR	PC,MDCNVT
	MOV	(SP),MDSAV+2
	JSR	PC,MDADD
	MOV	MDSAV,R5
.ENDC
	MOV	R5,LOD.6
	JSR	R5,SYSDSK	;GET END BLOCK
.IIF NZ F.HD,	0
LOD.6:	0
	DIROUT
	-DSKBSZ
	5
	MOV	#DIROUT+<DSKBSZ*2>,R2
LOD.7:	MOVB	-(R2),-(R3)	;FILL REST OF BLOCK
	CMP R1,R3
	BNE LOD.7
LOD.8:	MOV	(SP)+,LOD.9	;DAR'S
	JSR	R5,SYSDSK	;WRITE FRAME ON DISK
.IIF NZ F.HD,	0
LOD.9:	0
	ABSBUF
LOD10:	0
	3
	JMP	ABSLOD		;GET ANOTHER FRAME
;GETS BYTE INTO R3 FROM BLOCK POINTED AT BY R0
;IF IT REACHES THE END OF THE BLOCK IT GETS ANOTHER
;IF NO MORE ARE AVAILABLE IT BARFS


LODBYT:	CMP	R0,#BITAB+2000	;END OF BLOCK?
	BLO	LDBY.1		;NO WE DONT NEED ANY THANK YOU
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	MOV	LODR3,R3
	MOV	LODR2,R2	;POINTERS FOR RDDISC
	MOV	#BITAB,R0
	JSR	PC,RDDISC
	BNE	LDBY.0
	JSR	R5,TYPE
	.ASCIZ	/BAD FILE/
	.EVEN
	BR	LOD.ER
LDBY.0:	JSR	PC,RDBLK
	MOV	R2,#0
LODR2=.-2
	MOV	R3,#0
LODR3=.-2
	MOV	(SP)+,R4
	MOV	(SP)+,R3
	MOV	(SP)+,R2
LDBY.1:	MOVB	(R0)+,R3
	ADD	R3,R5		;CHECKSUM
	RTS	PC
;RETURNS WORD IN R3 ASSUMES THAT THERE ARE 2 BYTES LEFT IN FRAME

LODWRD:	JSR	PC,LODBYT
	MOVB	R3,R2
	JSR	PC,LODBYT
	SWAB	R3
	CLRB	R3
	BISB	R2,R3
	RTS	PC

.ENDC
;DISC ROUTINES
;4000-20000 ON DISC RESERVED FOR AN INVIOLATE  COPY OF RUG
;RUG AUTOMATICALLY WRITES THERE WHEN LOADED
;$^U WILL READ IT BACK

;FOLLOWING ARE WORD ADDRESSES
;20000-110000 ARE RESERVED FOR SWAPPING PROGRAM
;110000-143400 ARE RESERVED FOR SWAPPING SYMBOL TABLE
;143400-157400 ARE FOR SWAPPING RUG


;ON MOVING HEAD DISK, BOTTOM 100 SECTORS FOR RON
;DUMP TRACKS 1-9, EACH 300 SECTORS LONG

;THIS CALCULATES TRACK ADDRESS START, LEAVING
;THAT IN R0 AND 3 IN R3
;IF MOVING HEAD TRACK R1=-1 AT END
;R3 AND R4 BOTH INITIALLY CONTAIN 3 FOR WRITE OR 5 FOR READ



.IFZ FMH

.IFNZ	F.HD
DISC:	MOV	#TRKS-TRKL,R0
.IFNZ	M1145
	MOV	#THTRKS,R1
.ENDC
.IFZ	M1145
	CLR	R1
.ENDC
	CMP	R4,#11
	BHI	DSCER
.IFNZ	M.HD
	CMP	R4,#1
	BGE	DSCM
.ENDC
DSC1:	ADD	#TRKL,R0
	ADC	R1
	DEC	R4
	BGE	DSC1
MHD:	MOV	#SPRG,R2
	MOV	#3,R3
	MOV	R3,R4
	RTS	PC
DSCER:	TST	(SP)+	;FROM SBRTNE, SO POP STACK
DSCERR:	JMP	O.ERR
.ENDC

.IFZ	F.HD
DISC:	MOV	#TRKS-MTL,R0
	CMP	R4,#5
	BHI	DSCER
DSC1:	ADD	#MTL,R0
	DEC	R4
	BGE	DSC1
	MOV	#SPRG,R2
	MOV	#3,R3
	MOV	R3,R4
	BIS	PMKDA,R0
	RTS	PC
DSCER:	TST	(SP)+
DSCERR:	JMP	O.ERR
.ENDC

.IFNZ	F.HD

.IFNZ	M.HD
DSCM:	DEC	R1
	MOV	#LOWAD-MTL,R0
	DEC R4
MD1:	ADD	#MTL,R0
	DEC	R4
	BGE	MD1
	BIS	PMKDA,R0
	BR	MHD
.ENDC
.ENDC

DUMP:			;N^D
.IFNZ	M.HD
	CLR	PMKDA
.ENDC
DUMP1:	JSR	PC,DSTBL	;DO SYMBOL TABLE TRANSFER
	JSR	PC,DISC	;CONVERTS TO DISC ADDRESS, IN R0 (OVERFLOW IN R1)
	CMPB	(R4)+,(R4)+	;NOW R4 HAS 5 IN IT
	MOV	#DMP,FIRSTR
	MOV	#DMPT,SCNDR
	JSR	PC,DMPSUB
	BR	UNSV

UNSAVE:			;N^U
.IFNZ	M.HD
	CLR	PMKDA
.ENDC
UNSV1:	JSR	PC,USAVE
UNSV:	JMP	O.DCD



USAVE:	JSR	PC,DISC	;READS FIRST 10000 TRACK 0 LOCS
	CMPB	(R3)+,(R3)+	;NOW R3 HAS 5 IN IT
	MOV	#DMPT,FIRSTR
	MOV	#DMP,SCNDR
	JSR	PC,DMPSUB
	JMP	REINIT


FIRSTR:	0
SCNDR:	0	;RTNES TO BE CALLED IN DUMPING

DMPSUB:
.IFNZ	F.HD
	TST	R1
	BGE	DMS1
	MOV	R3,R1	;SO RTNES KNOW WHICH DISK
.ENDC
DMS1:	MOV	#-<<TRKL-<<RUGFNT/2>&77777>>/2>,R5	;SHOULD BE 22000 FOR HCOR=160000

	JSR	PC,CALLRS
	JSR	PC,CALLRS
	MOV	#-<<<RUGFNT+2>/2>&77777>,R5
;FALL INTO CALLRS

CALLRS:	JSR	PC,@FIRSTR
	JMP	@SCNDR
DMP:	;FOR GETTING OR STORING INTO SWAP AREA
.IFNZ	F.HD
	MOV	R2,DMPDAR
	CLR	DMPDAE
	MOV	R4,DMPDCS
	SUB	R5,R2
DMPP:	MOV	R5,DMPWC
	JSR	5,FDISK
DMPDAE:	0
DMPDAR:	0
	0
DMPWC:	0
DMPDCS:	0
	RTS	PC
.ENDC

.IFZ	F.HD
.IFNZ	M.HD
MDMP:	MOV	R2,SPMKDA
	MOV	R4,SPMKCS
	MOV	R5,SPMKWC
	MOV	R5,MDSAV
	NEG	MDSAV
	JSR	PC,MDCNVT
	JSR	5,MDISK
SPMKDA:	0
	0	;MEMORY ADDRESS
SPMKWC:	0
SPMKCS:	0
	MOV	R2,MDSAV+2
	JSR	PC,MDADD
	MOV	MDSAV,R2
	RTS	PC
.ENDC
.ENDC

DMPT:	;FOR GETTING OR WRITING INTO TRACK
.IFNZ	F.HD
.IFNZ	M.HD
	CMP	R1,R3
	BEQ	MDMPT
.ENDC
	MOV	R0,DMPDAR
	MOV	R1,DMPDAE
	MOV	R3,DMPDCS
	SUB	R5,R0
	SBC	R1
	INC	R1	;CARRY IS OPPOSITE OF WHAT IT SHOULD BE
	BR	DMPP
.ENDC

.IFNZ	M.HD
MDMPT:	MOV	R0,PMKDA
	MOV	R3,PMKCS
	JSR	PC,PMDSK
	MOV	R0,MDSAV+2
	JSR	PC,MDADD
	MOV	MDSAV,R0
	RTS	PC

PMDSK:	MOV	R5,PMKWC
	MOV	R5,MDSAV
	NEG	MDSAV
	JSR	PC,MDCNVT
PM1:	JSR	5,MDISK
PMKDA:	0
	0	;RKBA
PMKWC:	0
PMKCS:	0
	RTS	PC
.ENDC
.ENDC

FDISK:
.IFNZ	F.HD
	MOV	#10,-(SP)	;RETRY COUNT
.ENDC
FDISK1:
.IFNZ	F.HD
	MOV	(R5)+,DAE
	MOV	(R5)+,DAR
	MOV	(R5)+,CMA
	MOV	(R5)+,WC
	MOV	(R5)+,DCS
	MOV	#"FD,DERRTP
;FALL INTO SOOTH
SOOTH:	TSTB	DCS
	BPL	SOOTH
	TST	DCS	;WRITE ERROR?
	BPL	SOTH
DSER:	BR	.+2
	INCB	DCS+1	;POWER CLEAR
.ENDC
DSERR:	MOV	R0,-(SP)
	JSR	5,TYPE
DERRTP==.
	.ASCIZ	/MDE? /
	.EVEN
	CLR	R0		;NOW WAIT FOR THE DISK TO SETTLE
	DEC	R0
	BNE	.-2
	MOV	(SP)+,R0
	DEC	(SP)		;DECREMENT ERROR COUNT
	BNE	DSRTRY		;TRY AGAIN
	HALT			;IT IS PROBABLY WRITE PROTECTED
	MOV	#10,(SP)
DSRTRY:	SUB	#10,R5
	CMP	#"MD,DERRTP
	BEQ	MDISK1
	TST	-(R5)		;FIXED DISK HAS AN EXTRA REGISTER
	BR	FDISK1
SOTH:	TST	(SP)+		;POP ERROR COUNT
	RTS	R5

MDISK:
.IFNZ	M.HD
	MOV	#10,-(SP)		;RETRY COUNT
.ENDC
MDISK1:
.IFNZ	M.HD
	MOV	(R5)+,RKDA
	MOV	(R5)+,RKBA
	MOV	(R5)+,RKWC
	MOV	(R5)+,RKCS
	MOV	#"MD,DERRTP
;FALL INTO MOOTH
MOOTH:	TSTB	RKCS
	BPL	MOOTH
	TST	RKCS
	BPL	SOTH
MSER:	BR	.+2
	MOV	#1,RKCS
	BR	DSERR
.ENDC
;PROCESS $^U
BOOT:
.IFNZ	F.HD
	JSR	5,FDISK
	0
	INVRG	;DAR
.ENDC
.IFZ	F.HD
	JSR	5,MDISK
	LOWAD
.ENDC
	RUGFNT	;CMA
	-INVRGL	;WC
	5	;DCS
BOOT.1:	JMP	O.ODT


;PROCESS FOO^A, WHICH MAKES $G START AT FOO
GOADR:	TST	R2
	BEQ	PGOADR
	MOV	R4,ADRES
GOAD1:	JMP	O.DCD
PGOADR:	JSR	5,TYPE
	.BYTE	40
	.BYTE	0
	MOV	ADRES,R0
	CLRB	REGINF
	JSR	5,SYMBOL
	BR	GOAD1

REINIT:	MOVB	#-1,O.P
	CLR	O.CSR1
	CLR	O.UST
	MOV	#USP,R1
.IFNZ	M1145
	MOV	#O.UST+2,SAVKR6
	CMP	R6AD,#SAVKR6
	BNE	NOTDUN
.ENDC
	MOV	#O.UST+2,(R1)
NOTDUN:	CLR	-(R1)
	CMP	R1,#O.UR0
	BNE	NOTDUN
	CLR	R1
	DEC	R1
	BNE	.-2	;WAIT ABOUT 1/3 SEC FOR I/O TO FINISH, ESP 11-TO-10
	RESET
	JMP	DELT	;WILL RTS PC FOR US


DSTBL:
.IFNZ	F.HD
	JSR	5,FDISK
	0
.ENDC
.IFZ	F.HD
	JSR	5,MDISK
.ENDC
	SSTBL
	CSTBL
	-SSTBLL
	3
	RTS	PC


.IFNZ	M.HD
MDSAV:	0	;ARG AND RESULT OF MDCNVT
	0	;OPTIONAL OFFSET ARGUMENT TO MDSAV

MDCNVT:	MOV	R4,-(SP)	;LOOKS LIKE SAVING & RESTORING R4 IS UNNECESSARY, BUT UNCERTAIN ***
	CLRB	MDSAV
	SWAB	MDSAV
	DIVIDE	MDSAV,#14,SCRTCH,MDSAV
	MLTPLY	SCRTCH,#20,SCRTCH
	ADD	SCRTCH,MDSAV
	MOV	(SP)+,R4
	RTS	PC
MDADD:	MOV	R4,-(SP)
	MOV	MDSAV,R4
	BIC	#177760,R4
	ADD	MDSAV+2,MDSAV
	BIC	#177760,MDSAV+2
	ADD	MDSAV+2,R4
	CMP	#14,R4
	BGT	MDAD1
	ADD	#4,MDSAV
MDAD1:	MOV	(SP)+,R4
	RTS	PC

.ENDC
.IFZ FMH

STLOGO:	MOV	#O.UR0,SP	;START TRACK 0 (LOGO)
	CLR	R4
	JSR	PC,USAVE
	JMP	GO22

.IFNZ M.HD


BKUP:	MOV	#1,R1
	JSR	PC,VERIF
	MOV	#5,R4
	MOV	#3,R5
BKUP1:	MOV	#20000,R2	;COPY FROM DRIVE 1 TO 0
	CLR	R3
BK:	MOV	#313*2,R0
	CLR	R1
BKLOOP:	BIC	R3,R1
	BIS	R2,R1
	MOV	R4,BKCS
	JSR	PC,MBKE
	BIC	R2,R1
	BIS	R3,R1
	MOV	R5,BKCS
	JSR	PC,MBKE
	ADD	#20,R1
	DEC	R0
	BNE	BKLOOP
	JMP	O.DCD

GBK:	CLR	R1
	JSR	PC,VERIF
	MOV	#5,R4
	MOV	#3,R5
	MOV	#20000,R3
	CLR	R2
	BR	BK


MBKE:	MOV	R1,BKDA
	JSR	5,MDISK
BKDA:	0	;RKDA
	0	;RKBA
	-3072.	;RKWC
BKCS:	0	;RKCS
VRFOK:	RTS	PC

WCHECK:	MOV	#5,R4
	MOV	#7,R5
	BR	BKUP1

VERIF:
.IFZ	COMPUTER-1
;CHECK SWITCH ON LOGO MOVING HEAD DISK WHICH INVERTS LOW DRIVE SELECT BIT
;CALLED IN $$^U (COPY DRIVE 0 TO 1) AND $$^D (COPY DRIVE 1 TO 0)
	CLR	RKDA	;SELECT DRIVE 0
	MOV	#1,RKCS	;GATE DRIVE INTO RKDS
	BIT	#20000,RKCS	;IS IT REALLY DRIVE 0?
	BEQ	INVROK	;YES, NOT INVERTED
	JSR	5,TYPE
	.ASCIZ	\WARNING, DISK INVERTED. OK?\
	.EVEN
	JSR	PC,GET1UC
	CMPB	R0,#'Y
	BNE	VRFERR
	JSR	PC,CRLF
INVROK:
.ENDC
	ADD	#60,R1
	MOVB	R1,DRVFRM
	INC	R1	;CHEAP XOR #1,R1
	BIC	#2,R1
	MOVB	R1,DRVTO
	JSR	5,TYPE
	.ASCII	\COPY DRV \
DRVFRM=.	;DRIVE NUMBER OF "FROM" DRIVE
	.ASCII	\0 TO DRV \
DRVTO=.		;"TO" DRIVE
	.BYTE	'0,'?,0
	.EVEN
	JSR	PC,GET1UC
	CMPB	R0,#'Y
	BEQ	VRFOK
VRFERR:	MOV	#O.UR0,SP
	JMP	O.ERR


.ENDC

.IFF
STLOGO:

.IFNZ F.HD
	MOV	#FXWRT,WCHDSK
.IFF
	MOV	#MVWRT,WCHDSK
	CLR	WCHPLT
.ENDC
	MOV	#ROOTBK,BLKINC
	JSR	PC,RDIR.1
	MOV	#'.,DPNAM
	JSR	PC,RDDIR
	MOV	#"LO,DPNAM
	MOV	#"GO,DPNAM+2
	CLR	DPNAM+4
	JSR	PC,FIND.0
	BEQ	BOOT.1		;NO LOGO FILE
	JSR	PC,LODFIL
	JSR	PC,REINIT
	JMP	GO22
.ENDC
RUGEND==.

;ABS LOADER
.IFNZ	FPTR
DEVICE=177550
.ENDC

.IFZ	FPTR
DEVICE=O.RCSR
.ENDC
.IFZ 105
.=HCOR-200
.ENDC
L.LD2:	MOV	#L.READ,L.PTR
	CLR L.CKSM
	JSR PC,@L.PTR
	CMP	L.BYT,#EOT
	BNE	L.LD2B
	HALT
L.LD2B:	DECB L.BYT
	BNE L.LD2
	JSR PC,@L.PTR

	JSR PC,L.GWRD
	MOV R4,L.BC
	SUB #4,L.BC
	CMP #2,L.BC
	BEQ L.JMP
	JSR PC,L.GWRD
	MOV R4,L.ADR
	ADD	RELOC,L.ADR

L.LD3:	JSR PC,@L.PTR
	BGE L.LD4
	TSTB L.CKSM
	BEQ L.LD2
L.BAD:	HALT
	BR L.LD2
L.LD4:	MOVB L.BYT,(L.ADR)+
	BR L.LD3

L.READ:	MOV #DEVICE,L.BYT
	INCB @L.BYT
L.R1:	TSTB @L.BYT
	BPL L.R1
	MOVB 2(L.BYT),L.BYT
	ADD L.BYT,L.CKSM
	BIC #177400,L.BYT
	DEC L.BC
	RTS PC

L.GWRD:	MOV (SP)+,L.TMP
	JSR PC,@L.PTR
	MOV L.BYT,R4
	JSR PC,@L.PTR
	SWAB L.BYT
	BIS L.BYT,R4
	MOV L.TMP,PC

L.JMP:	JSR PC,L.GWRD
	JSR PC,@L.PTR
	TSTB L.CKSM
	BNE L.BAD
	ASR R4
	BCC L.JMP1
	HALT
L.JMP1:	RTS	PC

L.TMP:	.WORD 0
RELOC:	0
.IFZ	M1145
.	=	HCOR-700
.ENDC
.IFNZ	M1145
.	=	HCOR-1000
.ENDC
RUGST:	BR	RUGS1	;ENTRY TO START RUG=1
	INCB	RESTFL	;ENTRY TO START LOGO=2
RUGS1:	INCB	#0
RESTFL=.-2
	TSTB	#0
INPFL=.-2
	BNE	O.BRKS
	JMP	RESART

O.BRK:	MOV	(SP)+,O.UPC
	MOV	(SP)+,O.UST
O.BRKS:	MOV	SP,O.USP
.IFNZ	M1145
	MOV	SSR0,SVSSR0	;SAVE SEGMENTATION REGS
	BIC	#1,SSR0		;DISABLE SEGMENTATION
	MOV	SSR3,SVSSR3
	MOV	STACKR,SAVSLR	;STACK LIMIT REGISTER
	CLR	STACKR
	MOV	#7,SSR3		;ENABLE D SPACE
	BIC	#4000,PSW
.ENDC
	MOV	R0,(PC)+
SAVR0:	0
	MOV	R1,(PC)+
SAVR1:	0
.IFNZ	DM11
	MOV	#DMCSR+2,R1
DMWAIT:	TST	(R1)
	BNE	DMWAIT	;USED TO BE BNE O.BRKS ***
	MOV	-(R1),(PC)+
SAVDM:	0
	CLR	(R1)
.ENDC
	MOV	#SAVDCS,R0
.IFNZ	F.HD
	MOV	#DCS,R1
.ENDC
.IFZ	F.HD
	MOV	#RKCS,R1
.ENDC
GLOP1:	TSTB	(R1)
	BPL	GLOP1
	MOV	(R1)+,(R0)+	;SAVDCS
	MOV	(R1)+,(R0)+	;SAVWC
	MOV	(R1)+,(R0)+	;SAVCMA
	MOV	(R1)+,(R0)+	;SAVDAR
.IFNZ	F.HD
	MOV	(R1),(R0)+	;SAVDAE
.ENDC

LOZT:	MOV	#10,R0	;COUNT
LOST:
.IFNZ	F.HD
	MOV	#DAE,R1	;IN CASE LOOP BACK HERE
	CLR	(R1)
.ENDC
.IFZ	F.HD
	MOV	#RKDA+2,R1
.ENDC
	MOV	#SPRG,-(R1)
	CLR	-(R1)	;CMA
	MOV	#-SPRGL,-(R1)	;WC
	MOV	#3,-(R1)
GLOP2:	TSTB	(R1)
	BPL	GLOP2
	TST	(R1)
	BPL	GLOK
.IFNZ M1145+M1140
	SOB	R0,LOST
.IFF
	DEC	R0
	BGT	LOST
.ENDC
	HALT				;IT'S HOPELESS
	BR LOZT				;MAYBE IT NEEDS TIME
SHLOCK:	MOVB	#10,R0
GLOK:
.IFNZ	F.HD
	MOV	#DAE,R1
	CLR	(R1)
.ENDC
.IFZ	F.HD
	MOV	#RKDA+2,R1
.ENDC
	MOV	#SSTBL,-(R1)
	MOV	#CSTBL,-(R1)
	MOV	#-SSTBLL,-(R1)
	MOV	#5,-(R1)
GLOP3:	TSTB	(R1)
	BPL	GLOP3
	TST	(R1)
	BPL	GLOK3
.IFNZ M1145+M1140
	SOB	R0,GLOK
.IFF
	DEC	R0
	BGT	GLOK
.ENDC
	HALT
	BR SHLOCK	;YOU CERTAINLY ARE 
GNOOK:	HALT
GLOK3:	CLRB	INPFL	;NON ZERO WHEN SWAPED PROG IS IN CORE
	JMP	BREAK	;RESTORE R0 AND R1 THERE

;R1 CONTAINS #DCS
;R0 CONTAINS #SAVDCS
GOGO:	INCB	(R1)	;READ IN USER
GOGO2:	TSTB	(R1)
	BPL	GOGO2
	TST	(R1)
	BMI	GNOOK
	INCB	INPFL
	MOV	(R0)+,(R1)+
	MOV	(R0)+,(R1)+	;WC
	MOV	(R0)+,(R1)+	;CMA
	MOV	(R0)+,(R1)+	;DAR
.IFNZ	F.HD
	MOV	(R0)+,(R1)+	;DAE
.ENDC
.IFNZ	DM11
	MOV	SAVDM,DMCSR
.ENDC
;ALREADY RESTORED OTHER THINGS
	MOV	SAVR0,R0
	MOV	SAVR1,R1
.IFZ	M1145
	RTI
.ENDC
.IFNZ	M1145
	MOV	#0,STACKR	;RESTORE STACK LIMIT REG
SAVSLR=.-4
	MOV	#0,SSR3		;RESTORE SEGMENTATION STATUS REGS
SVSSR3=.-4
	MOV	#0,SSR0
SVSSR0=.-4
	RTT
.ENDC


;LOCATIONS FOR RESIDENT PORTION TO RESTORE BEFORE STARTING UP USER
	0
	0
	0	;PIDDLE INITIALIZED TO HERE
	0
	0
	0
O.UPC:	0	;USER'S PC
O.UST:	0	;USER'S STATUS
O.USP:	0	;USER'S STACK POINTER (R6)
SAVDCS:	0	;SAVED DISK REGISTERS
SAVWC:	0
SAVCMA:	0
SAVDAR:	0
.IFNZ	F.HD
SAVDAE:	0
.ENDC

.IIF L .-<HCOR-2000>,.ERROR RUGFNT TOO BIG - NO ROOM FOR CONSOLE PROGRAM.
.=HCOR-2000
;CONSOLE PROGRAM FOR THE PDP11

XSTART:	MOV	#XSTART,SP
	CLR	RELOC
	MOV	#1,R0
	JSR	PC,CNSL
	JSR	PC,XSTBLK
	JMP	XENDCN
WORD	=	.
XWORD:	0

.IIF Z FMH, CNSL.1:
CNSL:	MOV	#DCSPD+1,TSCR	;NO ITRPTS, PROPER SPEED
	MOV	#DCSPD+1,RCSR	;NO INTRPTS, PROPER SPEED
.IIF NZ FMH, CNSL.1:
	CLR	TPS		;NO INTRPTS ON TTO
	CLR	TKS		;NO INTRPTS IN TTI
XHERE3:	MOV	#XBUFF,R5
	CLR	(R5)
	MOV	R5,R4

XHERE:	TSTB	RCSR
	BMI	XTENI	;CHAR ARRIVED FROM 10
XTHERE:	TSTB	TPS	;TTO READY?
	BMI	XTTOUT
XTHR:	TSTB	TKS
	BPL	XHERE	;NONE FROM TTY

XITTI:	MOVB	TKB,R1
XITTI1:	TSTB	TSCR	;CAN YOU SEND TO TEN YET?
	BPL	XITTI1	;LOOP UNTIL CAN
	MOVB	R1,TBUF	;SEND TYPED CHAR TO TEN
	BIC	#177600,R1
	CMP	R1,#19.	;^S
	BEQ	XHERE3
	BR	XHERE

XTENI:	MOVB	RBUF,R1	;GET CHAR
	BIC	#177600,R1	;MASK JUNK
	CMP	R1,#1	;START OF BLOCK?
	BEQ	XRETN
	BLT	XOK	;BAD TO STRE ZERO IN BUFFER
	TST	R0
	BNE	XOK2
	CMP	R1,#2	;LODER SENDS THAT AT IRST. THEN ECHO (IN RUG)
	BNE	XOK
	INC	R0
XOK2:	MOVB	R1,(R5)+
	CMP	R5,#XBUFF+200
	BLE	XOK
	MOV	#XBUFF,R5
XOK:	CLRB	(R5)
	BR	XTHERE

XTTOUT:	TSTB	(R4)
	BEQ	XTHR
	MOVB	(R4)+,TPB
	CMP	R4,#XBUFF+200
	BLE	XTHR
	MOV	#XBUFF,R4
	BR	XTHR

;LOAD A SYMBOL TABLE IN SPECIAL 11LOGO;LODER FORMAT

XSTBLK:	JSR	PC,XREAD	;LOADS SYMBOL TABLE FOR $LT ALSO
	DECB	BYTE		;CHECK FOR +1 (START OF BLOCK)
	BNE	XSTBLK
	JSR	PC,XREAD	;READ ANOTHER CHAR (0 THIS TIME)
	MOV	#5,BCOUNT	;WON'T SKIP IN XGWORD WHEN DEC & WILL =3 AFTER
	CLR	CKSM
	JSR	PC,XGWORD	;GET TOTAL BYTE COUNT
	SUB	BCOUNT,XWORD	;BCOUNT=3
	CMP	BCOUNT,XWORD	;DOES IT = 3?
	BEQ	XJMPBLK
	MOV	XWORD,BCOUNT
	JSR	PC,XGWORD	;GET LOAD ADDRESS
	MOV	XWORD,ADRS	;PUT ADDRESS IN PROPER PLACE
	ADD	RELOC,ADRS
	MOV	ADRS,O.SYME	;NEW BOTTOM OF SYMBOL TABLE

;READ IN REMAINDER OF DATA
XLDATA:	JSR	PC,XGWORD
	TST	BCOUNT	;STILL DATA LEFT?
	BGT	XLDLP
	BLT	XCHECKS	;JUST CHECKSUM
	MOVB	XWORD,(ADRS)+	;ONE DATA, ONE CHECKSUM
XCHECKS:	INCB	CKSM
	BNE	XBAD
	JSR	R5,ACN
	4
	BR	XSTBLK
XLDLP:	MOVB	XWORD,(ADRS)+
	MOVB	XWORD+1,(ADRS)+
	BR	XLDATA
TENPNT:	0
XREAD:	.IFNZ TEN11
	TST TEN11S
	BEQ XREADL
	TST TENCNT
	BEQ .-4
	MOVB @TENPNT,BYTE
	DEC TENCNT
	BNE .+10
	MOV #TENBUF-1,TENPNT
	INC TENPNT
	BR XREAD1
.ENDC
XREADL:	TSTB	RCSR	;CHAR SENT YET?
	BPL	XREAD	;NO
	MOVB	RBUF,BYTE
XREAD1:	BIC	#177600,BYTE	;MASK OFF PARITY ETC
	SUB	#40,BYTE	;+40 AVOIDS CONTROL CHARATERS
XRETN:	RTS	PC

;INSTEAD OF 8 BIT FRAMES 6 BITS, THEN 4 THEN 6 WILL BE
;SENT THIS TOTALS 16 BITS
XGWORD:	JSR	PC,XREAD
	MOV	BYTE,XWORD	;WANT TO ZERO TOP BYTE
	JSR	PC,XREAD
	SWAB	BYTE
	ASR	BYTE	
	ASR	BYTE
	ADD	BYTE,XWORD
	ADD	XWORD,CKSM
	DEC	BCOUNT
	BEQ	XDONE
	JSR	PC,XREAD
	SWAB	BYTE
	ASL	BYTE
	ASL	BYTE
	ADD	BYTE,XWORD
	MOVB	XWORD+1,BYTE
	ADD	BYTE,CKSM
XDONE:	DEC	BCOUNT
	RTS	PC

XJMPBLK:	JSR	PC,XGWORD
	MOV	XWORD,ADRS
	JSR	PC,XGWORD
	INCB	CKSM
	BNE	XBAD
	JSR	R5,ACN
	4
	RTS	PC

XENDCNS:	ASR	ADRS
	BCC	XJUMP
	HALT
XBAD:	JSR	R5,ACN
	6
	BR	XSTBLK

XJUMP:	JSR	R5,ACN
	47	;DON'T SEND SYMBOLS
	ASL	ADRS
	JMP	(ADRS)

ACN:	.IFNZ TEN11
	TST TEN11S
	BEQ ACNL
	TST TENCHR
	BNE .-4
	MOV (R5)+,TENCHR
	RTS R5
.ENDC
ACNL:	TSTB	TSCR
	BPL	ACN
	MOV	(R5)+,TBUF
	RTS	R5

XBUFF:	0
.=.+200

.IIF P2, PFLAG RUGEND,\RUGEND
.END	BEGRUG
