.TITLE SITS

	.SBTTL INTERNAL REGISTER DEFINITIONS
A=%0
B=%1
C=%2
D=%3
E=%4
F=%5
P=%6
PC=%7


;MEMORY SEGMENTATION UNIT
SSR0=177572
SSR1=177574
SSR2=177576
SSR3=172516
USRISD=177600
USRDSD=177620
USRISA=177640
USRDSA=177660
SUPISD=172200
SUPDSD=172220
SUPISA=172240
SUPDSA=172260
KERISD=172300
KERDSD=172320
KERISA=172340
KERDSA=172360

;CONSOLE SWITCHES AND DISPLAY
CDISP=177570
CSWR=177570

;PROGRAM INTERUPT REQUEST REGISTER
PIRQ=177772

;STACK LIMIT REGISTER
STKLIM=177774

;PROCESSOR STATUS
PS=177776

RUGST==157000		;RUG STARTING LOCATION
;KERNAL MAP REGISTERS
I0AR=KERISA
I1AR=I0AR+2
I2AR=I1AR+2
I3AR=I2AR+2
I4AR=I3AR+2
I5AR=I4AR+2
I6AR=I5AR+2
I7AR=I6AR+2
RUGIAR=I6AR

I0DR=KERISD
I1DR=I0DR+2
I2DR=I1DR+2
I3DR=I2DR+2
I4DR=I3DR+2
I5DR=I4DR+2
I6DR=I5DR+2
I7DR=I6DR+2
RUGIDR=I6DR

VAR0AR=KERDSA
VAR1AR=VAR0AR+2
VAR2AR=VAR1AR+2
ITM0AR=VAR2AR+2
ITM1AR=ITM0AR+2
ITM2AR=ITM1AR+2
RUGDAR=ITM2AR+2
IOAR=RUGDAR+2

VAR0DR=KERDSD
VAR1DR=VAR0DR+2
VAR2DR=VAR1DR+2
ITM0DR=VAR2DR+2
ITM1DR=ITM0DR+2
ITM2DR=ITM1DR+2
RUGDDR=ITM2DR+2
IODR=RUGDDR+2

;INTERNAL TRAP VECTORS
BEBRV=4
ILLBRV=10
BPTBRV=14
IOTBRV=20
PWFBRV=24
EMTBRV=30
TRPBRV=34
PARBRV=114
PIRBRV=240
FPPBRV=244
SEGBRV=250
	.SBTTL DEVICE DEFINITIONS
;RF11 FIXED HEAD DISK
RFCS=177460	;CONTROL AND STATUS
RFWC=177462	;WORD COUNT
RFBA=177464	;BUSS ADDRESS
RFDA=177466	;DISK ADDRESS (LOW PART)
RFDAE=177470	;HIGH PART OF ADDRESS AND ERROR REGISTER
RFBRV=204

;RK11 MOVING HEAD DISK
RKDS=177400	;DRIVE STATUS REGISTER
RKER=177402	;ERROR REGISTER
RKCS=177406	;CONTROL AND STATUS REGISTER
RKWC=177410	;WORD COUNT
RKBA=177412	;BUSS ADDRESS
RKDA=177414	;DISK ADDRESS
RKBRV=220

;PROGRAMMABLE CLOCK KW11-P
PCCS=172540	;CONTROL AND STATUS
PCCB=172542	;COUNT SET BUFFER
PCCN=172544	;COUNTER
PCBRV=104	;INTERUPT VECTOR

;LINE FEQUENCY CLOCK KW11-L
LCCS=177546	;CONTROL AND STATUS
LCBRV=100	;INTERUPT VECTOR
	.SBTTL SYSTEM PARAMETERS

;FOR THE ITEM LIST
NITEMS==300.	;MAXIMUM NUMBER OF ITEMS
NITMBL==8.	;MAXIMUM NUMBER OF BLOCKS ALLOCATED TO ITEM STROAGE
NITMPS==10	;MAXIMUM DEPTH OF ITEM PUSHES
NITALS==NITMBL*64.	;NUMBER OF FREE STROAGE NODES
		;CURRENTLY ALLOCATED FOR THE WORST CASE
;DEFINITION OF AN ITEM TABLE ENTRY
ITMTEL==4	;LENGTH OF ENTRY
ITMADR==0	;WHERE THE ADDRESS OF THE ITEM IS KEPT
ITLINK==0	;ALSO USED FOR LINK OF FREE ENTRIES
ITACCS==2	;BYTE WHICH CONTAINS THE ACCESS CODE FOR THE ITEM
ITACCD==6	;ITEM ACCESS CODE (READ-WRITE NO TRAP)
ITLNGT==3	;BYTE WHICH CONTAINS THE LENGTH OF THE ITEM
;ADDRESSES OF THE ITEM SLOTS
ITM0AD==<ITM0AR-KERDSA>_12.
ITM1AD==<ITM1AR-KERDSA>_12.
ITM2AD==<ITM2AR-KERDSA>_12.

;PROCESS AND USER PARAMETERS
NPROSS==80.	;MAXIMUM NUMBER OF PROCESSES AND USERS
PRPDLL==40	;LENGTH OF THE PDL FOR THE PROCESS
;DEFINITION OF A PROCESS TABLE ENTRY
PRSTEL==14	;LENGTH OF A PROCESS TABLE ENTRY
PRTFRD==0	;FORWARD POINTER
PRTBCK==2	;BACK POINTER
PRTPPT==4	;PROCESS POINTER (OR TO ITEM IF USER)
PRTUPT==6	;USER POINTER (-1 FOR USER)
PRTJMT==10	;JMTU
PRTPRI==12	;HIS PRIORITY

;SPHERE PARAMTERS
MNCLSE==200	;MAXIMUM NUMBER OF C-LIST ENTRIES
NCLSEB==10	;NUMBER OF C-LIST ENTRIES PER BLOCK
CLSELN==10	;LENGTH OF A C-LIST ENTRY (NOTE THAT THE LENGTH OF A BLOCK=NCLSEB*CLSELN, WHATEVER IT IS)
;DEFINITION OF A C-LIST ENTRY
;(WILL GO HERE SOON)

;UPT ENTRY DEFINITION
UPTLEN==10	;LENGTH OF A UPT ENTRY
UPTDR==0	;DESCRIPTOR REGISTER (DON'T CHANGE!)
UPTDEI==100000	;THE DATA=INSTRUCTION BIT
UPTSMS==107460	;MASK TO CONVERT CONTENTS OF UPTDR FOR SEGMENTER
UPTSRT==1	;THE BOTTOM 3 BITS OF THIS BYTE IS THE LENGTH
UPTAR==2	;THE AR FOR THE SEGEMENT
UPTABT==100000	;THE ABSOLUTE PAGE BIT
UPTICR==40000	;THE IN CORE BIT
UPTMVB==20000	;THE "PAGE MOVING" BIT
UPASMS==7740	;THE MASK FOR THE ADDRESS FIELD
UPTCLP==4	;THE CIRCULAR LIST POINTER
UPTFPT==6	;THE SWAP ADDRESS OR FPT POINTER

;FOR THE CST
MNCBLK==180.	;MAXIMUM AMOUNT OF CORE IN 512 WORD BLOCKS
CSTSYB==100000	;THE "USED BY SYSTEM" BIT
CSTBEB==40000	;THE "BLOCK EXISTS" BIT
CSTFBB==20000	;THE "FIRST BLOCK OF PAGE" BIT
CSTFRB==10000	;THE FREE BIT
CSTCOM==176000	;THE CPT OFFSET MASK

;FOR THE CST
NCPTTE==MNCBLK/4	;NUMBER OF CPT TABLE ENTRIES (ASSUME AVERAGE PAGE SIZE=2K)
CPTLEN==6	;LENGTH OFA CPT ENTRY
CPTLNK==0	;THE LINK
CPTUPP==2	;THE UPT POINTER
CPTADR==4	;THE CORE ADDRESS AND MISC BITS
CPTCRM==176000	;THE CORE ADDRESS MASK
CPTSYB==100000	;THE "USED BY SYSTEM BIT" IN THE CPTADR
CPTSPB==40000	;THE "BEING SWAPPED" BIT IN THE CPTADR
CPTMOV==20000	;THE "BEING MOVED" BIT

;FOR THE LOCKED SWITCH LISTS
NLCKBL==NPROSS/2	;A GUESS
LCKLEN==10
LCKTIT==2	;TYPE AND ITEM
LCKWD1==4	;WORD ONE OF LOCK DATA
LCKWD2==6	;WORD TWO

;MISC SYSTEM PARAMETERS
LTIMEL==15.	;NUMBER OF TICKS BETWEEN CHECKING LONG FLUSHES
STIMEL==5.	;NUMBER OF TICKS BETWEEN SHORT FLUSH CHECKS
JMTUUT==6	;NUMBER OF TICKS BETWEEN JMTU UPDATES
JMTUAC==40	;ADDITIVE CONSTANT
JMTUDC==4	;DECAY CONSTANT
CLKL==1		;LEVEL CLOCK RUNS AT
CLKPIR==1_<CLKL+10>	;BIT FOR PIRQ
IPRIOR==4	;PRIORITY TO SET A NEWLY CREATED PROCESS TO
IQUANT==4	;INTIAL QUANTUM
	.SBTTL TYPES OF THINGS

;LOCK TYPES
;DON'T CHANGE THESE WITHOUT CHANGING LCKTDS
;AND MAYBE WRITING A NEW ROUTINE FOR A NEW TYPE OF LOCK
LONOFF==1_10.	;SIMPLE ON-OFF LOCK
LPCLRT==2_10.	;RUN ROUTINE IF PCLSR'ED
LCKRTN==3_10.	;RUN ROUTINE WHENEVER LOCK UNLOCKED
LCKDEC==4_10.	;DECREMENT COUNT POINTED TO
	.SBTTL DEFINITIONS FOR VARIOUS TYPES OF ITEMS
;MACROS TO DEFINE ITEMS WITH

;THE START DEFINING ITEM MACRO
	.MACRO SITEMD SYM
FOO==2
ITMTFO==ITMTFO+1
SYM==ITMTFO
	.ENDM

;THE DEFINE SYMBOL MACRO
;IF SECOND ARG IS PRESENT, IT IS HOW MUCH SPACE TO RESERVE, IN BYTES
	.MACRO DITMS SYM,SIZE
SYM==FOO
	.IIF B SIZE,FOO==FOO+2
	.IIF NB SIZE,FOO==FOO+<SIZE>
	.ENDM

;THE DEFINE FLAG WORD MACRO
;SPACE IS RESERVED FOR THE FLAG WORD, AND FLAGS ARE DEFIND
;SEQUENTIALLY FROM THE RIGHT TO THE LEFT 
	.MACRO DFWORD SYM,BITS
FOOBAR==0
SYM==FOO
FOO==FOO+2
	.IRP X,<BITS>
X==1_FOOBAR
FOOBAR==FOOBAR+1
	.ENDM
	.ENDM

;THE DEFINE ITEM SIZE MACRO
;DEFINES A SYMBOL AS THE SIZE OF THE ITEM DEFINED SO FAR
	.MACRO DITMSZ SYM
SYM==FOO_-6
	.ENDM
ITMTFO==0	;THE TYPE OF THE LAST ITEM DEFINED
ITTYPE==0	;FOR ALL ITEMS, THE FIRST WORD IS THE TYPE
;DEFINITION OF A PROCESS ITEM
SITEMD ITPROC
;THE NEXT THREE SHOULD NOT BE MOVED
;WITHOUT MOVING THE COORESPONDING THREE IN THE USER DEFINITION
DITMS PRSREF		;REFERENCE COUNT
DITMS PPRTPT		;POINTER TO PROCESS TABLE
DITMS PQBIT		;THE QUQUE BIT
DITMS PTUSED,4		;TIME USED BY THIS PROCESS IN HALF-TICKS
DITMS PFAULT		;IF NON-ZERO, THE FAULT NOT YET COMPLETED
DITMS PSPHRP		;POINTER TO SPHERE
DITMS PSPHCP		;CIRCULAR POINTER TO OTHER PROCESSES IN SPHERE
DITMS PLCKSL		;END OF THE LOCKED SWITCH LIST
DITMS PUPDLO		;OFFSET OF USER'S PDL IF CALL COMPLETES
DITMS PITEM2		;PROCESS'S ITEM2
DITMS PUPT0,UPTLEN	;UPT FOR RANDOMNESS
DITMS PUREGS,14		;THE USER'S REGISTER'S
DITMS PUP		;THE USER'S PDL POINTER
DITMS PUPC		;THE USER'S PC
DITMS PUPS		;THE USER'S PROCESSOR STATUS
DITMS PSREGS,14		;THE SYSTEM'S REGISTERS
DITMS PSP		;THE SYSTEM'S PDL POINTER
DITMS PSPC		;THE SYSTEM'S PC
DITMS PPDL,PRPDLL	;THE PROCESS'S PDL
DFWORD PFLAGS,<PFPFLG,PACSVF>	;PROCESS FLAG WORD
DITMS PSTOPC		;STOP COUNT
DFWORD PSTOP,<PSPHSB,PSUPSB>	;STOP WORD
;PSPHSB INDICATES THE SPHERE HAS STOPPED THE PROCESS
;PSUPSB INDICATES SOME OTHER SUPERIOR PROCESS HAS STOPPED IT
DITMSZ PRSLNF		;SIZE WITH NO FLOATING POINT
DITMS PFPPRG,24.*2	;FLOATING POINT REGISTERS
DITMS PFPPS		;FLOATING POINT STATUS
DITMS PFEC		;FLOATING EXCEPTION CODE
DITMS PFEAP		;FLOATING EXCEPTION ADDRESS POINTER
DITMSZ PRSLFP		;LENGTH WITH FLOATING POINT

;DEFINITION OF A USER ITEM
SITEMD ITUSER
;THE NEXT THREE SHOULD NOT BE MOVED (SEE PROCESS)
DITMS USRREF		;THE REFERENCE COUNT
DITMS UPRTPT		;POINTER INTO PROCESS TABLE
DITMS UQBIT		;THE QUQUE BIT (HAD BETTER BE USER QUQUE)
DITMS UTUSED,4		;TIME USED BY THIS USER
DITMSZ USRLEN		;LENGTH OF A USER ITEM
;DEFINITION OF A SPHERE ITEM
SITEMD ITSPHR
DITMS SPHREF		;REFERENCE COUNT
DITMS SPHPRP		;POINTER TO FIRST PORCESS
DITMS SSTOPC		;THE STOP COUNT
DITMS SSTOPF		;THE STOP FLAGS
DITMS SUSRPT		;POINTER TO USER ITEM RESPONSIBLE FOR THIS SPHERE
DITMS SCLSEP		;POINTER TO FIRST UNUSED LOCATION, RELATIVE TO ITEM
DITMS SUPTS,16.*UPTLEN	;THE UPT ENTRIES
DITMS SCLSTT,MNCLSE/NCLSEB	;THE INDEX OFFSETS TO THE C-LIST
DITMS SICLST,NCLSEB*CLSELN*2	;START WITH 2 BLOCKS OF C-LIST
DITMSZ SPHLEN
	.SBTTL MACROS FOR GENERATING CODE

;MACRO TO PUSH THINGS ONTO THE STACK
.MACRO SAVE THINGS
.IRP X,<THINGS>
	MOV X,-(P)
.ENDM
.ENDM

;MACRO TO POP THINGS FROM STACK
.MACRO REST THINGS
.IRP X,<THINGS>
	MOV (P)+,X
.ENDM
.ENDM
;MACRO TO REPLACE .WORD
.MACRO WORDS A,IB,C,D,E,F,G,H,I,J,K,L,M,N
.IRP X,<A,IB,C,D,E,F,G,H,I,J,K,L,M,N>
.IIF B X,.MEXIT
X
.ENDM
.ENDM

;MACRO TO REPLACE .BYTE
.MACRO BYTES A,IB,C,D,E,F,G,H,I,J,K,L,M,N
.IRP X,<A,IB,C,D,E,F,G,H,I,J,K,L,M,N>
.IIF B X,.MEXIT
.BYTE X
.ENDM
.ENDM
	.SBTTL TRAP VECTORS
	.MACRO TRAPV DEV,PRI
.=DEV'BRV
.IIF P2,.IIF NDF DEV'BRK,DEV'BRK==0
	DEV'BRK
.IIF NB PRI,	PRI_5
.IIF B PRI,	200
.ENDM
	.=0
	BPT
	.=4
	.REPT 77
	.+2
	IOT
	.ENDR

;TRAP VECTORS FOR INTERNAL DEVICES
TRAPV BE	;BUSS ERRORS
TRAPV ILL	;ILLEGAL INSTRUCTIONS
TRAPV BPT	;BREAKPOINTS
TRAPV IOT	;IOT
TRAPV PWF,7	;POWER FAILURE
TRAPV EMT	;EMT
TRAPV TRP	;TRAP
TRAPV PAR	;PARITY ERROR
TRAPV PIR,7	;PROGRAMMED INTERUPT
TRAPV FPP	;FLOATING POINT ERROR
TRAPV SEG	;SEGMENTATION ABORT OR TRAP

;TRAP VECTORS FOR OTHER DEVICES
TRAPV RF	;FIXED HEAD DISK
TRAPV RK	;MOVING HEAD DISK
TRAPV LC,CLKL	;LINE CLOCK
TRAPV PC,CLKL	;PROGRAMABLE CLOCK

	.=400
	.SBTTL SYSTEM VARIABLES AND TABLES

	.BLKW 100	;FOR THE SYSTEM PDL
PDL:
PATCH:
PAT:	.BLKW 100
	.BLKW 40
SYSJPD:		;THE SYSTEM JOB'S PDL
%CSX:	.BLKW 4	;PLACE FOR SIMULATOR TO DO X'S
BMT:	BYTES 1,2,4,10,20,40,100,200	;BIT MARK TABLE
	;FOR MARKING BIT TABLES, THE NTH ENTRY IS THE NTH BIT
INITSW:	-1	;ZERO AFTER EXITING INIT CODE
PRUNNG:	-1	;ITEM # OF RUNNING PROCESS, NEG=> IN SYSTEM
			;(THIS IS NOT SET TO -1 BY INTERUPT ROUTINES)
USRMOD:	-1	;IF A PROCESS IS RUNNING, NON-ZERO=> IN SYSTEM CODE
			;0=>IN USER'S CODE
CURUSR:	-1	;PROCESS BLOCK INDEX OF THE RUNNING PROCESS'S USER
CURSPH:	-1	;ITEM INDEX OF SPHERE OF THE RUNNING PROCESS
QUANT:	0	;NUMBER OF TICKS BEFORE THE RUNNING PROCESS SHOULD BE STOPPED
PQUANT:	IQUANT	;QUANTUM TO GIVE A PROCESS WHEN YOU START IT
TUSED:	0	;TIME THE PROCESS HAS USED SINCE LAST STARTED
TIME:	.BLKW 2	;TIME SINCE SYSTEM STARTED IN T˘0Â”ÒTÍIõ¯¥ù	aÒ.ÍIõ¯®*Iô˘à'E±˙à!»ã¯r–OçÙ‰O•T FLU˙r"”ÒS*Iõ¯¥ù	aÒ.ÍIõ¯®*Iô˘à'E±˙à!»ã¯r–OçÙ'ŒèÙ¶UßES
JMTUUP:	JMTUUT	;NUMBER OF TICKS TILL NEXT UPDATE OF JMTUS
PIRDIS:	WORDS PIRLOS,STOPPR,PIRLOS,PIRLOS,PIRLOS,PIRLOS,PIRLOS,PIRLOS	;THE PIR DISPATCH
PIRBIT:	WORDS 0,1000,2000,4000,10000,20000,40000,100000	;THE PIR BITS
LCKDIS:	WORDS LSWPOR,LSPONF,LSPERR,LSPERR
;EMT DISPACTCH TABLES
.MACRO EMTD NAME
.IF NB NAME
M'NAME==FOO
.'NAME==FOO+EMT
	E'NAME
.IFF
	BADEMT
.ENDC
FOO==FOO+1
.ENDM

FOO==0
EMTDIS:
	EMTD NOOP	;NOP CALL
	EMTD FORK
	EMTD POOFF
	EMTD SLEEP
EMTHGH==FOO
;INITALIZE TABLES
.MACRO ILIST AD,FREE,NUM,LEN
WORDS AD+LEN,FREE,NUM-2,LEN
.ENDM
INITLS:	ILIST ITMTAB,ITMFRE,NITEMS,ITMTEL
	ILIST ITMALS,ITMAFR,NITALS,4
	ILIST LCKTAB,LCKFRE,NLCKBL,LCKLEN
	0
;FOR THE ITEM TABLE
.IRPC X,<012>
ITEM'X:	-1		;ITEM CURRENTLY IN PAGE ITM0
ITM'X'A:	ITM'X'AD	;ADDRESS OF ITEM IN ITEM'X (CONSTANT NOW)
ITM'X'D:	0	;PUSH DEPTH
ITM'X'P:	ITM'X'PD		;PDL POINTER FOR ITM'X
	.BLKW NITMPS	;PDL FOR ITM'X'
ITM'X'PD::
.ENDM
ITMATB:	.BLKW 200	;ITEM ALLOCATE TABLE (ONE WORD PER SIZE)
			;THESE POINT INTO ITMALS
ITMAFR:	.BLKW 1		;FREE POINTER INTO NODES
ITMALS:	.BLKW NITALS*2	;TWO WORDS FOR EACH ALLOCATE NODE
ITMFRE:	.BLKW 1		;POINTER TO FREE LIST OF ITME TABLE
;NOTE THAT THE FIRST BLOCK IS NEVER USED, SO INDEX IS ALWAYS NON-ZERO
ITMTAB:	.BLKB NITEMS*ITMTEL
ITMBAL:	.BLKW 1		;ITEM BLOCK STORAGE ALLOCATE LOCK
INITM1::	;INITIALIZE FOLLOWING AREA TO -1
ITMBNF:	.BLKW NITMBL	;NUMBER OF BLOCKS FREE IN THIS BIG BLOCK
ITMBST:	.BLKW NITMBL	;ADDRESS OF FIRST BLOCK OF THIS BIG BLOCK
ITMBTP:	.BLKW NITMBL	;POINTERS TO BEGGININGS OF BIT TABLES
	.BLKW 1		;THIS IS THE BACKWARDS-SEARCHING FENCE FOR THE 1ST BIT TABLE
ITMBIT:	.BLKW 11*NITMBL	;8 WORD BIT TABLE FOR EACH BIG BLOCK
				;AND A FENCE BETWEEN THE BLOCKS
EINTM1::	;END OF STUFF TO INIT TO -1
;THE LOCKED SWITCH LISTS
LCKFRE:	.BLKW 1	;THE FREE POINTER
LCKTAB:	.BLKB NLCKBL*LCKLEN	;STORAGE FOR THE LOCKS
	;FOR THE PROCESS TABLE
;MACRO FOR DEFINING A QUQUE
.MACRO DEFQ NAME
NAME'Q:	.BLKW 2
NAME'QB==1_FOO
	1_FOO
FOO==FOO+1
.ENDM
QLEN==6		;THE LENGTH OF A QUQUE POINTER
QBIT==4		;POSITION OF QUQUE BIT WITHIN THE POINTER
FOO==0		;INITALIZE THE QUQUE NUMBER
FIRSTQ==.
DEFQ RUN	;GUYS WHO CAN BE RUN IMMEDIATELY
DEFQ PAGW	;GUYS WAITING FOR PAGES TO BE SWAPPED IN
DEFQ SWPB	;GUYS WHO ARE SWAP BLOCKED
DEFQ SFLS	;GUYS IN SHORT WAITS
DEFQ LFLS	;GUYS IN LONG WAITS
DEFQ STOP	;GUYS WHO ARE STOPPED
DEFQ USER	;FOR CONFORMITY, USERS ARE KEPT HERE
NQS==FOO
PFREEQ:	WORDS PRSTAB,0,0	;FREE PROCESS BLOCKS LIST POINTER
FOO==PRSTAB+PRSTEL
FOOBAR==PFREEQ
PRSTAB:	.REPT NPROSS
	FOO
	FOOBAR
FOO==FOO+PRSTEL
FOOBAR==.-4
	.=.+PRSTEL-4
	.ENDR
	WORDS 0,FOOBAR
	.BLKB PRSTEL-2	;THE LAST PROCESS BLOCK MUST GO HERE

;MEMORY TABLES
CST:	.BLKW MNCBLK	;ONE WORD PER BLOCK
MEMIAT:	WORDS 1,0,0,2,0,1,0,3	;INTIAL CORE ALLOCATIONS
FMMALT:	.BLKW 8		;ONE WORD PER PAGE SIZE (FOR FREE PAGES)
UMMALT:	.BLKW 8		;SAME FOR USED PAGES
CPT:	0	;UNUSED WORD
	.BLKB NCPTTE*CPTLEN	;THE ACTUAL CPT ENTRIES
CPTEND::
	.SBTTL ITEM TABLE ROUTINES
.IIF NZ ITMADR!ITLINK,.ERROR NO, IT WON'T WORK WITH ITLINK OR ITADDR NON-ZERO
;CREATE AN ITEM OF SPECIFIED SIZE
;THE SIZE IS PUT INTO A; THE ITEM'S INDEX RETURNS IN B
;THE Z BIT IS SET IF THE ITEM CANNOT BE CREATED; OTHERWISE, IT IS CLEARED
;THIS MAKES NO ATTEMPT TO COMPRESS EXISTING ITEMS TO PRODUCE CONTIGOUS FREE SAPCE
;THAT FEATURE IS OF SOMEWHAT QUESTIONALBE VALUE, BUT MIGHT BE ADDED LATER
CRITEM:	MOV ITMFRE,B	;ATTEMPT TO GET A FREE ITEM
	BEQ CRITM1	;NO MORE AVAILABLE, GO LOSE
	SAVE <C,D>
CRITM8:	TSTB ITACCS(B)	;IS THIS ITEM TABLE ENTRY REALLY FREE?
	BEQ .+4
	BPT		;OOPS!!
	MOV A,C		;GET THE LENGTH
	ASL C		;CONVERT IT TO AN INDEX
	ADD #ITMATB,C	;INTO THE ALLOCATE TABLE
	CLR D		;FOR THE LEFTOVER COUNT
CRITM3:	TST (C)+	;IS THERE A FREE ITEM BLOCK OF THIS SIZE?
	BNE CRITM2	;YES, GO USE IT
	TST (D)+	;ONE MORE TO FREE WHEN WE FINALLY FIND
			;A BLOCK BIGGER THAN WHAT WE REALLY WANTED
	CMP #ITMATB+400,C	;ARE WE ALREADY OFF THE TOP?
	BNE CRITM3	;NOPE, NOT YET
;IF WE GET HERE WE HAVE TO ALLOCATE A NEW BIG BLOCK
	TST ITMBAL	;IS SOMEONE ELSE ALREADY ALLOCATING?
	BEQ CRIT11	;NO, GO LOCK THE SWTICH
CRIT13:	JSR PC,SFLUSH	;WAIT FOR THE OTHER GUY TO BE DONE
	TST ITMBAL	;DONE YET?
	BNE CRIT13	;NOPE
	JSR PC,RUNME	;DONE, NOW  SEE IF HE LEFT ENGOUGH FOR US
CRIT16:	MOV ITMFRE,B	;HAVE TO GET ANOTHER ITEM
	BEQ CRIT12	;MAYBE OTHER PEOPLE TOOK THEM ALL
	BR CRITM8	;NOPE
CRIT11:	SAVE A	;LOCK SWTCH SO NO ONE ELSE GETS TO THIS CODE
	MOV #ITMBAL,A
	MOV #-1,B	;USE ALL THE BITS
	JSR PC,LCKASW	;IN CASE WE HANG WAITING FOR A BLOCK
	MOV #NITMBL,B	;FIND A FREE ITEM BLOCK SLOT
	MOV #ITMBST,C
CRIT10:	TST (C)+	;NEGATIVE INDICATES FREE
	BLT CRITM9	;FOUND ONE!
	SOB B,CRIT10	;KEEP TRYING
	JSR PC,LSWPOP	;LOSE, NO SPACE TO PUT ANOTHER BLOCK
	REST A
CRIT12:	REST <D,C>
CRITM1:	SEZ		;INDICATE FAILURE
	RTS PC
;NO, THIS ISN'T THE END OF THE ROUTINE!
CRITM2:	MOV (B),ITMFRE	;NOW THE ITEM POINTED TO BY THIS ONE IS
			;THE BEGINNING OF THE FREE LIST
	MOVB A,ITLNGT(B)	;SET IN THE LENGTH
	MOVB #ITACCD,ITACCS(B)	;AND THE ACCESS CODE
	SAVE <E,F>
	MOV -(C),E	;GET A POINTER TO THE NODE FOR THE FREE BLOCK
	MOV (E),(C)	;SPLICE OUT THIS NODE
	MOV 2(E),F	;ADDRESS OF THE BLOCK
	MOV F,(B)	;PUT IT AWAY IN THE ITEM
	MOV F,C		;COPY IT
	BIC #170000,F	;GET THE ADDRESS PART
	SAVE F		;AND SAVE IT FOR LATER
	MOV F,(B)	;PUT IT AWAY IN THE ITEM
	TST D		;IS THERE ANY LEFTOVER?
	BEQ CRITM4	;NO, JUST GO FREE THE NODE
	TST -(D)	;CORRECT D, IT'S OVERENTHUSIASTIC
	MOV ITMATB(D),(E)	;PUT THE NODE INTO THE LIST FOR THE LEFTOVER SIZE
	MOV E,ITMATB(D)		;THERE!
	ADD A,2(E)	;ADD THE AMOUNT USED TO THE ADDRESS
	INC 2(E)	;SINCE ZERO IS ONE(?)
	BR CRITM5	;NOW GO USE WHAT WE GOT
CRITM4:	MOV ITMAFR,(E)	;LINK IT BACK TO THE FREE LIST
	MOV E,ITMAFR
CRITM5:	JSR PC,BITSET	;GRAB THE BLOCKS WE WANT
	TST (P)+	;FLUSH THE ADDRESS FROM THE STACK
	SUB #ITMTAB,B
	REST <F,E,D,C>
	CLZ
	RTS PC
CRITM9:	MOV #FMMALT+6,A	;START BY LOOKING FROM 2K UPWARDS
	MOV #5,B	;2K, 2.5K, 3K, 3.5K 4K
CRIT17:	MOV (A),D	;ANYONE HOME?
	BEQ .+6		;NOPE, NOT THIS SIZE
	JSR PC,CRIT19	;GO SEE IF WE CAN GOBBLE IT
	TST (A)+	;NEXT!
	SOB B,CRIT17	;FOR THE 5 DIFFERNET SIZES
	MOV #10,B	;OK, I'LL TAKE ANY SIZE
CRIT18:	MOV -(A),D	;ANY?
	BEQ .+6		;NOPE
	JSR PC,CRIT19	;CAN I HAVE SOME?
	SOB B,CRIT18
	HALT		;HERE, SWAP SOMETHING OUT!

CRIT19:	SAVE A
CRIT20:	BIT #CPTMOV,CPTADR+CPT(D)	;IS IT MOVING?
	BEQ CRIT21	;NO, TAKE IT AWAY
	MOV D,A		;SAVE POINTER TO PREVIOUS
	ADD #CPT,A	;ALWAYS A CORE ADDR
	MOV CPT(D),D	;LINK THROUGH
	BNE CRIT20	;TRY NEXT ONE
	REST A		;NO MORE GIVE UP
	RTS PC
CRIT21:	MOV CPT(D),(A)	;TAKE OFF THE FREE LIST
	REST A
	TST (P)+	;FLUSH RETURN ADDRESS
	SUB #FMMALT,A	;MAKE IT RELATIVE
	MOV UMMALT(A),CPT(D)	;POINT IT TO A USED LIST
	MOV D,UMMALT(A)	;CLOBBER THE USED POINTER
	MOV CPT+CPTADR(D),B	;THE ADDRESS OF THING WE GOBBLED
	ASH #4,B	;CONVERT TO AN AR-STYLE
	BIC #170017,B
	ASH #3,A	;THE LENGTH
	BIS #17,A	;CONVERT TO DR-STYLE
	JSR PC,LSWPOP
;DONE ALLOCATING CORE
;FALL THROUGH TO NEXT PAGE
;FALLS IN FROM PREVIOUS PAGE
	MOV B,-(C)	;B GETS THE ADDRESS
	SUB #ITMBST,C	;UN-RELATIVE IT
	MOV A,ITMBNF(C)	;A GETS THE NUMBER OF BLOCKS GOBBLED
	MOV ITMAFR,D	;GET AN ALLOCATE NODE
	BNE .+4		;THERE SHOULD ALWAYS BE ONE AVAILABLE
	BPT
	MOV (D),ITMAFR	;SPLICE IT OUT OF THE FREE LIST
	SAVE C		;SAVE FOR LATER
	ASH #11.,C	;PUT IT INTO THE HIGH FOUR BITS
	ADD B,C		;COMBINE THE BLOCK ADDRESS AND THE BIG BLOCK NUMBER
	MOV C,2(D)	;AND SAVE IT IN THE NODE
	ASL A		;CONVERT SIZE OF BLOCK TO WORD OFFSET
	MOV ITMATB(A),(D)	;SPLICE THIS NODE
	MOV D,ITMATB(A)	;INTO LIST FOR THIS SIZE
	ASR A		;RESTORE A
	REST C		;GET THE INDEX INTO THE BLOCK VARIABLES
	MOV ITMBTP(C),C	;ADDRESS OF THE BIT TABLE FOR THIS BLOCK
	MOV C,D		;COPY POINTER TO BIT TABLE
	MOV #8.,B	;THERE ARE 8 WORDS
CRIT14:	MOV #-1,(C)+	;FIRST, SET ALL BLOCKS AS USED
	SOB B,CRIT14	;DO 8 TIMES
	INC A		;0 IS ONE BLOCK!
	ASH #-4,A	;COVERT TO 512 WORD BLOCKS
CRIT15:	CLR (D)+	;THERE WILL ALWAYS BE AT LEAST ONE
	SOB A,CRIT15	;DO UP TO 8 TIMES
	JSR PC,LSWPOP
	REST A
	JMP CRIT16	;NOW GO TRY THE WHOLE THING AGAIN!
;THIS ISN'T THE END EITHER
;DELETE THE ITEM WHOSE ITEM NUMBER IS IN A
;A GETS CLOBBERED
;THIS MAKES NO ATTEMPT TO RETURN AN EMPTY BIG BLOCK
;THAT FEATURE SHOULD BE ADDED AS SOON AS POSSIBLE (PROBABLY)
DLITEM:	SAVE <B,C,D,E,F>
	CLR -(P)	;SAVE A STACK WORD FOR TEMP
	ADD #ITMTAB,A	;RELOCATE INDEX TO BE ACTUAL ADDRESS
	TSTB ITACCS(A)	;IS THIS ITEM FOR REAL?
	BNE .+4
	BPT		;OOPS!
	MOV (A),E	;GET THE ADDRESS AND BLOCK # OF THE ITEM
	MOVB ITLNGT(A),(P)	;SAVE THE LENGTH ON THE STACK
	MOV ITMFRE,(A)	;PUT THE NEWLY-FREED NODE ON THE HEAD OF THE
	CLRB ITACCS(A)	;MARK IT AS FREE
	MOV A,ITMFRE	;FREE LIST. IT WON'T BE FREE LONG!
	INC (P)		;CORRECT FOR OFFSET
	MOV (P),F
	MOV E,A
	JSR PC,BITCLR	;CLEAR THE BITS OF THE BLOCK WE ARE FREEING
	MOV #-1,C	;NOW SEE IF THE SPACE BEFORE THE BLOCK IS FREE
	DEC E		;LOOK BEFORE THE BLOCK
	JSR PC,CNTFRE	;GO SEE IF THERE'S ANYTHING WE CAN FREE
	MOV E,F		;SAVE THE REAL BEGGING ADDRESS
	ADD (P),E	;GO TO THE END OF THE SO-FAR FREE BLOCK
	MOV #1,C	;NOW SEARCH FORWARD
	JSR PC,CNTFRE	;GO SEE IF ANYTHING THERE AND FREE WHATEVER YOU FIND
	MOV F,C		;GET THE REAL BEGGINING OF THE BLOCK
	JSR PC,BLKFRE	;FREE THE BLOCK WE HAVE FOUND
	TST (P)+	;FLUSH THE COUNT FROM THE STACK
	REST <F,E,D,C,B>
	RTS PC
;EXPAND OR CONTRACT ITEM WHOSE INDEX IS IN B
;TO THE SIZE IN A
;CLEAR Z IF SUCCESSFUL, OTHERWISE SET Z
EXITEM:	SAVE <F,E,D,C,B,A>
EXITM4:	TSTB ITACCS+ITMTAB(B)	;IS THIS ITEM FOR REAL?
	BNE .+4
	BPT		;OOOPS!
	CMPB A,ITLNGT+ITMTAB(B)	;WHAT IS THE RELATION OF THE DESIRED LENGTH
				;TO THE CURRENT LENGHT?
	BGT EXITM2	;NEED TO ADD MORE TO THE ITEM
	BEQ EXITM1	;THE ITEM IS ALREADY THE DESIRED LENGTH
			;GET HERE TO REMOVE EXTRA STUFF FROM ITEM
	MOVB ITLNGT+ITMTAB(B),F	;GET THE CURRENT LENGTH
	SUB A,F		;DIFFERENCE BETWEEN CURRENT AND DESIRED
	SAVE F		;SAVE THE NUMBER OF BLOCKS TO BE FREED
	MOV ITMADR+ITMTAB(B),E	;ADDRESS OF THE ITEM
	MOVB A,ITLNGT+ITMTAB(B)	;SET THE NEW LENGTH INTO THE ITEM
	ADD A,E		;GET TO THE END OF THE DESIRED PART
	INC E		;CORRECT IT
	MOV E,A		;MAKE THE ROUTINE HAPPY
	JSR PC,BITCLR	;CLEAR THE NEWLY FREED AREA
	MOV E,F		;SAVE THE ADDRESS OF THE BLOCK WE ARE ABOUT TO FREE
	ADD (P),E	;END OF AREA WE KNOW TO BE FREE
	MOV #1,C	;SEARCH FORWARD
	JSR PC,CNTFRE	;LOOK FOR FREE BLOCKS AND FREE THOSE YOU FIND
	MOV F,C		;PUT ADDRESS OF BLOCK INTO THE RIGHT PLACE
	JSR PC,BLKFRE	;PUT FREE BLOCKS ON FREE LIST
	TST (P)+	;GET RID OF COUNT ON PDL
EXITM1:	REST <A,B,C,D,E,F>
	CLZ
	RTS PC
;CONTINUED NEXT WEEK (ACTUALLY, NEXT PAGE)
;GET HERE IF MORE SPACE NEEDED FOR ITEM
EXITM2:	MOV ITMADR+ITMTAB(B),E	;ADDRESS OF START OF ITEM
	MOVB ITLNGT+ITMTAB(B),A	;GET CURRENT SIZE
	ADD A,E		;TO GET END OF CURRENT BLOCK
	INC E		;CORRECT IT
	MOV E,D		;NOW FIND WHICH BLOCK
	ASH #-11.,D
	BIC #177741,D	;WORD INDEX
	MOV #1,C	;NOW SEARCH FORWARD FOR FREE BLOCKS
	JSR PC,CNTBLK
	BLT EXITM3	;FORGET THIS IF THERE AREN'T ANY
	MOV (P),C	;GET THE DESIRED COUNT
	INC A		;CORRECT THE AMOUNT FOUND
	SUB A,C		;C=AMOUNT NEEDED-EXTRA FOUND
	MOVB ITLNGT+ITMTAB(B),F	;THE AMOUNT WE ALREADY HAVE
	CMP C,F		;WILL THE TOTAL BE ENOUGH?
	BGT EXITM3	;NO, FORGET IT
	ADD A,F		;YES, WHAT IS THAT TOTAL?
	MOVB F,ITLNGT+ITMTAB(B)	;THAT IS THE NEW ITEM LENGTH
	MOV A,F		;SAVE THE NUMBER OF BLOCKS WE ARE STEALING
	DEC A		;UNCORRECT IT
	JSR PC,FINDEL	;DELETE IT FROM THE FREE LIST
	MOV F,A		;GET THE COUNT BACK
	MOV E,C		;MAKE THE ROUTINE HAPPY
	SAVE E		;HAPPY!!??
	JSR PC,BITSET	;INDICATE THOSE BLOCKS IN USE
	TST (P)+	;GET RID OF THE GARBAGE
	MOV (P),A	;NOW, HOW MUCH DID WE REALLY WANT?
	MOV 2(P),B	;FOR WHAT ITEM?
	BR EXITM4	;GO FLUSH ANY EXTRA WE TOOK
;GET HERE IF THE BLOCK CAN'T BE EXPANDED NICELY
EXITM3:	MOV (P),A	;GET THE DESIRED SIZE
	JSR PC,CRITEM	;GET AN ITEM OF THE RIGHT SIZE
	BNE EXITM6	;GOT IT, GO USE IT
	REST <A,B,C,D,E,F>	;LOSE, RESTORE AC'S AND GET OUT
	SEZ
	RTS PC
;TO BE CONTINUED (NEXT PAGE)
EXITM6:	MOV B,A		;LOAD THE NEW ITEM INTO THE MAP
	JSR PC,ITM0PL	;PUSH AND LOAD
	MOV A,C		;SAVE THE ADDRESS IT WAS LOADED AT
	MOV 2(P),D	;THE ITEM WE WANT TO EXPAND (COPY)
	MOV D,A		;LOAD IT INTO THE MAP TOO
	JSR PC,ITM1PL	;PUSH AND LOAD
	MOVB ITLNGT+ITMTAB(D),F	;GET THE LENGTH OF THE OLD THING
	INC F		;CORRECT IT
	ASH #5,F	;CONVERT TO WORDS
	MOV (A)+,(C)+	;COPY THE BLOCK
	SOB F,.-2
	JSR PC,ITM0PO	;POP ITEM0
	JSR PC,ITM1PO	;POP ITEM1
	MOV B,A		;SAVE THE NEW ITEM INDEX
	ADD #ITMTAB,D	;MAKE AN ACTUAL ADDRESS
	ADD #ITMTAB,B
	MOV #ITMTEL/2,F	;NUMBER OF WORDS TO EXCAHNGE
EXITM5:	MOV (B),E
	MOV (D),(B)+
	MOV E,(D)+
	SOB F,EXITM5	;EXCAHNGE OLD AND NEW ITEMS
	JSR PC,DLITEM	;DELETE THE NEW ITEM SLOT WITH THE OLD ITEM CONTENTS!!
	BR EXITM1	;RETURN SUCESSFULLY, IF SOMEWHAT WEARILY


;CLEAR ITEM WHOSE INDEX IS IN B
;IT'S LENGTH IS IN A. IT IS ALSO LOADED INTO ITEM0
;AND ITEM0'S PDL IS PUSHED. A IS CLOBBERED TO THE ADDRESS OF THE ITEM
CLITEM:	SAVE C		;FOR THE WORD COUNT
	MOV A,C		;THE BLOCK COUNT
	INC C		;CORRECTED
	ASH #5,C	;CONVERT TO WORDS
	MOV B,A		;THE ITEM TO CLEAR
	JSR PC,ITM0PL	;GETS LOADED
	ADD C,A		;POINT A TO THE END OF THE ITEM
	ADD C,A		;SINCE C IS A WORD COUNT
	CLR -(A)	;CLEAR TE ITEM, CORRECTING A
	SOB C,.-2	;CLEAR ALL THE WORDS
	REST C
	RTS PC
;SET THE BITS IN THE ITEM BLOCK BIT TABLE
;THE STARTING ADDRESS IS EXPECTED IN C AND 2(P)
;THE COUNT OF BLOCKS (UNCORRECTED) IS EXPECTED IN A (IT SHOULD NOT BE -1)
;CLOBBERS C,D,E AND F
BITSET:	ASH #-11.,C	;GET THE BIG BLOCK NUMBER
	BIC #177741,C
	DEC ITMBNF(C)	;CORRECT FOR 0=1
	SUB A,ITMBNF(C)	;THAT MANY FEWER BLOCKS AVAILABLE
	MOV 2(P),E	;GET THE ADDRESS BACK
	MOV A,D		;AND A COUNT WE CAN MUNGE
	SUB ITMBST(C),E	;CONVERT TO BLOCK WITHIN BIG BLOCK
	ASHC #-3.,E	;FIGURE IT OUT YOURSELF
	ASH #-13.,F
	BIC #177770,F
	ADD ITMBTP(C),E	;MAKE IT POINT INTO THE BIT TABLE
	INC D		;SINCE 0=1
BITST1:	BISB BMT(F),(E)	;SET THE BIT
	INC F		;CHANGE THE BIT NUMBER
	BIT #7,F	;HAVE WE JUMPED A BYTE?
	BNE BITST2	;NOT YET
	CLR F		;NEW BIT NUMBER
	INC E		;AND NEW BYTE NUMBER
BITST2:	SOB D,BITST1	;DO FOR HOWEVER MANY LITTLE BLOCKS
	RTS PC
;CLEAR BITS IN THE BIT TABLE FOR THE ITEM BLOCK
;EXPECTS THE STARTING ADDRESS IN A AND THE COUNT (CORRECTED) IN F
;CLOBBERS A,B,D AND F
BITCLR:	MOV A,D		;COPY IT
	ASH #-11.,D	;TO GET THE BLOCK #
	BIC #177741,D	;CLEAR BITS THAT MAY BE SET BY ASH
	BIC #170000,A	;GET RID OF THE BLOCK NUMBER
	SUB ITMBST(D),A	;AND MAKE RELATIVE TO START OF BLOCK
	ASHC #-3,A	;KNOCK THE BIT ADDRESS OFF THE END
	ASH #-13.,B	;AND PUT IT IN IT'S PLACE
	BIC #177770,B	;OH FOR A LSH!
	ADD ITMBTP(D),A	;ADDRESS IN THE BIT TABLE
	ADD F,ITMBNF(D)	;MORE FREE SPACE!
;THIS IS WHERE THE RETURN BIG BLOCK STUFF SHOULD GO
BITCL1:	BICB BMT(B),(A)	;THIS BLOCK NOW FREE
	INC B		;GO TO NEXT BIT ADDRESS
	BIT #7,B	;TO NEXT BYTE?
	BNE BITCL2	;NOT YET
	CLR B		;ZEROTH BIT
	INC A		;IN THE NEXT BYTE
BITCL2:	SOB F,BITCL1	;CLEAR UNTIL DEAD
	RTS PC
;PUT AN ENTRY ON THE APPROPRIATE FREE LIST FOR THE BLOCK WE HAVE FREED
;EXPECTS THE COUNT (CORRECTED) ON 2(P), THE ADDESS OF THE BLOCK IN C
;CLOBBERS A AND B
BLKFRE:	MOV 2(P),A	;AND IT'S LENGTH
	DEC A		;SIGH
	ASL A		;CONVERT THE LENGTH INTO A WORD INDEX
	ADD #ITMATB,A	;NOW, THE ADDRESS IN THE ALLOCATE TABLE
	MOV ITMAFR,B	;GET THE FIRST FREE ALLOCATE NODE
	BNE .+4		;WE SHOULD NEVER RUN OUT OF THESE!
	BPT
	MOV (B),ITMAFR	;SPLICE IT OUT
	MOV (A),(B)	;SPLICE INTO THE LIST FOR THIS SIZE BLOCK
	MOV B,(A)	;AND FIX THE POINTER TO THE LIST
	MOV C,2(B)	;FINALLY, THE LOCATION OF THE NEWLY FREED BLOCK
	RTS PC


;THIS ROUTINE IS SPECIAL FOR DLITEM
;IT FINDS FREE SPACE A TACKS IT ON TO EXISTING FREE SPACE
;NOTE THAT THE WORD AT 2(P) IS EXPECTED TO CONTAIN THE COUNT
;OF BLOCKS THAT HAVE BEEN FOUND TO BE FREE
;CLOBBERS A AND B ADDS THE NUMBER OF BLOCKS IT FINDS TO 2(P)
CNTFRE:	JSR PC,CNTBLK	;AND IF SO, HOW MUCH?
	BLT CNTFR1	;NONE FREE THERE!
	ADD A,2(P)	;SOME THERE, ADD TO PREVIOUS AMOUNT
	INC 2(P)	;SIGH
FINDEL:	JSR PC,FINBLK	;FIND THE BLOCK THAT IS FREE
DELBLK:	MOV (A),(B)	;SPLICE THE NODE OUT OF THE LIST
	MOV ITMAFR,(A)	;AND PUT THE FREED NODE ON THE FREE LIST
	MOV A,ITMAFR	;NEW START OF FREE LIST
CNTFR1:	RTS PC
;FIND A BLOCK OF A PARTICULAR SIZE THAT BEGINS AT A CERTAIN LOCATION
;SIZE IN A
;LOCATION IN E
;POINTER TO NODE IS RETURNED IN A
;POINTER TO PREVIOUS NODE IS RETURNED IN B
;(IT IS A BUG FOR THERE TO BE NO SUCH BLOCK!!!)
FINBLK:	ASL A		;CONVERT THIS INTO A POINTER
	ADD #ITMATB,A	;INTO THE ALLOCATE VECTOR
FINBL1:	MOV A,B		;THE OLD ONE
	MOV (A),A	;THE ONE IT POINTS TO
	BNE .+4		;MUST BE THERE!!
	BPT
	CMP 2(A),E	;IS THIS THE ONE?
	BNE FINBL1		;NOPE
	RTS PC		;YES, WE'RE ALL SET
;FIND HOW MANY BLOCKS ARE FREE STARTING AT A GIVEN BLOCK AND
;LOOKING IN A GIVEN DIRETION
;E CONTAINS THE ABSOULUTE BLOCK NUMBER
;D CONTIANS THE INDEX OF THE BLOCK IT IS IN
;C CONTAINS THE DIRECTION (1=> FORWARD, -1=> BACKWARDS)
;A GETS -1 OR THE LENGTH OF WHAT'S FOUND
;CONDITON CODES ARE SET BY TST A, I.E. N IS CLEAR IF ANYTHING FOUND
;E GETS THE ADDRESS OF THE FIRST BLOCK IN THE CHUNK
CNTBLK:	SAVE <F,B,E>
	MOV #-1,A	;THE INTIAL COUNT
	BIC #170000,E	;GET RID OF BLOCK #
	SUB ITMBST(D),E	;MAKE IT RELATIVE TO START OF BLOCK
	BLT CNTBL2	;NO BLOCKS BEFORE BLOCK!
	ASHC #-4,E	;GET THE BIT NUMBER
	ASH #-12.,F	;AND THE WORD NUMBER
	BIC #177760,F	;MAKE SURE THE BIT NUMBER IS RIGHT
	ASL E		;MAKE A WORD ADDRESS
	MOV #1,B	;THE FIRST BIT
	ASH F,B		;SHIFT BY THE BIT NUMBER
	ADD ITMBTP(D),E	;THE REAL BIT TABLE ADDRESS
CNTBL1:	BIT B,(E)	;IS THIS ONE FREE?
	BNE CNTBL2	;THEN WE'RE DONE
	INC A		;ANOTHER ONE FREE
	ASH C,B		;SHIFT ONE WAY OR THE OTHER
	BNE CNTBL1	;NOT DONE WITH WORD YET
	ADD C,E		;ADJUST ADDRESS
	ADD C,E		;IT IS A WORD ADDRESS
	MOV #1,B	;RESET THE BIT
	TST C		;UNLESS WE ARE LOOKING BACKWARDS
	BGT CNTBL1	;NOPE, FORWARDS
	MOV #100000,B	;OOPS, BACKWARDS
	BR CNTBL1
CNTBL2:	REST E
	TST C		;THIS IS OK FOR FORWARDS SEARCH
	BGT CNTBL3
	SUB A,E		;BUT MUST BE CORRECTED FOR BACKWARD
CNTBL3:	REST <B,F>
	TST A		;TO SET THE CONDITION CODES
	RTS PC

;ROUTINES TO LOAD ITEMS INTO THE MAP AND TO PUSH AND POP THE ITEM STACKS

.IRPC X,<012>	;CONSTRUCT ROUTINES FOR EACH OF THE ITEM PAGES
;PUSH THE CURRENT ITEM FOR THIS PAGE ON THE STACK
;AND LOAD THE ITEM WHOSE INDEX IS IN A
ITM'X'PL:	SUB #2,ITM'X'P		;DECREMENT THE STACK POINTER
	MOV ITEM'X,@ITM'X'P		;STORE CURRENT ITEM ON STACK
	INC ITM'X'D			;INDICATE PUSHED ONE MORE LEVEL
;FALL INTO THE LOAD ITEM ROUTINE

;LOAD ITEM WHOSE INDEX IS IN A INTO AN ITEM PAGE
;RETURN THE ADDRESS THAT THE ITEM WAS LOADED INTO IN A
ITM'X'LD:	MOV A,ITEM'X		;THIS ISNOW THE CURRENT ITEM
	BLT ITM'X'L1			;NOT REALLY AN ITEM
	MOV ITMTAB(A),ITM'X'AR		;SET THE AR
	MOV ITMTAB+ITACCS(A),ITM'X'DR	;AND THE DR
ITM'X'L2:	MOV #ITM'X'AD,A		;AND THE ADDRESS
	RTS PC
ITM'X'L1:	CLR ITM'X'DR		;MAKE THE ITEM NXM
	BR ITM'X'L2			;GO FINISH

;POP THE TOP ITEM OFF THE STACK
ITM'X'PO:	SAVE A	;DON'T CLOBBER A
	DEC ITM'X'D	;INDICATE POPED ONE LEVEL
	BGE .+4		;DID WE OVER POP?
	BPT		;FOO!
	MOV @ITM'X'P,A	;GET THE OLD THING
	ADD #2,ITM'X'P	;FLUSH ITFROM THE PDL
	JSR PC,ITM'X'LD	;LOAD THE OLD ITEM
	REST A
	RTS PC
.ENDM
	.SBTTL PROCESS HACKING ROUTINES
;CREATE PROCESS AND PUT IT ON THE STOPPED QUQUE
;RETURN ITEM NUMBER IN A AND CLEAR Z IF SUCESSFUL
;OTHERWISE SEET Z
;RETURN ADDRESS OF PROCESS TABLE ENTRY IN B
CRPROC:	MOV #PRSLNF,A	;SIZE OF A PROCESS WITHOUT THE FLOATING POINT
	JSR PC,CRITEM	;GET AN ITEM FOR IT
	BEQ CRPRO1	;NO ITEM, TOUGH LUCK
	JSR PC,CLITEM	;CLEAR IT AND PUT IT IN ITEM0
	MOV #ITPROC,(A)	;SET THE TYPE
	BIS #PSUPSB,PSTOP(A)	;STOPPED!
	INC PSTOPC(A)		;ONE FOR THE BIT
	MOV #-1,PSPHRP(A)	;NO SPHERE AS OF NOW
	MOV #-1,PITEM2(A)	;NO ITEMS EITHER
	MOV #174000,PUPS(A)	;THE USER MODE PS
;NOTE THAT CRUSER ENTERS HERE
;AND INTIALIZES THE VARIABLES THAT IT HAS IN COMMON WITH PROCESSES
CRUSR1:	INC PRSREF(A)	;PRESUMABLY, THE GUY ASKING FOR IT WILL REFERENCE IT
	MOV PFREEQ,PPRTPT(A)	;THE PROCESS BLOCK WE WILL SOON GOBBLE
	JSR PC,ITM0PO	;NOW WE POP THE ITEM STACK
	MOV PFREEQ,A	;GET A PROCESS TABLE ENTRY
	BNE CRPRO2	;GOT ONE!
	MOV B,A		;AFTER ALL THAT WORK
	JSR PC,DLITEM	;WE HAVE TO GIVE UP
CRPRO1:	SEZ		;FAILURE
	RTS PC
CRPRO2:	MOV B,PRTPPT(A)	;SAVE THE ITEM # OF THE PROCESS IN THE PROCESS TABLE
	MOV #IPRIOR,PRTPRI(A)	;EVERYONE STARTS OUT WITH THIS
	SAVE B		;SAVE THE ITEM NUM
	MOV CURUSR,B	;THE CURRENT USER BLOCK
	CMP #-1,CURUSR	;ONLY THE VERY FIRST TIME (I HOPE)
	BEQ CRPRO3
	MOV PRTJMT(B),PRTJMT(A)	;START HIM AT A DISADVANTAGE
CRPRO3:	MOV B,PRTUPT(A)		;THE USER CREATING THIS IS THE PROCESS'S USER
	MOV #STOPQ,B	;MOVE FROM THE FREE Q TO THE STOPPED Q
	JSR PC,TQUQUE
	MOV A,B
POPACZ:	REST A		;ITEM NUM
	CLZ		;SUCESS
	RTS PC


;KEEP THIS NEAR CRPROC
;CREATE A USER
;RETURN ITEM NUMBER IN A, ADDRESS OF PROCESS TABLE ENTRY IN B
;CLEAR Z IF SUCESSFUL, OTHERWISE SET IT
CRUSER:	MOV #USRLEN,A	;THE LENGTH OF A USER
	JSR PC,CRITEM	;DO IT!
	BEQ CRPRO1	;FAIL
	JSR PC,CLITEM	;CLEAR THE ITEM
	MOV #ITUSER,(A)	;SET THE TYPE
	JSR PC,CRUSR1	;USE A LOT OF CODE FROM CRPROC
;NOTE THAT THIS WILL LEAVE THE USER ON THE STOP QUQUE
;WHICH WILL CAUSE A PROBLEM IF THE SCHEDULER RUNS
;WHICH IT SHOULDN'T
	BEQ CRPRO1	;FAILURE
	SAVE A		;SAVE THE ITEM INDEX
	MOV B,A		;THE PROCESS TABLE ADDRESS
	MOV #USERQ,B	;THE PLACE WHERE A USER BELONGS
	JSR PC,TQUQUE	;TRANSFER TO USER QUQUE
	MOV A,B
	BR POPACZ	;SUCCESS

;DECREMENT REFERENCE COUNT OF PROCESS IN A
;WIPE IT OUT IFCOUNT REACHES ZERO
DLPROC:	SAVE B
	JSR PC,ITM0PL
	DEC PRSREF(A)	;ONE LESS REFERENCE
	BNE DLPRO1	;SOMEONE ELSE STILL REFERENCES IT
	JSR PC,REMPRS	;REMOVE IT FROMTHE SPHERE
	MOV ITM0A,A
	MOV PPRTPT(A),A	;THE PROCESS TABLE ENTRY FOR IT
	MOV #PFREEQ,B	;MAKE THE PROCESS TABLE ENTRY FREE
	JSR PC,TQUQUE
	MOV ITEM0,A
	JSR PC,DLITEM	;FLUSH THE ACTUAL PROCESS
DLPRO1:	JSR PC,ITM0PO
	REST B
	RTS PC
;TRANFER PROCESS TABLE ENTRY IN A
;FROM IT'S PRESENT QUQUE TO THE ONE IN B
TQUQUE:	SAVE C
;MUST SPL 7 HERE IF THE INT LEVEL LOOKS AT QUQUES BACKWARDS
	MOV (A),C	;THE FORWARD POINTER OF THE ENTRY TO BE MOVED
	MOV C,@PRTBCK(A)	;CORRECT THE FORWARD POINTER OF THE PREVIOUS ENTRY
	MOV PRTBCK(A),PRTBCK(C)	;CORRECT THE BACK POINTER OF THE NEXT ENTRY
;MAY SPL 0 HERE, THE ENTRY IS IN LIMBO FOR THE TIME BEING
	MOV (B),C	;GET THE CONTENTS OF THE QUQUE POINTER
	MOV C,(A)	;POINT THE THING BEING MOVED AT THE BEGGINING OF THE QUQUE
	MOV B,PRTBCK(A)	;CORRECT BACK POINTER OF THING WE ARE MOVING
;SPL 7 HERE IF YOU DID ABOVE
	MOV A,PRTBCK(C)	;FIX BACK POINTER OF OLD FIRST ENTRY ON NEW QUQUE
	MOV A,(B)	;FIX QUQUE POINTER ITSELF
;SPL 0
	SAVE A
	MOV PRTPPT(A),A	;GET THE ITEM NUMBER OF THE THING
	JSR PC,ITM0PL
	CLR PQBIT(A)
	BIS QBIT(B),PQBIT(A)	;SET THE RIGHT Q-BIT
	JSR PC,ITM0PO
	REST A
	REST C
	RTS PC
;PUT THE PROCESS WHO'S ITEM IS IN A
;INTO THE SPHERE WHOS ITEM IS IN B
;SHOULD FAIL FOR RUNNING PROCESS OR TOO MANY PROCESSES IN SPHERE (NOT YET)
;CLEARS Z ON SUCESS
PUTPRS:	SAVE <A,B>
	JSR PC,ITM0PL	;PUT THE PROCESS INTO ITEM 0
	TST PSTOPC(A)	;IS IT STOPPED?
	BEQ PUTPR2	;NO, CAN'T MOVE IT THEN
	JSR PC,REMPRS	;GET IT OUT OF ANY SPHERE IT IS IN
	MOV (P),A	;GET THE SPHERE INDEX
	JSR PC,ITM1PL	;LOAD IT UP
	MOV ITM0A,B	;ADDRESS OF THE PROCESS
	MOV SPHPRP(A),PSPHCP(B)	;POINT PROCESS TO BEG OF OLD LIST
	MOV (P),PSPHRP(B)	;TELL PROCESS WHO IT BELONGS TO
	MOV 2(P),SPHPRP(A)	;LINK IT INTO THE LIST
	REST <B,A>
	JSR PC,ITM0PO
	JSR PC,ITM1PO
	CLZ
	RTS PC
PUTPR2:	JSR PC,ITM0PO	;POP ITEM 0
	REST <B,A>
	SEZ	;SAY WE CAN'T DO IT
	RTS PC

;REMOVE PROCESS IN ITEM0 (ADDRESS IN A) FROM WHATEVER SPHERE IT IS IN
;CLOBBERS B AND A
REMPRS:	MOV PSPHRP(A),A	;POINTER TO SPHERE THIS BELONGS TO
	BLE REMPR1	;WHEW, NO SPHERE, IT'S EASY
	JSR PC,ITM1PL	;GET THE SPHERE IT'S IN
	MOV ITM0A,B	;ADDRESS OF THE PROCESS ITEM
	CMP SPHPRP(A),ITEM0	;DOES IT POINT DIRECTLY TO THE PROCESS?
	BNE REMPR3	;NO, GO SEARCH FO RIT
	MOV PSPHCP(B),SPHPRP(A)	;SPLICE IT OUT OF THE LIST
REMPR5:	JSR PC,ITM1PO	;RESTORE ITEM 1
REMPR1:	RTS PC
REMPR3:	MOV SPHPRP(A),A	;GET THE FIRST PROCESS IN LINE
REMPR6:	BNE .+4		;IS THERE ANOTHER ONE?
	BPT		;NO, PROCESS LIED ABOUT BELONGING TO SPHERE
	JSR PC,ITM1LD	;PUT THIS PROCESS INTO ITEM1
	CMP PSPHCP(A),ITEM0	;DOES IT POINT TO PROCESS WE WANT TO SPLICE OUT?
	BNE REMPR4	;NOPE, KEEP TRYING
	MOV ITM0A,B
	MOV PSPHCP(B),PSPHCP(A)	;SPLICE IT OUT OF THE LIST
	BR REMPR5	;NOW WE CAN PUT IT WHERE WE WANT TO
REMPR4:	MOV PSPHCP(A),A	;GET NEXT ONE
	BR REMPR6	;GO CHECK IT OUT
;DECREMENT STOP COUNT OF PROCESS
;IF IT REACHES ZERO, PUT PROCESS ONTO RUN Q
;ASSUMES PROCESS IS LOADED INTO ITEM 0
PSTPDC:	SAVE A
	MOV ITM0A,A	;WHERE IS IT?
	DEC PSTOPC(A)	;ONE LESS REASON TO BE STOPPED
	BGE .+4		;SHOULD NOT GET NEGATIVE!
	BPT		;(WHAT CAN I SAY!)
	BGT PSTPD1	;DON'T START IT YET
	SAVE B
	MOV PPRTPT(A),A	;POINTER TO THE PROCESS TABLE
	MOV #RUNQ,B	;PUT IT ONTO THE RUN Q
	JSR PC,TQUQUE
	REST B
PSTPD1:	REST A
	RTS PC

;INCREMENT STOP COUNT OF PROCESS WHOSEITEM ISIN A
;IF THE COUNT WAS ZERO AND THE PROCESS WAS IN THE SYSTEM, PCLOSER IT
PSTPIN:	SAVE <A,B>
	JSR PC,ITM0PL	;GET IT INTO THE MAP
	TST PSTOPC(A)	;IS IT ALREADY NON-ZERO?
	BNE PSTPI1	;YES, JUST INCREMENT
	MOV PPRTPT(A),A	;IT'S PROCESS TABLE ENTRY
	MOV #STOPQ,B	;STOP THE PROCESS
	JSR PC,TQUQUE
	MOV ITM0A,A
	TST PSPC(A)	;IN THE SYSTEM?
	BEQ PSTPI1	;NOPE, PC ISUSER MODE PC
	HALT		;HERE, PCLOSER THE GUY
PSTPI1:	INC PSTOPC(A)	;TELL THE WORLDHE IS STOPPED
	JSR PC,ITM0PO
	REST <B,A>
	RTS PC

;THIS IS WHERE WE GET AFTER SOMEONE SETS PIRQ AND PIRBRK DISPATCHES
;(NOTE THAT WE DON'T GET TO PIRBRK UNTIL ALL INTERUPTS HIGHER
;THAN CLKL HAVE EXITED. CLKL SHOULD BE THE LOWEST INTERUPT IN
;THE SYSTEM, SO IT ALWAYS INTERRUPTS DIRECTLY FROM
;THE MAIN PROGRAM LEVEL)
;STOP A PROCESS IF IT IS IN USER MODE
;IF IT FINDS THE PROCESS
;WAS IN USER MODE, IT ASSUMES THAT THE SECOND REGISTER SET
;WAS BEING USED, AND CLOBBERS SET 0 ARBITRAILY
;IT SAVES THE PROCESSES REGISTERS, THEN RETURNS TO WHOMEVER STARTED
;THE PROCESS BY DOING AN RTS PC
STOPPR:	TST USRMOD	;ARE WE IN USER MODE?
	BNE PIRRET	;NOPE, THE SYSTEM WILL STOP HIM
	MOV PC,USRMOD	;NO LONGER IN USER MODE
	TST (P)+	;FLUSH THE SAVED A
	JSR F,SPCPSP	;SAVE THE PC, THE PS AND P
	JSR PC,PACSAV	;SAVE THE REST OF THE REGISTERS, INCLUDING THE FPP
	JSR PC,SAVAWB	;SAVE THE A AND W BITS
	JSR PC,TIMEUS	;GO CHARGE HIM FOR TIME USED
	MOV #-1,PRUNNG	;NO PROCESS RUNNING NOW
	RTS PC		;(GULP!!) RETURN TO CALLER
PIRRET:	REST A
	RTT
;CHARGE USER FOR THE TIME HE HAS USED
;EXPECTS POINTER TO ITEM0 IN A. CLOBBERS B AND C
TIMEUS:	MOV TUSED,B	;NUMBER OF TICKS HE USED
	ASL B		;CONVERT TO HALF TICKS
	BNE .+4		;DID HE USE ANY TIME?
	INC B		;EVERYONE USES AT LEAST ONE HALF-TICK
	ADD B,PTUSED(A)	;UPDATE HIS TIME USED
	ADC PTUSED+2(A)
	MUL #JMTUAC,B	;MULTIPLY BY THE ADDTIVE FACTOR
	MOV PPRTPT(A),C	;POINTER TO PROCESS BLOCK
	ADD B,PRTJMT(C)	;UPDATE THE PROCESS JMTU
	MOV PRTUPT(C),C	;POINTER TO THE USER BLOCK
	ADD B,PRTJMT(C)	;UPDATE THAT JMTU TOO
	RTS PC
;ENTER THE RUNNING QUQUE
RUNME:	SAVE #RUNQ
	BR FLUSH
;ENTER THE SHORT FLUSHED QUQUE
SFLUSH:	SAVE #SFLSQ
	BR FLUSH
;ENTER THE LONG FLUSH QUQUE
LFLUSH:	SAVE #LFLSQ
	BR FLUSH
;ENTER THE PAGE WAIT QUQUE
PAGEW:	SAVE #PAGWQ
	BR FLUSH
;ENTER THE SWAP BLOCKED QUQUE
SWAPB:	SAVE #SWPBQ
FLUSH:	SAVE A		;GET A FREE REGISTER
	MOV ITM0A,A	;THE RUNNING PROCESS IS ALWAYS ITEM 0
	ADD #PSREGS,A	;A POINTER TO THE SYSTEM REGISTERS FOR THE GUY
	REST (A)+	;GET BACK A
.IRPC X,<BCDEF>
	MOV X,(A)+
.ENDM
	MOV ITM0A,E
	MOV PPRTPT(E),A	;POINTER TO PROCESS TABLE
	MOV (P),B	;QUQUE TO MOV IT TO
	JSR PC,TQUQUE	;DO THE ACTUAL MOVE
	MOV ITM0A,A
	REST <B,E>		;GET THE QUQUE AGAIN
	TST PSPC(A)	;WERE WE ALREADY FLUSHED?
	BNE FLUSH2	;YES
	JSR PC,PACSAV	;IN CASE USER'S REGISTERS NOT SAVED YET
	JSR PC,TIMEUS	;CHARGE HIM FOR TIME USED
	JSR PC,SAVAWB	;SAVE REFERENCED PAGES
	JSR PC,PDLSAV	;SAVE THE SYSTEM PDL
FLUSH2:	MOV ITM0A,A
	MOV E,PSPC(A)
	RTS PC
;START THE PROCESS WHOSE PROCESS TABLE ENTRY IS
;POINTED TO BY A
;WHEN PROCESS FINALLY STOPS, THE ROUTINE WILL RETURN
;CLOBBERS ALL REGISTERS
STPROC:	BIS #30000,PS	;MAKE SURE PREVIOUS MODE IS USER
	SPL CLKL	;STOP US FROM GETTING STOPPED
	BIC #CLKPIR,PIRQ	;MAKE SURE NO STOP PENDING
	MOV PRTUPT(A),CURUSR	;THE GUY TO "CHARGE" FOR THIS RUN
	CLR TUSED		;START COUNTING NOW
	MOV PRTPPT(A),A		;GET THE PROCESS ITEM #
	MOV A,PRUNNG		;THIS IS THE RUNING PROCESS
	JSR PC,ITM0LD	;IT IS EXPECTED TO BE IN ITEM0
	MOV A,B		;SAVE THE POINTER TO IT
	MOV PSPHRP(A),A	;GET A POINTER TO THE SPHERE
	JSR PC,ITM1LD	;IT IS EPECTED IN ITEM1
	JSR PC,PACRES	;RESTORE REGISTER SET 1
	JSR PC,MAPRES	;RESTORE THE MAP
	SAVE PUP(B)	;GET THE USER'S PDL POINTER
	MTPI P		;RESTORE IT TO HIM
	TST PSPC(B)	;IS HE RUNNING IN THE SYSTEM?
	BNE STPRO1	;YES, GO RESTORE OTHER THINGS
	TST PFAULT(B)	;DOES HE HAVE A FAULT PENDING?
	BEQ .+6		;NO, PUT HIM INTO USERMODE
	JMP CFAULT	;YES, GO MAKE IT HAPPEN
	MOV P,PSP(B)	;WHERE THE PDL ENDS
	SAVE <PUPS(B),PUPC(B)>	;HIS PROCESSOR STATUS AND HIS PROGRAM COUNTER
	CLR USRMOD	;THE WORLD IS NOW IN USER MODE
	RTI		;RETURN TO HIM IN USER MODE
STPRO1:	JSR F,PDLRES	;RESTORE HIS SYSTEM PDL
	SAVE <#30000,PSPC(B)>	;GET PS AND GET PC
	CLR PSPC(B)	;INDICATE NOT HUNG
	MOV (P),USRMOD	;INDICATE THAT WE ARE NOT IN USER MODE
	MOV B,A		;POINTER TO THE PROCESS
	ADD #PSREGS+14,A	;THE SYSTEM REGISTERS
.IRPC X,FEDCBA
	MOV -(A),X
.ENDM
	RTI		;EXIT TO RIGHT PLACE IN THE SYSTEM
;SAVE THE USER'S PC, PS AND PDL POINTER
;CALL WITH JSR F,SPCPSP
;A GETS CLOBBERED TO ITEM 0 ADDRESS
;F GETS CLOBBERED TO VALUE OF THE USER'S P
;ITEM0 IS EXPECTED TO BE THE PROCESS
SPCPSP:	TST (P)+
	MOV ITM0A,A	;THE ADDRESS OF THE PROCESS IN THE MAP
	REST <PUPC(A),PUPS(A)>	;SAVE HIS PC AND HIS PS
	MFPD P		;GET HIS P
	MOV (P),PUP(A)	;SAVE HIS PDL POINTER (PUP-P?)
	RTS F		;RETURN WITH P IN F
;SAVE THE PROCESSES REGISTERS, INCLUDING THE FPP IF THAT IS ENABLED
;THE GENERAL REGISTERS ARE IN SET 1
;THE ADDRESS OF THE PROCESS ITEM IS EXPECTED IN A
;THE PROCESS ITEM IS EXPECTED TO BE IN THE MAP
PACSAV:	SAVE A		;TO COMMUNICATE WITH THE OTHER REGISTER SET
	BIT #PACSVF,PFLAGS(A)	;HAVE THE AC'S ALREADY BEEN SAVED?
	BEQ PACSV1	;ZERO=>SAVED
	BIC #PACSVF,PFLAGS(A)
	BIS #4000,PS	;CHANGE TO OTHER SET
	SAVE A		;SAVE A OF SET 1
	MOV 2(P),A	;GET A FROM SET 0
	ADD #PUREGS,A	;POINT TO PALCE TO SAVE REGISTERS
	REST (A)+	;SAVE A OF SET 1
	MOV B,(A)+	;SAVE REST OF SET 1
	MOV C,(A)+
	MOV D,(A)+
	MOV E,(A)+
	MOV F,(A)+
	BIC #4000,PS	;BACK TO SET 0
;NOTE THAT SET 0'S A HAS NOT BEEN CLOBBERED
	BIT #PFPFLG,PFLAGS(A)	;HAS HE ENABLED THE FPP?
	BEQ PACSV1	;NOPE
	STFPS PFPPS(A)		;STORE THE STATUS
	ADD #PFPPRG,A	;POINT TO FPP REGISTERS
	SETD		;SO WE SAVE ALL THE BITS
.IFZ 1	;UNTIL PALX AND I UNDERSTAND EACH OTHER
	STD A,(A)+
	STD B,(A)+
	STD C,(A)+
	STD D,(A)+	;SAVE ALL WE CAN GET TO DIRECTLY
	LDD A,E		;LAST 2 HAVE TO BE MOVED SPECIAL
	STD A,(A)+
	LDD A,F
	STD A,(A)+
.ENDC
PACSV1:	REST A
	RTS PC
;RESTORE THE USER'S REGISTERS
;B IS EXPECTED TO CONTAIN A POINTER TO THE PROCESS ITEM
;NO REGISTERS ARE CLOBBERED (EXCEPT, OF COURSE, THE USER'S)
PACRES:	SAVE B
	BIT #PACSVF,PFLAGS(B)	;WERE THEY EVER SAVED?
	BNE PACRS1	;ONE=>NOT SAVED
	BIS #PACSVF,PFLAGS(B)
	BIS #4000,PS	;GO TO REGISTER SET 1
	MOV (P),A	;GET THE POINTER TO THE ITEM
	ADD #PUREGS+14,A	;CONVERT TO A REGISTER POINTER
.IRPC X,<FEDCBA>
	MOV -(A),X
.ENDM
	BIC #4000,PS	;BACK TO SET 0
;RESTORE FPP!!!!
PACRS1:	TST (P)+
	RTS PC
;RESTORE THE USER'S SYSTEM PDL
;CALLED WITH JSR F,PDLRES  
;CLOBBERS A AND C AND F
;AS WELL AS PUSHING THINGS ONTO P
;EXPECTS A POINTER TO THE PROCESS ITEM IN B
PDLRES:	TST (P)+
	MOV PSP(B),A	;THE VALUE THAT THE STACK POINTER SHOULD HAVE
	MOV P,PSP(B)	;FOR PDLSAV, THE VALUE IT SHOULD HAVE AFTER SAVING
	MOV B,C		;COPY POINTER TO ITEM
	ADD #PPDL,C	;MAKE IT A POINTER TO THE PDL
PDLRE2:	CMP P,A		;HAVE WE PUSHED ENOUGH?
	BEQ PDLSA1	;YUP
	MOV (C)+,-(P)	;POP-PUSH
	BR PDLRE2
;SAVE THE SYSTEM PDL INTO THE PROCESS'S
;SYSTEM PDL AREA. SAVES UP TO WHAT IS INDICATED BY PSP
;CALLED WITH JSR PC,PDLSAV
;CLOBBERS A,B,C, AND F
;ALSO POPS STUFF OFF THE STACK
PDLSAV:	REST F		;GET THE RETURN ADDRESS
	MOV ITM0A,A	;GET A POINTER TO THE PROCESS
	MOV PSP(A),B	;WHAT THE PDL POINTER SHOULD BE
	MOV B,C
	SUB P,B		;WHAT'S THE DIFFERENCE?
	BEQ PDLSA1	;NONE, FORGET IT
	BGT .+4	;MAKE SURE IT'S POSITIVE
	BPT		;GASP!
	CMP #PRPDLL,B	;IS IT PUSHED TO DEEP?
	BGT .+4
	BPT		;NAUTGHY!
	ADD A,B		;MAKE A POINTER TO THE END OF
	ADD #PPDL,B	;THE PROCESS'S PDL
PDLSA2:	MOV (P)+,-(B)	;POP-PUSH
	CMP C,P		;ARE WE DONE YET?
	BNE PDLSA2	;NOPE
PDLSA1:	JMP (F)
	.SBTTL SPHERE HACKING ROUTINES

;CREATE A SPHERE
;RETURN THE INDEX OF THE ITEM IN A
CRSPHR:	SAVE B
	MOV #SPHLEN,A	;THE LENGTH OF A SPHERE (INITIALLY)
	JSR PC,CRITEM	;MAKE ONE
	BNE .+4		;DID IT SUCEED?
	RTS PC		;NOPE
	JSR PC,CLITEM	;LOAD IT INTO ITEM0 AND CLEAR IT
	MOV #ITSPHR,(A)	;SET THE TYPE
	INC SPHREF(A)	;ASSUME THE GUY IS GOING TO REFERENCE IT
	MOV CURUSR,SUSRPT(A)	;THE GUY WHO CREATES IT GETS "CHARGED" FOR  IT
	MOV #SICLST+<NCLSEB*CLSELN*2>,SCLSEP(A)	;THE LAST LOCATION USED
	SAVE <B,C>
	MOV A,B
	ADD #SCLSTT,B	;GET AN ADDRESS POINTER TO THE INDEX TABLE
	MOV #<MNCLSE/NCLSEB>/2,C	;NUMBER OF WORDS OF POINTERS
	MOV #-1,(B)+
	SOB C,.-4	;INTIALIZE THEM TO POINT AT NOTHING
	MOVB #1,-(C)	;EXPECT THE LAST ONE POINTS AT THE 2ND BLOCK
	CLRB SCLSTT(A)	;AND THE FIRST TO THE FIRST
	REST C
	REST A	;THE ITEM #
	REST B	;THE ORIGINAL CONTENTS OF B
	CLZ		;SUCECESS
	RTS PC

;SAVE THE A AND W BITS FOR THE CURRENT SPHERE
;THE SPHERE IS EXPECTED TO BE IN ITEM1, AND THE USER
;SEGMENTATION REGISTERS ARE EXPECTED TO REFLECT THIS SPHERE
SAVAWB:	SAVE <A,B,C,D>
	MOV ITM1A,A	;ADDRESS OF ITEM1 IN THE MAP
	ADD #SUPTS+UPTDR,A	;POINT TO THE UPTS DR
	MOV #USRISD,B	;THE ACTUAL SEGMENTATION REGISTERS
	MOV #20,C	;NUMBER OF SEGMENTS
SAVAW1:	MOV (B)+,D	;THE SEGMENTER'S DR
	BIC #177477,D	;JUST THE A+W BITS
	BIS D,(A)	;INTO THE APPROPRIATE UPT
	TST (A)		;IS IT A D=I PAGE?
	BGE SAVAW2	;NOPE
	BIS D,-10*UPTLEN(A)	;SET THE COORESPONDING I PAGE
SAVAW2:	ADD #UPTLEN,A	;TO THE NEXT UPT ENTRY
	SOB C,SAVAW1
	REST <D,C,B,A>
	RTS PC
	.SBTTL SPHERE HACKING ROUTINES- C-LIST HANDLERS
;GET ADDRESS OF A C-LIST ENTRY
;A CONTAINS ADDRESS OF SPHERE IN MAP
;B CONTAINS C-LIST NUMBER
;B RETURNS OFFSET INTO SPHERE IF SUCESSFUL (Z CLEAR)
;OTHERWISE Z SET AND B CONTAINS SPHERE BYTE ADDRESS OF INDEX BYTE
GCLSTA:	SAVE <D,C,A>
	CLR C		;FOR THE DIVIDE
	MOV B,D		;SAVE C-LIST NUMBER
	DIV #NCLSEB,C	;GET THE BLOCK AND OFFSET
	ADD C,A		;CONVERT TO
	ADD #SCLSTT,A	;ADDRESS OF INDEX BYTE
	MOVB (A),B	;GET THE BYTE
	BLT GCLST1	;NEGATIVE IMPLIES NO STUCK BLOCK
	MUL #NCLSEB*CLSELN,B	;RELATIVE ADDRESS OF BLOCK
	MUL #CLSELN,D	;REMANDER
	ADD D,B		;NOW WITHIN BLOCK
	ADD #SICLST,B	;LESS RELATIVE
	REST <A,C,D>
	CLZ		;SUCESS
	RTS PC
GCLST1:	MOV A,B		;SAVE FOR THE CALLER
	REST <A,C,D>
	SEZ		;FAILURE
	RTS PC
	.SBTTL CLOCK AND PIRQ ROUTINES
;ENTERED BY AN INTERUPT FROM EITHER THE LINE CLOCK OR THE PROGRAMABLE
;CLOCK. HOPEFULLY, ONLY ONE OF THESE WILL BE ENABLED!
LCBRK:
PCBRK:	SAVE A
	INC TIME	;INCREASE TIME-SINCE-SYSTEM UP
	BNE .+6		;OVERFLOW?
	INC TIME+2	;YUP
	INC TUSED	;ONE MORE TICK FOR THIS USER
	DEC STIMER	;MAINTAIN TIMERS
	DEC LTIMER
	DEC JMTUUP	;TIME TO UPDATE THE JMTUS?
	BNE .+6		;NOT YET
	JSR PC,JMTUU	;GO UPDATE THEM
	DEC QUANT	;HAS THE CURRENT USER OVERSTAYED HIS WELCOME?
	BGT CLKRET	;NO, RETURN TO MAIN PROGRAM
	BIS #CLKPIR,PIRQ	;CAUSE THE STOP USER ROUTINE TO RUN
CLKRET:	REST A		;ALL'S QUIET NOW?
	RTT

;THIS IS ENTERED BY THE PROGRAM INTERUPT REQUEST
;CURRENTLY IT IS ONLY USED FOR THE "CLOCK", BUT ITS DISPATCH
;TABLE COULD ACCOMADATE USES FOR OTHER LEVELS
PIRBRK:	SAVE A		;SAVE A REGISTER
	MOV PIRQ,A	;GET THE INTERUPT LEVEL
	BIC #177761,A	;USE AS AN INDEX TO DISPATCH
	BIC PIRBIT(A),PIRQ	;CLEAR THE RIGHT BIT
	MOVB PIRQ,PS	;SET PRIORITY OF PROCESSOR TO PRIORITY
			;LEVEL RESPONSABLE FOR THIS INTERUPT
	JMP @PIRDIS(A)
PIRLOS:	BPT	;UNIMPLEMENTED LEVELS COME HERE
	BR .-2

;UPDATE JMTUS ON ALL QUQUES. CLOBBERS A
JMTUU:	SAVE <B,C,E,F>
	MOV #JMTUUT,JMTUUP	;RESTORE TIME TILL NEXT UPDATE
	MOV #FIRSTQ,A	;BEGGINING OF THE QUQUE POINTERS
	MOV #NQS,B	;NUMBER OF QUQUES THAT EXIST
JMTUU1:	MOV (A),C	;POINTER TO BEGGINING OF QUQUE
	BEQ JMTUU2	;NOBODY THERE!
JMTUU4:	MOV PRTJMT(C),F	;GET THE JMTU
	BEQ JMTUU3	;IT'S ALREADY ZERO, FORGET IT
	CLR E		;FOR THE DIVIDE
	DIV #JMTUDC,E	;FIND OUT HOW MUCH TO DECAY BY
	INC E		;MAKE SURE IT EVENTUALLY GETS TO ZERO
	SUB E,PRTJMT(C)	;DECAY IT
JMTUU3:	MOV (C),C	;GO DOWN THE LINK
	BNE JMTUU4	;MORE ON THIS QUQUE
JMTUU2:	ADD #QLEN,A	;GO TO NEXT QUQUE
	SOB B,JMTUU1	;GO THROUGH ALL QUQUES
	REST <F,E,C,B>
	RTS PC
	.SBTTL SCHEDULING ROUTINES
;THE SYSTEM'S MAIN LOOP
;ENTERED AT SCHED, NEVER EXITED
SCHED:	JSR PC,RUNBPS	;FOR NOW, JUST RUN THE BEST USER
	TST RUNQ	;IS ANYONE RUNNABLE?
	BEQ SCHED1	;NO, GO TRY EVERYONE
	TST STIMER	;IS IT TIME TO CHECK SHORT-FLUSHED GUYS?
	BGT SCHED2	;NOT YET
	MOV #STIMEL,STIMER	;RESET THE TIMER
	MOV #SFLSQ,A
	JSR PC,CHKQ	;GO CHECK THEM ALL
	MOV #PAGWQ,A	;CHECK GUYS WAITING FOR PAGES TOO
	JSR PC,CHKQ
SCHED2:	TST LTIMER	;TIME TO CHECK THE LONG FLUSHED GUYS?
	BGT SCHED3	;NOPE, NOT YET
	MOV #LTIMEL,LTIMER
	MOV #LFLSQ,A
	JSR PC,CHKQ
SCHED3:	BR SCHED	;NOW GO RUN THE BEST ONE
SCHED1:	MOV #SFLSQ,A	;CHECK THE SHORT ONES
	JSR PC,CHKQ
	MOV #PAGWQ,A	;AND THE LONG ONES
	JSR PC,CHKQ
	TST RUNQ	;DID WE CATCH ANY?
	BNE SCHED	;YUP, TRY ONE
	MOV #LFLSQ,A	;OH WELL, TRY THE LONG ONES
	JSR PC,CHKQ
	BR SCHED
;CHECK RUNNABILITY OF A PROCESS
;PROCESS TABLE ENTRY IN A
;MIGHT CLOBBER ALL REGISTERS
CHKPRS:	MOV PRTPPT(A),A	;GET THE ITEM
	JSR PC,ITM0LD
	SAVE PSPC(A)	;GET THE PLACE TO CONTINUE IT AT
	BNE .+4		;MAKE SURE IT IS NON-ZERO
	BPT		;UGH! BLETCH! BARF!
	MOV PSPHRP(A),A	;GET THE SPHERE
	JSR PC,ITM1LD
	MOV ITM0A,A
	ADD #PSREGS+14,A	;POINTER TO REGISTERS
.IRPC X,<FEDCBA>
	MOV -(A),X
.ENDM
	RTS PC

;CHECK RUNNABLITY OF PROCESSES ON QUQUE IN A
;MAY CLOBBER ALL REGISTERS
CHKQ:	SAVE (A)
CHKQ1:	MOV (P),A	;GET THE NEXT IN LINE TO CHECK
	BEQ CHKQ2	;NO MORE
	MOV (A),(P)	;LINK THROUGH FOR NEXT TIME
	JSR PC,CHKPRS	;CHECK IT
	BR CHKQ1
CHKQ2:	REST A
	RTS PC

;RUN THE BEST PROCESS ON THE RUN QUQUE
;CLOBBERS ALL REGISTERS
RUNBPS:	MOV RUNQ,A	;START OF GUYS TO RUN
	BNE RUNBP1	;SOME THERE FIND HIM
	WAIT		;TWIDDLE YOUR THUMBS
	RTS PC		;I GIVE UP!
RUNBP1:	SAVE <#-1,#77777,#-1,#-1,#77777,#-1>
RUNBP2:	MOV PRTUPT(A),B	;WHO IS THIS GUY'S USER?
	CMP 6(P),B	;SAME GUY WHO IS ALREADY BEST?
	BEQ RUNBP3	;YES, GO SEE IF THIS PROCESS IS BETTER
	MOV PRTPRI(B),E	;GET THE PRIORITY MULITPLE FOR THIS GUY
	BIC #177760,E	;MASK IT TO 4 BITS
	MUL PRTJMT(B),E	;GET THE NET PRIOTIRTY
	CMP E,10(P)	;HIGH PART > THAN OLD HIGH PART?
	BLO RUNBP4	;NO, THIS USER IS BETTER!
	BHI RUNBP6	;YES, THIS USER NOT AS GOOD
	CMP F,12(P)	;HIGH ORDER EQUAL, TRY LOW
	BHIS RUNBP6	;SAME OR WORSE
RUNBP4:	MOV B,6(P)	;THIS IS THE NEW BEST USER
	MOV E,10(P)	;AND HERE IS HIS PRIORITY
	MOV F,12(P)
	MOV PRTPRI(A),E	;NOW COMPUTE PRIORITY FOR THIS PROCESS
	BIC #177760,E
	MUL PRTJMT(A),E
RUNBP5:	MOV A,(P)	;THIS IS NOW THE BEST PROCESS
	MOV E,2(P)	;AND THIS IS IT'S PRIORITY
	MOV F,4(P)
RUNBP6:	MOV (A),A	;NEXT ONE ON THE QUQUE
	BNE RUNBP2	;GO SEE IF HE IS BETTER
	REST A		;THIS ONE IS BEST
	ADD #12,P	;FLUSH THE CRAP OFF THE STACK
	MOV PQUANT,QUANT	;HOW LONG TO RUN HIM FOR
	JMP STPROC	;GO TO IT (WILL RETURN TO CALLER OF RUNBPR)
RUNBP3:	MOV PRTPRI(A),E	;SAME USER, IS THIS PROCESS BETTER?
	BIC #177760,E
	MUL PRTJMT(A),E
	CMP E,2(P)	;IS THE HIGH PART BETTER?
	BLO RUNBP5	;YUP, HE'S NOW BEST
	BHI RUNBP6	;NOPE, OLD GUY IS BEST
	CMP F,4(P)	;SAME HIGH PARTS, WHAT ABOUT LOW?
	BHIS RUNBP6	;OLD GUY BEST
	BR RUNBP5	;NEW GUY BEST
	.SBTTL LOCK SWITCH ROUTINES
;GET A LOCKED SWITCH BLOCK AND STUFF THE TYPE AND ITEM INTO IT
;AND LINK IT INTO THE CURRENT PROCESS'S LOCKED LIST
;CALL WIHT TYP EIN A, ITME IN B
;PUTS ADDRESS OF BLOCK INTO A, CLOBBERS B
LOCKSW:	TST LCKFRE	;ARE THERE ANY FREE LOCKS?
	BNE LOCKS1	;YES, GO GOBBLE
LOCKS3:	JSR PC,SFLUSH	;WAIT A WHILE
	TST LCKFRE	;TRY AGAIN
	BNE LOCKS3	;NONE YET
	JSR PC,RUNME	;HOPEFULLY, WE CAN GET ONE NOW
	BR LOCKSW	;TRY AGAIN
LOCKS1:	SAVE A
	CLR A		;TO DO THE SILLY DIVIDE
	DIV #ITMTEL,A	;TO CONVERT INDEX TO NUMBER
	BIS A,(P)	;SET NUMBER INTO TYPE
	MOV LCKFRE,A	;GET THE FREE LOCK BLOCK
	MOV (A),LCKFRE	;SPLICE IT OUT
	REST LCKTIT(B)	;POP THE THING INTO THE TYPE AND ITEM
	MOV ITM0A,B	;ADDRESS OF THE PROCESS
	MOV PLCKSL(B),(A)	;PUT IT INTO LIST FOR THIS PROCESS
	MOV A,PLCKSL(B)
	MOV #-1,LCKWD1(A)	;LOCK NOT REALLY USED YET
	RTS PC

;LOCK A PARTICULAR SWITCH
;A HAS THE ADDRESS OF THE SWITCH, B HAS THE BIT(S) WHICH ARE TO BE LOCKED
LCKASW:	TST INITSW	;ARE WE IN INIT CODE?
	BNE LOCKA5	;YES, DON'T LOCK
	SAVE <C,B,A>
	MOV #LONOFF,A	;IT IS AN ON-OFF TYPE OF SWITCH
	CLR B		;NOT IN AN ITEM (CHANGE LATER?)
	JSR PC,LOCKSW	;GET A BLOCK FOR IT
	MOV A,C	;SAVE ADDRESS OF THE BLOCK
	REST <A,B>
LOCKA2:	BIT B,(A)	;ARE THE APPROPRIATE BITS ZERO?
	BEQ LOCKA1	;YES, WE CAN TAKE THE SWITCH
LOCKA3:	JSR PC,SFLUSH	;NO, WAIT A WHILE
	BIT B,(A)	;TRY AGAIN
	BNE LOCKA3	;NOT YET
	JSR PC,RUNME	;I THINK I'VE GOT IT!
	BR LOCKA2	;MAKE SURE
LOCKA1:	MOV A,LCKWD1(C)	;GOT IT, TELL THE BLOCK WHAT WE GOT
	MOV B,LCKWD2(C)
	BIS B,(A)	;TELL THE WORLD IT'S LOCKED
	REST C
LOCKA5:	RTS PC
;POP THE TOP LOCK OFF THE LOCKED SWITCH LIST
LSWPOP:	TST INITSW	;ARE WE IN INIT CODE?
	BNE LSWPO2	;NO SWITCHES EVER LOCKED
	SAVE <A,B>
	MOV ITM0A,A	;ASSUME ITEM0 IS THE PROCESS WHICH IS UNLOCKING
	MOV PLCKSL(A),B	;SPLICE LOCK OUT OF IT'S LIST
	MOV (B),PLCKSL(A)
	MOV LCKFRE,(B)	;PUT IT ONTO THE FREE LIST
	MOV B,LCKFRE
	CMP #-1,LCKWD1	;IS IT FOR REAL?
	BEQ LSWPOR	;NOPE, WE HAVE "UNLOCKED" IT
	MOV LCKTIT(B),B	;GET THE TYPE
	MOV #-1,A	;MAKE ITEM NXM (FOR THE SAKE OF THE PUSH)
	JSR PC,ITM2PL
	SAVE B		;SAVE TYPE AND ITEM
	CLR A		;IN CASE THERE IS NO ITEM
	BIC #176000,B	;GET THE ITEM
	BEQ LSWPO1	;NOPE, NO ITEM
	MUL #ITMTEL,B	;CONVERT TO INDEX
	MOV B,A
	JSR PC,ITM2LD	;SAVE IT AWAY
LSWPO1:	REST B		;GET BACK FOR TYPE
	ASH #-9.,B
	BIC #177601,B	;MAKE IT INTO A 6 BIT INDEX
	JMP @LCKDIS(B)	;DISPATCH ON TYPE

LSPONF:	ADD LCKWD1(B),A	;POINT INTO ITEM IF THERE IS ONE
	BIC LCKWD2(B),(A)	;UNLOCK ON-OFF TYPE LOCK
LSWPOR:	JSR PC,ITM2PO	;POP THE ITEM STACK
	REST <B,A>
LSWPO2:	RTS PC
LSPERR:	BPT		;GASP! BAD LOCK TYPE
	BR .-2
	.SBTTL MEMORY MANAGMENT ROUTINES
;MAP RESTORE ROUTINE
;CLOBBERS NO REGISTERS
;EXPECTS THE SPHERE TO RESTORE IN ITEM1
;DOES NOT RESTORE IF CURSPH IS SAME AS ITEM1
MAPRES:	CMP CURSPH,ITEM1	;IS IT ALREADY LOADED?
	BEQ MAPRE1		;YES
	MOV ITEM1,CURSPH
	SAVE <A,B,C>
	MOV ITM1A,A	;POINTER TO THE ITEM
	ADD #SUPTS,A	;GET POINTER TO UPTS FOR SPHERE
	MOV #USRISD,B	;POINT TO USER MAP
	MOV #20,C	;NUMBER OF SEGMENTS TO LOAD
MAPRE2:	TST (A)		;DOES THE PAGE EXIST?
	BEQ MAPRE3	;NO PAGE HERE
	BLT MAPRE4	;SAME AS COORESPONDING I PAGE
	TST UPTAR(A)	;IS IT AN ABSOLUTE PAGE?
	BLT MAPRE5	;YUP, GO LOAD IT
	HALT		;HERE, LOAD A NON-ABSOLUTE PAGE
			;(OR DON'T IF IT'S NOT SWAPPED IN OR IN MOTION)


MAPRE5:	MOV (A),(B)	;ABSOLUTE PAGE IS SIMPLE
	MOV UPTAR(A),USRISA-USRISD(B)	;COPY AR
MAPRE3:	TST (B)+	;INCREMENT POINTER TO SEG REGISTERS
	ADD #UPTLEN,A	;AND POINTER TO UPTS
	SOB C,MAPRE2	;GO BACK IF NOT FINISHED
	REST <C,B,A>
MAPRE1:	RTS PC

MAPRE4:	CMP #10,C	;IS IT REAL A DATA PAGE?
	BGE .+4
	BPT		;<STICK OUT TONGUE WHEN YOU READ THIS LINE>
	MOV USRISD-USRDSD(B),(B)	;DR FROM I-SPACE PAGE
	MOV USRISA-USRDSD(B),USRISA-USRISD(B)	;SAME FOR AR
	BR MAPRE3
;INTIAL MAP-SETTING ROUTINE
;CLOBBERS MOST AC'S, INTENDED TO BE RUN ONLY AT ITIALIZE TIME
;OR AFTER A POWER FAIL RESTART
MAPSET:	MOV #I0AR,A	;FIRST WE'LL SET UP A STRAIGHT MAP
	CLR B		;I AND D SPACE THE SAME AND MAPPED DIRECTLY
	MOV #8.,C	;FROM VIRTUAL CORE TO PHYSICAL
MAPST1:	MOV #77406,VAR0DR-I0AR(A)	;DATA SPACE 4K SEGEMNET
	MOV #77406,I0DR-I0AR(A)		;INSTRUCTION SPACE 4K SEGMENT
	MOV B,VAR0AR-I0AR(A)		;VIRTUAL MAPPED DIRECTLY TO PHYSICAL
	MOV B,(A)+			;FOR BOTH INST AND DATA SPACE
	ADD #200,B	;4K WORTH
	SOB C,MAPST1	;DO FORR 8 SEGMENTS
	;NOW WE'LL HACK THE SPEECAIL THINGS
	MOV #7600,IOAR	;MAP USUAL I/O SPACE TO REAL I/O SPACE
;THE FOLLOWING THING IS THE DR FOR THE RUG PAGES (UGH!)
FOO==<<200-<<RUGIDR-I0DR+2>*100>+<<RUGST_-6>&1777>>_8.>+16
	MOV #FOO,RUGIDR	;SPECIAL RUG SEGMENT
	MOV #FOO,RUGDDR	;MAP 156000-157776 VIRTUAL TO SAME PHYSICAL
	MOV #VAR2DR,A	;NOW FLUSH UNUSED VARIABLE PAGE AND 3 ITEM PAGES
	CLR (A)+
	CLR (A)+
	CLR (A)+
	CLR (A)
	MOV #I7DR,A
	CLR (A)		;FLUSH HIGH INSTRUCTION PAGE
	TST -(A)	;DON'T CLOBBER RUG PAGE
	MOV #120000,B	;FIRST LOCATION IN A PAGE BEFORE RUG PAGE
MAPST2:	CMP #LSTILC,B	;LAST INSTRUCTION LOCATION
	BHI MAPST3	;IF THERE IS SOMETHING THERE, WE'RE DONE
	CLR -(A)	;NO ONE THERE, FLUSH IT
	SUB #20000,B	;NEXT PAGE DOWN
	BR MAPST2
MAPST3:	MOV #7,SSR3	;ENABLE I AND D FOR ALL MAPS
	MOV #1,SSR0	;THERE WE GO!!
	RTS PC
;THE MEMORY TABLE INITIALIZER
;CLOBBERS ALL REGISTERS
MEMTST:	CLR ITM0AR	;FIRST FIND HOW MUCH MEMORY
	MOV #6,ITM0DR	;LENGTH 1 PAGE
	SAVE BEBRV	;SAVE THE BUSS ERROR VECTOR
	MOV #MEMTS1,BEBRV	;TRAP BACK TO THE ROUTINE
	MOV #MNCBLK,A		;THE MOST WE WILL PAY ATTENTION TO
	MOV #CST,B
MEMTS2:	TST ITM0AD	;CAUSE BUSS ERROR IF NXM
	ADD #20,ITM0AR	;INCREMENT BY 512 WORDS
	MOV #CSTBEB!CSTSYB,(B)+	;SAY IT EXISTS AND SYSTEM USING IT
	SOB A,MEMTS2	;TRY AGAIN UNLESS WE HAVE ENOUGH
	BR MEMTS3
MEMTS1:	SPL 0
	CMP (P)+,(P)+	;FLUSH THE TRAP
	REST BEBRV
	MOV #CSTSYB,(B)+	;SAY THE SYSTEM IS USING NON-EX CORE
	SOB A,.-4
MEMTS3:	MOV ITM0AR,B
	SUB #<<RUGIAR-I0AR>+2>*100,B	;CONVERT TO AMOUNT ABOVE RUG
	BGE .+4		;IS THERE ENOGUH FOR RUG
	BPT		;NO!!!!
	ASH #-4,B	;CONVERT TO 512 WORD BLOCKS
	MOV #<<RUGIAR-I0AR>+2>*4,A	;FIRST BLOCK AFTER RUG
	JSR PC,MEMALC	;NOW GO SEE WHAT WE CAN GET FROM THIS
	MOV #FSTFRB,A	;FROM FIRST FREE BLOCK
	MOV #<<RUGST-LSTILC>_-10.>&77,B	;NUMBER FREE BEFORE RUG
;FALL INTO MEMALC TO USE UP SPACE BETWEEN END OF CODE AND RUG
MEMALC:	MOV A,C		;THE BEGGINING OF THE AREA
	ASL C		;CONVERT TO A WORD INDEX
	ADD #CST,C	;WE WILL USE IT TO SET THE CST
	MOV #2,-(P)	;FIRST CPT INDEX TO USE
	TST -(P)	;AND A FREE WORD
MEMAL1:	MOV #10,D	;INDEX TO SIZE-INDEXED TABLES
MEMAL7:	ASL D		;CONVERT BACK TO INDEX
MEMAL2:	MOV MEMIAT-2(D),(P)	;NUMBER OF THINGS THIS SIZE TO TRY TO ALLOCATE
	BEQ MEMAL4	;OOOPS, NONE THIS SIZE PLEASE!
MEMAL5:	ASR D		;CONVERT INDEX TO COUNT
	TST B		;IS THERE ANY LEFT?
	BEQ MEMAL3	;NOPE! GOODBYE.
	CMP D,B		;DO WE HAVE ENOGUH FOR THIS SIZE BLOCK?
	BGT MEMAL6	;NOPE, TRY A SMALLER ONE
	BIS #CSTFBB!CSTFRB,(C)	;THE BEGINNING OF A FREE PAGE
	MOV D,E		;THE SIZE OF THE PAGE
	ADD 2(P),(C)+	;THE CPT INDEX
	SOB E,.-4	;IN ALL THE CST WORDS FOR THIS PAGE
;FALL THROUGH TO NEXT PAGE
;FALL IN FROM PREVIOUS PAGE
	MOV 2(P),E	;GET THE CPT INDEX
	ADD #CPTLEN,2(P)	;MOV TO NEXT CPT BLOCK
	CMP #CPTEND,E	;MAKE SURE WE DON'T GO OFF THE END
	BGT .+4		;BRANCH IF NOT OFF THE END
	BPT		;!
	ASL D		;BACK TO AN INDEX AGIAN
	MOV FMMALT-2(D),CPT(E)	;LINK INTO FREE LIST FOR THIS SIZE
	MOV E,FMMALT-2(D)
	MOV #-1,CPT+CPTUPP(E)	;THE UPT POINTER=NULL
	MOV A,CPT+CPTADR(E)	;THE CORE ADDRESS
	ASR D		;BACK TO COUNT
	ADD D,A		;INCREMENT ADDRESS
	SUB D,B		;DECREMENT SPACE LEFT
	ASL D		;BACK AGAIN
	DEC (P)		;DONE ALL OF THIS SIZE?
	BNE MEMAL5	;NOT YET
MEMAL4:	ASR D	;BACK TO COUNT
MEMAL6:	SOB D,MEMAL7
	BR MEMAL1	;DO IT ALL AGAIN
MEMAL3:	CMP (P)+,(P)+	;RESTRE STACK
	RTS PC
	.SBTTL ROUTINES THAT ARE NOT YET WRITTEN

BPTBRK:	HALT
	RTI
BEBRK:	HALT
	RTI
IOTBRK:	HALT
	RTI
	.SBTTL EMT HANDLERS
;GET HERE WHEN A USER EXECUTES AN EMT
EMTBRK:	CMPB #60,PS+1	;MAKE SURE IT CAM FROM USER MODE
	BEQ .+4
	BPT		;ERF!
	MOV PC,USRMOD	;NOW WE AREIN THE SYSTEM!
	JSR F,SPCPSP	;SAVE THE USER'S PC, PS AND PDL POINTER
	CLR PUPDLO(A)	;NOTHING POPED YET
	SUB #2,PUPC(A)	;POINT TO THE CALL ITSELF
	MFPI @PUPC(A)	;GET THE ACTUAL CALL
	REST B		;POP IT OFF THE STACK
	ASL B		;CONVERT IT TO A WORD INDEX
	BIC #177001,B	;8 BITS ARE SIGNIFICANT
	CMP #EMTHGH*2,B	;IS IT TOO HIGH?
	BLOS BADEMT	;YUP, TELL HIM HE IS A LOSER
	SAVE PS		;NOTE THAT TRACE TRAPS WILL ACT STRANGELY HERE
	BIC #357,(P)	;PRIORITY 0
	SAVE EMTDIS(B)	;DISPATCH ADDRESS
	RTI
BADEMT:	HALT
CFAULT:	HALT

;RETURN FROM EMT TO USER
ENOOP:
EMTRET:	SAVE PS		;FOR THE CONDITION CODES
	MOV ITM0A,A	;PROCESS HAD BETTER BE THERE
	CLR PSPC(A)	;NOT IN THE SYS ANYMORE
	MOVB PUPS+1(A),1(P)	;GO BACK TO USER MODE PROPERLY
	SAVE PUP(A)	;GET HIS OLD P ONTO MY STACK
	ADD PUPDLO(A),(P)	;ANYTHING POPED FROM IT?
	MTPI P		;RESTORE P FOR HIM
	SAVE PUPC(A)	;PUT THE PC ON THE STACK NOW
	ADD #2,(P)	;START HIM AFTER THE CALL
	MOV A,B		;THE ITEM ADDRESS
	JSR PC,PACRES	;RESTORE HIS AC'S
	SPL CLKL	;PREVENT A SCHEDULE
	CLR USRMOD	;THIS COULD CAUSE ONE
	TST QUANT	;HAS HE OVERSTAYED HIS WELCOME?
	BGE .+10	;NO
	BIS #CLKPIR,PIRQ	;GET HIM AFTER THE RTI
	RTI		;GO TO USER MODE
;PROCESS HACKING EMTS
;.FORK:
;1 ARGUMENT IS ADDRESS OF PLACE TO START NEW PROCESS
;CLEARS Z IF IT SUCEEDS IN CREATING A NEW PROCESS
EFORK:	MFPD @PUP(A)	;GET THE PLACE TO START IT
	MOV #2,PUPDLO(A)	;INDICATE THAT AN ARG SHOULD BE POPED
	JSR PC,CRPROC	;ATTEMPT TO CREATE A PROCESS
	BEQ EFORK1	;FAIL
	MOV CURSPH,B	;PUT IT INTO THE CURRENT PROCESS
	JSR PC,PUTPRS
	JSR PC,ITM0PL	;LOAD IT TEMPORARILLY
	REST PUPC(A)	;SET ITS PC
	BIC #PSUPSB,PSTOP(A)	;CLEAR THE STOP BIT
	JSR PC,PSTPDC	;GO START IT
	JSR PC,ITM0PO	;POP ITEM STACK
ERETCZ:	CLZ		;SUCESS
EFORK1:	JMP EMTRET

;.POOFF:
;NO ARGUMENT. MAKE THE PROCESS EXECUTING ITDISAPPEAR WITHOUT A TRACE
;CURRENTLY, THE PROCESS IS ONLY STOPPED
;IF THERE ARE ANY REFERENCES TO ITREMAINING
EPOOFF:	MOV PRUNNG,A	;THE PROCESS THATIS RUNNING
	JSR PC,PSTPIN	;INCREMENT THE STOP WORD
	JSR PC,DLPROC	;DECREMENT REFERENCE COUTN AND DELETE IF ZERO
	RTS PC		;HOPEFULLY, RETURN TO SCHEDULER
;.SLEEP:
;1 ARG IS TOP 2 WORDS ON STACK (LOW ORDER IS TOP WORD)
;NEGATIVE=>NEGATIVE OF SYSTEM TIME TO CONTINUE
;POSITIVE=>NUMBER OF 60THS TO SLEEP
ESLEEP:	MOV PUP(A),B	;GET HIS PDL POINTER
	MFPD (B)	;GET TOP WORD
	MOV (P),C	;SAVE IT IN C
	MTPD (B)+	;MAKE SURE WE CAN WRITE IT
	MFPD (B)	;GET HIGH ORDER WORD
	MOV (P),D	;SAVE IT IN D
	MTPD (B)	;MAKE SURE WE CAN WRITE IT
	MOV #4,PUPDLO(A)	;POP 2 THINGS IF SUCESSFUL
	TST D		;IS IT NEGATIVE?
	BLT ESLEE1	;YES, GO SEE IF IT'S TIME YET
	NEG C		;NEGATE DOUBLE WORD NUMBER
	ADC D
	NEG D
	SUB TIME,C	;NOW COMPUTE NEGATIVE TIME TO WAKE UP
	SBC D
	SUB TIME+2,D
	SAVE D		;NOW CLOBBER USER'S THING TO NEGATTIVE
	MTPD (B)	;CLOBBER HIGH ORDER
	SAVE C
	MTPD -(B)
ESLEE1:	JSR PC,ESLEEC	;CHECK IF TIME IS UP
	BGE ERETCZ	;YES, GO AWAY
ESLEE4:	CMP #-1,B	;IS IT A LONGE TIME TO WAIT?
	BNE ESLEE2	;YES, MORE THAN 2**16 TICKS
	CMP #-LTIMEL*4,A	;WELL, IS IT LONG?
	BGT ESLEE2	;YUP, MORE THAN 4 LONG WAITS
	JSR PC,SFLUSH	;NOT LONG
	BR ESLEE3	;NOW TRY AGAIN
ESLEE2:	JSR PC,LFLUSH	;LONG TIME TO WAIT
ESLEE3:	JSR PC,ESLEEC	;WELL, TIME UP NOW?
	BLT ESLEE4	;NOPE
	JSR PC,RUNME	;ALL DONE
	BR ERETCZ	;GO RETURN TO USER
ESLEEC:	MOV C,A	;COPY TIME TO WAKE UP
	MOV D,B
	ADD TIME,A
	ADC B
	ADD TIME+2,B
		RTS PC
	.SBTTL START THE WORLD ROUTINE
GO:	RESET
	MOV #PDL,P	;SET UP THE PDL
	JSR PC,MAPSET	;SET UP THE INTIAL MAP
	JSR PC,MEMTST	;SET UP MEMORY TABLES
	SAVE BEBRV	;FIND OUT WHICH CLOCK WE HAVE
	MOV #GOPC,BEBRV	;GO TO GOPC FOR PROGRAMMABLE CLOCK
	MOV #100,LCCS	;TRY TO START THE LINE CLOCK
	BR GOLC		;WON'T GET HERE IF UNSUCESSFUL
GOPC:	SPL 0		;IN CASE SET BY THE BREAK
	CMP (P)+,(P)+	;FLUSH SAVED THINGS
	CLR PCCB	;WE HAD BETTER HAVE A PROGRAMMABLE CLOCK!
	MOV #115,PCCS	;TRY LINE FEQUENCY, REPEAT INT, ETC.
GOLC:	REST BEBRV	;WE HAVE SET UP THE CLOCK
;INITIALIZE VARIOUS TABLES ON THE NEXT PAGE
	MOV #INITLS,A	;THINGS TO LINK INTO FREE LISTS
INTLST:	MOV (A)+,B	;GET THE TABLE ADDRESS
	BEQ INTLS1	;DONE WITH THESE THINGS
	MOV (A)+,C	;GET THE ADDRESS OF THE FREE POINTER
	MOV (A)+,D	;GET THE NUMBER OF THINGS
	MOV (A)+,E	;GET THE LENGTH OF THEM
	MOV B,(C)	;SET UP THE FREE POINTER
	MOV B,C		;COPY POINTER INTO TABLE
INTLS2:	ADD E,C		;POINTER TO NEXT ONE
	MOV C,(B)	;GET PUT INTO THIS ONE
	ADD E,B		;GO TO NEXT ONE
	SOB D,INTLS2	;HOWEVER MANY TIMES
	BR INTLST
INTLS1:	MOV #INITM1,A	;STUFF TO MAKE -1
INTM11:	MOV #-1,(A)+
	CMP #EINTM1,A
	BNE INTM11
	MOV #ITMBIT,A	;THE BIT TABLE POINTERS
	MOV #ITMBTP,B
	MOV #NITMBL,C
INTBT1:	MOV A,(B)+	;POINTER TO A BIT TABLE
	ADD #22,A	;FURTHER ON
	SOB C,INTBT1	;FOR SO MANY BIT TABLES

	JSR PC,MEMTST	;SET UP MEMORY TABLES
;FALL THROUGH TO NEXT PAGE TO START UP THE SYSTEM PROCESS, ETC.
;FALLS IN FROM PREVIOUS PAGE
;START UP THE SYSTEM PROCESS
	JSR PC,CRUSER	;CREATE A USER
	MOV B,CURUSR	;HE IS THE CURRENT USER
	MOV #2,PRTPRI(B)	;INCREASE HIS PRITORITY
	JSR PC,CRSPHR	;CREATE A SPHERE FOR HIM
	MOV A,C		;SAVE THE SPHERE ITEM#
	JSR PC,CRPROC	;CREATE A PROCESS
	MOV C,B		;PUT THE SPHERE ITEM IN THE RIGHT PLACE
	JSR PC,PUTPRS	;PUT THE PROCESS INTO THE SPHERE
	MOV A,D		;SAVE THE PROCESS ITEM
	JSR PC,ITM0LD	;MAKE IT ITEM 0
	MOV A,C		;SAVE INDEX FOR PROCESS
	MOV B,A		;GET SPHERE ITEM #
	JSR PC,ITM1LD	;MAKE SPHERE ITEM1
	ADD #SUPTS,A	;GET A POINTER TO THE UPTS
	MOV #20,D	;THERE ARE 20 PAGES
	MOV #KERISD,E	;WE WILL COPY THE KERNEL MAP INTO THIS SPHERE
SYSJI1:	MOV (E)+,(A)+	;THE DR
	MOV KERISA-KERISD-2(E),(A)	;THE AR
	BIS #UPTABT,(A)	;AN ABSOLUTE PAGE
	ADD #UPTLEN-2,A
	SOB D,SYSJI1	;DO FOR 20 PAGES
	MOV #SYSJOB,PUPC(C)	;SET THE THINGS PROGRAM COUNTER
	MOV #SYSJPD,PUP(C)	;AND ITS PDL POINTER
	BIC #PSUPSB,PSTOP(C)	;CLEAR THE STOP BIT
	JSR PC,PSTPDC	;GO DECREMENT THE STOP COUNT AND PUT ON RUN Q
	CLR INITSW	;EXITING INIT CODE
	JMP SCHED	;GO GO GO!
	.SBTTL THE SYSTEM PROCESS(ES)
SYSJOB:	EMT 0		;NOP
	MOV #SYSJB1,-(P)
	.FORK
	CLR -(P)
	MOV #1,-(P)
	.SLEEP
	BR SYSJOB
SYSJB1:	WAIT
	WAIT
	WAIT
	WAIT
	WAIT
	.POOFF
	LSTILC=.	;PUT THIS AT THE LAST INSTRUCTION LOCATION
FSTFRB==<<<.!1777>+1>_-10.>&77	;FIRST FREE BLOCK
	.END GO
