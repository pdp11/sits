.MACRO FLASK Q,FLAG
.IF1
.PRINT /Q
FLAG=/
.TTYMAC F
FLAG==F
.ENDM
.ENDC
.ENDM

	.SBTTL INTERNAL REGISTER DEFINITIONS
.ABS
A=%0
B=%1
C=%2
D=%3
E=%4
F=%5
P=%6
PC=%7
.XCREF A,B,C,D,E,F,P,PC,FOO,FOOBAR

;MEMORY SEGMENTATION UNIT
SSR0=177572
SSR1=177574
SSR2=177576
SSR3=172516
USRISD=177600
USRDSD=177620
USRISA=177640
USRDSA=177660
SUPISD=172200
SUPDSD=172220
SUPISA=172240
SUPDSA=172260
KERISD=172300
KERDSD=172320
KERISA=172340
KERDSA=172360

;CONSOLE SWITCHES AND DISPLAY
CDISP=177570
CSWR=177570

;PROGRAM INTERUPT REQUEST REGISTER
PIRQ=177772

;STACK LIMIT REGISTER
STKLIM=177774

;PROCESSOR STATUS
PS=177776

RUGST==157000		;RUG STARTING LOCATION
;KERNAL MAP REGISTERS
I0AR=KERISA
I1AR=I0AR+2
I2AR=I1AR+2
I3AR=I2AR+2
I4AR=I3AR+2
I5AR=I4AR+2
I6AR=I5AR+2
I7AR=I6AR+2
RUGIAR=I6AR

I0DR=KERISD
I1DR=I0DR+2
I2DR=I1DR+2
I3DR=I2DR+2
I4DR=I3DR+2
I5DR=I4DR+2
I6DR=I5DR+2
I7DR=I6DR+2
RUGIDR=I6DR

VAR0AR=KERDSA
VAR1AR=VAR0AR+2
VAR2AR=VAR1AR+2
ITM0AR=VAR2AR+2
ITM1AR=ITM0AR+2
ITM2AR=ITM1AR+2
RUGDAR=ITM2AR+2
IOAR=RUGDAR+2

VAR0DR=KERDSD
VAR1DR=VAR0DR+2
VAR2DR=VAR1DR+2
ITM0DR=VAR2DR+2
ITM1DR=ITM0DR+2
ITM2DR=ITM1DR+2
RUGDDR=ITM2DR+2
IODR=RUGDDR+2

;INTERNAL TRAP VECTORS
BEBRV=4
ILLBRV=10
BPTBRV=14
IOTBRV=20
PWFBRV=24
EMTBRV=30
TRPBRV=34
PARBRV=114
PIRBRV=240
FPPBRV=244
SEGBRV=250
	.SBTTL DEVICE DEFINITIONS
;RF11 FIXED HEAD DISK
RFCS=177460	;CONTROL AND STATUS
RFWC=177462	;WORD COUNT
RFBA=177464	;BUSS ADDRESS
RFDA=177466	;DISK ADDRESS (LOW PART)
RFDAE=177470	;HIGH PART OF ADDRESS AND ERROR REGISTER
RFBRV=204

;RK11 MOVING HEAD DISK
RKDS=177400	;DRIVE STATUS REGISTER
RKER=177402	;ERROR REGISTER
RKCS=177406	;CONTROL AND STATUS REGISTER
RKWC=177410	;WORD COUNT
RKBA=177412	;BUSS ADDRESS
RKDA=177414	;DISK ADDRESS
RKBRV=220

;CONSOLE TELETYPE
;BREAK LEVEL 4
TKBRV=60	;CONSOLE KEYBOARD BREAK VECTOR
TKS=177560	;CONSOLE KEYBOARD STATUS
TKB=177562	;CONSOLE KEYBOARD DATA
TPBRV=64	;CONSOLE PRINTER BREAK VECTOR
TPS=177564	;CONSOLE PRINTER STATUS
TPB=177566	;CONSOLE PRINTER DATA


;PROGRAMMABLE CLOCK KW11-P
PCCS=172540	;CONTROL AND STATUS
PCCB=172542	;COUNT SET BUFFER
PCCN=172544	;COUNTER
PCBRV=104	;INTERUPT VECTOR

;LINE FEQUENCY CLOCK KW11-L
LCCS=177546	;CONTROL AND STATUS
LCBRV=100	;INTERUPT VECTOR

	.SBTTL SYSTEM PARAMETERS

;GENERALIZED ITEM POINTER DEFINITION
GIPBIT==100000	;SET IF IT IS A GENERALIZED ITEM POINTER
GIPSPR==40000	;BIT SET IF UPT IS IN A SPHERE
GIPITM==176000	;MASK FOR ITEM INDEX
GIPUPT==141777	;MASK FOR UPT NUMBER (IN SPHERE)
GIPFUP==140000	;MASK FOR FLOATING UPT TABLE OFFSET

;FOR THE ITEM LIST
NITEMS==300.	;MAXIMUM NUMBER OF ITEMS
NITMBL==8.	;MAXIMUM NUMBER OF BLOCKS ALLOCATED TO ITEM STROAGE
NITMPS==10	;MAXIMUM DEPTH OF ITEM PUSHES
NITALS==NITMBL*64.	;NUMBER OF FREE STROAGE NODES
		;CURRENTLY ALLOCATED FOR THE WORST CASE
;DEFINITION OF AN ITEM TABLE ENTRY
ITMTEL==4	;LENGTH OF ENTRY
ITMADR==0	;WHERE THE ADDRESS OF THE ITEM IS KEPT
ITLINK==0	;ALSO USED FOR LINK OF FREE ENTRIES
ITACCS==2	;BYTE WHICH CONTAINS THE ACCESS CODE FOR THE ITEM
ITACCD==6	;ITEM ACCESS CODE (READ-WRITE NO TRAP)
ITLNGT==3	;BYTE WHICH CONTAINS THE LENGTH OF THE ITEM
;ADDRESSES OF THE ITEM SLOTS
ITM0AD==<ITM0AR-KERDSA>_12.
ITM1AD==<ITM1AR-KERDSA>_12.
ITM2AD==<ITM2AR-KERDSA>_12.

;PROCESS AND USER PARAMETERS
NPROSS==80.	;MAXIMUM NUMBER OF PROCESSES AND USERS
PRPDLL==40	;LENGTH OF THE PDL FOR THE PROCESS
;DEFINITION OF A PROCESS TABLE ENTRY
PRSTEL==14	;LENGTH OF A PROCESS TABLE ENTRY
PRTFRD==0	;FORWARD POINTER
PRTBCK==2	;BACK POINTER
PRTPPT==4	;PROCESS POINTER (OR TO ITEM IF USER)
PRTUPT==6	;USER POINTER (-1 FOR USER)
PRTJMT==10	;JMTU
PRTPRI==12	;HIS PRIORITY

;SPHERE PARAMTERS
MNCLSE==200	;MAXIMUM NUMBER OF C-LIST ENTRIES
NCLSEB==10	;NUMBER OF C-LIST ENTRIES PER BLOCK
CLSELN==12	;LENGTH OF A C-LIST ENTRY (NOTE THAT THE LENGTH OF A BLOCK=NCLSEB*CLSELN, WHATEVER IT IS)
;DEFINITION OF A C-LIST ENTRY
CLSETY==0	;TYPE
CLSEPI==2	;PRIMARY ITEM FOR ENTRY
CLSESI==4	;SECONDARY ITEM FOR ENTRY
CLSEM0==6	;FIRST RANDOM WORD FOR ENTRY
CLSEM1==10	;SECOND RANDOM WORD
;UPT ENTRY DEFINITION
UPTLEN==10	;LENGTH OF A UPT ENTRY
UPTDR==0	;DESCRIPTOR REGISTER (DON'T CHANGE!)
UPTDEI==100000	;THE DATA=INSTRUCTION BIT
UPTSMS==107460	;MASK TO CONVERT CONTENTS OF UPTDR FOR SEGMENTER
UPMSRE==174377	;MASK FOR START OF REFERENCED ENTRY
UPMLRE==107777	;MASK FOR LENGTH OF REFERENCED ENTRY
UPTEXP==10	;PAGE EXPANSION BIT (SET IF DOWNWARD EXPANSION)
UPTSRT==1	;BOTTOM THREE BITS ARE START
UPTAR==2	;THE AR FOR THE SEGEMENT
UPTABT==100000	;THE ABSOLUTE PAGE BIT
UPTICR==10	;THE IN CORE BIT
UPASMS==170017	;THE MASK FOR THE ADDRESS FIELD
UPMSSW==177770	;MASK FOR START OF AREA TO BE SWAPPED
UPMLSW==107777	;MASK FOR LENGTH OF AREA TO BE SWAPPED
UPTCLP==4	;THE CIRCULAR LIST POINTER (GIP)
UPTFPT==6	;THE SWAP ADDRESS OR FPT POINTER (IF 100000 BIT SET)
;FORMAT OF A UPT SWAP ADDRESS (DON'T CHANGE THESE DEFINITIONS)
UPTLSB==1	;SET IF LARGE SWAP BLOCK
UPTBTM==177761	;BIT TABLE MASK
UPTBOM==100017	;OFFSET INTO BIT TABLE MASK

;FPT ENTRY DEFINITION
NFPTS==100.	;PSEUDO-RANDOMM MAXIMUM # OF FPTS
FPTLEN==34	;LENGTH OF FPT ENTRY
FPTSWA==0	;SWAP ADDRESS
FPTLNK==2	;POINTER TO NEXT FPT IN LINKED LIST
FPTMFI==4	;MFI POINTER
FPTUPT==6	;GENERALIZED ITEM POINTER TO LINKED UPT'S
FPTPNO==10	;FILE PAGE NUMBER
FPTFLG==12	;FLAG WORD BOTTOM BYTE IS LOGICAL DSK # 
FPTWSB==MFIWSB	;"WRITE TO SOURCE" BIT
FPTLKB==400	;LOCK BIT
FPTSRC==14	;FIRST OF 8 WORDS CONTAINING BLOCK SOURCE ADDRESSES
FPTBAS==100000	;"BLOCK AT SOURCE" BIT

;FUPT ENTRY DEFINITION (FLOATING UPT)
;BEGINS LIKE UPT
NFUPTS==NFPTS	;MAYBE 2* OR SOME OTHER CONSTANT
FUPTLE==12	;LEGNTH OF FUPT ENTRY
UPTPRP==10	;PROCESS POINTER

;PFPT ENTRY DEFINITION
NPFPTS==100.	;PSEUDO-RANDOM MAX. # OF PFPTS
PFPTLE==4	;LENGTH OF PFPT ENTRY
PFPSWA==0	;SWAP ADDRESS FOR PFPT (IF 100000 BIT SET)
PFPPTR==2	;POINTS TO FPT

	;FOR THE TELETYPE ITEM
TITQ==TOQM-1
TIQSZ==350.
TIBSZ==50.
TOQSZ==64.
TIBT==TIQM
TIQLM==TOQM
TOQLM==TOQM+TOQSZ

;FOR THE QUE ITEM
QUESZ==64	;THE SIZE OF THE QUE

	;DEFINITION OF A DISK REQUEST LIST ENTRY
NDSKRQ==10.	;A GUESS, THE MAXIMUN NUMBER OF PENDING DISK TRANSFERS
DSKLEN==6	;LENGTH OF A DISK REQUEST
		;THE FIRST WORD IS POINTER TO NEXT DISK REQUEST, 0 IF LAST
DSKGIP==2	;GENERALIZED ITEM POINTER TO DATA
DSKWD==4	;RANDOM DATA WORD, CONTAINING FUNCTION


;FOR THE CST
MNCBLK==180.	;MAXIMUM AMOUNT OF CORE IN 512 WORD BLOCKS
CSTSYB==100000	;THE "USED BY SYSTEM" BIT
CSTBEB==40000	;THE "BLOCK EXISTS" BIT
CSTFBB==20000	;THE "FIRST BLOCK OF PAGE" BIT
CSTFRB==10000	;THE FREE BIT
CSTCOM==176000	;THE CPT OFFSET MASK

;FOR THE CST
NCPTTE==MNCBLK/4	;NUMBER OF CPT TABLE ENTRIES (ASSUME AVERAGE PAGE SIZE=2K)
CPTLEN==6	;LENGTH OF A CPT ENTRY
CPTLNK==0	;THE LINK
CPTUPP==2	;THE UPT POINTER
CPTADR==4	;THE CORE ADDRESS AND MISC BITS
CPTCRM==176000	;THE CORE ADDRESS MASK
CPTSYB==100000	;THE "USED BY SYSTEM BIT" IN THE CPTADR
CPTSPB==40000	;THE "BEING SWAPPED" BIT IN THE CPTADR
CPTMOV==20000	;THE "BEING MOVED" BIT

;FOR THE LOCKED SWITCH LISTS
NLCKBL==NPROSS/2	;A GUESS
LCKLEN==10
LCKTIT==2	;TYPE AND ITEM
LCKWD1==4	;WORD ONE OF LOCK DATA
LCKWD2==6	;WORD TWO

;MISC SYSTEM PARAMETERS
LTIMEL==15.	;NUMBER OF TICKS BETWEEN CHECKING LONG FLUSHES
STIMEL==5.	;NUMBER OF TICKS BETWEEN SHORT FLUSH CHECKS
JMTUUT==6	;NUMBER OF TICKS BETWEEN JMTU UPDATES
JMTUAC==40	;ADDITIVE CONSTANT
JMTUDC==4	;DECAY CONSTANT
CLKL==1		;LEVEL CLOCK RUNS AT
CLKPIR==1_<CLKL+10>	;BIT FOR PIRQ
IPRIOR==4	;PRIORITY TO SET A NEWLY CREATED PROCESS TO
IQUANT==4	;INTIAL QUANTUM
	.SBTTL DEFINITIONS FOR VARIOUS TYPES OF ITEMS
;MACROS TO DEFINE ITEMS WITH

;THE START DEFINING ITEM MACRO
	.MACRO SITEMD SYM
FOO==2
ITMTFO==ITMTFO+1
SYM==ITMTFO
	.ENDM

;THE DEFINE SYMBOL MACRO
;IF SECOND ARG IS PRESENT, IT IS HOW MUCH SPACE TO RESERVE, IN BYTES
	.MACRO DITMS SYM,SIZE
SYM==FOO
	.IIF B SIZE,FOO==FOO+2
	.IIF NB SIZE,FOO==FOO+<SIZE>
	.ENDM

;THE DEFINE FLAG WORD MACRO
;SPACE IS RESERVED FOR THE FLAG WORD, AND FLAGS ARE DEFIND
;SEQUENTIALLY FROM THE RIGHT TO THE LEFT 
	.MACRO DFWORD SYM,BITS
FOOBAR==0
SYM==FOO
FOO==FOO+2
	.IRP X,<BITS>
X==1_FOOBAR
FOOBAR==FOOBAR+1
	.ENDM
	.ENDM

;THE DEFINE ITEM SIZE MACRO
;DEFINES A SYMBOL AS THE SIZE OF THE ITEM DEFINED SO FAR
	.MACRO DITMSZ SYM
SYM==FOO_-6
	.ENDM
ITMTFO==0	;THE TYPE OF THE LAST ITEM DEFINED
ITTYPE==0	;FOR ALL ITEMS, THE FIRST WORD IS THE TYPE
;DEFINITION OF A PROCESS ITEM
SITEMD ITPROC
;THE NEXT THREE SHOULD NOT BE MOVED
;WITHOUT MOVING THE COORESPONDING THREE IN THE USER DEFINITION
DITMS PRSREF		;REFERENCE COUNT
DITMS PPRTPT		;POINTER TO PROCESS TABLE
DITMS PQBIT		;THE QUEUE BIT
DITMS PTUSED,4		;TIME USED BY THIS PROCESS IN HALF-TICKS
DITMS PFAULT		;IF NON-ZERO, THE FAULT NOT YET COMPLETED
DITMS PSPHRP		;POINTER TO SPHERE
DITMS PSPHCP		;CIRCULAR POINTER TO OTHER PROCESSES IN SPHERE
DITMS PLCKSL		;END OF THE LOCKED SWITCH LIST
DITMS PUPDLO		;OFFSET OF USER'S PDL IF CALL COMPLETES
DITMS PITEM2		;PROCESS'S ITEM2
DITMS PUPT0,UPTLEN	;UPT FOR RANDOMNESS
DITMS PUREGS,14		;THE USER'S REGISTER'S
DITMS PUP		;THE USER'S PDL POINTER
DITMS PUPC		;THE USER'S PC
DITMS PUPS		;THE USER'S PROCESSOR STATUS
DITMS PSREGS,14		;THE SYSTEM'S REGISTERS
DITMS PSP		;THE SYSTEM'S PDL POINTER
DITMS PSPC		;THE SYSTEM'S PC
DITMS PPDL,PRPDLL	;THE PROCESS'S PDL
DFWORD PFLAGS,<PFPFLG,PACSVF>	;PROCESS FLAG WORD
DITMS PSTOPC		;STOP COUNT
DFWORD PSTOP,<PSPHSB,PSUPSB>	;STOP WORD
;PSPHSB INDICATES THE SPHERE HAS STOPPED THE PROCESS
;PSUPSB INDICATES SOME OTHER SUPERIOR PROCESS HAS STOPPED IT
DITMSZ PRSLNF		;SIZE WITH NO FLOATING POINT
DITMS PFPPRG,24.*2	;FLOATING POINT REGISTERS
DITMS PFPPS		;FLOATING POINT STATUS
DITMS PFEC		;FLOATING EXCEPTION CODE
DITMS PFEAP		;FLOATING EXCEPTION ADDRESS POINTER
DITMSZ PRSLFP		;LENGTH WITH FLOATING POINT

;DEFINITION OF A USER ITEM
SITEMD ITUSER
;THE NEXT THREE SHOULD NOT BE MOVED (SEE PROCESS)
DITMS USRREF		;THE REFERENCE COUNT
DITMS UPRTPT		;POINTER INTO PROCESS TABLE
DITMS UQBIT		;THE QUEUE BIT (HAD BETTER BE USER QUEUE)
DITMS UTUSED,4		;TIME USED BY THIS USER
DITMSZ USRLEN		;LENGTH OF A USER ITEM
;DEFINITION OF A SPHERE ITEM
SITEMD ITSPHR
;THE NEXT THREE SHOULD NOT BE MOVED (SEE USER)
DITMS SPHREF		;REFERENCE COUNT
DITMS SPRTPT		;THE SPHERE PROCESS TABLE POINTER
DITMS SQBIT		;THE QUEUE BIT (BETTER BE SPHERE QUE)
DITMS SCLSLK		;SPHERE C-LIST LOCK (CONTAINS THE ITEM NO. OF THE PROCESS THAT
			;LOCKED IT
DITMS STTFG1		;TELETYPE FLAG WORD 1
DITMS STTFG2		;TTY FLAG WORD 2
DITMS SMTTY		;ITEM NO. OF MASTER TTY ITEM
DITMS SIFTTY		;ITEM NO. OF INFERIOR TTY SPHERE
DITMS SPHPRP		;POINTER TO FIRST PORCESS
DITMS SUSRPT		;POINTER TO USER ITEM RESPONSIBLE FOR THIS SPHERE
DITMS SMSSPT		;POINTER TO MASTER SPHERE OF THIS SPHERE
DITMS SCLSEP		;POINTER TO FIRST UNUSED LOCATION, RELATIVE TO ITEM
DITMS SUPTS,16.*UPTLEN	;THE UPT ENTRIES
DITMS SCLSTT,MNCLSE/NCLSEB	;THE INDEX OFFSETS TO THE C-LIST
DITMS SICLST,NCLSEB*CLSELN*2	;START WITH 2 BLOCKS OF C-LIST
DITMSZ SPHLEN

;DEFINITION OF A TELETYPE ITEM
SITEMD ITTTY
DITMS TTYREF	;REFERENCE COUNTER FOR TTY
DITMS TTITM	;ITEM THAT CURRENTLY OWNS THIS TTY
DITMS TTLTTY	;THE LOGICAL TTY NO. ASSOCIATED WITH THIS ITEM
DITMS TTYU	;USER NUMBER OF THE OWNER OF THIS TTY
DFWORD TTYST,<TIRST,TIQF,TOTRAN,TIMAGI,TIMAGO,TIRBM,TIEDM,TIECM,TICVM,TILIPM,TORST>	;STATUS OF TTY
DITMS TOTSR	;ADDR OF TRANSMIT STATUS REGISTER
DITMS TIBI	;POINTER TO WHERE NEXT CHAR. GOES IN, IN INPUT BUFFER
DITMS TIBO	;  "     "    "     "    "  COMES OUT  "   "     "
DITMS TIBN	;NUMBER OF CHAR. IN INPUT BUFFER
DITMS TIQI	;POINTER TO WHERE NEXT CHAR GOES IN, IN INPUT QUE
DITMS TIQO	;    "    "   "     "    " COMES OUT  "   "    "
DITMS TIQN	;NUMBER OF CHAR. IN INPUT QUE
DITMS TOQI	;POINTER TO WHERE NEXT CHAR. GOES IN, IN OUTPUT QUE
DITMS TOQO	;   "     "   "    "    "   COMES OUT  "    "     "
DITMS TOQN	;NUMBER OF CHAR. IN OUTPUT QUE
DITMS TIEQO	;POINTER TO WHERE NEXT CHAR COMES OUT, IN OUTPUT QUE
DITMS TIEQN	;NUMBER OF CHARACTERS IN EDIT QUE
DITMS TIBC	;NUMBER OF UNMATCHED LEFT BRACKETS IN INPUT QUE
DITMS TIEBC	;   "   "       "      "      "     "   "    "
DITMS TIQTO	;POINTER TO WHERE ECHO IS PROCESSING
DITMS TIQTON	;NUMBER OF CHAR THAT ECHO STILL HAS TO PROCESS
DITMS TIEQTN	;NUMBER OF CHAR THAT RDSTR HAS TO PROCESS
DITMS TIEQTO	;POINTER TO WHERE RDSTR IS PROCESSING
DITMS TITQN	;TOTAL NUMBER OF CHAR IN INPUT/EDIT QUE
DITMS TOPAD	;NUMBER OF CHAR LEFT TO SEND PAD
DITMS TOIPC	;SAVED PC FOR ECHO
DITMS TOISVA	;SAVED A FOR ECHO
DITMS TOPC	;SAVED PC FOR OUTPUT
DITMS TOSVC	;SAVED C FOR OUTPUT
DITMS TOSVD	;SAVED D FOR OUTPUT
DITMS CHARNO	;NUMBER OF CHAR PRINTED FROM LEFT EDGE OF PAGE
DITMS TIBB,TIBSZ	;INPUT BUFFER
DITMS TIQM,TIQSZ	;INPUT QUE
DITMS TOQM,TOQSZ	;OUTPUT QUE
DITMSZ TTYLEN


;DEFINITION OF A QUE ITEM
SITEMD ITQUE	;QUE ITEM
DITMS QUEREF	;REFERENCE COUNT OF THE ITEM
DITMS QUEENO	;NO OF ENTRIES IN QUE
DITMS QUECNT	;NO OF PEOPLE ON QUE
DITMS QUENUM	;THE NUMBER OF PEOPLE WHO CAN LOCK QUE
DITMS QUEQUE,QUESZ	;THE QUE
DITMSZ QUELEN
;DEFINITION OF A MASTER FILE ITEM
SITEMD ITMF
DITMS MFREF		;CAPABILITIES AND SPHERE UPTS INCREMENT THIS
			;ALSO UPTS (NOT FUPTS)
DITMS MFHLNK		;HASH LINK
DITMS MFLAGW		;BOTTOM BYTE IS LOGICAL DSK #
MFILEB==.FAFB		;FILE/DIRECTORY BIT
MFLOKB=.FAMFL		;LOCK BIT FOR PRIVATE MFI
MFDWDB==20000		;DELETE WHEN DONE BIT
MFEBMB==10000		;ENTRY BEEN MUNGED
MFFIUB==4000		;FILE IN USE
MFIWSB==2000		;WRITE TO SOURCE
MFIRTB=1000		;ROOT DIR. BIT
DITMS MFPARB		;BLOCK # OF PARENT DIRECTORY
DITMS MFBKP		;POINTS TO PARENT MFI IF A FILE
			;OR BYTES LEFT IN BLOCK IF DIR
DITMS MFBFPT		;BIT TABLE PTR
DITMS MFIFPT		;FIRST IN LIST OF LINKED FPT'S
DITMSZ MFLEN
MFELEN==FOO		;EXACT LEGNTH IN BYTES
DITMS MFENHD		;ENTRY HEADER
DITMS MFNAME		;NAME GOES HERE
MFHEDB==0		;BITS IN ENTRY HEADER FLAG WORD
MFDIRB==100
MFFILB==200
MFLNKB==300
MFWDLF==20000		;WORD LEFT BIT
MFBTLF==10000		;BYTE LEFT BIT


.SBTTL MACROS FOR GENERATING CODE

;MACRO TO PUSH THINGS ONTO THE STACK
.MACRO SAVE THINGS
.IRP X,<THINGS>
	MOV X,-(P)
.ENDM
.ENDM

;MACRO TO POP THINGS FROM STACK
.MACRO REST THINGS
.IRP X,<THINGS>
	MOV (P)+,X
.ENDM
.ENDM
;MACRO TO REPLACE .WORD
.MACRO WORDS A,IB,C,D,E,F,G,H,I,J,K,L,M,N
.IRP X,<A,IB,C,D,E,F,G,H,I,J,K,L,M,N>
.IIF B X,.MEXIT
X
.ENDM
.ENDM

;MACRO TO REPLACE .BYTE
.MACRO BYTES A,IB,C,D,E,F,G,H,I,J,K,L,M,N
.IRP X,<A,IB,C,D,E,F,G,H,I,J,K,L,M,N>
.IIF B X,.MEXIT
.BYTE X
.ENDM
.ENDM

	.SBTTL TRAP VECTORS
	.MACRO TRAPV DEV,PRI
.=DEV'BRV
.IIF P2,.IIF NDF DEV'BRK,DEV'BRK==0
	DEV'BRK
.IIF NB PRI,	PRI_5
.IIF B PRI,	200
.ENDM
	.=0
	BPT
	.=4
	.REPT 77
	.+2
	BPT
	.ENDR

;TRAP VECTORS FOR INTERNAL DEVICES
TRAPV BE	;BUSS ERRORS
TRAPV ILL	;ILLEGAL INSTRUCTIONS
TRAPV BPT	;BREAKPOINTS
TRAPV IOT	;IOT
TRAPV PWF,7	;POWER FAILURE
TRAPV EMT	;EMT
TRAPV TRP	;TRAP
TRAPV PAR	;PARITY ERROR
TRAPV PIR,7	;PROGRAMMED INTERUPT
TRAPV FPP	;FLOATING POINT ERROR
TRAPV SEG	;SEGMENTATION ABORT OR TRAP

;TRAP VECTORS FOR OTHER DEVICES
TRAPV RF	;FIXED HEAD DISK
TRAPV RK	;MOVING HEAD DISK
TRAPV LC,CLKL	;LINE CLOCK
TRAPV PC,CLKL	;PROGRAMABLE CLOCK
TRAPV TK	;CONSOLE KEYBOARD
TRAPV TP	;CONSOLE PRINTER 

	.=400
	.SBTTL SYSTEM VARIABLES AND TABLES

	.BLKW 100	;FOR THE SYSTEM PDL
PDL:
PATCH:
PAT:	.BLKW 100
	.BLKW 40
SYSJPD:		;THE SYSTEM JOB'S PDL
%CSX:	.BLKW 4	;PLACE FOR SIMULATOR TO DO X'S
BMT:	BYTES 1,2,4,10,20,40,100,200	;BIT MARK TABLE
	;FOR MARKING BIT TABLES, THE NTH ENTRY IS THE NTH BIT
INITSW:	-1	;ZERO AFTER EXITING INIT CODE
PRUNNG:	-1	;ITEM # OF RUNNING PROCESS, NEG=> IN SYSTEM
			;(THIS IS NOT SET TO -1 BY INTERUPT ROUTINES)
USRMOD:	-1	;IF A PROCESS IS RUNNING, NON-ZERO=> IN SYSTEM CODE
			;0=>IN USER'S CODE
SYSSPR:	-1	;ITEM NUMBER OF THE SYSTEM SPHERE
CURUSR:	-1	;PROCESS BLOCK INDEX OF THE RUNNING PROCESS'S USER
CURSPH:	-1	;ITEM INDEX OF SPHERE OF THE RUNNING PROCESS
BPCLSR:	0	;NON-ZERO WHEN IN PROCESS OF PCLSRING THE GUY GETTING UNLOCKED
QUANT:	0	;NUMBER OF TICKS BEFORE THE RUNNING PROCESS SHOULD BE STOPPED
PQUANT:	IQUANT	;QUANTUM TO GIVE A PROCESS WHEN YOU START IT
TUSED:	0	;TIME THE PROCESS HAS USED SINCE LAST STARTED
TIME:	.BLKW 2	;TIME SINCE SYSTEM STARTED IN TICKS
STIMER:	0	;TIME TILL NEXT CHECK OF SHORT FLUSHES
LTIMER:	0	;TIME TILL NEXT CHECK OF LONG FLUSES
JMTUUP:	JMTUUT	;NUMBER OF TICKS TILL NEXT UPDATE OF JMTUS
PIRDIS:	WORDS PIRLOS,STOPPR,PIRLOS,PIRLOS,PIRLOS,PIRLOS,PIRLOS,PIRLOS	;THE PIR DISPATCH
PIRBIT:	WORDS 0,1000,2000,4000,10000,20000,40000,100000	;THE PIR BITS
;LOCK TABLES AND DEFINTIONS
.MACRO LCKDEF A,B
A==FOO
B
FOO==FOO+2000
.ENDM
FOO==0
;LOCK DISPATCH TABLE
LCKDIS:	LCKDEF FOO,LSPERR	;THE ZERO LOCK SHOULD NOT OCCUR
	LCKDEF LONOFF,LSPONF	;ON/OFF LOCK
				;WORD 1 IS ABS ADDR OR OFFSET INTO ITEM
				;WORD 2 CONTAINS BIT(S) LOCKED IN WORD
	LCKDEF LPCLRT,LSPPCL	;RUN ROUTINE IF PCLSRED
				;WORD 1 IS ADDRESS OF ROUTINE
	LCKDEF LCKRTN,LSPRTN	;RUN ROUTINE WHEEVER UNLOCKED
				;WORD 1 IS ROUTINE ADDRESS
	LCKDEF LCKDEC,LSPDEC	;DECREMENT WORD WHEN UNLOCKED
				;WORD 1 IS ABS ADDR OR OFFSET INTO ITEM
				;WORD 2 IF NON-ZERO IS ADDR OF ROUTINE
				;TO RUN IF DEC RESULTS IN ZERO BYTE
;EMT DISPACTCH TABLES
.MACRO EMTD NAME
.IF NB NAME
M'NAME==FOO
.'NAME==FOO+EMT
	E'NAME
.IFF
	BADEMT
.ENDC
FOO==FOO+1
.ENDM

FOO==0
;REMEMBER THAT USER PROGRAMS DEPEND ON THESE TABLES
;NOT CHANGING ORDER
EMTDIS:
	EMTD NOOP	;NOP CALL
	EMTD FORK
	EMTD POOFF
	EMTD SLEEP
	EMTD SINK
	EMTD FLOAT
	EMTD INVOK
	EMTD QULK
	EMTD QUNLK
	EMTD TTGIV
	EMTD TTGET
	EMTD WRDI
	EMTD WRDO
	EMTD BYTI
	EMTD BYTO
	EMTD BLKI
	EMTD BLKO
	EMTD MAP
	EMTD ALLOC
EMTHGH==FOO
.MACRO CLSTYD X
.'X'CAP==FOO
.=IVKCTB+<2*FOO>
	CAPR'X
.=.+CAPHGH-2
	CCPR'X
.=.+CAPHGH-2
	CPY'X
.=.+CAPHGH-2
	DEL'X
.=.+CAPHGH-2
	GIV'X
.=.+CAPHGH-2
	TAK'X
.IIF P1,CAPHGH==CAPHGH+2
.=IVKCTB+<CAPHGH*6>
FOO==FOO+1
.ENDM
.IIF P1,CAPHGH==0
FOO==0

;REMEMBER THAT USER PROGRAMS DEPEND ON THESE TABLES
;NOT CHANGING ORDER
IVKCTB:
CLSTYD XX	;THE ZERO CAPABILITY SHOULD NOT EXIST
CLSTYD CC	;CREATE CAPABILITY
;NO DATA WORDS
CLSTYD MS	;MASTER SPHERE
;FIRST ITEM IS THE SPHERE
;SECOND IS SPHERE (IF ANY) IN CIRCULAR LIST OF SPHERES HAVING SHPERE
;CAPABILITY TO THIS SPHERE
;FIRST MISC IS FAULT ENTRY ADDRESS
;SECOND MISC IS C-LIST NUMBER (IF ANY) FOR CIRCULAR LIST
;BITS ARE:
.SPFES==400	;SURPRESS ENTERS THROUGH HERE
.SPCLC==1000	;ALLOW COPY FROM C-LIST
.SPCLD==2000	;ALLOW DELETE FROM C-LIST
.SPCRR==4000	;ALLOW CORE READ
.SPCRW==10000	;ALLOW CORE WRITE
.SPCRE==20000	;ALLOW CORE EXECUTE
.SPCAD==40000	;ALLOW C-LIST APPEND
MSPCBT==.SPCAD!.SPCLC!.SPCLD!.SPCRR!.SPCRW!.SPCRE	;ALL SET IN SPHERE
CLSTYD SP	;SPHERE (NON-MASTER I.E. COPY OF MASTER)
;SAME PROPERTIES AS MASTER SPHERE, EXCEPT SOME BITS MAY NOT BE SET
;AND THERE IS NO ENTRY ADDRESS
CLSTYD PR	;PROCESS CAPABILITY
;WORDS ARE ASSIGNED AS IN MASTER SPHERE AND ENTER ADDRESS IS STARTING ADDRESS
;BITS ARE:
.PRWRT==10000	;ALLOW WRITING OF INFORMATION
CLSTYD TT	;TELETYPE CAPABILITY (NO DATA WORDS)
;FLAGS ARE
.TTYO==10000	;ALLOW OUTPUT TO TTY
.TTYI==20000		;ALLOW INPUT FROM TTY

CLSTYD FA	;FILE ACCESS CAPABILITY
FAMFI==2	;FIRST WORD IS MFI PTR
FAFPN==4	;SECOND IS FILE PAGE NUMBER
FAUPT==6	;THIRD IS GIP FOR FUPT
FAFBP==10	;FOURTH IS BYTE PTR IN FILE PAGE (SEE 2ND WORD)
;BITS ARE:
.FARD==400	;FILE READ ACCESS
.FAWT==1000	;FILE WRITE ACCESS
.FAAP==2000	;FILE APPEND ACCESS
.FALB==4000	;LOCKED BIT
.FAEOF==10000	;EOF FLAG
.FAHIF==20000	;HOLE IN FILE FLAG
.FAMFL==40000	;THIS GUY LOCKED THE MFI
.FAFB==100000	;FILE/DIRECTORY BIT


CLSTYD QU	;THE QUE CAPABILITY
		;NO FLAGS
	;DISPATCH TABLES
CCTAB=IVKCTB+CAPHGH	;THE CREATE CAPABILITY TABLE
CPYTAB=CCTAB+CAPHGH	;THE COPY CAPABILIY TABLE
DELTAB=CPYTAB+CAPHGH	;THE DELETE TABLE
GIVTAB=DELTAB+CAPHGH	;THE GIVE AWAY TABLE
TAKTAB=GIVTAB+CAPHGH
	;GENERAL FUNCTIONS FOR INVOKE
.MACRO GENFUN NAME
	NAME'CAP
	FOO==FOO+1
.ENDM

FOO==0
GENDIS:	GENFUN DEL	;DELETE THE CAPABLITY
	GENFUN CPY	;COPY THE CAPABILITY
	GENFUN GIV	;GIVE THE CAPABILIITY AWAY
	GENFUN TAK	;TAKE THE CAPABILITY (GIMMEE,GIMMEE)
GENHGH==FOO*2

;THIS IS THE DISPATCH TABLE FOR I-O DEVICES

.IRP X,<WDI,WDO,BTI,BTO,BKI,BKO>	;INITIALZE TABLES FOR THESE TRANSFER TYPES
X'TAB:	DK'X
	TT'X
		;OTHER IO DEVICES GO HERE
.ENDM
;INITALIZE TABLES
.MACRO ILIST AD,FREE,NUM,LEN
WORDS AD+LEN,FREE,NUM-2,LEN
.ENDM
INITLS:	ILIST ITMTAB,ITMFRE,NITEMS+NITALS+NPFPTS,ITMTEL
	ILIST LCKTAB,LCKFRE,NLCKBL,LCKLEN
	ILIST DSKTAB,DSKFRE,NDSKRQ,DSKLEN
	ILIST FPTTAB,FPTFRE,NFPTS,FPTLEN
	ILIST FUPTTB,FUPTFR,NFUPTS,FUPTLE
	0


;FOR THE ITEM TABLE
.IRPC X,<012>
ITEM'X:		-1		;ITEM CURRENTLY IN PAGE ITM0
ITM'X'A:	ITM'X'AD	;ADDRESS OF ITEM IN ITEM'X
ITM'X'D:	0		;PUSH DEPTH
ITM'X'P:	ITM'X'PD	;PDL POINTER FOR ITM'X
	.BLKW NITMPS		;PDL FOR ITM'X'
ITM'X'PD::
.ENDM
MFHTAB:	.REPT 20
	0
	.ENDR			;MFI HASH TABLE (INIT TO 0)
MFBKCT:	0			;BLOCK COUNT FOR DISCRIPTOR HACKING
MFBKNO:	0			;CURRENT BLOCK FOR DISCRIPTOR HACKING
MFDIST:	0			;CURRENT TYPE FOR DISCRIPTOR HACKING
MFDPTR:	0			;POINTER INTO MFI AT DISCRIPTOR
MFEND:	0			;POINTER PAST END OF DISCRIPTOR
FATAB:	FACFLG			;CLEAR FLAGS
.FACF==0
	FASFLG			;SET FLAGS
.FASF==2
	FASPTR			;SET POINTER
.FASP==4
	FARPTR			;RETURN POINTER
.FARP==6
	DIRDEL			;DELETE ENTRY
.FADL==10
	DIRADD			;ADD ENTRY
.FAAD==12
	DIRMUT			;MUTATE CAPABILITY
.FAMU==14
	MAKBIT		;SET UP BIT TABLE FOR ROOT DIR
.FAMB==16
FAGTFN==16			;GREATEST LEGAL FUNCTION
MFDTAB:	MFG1SK			;DISCRIPTOR HANDELING TABLE
	MFGSOM
	MFSADD
	MFSKAG

FPTFRE: .BLKW 1		;FREE POINTER TO FPTS
FPTTAB: .BLKB FPTLEN*NFPTS
FUPTFR:	.BLKW 1		;FREE POINTER TO FUPTS
FUPTTB:	.BLKB NFUPTS*FUPTLE
PFPTFR:
ITMAFR:
ITMFRE:	.BLKW 1		;PTR TO FREE LIST OF PFPTS, FREE PTR INTO NODES,
			;POINTER TO FREE LIST OF ITEM TABLE
;NOTE THAT THE FIRST BLOCK IS NEVER USED, SO INDEX IS ALWAYS NON-ZERO
PFPTTB:
ITMALS:
ITMTAB:	.BLKB <NITEMS*ITMTEL>+<NITALS*4>+<NPFPTS*PFPTLE>
ITMATB:	.BLKW 200	;ITEM ALLOCATE TABLE (ONE WORD PER SIZE)
			;THESE POINT INTO ITMALS
ITMBAL:	.BLKW 1		;ITEM BLOCK STORAGE ALLOCATE LOCK
INITM1::		;INITIALIZE FOLLOWING AREA TO -1
ITMBNF:	.BLKW NITMBL	;NUMBER OF BLOCKS FREE IN THIS BIG BLOCK
ITMBST:	.BLKW NITMBL	;ADDRESS OF FIRST BLOCK OF THIS BIG BLOCK
ITMBTP:	.BLKW NITMBL	;POINTERS TO BEGGININGS OF BIT TABLES
	.BLKW 1		;THIS IS THE BACKWARDS-SEARCHING FENCE FOR THE 1ST BIT TABLE
ITMBIT:	.BLKW 11*NITMBL	;8 WORD BIT TABLE FOR EACH BIG BLOCK
				;AND A FENCE BETWEEN THE BLOCKS
EINTM1::	;END OF STUFF TO INIT TO -1
;THE LOCKED SWITCH LISTS
.IIF NZ <ITMTEL-4>!<PFPTLE-4>,.ERROR LENGTH CHANGED, CAN'T SHARE
LCKFRE:	.BLKW 1	;THE FREE POINTER
LCKTAB:	.BLKB NLCKBL*LCKLEN	;STORAGE FOR THE LOCKS
	.STITL DISK VARIABLES
;THESE TABLES MUST GO IN DATA SPACE, AND SHOULD BE RELOCATED WHEN
;THIS FILE IS COMBINED WITH SITS
DSK0RQ:	.BLKW 1		;POINTER TO THE FIRST DISK REQUEST
DSKFRE:	.BLKW 1		;POINTER TO THE FREE LIST OF DISK REQUESTS
DSKTAB:	.BLKB NDSKRQ*DSKLEN	;STORAGE FOR THE DISK REQUESTS

DSKRD==2		;DISK FUNCTION FOR READ
DSKWRT==4		;DISK FUNCTION FOR WRITE
DSKWCK==6		;FOR INTERNAL DISK USE ONLY
DSKWCH==10		;DISK FUNCTION FOR WRITE AND THEN WRITE CHECK

NSPDSK==1		;NUMBER OF DISKS THAT WE SWAP ON

;THE FORMAT FOR THE BIT TABLES IS:
;1) THE START OF THE SWAP SPACE IN 512 WORD DISK BLOCKS
;2) THE LENGTH OF THE SWAP SPACE (NUMBER OF VALID BITS IN BIT TABLE)
;3) WHICH LOGICAL DISK THE SPACE IS ON. NOTE THAT THE FASTER
;   DISK SHOULD BE FIRST

;THESE ARE THE POINTERS TO THE LARGE SPACE SWAPPING BIT TABLES
LSPBTP:	.BLKW NSPDSK*2	;TWO SWAP AREAS ON EACH DISK

;THESE ARE THE POINTERS TO THE SMALL SPACE SWAPPING BIT TABLES
SSPBTP:	.BLKW NSPDSK*2

;THIS IS THE STORAGE FOR THE SWAPPING BIT TABLES
BITTAB:	.BLKW 50*NSPDSK	;ARBITRARY CONSTANT,  THE MAXIMUM SIZE OF THE BIT TABLES
			;IT IS VERY IMPORTANT THAT THE UNUSED BITS OF THE LAST WORD
			;OF THESE TABLES BE ALL ONES (SEE SWPAL4)
BITEND==.		;THE END OF THE BIT TABLES
BTRATO:	WORDS 5,2	;THE FIRST NUMBER IS THE NUMBER OF LARGE SWAP AREAS TO ALLOCATE
			;FOR EVERY ONE OF THE SECOND NUMBER(512 WORD BLOCKS)
DK0NXT:	.BLKW 6		;FIRST WORD IS CNT-STATUS REG
			;SECOND IS WORD COUNT
			;THIRD IS MEMORY ADD
			;FOURTH IS DISK ADDRESS
			;FIFTH IS DAE OR -1 IF RK11
			;SIXTH IS EITHER #RFDAE+2 OR #RKDA
CURTRN:	.BLKW 6		;THIS CONTAINS A COPY OF DK0NXT OF THE TRANSFER IN PROGRESS
CURRQ:	.BLKW DSKLEN	;THIS CONTAINS A COPY OF THE REQUEST OF THE TRAN. IN PROGRESS
			;EXCEPT THAT THE FUNCTION IS THE CST OFFSET FOR THE PAGE
RETRYS:	0		;NUMBER OF RETRYS LEFT ON THIS TRANSFER
NRETRY==10.		;NUMBER OF RETRYS TO ALLOW
NRKERS:	0		;NUMBER OF RK11 ERRORS
NRFERS:	0		;NUMBER OF RF11 ERRORS
SWPDON:	0		;THIS IS 0 UNTIL SWAPPING BIT TABLES ARE ALLOCATED
	;FOR THE PROCESS TABLE
;MACRO FOR DEFINING A QUEUE
.MACRO DEFQ NAME
NAME'Q:	.BLKW 2
NAME'QB==1_FOO
	1_FOO
FOO==FOO+1
.ENDM
QLEN==6		;THE LENGTH OF A QUEUE POINTER
QBIT==4		;POSITION OF QUEUE BIT WITHIN THE POINTER
FOO==0		;INITALIZE THE QUEUE NUMBER
FIRSTQ==.
DEFQ RUN	;GUYS WHO CAN BE RUN IMMEDIATELY
DEFQ PAGW	;GUYS WAITING FOR PAGES TO BE SWAPPED IN
DEFQ SWPB	;GUYS WHO ARE SWAP BLOCKED
DEFQ SFLS	;GUYS IN SHORT WAITS
DEFQ LFLS	;GUYS IN LONG WAITS
DEFQ STOP	;GUYS WHO ARE STOPPED
DEFQ USER	;FOR CONFORMITY, USERS ARE KEPT HERE
DEFQ SPHR	;FOR CONFORMITY SPHERES ARE KEPT HERE
NQS==FOO
PFREEQ:	WORDS PRSTAB,0,0	;FREE PROCESS BLOCKS LIST POINTER
FOO==PRSTAB+PRSTEL
FOOBAR==PFREEQ
PRSTAB:	.REPT NPROSS
	FOO
	FOOBAR
FOO==FOO+PRSTEL
FOOBAR==.-4
	.=.+PRSTEL-4
	.ENDR
	WORDS 0,FOOBAR
	.BLKB PRSTEL-2	;THE LAST PROCESS BLOCK MUST GO HERE

;MEMORY TABLES
CST:	.BLKW MNCBLK	;ONE WORD PER BLOCK
MEMIAT:	WORDS 1,0,0,2,0,1,0,3	;INTIAL CORE ALLOCATIONS
FMMALT:	.BLKW 8		;ONE WORD PER PAGE SIZE (FOR FREE PAGES)
UMMALT:	.BLKW 8		;SAME FOR USED PAGES
CPT:	0	;UNUSED WORD
	.BLKB NCPTTE*CPTLEN	;THE ACTUAL CPT ENTRIES
CPTEND::
;SWAP VARIABLES AND TABLES
NUMBLKS:	0
TIMTSS:	0
.INSRT STYI >
	.STITL SWAPPING ROUTINES
;THIS IS THE START OF THE SWAPPING ROUTINES.  THESE TWO ROUTINES WILL DO EVERYTHING
;EXCEPT DECIDE EXACTLY WHICH PAGES SHOULD BE SWAPPED.
;CORALL TAKES A SIZE OF CORE DESIRED (IN 512 WORD BLOCKS) IN REG. A AND RETURNS A
;POINTER TO THE CPT TABLE ENTRY.  IT REMOVES IT FROM THE FREE LIST.
;IT LOCKS A SWITCH WHICH RESTORES IT TO THE FREE LIST IF PCLOSERED
;SWPOUT CAUSES A PAGE POINTED TO BY A GIP TO BE SWAPPED OUT.  SWPIN CAUSES A PAGE
;POINTED TO BY A GIP TO BE SWAPPED IN, AND WAITS FOR THE TRANSFER TO FINISH.
;THE CORALL ROUTINE CALLS SWPPAG WHICH GIVEN A CERTAIN PAGE SIZE, WILL SWAP
;OUT THE BEST PAGE AS DETERMINED BY A YET UNSPECIFIED ALGORITHM.  THIS ROUTINE
;RETURNS A POINTER TO THE CPT TABLE ENTRY.

CORALL:	SAVE <B,C,D>
	CLR C		;THIS CONTAINS THE FIRST FOUND MOVING BLOCK
	MOV #10,B	;THE TOTAL NUMBER OF FREE LISTS
	SUB A,B		;THE NUMBER OF LISTS TO SEARCH
	SAVE A		;FOR THE SWAPPING ROUTINES
	ASL A		;TURN IT INTO A WORD INDEX
	ADD FMMALT,A	;MAKE IT POINT INTO THE FREE BLOCK LISTS
	SAVE A		;TO BE THE FIRST BACK POINTER
	MOV (A)+,D	;GET A FREE BLOCK
	BEQ CORAL2	;NONE HERE
CORAL1:	BIT #CPTMOV,CPTADR+CPT(D)	;IS IT MOVING
	BEQ CORAL3	;NOPE GOBBLE IT
	TST C		;HAVE WE ALREADY FOUND A SUITABLE MOVING BLOCK
	BNE .+4
	MOV D,C		;SAY WE FOUND ONE
	MOV D,A		;SAVE POINTER TO PREVIOUS
	ADD #CPT,A	;MAKE IT ABSOLUTE
	MOV CPT(D),D	;LINK THROUGH TO THE NEXT ONE
	BNE CORAL1	;TRY THE NEXT BLOCK
CORAL2:	MOV (P),A	;UPDATE THE PREVIOUS POINTER
	ADD #2,(P)	;INCREMENT THE POINTER
	MOV (A),D	;GET THE NEXT LIST
	BNE CORAL1	;CHECK IT OUT
	SOB B,CORAL2	;NOTHING HERE CHECK THE NEXT LIST
	MOV C,D		;DID WE FIND A PAGE THAT WAS MOVING?
	BNE CORAL3	;YES WAIT FOR IT TO STOP
	REST <A,A>	;POP OFF THE EXTRA STUFF AND GET THE SIZE
	JSR PC,SWAPPG	;GET A PAGE SWAPPED OUT, RETURN POINTER TO THE CPT ENTRY IN A
	BR CORAL5	;WAIT FOR IT TO STOP MOVING
CORAL3:	MOV CPT(D),(A)	;LINK OUT THE FREE BLOCK
	MOV #LPCLRT,A	;RUN THIS ROUTINE WHEN PCLOSERED
	CLR B		;THERE IS NO ITEM THAT HAS TO BE LOADED
	JSR PC,LOCKSW	;LOCK A SWITCH
	MOV #FREBLK,LCKWD1(A)	;FREE THE BLOCK WHEN PCLOSERED
	SAVE D		;SAVE THE CPT POINTER
	CLR C		;CLEAR FOR THE DIVISION
	DIV #CPTLEN,C	;TURN IT INTO A CPT NUMBER	
	MOVB C,LCKWD2(A)	;TELL IT WHICH BLOCK
	REST <D,C>	;POINTER TO THE NEXT FREE LIST
	SUB #FMMALT+2,C	;GET THE ACTUAL OFFSET INTO THE FREE LISTS FOR THIS SIZE
	MOVB C,LCKWD2+1(A)	;TELL IT WHICH FREE LIST
	MOV D,A		;RETURN POINTER IN A
	ADD #CPT,A	;MAKE IT AN ABSOLUTE POINTER
	TST (P)+	;POP OFF THE EXTRA WORD
CORAL5:	REST <D,C,B>
	BIT #CPTMOV,CPTADR(A)	;IS IT A MOVING PAGE
	BNE .+4		;YES
	RTS PC		;DONE
CORAL4:	JSR PC,LFLUSH	;WAIT A LONG TIME FOR THE DISK
	BIT #CPTMOV,CPTADR(A)	;IS IT STILL MOVING
	BNE CORAL4
	JSR PC,RUNME	;RUN ME!
	RTS PC		;ALL DONE AND PAGE NOT MOVING
;THIS IS A PCLOSER ROUTINE THAT TAKES A BLOCK AND PUTS IT BACK ON THE FREE LIST
;IT EXPECTS A CPT NUMBER OF THE BLOCK IN LCKWD2(B) AND AN OFFSET INTO THE FREE LISTS
;IN LCKWD2+1(B).
FREBLK:	MOV B,A		;JUGGLE POINTER TO LOCK
	MOVB LCKWD2(A),B	;THE CPT NUMBER
	MUL #CPTLEN,B	;TURN IT INTO AN INDEX
	MOVB LCKWD2+1(A),C	;THE OFFSET INTO THE FREE LISTS
	ADD #FMMALT,C	;MAKE IT ABSOLUTE
	MOV (C),CPT(D)	;MAKE THE OLD FREE LIST POINTER THE NEXT POINTER
	MOV D,(C)	;PUT IT BACK ON THE FREE LIST
	RTS PC

;THIS ROUTINE ALLOCATES BLOCKS OF SWAPPING SPACE.  IF B IS ZERO, IT ALLOCATES
;A SMALL BLOCK OF SPACE, ELSE A LARGE BLOCK.  IT RETURNS THE SWAP ADDRESS IN B
SWPAL:	SAVE <A,C,D>
	TST B		;ALLOCATE A LARGE BLOCK
	BNE LSWPAL	;YES
	SAVE #SSPBTP	;POINT TO THE POINTERS TO THE SMALL BIT TABLES
	BR SWPAL1	;ALLOCATE THE SPACE
LSWPAL:	MOV #1,B	;SAY WE ARE LOOKING AT BIG SPACES
	SAVE #LSPBTP
SWPAL1:	REST A
	MOV (A)+,C	;GET POINTER TO BIT TABLE
	BNE SWPAL2	;ANOTHER BIT TABLE
	TST B		;WAS HE ASKING FOR A SMALL SPACE
	BEQ LSWPAL	;YES CHECK THE BIG SPACES
	REST <D,C,A>	;NO SWAP SPACES LEFT
	SEZ
	RTS PC
SWPAL2:	SAVE A		;SAVE POINTER TO BIT TABLES
	TST (C)+	;PASS THE START WORD
	MOV (C)+,D	;GET THE LENGTH
	MOV D,A		;THE LENGTH IN BITS
	BIC #17,D	;CLEAR THE LOW ORDER BITS
	SUB D,A		;CALCULATE THE NUMBER LEFT OVER
	ASH #-4,D	;GET THE NUMBER OF WORDS IN THE TABLE
	TST (C)+	;SKIP THE DISK NO. FOR NOW
SWPAL3:	CMP (C)+,#-1	;ALL THE SWAP SPACES USED?
	BNE SWPAL4	;NOPE
	SOB D,SWPAL3	;GO BACK IF THERE IS MORE
	TST A		;ANY LEFT OVERS
	BEQ SWPAL1	;NOPE
	BR .+4		;THIS TIME THE POINTER IS CORRECT ALREADY
SWPAL4:	TST -(C)	;GET POINTER TO CORRECT WORD
	MOV #100000,D	;BIT TO TEST
	MOV #16.,A	;CHECK ALL THE BITS
SWPAL5:	BIT D,(C)	;IS THIS BLOCK FREE
	BEQ SWPAL6	;YES
	ASR D		;GET THE NEXT BIT
	SOB A,SWPAL5
	BR SWPAL1	;NO GOOD BLOCKS LEFT OVER
SWPAL6:	BIS D,(C)	;TAKE THIS BIT
	MOV (P),D	;POINTER TO THE NEXT BIT TABLE
	MOV -(D),D	;GET THE POINTER TO THE BIT TABLE
	SUB #6,C	;THE NUMBER OF TYPE WORDS AT THE START
	SUB D,C		;GET THE NUMBER OF WORDS TESTED
	ASH #3,C	;GET THE NUMBER OF BITS TESTED
	BIC #17,C	;CLEAR THE EXTRA BITS
	DEC A		;CORRECT THE BIT NO.
	ADD A,C		;THE NUMBER OF THE (BIT) WE SNARFED			
	ASH #4,C	;PUT IT INTO THE OFFSET FIELD
	BIC #17,C
	ADD C,B		;SET THE BOTTOM BIT IF LARGE SPACE
	REST D		;POINTER TO THE CURRENT BIT TABLE + 1
	TST -(D)	;MAKE IT CORRECT
	TST B		;LARGE OR SMALL BIT TABLE
	BNE SWPAL7	;LARGE
	SUB #SSPBTP,D	;GET THE OFFSET INTO THE TABLE
	BR .+6
	;FALLS THROUGH TO NEXT PAGE
	;FALLS IN FROM PREVIOUS PAGE
SWPAL7:	SUB #LSPBTP,D	;THE OFFSET INTO TABLE	
	BIS D,B		;SET IN THE BIT TABLE NUMBER
	REST <D,C,A>
	CLZ
	RTS PC


;THIS ROUTINE DEALLOCATES SWAP SPACE.  IT TAKES THE SWAP ADDRESS OF THE SPACE TO
;FREE IN B.
DSWPAL:	SAVE <A,C>
	BIT #1,B	;IS IT A LARGE BLOCK?
	BEQ DSWPL1	;NO
	MOV #LSPBTP,C	;POINT TO THE LARGE BLOCK BIT TABLES
	BR .+6
DSWPL1:	MOV #SSPBTP,C	;POINT TO THE SMALL BLOCK BIT TABLES
	MOV B,A		;COPY THE SWAP ADDRESS
	BIC #UPTBTM,A	;CLEAR THE BIT TABLE MASK
	ADD A,C		;MAKE C POINT TO THE BIT TABLE POINTER
	MOV (C),C	;POINTER TO THE BIT TABLE
	BNE .+4
	BPT		;THE BITTABLE DOESN'T EXIST
	BIC #UPTBOM,B	;CLEAR ALL BUT THE BIT TABLE MASK
	ASH #-4,B	;GET THE BIT TABLE OFFSET
	CMP B,2(C)	;IS THIS A VALID BIT
	BLE .+4		;YES
	BPT
	ADD #6,C	;MAKE C POINT TO THE FIRST DATA BIT
	MOV B,A		;COPY THE OFFSET
	ASH #-3,A	;GET THE BYTE OFFSET
	ADD A,C		;MAKE C POINT TO THE CORRECT BYTE
	BIC #177770,B	;MAKE B THE OFFSET IN BYTE
	MOV #1,A	;BECOMES BIT TO CLEAR
	ASH B,A		;MAKE A THE SAME BIT THAT WE WANT TO CLEAR
	BICB B,(C)	;CLEAR THE BIT
	REST <C,A>
	RTS PC

;THIS ROUTINE TAKES THE SIZE OF A PAGE IN REG. A, CAUSES AN APPROPRIATE PAGE
;TO BE SWAPPED OUT, REMOVES THE PAGE FROM THE FREE LIST AND LOCKS A SWITCH PUTTING
;IT BACK IF YOU GET PCLOSERED, IT THEN RETURNS THE OFFSET INTO THE CPT OF THE PAGE
SWAPPG:	HALT


;THIS ROUTINE TAKES A GIP IN B AND A CONTAINS THE TRANSFER TYPE
;IT PUTS A DISK REQUEST ON THE DISK REQUEST LIST, HANGING IF NO
;BLOCK AVAILABLE
DSKRQ:	SAVE C
DSKRQ1:	MOV DSKFRE,C	;THE FREE POINTER TO THE DISK REQUEST BLOCKS
	BEQ DSKRQ4	;NONE LEFT
	MOV (C),DSKFRE	;LINK OUT THE FIRST FREE BLOCK
	MOV B,DSKGIP(C)	;PUT THE GIP INTO THE REQUEST BLOCK
	MOV A,DSKWD(C)	;PUT IN THE FUNCTION WORD ALSO
	SAVE <PS,C>	;SAVE THE CURRENT PRIORITY LEVEL
	SPL 5		;STOP THE DISK FROM INTERRUPTING
	MOV #DSK0RQ,C	;ADDRESS OF THE POINTER TO THE FIRST REQUEST
	TST (C)		;IS THIS THE END OF THE LIST
	BEQ DSKRQ3	;YES
DSKRQ2:	MOV (C),C	;GET THE NEXT REQUEST
	TST (C)
	BNE DSKRQ2	;GO LINK THROUGH IT
DSKRQ3:	REST <(C),PS,C>	;LINK ON THE NEW REQUEST AND RESTORE STATUS	
	RTS PC
DSKRQ4:	JSR PC,LFLUSH
	TST DSKFRE	;ANY LEFT
	BEQ DSKRQ1	;NOPE
	JSR PC,RUNME	;RUNME THERE IS A BLOCK WAITING
	BR DSKRQ1	;GO BACK AND TRY AGAIN

;THIS ROUTINE TAKES A GIP IN B AND A FUNCTION IN A, AND WAITS FOR THE TRANSFER
;TO FINISH.  WHEN IT FINISHES,  IT DOES A SPL 5 TO KEEP THE DISK FROM SWAPPING IT.
;IF THE TRANSFER IS DONE, BUT THE DISK STARTS TO MOVE IT AGAIN BEFORE WE GET TO
;IT, THIS ROUTINE WILL REINITIATE THE TRANSFER, AND REPEAT ITSELF.
;IT THEN RETURNS WITH THE OLD PS IN F
DSKWT:	SAVE C
			;HERE YOU CAN SPL 5 ALTHOUGH NOT REALLY NEEDED.
			;AS LONG AS THE INTERUPT ROUTINES
			;LEAVE THINGS IN A CONSISTENT STATE
			;(A DISK REQUEST IS EITHER ON THE FREE LIST OR
			;ON THE DISK REQUEST LIST
	MOV #DSK0RQ,C
	BEQ RQDONE	;THE REQUEST IS DONE
DKWT1:	MOV (C),C	;GET THE NEXT REQUEST BLOCK
	BEQ RQDONE	;NONE LEFT, IT MUST BE DONE
	CMP DSKGIP(C),B	;IS IT THE SAME GIP?
	BNE DKWT1	;NOT OUR TRANSFER
DKWT2:	JSR PC,LFLUSH	;GET RID OF OURSELVES
			;HERE PERHAPS WE SHOULD CALL RUNME ALWAYS
	MOV #DSK0RQ,C
DKWT3:	MOV (C),C
	BEQ DKWT4	;NONE LEFT READY TO GO
	CMP DSKGIP(C),B	;IS IT THE SAME GIP
	BNE DKWT3	;NOPE
	BR DKWT2	;GO FLUSH OURSELVES
DKWT4:	JSR PC,RUNME	;HERE WE HAVE FOUND IT
RQDONE:	SAVE B
	JSR PC,UPTPLD	;B POINTS TO THE UPT
	MOV UPTAR(B),B	;THE AR FOR THE PAGE
	JSR PC,ITM2PO	;POP THE ITEM PUSHED BY UPTPLD
	BIC #UPASMS,B	;CLEAR ALL BUT THE STARTING ADDRESS
	ASH #-3,B	;GET THE STARTING ADDRESS IN 512 WORD BLOCKS*2
	BIC #1,B	;MAKE SURE IT IS ON A WORD BOUNDARY
	MOV CST(B),B	;THE CST ENTRY FOR THIS BLOCK
	BIC #CSTCOM,B	;CLEAR ALL BUT THE CPT OFFSET
	ADD #CPT,B	;MAKE B POINT TO THE CORRECT CPT ENTRY
RQDON1:	BIT #CPTMOV,CPTADR(B)	;IS IT MOVING
	BEQ RQDON3	;NOPE
RQDON2:	JSR PC,SFLUSH	;FLUSH YOURSELF
	BIT #CPTMOV,CPTADR(B)	;IS IT MOVING
	BNE RQDON2	;YES
	JSR PC,RUNME
RQDON3:	MOV PS,F	;SAVE THE PSW
	SPL 5		;STOP THE DISK
	BIT #CPTMOV,CPTADR(B)	;DID IT START MOVING AGAIN
	BEQ RQDON4	;NOPE
	MOV F,PS	;RESET THE PRIORITY LEVEL
	BR RQDON2
RQDON4:	MOV (P),B	;THE GIP
	JSR PC,UPTPLD	;LOAD THE UPT
	BIT #UPTICR,UPTAR(B)	;IS IT IN CORE
	BNE RQINCO	;REQUEST IN CORE
	CMP #DSKRD,A	;WAS IT A REQUEST FOR SWAPIN
	BEQ RQRTRY	;YES, RETRY THE OPERATION
RQDON5:	REST <B,C>		;POP THE STACK
	JSR PC,ITM2PO	;POP THE ITEM PUSHED BY UPTPLD
	RTS PC
RQINCO:	CMP #DSKRD,A	;WAS IT A REQUEST FOR READ
	BEQ RQDON5
RQRTRY:	JSR PC,ITM2PO	;POP THE ITEM PUSHED BY UPTPLD
	REST B		;RESTORE GIP POINTER
	JSR PC,DSKRQ1	;PLACE THE REQUEST
			;NOTE THAT DSKRQ1 RESTORES C FOR US
	JMP DSKWT	;WAIT FOR IT AGAIN
;THIS ROUTINE TAKES A GIP POINTER IN B AND SWAPS IT IN
SWPIN:	SAVE A
	MOV #DSKRD,A	;THE READ FUNCTION
SWPIO:	JSR PC,DSKRQ	;SET IN THE DISK REQUEST
	SAVE F
	JSR PC,DSKWT	;WAIT FOR THE TRANSFER TO FINISH
	MOV F,PS	;RESTORE THE PSW
	REST <F,A>	;RESTORE REGS
	RTS PC

;LIKE SWPIN, BUT CAUSES PAGE TO BE SWAPPED OUT
SWPOT:	;HERE CALL A ROUTINE THAT CAUSES ANYONE WHO IS POINTING TO THAT PAGE TO BE PCLOSERED
	SAVE A
	MOV #DSKWRT,A	;SET UP WRITE
	BR SWPIO	;DO IT

;LIKE SWPIN, BUT LEAVES THE DISK STOPPED
;LEAVES OLD PS IN F
SWPINS:	SAVE A
	MOV #DSKRD,A	;READ FUNCTION
SWPIOS:	JSR PC,DSKRQ	;PUT IN THE REQUEST
	JSR PC,DSKWT	;WAIT FOR THE TRANSFER TO FINISH
	REST A
	RTS PC

;LIKE SWPOT, BUT LEAVES THE DISK STOPPED
SWPOTS:	;CALL THE SAME ROUTINE THAT SWPOT DOES
	SAVE A
	MOV #DSKWRT,A	;SET UP WRITE
	BR SWPIOS	;DO IT

	.STITL ALLOCATION ROUTINES
;THIS ROUTINE ALLOCATES BIT TABLES
;(A) IS THE FIRST FREE SMALL POINTER SLOT, (B) IS THE SAME FOR LARGE SWAP AREAS
;(C) IS THE FIRST FREE WORD IN BIT TABLE STORAGE
;2(P) IS THE LENGTH, 4(P) IS THE START, 6(P) IS THE LOGICAL DISK NO.
BTABLE:	JSR F,ACSAV	;SAVE THE AC'S
	MOV BTRATO,F	;THE RATIO OF LARGE SWAP SPACES/SMALL SWAP SPACES
	ASH #3,F	;MULTIPLY IT BY 8.
	ADD BTRATO+2,F	;ADD THE NUMBER OF SMALL SWAP SPACES
	MOV 20(P),A	;THE START OF THE SWAPPING AREA
	MOV 16(P),E	;THE LENGTH OF THE SWAP AREA
	MOV E,D		;FOR THE DIVIDE
	CLR C		;FOR THE DIVIDE
	DIV F,C		;DETERMINE THE NUMBER OF LARGE AREAS TO LOCATE
	BEQ SMALAL	;NO BIG BLOCKS ALLOCATE 512 WORD ONES
LRGAL:	MOV 4(P),(B)+	;SET UP POINTER TO BITTABLE
	MOV B,2(P)	;UPDATE THE POINTER TO NEXT LARGE BIT TABLE
	MOV -(B),B	;MAKE B POINT TO THE ACTUAL STORAGE
	MOV C,F		;THE LENGTH OF THIS TABLE
	SAVE D
	MUL BTRATO,C	;THE NUMBER OF LARGE SWAP AREAS
	MOV D,C		;DITTO
	MOV 24(P),D	;THE LOGICAL DISK NO.
	ASH #3,C	;GET THE NUMBER OF BLOCKS WE ARE ALLOCATING
	JSR PC,BTALLO	;ALLOCATE THE BIT TABLE
	REST D
	ADD C,A		;UPDATE THE POINTER TO THE START
	BR SMALA1	;ALLOCATE SMALL BIT TABLES
SMALAL:	CLR F		;SAY THERE IS NO CONTRIBUTION FROM THE RATIO
	MOV 4(P),B	;POINTER TO THE FIRST ALLOCATED SPACE
SMALA1:	CLR E		;FOR THE MULTIPLY
	MUL BTRATO+2,F	;THE NUMBER OF SMALL SWAP AREAS
	ADD D,F		;ADD THE REMAINDER TO THE NUMBER TO ALLOCATE
	BEQ BTABRT
	MOV (P),E	;POINTER TO FIRST SMALL SLOT
	MOV B,(E)+	;MAKE THE POINTER POINT TO THE STORAGE
	MOV E,(P)	;UPDATE POINTER TO THE NEXT SMALL BIT TABLE
	MOV 22(P),D	;THE LOGICAL DISK NO.
	JSR PC,BTALLO	;ALLOCATE THE BIT TABLE
BTABRT:	MOV B,4(P)	;UPDATE THE POINTER TO FREE STARAGE
	JSR F,ACRES	;RESTORE THE AC'S
	RTS PC		;RETURN
;THIS ROUTINE TAKES A POINTER TO THE STORAGE IN B, RETURNS POINTER TO FIRST FREE 
;WORD IN STORAGE IN B.  TAKES NUMBER OF BITS TO ALLOCATE IN F, DOESN'T CLOBBER IT
;TAKES START OF THE FIELD IN A, IT ALSO TAKES THE LOGICAL DISK NO. IN D
BTALLO:	SAVE <C,D>
	MOV A,(B)+	;SET IN THE START FIELD
	MOV F,(B)+	;SET IN THE LENGTH
	MOV (P),(B)+	;SET IN THE LOGICAL DISK NO.
	MOV F,E		;THE LENGTH
	ASH #-4,E	;THE NUMBER OF WORDS TO ALLOCATE
	BIT #17,F	;WERE ANY OF THE LOW ORDER BITS SET
	BEQ .+4		;NO, THE COUNT IS CORRECT
	INC E		;CORRECT THE COUNT
	ASL E		;TURN IT INTO A BYTE INDEX
	ADD E,B		;UPDATE POINTER TO END OF BIT TABLE
	ASH #3,E	;TURN THE COUNT INTO NUMBER OF BITS ALLOCATE
	SUB F,E		;GET THE NUMBER OF EXTRA BITS
	BEQ BTALRT	;NONE, RETURN
	MOV #-1,C	;SET ALL THE BITS
	CLR D		;CLEAR THE MASK
	NEG E		;GET THE NEGATIVE OF THE NUMBER OF EXTRA BITS
	ASHC E,C	;SET THE NUMBER OF HIGH ORDER BITS = TO THE NUMBER OF EXTRA BITS
	MOV D,-2(B)	;SET IT INTO THE LAST WORD OF THE BIT TABLE
BTALRT:	CMP B,#BITEND	;ARE WE AT THE END OF THE BIT TABLE
	BLE .+4		;NOPE
	BPT		;PASSED THE END, BARF!!
	REST <D,C>
	RTS PC
	.STITL DISK INTERRUPT ROUTINES
RKBRK:	JSR F,ACSAV	;SAVE THE AC'S
	MOV RKCS,A	;GET THE STATUS REGISTER
	TST A
	BLT .+6		;THERE WAS AN ERROR
	JMP DSKBRK
	INC NRKERS	;SAY THERE WAS ONE MORE ERROR
	BIT #66340,RKER	;A BAD ERROR
	BEQ RKSOFT
RKHARD:	BPT
RKSOFT:	INC RETRYS	;INCREMENT THE RETRYS
	BGE RKHARD
	MOV #1,RKCS	;CONTROL RESET
	BR RETRY
DSKLOS:	INC NRFERS	;INCREMENT THE NUMBER OF ERRORS
	BIT #40000,A	;IS IT FROZEN
	BNE DSKLS1	;YES
	BIT #26000,A	;IS IT WRITE CHECK,NED, OR WRITE LOCKOUT
	BEQ DSKLS2	;NO, MUST BE PARITY
RFHARD:	BPT
DSKLS1:	BIT #2000,RFDAE	;NXM?
	BNE RFHARD	;YES
DSKLS2:	INC RETRYS
	BGE RFHARD	;TRIED TO MANY TIMES
	MOV #400,RFCS	;POWER CLEAR THE DISK
RETRY:	MOV #CURTRN+12,A	;POINTER TO THE CURRENT TRANSFER
	MOV (A),B	;THE POINTER TO THE DISK REGISTER
	MOV -(A),C	;THE POSSIBLE DAE
	BMI .+4		;NOT REAL
	MOV C,-(B)	;SET IN THE DAE
	MOV -(A),-(B)	;SET UP THE TRANSFER AGAIN
	MOV -(A),-(B)
	MOV -(A),-(B)
	MOV -(A),-(B)
	JSR F,ACRES	;RESTORE AC'S
	RTI		;GET OUT

RFBRK:	JSR F,ACSAV
	MOV RFCS,A	;THE STATUS REGISTER
	TST A
	BLT DSKLOS	;THERE WAS AN ERROR

DSKBRK:	MOV #DK0NXT+12,A	;IS THERE A REQUEST PENDING
	TST (A)		;IS THERE A TRANSFER WAITING	
	BEQ DSKBR3	;NO REQUEST CAN'T BE DSKWCK
	MOV DK0NXT,A	;THE FUNCTION
	BIC #177771,A	;CLEAR ALL BUT FUNCTION
	CMP A,#DSKWCK	;IS IT A WRITE CHECK
	BEQ DSKBR4	;YES, DON'T UPDATE CORE STATUS
DSKBR3:	CLR CURRQ
	MOV CURRQ+4,B	;THE CST INDEX OF THE PAGE JUST FINISHED
	BIC #CPTMOV,<CPT+CPTADR>(B)	;CLEAR THE PAGE MOVING BIT
DSKBR4:	MOV #DK0NXT+12,A	;POINTER TO NEXT REQUEST
	MOV (A),B	;POINTER TO DISK REG.
	BNE DSKBR1	;TRANSFER DK0NXT INTO DISK REGISTERS
	JSR PC,DSKGRB	;GRAB A REQUEST OF THE LIST
	MOV #DK0NXT+14,A	;POINTER TO THE REQUEST
	MOV -(A),B	;THE FIRST WORD POINTS TO THE RIGHT DISK REGISTERS
	BEQ DSKBRT	;NOTHING TO DO, JUST RETURN
DSKBR1:	MOV -(A),C	;THE POSSIBLE DAE
	BMI .+4		;THIS TRANFER IS FOR RK
	MOV C,-(B)	;SET IN THE DAE
	MOV -(A),-(B)	;TRANSFER WORD COUNT AND OTHER STUFF
	MOV -(A),-(B)
	MOV -(A),-(B)
	MOV -(A),-(B)
	MOV #-NRETRY,RETRYS	;SET UP COUNT OF NUMBER OF RETRYS
	MOV #CURTRN,B	;SET UP COPY INTO CURENT TRANSFER
	MOV #6,C	;NUMBER OF WORDS TO TRANSFER
	MOV (A)+,(B)+	;COPY THE TRANSFER
	SOB C,.-2	;COPY ALL THE WORDS
	JSR PC,DSKGRB	;PROCESS ANOTHER REQUEST
DSKBRT:	JSR F,ACRES	;RESTORE THE AC'S
	RTI

;THIS ROUTINE TAKES THE FIRST DISK REQUEST OF DSK0RQ AND LOADS UP DK0NXT
;CLOBBERS ALL AC'S
DSKGRB:	MOV DSK0RQ,C	;GET THE FIRST REQUEST
	BNE DSKGR1	;GOT ONE
	CLR DK0NXT+12	;SAY WE MISSED
	RTS PC		;NONE EXIST
DSKGR1:	MOV (C),DSK0RQ	;UPDATE PONTER TO NEXT REQUEST
	MOV DSKFRE,(C)	;SET IT ONTO THE FREE LIST
	MOV C,DSKFRE	
	MOV DSKGIP(C),B	;THE GIP TO THE DATA TO BE TRANSFERED
	JSR PC,UPTPLD	;LOAD THE UPT
	MOV UPTAR(B),B	;THE ADDRESS REGISTER FOR THE PAGE
	BIT #UPTICR,B	;IS IT IN CORE
	BNE DSKGR3	;YES
	CMP #DSKWCK,DSKWD(C)	;IS IT A WRITE CHECK
	BNE DSKG2A	;NOPE
	BIC #17,DK0NXT	;CLEAR THE OLD WRITE FUNCTION
	BIS #DSKWCK,DK0NXT	;SAY THAT THIS IS A WRITE CHECK.	
	JSR PC,ITM2PO	;POP THE ITEM PUSHED BY UPTPLD
	RTS PC
DSKG2A:	CMP #DSKRD,DSKWD(C)	;IS IT A REQUEST FOR A READ
	BEQ DSKGR4	;YES, EVERYTHING IS OKAY
DSKGR2:	JSR PC,ITM2PO	;POP THE ITEM PUSHED BY UPTPLD
	BR DSKGRB	;THIS REQUEST SPURIOUS, GET THE NEXT REQUEST
DSKGR3:	CMP #DSKRD,DSKWD(C)	;IS IT A REQUEST FOR A READ
	BEQ DSKGR2	;YES, IT ALREADY IS, THUS IT IS SPURIOUS
DSKGR4:	MOV #CURRQ,E	;POINT TO CURRENT REQUEST
	TST (E)		;IS THERE A CURRENT REQUEST
	BNE DSKG4A	;YES, FORGET ABOUT IT
	MOV (C)+,(E)+	;COPY THE REQUEST
	MOV (C)+,(E)+
	;FALLS THROUGH TO NEXT PAGE
	;FALLS IN FROM PREVIOUS PAGE
DSKG4A:	MOV B,F		;COPY THE AR
	BIC #UPMLSW,F	;GET THE LENGTH FIELD
	ASH #-3,F	;SHIFT IT INTO NO. OF WORDS
	NEG F		;NEGATE F
	MOV F,DK0NXT+2	;SET IN THE WORD COUNT
	MOV B,F		;COPY IT AGAIN
	BIC #UPMSSW,F	;GET THE START OF SWAP AREA FIELD
	MOV B,E		;COPY IT
	BIC #UPASMS,E	;CLEAR ALL BUT THE START FIELD
	ASH #-4,E	;GET THE START OF THIS PAGE IN 512 WORD BLOCKS
	ADD E,F		;GET THE START OF THE SWAPPING AREA FIELD+THE START OF THIS PAGE
	MOV UPTDR(B),E	;GET THE START OF THIS PAGE
	BIC #UPMSRE,E	;CLEAR EXTRA BITS
	ASH #-8.,E	;GET THE RIGHT NO.
	SUB E,F		;MAKE F THE START OF THE SWAPPING AREA
	MOV F,B		;SAVE FOR INDEXING INTO THE CST
	CLR E		;FOR THE SHIFT
	ASHC #10.,E	;SHIFT TO GET THE RIGHT CORE ADDRESS
	ASH #4,E	;GET THE MEM EX. BITS
	MOV E,DK0NXT	;PUT THEM INTO THE CTL-STATUS
	MOV F,DK0NXT+4	;PUT IN THE CORE ADDRESS
	MOV UPTFPT,F	;THE SWAP ADDRESS POINTER
	BMI DSKFPT	;IS IT AN FPT
	BIT #UPTLSB,F	;IS IT A LARGE AREA
	BNE DSKLSW	;YES
	MOV #SSPBTP,A	;POINT TO THE SMALL SWAP AREAS
	CLR -(P)	;SAY EACH BIT IS ONE BLOCK
	BR DSKSWP
DSKLSW:	MOV #LSPBTP,A	;ACCESS THE LARGE SWAP TABLES
	SAVE #3 	;SAY EACH BIT IS 8 BLOCKS
	BR DSKSWP
DSKFPT:	HALT		;HERE MUNCH THE FPT
DSKSWP:	MOV F,E		;COPY SWAP ADDRESS
	BIC #UPTBTM,E	;CLEAR ALL BUT THE BIT TABLE MASK
	ADD E,A		;MAKE A POINT TO THE CORRECT BIT TABLE POINTER
	MOV F,D		;COPY IT AGAIN
	BIC #UPTBOM,D	;GET THE OFFSET INTO THE BIT TABLE
	ASH #-4,D	;GET IT INTO THE LOW ORDER BITS
	ASH (P)+,D	;SHIFT IT THE CORRECT NUMER OF BITS TO GET START IN 512 BLOCKS
	ADD (A),D	;ADD THE STARTING ADDRESS OF THIS SWAP TRACK
	MOV 4(A),E	;THE LOGICAL DISK NO.
	BEQ DSKRF	;THE RF 11 HAS LOGICAL NO 0
DSKRK:	ASL D		;DOUBLE THE BLOCK NO. (2 SECTORS/BLOCK)
	CLR C		;CLEAR FOR THE DIVIDE
	DIV #12.,C	;A = NO OF TRACKS, B=NO OF SECTORS
	ASH #4,C	;PUT NO OF TRACKS IN RIGHT SPOT
	ADD C,D		;THE DISK ADDRESS
	ASH #13.,E	;GET THE DISK NO.
	BIS E,D		;COMPLETE THE DISK ADDRESS
	MOV D,DK0NXT+6	;THE DISK ADDRESS
	MOV #-1,DK0NXT+10	;TELL IT THAT THERE IS NO DAE
	MOV #RKDA+2,DK0NXT+12	;TELL IT IT IS THE RK
	BR DSKGR5	;FINISH THE JOB
DSKRF:	CLR C		;FOR THE LONG SHIFT
	ASHC #9.,C	;GET THE DISK ADDRESS
	MOV D,DK0NXT+6	;THE DISK ADDESS
	MOV C,DK0NXT+10	;THE DAE
	MOV #RFDAE+2,DK0NXT+12	;TELL IT THAT IT IS THE RF11
	;BRANCHES INTO NEXT PAGE
	;BRANCHES IN FROM PREVIOUS PAGE
DSKGR5:	MOV DSKFRE,D	;GET POINTER TO THE CURRENT REQUEST
	MOV 4(D),C	;THE FUNCTION
	CMP C,#DSKWCH	;IS IT WRITE AND THEN CHECK
	BEQ DSKGR6	;YES
	BIS #1,C	;SET THE GO BIT
	BIS C,DK0NXT	;SET THE FUNCTION INTO THE CTL-STATUS REG.
	BR DSKGR8	;GO CLEAR/SET THE IN CORE BITS
DSKGR6:	TST DK0NXT+10	;IS IT THE RF11
	BMI DSKGR7	;NO
	MOV #DSKWRT+1,C	;MAKE IT JUST A WRITE
	BIS C,DK0NXT	;SET IN THE FUNCTION
	BR DSKGR8
DSKGR7:	MOV (D),DSKFRE	;RESURECT THE DISK REQUEST
	MOV #DSKWCK,4(D)	;SET IN THE WRITE CHECK FUNCTION
	MOV DSK0RQ,(D)	;LINK IN OLD REQUEST LIST
	MOV D,DSK0RQ	;PUT IT BACK ON THE REQUEST LIST
	MOV #DSKWRT+1,C	;MAKE THIS REQUEST A WRITE
	BIS C,DK0NXT
DSKGR8:	ASL B		;THE STARTING ADDRESS OF PAGE INTO WORD INDEX
	MOV CST(B),B	;THE CST ENTRY FOR THIS BLOCK
	BIC #CSTCOM,B	;GET THE CPT OFFSET MASK
	BIS #CPTMOV,<CPT+CPTADR>(B)	;SAY THE PAGE IS MOVING
	MOV B,CURRQ+4	;SAVE THE CPT OFFSET FOR CLEARING WHEN TRAN. IS DONE
	MOV DK0NXT,A	;GET THE FUNCTION
	MOV CURRQ+2,B	;THE GIP
	JSR PC,UPTSET	;SET THE UPTICR BIT TO APPROPRIATE THING
	JSR PC,ITM2PO
	RTS PC
;THIS ROUTINE TAKES GIP IN B, AND TRANSFER TYPE IN A, AND SETS OR CLEARS THE UPT'S
;UPTICR AS APPROPRIATE.  ALSO ASSUMES THAT ITEM2 CAN BE WRITTEN OVER
UPTSET:	BIC #177771,A	;CLEAR THE EXTRA BITS
	MOV #1,F	;SET FLAG
	CMP #DSKWCH,A	;IS IT A WRITE AND THEN CHECK
	BNE .+4		;NOPE
	CLR F		;CLEAR FLAG
	CMP #DSKWRT,A	;IS IT A WRITE
	BNE .+4
	CLR F		;CLEAR FLAG
	SAVE B		;SAVE THE POINTER TO THE FIRST UPT
	JSR PC,UPTLD	;LOAD THE UPT
	TST UPTCLP(B)	;IS IT IN A CIRCULAR LIST
	BNE .+4		;YES
	CLR (P)		;CLEAR THE COMPARISON 
UPTLP:	TST F		;IS IT A WRITE
	BNE UPTLP1	;NO
	BIC #UPTICR,UPTAR(B)	;CLEAR THE IN CORE BIT
	BR .+10
UPTLP1:	BIS #UPTICR,UPTAR(B)	;SET THE IN CORE BIT
	MOV UPTCLP(B),B	;GET THE NEXT POINTER
	CMP (P),B	;DOES IT POINT TO THE ORIGINAL ONE
	BNE UPTLP	;NOPE TRY THE NEXT ONE
	TST (P)+	;POP THE EXTRA WORD
	RTS PC
ACSAV:	SAVE <E,D,C,B,A>
	JMP (F)

ACRES:	TST (P)+
	REST <A,B,C,D,E>
	RTS F

	.SBTTL ITEM TABLE ROUTINES
.IIF NZ ITMADR!ITLINK,.ERROR NO, IT WON'T WORK WITH ITLINK OR ITADDR NON-ZERO
;CREATE AN ITEM OF SPECIFIED SIZE
;THE SIZE IS PUT INTO A; THE ITEM'S INDEX RETURNS IN B
;THE Z BIT IS SET IF THE ITEM CANNOT BE CREATED; OTHERWISE, IT IS CLEARED
;THIS MAKES NO ATTEMPT TO COMPRESS EXISTING ITEMS TO PRODUCE CONTIGOUS FREE SAPCE
;THAT FEATURE IS OF SOMEWHAT QUESTIONALBE VALUE, BUT MIGHT BE ADDED LATER
CRITEM:	MOV ITMFRE,B	;ATTEMPT TO GET A FREE ITEM
	BEQ CRITM1	;NO MORE AVAILABLE, GO LOSE
	SAVE <C,D>
CRITM8:	TSTB ITACCS(B)	;IS THIS ITEM TABLE ENTRY REALLY FREE?
	BEQ .+4
	BPT		;OOPS!!
	MOV A,C		;GET THE LENGTH
	ASL C		;CONVERT IT TO AN INDEX
	ADD #ITMATB,C	;INTO THE ALLOCATE TABLE
	CLR D		;FOR THE LEFTOVER COUNT
CRITM3:	TST (C)+	;IS THERE A FREE ITEM BLOCK OF THIS SIZE?
	BNE CRITM2	;YES, GO USE IT
	TST (D)+	;ONE MORE TO FREE WHEN WE FINALLY FIND
			;A BLOCK BIGGER THAN WHAT WE REALLY WANTED
	CMP #ITMATB+400,C	;ARE WE ALREADY OFF THE TOP?
	BNE CRITM3	;NOPE, NOT YET
;IF WE GET HERE WE HAVE TO ALLOCATE A NEW BIG BLOCK
	TST ITMBAL	;IS SOMEONE ELSE ALREADY ALLOCATING?
	BEQ CRIT11	;NO, GO LOCK THE SWTICH
CRIT13:	JSR PC,SFLUSH	;WAIT FOR THE OTHER GUY TO BE DONE
	TST ITMBAL	;DONE YET?
	BNE CRIT13	;NOPE
	JSR PC,RUNME	;DONE, NOW  SEE IF HE LEFT ENGOUGH FOR US
CRIT16:	MOV ITMFRE,B	;HAVE TO GET ANOTHER ITEM
	BEQ CRIT12	;MAYBE OTHER PEOPLE TOOK THEM ALL
	BR CRITM8	;NOPE
CRIT11:	SAVE A		;LOCK SWTCH SO NO ONE ELSE GETS TO THIS CODE
	MOV #ITMBAL,A
	MOV #-1,B	;USE ALL THE BITS
	CLR C		;THE SWITCH IS INOT IN AN ITEM
	JSR PC,LCKASW	;IN CASE WE HANG WAITING FOR A BLOCK
	MOV #NITMBL,B	;FIND A FREE ITEM BLOCK SLOT
	MOV #ITMBST,C
CRIT10:	TST (C)+	;NEGATIVE INDICATES FREE
	BLT CRITM9	;FOUND ONE!
	SOB B,CRIT10	;KEEP TRYING
	JSR PC,LSWPOP	;LOSE, NO SPACE TO PUT ANOTHER BLOCK
	REST A
CRIT12:	REST <D,C>
CRITM1:	SEZ		;INDICATE FAILURE
	RTS PC
;NO, THIS ISN'T THE END OF THE ROUTINE!
CRITM2:	MOV (B),ITMFRE	;NOW THE ITEM POINTED TO BY THIS ONE IS
			;THE BEGINNING OF THE FREE LIST
	MOVB A,ITLNGT(B)	;SET IN THE LENGTH
	MOVB #ITACCD,ITACCS(B)	;AND THE ACCESS CODE
	SAVE <E,F>
	MOV -(C),E	;GET A POINTER TO THE NODE FOR THE FREE BLOCK
	MOV (E),(C)	;SPLICE OUT THIS NODE
	MOV 2(E),F	;ADDRESS OF THE BLOCK
	MOV F,(B)	;PUT IT AWAY IN THE ITEM
	MOV F,C		;COPY IT
	BIC #170000,F	;GET THE ADDRESS PART
	SAVE F		;AND SAVE IT FOR LATER
	TST D		;IS THERE ANY LEFTOVER?
	BEQ CRITM4	;NO, JUST GO FREE THE NODE
	TST -(D)	;CORRECT D, IT'S OVERENTHUSIASTIC
	MOV ITMATB(D),(E)	;PUT THE NODE INTO THE LIST FOR THE LEFTOVER SIZE
	MOV E,ITMATB(D)		;THERE!
	ADD A,2(E)	;ADD THE AMOUNT USED TO THE ADDRESS
	INC 2(E)	;SINCE ZERO IS ONE(?)
	BR CRITM5	;NOW GO USE WHAT WE GOT
CRITM4:	MOV ITMAFR,(E)	;LINK IT BACK TO THE FREE LIST
	MOV E,ITMAFR
CRITM5:	JSR PC,BITSET	;GRAB THE BLOCKS WE WANT
	TST (P)+	;FLUSH THE ADDRESS FROM THE STACK
	SUB #ITMTAB,B
	REST <F,E,D,C>
	CLZ
	RTS PC
CRITM9:	MOV #FMMALT+6,A	;START BY LOOKING FROM 2K UPWARDS
	MOV #5,B	;2K, 2.5K, 3K, 3.5K 4K
CRIT17:	MOV (A),D	;ANYONE HOME?
	BEQ .+6		;NOPE, NOT THIS SIZE
	JSR PC,CRIT22	;GO SEE IF WE CAN GOBBLE IT
	TST (A)+	;NEXT!
	SOB B,CRIT17	;FOR THE 5 DIFFERNET SIZES
	MOV #10,B	;OK, I'LL TAKE ANY SIZE
CRIT18:	MOV -(A),D	;ANY?
	BEQ .+6		;NOPE
	JSR PC,CRIT22	;CAN I HAVE SOME?
	SOB B,CRIT18
	MOV #3,A	;HERE, SWAP SOMETHING OUT!
	JSR PC,SWAPO
	BR CRITM9

CRIT19:	SAVE A
CRIT20:	BIT #CPTMOV,CPTADR+CPT(D)	;IS IT MOVING?
	BEQ CRIT21	;NO, TAKE IT AWAY
	MOV D,A		;SAVE POINTER TO PREVIOUS
	ADD #CPT,A	;ALWAYS A CORE ADDR
	MOV CPT(D),D	;LINK THROUGH
	BNE CRIT20	;TRY NEXT ONE
	REST A		;NO MORE GIVE UP
	SEZ		;PAGE ALLOCATE HAS TO KNOW IT LOST
	RTS PC
CRIT21:	MOV CPT(D),(A)	;TAKE OFF THE FREE LIST
	REST A
	SUB #FMMALT,A	;MAKE IT RELATIVE
	MOV UMMALT(A),CPT(D)	;POINT IT TO A USED LIST
	MOV D,UMMALT(A)		;CLOBBER THE USED POINTER
	CLZ
	RTS PC		;YES, DONE
CRIT22:	JSR PC,CRIT19
	BNE .+4
	RTS PC
	MOV CPT+CPTADR(D),B	;THE ADDRESS OF THING WE GOBBLED
	ASH #4,B	;CONVERT TO AN AR-STYLE
	BIC #170017,B
	ASR A
	SUB A,NUMBLKS
	ASH #4,A	;THE LENGTH
	BIS #17,A	;CONVERT TO DR-STYLE
	TST (P)+		;FLUSH RETURN ADDRESS
	JSR PC,LSWPOP
;DONE ALLOCATING CORE
;FALL THROUGH TO NEXT PAGE
;FALLS IN FROM PREVIOUS PAGE
	MOV B,-(C)	;B GETS THE ADDRESS
	SUB #ITMBST,C	;UN-RELATIVE IT
	MOV A,ITMBNF(C)	;A GETS THE NUMBER OF BLOCKS GOBBLED
	MOV ITMAFR,D	;GET AN ALLOCATE NODE
	BNE .+4		;THERE SHOULD ALWAYS BE ONE AVAILABLE
	BPT
	MOV (D),ITMAFR	;SPLICE IT OUT OF THE FREE LIST
	SAVE C		;SAVE FOR LATER
	ASH #11.,C	;PUT IT INTO THE HIGH FOUR BITS
	ADD B,C		;COMBINE THE BLOCK ADDRESS AND THE BIG BLOCK NUMBER
	MOV C,2(D)	;AND SAVE IT IN THE NODE
	ASL A		;CONVERT SIZE OF BLOCK TO WORD OFFSET
	MOV ITMATB(A),(D)	;SPLICE THIS NODE
	MOV D,ITMATB(A)	;INTO LIST FOR THIS SIZE
	ASR A		;RESTORE A
	REST C		;GET THE INDEX INTO THE BLOCK VARIABLES
	MOV ITMBTP(C),C	;ADDRESS OF THE BIT TABLE FOR THIS BLOCK
	MOV C,D		;COPY POINTER TO BIT TABLE
	MOV #8.,B	;THERE ARE 8 WORDS
CRIT14:	MOV #-1,(C)+	;FIRST, SET ALL BLOCKS AS USED
	SOB B,CRIT14	;DO 8 TIMES
	INC A		;0 IS ONE BLOCK!
	ASH #-4,A	;COVERT TO 512 WORD BLOCKS
CRIT15:	CLR (D)+	;THERE WILL ALWAYS BE AT LEAST ONE
	SOB A,CRIT15	;DO UP TO 8 TIMES
	REST A
	JMP CRIT16	;NOW GO TRY THE WHOLE THING AGAIN!
;THIS ISN'T THE END EITHER
;DELETE THE ITEM WHOSE ITEM NUMBER IS IN A
;A GETS CLOBBERED
;THIS MAKES NO ATTEMPT TO RETURN AN EMPTY BIG BLOCK
;THAT FEATURE SHOULD BE ADDED AS SOON AS POSSIBLE (PROBABLY)
DLITEM:	SAVE <B,C,D,E,F>
	CLR -(P)	;SAVE A STACK WORD FOR TEMP
	ADD #ITMTAB,A	;RELOCATE INDEX TO BE ACTUAL ADDRESS
	TSTB ITACCS(A)	;IS THIS ITEM FOR REAL?
	BNE .+4
	BPT		;OOPS!
	MOV (A),E	;GET THE ADDRESS AND BLOCK # OF THE ITEM
	MOVB ITLNGT(A),(P)	;SAVE THE LENGTH ON THE STACK
	MOV ITMFRE,(A)	;PUT THE NEWLY-FREED NODE ON THE HEAD OF THE
	CLRB ITACCS(A)	;MARK IT AS FREE
	MOV A,ITMFRE	;FREE LIST. IT WON'T BE FREE LONG!
	INC (P)		;CORRECT FOR OFFSET
	MOV (P),F
	MOV E,A
	JSR PC,BITCLR	;CLEAR THE BITS OF THE BLOCK WE ARE FREEING
	MOV #-1,C	;NOW SEE IF THE SPACE BEFORE THE BLOCK IS FREE
	DEC E		;LOOK BEFORE THE BLOCK
	JSR PC,CNTFRE	;GO SEE IF THERE'S ANYTHING WE CAN FREE
	MOV E,F		;SAVE THE REAL BEGGING ADDRESS
	ADD (P),E	;GO TO THE END OF THE SO-FAR FREE BLOCK
	MOV #1,C	;NOW SEARCH FORWARD
	JSR PC,CNTFRE	;GO SEE IF ANYTHING THERE AND FREE WHATEVER YOU FIND
	MOV F,C		;GET THE REAL BEGGINING OF THE BLOCK
	JSR PC,BLKFRE	;FREE THE BLOCK WE HAVE FOUND
	TST (P)+	;FLUSH THE COUNT FROM THE STACK
	REST <F,E,D,C,B>
	RTS PC
;EXPAND OR CONTRACT ITEM WHOSE INDEX IS IN B
;TO THE SIZE IN A
;CLEAR Z IF SUCCESSFUL, OTHERWISE SET Z
EXITEM:	SAVE <F,E,D,C,B,A>
EXITM4:	TSTB ITACCS+ITMTAB(B)	;IS THIS ITEM FOR REAL?
	BNE .+4
	BPT		;OOOPS!
	CMPB A,ITLNGT+ITMTAB(B)	;WHAT IS THE RELATION OF THE DESIRED LENGTH
				;TO THE CURRENT LENGHT?
	BGT EXITM2	;NEED TO ADD MORE TO THE ITEM
	BEQ EXITM1	;THE ITEM IS ALREADY THE DESIRED LENGTH
			;GET HERE TO REMOVE EXTRA STUFF FROM ITEM
	MOVB ITLNGT+ITMTAB(B),F	;GET THE CURRENT LENGTH
	SUB A,F		;DIFFERENCE BETWEEN CURRENT AND DESIRED
	SAVE F		;SAVE THE NUMBER OF BLOCKS TO BE FREED
	MOV ITMADR+ITMTAB(B),E	;ADDRESS OF THE ITEM
	MOVB A,ITLNGT+ITMTAB(B)	;SET THE NEW LENGTH INTO THE ITEM
	ADD A,E		;GET TO THE END OF THE DESIRED PART
	INC E		;CORRECT IT
	MOV E,A		;MAKE THE ROUTINE HAPPY
	JSR PC,BITCLR	;CLEAR THE NEWLY FREED AREA
	MOV E,F		;SAVE THE ADDRESS OF THE BLOCK WE ARE ABOUT TO FREE
	ADD (P),E	;END OF AREA WE KNOW TO BE FREE
	MOV #1,C	;SEARCH FORWARD
	JSR PC,CNTFRE	;LOOK FOR FREE BLOCKS AND FREE THOSE YOU FIND
	MOV F,C		;PUT ADDRESS OF BLOCK INTO THE RIGHT PLACE
	JSR PC,BLKFRE	;PUT FREE BLOCKS ON FREE LIST
	TST (P)+	;GET RID OF COUNT ON PDL
EXITM1:	REST <A,B,C,D,E,F>
	CLZ
	RTS PC
;CONTINUED NEXT WEEK (ACTUALLY, NEXT PAGE)
;GET HERE IF MORE SPACE NEEDED FOR ITEM
EXITM2:	MOV ITMADR+ITMTAB(B),E	;ADDRESS OF START OF ITEM
	MOVB ITLNGT+ITMTAB(B),A	;GET CURRENT SIZE
	ADD A,E		;TO GET END OF CURRENT BLOCK
	INC E		;CORRECT IT
	MOV E,D		;NOW FIND WHICH BLOCK
	ASH #-11.,D
	BIC #177741,D	;WORD INDEX
	MOV #1,C	;NOW SEARCH FORWARD FOR FREE BLOCKS
	JSR PC,CNTBLK
	BLT EXITM3	;FORGET THIS IF THERE AREN'T ANY
	MOV (P),C	;GET THE DESIRED COUNT
	INC A		;CORRECT THE AMOUNT FOUND
	SUB A,C		;C=AMOUNT NEEDED-EXTRA FOUND
	MOVB ITLNGT+ITMTAB(B),F	;THE AMOUNT WE ALREADY HAVE
	CMP C,F		;WILL THE TOTAL BE ENOUGH?
	BGT EXITM3	;NO, FORGET IT
	ADD A,F		;YES, WHAT IS THAT TOTAL?
	MOVB F,ITLNGT+ITMTAB(B)	;THAT IS THE NEW ITEM LENGTH
	MOV A,F		;SAVE THE NUMBER OF BLOCKS WE ARE STEALING
	DEC A		;UNCORRECT IT
	JSR PC,FINDEL	;DELETE IT FROM THE FREE LIST
	MOV F,A		;GET THE COUNT BACK
	MOV E,C		;MAKE THE ROUTINE HAPPY
	SAVE E		;HAPPY!!??
	JSR PC,BITSET	;INDICATE THOSE BLOCKS IN USE
	TST (P)+	;GET RID OF THE GARBAGE
	MOV (P),A	;NOW, HOW MUCH DID WE REALLY WANT?
	MOV 2(P),B	;FOR WHAT ITEM?
	BR EXITM4	;GO FLUSH ANY EXTRA WE TOOK
;GET HERE IF THE BLOCK CAN'T BE EXPANDED NICELY
EXITM3:	MOV (P),A	;GET THE DESIRED SIZE
	JSR PC,CRITEM	;GET AN ITEM OF THE RIGHT SIZE
	BNE EXITM6	;GOT IT, GO USE IT
	REST <A,B,C,D,E,F>	;LOSE, RESTORE AC'S AND GET OUT
	SEZ
	RTS PC
;TO BE CONTINUED (NEXT PAGE)
EXITM6:	MOV B,A		;LOAD THE NEW ITEM INTO THE MAP
	JSR PC,ITM0PL	;PUSH AND LOAD
	MOV A,C		;SAVE THE ADDRESS IT WAS LOADED AT
	MOV 2(P),D	;THE ITEM WE WANT TO EXPAND (COPY)
	MOV D,A		;LOAD IT INTO THE MAP TOO
	JSR PC,ITM1PL	;PUSH AND LOAD
	MOVB ITLNGT+ITMTAB(D),F	;GET THE LENGTH OF THE OLD THING
	INC F		;CORRECT IT
	ASH #5,F	;CONVERT TO WORDS
	MOV (A)+,(C)+	;COPY THE BLOCK
	SOB F,.-2
	JSR PC,ITM0PO	;POP ITEM0
	JSR PC,ITM1PO	;POP ITEM1
	MOV B,A		;SAVE THE NEW ITEM INDEX
	ADD #ITMTAB,D	;MAKE AN ACTUAL ADDRESS
	ADD #ITMTAB,B
	MOV #ITMTEL/2,F	;NUMBER OF WORDS TO EXCAHNGE
EXITM5:	MOV (B),E
	MOV (D),(B)+
	MOV E,(D)+
	SOB F,EXITM5	;EXCAHNGE OLD AND NEW ITEMS
	JSR PC,DLITEM	;DELETE THE NEW ITEM SLOT WITH THE OLD ITEM CONTENTS!!
	BR EXITM1	;RETURN SUCESSFULLY, IF SOMEWHAT WEARILY


;CLEAR ITEM WHOSE INDEX IS IN B
;IT'S LENGTH IS IN A. IT IS ALSO LOADED INTO ITEM0
;AND ITEM0'S PDL IS PUSHED. A IS CLOBBERED TO THE ADDRESS OF THE ITEM
CLITEM:	SAVE C		;FOR THE WORD COUNT
	MOV A,C		;THE BLOCK COUNT
	INC C		;CORRECTED
	ASH #5,C	;CONVERT TO WORDS
	MOV B,A		;THE ITEM TO CLEAR
	JSR PC,ITM0PL	;GETS LOADED
	ADD C,A		;POINT A TO THE END OF THE ITEM
	ADD C,A		;SINCE C IS A WORD COUNT
	CLR -(A)	;CLEAR TE ITEM, CORRECTING A
	SOB C,.-2	;CLEAR ALL THE WORDS
	REST C
	RTS PC
;SET THE BITS IN THE ITEM BLOCK BIT TABLE
;THE STARTING ADDRESS IS EXPECTED IN C AND 2(P)
;THE COUNT OF BLOCKS (UNCORRECTED) IS EXPECTED IN A (IT SHOULD NOT BE -1)
;CLOBBERS C,D,E AND F
BITSET:	ASH #-11.,C	;GET THE BIG BLOCK NUMBER
	BIC #177741,C
	DEC ITMBNF(C)	;CORRECT FOR 0=1
	SUB A,ITMBNF(C)	;THAT MANY FEWER BLOCKS AVAILABLE
	MOV 2(P),E	;GET THE ADDRESS BACK
	MOV A,D		;AND A COUNT WE CAN MUNGE
	SUB ITMBST(C),E	;CONVERT TO BLOCK WITHIN BIG BLOCK
	ASHC #-3.,E	;FIGURE IT OUT YOURSELF
	ASH #-13.,F
	BIC #177770,F
	ADD ITMBTP(C),E	;MAKE IT POINT INTO THE BIT TABLE
	INC D		;SINCE 0=1
BITST1:	BISB BMT(F),(E)	;SET THE BIT
	INC F		;CHANGE THE BIT NUMBER
	BIT #7,F	;HAVE WE JUMPED A BYTE?
	BNE BITST2	;NOT YET
	CLR F		;NEW BIT NUMBER
	INC E		;AND NEW BYTE NUMBER
BITST2:	SOB D,BITST1	;DO FOR HOWEVER MANY LITTLE BLOCKS
	RTS PC
;CLEAR BITS IN THE BIT TABLE FOR THE ITEM BLOCK
;EXPECTS THE STARTING ADDRESS IN A AND THE COUNT (CORRECTED) IN F
;CLOBBERS A,B,D AND F
BITCLR:	MOV A,D		;COPY IT
	ASH #-11.,D	;TO GET THE BLOCK #
	BIC #177741,D	;CLEAR BITS THAT MAY BE SET BY ASH
	BIC #170000,A	;GET RID OF THE BLOCK NUMBER
	SUB ITMBST(D),A	;AND MAKE RELATIVE TO START OF BLOCK
	ASHC #-3,A	;KNOCK THE BIT ADDRESS OFF THE END
	ASH #-13.,B	;AND PUT IT IN IT'S PLACE
	BIC #177770,B	;OH FOR A LSH!
	ADD ITMBTP(D),A	;ADDRESS IN THE BIT TABLE
	ADD F,ITMBNF(D)	;MORE FREE SPACE!
;THIS IS WHERE THE RETURN BIG BLOCK STUFF SHOULD GO
BITCL1:	BICB BMT(B),(A)	;THIS BLOCK NOW FREE
	INC B		;GO TO NEXT BIT ADDRESS
	BIT #7,B	;TO NEXT BYTE?
	BNE BITCL2	;NOT YET
	CLR B		;ZEROTH BIT
	INC A		;IN THE NEXT BYTE
BITCL2:	SOB F,BITCL1	;CLEAR UNTIL DEAD
	RTS PC
;PUT AN ENTRY ON THE APPROPRIATE FREE LIST FOR THE BLOCK WE HAVE FREED
;EXPECTS THE COUNT (CORRECTED) ON 2(P), THE ADDESS OF THE BLOCK IN C
;CLOBBERS A AND B
BLKFRE:	MOV 2(P),A	;AND IT'S LENGTH
	DEC A		;SIGH
	ASL A		;CONVERT THE LENGTH INTO A WORD INDEX
	ADD #ITMATB,A	;NOW, THE ADDRESS IN THE ALLOCATE TABLE
	MOV ITMAFR,B	;GET THE FIRST FREE ALLOCATE NODE
	BNE .+4		;WE SHOULD NEVER RUN OUT OF THESE!
	BPT
	MOV (B),ITMAFR	;SPLICE IT OUT
	MOV (A),(B)	;SPLICE INTO THE LIST FOR THIS SIZE BLOCK
	MOV B,(A)	;AND FIX THE POINTER TO THE LIST
	MOV C,2(B)	;FINALLY, THE LOCATION OF THE NEWLY FREED BLOCK
	RTS PC


;THIS ROUTINE IS SPECIAL FOR DLITEM
;IT FINDS FREE SPACE A TACKS IT ON TO EXISTING FREE SPACE
;NOTE THAT THE WORD AT 2(P) IS EXPECTED TO CONTAIN THE COUNT
;OF BLOCKS THAT HAVE BEEN FOUND TO BE FREE
;CLOBBERS A AND B ADDS THE NUMBER OF BLOCKS IT FINDS TO 2(P)
CNTFRE:	JSR PC,CNTBLK	;AND IF SO, HOW MUCH?
	BLT CNTFR1	;NONE FREE THERE!
	ADD A,2(P)	;SOME THERE, ADD TO PREVIOUS AMOUNT
	INC 2(P)	;SIGH
FINDEL:	JSR PC,FINBLK	;FIND THE BLOCK THAT IS FREE
DELBLK:	MOV (A),(B)	;SPLICE THE NODE OUT OF THE LIST
	MOV ITMAFR,(A)	;AND PUT THE FREED NODE ON THE FREE LIST
	MOV A,ITMAFR	;NEW START OF FREE LIST
CNTFR1:	RTS PC
;FIND A BLOCK OF A PARTICULAR SIZE THAT BEGINS AT A CERTAIN LOCATION
;SIZE IN A
;LOCATION IN E
;POINTER TO NODE IS RETURNED IN A
;POINTER TO PREVIOUS NODE IS RETURNED IN B
;(IT IS A BUG FOR THERE TO BE NO SUCH BLOCK!!!)
FINBLK:	ASL A		;CONVERT THIS INTO A POINTER
	ADD #ITMATB,A	;INTO THE ALLOCATE VECTOR
FINBL1:	MOV A,B		;THE OLD ONE
	MOV (A),A	;THE ONE IT POINTS TO
	BNE .+4		;MUST BE THERE!!
	BPT
	CMP 2(A),E	;IS THIS THE ONE?
	BNE FINBL1		;NOPE
	RTS PC		;YES, WE'RE ALL SET
;FIND HOW MANY BLOCKS ARE FREE STARTING AT A GIVEN BLOCK AND
;LOOKING IN A GIVEN DIRETION
;E CONTAINS THE ABSOULUTE BLOCK NUMBER
;D CONTIANS THE INDEX OF THE BLOCK IT IS IN
;C CONTAINS THE DIRECTION (1=> FORWARD, -1=> BACKWARDS)
;A GETS -1 OR THE LENGTH OF WHAT'S FOUND
;CONDITON CODES ARE SET BY TST A, I.E. N IS CLEAR IF ANYTHING FOUND
;E GETS THE ADDRESS OF THE FIRST BLOCK IN THE CHUNK
CNTBLK:	SAVE <F,B,E>
	MOV #-1,A	;THE INTIAL COUNT
	BIC #170000,E	;GET RID OF BLOCK #
	SUB ITMBST(D),E	;MAKE IT RELATIVE TO START OF BLOCK
	BLT CNTBL2	;NO BLOCKS BEFORE BLOCK!
	ASHC #-4,E	;GET THE BIT NUMBER
	ASH #-12.,F	;AND THE WORD NUMBER
	BIC #177760,F	;MAKE SURE THE BIT NUMBER IS RIGHT
	ASL E		;MAKE A WORD ADDRESS
	MOV #1,B	;THE FIRST BIT
	ASH F,B		;SHIFT BY THE BIT NUMBER
	ADD ITMBTP(D),E	;THE REAL BIT TABLE ADDRESS
CNTBL1:	BIT B,(E)	;IS THIS ONE FREE?
	BNE CNTBL2	;THEN WE'RE DONE
	INC A		;ANOTHER ONE FREE
	ASH C,B		;SHIFT ONE WAY OR THE OTHER
	BNE CNTBL1	;NOT DONE WITH WORD YET
	ADD C,E		;ADJUST ADDRESS
	ADD C,E		;IT IS A WORD ADDRESS
	MOV #1,B	;RESET THE BIT
	TST C		;UNLESS WE ARE LOOKING BACKWARDS
	BGT CNTBL1	;NOPE, FORWARDS
	MOV #100000,B	;OOPS, BACKWARDS
	BR CNTBL1
CNTBL2:	REST E
	TST C		;THIS IS OK FOR FORWARDS SEARCH
	BGT CNTBL3
	SUB A,E		;BUT MUST BE CORRECTED FOR BACKWARD
CNTBL3:	REST <B,F>
	TST A		;TO SET THE CONDITION CODES
	RTS PC

;ROUTINES TO LOAD ITEMS INTO THE MAP AND TO PUSH AND POP THE ITEM STACKS

.IRPC X,<012>	;CONSTRUCT ROUTINES FOR EACH OF THE ITEM PAGES
;PUSH THE CURRENT ITEM FOR THIS PAGE ON THE STACK
;AND LOAD THE ITEM WHOSE INDEX IS IN A
ITM'X'PL:	SUB #2,ITM'X'P		;DECREMENT THE STACK POINTER
	MOV ITEM'X,@ITM'X'P		;STORE CURRENT ITEM ON STACK
	INC ITM'X'D			;INDICATE PUSHED ONE MORE LEVEL
;FALL INTO THE LOAD ITEM ROUTINE

;LOAD ITEM WHOSE INDEX IS IN A INTO AN ITEM PAGE
;RETURN THE ADDRESS THAT THE ITEM WAS LOADED INTO IN A
ITM'X'LD:	MOV A,ITEM'X		;THIS IS NOW THE CURRENT ITEM
	BLT ITM'X'L1			;NOT REALLY AN ITEM
	MOV ITMTAB(A),ITM'X'AR		;SET THE AR
	MOV ITMTAB+ITACCS(A),ITM'X'DR	;AND THE DR
ITM'X'L2:	MOV #ITM'X'AD,A		;AND THE ADDRESS
	RTS PC
ITM'X'L1:	CLR ITM'X'DR		;MAKE THE ITEM NXM
	BR ITM'X'L2			;GO FINISH

;POP THE TOP ITEM OFF THE STACK
ITM'X'PO:	SAVE A	;DON'T CLOBBER A
	DEC ITM'X'D	;INDICATE POPED ONE LEVEL
	BGE .+4		;DID WE OVER POP?
	BPT		;FOO!
	MOV @ITM'X'P,A	;GET THE OLD THING
	ADD #2,ITM'X'P	;FLUSH ITFROM THE PDL
	JSR PC,ITM'X'LD	;LOAD THE OLD ITEM
	REST A
	RTS PC
.ENDM
	.SBTTL PROCESS HACKING ROUTINES
;CREATE PROCESS AND PUT IT ON THE STOPPED QUQUE
;RETURN ITEM NUMBER IN A AND CLEAR Z IF SUCESSFUL
;OTHERWISE SEET Z
;RETURN ADDRESS OF PROCESS TABLE ENTRY IN B
CRPROC:	MOV #PRSLNF,A	;SIZE OF A PROCESS WITHOUT THE FLOATING POINT
	JSR PC,CRITEM	;GET AN ITEM FOR IT
	BEQ CRPRO1	;NO ITEM, TOUGH LUCK
	JSR PC,CLITEM	;CLEAR IT AND PUT IT IN ITEM0
	MOV #ITPROC,(A)	;SET THE TYPE
	BIS #PSUPSB,PSTOP(A)	;STOPPED!
	INC PSTOPC(A)		;ONE FOR THE BIT
	MOV #-1,PSPHRP(A)	;NO SPHERE AS OF NOW
	MOV #-1,PITEM2(A)	;NO ITEMS EITHER
	MOV #174000,PUPS(A)	;THE USER MODE PS
;NOTE THAT CRUSER ENTERS HERE
;AND INTIALIZES THE VARIABLES THAT IT HAS IN COMMON WITH PROCESSES
CRUSR1:	INC PRSREF(A)	;PRESUMABLY, THE GUY ASKING FOR IT WILL REFERENCE IT
	MOV PFREEQ,PPRTPT(A)	;THE PROCESS BLOCK WE WILL SOON GOBBLE
	JSR PC,ITM0PO	;NOW WE POP THE ITEM STACK
	MOV PFREEQ,A	;GET A PROCESS TABLE ENTRY
	BNE CRPRO2	;GOT ONE!
	MOV B,A		;AFTER ALL THAT WORK
	JSR PC,DLITEM	;WE HAVE TO GIVE UP
CRPRO1:	SEZ		;FAILURE
	RTS PC
CRPRO2:	MOV B,PRTPPT(A)	;SAVE THE ITEM # OF THE PROCESS IN THE PROCESS TABLE
	MOV #IPRIOR,PRTPRI(A)	;EVERYONE STARTS OUT WITH THIS
	SAVE B		;SAVE THE ITEM NUM
	MOV CURUSR,B	;THE CURRENT USER BLOCK
	CMP #-1,CURUSR	;ONLY THE VERY FIRST TIME (I HOPE)
	BEQ CRPRO3
	MOV PRTJMT(B),PRTJMT(A)	;START HIM AT A DISADVANTAGE
CRPRO3:	MOV B,PRTUPT(A)		;THE USER CREATING THIS IS THE PROCESS'S USER
	MOV #STOPQ,B	;MOVE FROM THE FREE Q TO THE STOPPED Q
	JSR PC,TQUEUE
	MOV A,B
POPACZ:	REST A		;ITEM NUM
	CLZ		;SUCESS
	RTS PC


;KEEP THIS NEAR CRPROC
;CREATE A USER
;RETURN ITEM NUMBER IN A, ADDRESS OF PROCESS TABLE ENTRY IN B
;CLEAR Z IF SUCESSFUL, OTHERWISE SET IT
CRUSER:	MOV #USRLEN,A	;THE LENGTH OF A USER
	JSR PC,CRITEM	;DO IT!
	BEQ CRPRO1	;FAIL
	JSR PC,CLITEM	;CLEAR THE ITEM
	MOV #ITUSER,(A)	;SET THE TYPE
	JSR PC,CRUSR1	;USE A LOT OF CODE FROM CRPROC
;NOTE THAT THIS WILL LEAVE THE USER ON THE STOP QUEUE
;WHICH WILL CAUSE A PROBLEM IF THE SCHEDULER RUNS
;WHICH IT SHOULDN'T
	BEQ CRPRO1	;FAILURE
	SAVE A		;SAVE THE ITEM INDEX
	MOV B,A		;THE PROCESS TABLE ADDRESS
	MOV #USERQ,B	;THE PLACE WHERE A USER BELONGS
	JSR PC,TQUEUE	;TRANSFER TO USER QUEUE
	MOV A,B
	BR POPACZ	;SUCCESS

;DECREMENT REFERENCE COUNT OF PROCESS IN A
;WIPE IT OUT IFCOUNT REACHES ZERO
DLPROC:	SAVE B
	JSR PC,ITM0PL
	DEC PRSREF(A)	;ONE LESS REFERENCE
	BNE DLPRO1	;SOMEONE ELSE STILL REFERENCES IT
	JSR PC,REMPRS	;REMOVE IT FROMTHE SPHERE
	MOV ITM0A,A
	MOV PPRTPT(A),A	;THE PROCESS TABLE ENTRY FOR IT
	MOV #PFREEQ,B	;MAKE THE PROCESS TABLE ENTRY FREE
	JSR PC,TQUEUE
	MOV ITEM0,A
	JSR PC,DLITEM	;FLUSH THE ACTUAL PROCESS
	JSR PC,ITM0PO
	REST B
	SEZ		;SAY YOU DELETED IT
	RTS PC
DLPRO1:	JSR PC,ITM0PO
	REST B
	CLZ		;SAY YOU DIDN'T DELETE THE PROCESS
	RTS PC

;TRANFER PROCESS TABLE ENTRY IN A
;FROM IT'S PRESENT QUEUE TO THE ONE IN B
TQUEUE:	SAVE C
;MUST SPL 7 HERE IF THE INT LEVEL LOOKS AT QUEUES BACKWARDS
	MOV (A),C	;THE FORWARD POINTER OF THE ENTRY TO BE MOVED
	MOV C,@PRTBCK(A)	;CORRECT THE FORWARD POINTER OF THE PREVIOUS ENTRY
	TST C		;IS THERE A NEXT ENTRY?
	BEQ .+10	;NO, DON'T DO ANYTHING TO IT!
	MOV PRTBCK(A),PRTBCK(C)	;CORRECT THE BACK POINTER OF THE NEXT ENTRY
;MAY SPL 0 HERE, THE ENTRY IS IN LIMBO FOR THE TIME BEING
	MOV (B),C	;GET THE CONTENTS OF THE QUEUE POINTER
	MOV C,(A)	;POINT THE THING BEING MOVED AT THE BEGGINING OF THE QUEUE
	MOV B,PRTBCK(A)	;CORRECT BACK POINTER OF THING WE ARE MOVING
;SPL 7 HERE IF YOU DID ABOVE
	TST C		;IS THERE AN OLD FIRST ENTRY?
	BEQ .+6		;NO, DON'T DO ANYTHING TO IT!
	MOV A,PRTBCK(C)	;FIX BACK POINTER OF OLD FIRST ENTRY ON NEW QUEUE
	MOV A,(B)	;FIX QUEUE POINTER ITSELF
;SPL 0
	SAVE A
	MOV PRTPPT(A),A	;GET THE ITEM NUMBER OF THE THING
	JSR PC,ITM0PL
	CLR PQBIT(A)
	BIS QBIT(B),PQBIT(A)	;SET THE RIGHT Q-BIT
	JSR PC,ITM0PO
	REST A
	REST C
	RTS PC
;PUT THE PROCESS WHO'S ITEM IS IN A
;INTO THE SPHERE WHOS ITEM IS IN B
;SHOULD FAIL FOR RUNNING PROCESS OR TOO MANY PROCESSES IN SPHERE (NOT YET)
;CLEARS Z ON SUCESS
PUTPRS:	SAVE <A,B>
	JSR PC,ITM0PL	;PUT THE PROCESS INTO ITEM 0
	TST PSTOPC(A)	;IS IT STOPPED?
	BEQ PUTPR2	;NO, CAN'T MOVE IT THEN
	JSR PC,REMPRS	;GET IT OUT OF ANY SPHERE IT IS IN
	MOV (P),A	;GET THE SPHERE INDEX
	JSR PC,ITM1PL	;LOAD IT UP
	MOV ITM0A,B	;ADDRESS OF THE PROCESS
	MOV SPHPRP(A),PSPHCP(B)	;POINT PROCESS TO BEG OF OLD LIST
	MOV (P),PSPHRP(B)	;TELL PROCESS WHO IT BELONGS TO
	MOV 2(P),SPHPRP(A)	;LINK IT INTO THE LIST
	REST <B,A>
	JSR PC,ITM0PO
	JSR PC,ITM1PO
	CLZ
	RTS PC
PUTPR2:	JSR PC,ITM0PO	;POP ITEM 0
	REST <B,A>
	SEZ	;SAY WE CAN'T DO IT
	RTS PC
;REMOVE PROCESS IN ITEM0 (ADDRESS IN A) FROM WHATEVER SPHERE IT IS IN
;CLOBBERS B AND A
REMPRS:	MOV PSPHRP(A),A	;POINTER TO SPHERE THIS BELONGS TO
	BLE REMPR1	;WHEW, NO SPHERE, IT'S EASY
	JSR PC,ITM1PL	;GET THE SPHERE IT'S IN
	MOV ITM0A,B	;ADDRESS OF THE PROCESS ITEM
	CMP SPHPRP(A),ITEM0	;DOES IT POINT DIRECTLY TO THE PROCESS?
	BNE REMPR3	;NO, GO SEARCH FO RIT
	MOV PSPHCP(B),SPHPRP(A)	;SPLICE IT OUT OF THE LIST
REMPR5:	JSR PC,ITM1PO	;RESTORE ITEM 1
REMPR1:	RTS PC
REMPR3:	MOV SPHPRP(A),A	;GET THE FIRST PROCESS IN LINE
REMPR6:	BNE .+4		;IS THERE ANOTHER ONE?
	BPT		;NO, PROCESS LIED ABOUT BELONGING TO SPHERE
	JSR PC,ITM1LD	;PUT THIS PROCESS INTO ITEM1
	CMP PSPHCP(A),ITEM0	;DOES IT POINT TO PROCESS WE WANT TO SPLICE OUT?
	BNE REMPR4	;NOPE, KEEP TRYING
	MOV ITM0A,B
	MOV PSPHCP(B),PSPHCP(A)	;SPLICE IT OUT OF THE LIST
	BR REMPR5	;NOW WE CAN PUT IT WHERE WE WANT TO
REMPR4:	MOV PSPHCP(A),A	;GET NEXT ONE
	BR REMPR6	;GO CHECK IT OUT
;DECREMENT STOP COUNT OF PROCESS
;IF IT REACHES ZERO, PUT PROCESS ONTO RUN Q
;ASSUMES PROCESS IS LOADED INTO ITEM 0
PSTPDC:	SAVE A
	MOV ITM0A,A	;WHERE IS IT?
	DEC PSTOPC(A)	;ONE LESS REASON TO BE STOPPED
	BGE .+4		;SHOULD NOT GET NEGATIVE!
	BPT		;(WHAT CAN I SAY!)
	BGT PSTPD1	;DON'T START IT YET
	SAVE B
	MOV PPRTPT(A),A	;POINTER TO THE PROCESS TABLE
	MOV #RUNQ,B	;PUT IT ONTO THE RUN Q
	JSR PC,TQUEUE
	REST B
PSTPD1:	REST A
	RTS PC
;INCREMENT STOP COUNT OF PROCESS WHOSEITEM ISIN A
;IF THE COUNT WAS ZERO AND THE PROCESS WAS IN THE SYSTEM, PCLOSER IT
PSTPIN:	SAVE <A,B>
	JSR PC,ITM0PL	;GET IT INTO THE MAP
	TST PSTOPC(A)	;IS IT ALREADY NON-ZERO?
	BNE PSTPI1	;YES, JUST INCREMENT
	MOV PPRTPT(A),A	;IT'S PROCESS TABLE ENTRY
	MOV #STOPQ,B	;STOP THE PROCESS
	JSR PC,TQUEUE
	MOV ITM0A,A
	TST PSPC(A)	;IN THE SYSTEM?
	BEQ PSTPI1	;NOPE, PC ISUSER MODE PC
	SAVE BPCLSR	;SAVE THE FLAG
	MOV #1,BPCLSR	;SAY WE ARE PCLOSERING HIM
PSTPI2:	TST PLCKSL(A)	;ANY SWITCHES LOCKED
	BEQ PSTPI3	;NOPE
	JSR PC,LSWPOP	;POP THE TOP SWITCH
	BR PSTPI2
PSTPI3:	REST BPCLSR	;DONE PCLOSERING HIM
PSTPI1:	INC PSTOPC(A)	;TELL THE WORLDHE IS STOPPED
	JSR PC,ITM0PO
	REST <B,A>
	RTS PC

;THIS IS WHERE WE GET AFTER SOMEONE SETS PIRQ AND PIRBRK DISPATCHES
;(NOTE THAT WE DON'T GET TO PIRBRK UNTIL ALL INTERUPTS HIGHER
;THAN CLKL HAVE EXITED. CLKL SHOULD BE THE LOWEST INTERUPT IN
;THE SYSTEM, SO IT ALWAYS INTERRUPTS DIRECTLY FROM
;THE MAIN PROGRAM LEVEL)
;STOP A PROCESS IF IT IS IN USER MODE
;IF IT FINDS THE PROCESS
;WAS IN USER MODE, IT ASSUMES THAT THE SECOND REGISTER SET
;WAS BEING USED, AND CLOBBERS SET 0 ARBITRAILY
;IT SAVES THE PROCESSES REGISTERS, THEN RETURNS TO WHOMEVER STARTED
;THE PROCESS BY DOING AN RTS PC
STOPPR:	TST USRMOD	;ARE WE IN USER MODE?
	BNE PIRRET	;NOPE, THE SYSTEM WILL STOP HIM
	MOV PC,USRMOD	;NO LONGER IN USER MODE
	TST (P)+	;FLUSH THE SAVED A
	JSR F,SPCPSP	;SAVE THE PC, THE PS AND P
	JSR PC,PACSAV	;SAVE THE REST OF THE REGISTERS, INCLUDING THE FPP
	JSR PC,SAVAWB	;SAVE THE A AND W BITS
	JSR PC,TIMEUS	;GO CHARGE HIM FOR TIME USED
	MOV #-1,PRUNNG	;NO PROCESS RUNNING NOW
	RTS PC		;(GULP!!) RETURN TO CALLER
PIRRET:	REST A
	RTT
;CHARGE USER FOR THE TIME HE HAS USED
;EXPECTS POINTER TO ITEM0 IN A. CLOBBERS B AND C
TIMEUS:	MOV TUSED,B	;NUMBER OF TICKS HE USED
	ASL B		;CONVERT TO HALF TICKS
	BNE .+4		;DID HE USE ANY TIME?
	INC B		;EVERYONE USES AT LEAST ONE HALF-TICK
	ADD B,PTUSED(A)	;UPDATE HIS TIME USED
	ADC PTUSED+2(A)
	MUL #JMTUAC,B	;MULTIPLY BY THE ADDTIVE FACTOR
	MOV PPRTPT(A),C	;POINTER TO PROCESS BLOCK
	ADD B,PRTJMT(C)	;UPDATE THE PROCESS JMTU
	MOV PRTUPT(C),C	;POINTER TO THE USER BLOCK
	ADD B,PRTJMT(C)	;UPDATE THAT JMTU TOO
	RTS PC
;ENTER THE RUNNING QUEUE
RUNME:	SAVE #RUNQ
	BR FLUSH
;ENTER THE SHORT FLUSHED QUEUE
SFLUSH:	SAVE #SFLSQ
	BR FLUSH
;ENTER THE LONG FLUSH QUEUE
LFLUSH:	SAVE #LFLSQ
	BR FLUSH
;ENTER THE PAGE WAIT QUEUE
PAGEW:	SAVE #PAGWQ
	BR FLUSH
;ENTER THE SWAP BLOCKED QUEUE
SWAPB:	SAVE #SWPBQ
FLUSH:	SAVE A		;GET A FREE REGISTER
	MOV ITM0A,A	;THE RUNNING PROCESS IS ALWAYS ITEM 0
	ADD #PSREGS,A	;A POINTER TO THE SYSTEM REGISTERS FOR THE GUY
	REST (A)+	;GET BACK A
.IRPC X,<BCDEF>
	MOV X,(A)+
.ENDM
	MOV ITM0A,E
	MOV PPRTPT(E),A	;POINTER TO PROCESS TABLE
	MOV (P),B	;QUEUE TO MOV IT TO
	JSR PC,TQUEUE	;DO THE ACTUAL MOVE
	MOV ITM0A,A
	REST <B,E>		;GET THE QUEUE AGAIN
	TST PSPC(A)	;WERE WE ALREADY FLUSHED?
	BNE FLUSH2	;YES
	JSR PC,PACSAV	;IN CASE USER'S REGISTERS NOT SAVED YET
	JSR PC,TIMEUS	;CHARGE HIM FOR TIME USED
	JSR PC,SAVAWB	;SAVE REFERENCED PAGES
	JSR PC,PDLSAV	;SAVE THE SYSTEM PDL
FLUSH2:	MOV ITM0A,A
	MOV E,PSPC(A)
	RTS PC
;START THE PROCESS WHOSE PROCESS TABLE ENTRY IS
;POINTED TO BY A
;WHEN PROCESS FINALLY STOPS, THE ROUTINE WILL RETURN
;CLOBBERS ALL REGISTERS
STPROC:	BIS #30000,PS	;MAKE SURE PREVIOUS MODE IS USER
	SPL CLKL	;STOP US FROM GETTING STOPPED
	BIC #CLKPIR,PIRQ	;MAKE SURE NO STOP PENDING
	MOV PRTUPT(A),CURUSR	;THE GUY TO "CHARGE" FOR THIS RUN
	CLR TUSED		;START COUNTING NOW
	MOV PRTPPT(A),A		;GET THE PROCESS ITEM #
	MOV A,PRUNNG		;THIS IS THE RUNING PROCESS
	JSR PC,ITM0LD	;IT IS EXPECTED TO BE IN ITEM0
	MOV A,B		;SAVE THE POINTER TO IT
	MOV PSPHRP(A),A	;GET A POINTER TO THE SPHERE
	JSR PC,ITM1LD	;IT IS EPECTED IN ITEM1
	JSR PC,PACRES	;RESTORE REGISTER SET 1
	JSR PC,MAPRES	;RESTORE THE MAP
	SAVE PUP(B)	;GET THE USER'S PDL POINTER
	MTPI P		;RESTORE IT TO HIM
	TST PSPC(B)	;IS HE RUNNING IN THE SYSTEM?
	BNE STPRO1	;YES, GO RESTORE OTHER THINGS
	TST PFAULT(B)	;DOES HE HAVE A FAULT PENDING?
	BEQ .+6		;NO, PUT HIM INTO USERMODE
	JMP CFAULT	;YES, GO MAKE IT HAPPEN
	MOV P,PSP(B)	;WHERE THE PDL ENDS
	SAVE <PUPS(B),PUPC(B)>	;HIS PROCESSOR STATUS AND HIS PROGRAM COUNTER
	CLR USRMOD	;THE WORLD IS NOW IN USER MODE
	RTI		;RETURN TO HIM IN USER MODE
STPRO1:	JSR F,PDLRES	;RESTORE HIS SYSTEM PDL
	SAVE <#30000,PSPC(B)>	;GET PS AND GET PC
	CLR PSPC(B)	;INDICATE NOT HUNG
	MOV (P),USRMOD	;INDICATE THAT WE ARE NOT IN USER MODE
	MOV B,A		;POINTER TO THE PROCESS
	ADD #PSREGS+14,A	;THE SYSTEM REGISTERS
.IRPC X,FEDCBA
	MOV -(A),X
.ENDM
	RTI		;EXIT TO RIGHT PLACE IN THE SYSTEM
;SAVE THE USER'S PC, PS AND PDL POINTER
;CALL WITH JSR F,SPCPSP
;A GETS CLOBBERED TO ITEM 0 ADDRESS
;F GETS CLOBBERED TO VALUE OF THE USER'S P
;ITEM0 IS EXPECTED TO BE THE PROCESS
SPCPSP:	TST (P)+
	MOV ITM0A,A	;THE ADDRESS OF THE PROCESS IN THE MAP
	REST <PUPC(A),PUPS(A)>	;SAVE HIS PC AND HIS PS
	MFPD P		;GET HIS P
	MOV (P),PUP(A)	;SAVE HIS PDL POINTER (PUP-P?)
	RTS F		;RETURN WITH P IN F
;SAVE THE PROCESSES REGISTERS, INCLUDING THE FPP IF THAT IS ENABLED
;THE GENERAL REGISTERS ARE IN SET 1
;THE ADDRESS OF THE PROCESS ITEM IS EXPECTED IN A
;THE PROCESS ITEM IS EXPECTED TO BE IN THE MAP
PACSAV:	SAVE A		;TO COMMUNICATE WITH THE OTHER REGISTER SET
	BIT #PACSVF,PFLAGS(A)	;HAVE THE AC'S ALREADY BEEN SAVED?
	BEQ PACSV1	;ZERO=>SAVED
	BIC #PACSVF,PFLAGS(A)
	BIS #4000,PS	;CHANGE TO OTHER SET
	SAVE A		;SAVE A OF SET 1
	MOV 2(P),A	;GET A FROM SET 0
	ADD #PUREGS,A	;POINT TO PALCE TO SAVE REGISTERS
	REST (A)+	;SAVE A OF SET 1
	MOV B,(A)+	;SAVE REST OF SET 1
	MOV C,(A)+
	MOV D,(A)+
	MOV E,(A)+
	MOV F,(A)+
	BIC #4000,PS	;BACK TO SET 0
;NOTE THAT SET 0'S A HAS NOT BEEN CLOBBERED
	BIT #PFPFLG,PFLAGS(A)	;HAS HE ENABLED THE FPP?
	BEQ PACSV1	;NOPE
	STFPS PFPPS(A)		;STORE THE STATUS
	ADD #PFPPRG,A	;POINT TO FPP REGISTERS
	SETD		;SO WE SAVE ALL THE BITS
	STD A,(A)+
	STD B,(A)+
	STD C,(A)+
	STD D,(A)+	;SAVE ALL WE CAN GET TO DIRECTLY
	LDD E,A		;LAST 2 HAVE TO BE MOVED SPECIAL
	STD A,(A)+
	LDD F,A
	STD A,(A)+
PACSV1:	REST A
	RTS PC
;RESTORE THE USER'S REGISTERS
;B IS EXPECTED TO CONTAIN A POINTER TO THE PROCESS ITEM
;NO REGISTERS ARE CLOBBERED (EXCEPT, OF COURSE, THE USER'S)
PACRES:	SAVE B
	BIT #PACSVF,PFLAGS(B)	;WERE THEY EVER SAVED?
	BNE PACRS1	;ONE=>NOT SAVED
	BIS #PACSVF,PFLAGS(B)
	BIS #4000,PS	;GO TO REGISTER SET 1
	MOV (P),A	;GET THE POINTER TO THE ITEM
	ADD #PUREGS+14,A	;CONVERT TO A REGISTER POINTER
.IRPC X,<FEDCBA>
	MOV -(A),X
.ENDM
	BIC #4000,PS	;BACK TO SET 0
	BIT #PFPFLG,PFLAGS(B)
	BEQ PACRS1		;DOESN'T USE FPP
	SETD		;RESTORE ALL BITS
	ADD #PFPPRG+<16.*2>,B	;POINT TO REGISTERS E AND F FIRST
	LDD (B)+,A
	STD A,E
	LDD (B)+,A
	STD A,F
	MOV (P),B
	ADD #PFPPRG,B		;GO BACK FOR REG'S A THROUGH D
.IRPC X,<DCBA>
	LDD (B)+,X
.ENDM
	MOV (P),B
	LDFPS PFPPS(B)
PACRS1:	REST B
	RTS PC
;RESTORE THE USER'S SYSTEM PDL
;CALLED WITH JSR F,PDLRES  
;CLOBBERS A AND C AND F
;AS WELL AS PUSHING THINGS ONTO P
;EXPECTS A POINTER TO THE PROCESS ITEM IN B
PDLRES:	TST (P)+
	MOV PSP(B),A	;THE VALUE THAT THE STACK POINTER SHOULD HAVE
	MOV P,PSP(B)	;FOR PDLSAV, THE VALUE IT SHOULD HAVE AFTER SAVING
	MOV B,C		;COPY POINTER TO ITEM
	ADD #PPDL,C	;MAKE IT A POINTER TO THE PDL
PDLRE2:	CMP P,A		;HAVE WE PUSHED ENOUGH?
	BEQ PDLSA1	;YUP
	MOV (C)+,-(P)	;POP-PUSH
	BR PDLRE2
;SAVE THE SYSTEM PDL INTO THE PROCESS'S
;SYSTEM PDL AREA. SAVES UP TO WHAT IS INDICATED BY PSP
;CALLED WITH JSR PC,PDLSAV
;CLOBBERS A,B,C, AND F
;ALSO POPS STUFF OFF THE STACK
PDLSAV:	REST F		;GET THE RETURN ADDRESS
	MOV ITM0A,A	;GET A POINTER TO THE PROCESS
	MOV PSP(A),B	;WHAT THE PDL POINTER SHOULD BE
	MOV B,C
	SUB P,B		;WHAT'S THE DIFFERENCE?
	BEQ PDLSA1	;NONE, FORGET IT
	BGT .+4	;MAKE SURE IT'S POSITIVE
	BPT		;GASP!
	CMP #PRPDLL,B	;IS IT PUSHED TO DEEP?
	BGT .+4
	BPT		;NAUTGHY!
	ADD A,B		;MAKE A POINTER TO THE END OF
	ADD #PPDL,B	;THE PROCESS'S PDL
PDLSA2:	MOV (P)+,-(B)	;POP-PUSH
	CMP C,P		;ARE WE DONE YET?
	BNE PDLSA2	;NOPE
PDLSA1:	JMP (F)

;RETURN THE NEXT WOR DFROM THE USER'S PDL
;INCREMENT THE POP COUNT SO IT IS POPED IF THE CALL RETURNS
;THE WORD IS RETURNED IN A
RETNSW:	SAVE B
	MOV ITM0A,A	;ASSUME THE PROCESS IS ITEM 0
RETNS1:	MOV PUP(A),B	;THE PDL POINTER
	ADD PUPDLO(A),B	;THE OFFSET SO FAR
	ADD #2,PUPDLO(A)	;POPPED ONE MORE THING
	MFPD (B)	;GET THE WORD
	MOV  (P),A	;SAVE THE WORD
	MTPD (B)	;MAKE SURE WE CAN WRITE IT BACK
	REST B
	RTS PC
;RETURN THE PREVIOUS WORD FROM THE USER'S STACK (THE ONE YOU GOT ALREADY)
;RETURNED IN A
RETPSW:	SAVE B
	MOV ITM0A,A
	SUB #2,PUPDLO(A)	;BACK UP!
	BR RETNS1	;GO DO THE REST

:GIVE THE WORD IN B TO THE USER
GIVPSW:	SAVE <A,C,B>
	MOV ITM0A,A	;ASSUME PROCESS IS IN ITEM0
	MOV PUP(A),C	;THE PDL POINTER
	SUB #2,PUPDLO(A)	;DEC THE OFFSET
	ADD PUPDLO(A),C	;MAKE IT CORRECTED
	MTPD (C)	;MOVE THE WORD
	REST <C,A>	;RESTORE REGS
	RTS PC
	.SBTTL SPHERE HACKING ROUTINES

;CREATE A SPHERE
;RETURN THE INDEX OF THE ITEM IN A
CRSPHR:	SAVE B
	MOV #SPHLEN,A	;THE LENGTH OF A SPHERE (INITIALLY)
	JSR PC,CRITEM	;MAKE ONE
	BNE CRSPH1	;DID IT SUCEED?
CRSPH0:	REST B
	SEZ		;INDICATE FAILURE
	RTS PC		;NOPE
CRSPH1:	JSR PC,CLITEM	;LOAD IT INTO ITEM0 AND CLEAR IT
	MOV #ITSPHR,(A)	;SET THE TYPE
	MOV CURUSR,SUSRPT(A)	;THE GUY WHO CREATES IT GETS "CHARGED" FOR  IT
	MOV #SICLST+<NCLSEB*CLSELN*2>,SCLSEP(A)	;THE LAST LOCATION USED
	SAVE <C,B>
	MOV A,B
	ADD #SCLSTT,B	;GET AN ADDRESS POINTER TO THE INDEX TABLE
	MOV #<MNCLSE/NCLSEB>/2,C	;NUMBER OF WORDS OF POINTERS
	MOV #-1,(B)+
	SOB C,.-4	;INTIALIZE THEM TO POINT AT NOTHING
	MOVB #1,-(B)	;EXPECT THE LAST ONE POINTS AT THE 2ND BLOCK
	CLRB SCLSTT(A)	;AND THE FIRST TO THE FIRST
	MOV CURSPH,SMSSPT(A)
	MOV (P),B	;GET THE ITEM INDEX BACK
	JSR PC,CRUSR1	;INITIALIZE THE PROCESS TABLE ENTRY
	BEQ CRSPH2
	MOV B,A		;THE PROCESS TABLE ENTRY
	MOV #SPHRQ,B	;THE PLACE TO PUT IT
	JSR PC,TQUEUE	;MOVE IT
	REST A	;THE ITEM #
	REST C
	REST B	;THE ORIGINAL CONTENTS OF B
	CLZ		;SUCECESS
	RTS PC
CRSPH2:	REST <A,C>
	BR	CRSPH0

;SAVE THE A AND W BITS FOR THE CURRENT SPHERE
;THE SPHERE IS EXPECTED TO BE IN ITEM1, AND THE USER
;SEGMENTATION REGISTERS ARE EXPECTED TO REFLECT THIS SPHERE
SAVAWB:	SAVE <A,B,C,D>
	MOV ITM1A,A	;ADDRESS OF ITEM1 IN THE MAP
	ADD #SUPTS+UPTDR,A	;POINT TO THE UPTS DR
	MOV #USRISD,B	;THE ACTUAL SEGMENTATION REGISTERS
	MOV #20,C	;NUMBER OF SEGMENTS
SAVAW1:	MOV (B)+,D	;THE SEGMENTER'S DR
	BIC #177477,D	;JUST THE A+W BITS
	BIS D,(A)	;INTO THE APPROPRIATE UPT
	TST (A)		;IS IT A D=I PAGE?
	BGE SAVAW2	;NOPE
	BIS D,-10*UPTLEN(A)	;SET THE COORESPONDING I PAGE
SAVAW2:	ADD #UPTLEN,A	;TO THE NEXT UPT ENTRY
	SOB C,SAVAW1
	REST <D,C,B,A>
	RTS PC
	.SBTTL SPHERE HACKING ROUTINES- C-LIST HANDLERS
;GET ADDRESS OF A C-LIST ENTRY
;A CONTAINS ADDRESS OF SPHERE IN MAP
;B CONTAINS C-LIST NUMBER
;B RETURNS OFFSET INTO SPHERE IF SUCESSFUL (Z CLEAR)
;OTHERWISE Z SET AND B CONTAINS SPHERE BYTE ADDRESS OF INDEX BYTE
GCLSTA:	SAVE <D,C,A>
	CLR C		;FOR THE DIVIDE
	MOV B,D		;SAVE C-LIST NUMBER
	DIV #NCLSEB,C	;GET THE BLOCK AND OFFSET
	ADD C,A		;CONVERT TO
	ADD #SCLSTT,A	;ADDRESS OF INDEX BYTE
	MOVB (A),B	;GET THE BYTE
	BLT GCLST1	;NEGATIVE IMPLIES NO STUCK BLOCK
	MUL #NCLSEB*CLSELN,B	;RELATIVE ADDRESS OF BLOCK
	MUL #CLSELN,D	;REMANDER
	ADD D,B		;NOW WITHIN BLOCK
	ADD #SICLST,B	;LESS RELATIVE
	REST <A,C,D>
	CLZ		;SUCESS
	RTS PC
GCLST1:	MOV A,B		;SAVE FOR THE CALLER
	REST <A,C,D>
	SEZ		;FAILURE
	RTS PC
;ALWAYS GET THE ADDRESS OF A C-LIST ENTRY
;(CREATE IF NON-EXISTANT)
;B CONTAINSC-LIST NUMBER
;C CONTAINS ITEM NUMBER TO INSERT INTO
;A GETS CLOBBERED
;B RETURNS OFFSET INTO SPHERE IF SUCESSFUL (Z CLEARED)
;OTHERWISE, SET Z
AGCLSA:	SAVE B
	MOV C,A		;COPY SPHERE ITEM NUMBER
	JSR PC,ITM1PL	;LOAD IT INTO THE MAP
	JSR PC,GCLSTA	;SEE IF THE ENTRY IS ALREADY THERE
	BNE AGCLS1	;SUCESS, IT'S ALREADY THERE
	MOV SCLSEP(A),A	;POINTER TO BEGGINING OF UNUSED SPACE
	ADD #NCLSEB*CLSELN,A	;NEW END
	JSR PC,ITM1PO	;IN CASE WE HANG
	SAVE B
	MOV C,B		;COPY SPHERE ITEM NUMBER
	ASH #-6,A	;MAKE WORD SIZE INTO BLOCK SIZE
	JSR PC,EXITEM	;MAKE SURE IT'S BIG ENOUGH
	BEQ AGCLS2	;FAILURE
	MOV C,A		;ITEM WHERE THE NEW THING IS GOING
	JSR PC,ITM1PL	;LOAD IT UP
	MOV #NCLSEB*CLSELN/2,B	;NUMBER OF WORDS WE JUST ADDED
	MOV SCLSEP(A),C	;POINTER TO OLD END+2
	ADD #NCLSEB*CLSELN,SCLSEP(A)	;THE NEW END
	SAVE D
	MOV C,D		;FOR DIVIDE LATER
	ADD A,C		;MAKE IT A REAL ADDRESS FOR CLEAR
	CLR (C)+	;WIPE OUT NEW STUFF
	SOB B,.-2
	CLR C		;FOR DIVIDE
	SUB #SICLST,D	;MAKE IT RELATIVE
	DIV #NCLSEB*CLSELN,C	;GET BLOCK NUMBER
	MOV 2(P),B	;RESTORE BYTE POINTER
	MOVB C,(B)	;NEW BLOCK NUMBER
	MOV ITEM1,C	;THE SPHERE WE ARE HACKING
	JSR PC,ITM1PO	;RESTORE ITEM 1
	REST <D,B,B>
	BR GCLSTA	;TRY AGAIN
AGCLS1:	JSR PC,ITM1PO	;POP THE ITEM WE PUSHED
	TST (P)+
	CLZ
	RTS PC
AGCLS2:	REST <B,B>
	SEZ
	RTS PC
;GET THE ADDRESS OF A C-LIST ENTRY, ASSUMING THE SPHERE IS IN ITEM 1
;RETURN REAL ADDRESS IN A AND CLEAR Z, UNLESS YOU FAIL
AGCLAD:	SAVE <B,C>
	MOV ITEM1,C	;ASSUME THE SPHERE IS IN ITEM 1
	JSR PC,AGCLSA	;GO GET THE ADDRESS
	BEQ AGCLA1	;FAILURE
	MOV ITM1A,A	;GET THE ADDRESS IN THE MAP
	ADD B,A		;MAKE A REAL ADDRESS
	REST <C,B>
	CLZ
	RTS PC
AGCLA1:	REST <B,C>
	SEZ
	RTS PC
;CREATE A C-LIST ENTRY, ITEM OF SPHERE IN C, POSITION OF ENTRY
;TO BE CREATED IN B (-1 GETS THE FIRST AVAILABLE ENTRY), RETRURNS WITH Z CLEARED
;NORMALLY, SETS Z IF SLOT ISN'T AVAILABLE, AND SETS C IF NO SLOTS AVAILABLE
;ON NORMAL RETURN, B CONTAINS C-LIST NO. AND A CONTAINS ADDRESS OF ENTRY RELATIVE TO SPHERE
CRCLST:	BIC #177400,B	;ONLY THE BOTTOM BYTE IS SIGINIFICANT
	CMP #377,B	;IS IT -1
	BNE CRCLS1	;NO, FIGURE OUT WHICH ONE IT IS
	MOV #MNCLSE-1,B	;START LOOKING AT THE TOP
CRCLS2:	SAVE B		;THE CURRENT C-LIST NO.
	JSR PC,AGCLSA	;GET A C-LIST ENTRY
	BEQ CRCLS3	;FAILED, BECAUSE NOT AVAILABLE
	MOV C,A		;THE SPHERES ITEM NO.
	JSR PC,ITM1PL	;LOAD IT UP
	ADD B,A		;MAKE THE POINTER TO THE C-LIST ENTRY ABSOLUTE
	TST (A)		;IS IT FREE
	BEQ CRCLS4	;YES RETURN SUCESSFUL
	REST B
	DEC B		;TRY THE NEXT C-LIST ENTRY
	BEQ CRCLS5	;NO MORE RETURN WITH CARRY SET
	JSR PC,ITM1PO	;POP THE SPHERE
	BR CRCLS2	;TRY THE NEXT ONE
CRCLS1:	SAVE B
	JSR PC,AGCLSA	;GET A C-LIST ENTRY
	BEQ CRCLS3	;FAILED (NOT AVAILABLE)
	MOV C,A		;SPHERES ITEM NO
	JSR PC,ITM1PL	;LOAD UP THE SPHERE
	ADD B,A		;MAKE THE POINTER ABSOLUTE
	TST (A)		;IS TI FREE
	BNE CRCLS6	;NOPE
CRCLS4:	REST B
	SUB ITM1A,A	;MAKE IT RELATIVE AGAIN
	JSR PC,ITM1PO	;POP THE SPHERE
	CLZ!CLC		;CLEAR EVERYTHING
	RTS PC
CRCLS6:	REST B
CRCLS5:	JSR PC,ITM1PO	;POP THE SHPERE
	CLZ
	SEC
	RTS PC
CRCLS3:	REST B
	SEZ 
	RTS PC
;THIS ROUTINE TAKES A POINTER TO THE FIRST CAPABILITY OF A CIRCULAR
;LIST IN A AND THE C-LIST NO. OF THAT CAP IN B, AND RETURNS THE
;ITEM NO. (IN C) AND THE C-LIST NO. (IN D) OF THE C-LIST ENTRY THAT
;POINTS TO IT. THE C-LIST NO. OF THE ORIG. ENTRY IS IN B,AND THE ORIG.
;ITEM NO. IN A. RETURNS WITH Z SET IF NO CIRCULAR LIST
FNBKPT:	TST 4(A)	;IS THERE A CIRCULAR LIST
	BNE FNBPT1	;YES
	RTS PC
FNBPT1:	MOV ITEM1,A	;THE CURRENT ITEM NO.
	SAVE <A,B>	;FOR REFERENCE LATER
FNBPT2:	SAVE <A,B>	;SAVE CURRENT ITEM AND C-LIST
	JSR PC,ITM1PL	;LOAD UP THIS SPHERE
	JSR PC,GCLSTA	;GET ADDRESS OF C-LIST ENTRY
	BNE .+4		;DID WE SUCCEED
	BPT		;URP
	ADD A,B		;MAKE THE POINTER ABSOLUTE
	MOV 4(B),A	;THE NEXT C-LIST NO.
	MOV 10(B),B	;THE NEXT C-LIST ITEM
	BNE .+4		;THE ITEM SHOULDN'T BE 0
	BPT		;WHAT MORE CAN I SAY
	JSR PC,ITM1PO	;GET RID OF THIS ITEM
	REST <D,C>	;GET THE OLD VALUES
	CMP A,2(P)	;IS THE POINTER THE SAME AS THE ORIG.
	BNE FNBPT2	;NOPE FIND THE NEXT ONE
	CMP B,(P)	;IS THE REST OF THE POINTER THE SAME
	BNE FNBPT2	;NOPE TRY AGAIN
	ADD #4,P	;POP OFF THE ORIG. ITEM AND C-LIST NO.
	CLZ
	RTS PC

;STOP SPHERE WITH INDEX IN C
SPRSTP:	SAVE A
	MOV #-1,A	;FOR THE BOGUS PUSH
	JSR PC,ITM0PL	;CREATE A WORK CELL
	MOV C,A		;THE SPHERE NO.
	JSR PC,ITM1PL	;LOAD THE SPHERE
	MOV SPHPRP(A),A	;GET POINTER TO THE FIRST PROCESS
	JSR PC,ITM1PO	;POP THE SPHERE
	BR SPSTP2	;CHECK OUT THE FIRST PROCESS
SPSTP1:	JSR PC,PSTPIN	;STOP THE PROCESS
SPSTP3:	JSR PC,ITM0LD	;LOAD THE PROCESS JUST STOPPED
	MOV PSPHCP(A),A	;GET THE NEXT PROCESS
SPSTP2:	CMP A,PRUNNG	;DONT STOP THE CURRENT PROCESS
	BEQ SPSTP3	;THIS IS IT
	TST A		;ARE THERE ANY PROCESSES
	BNE SPSTP1	;YES
	JSR PC,ITM0PO	;POP THE WORK CELL
	REST A
	RTS PC

;PCLOSER ROUTINE FOR DECREMENTING SPHERE STOP COUNTS
PCSPST:	SAVE E
	MOV LCKWD2(B),E	;THE ONE NOT TO START
	MOV ITEM2,A	;THE SPHERE IS LOADED INTO ITEM2
	BR SPRST5
;DECREMENT THE STOP COUNTS OF EVERYTHING ATTACHED TO THIS SPHERE
;INDEX IN A
SPRSTR:	SAVE E
	CLR E		;STOP ALL THE PROCESSES
SPRST5:	SAVE B
	JSR PC,ITM1PL	;LOAD THE SPHERE
	MOV SPHPRP(A),B	;GET THE POINTER TO THE FIRST PROCESS
	JSR PC,ITM1PO	;POP THE SPHERE
	MOV #-1,A
	JSR PC,ITM0PL	;MAKE A BOGUS PUSH
	BR SPSTR4	;CHECK THE FIRST ONE
SPSTR1:	JSR PC,PSTPDC	;DECREMENT THE PROCESSES STOP COUNT
SPSTR3:	MOV PSPHCP(A),B	;GET THE NEXT PROCESS
SPSTR4:	TST B		;ARE THERE ANY MORE PROCESSES
	BEQ SPSTR2	;NO WE ARE DONE
	MOV B,A		;THE NEXT PROCESS
	JSR PC,ITM0LD
	CMP B,E		;IS THIS THE ONE NOT TO DECREMENT
	BEQ SPSTR3	;YES IGNORE IT
	BR SPSTR1	;GO STOP THIS ONE
SPSTR2:	JSR PC,ITM0PO	;POP THE PROCESS
	REST <B,E>
	RTS PC
;THIS ROUTINE IS THE PC-LOSER ROUTINE FOR RESTARTING PROCESSES IN A SPHERE AND
;ALL INFERIOR SPHERES
PCMSST:	MOV ITEM2,A	;GET THE SPHERE NO.
	JSR PC,ITM1PL	;LOAD UP THE SPHERE
	SAVE E		;KEEP E FROM BEING CLOBBERED
	CLR E		;SAY WE SHOULD START THE PROCESSES
	JSR PC,STPMS	;START THEM
	REST E		;RESTORE E
	JSR PC,ITM1PO	;POP THE SPHERE
	RTS PC		;RETURN

;THIS ROUTINE EXPECTS THAT MS TO BE STOPPED OR STARTED TO BE LOADED IN ITEM1
;IF E IS < 0 THE SPHERE (AND INFERIORS ARE STOPPED, ELSE STARTED)
STPMS:	JSR F,ACSAV	;SAVE THE AC'S
	CLR -(P)	;CREATE A DEPTH COUNTER
	MOV ITEM1,C	;THE SPHERE TO STOP
STPMS1:	MOV #MNCLSE/NCLSEB,F	;THE NUMBER OF C-LIST BLOCKS
	CLR D		;THE CURRENT C-LIST NO.
	TST E		;SHOULD WE START OR STOP
	BMI MSSTP	;STOP THEM
	MOV C,A		;THE ITEM NO
	JSR PC,SPRSTR	;START THE PROCESSES
	BR .+6		;CONTINUE ON INFERIOR SPHERE
MSSTP:	JSR PC,SPRSTP	;STOP THE SPHERE
	MOV ITM1A,A	;THE ADDRESS IN THE MAP WHERE THE SPHERE IS LOADED
MSSTP1:	MOV D,B		;THE CURRENT C-LIST NO.
	JSR PC,GCLSTA	;GET THE FIRST CAPABILITY OF THIS BLOCK
	BEQ MSSTP3	;IT DOESN'T EXIST
	ADD A,B		;MAKE B POINT TO THE CORRECT CAPABILITY
	MOV #NCLSEB,C	;THE NUMBER OF ENTRIES TO CHECK
MSSTP2:	CMPB (B),#.MSCAP	;IS IT A MASTER SPHERE CAPABILITY
	BEQ MSSTP4	;YES, DO SOMETHING ABOUT IT
	ADD #CLSELN,B	;GET THE NEXT C-LIST ENTRY
	SOB C,MSSTP2	;TRY IT	OUT
MSSTP3:	ADD #NCLSEB,D	;MAKE D POINT TO NEXT BLOCK
	SOB F,MSSTP1	;GO BACK UNTIL THIS C-LIST IS CHECKED OUT
	DEC (P)		;DECREMENT THE REFERENCE COUNTER
	BMI STMSRT	;DONE IF LESS THAN ZERO
	MOV SMSSPT(A),A	;THE MASTER SPHERE OF THIS SPHERE
	MOV A,C		;GET THE SPHERE NO.
	JSR PC,ITM1LD	;LOAD THE SUPERIOR SPHERE
	BR STPMS1	;TRY THE SUPERIOR SPHERE FOR MORE .MSCAP'S
MSSTP4:	INC (P)		;INCREMENT THE REFERENCE COUNT
	MOV 2(B),A	;THE SPHERE THE .MSCAP REFERS TO
	JSR PC,ITM1LD	;LOAD IT UP
	BR STPMS1	;TRY TO STOP THIS ONE
STMSRT:	TST (P)+	;POP OFF THE DEPTH COUNT
	JSR F,ACRES	;RESTORE THE AC'S
	RTS PC		;DONE
	.SBTTL SPHERE HACKING ROUTINES => UPT HANDLERS

;MAKES A GENERALIZED ITEM POINTER, B CONTAINS UPT NO, C CONTAINS SPHERE NO.
;THEN DELETES UPT, BY FALLING INTO UPTDEL
SUPTDL:	ASH #10.,B		;SET THE UPT NO. INTO THE RIGHT SPOT
	BIS C,B			;MAKE THE GIP
	BIS #GIPBIT!GIPSPR,B	;SAY THAT IT IS A GIP AND IN A SPHERE
;FALL INTO UPTDEL

;DELETE A UPT
;IT DIVIDES INTO THREE MAIN PARTS
;1. DELETING ABSOLUTE PAGES (RIDICULOUSLY EASY)
;2. DELETING CORE PAGES (PAGES WITH NO FPT WITH THEM)
;3. DELETING FPT AND PFPT PAGES (RIDICULOUSLY HARD)

;THIS IS THE PLANNED STRUCTURE
;1. DECIDE IF IT IS AN ABSOLUTE PAGE (IF SO <GO >)
;2. DECIDE IF IT IS A SWAP PAGE, IF IT IS:
;	A. IS IT MOVING? IF SO <FLUSH><GO A.>
;	B. DEALLOCATE SWAP SPACE
;	C. DEALLOCATE CORE SPACE
;	D. <GO 5>
;3. IS IT A PFPT, OR ARE THERE ANY MORE REFERENCES TO THE FPT, IF SO
;	A. CHECK TO SEE IF THE GLOBAL SIZE IS GOING TO BE LARGER, IF SO:
;		i. SWAP IT OUT, WHILE WAITING
;	       ii. UPDATE THE GLOBAL SIZE
;	      iii. UPDATE FPT'S UPT POINTER
;	B. <GO 5>
;4. HERE DELETE THE FPT WITHOUT SCREWING YOURSELF (SEE FMH ABOUT THIS)
;5. UPDATE CPT'S UPT POINTER
;6. UNLINK THE UPT
;7. DONE?
;THIS ROUTINE TAKES A GIP IN B AND DELETES THAT UPT
;IT CLOBBERS NO OTHER REGISTERS.
UPTDEL:	SAVE <B,C,D>		;SAVE THE GIP AND OTHER REG
	JSR PC,UPTPLD		;LOAD THE UPT INTO ITEM2 AFTER PUSH
	TST (B)			;IS THERE ANYTHING HERE?
	BNE UPTDL1		;YES
	CMP ITEM2,#-1		;WAS IT IN A SPHERE?
	BEQ UPTRT		;NO, WE ARE DONE
	CMP B,#<ITM2AD+SUPTS+<10*UPTLEN>>
				;THAT FOO CHECKS TO SEE IF IT IS A DATA PAGE
	BLT .+10		;IT WASN'T
	BIC #UPTDEI,-<10*UPTLEN>(B)	;THAT MAKES SURE THAT THE D=I BIT GETS CLEARED
UPTRT:	JSR PC,ITM2PO		;CLEAN OFF THE ITEM STACK
	REST <D,C,B>
	RTS PC
UPTDL1:	BIT #UPTABT,UPTAR(B)	;IS IT AN ABSOLUTE PAGE?
	BNE UPTDL2		;NO,UGH
	MOV B,D			;SAVE THE POINTER TO THE UPT
	JSR PC,UNLINK		;UNLINK THE UPT
;HERE UPDATE THE CPT
	MOV #UPTLEN/2,B		;GET THE LENGTH OF THE UPT IN WORDS
	CLR (D)+		;CLEAR THE WORDS OF THE UPT
	SOB B,.-2
	BR UPTRT
UPTDL2:	HALT
;THIS IS A ROUTINE THAT WILL LINK A UPT OUT OF
;THE CIRCULAR LIST OF UPT'S, AND IF THERE IS ONLY ONE
;LEFT IT WILL UNCIRCULARIZE THE LIST.  IF THERE IS NO
;CIRCULAR LIST, IT RETURNS SETTING Z. ELSE CLEARS Z.
;IT TAKES A GENERALIZED ITEM POINTER IN B TO THE UPT.
;IT RETURNS IN C WHAT THE UPT IT UNLINKED USED TO POINT TO
UNLINK:	MOV B,F			;SAVE THE POINTER
	BIT #GIPBIT,B		;IS IT A GIP
	BNE .+4			;YES
	BPT
	JSR PC,UPTPLD		;LOAD THE UPT INTO ITEM2
	MOV UPTCLP(B),B		;GET THE NEXT POINTER
	MOV B,C			;SAVE THIS FOR LATER
	BNE UNLNK1		;THERE IS A CIRCULAR LIST
	JSR PC,ITM2PO		;POP ITEM2 PUSHED BY UPTPLD
	CLR C			;CLEAR THE FORWARD POINTER
	RTS PC
UNLNK1:	JSR PC,UPTLD		;LOAD THE NEXT UPT
	CMP UPTCLP(B),F		;DOES THIS POINT TO THE FIRST UPT
	BEQ UNLNK2		;YES
	MOV UPTCLP(B),B		;GET THE NEXT POINTER
	BNE UNLNK1		;THERE IS A NEXT POINTER
	BPT
UNLNK2:	MOV C,UPTCLP(B)		;UPDATE THE UPT CIRCULAR POINTER
	MOV C,B			;CHECK THAT THERE ARE MORE THAN ONE
	JSR PC,UPTLD		;LOAD THE NEW FORWARD POINTER
	CMP C,UPTCLP(B)		;DOES THE UPT POINT TO ITSELF?
	BNE .+6			;NOPE
	CLR UPTCLP(B)		;NOW IT DOESN'T
	JSR PC,ITM2PO		;POP THE ITEM STACK PUSHED BY UPTPLD
	SEZ			;SET FLAG
	RTS PC
;PUSH ITEM2 AND THEN FALL INTO LOAD A UPT
;GIP IS IN B
;RETURN CORE ADDRESS IN B

UPTPLD:	SAVE <A>
	MOV #-1,A		;MAKE IT NXM
	JSR PC,ITM2PL
	REST <A>
UPTLD:	TST B
	BNE .+4
	BPT
	BIT #40000,B		;THIS BIT SET IN SPHERE UPT
	BNE UPTL.1
	ADD #<100000+FUPTTB>,B	;FUPT CORE ADDRESS
	RTS PC
UPTL.1:	SAVE <A>
	MOV B,A
	BIC #GIPITM,A		;GET THE ITEM NUMBER
	JSR PC,ITM2LD		;LOAD THE SPHERE OVER THIS ITEM
	BIC #GIPUPT,B		;GET THE UPT NUMBER
	SWAB B
	ASH #-2,B	;GET THE UPT NO.
	MUL #UPTLEN,B
	ADD A,B
	ADD #SUPTS,B
	REST <A>
	RTS PC

;LOAD WHAT A UPT DESCRRIBES INTO ITEM2
;(B) IS GIP
;RETURN ADDRESS IN E

GIP2LD:	JSR PC,UPTLD
	MOV UPTAR(B),E
	MOV UPTDR(B),D
	BIC #UPASMS,E
	BIC #UPTSMS,D
	MOV E,ITM2AR
	MOV D,ITM2DR
	MOV ITM2A,E
	RTS PC
	.SBTTL CLOCK AND PIRQ ROUTINES
;ENTERED BY AN INTERUPT FROM EITHER THE LINE CLOCK OR THE PROGRAMABLE
;CLOCK. HOPEFULLY, ONLY ONE OF THESE WILL BE ENABLED!
LCBRK:
PCBRK:	JSR F,ACSAV	;SAVE THE ACS
	INC TIME	;INCREASE TIME-SINCE-SYSTEM UP
	BNE .+6		;OVERFLOW?
	INC TIME+2	;YUP
	BIT #1,TIME	;DO THIS ONLY EVERY OTHER TICK
	BNE .+6
	JSR PC,CLKTTY	;PROCESS CHARACTERS
	INC TUSED	;ONE MORE TICK FOR THIS USER
	DEC STIMER	;MAINTAIN TIMERS
	DEC LTIMER
	DEC TIMTSS
	DEC JMTUUP	;TIME TO UPDATE THE JMTUS?
	BNE .+6		;NOT YET
	JSR PC,JMTUU	;GO UPDATE THEM
	DEC QUANT	;HAS THE CURRENT USER OVERSTAYED HIS WELCOME?
	BGT CLKRET	;NO, RETURN TO MAIN PROGRAM
	BIS #CLKPIR,PIRQ	;CAUSE THE STOP USER ROUTINE TO RUN
CLKRET:	JSR F,ACRES	;RESTORE THE ACS
	RTT

;THIS IS ENTERED BY THE PROGRAM INTERUPT REQUEST
;CURRENTLY IT IS ONLY USED FOR THE "CLOCK", BUT ITS DISPATCH
;TABLE COULD ACCOMADATE USES FOR OTHER LEVELS
PIRBRK:	SAVE A		;SAVE A REGISTER
	MOV PIRQ,A	;GET THE INTERUPT LEVEL
	BIC #177761,A	;USE AS AN INDEX TO DISPATCH
	BIC PIRBIT(A),PIRQ	;CLEAR THE RIGHT BIT
	MOVB PIRQ,PS	;SET PRIORITY OF PROCESSOR TO PRIORITY
			;LEVEL RESPONSABLE FOR THIS INTERUPT
	JMP @PIRDIS(A)
PIRLOS:	BPT	;UNIMPLEMENTED LEVELS COME HERE
	BR .-2

;UPDATE JMTUS ON ALL QUEUES.
JMTUU:	MOV #JMTUUT,JMTUUP	;RESTORE TIME TILL NEXT UPDATE
	MOV #FIRSTQ,A	;BEGGINING OF THE QUEUE POINTERS
	MOV #NQS,B	;NUMBER OF QUEUES THAT EXIST
JMTUU1:	MOV (A),C	;POINTER TO BEGGINING OF QUEUE
	BEQ JMTUU2	;NOBODY THERE!
JMTUU4:	MOV PRTJMT(C),F	;GET THE JMTU
	BEQ JMTUU3	;IT'S ALREADY ZERO, FORGET IT
	CLR E		;FOR THE DIVIDE
	DIV #JMTUDC,E	;FIND OUT HOW MUCH TO DECAY BY
	INC E		;MAKE SURE IT EVENTUALLY GETS TO ZERO
	SUB E,PRTJMT(C)	;DECAY IT
JMTUU3:	MOV (C),C	;GO DOWN THE LINK
	BNE JMTUU4	;MORE ON THIS QUEUE
JMTUU2:	ADD #QLEN,A	;GO TO NEXT QUEUE
	SOB B,JMTUU1	;GO THROUGH ALL QUEUES
	RTS PC
	.SBTTL SCHEDULING ROUTINES
;THE SYSTEM'S MAIN LOOP
;ENTERED AT SCHED, NEVER EXITED
SCHED:	JSR PC,RUNBPS	;FOR NOW, JUST RUN THE BEST USER
	JSR PC,SWAPSC
	TST RUNQ	;IS ANYONE RUNNABLE?
	BEQ SCHED1	;NO, GO TRY EVERYONE
	TST STIMER	;IS IT TIME TO CHECK SHORT-FLUSHED GUYS?
	BGT SCHED2	;NOT YET
	MOV #STIMEL,STIMER	;RESET THE TIMER
	MOV #SFLSQ,A
	JSR PC,CHKQ	;GO CHECK THEM ALL
	MOV #PAGWQ,A	;CHECK GUYS WAITING FOR PAGES TOO
	JSR PC,CHKQ
SCHED2:	TST LTIMER	;TIME TO CHECK THE LONG FLUSHED GUYS?
	BGT SCHED3	;NOPE, NOT YET
	MOV #LTIMEL,LTIMER
	MOV #LFLSQ,A
	JSR PC,CHKQ
SCHED3:	BR SCHED	;NOW GO RUN THE BEST ONE
SCHED1:	MOV #SFLSQ,A	;CHECK THE SHORT ONES
	JSR PC,CHKQ
	MOV #PAGWQ,A	;AND THE LONG ONES
	JSR PC,CHKQ
	TST RUNQ	;DID WE CATCH ANY?
	BNE SCHED	;YUP, TRY ONE
	MOV #LFLSQ,A	;OH WELL, TRY THE LONG ONES
	JSR PC,CHKQ
	BR SCHED
SWAPSC:	TST TIMTSS
	BLE .+4
	RTS PC
SWAPO:	HALT		;SWAP HERE I GUESS
;SWAPO NEDED TO BE DEFINED SO I PUT IT HERE,  FMH
;CHECK RUNNABILITY OF A PROCESS
;PROCESS TABLE ENTRY IN A
;MIGHT CLOBBER ALL REGISTERS
CHKPRS:	MOV PRTPPT(A),A	;GET THE ITEM
	JSR PC,ITM0LD
	SAVE PSPC(A)	;GET THE PLACE TO CONTINUE IT AT
	BNE .+4		;MAKE SURE IT IS NON-ZERO
	BPT		;UGH! BLETCH! BARF!
	MOV PSPHRP(A),A	;GET THE SPHERE
	JSR PC,ITM1LD
	MOV ITM0A,A
	ADD #PSREGS+14,A	;POINTER TO REGISTERS
.IRPC X,<FEDCBA>
	MOV -(A),X
.ENDM
	RTS PC

;CHECK RUNNABLITY OF PROCESSES ON QUEUE IN A
;MAY CLOBBER ALL REGISTERS
CHKQ:	SAVE (A)
CHKQ1:	MOV (P),A	;GET THE NEXT IN LINE TO CHECK
	BEQ CHKQ2	;NO MORE
	MOV (A),(P)	;LINK THROUGH FOR NEXT TIME
	JSR PC,CHKPRS	;CHECK IT
	BR CHKQ1
CHKQ2:	REST A
	RTS PC

;RUN THE BEST PROCESS ON THE RUN QUEUE
;CLOBBERS ALL REGISTERS
RUNBPS:	MOV RUNQ,A	;START OF GUYS TO RUN
	BNE RUNBP1	;SOME THERE FIND HIM
	WAIT		;TWIDDLE YOUR THUMBS
	RTS PC		;I GIVE UP!
RUNBP1:	SAVE <#-1,#77777,#-1,#-1,#77777,#-1>
RUNBP2:	MOV PRTUPT(A),B	;WHO IS THIS GUY'S USER?
	CMP 6(P),B	;SAME GUY WHO IS ALREADY BEST?
	BEQ RUNBP3	;YES, GO SEE IF THIS PROCESS IS BETTER
	MOV PRTPRI(B),E	;GET THE PRIORITY MULITPLE FOR THIS GUY
	BIC #177760,E	;MASK IT TO 4 BITS
	MUL PRTJMT(B),E	;GET THE NET PRIOTIRTY
	CMP E,10(P)	;HIGH PART > THAN OLD HIGH PART?
	BLO RUNBP4	;NO, THIS USER IS BETTER!
	BHI RUNBP6	;YES, THIS USER NOT AS GOOD
	CMP F,12(P)	;HIGH ORDER EQUAL, TRY LOW
	BHIS RUNBP6	;SAME OR WORSE
RUNBP4:	MOV B,6(P)	;THIS IS THE NEW BEST USER
	MOV E,10(P)	;AND HERE IS HIS PRIORITY
	MOV F,12(P)
	MOV PRTPRI(A),E	;NOW COMPUTE PRIORITY FOR THIS PROCESS
	BIC #177760,E
	MUL PRTJMT(A),E
RUNBP5:	MOV A,(P)	;THIS IS NOW THE BEST PROCESS
	MOV E,2(P)	;AND THIS IS IT'S PRIORITY
	MOV F,4(P)
RUNBP6:	MOV (A),A	;NEXT ONE ON THE QUEUE
	BNE RUNBP2	;GO SEE IF HE IS BETTER
	REST A		;THIS ONE IS BEST
	ADD #12,P	;FLUSH THE CRAP OFF THE STACK
	MOV PQUANT,QUANT	;HOW LONG TO RUN HIM FOR
	JMP STPROC	;GO TO IT (WILL RETURN TO CALLER OF RUNBPR)
RUNBP3:	MOV PRTPRI(A),E	;SAME USER, IS THIS PROCESS BETTER?
	BIC #177760,E
	MUL PRTJMT(A),E
	CMP E,2(P)	;IS THE HIGH PART BETTER?
	BLO RUNBP5	;YUP, HE'S NOW BEST
	BHI RUNBP6	;NOPE, OLD GUY IS BEST
	CMP F,4(P)	;SAME HIGH PARTS, WHAT ABOUT LOW?
	BHIS RUNBP6	;OLD GUY BEST
	BR RUNBP5	;NEW GUY BEST
	.SBTTL LOCK SWITCH ROUTINES
;GET A LOCKED SWITCH BLOCK AND STUFF THE TYPE AND ITEM INTO IT
;AND LINK IT INTO THE CURRENT PROCESS'S LOCKED LIST
;CALL WITH TYPE IN A, ITEM IN B
;PUTS ADDRESS OF BLOCK INTO A, CLOBBERS B
LOCKSW:	TST LCKFRE	;ARE THERE ANY FREE LOCKS?
	BNE LOCKS1	;YES, GO GOBBLE
LOCKS3:	BPT		;WE JUST RAN OUT OF LOCK BLOCKS!!!
			;NO GARENTEES IF YOU PROCEED FROM HERE, BUT IT WILL TRY
	JSR PC,SFLUSH	;WAIT A WHILE
	TST LCKFRE	;TRY AGAIN
	BNE LOCKS3	;NONE YET
	JSR PC,RUNME	;HOPEFULLY, WE CAN GET ONE NOW
	BR LOCKSW	;TRY AGAIN
LOCKS1:	SAVE A
	CLR A		;TO DO THE SILLY DIVIDE
	DIV #ITMTEL,A	;TO CONVERT INDEX TO NUMBER
	BIS A,(P)	;SET NUMBER INTO TYPE
	MOV LCKFRE,A	;GET THE FREE LOCK BLOCK
	MOV (A),LCKFRE	;SPLICE IT OUT
	REST LCKTIT(A)	;POP THE THING INTO THE TYPE AND ITEM
	MOV ITM0A,B	;ADDRESS OF THE PROCESS
	MOV PLCKSL(B),(A)	;PUT IT INTO LIST FOR THIS PROCESS
	MOV A,PLCKSL(B)
	MOV #-1,LCKWD1(A)	;LOCK NOT REALLY USED YET
	CLR LCKWD2(A)
	RTS PC
;LOCK A PARTICULAR SWITCH
;A HAS THE ADDRESS OF THE SWITCH, OR THE OFFSET INTO THE SPHERE
;B HAS THE BIT(S) WHICH ARE TO BE LOCKED
;C HAS THE ITEM NO THAT THE SWITCH IS IN  (OR 0 IF ABSOLUTE)
LCKASW:	TST INITSW	;NO SWITCHES LOCKED IN THE INIT CODE
	BNE LOCKA5
	SAVE <D,A>
	MOV #LONOFF,A	;THE TYPE OF LOCK
	SAVE B
	MOV C,B		;THE ITEM NO. OF THE SPHERE
	JSR PC,LOCKSW	;GET A LOCK
	REST B
	MOV A,D		;SAVE POINTER TO THE LOCK
LOCKA2:	MOV C,A		;THE SPHERE NO. THAT THE SWITCH IS IN
	BEQ .+6		;NO ITEM
	JSR PC,ITM1PL	;LOAD IT UP
	ADD (P),A	;MAKE A POINT TO THE SWITCH
	BIT B,(A)	;IS THE LOCK UNLOCKED?
	BEQ LOCKA1	;YES
LOCKA3:	TST C		;ANY ITEM PUSHES
	BEQ .+6		;NOPE
	JSR PC,ITM1PO	;POP THE SPHERE
	JSR PC,SFLUSH	;TWIDDLE OUR THUMBS
	MOV C,A		;THE SPHERE NO.
	JSR PC,ITM1PL	;LOAD IT UP
	ADD (P),A	;MAKE A POINT TO THE SWITCH
	BIT B,(A)	;IS IT UNLOCKED YET
	BNE LOCKA3	;NOT YET
	TST C		;IS THE SWITCH IN AN ITEM
	BEQ .+6		;NOPE
	JSR PC,ITM1PO	;POP THE SPHERE
	JSR PC,RUNME	;I THINK I HAVE GOT IT
	BR LOCKA2	;MAKE SURE
LOCKA1:	BIS B,(A)	;LOCK THE SWITCH
	TST C		;ANY ITEM PUSHED
	BEQ .+6		;NOPE
	JSR PC,ITM1PO	;POP THE SPHERE
	REST A		;GET THE POINTER TO THE LOCK
	MOV A,LCKWD1(D)	;SAY THIS LOCK IS USED
	MOV B,LCKWD2(D)	;THE BITS LOCKED
	REST D		;GET ORIGINAL CONTENTS OF D
LOCKA5:	RTS PC
;POP THE TOP LOCK OFF THE LOCKED SWITCH LIST
LSWPOP:	TST INITSW	;ARE WE IN INIT CODE?
	BNE LSWPO2	;NO SWITCHES EVER LOCKED
	SAVE <A,B,C>
	MOV ITM0A,A	;ASSUME ITEM0 IS THE PROCESS WHICH IS UNLOCKING
	MOV PLCKSL(A),B	;SPLICE LOCK OUT OF IT'S LIST
	BNE .+4		;ONLY SHOULD GET CALLED IF ANYTHING IS LOCKED
	BPT		;OOPS!
	MOV (B),PLCKSL(A)
	MOV LCKFRE,(B)	;PUT IT ONTO THE FREE LIST
	MOV B,LCKFRE
	CMP #-1,LCKWD1(B)	;IS IT FOR REAL?
	BEQ LSWPOR	;NOPE, WE HAVE "UNLOCKED" IT
	SAVE B		;FOR THE ROUTINES WE CALL
	MOV LCKTIT(B),B	;GET THE TYPE
	MOV #-1,A	;MAKE ITEM NXM (FOR THE SAKE OF THE PUSH)
	JSR PC,ITM2PL
	SAVE B		;SAVE TYPE AND ITEM
	CLR A		;IN CASE THERE IS NO ITEM
	BIC #176000,B	;GET THE ITEM
	BEQ LSWPO1	;NOPE, NO ITEM
	MUL #ITMTEL,B	;CONVERT TO INDEX
	MOV B,A
	JSR PC,ITM2LD	;SAVE IT AWAY
LSWPO1:	REST <C,B>		;GET BACK FOR TYPE
	ASH #-9.,C
	BIC #177601,C	;MAKE IT INTO A 6 BIT INDEX
	JMP @LCKDIS(C)	;DISPATCH ON TYPE

LSPONF:	ADD LCKWD1(B),A	;POINT INTO ITEM IF THERE IS ONE
	BIC LCKWD2(B),(A)	;UNLOCK ON-OFF TYPE LOCK
LSWPOR:	JSR PC,ITM2PO	;POP THE ITEM STACK
	REST <C,B,A>
LSWPO2:	RTS PC
LSPERR:	BPT		;GASP! BAD LOCK TYPE
	BR .-2
LSPPCL:	TST BPCLSR	;IS HE BEING PCLSRED?
	BEQ LSWPOR	;IF NO, GO AWAY
LSPRTN:	JSR PC,@LCKWD1(B)	;BEING PCLSRED, RUN ROUTINE
	BR LSWPOR	;ALL DONE WITH THIS SWITCH
LSPDEC:	ADD LCKWD1(B),A	;GET ABSOULUTE ADDRESS
	DEC (A)		;FIXUP THE FLAG
	BNE LSWPOR	;IF NOT ZERO, ALL DONE
	TST LCKWD2(B)	;IS THERE A ROUTINE TO RUN ON ZERO FLAG?
	BEQ LSWPOR	;NO, FINISHED THEN
	JSR PC,@LCKWD2(B)	;CALL THE ROUTINE
	BR LSWPOR
;THE DELETE ON PCLOSERING ROUTINE, FOR THINGS THAT NEED ITEMS FLUSHED
PCLDLI:	MOV ITEM2,A
	JMP DLITEM	;THE LOADED ITEM IS GETTING FLUSHED

	.SBTTL MEMORY MANAGMENT ROUTINES
;MAP RESTORE ROUTINE
;CLOBBERS NO REGISTERS
;EXPECTS THE SPHERE TO RESTORE IN ITEM1
;DOES NOT RESTORE IF CURSPH IS SAME AS ITEM1
MAPRES:	CMP CURSPH,ITEM1	;IS IT ALREADY LOADED?
	BEQ MAPRE6		;YES
	MOV ITEM1,CURSPH
MAPRE1:	SAVE <A,B,C>	;THIS IS THE ENTRY POINT FOR RESTORING THE MAP EVERY TIME
	MOV ITM1A,A	;POINTER TO THE ITEM
	ADD #SUPTS,A	;GET POINTER TO UPTS FOR SPHERE
	MOV #USRISD,B	;POINT TO USER MAP
	MOV #20,C	;NUMBER OF SEGMENTS TO LOAD
MAPRE2:	CLR (B)		;CLEAR OUT THE OLD REGISTER
	TST (A)		;DOES THE PAGE EXIST?
	BEQ MAPRE3	;NO PAGE HERE
	BLT MAPRE4	;SAME AS COORESPONDING I PAGE
	TST UPTAR(A)	;IS IT AN ABSOLUTE PAGE?
	BLT MAPRE5	;YUP, GO LOAD IT
	HALT		;HERE, LOAD A NON-ABSOLUTE PAGE
			;(OR DON'T IF IT'S NOT SWAPPED IN OR IN MOTION)


MAPRE5:	MOV (A),(B)	;ABSOLUTE PAGE IS SIMPLE
	MOV UPTAR(A),USRISA-USRISD(B)	;COPY AR
MAPRE3:	TST (B)+	;INCREMENT POINTER TO SEG REGISTERS
	ADD #UPTLEN,A	;AND POINTER TO UPTS
	SOB C,MAPRE2	;GO BACK IF NOT FINISHED
	REST <C,B,A>
MAPRE6:	RTS PC

MAPRE4:	CMP #10,C	;IS IT REAL A DATA PAGE?
	BGE .+4
	BPT		;<STICK OUT TONGUE WHEN YOU READ THIS LINE>
	MOV USRISD-USRDSD(B),(B)	;DR FROM I-SPACE PAGE
	MOV USRISA-USRDSD(B),USRISA-USRISD(B)	;SAME FOR AR
	BR MAPRE3
;INTIAL MAP-SETTING ROUTINE
;CLOBBERS MOST AC'S, INTENDED TO BE RUN ONLY AT ITIALIZE TIME
;OR AFTER A POWER FAIL RESTART
MAPSET:	MOV #I0AR,A	;FIRST WE'LL SET UP A STRAIGHT MAP
	CLR B		;I AND D SPACE THE SAME AND MAPPED DIRECTLY
	MOV #8.,C	;FROM VIRTUAL CORE TO PHYSICAL
MAPST1:	MOV #77406,VAR0DR-I0AR(A)	;DATA SPACE 4K SEGEMNET
	MOV #77406,I0DR-I0AR(A)		;INSTRUCTION SPACE 4K SEGMENT
	MOV B,VAR0AR-I0AR(A)		;VIRTUAL MAPPED DIRECTLY TO PHYSICAL
	MOV B,(A)+			;FOR BOTH INST AND DATA SPACE
	ADD #200,B	;4K WORTH
	SOB C,MAPST1	;DO FORR 8 SEGMENTS
	;NOW WE'LL HACK THE SPEECAIL THINGS
	MOV #7600,IOAR	;MAP USUAL I/O SPACE TO REAL I/O SPACE
;THE FOLLOWING THING IS THE DR FOR THE RUG PAGES (UGH!)
FOO==<<200-<<RUGIDR-I0DR+2>*100>+<<RUGST_-6>&1777>>_8.>+16
	MOV #FOO,RUGIDR	;SPECIAL RUG SEGMENT
	MOV #FOO,RUGDDR	;MAP 156000-157776 VIRTUAL TO SAME PHYSICAL
	MOV #VAR2DR,A	;NOW FLUSH UNUSED VARIABLE PAGE AND 3 ITEM PAGES
	CLR (A)+
	CLR (A)+
	CLR (A)+
	CLR (A)
	MOV #I7DR,A
	CLR (A)		;FLUSH HIGH INSTRUCTION PAGE
	TST -(A)	;DON'T CLOBBER RUG PAGE
	MOV #120000,B	;FIRST LOCATION IN A PAGE BEFORE RUG PAGE
MAPST2:	CMP #LSTILC,B	;LAST INSTRUCTION LOCATION
	BHI MAPST3	;IF THERE IS SOMETHING THERE, WE'RE DONE
	CLR -(A)	;NO ONE THERE, FLUSH IT
	SUB #20000,B	;NEXT PAGE DOWN
	BR MAPST2
MAPST3:	MOV #7,SSR3	;ENABLE I AND D FOR ALL MAPS
	MOV #1,SSR0	;THERE WE GO!!
	RTS PC
;THE MEMORY TABLE INITIALIZER
;CLOBBERS ALL REGISTERS
MEMTST:	CLR ITM0AR	;FIRST FIND HOW MUCH MEMORY
	MOV #6,ITM0DR	;LENGTH 1 PAGE
	SAVE BEBRV	;SAVE THE BUSS ERROR VECTOR
	MOV #MEMTS1,BEBRV	;TRAP BACK TO THE ROUTINE
	MOV #MNCBLK,A		;THE MOST WE WILL PAY ATTENTION TO
	MOV #CST,B
MEMTS2:	TST ITM0AD	;CAUSE BUSS ERROR IF NXM
	ADD #20,ITM0AR	;INCREMENT BY 512 WORDS
	MOV #CSTBEB!CSTSYB,(B)+	;SAY IT EXISTS AND SYSTEM USING IT
	SOB A,MEMTS2	;TRY AGAIN UNLESS WE HAVE ENOUGH
	BR MEMTS3
MEMTS1:	SPL 0
	CMP (P)+,(P)+	;FLUSH THE TRAP
	REST BEBRV
	MOV #CSTSYB,(B)+	;SAY THE SYSTEM IS USING NON-EX CORE
	SOB A,.-4
MEMTS3:	MOV ITM0AR,B
	SUB #<<RUGIAR-I0AR>+2>*100,B	;CONVERT TO AMOUNT ABOVE RUG
	BGE .+4		;IS THERE ENOGUH FOR RUG
	BPT		;NO!!!!
	ASH #-4,B	;CONVERT TO 512 WORD BLOCKS
	MOV B,NUMBLKS
	MOV #<<RUGIAR-I0AR>+2>*4,A	;FIRST BLOCK AFTER RUG
	JSR PC,MEMALC	;NOW GO SEE WHAT WE CAN GET FROM THIS
	MOV #FSTFRB,A	;FROM FIRST FREE BLOCK
	MOV #<<RUGST-LSTILC>_-10.>&77,B	;NUMBER FREE BEFORE RUG
	ADD B,NUMBLKS
;FALL INTO MEMALC TO USE UP SPACE BETWEEN END OF CODE AND RUG
MEMALC:	MOV A,C		;THE BEGGINING OF THE AREA
	ASL C		;CONVERT TO A WORD INDEX
	ADD #CST,C	;WE WILL USE IT TO SET THE CST
	MOV #2,-(P)	;FIRST CPT INDEX TO USE
	TST -(P)	;AND A FREE WORD
MEMAL1:	MOV #10,D	;INDEX TO SIZE-INDEXED TABLES
MEMAL7:	ASL D		;CONVERT BACK TO INDEX
MEMAL2:	MOV MEMIAT-2(D),(P)	;NUMBER OF THINGS THIS SIZE TO TRY TO ALLOCATE
	BEQ MEMAL4	;OOOPS, NONE THIS SIZE PLEASE!
MEMAL5:	ASR D		;CONVERT INDEX TO COUNT
	TST B		;IS THERE ANY LEFT?
	BEQ MEMAL3	;NOPE! GOODBYE.
	CMP D,B		;DO WE HAVE ENOGUH FOR THIS SIZE BLOCK?
	BGT MEMAL6	;NOPE, TRY A SMALLER ONE
	BIS #CSTFBB!CSTFRB,(C)	;THE BEGINNING OF A FREE PAGE
	MOV D,E		;THE SIZE OF THE PAGE
	ADD 2(P),(C)+	;THE CPT INDEX
	SOB E,.-4	;IN ALL THE CST WORDS FOR THIS PAGE
;FALL THROUGH TO NEXT PAGE
;FALL IN FROM PREVIOUS PAGE
	MOV 2(P),E	;GET THE CPT INDEX
	ADD #CPTLEN,2(P)	;MOV TO NEXT CPT BLOCK
	CMP #CPTEND,E	;MAKE SURE WE DON'T GO OFF THE END
	BGT .+4		;BRANCH IF NOT OFF THE END
	BPT		;!
	ASL D		;BACK TO AN INDEX AGIAN
	MOV FMMALT-2(D),CPT(E)	;LINK INTO FREE LIST FOR THIS SIZE
	MOV E,FMMALT-2(D)
	MOV #-1,CPT+CPTUPP(E)	;THE UPT POINTER=NULL
	MOV A,CPT+CPTADR(E)	;THE CORE ADDRESS
	ASR D		;BACK TO COUNT
	ADD D,A		;INCREMENT ADDRESS
	SUB D,B		;DECREMENT SPACE LEFT
	ASL D		;BACK AGAIN
	DEC (P)		;DONE ALL OF THIS SIZE?
	BNE MEMAL5	;NOT YET
MEMAL4:	ASR D	;BACK TO COUNT
MEMAL6:	SOB D,MEMAL7
	BR MEMAL1	;DO IT ALL AGAIN
MEMAL3:	CMP (P)+,(P)+	;RESTRE STACK
	RTS PC
	.SBTTL ROUTINES THAT ARE NOT YET WRITTEN

BPTBRK:	HALT
	RTI
BEBRK:	HALT
	RTI
IOTBRK:	HALT
	RTI
	.SBTTL EMT HANDLERS
;GET HERE WHEN A USER EXECUTES AN EMT
EMTBRK:	CMPB #60,PS+1	;MAKE SURE IT CAM FROM USER MODE
	BEQ .+4
	BPT		;ERF!
	MOV PC,USRMOD	;NOW WE AREIN THE SYSTEM!
	JSR F,SPCPSP	;SAVE THE USER'S PC, PS AND PDL POINTER
	CLR PUPDLO(A)	;NOTHING POPED YET
	SUB #2,PUPC(A)	;POINT TO THE CALL ITSELF
	MFPI @PUPC(A)	;GET THE ACTUAL CALL
	REST B		;POP IT OFF THE STACK
	ASL B		;CONVERT IT TO A WORD INDEX
	BIC #177001,B	;8 BITS ARE SIGNIFICANT
	CMP #EMTHGH*2,B	;IS IT TOO HIGH?
	BLOS BADEMT	;YUP, TELL HIM HE IS A LOSER
	SAVE PS		;NOTE THAT TRACE TRAPS WILL ACT STRANGELY HERE
	BIC #357,(P)	;PRIORITY 0
	SAVE EMTDIS(B)	;DISPATCH ADDRESS
	RTI
BADEMT:	HALT
CFAULT:	HALT

;RETURN FROM EMT TO USER
ENOOP:
EMTRET:	SAVE PS		;FOR THE CONDITION CODES
	MOV ITM0A,A	;PROCESS HAD BETTER BE THERE
EMTRE1:	TST PLCKSL(A)	;DOES HE HAVE ANY SWITCHES LOCKED?
	BEQ EMTRE2		;NOPE
	JSR PC,LSWPOP	;POP TOP ONE
	BR EMTRE1	;AND TRY AGAIN
EMTRE2:	CLR PSPC(A)	;NOT IN THE SYS ANYMORE
	MOVB PUPS+1(A),1(P)	;GO BACK TO USER MODE PROPERLY
	SAVE PUP(A)	;GET HIS OLD P ONTO MY STACK
	ADD PUPDLO(A),(P)	;ANYTHING POPED FROM IT?
	MTPI P		;RESTORE P FOR HIM
	SAVE PUPC(A)	;PUT THE PC ON THE STACK NOW
	ADD #2,(P)	;START HIM AFTER THE CALL
	MOV A,B		;THE ITEM ADDRESS
	JSR PC,PACRES	;RESTORE HIS AC'S
	SPL CLKL	;PREVENT A SCHEDULE
	CLR USRMOD	;THIS COULD CAUSE ONE
	TST QUANT	;HAS HE OVERSTAYED HIS WELCOME?
	BGE .+10	;NO
	BIS #CLKPIR,PIRQ	;GET HIM AFTER THE RTI
	RTI		;GO TO USER MODE
;THIS IS THE SYSTEM CALL THAT SETS UP THE SWAPPING BIT TABLES.  BASICALLY, THE SYSTEM
;SHPERE GETS CAPABILITIES TO ALL THE ROOT DIRECTORIES OF ALL THE DISKS.  IT THEN COPIES
;THEM AND TURNS THE COPIES INTO FILE CAPABILITIES TO THE DESCRIPTOR FILES OF THE DISKS
;IT THEN DOES BLKIN'S AND READS THE FIRST 5 WORDS OF THE DESCRIPTOR FILE, OF ALL THE 
;FILES.  IT THEN  PUTS THE LAST FOUR WORDS OF ALL THE TABLES INTO CONTIGUOUS LOCATIONS
;AND PUSHES A COUNT OF HOW MANY DISK, THE SECOND WORD IS THE POINTER TO THE WORDS OF THE
;DESCRIPTOR FILES. THIS ROUTINE LOCKS A SWITCH THAT DOESN'T ALLOW THIS ROUTINE TO BE
;CALLED AGAIN.

EALLOC:	TST SWPDON	;HAVE WE DONE THIS BEFORE
	BEQ .+6		;NO
	JMP BADEMT	;THIS SHOULD ONLY BE CALLED ONCE
	JSR PC,RETNSW	;GET THE COUNT
	MOV A,F		;THE NUMBER OF TABLES TO ALLOCATE
	JSR PC,RETNSW	;THE POINTER TO THE TABLES
	MOV A,E		;SAVE IT
	TST F		;ANY TABLES TO ALLOCATE
	BEQ ALOCRT	;NO, JUST RETURN
	MOV #SSPBTP,A	;POINTER TO WHERE THE FIRST SMALL BIT TABLE POINTER
	MOV #LSPBTP,B	;POINTER TO WHERE THE FIRST LARGE BITTABLE POINTER
	MOV #BITTAB,C	;THE START OF THE ACTUAL STORAGE FOR THE TABLES
BTALOC:	MFPD (E)+	;GET THE LOGICAL DISK NO.
	MFPD (E)+	;GET THE STARTING ADDRESS SWAP AREA
	MFPD (E)+	;GET THE LENGTH OF THE SWAP AREA
	JSR PC,BTABLE	;ALLOCATE A BIT TABLE
	ADD #6,P	;POP THE PREVIOUS INFO
	SOB F,BTALOC	;DO IT FOR ALL THE SWAP AREAS
ALOCRT:	MOV #-1,SWPDON	;LOCK THE ROUTINE
	JMP ERETCZ	;SUCCEED

;PROCESS HACKING EMTS
;.FORK:
;1 ARGUMENT IS ADDRESS OF PLACE TO START NEW PROCESS
;CLEARS Z IF IT SUCEEDS IN CREATING A NEW PROCESS
EFORK:	MFPD @PUP(A)	;GET THE PLACE TO START IT
	MOV #2,PUPDLO(A)	;INDICATE THAT AN ARG SHOULD BE POPED
	JSR PC,CRPROC	;ATTEMPT TO CREATE A PROCESS
	BEQ EFORK1	;FAIL
	MOV CURSPH,B	;PUT IT INTO THE CURRENT PROCESS
	JSR PC,PUTPRS
	JSR PC,ITM0PL	;LOAD IT TEMPORARILLY
	REST PUPC(A)	;SET ITS PC
	BIC #PSUPSB,PSTOP(A)	;CLEAR THE STOP BIT
	JSR PC,PSTPDC	;GO START IT
	JSR PC,ITM0PO	;POP ITEM STACK
ERETCZ:	CLZ		;SUCESS
EFORK1:	JMP EMTRET

;.POOFF:
;NO ARGUMENT. MAKE THE PROCESS EXECUTING ITDISAPPEAR WITHOUT A TRACE
;CURRENTLY, THE PROCESS IS ONLY STOPPED
;IF THERE ARE ANY REFERENCES TO ITREMAINING
EPOOFF:	MOV PRUNNG,A	;THE PROCESS THATIS RUNNING
	JSR PC,PSTPIN	;INCREMENT THE STOP WORD
	JSR PC,DLPROC	;DECREMENT REFERENCE COUTN AND DELETE IF ZERO
	RTS PC		;HOPEFULLY, RETURN TO SCHEDULER
;.INVOKE:
;1 ARG IS CAPABILITY NUMBER TO INVOKE AND MAYBE FLAGS
;MORE ARGS MAY BE TAKEN IF CAPABILTY WANTS THEM
;BUT THERE MUST ALWAYS BE 3 THINGS ON THE STACK AND 3 THINGS WILL BE POPPED
EINVOK:	SUB #6,P	;CREATE 3 WORDS OF TEMP STORAGE FOR ARG
	JSR PC,RETNSW	;GET THE TOP OF THE STACK
	MOV A,(P)	;LOTS OF PEOPLE WILL WANT IT
	JSR PC,RETNSW	;GET 2ND ARG
	MOV A,2(P)	;SAVE IT
	JSR PC,RETNSW	;GET 3RD ARG
	MOV A,4(P)	;SAVE LAST ARG
	MOV ITM1A,A	;GET ADDRESS OF SPHERE
	MOV (P),B	;THE CAP NUMBER
	BIC #177400,B	;CLEAR WHATEVER IS THERE
	MOV B,E		;TO SAVE IT FOR LATER ROUTINES
	JSR PC,GCLSTA	;SEE IF IT IS THERE
	BEQ EIVOK1	;LOSER
	ADD B,A		;GET A REAL ADDRESS FOR CAP
	MOV (A),B	;THE FIRST WORD OF CAP
	BEQ EIVOK1	;NOTHING THERE
	CMP B,#-1
	BEQ EIVOK1
	ASL B		;TO A WORD ADDR
	BIC #177001,B	;FLUSH EXTRA BITS
	CMP B,#CAPHGH*2
	BLT .+4		;IF THE CAPABLITY IS TOO BIG
	BPT		;YECH!
	MOVB 1(P),C	;THE FUNCTION
	BITB #200,C	;IS IT A GENERAL REQUEST
	BNE .+6
	JMP @IVKCTB(B)	;GO TO THE RIGHT ROUTINE
	ASL C		;TURN IT INTO A WORD INDEX
	BIC #177400,C	;CLEAR THE TOP BYTE
	CMP C,#GENHGH
	BLT EIVOK2	;TOO HIGH OF A FUNCTION
	ADD #6,P	;CLEAN UP STACK
	JMP BADEMT
EIVOK2:	JMP @GENDIS(C)	;GO TO THE GENERAL FUNCTION ROUTINE
EIVOK1:	ADD #6,P	;POP OFF THE THREE ARGS
ERETSZ:	MOV ITM0A,A	;IF THE CALL FAILS
	CLR PUPDLO(A)	;NOTHING GETS POPPED
	SEZ
	JMP EMTRET

DELCAP:	ADD #6,P	;POP OFF ALL THE ARGUMENTS
	JSR PC,@DELTAB(B)	;DELETE ROUTINE FOR THIS CAPABILITY
	JMP EMTRET	;RETURN WHATEVER FLAGS SET
CPYCAP:	MOV A,F
	MOV B,C		;FOR ROUTINES LATER
	TST (P)+	;ONLY WANT TWO ARGS
	ADD #CPYTAB,C
	JMP CPYCA1
GIVCAP:	TST (P)+	;FIRST ARG NO LONGER NEEDED
	MOV (A),C	;TYPE AND FLAGS OF CAP TO USE WHEN GIVING AWAY
	CMPB C,#.MSCAP	;IS IT A MASTER SPHERE CAPABILITY
	BEQ GVCAP1	;YES
	CMPB C,#.SPCAP	;IS IT SPHERE CAP.
	BEQ GVCAP1	;YEP
GVCAP2:	ADD #4,P	;POP OFF GARBAGE
	JMP BADEMT
GVCAP1:	BIT #.SPCAD,C	;DOES HE HAVE APPEND ACCESS
	BEQ GVCAP2	;NOPE, HE LOSES
	MOV (P),B	;THE SECOND ARG SPECIFIES WHAT TO GIVE AWAY
	BIC #177400,B	;GET THE GOOD BITS
	MOV B,E		;TO SAVE IT FOR LATER
	MOV A,C		;SAVE POINTER TO SPHERE OR MS CAP
	MOV ITM1A,A	;FIND IT IN THIS SPHERE
	JSR PC,GCLSTA	;FIND THE CAP.
	BEQ GIVLOS	;CAN'T FIND IT
	ADD A,B		;MAKE B POINT TO THE CAPABILITY
	MOV B,D		;FOR LATER DELETION
	MOV (B),F	;GET THE TYPE AND FLAGS
	BEQ GIVLOS	;THERE ISN'T A CAPABILITY THERE
	CMP #-1,F
	BEQ GIVLOS
	ASL F		;CHANGE IT TO A WORD INDEX
	BIC #177001,F	;CLEAR EXTRA BITS
	MOV 2(C),C	;GET THE SPHERE NO. THAT WE ARE GIVING TO
	JSR PC,SPRSTP	;STOP IT
	MOV C,B		;FOR THE LOCK ROUTINES
	MOV #LCKRTN,A	;RUN A ROUTINE IF UNLOCKED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCSPST,LCKWD1(A)	;START PROCESSES IF UNLOCKED
	MOV ITEM0,B	;PUT THIS PROCESSES ITEM NO. THERE
	MOV #SCLSLK,A	;C-LIST LOCK
	JSR PC,LCKASW	;LOCK AN ITEM'S SWITCH
	MOV 2(P),B	;WHERE TO PUT IT
	JSR PC,CRCLST	;CREATE A C-LIST ENTRY IN HIS C-LIST
	BCS GVCAP2	;C-LIST FULL
	BEQ GIVLOS	;DESTINATION OCCUPIED
	SAVE <C,B,A>
	MOV ITEM1,C	;THIS SPHERE
	JSR PC,SPRSTP	;STOP IT (EXCEPT FOR ME)
	MOV C,B		;THE ITEM FOR THE LOCKSW ROUTINES
	MOV #LCKRTN,A	;RUN A ROUTINE WHEN UNLOCKED
	JSR PC,LOCKSW	;LOCK THE SWITCH
	MOV #PCSPST,LCKWD1(A)	;START THE PROCESSES WHEN UNLOCKED
	MOV ITEM0,LCKWD2(A)	;START ALL THE PROCESSES, EXCEPT ME
	REST <A,B,C>
	JMP @GIVTAB(F)	;DISPATCH ON TYPE
GIVLOS:	ADD #4,P
	JMP ERETSZ

;THIS ROUTINE CALLS THE APPROPRIATE ROUTINE WITH INFO AS FOLLOWS
;A- POINTER TO CAP DEST.,C- SPHERE OF TAKEE, D-OFFSET OF TAKEE CAP.
;B-C LIST NO. OF DESTINATION,E-C LIST NO. OF TAKEE,F-DISPATCH TYPE
TAKCAP:	TST (P)+	;FIRST ARGUMENT NO LONGER NEEDED
	MOV (A),C	;TYPE AND FLAGS OF CAP. TO USE WHEN TAKING AWAY
	CMPB C,#.MSCAP	;MASTER SPHERE CAP.
	BEQ TKCAP1	;YES
	CMPB C,#.SPCAP	;SPHERE CAP.?
	BEQ TKCAP1	;YES
TKCAP2:	ADD #4,P	;POP OFF ARGS
	JMP BADEMT
TKCAP1:	BIT #.SPCLD,C	;CAN WE DELETE FROM THIS C-LIST
	BEQ TKCAP2	;NO!
	MOV (P),B	;WHAT WE ARE SUPPOSED TO TAKE AWAY
	BIC #177400,B	;GET THE GOOD BITS
	MOV B,E		;THE C-LIST NO. OF TAKEE
	MOV 2(A),A	;THE SPHERE NO. OF TAKEE
	MOV A,C		;SAVE IT FOR LATER
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,GCLSTA	;DOES THE CAP EXIST
	BEQ TAKLOS	;NOPE
	MOV B,D		;OFFSET OF TAKEE
	ADD A,B		;MAKE B POINT TO IT
	MOV (B),F	;CAPABILITY TYPE AND FLAGS
	BEQ TAKLOS	;DOESN'T EXIST
	CMP #-1,F
	BEQ TAKLOS
	JSR PC,ITM2PO	;DONE FOR NOW WITH THIS
	ASL F		;TURN TYPE INTO WORD INDEX
	BIC #177001,F	;CLEAR EXTRA BITS
	JSR PC,SPRSTP	;STOP THE SPHERE OF TAKEE
	MOV C,B		;FOR THE LOCK ROUTINE
	MOV #LCKRTN,A	;RUN A ROUTINE WHEN UNLOCKED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCSPST,LCKWD1(A)	;START THE SPHERE WHEN UNLOCKED
	MOV ITEM0,B	;PUT THE PROCESS'S ITEM NO. THERE
	MOV #SCLSLK,A	;LOCK THE SPHERES C-LIST
	JSR PC,LCKASW	;LOCK AN ITEM'S SWITCH
	MOV 2(P),B	;THE DESTINATION IN TAKER
	SAVE C		;SAVE SPHERE OF TAKEE
	MOV ITEM1,C	;CREATE THE C-LIST ENTRY IN THIS SPHERE
	JSR PC,CRCLST	;CREATE AN ENTRY
	BCS TKCAP4	;C-LIST FULL
	BEQ TKCAP3	;C-LIST DESTINATION OCCUPIED
	ADD ITM1A,A	;MAKE A POINT ABSOLUTELY
	REST C		;SPHERE OF TAKEE
	JMP @TAKTAB(F)
TAKLOS:	JSR PC,ITM2PO
	BR TKCAP2
TKCAP3:	JMP EIVOK1
TKCAP4:	ADD #6,P
	JMP BADEMT

;.SINK
;DISABLES FLOATING POINT FOR THIS PROCEEDURE
;ALWAYS SUCCEEDS
ESINK:	MOV #PRSLNF,A		;SIZE OF A PROCESS WITHOUT FLOATING POINT AC'S
	MOV ITEM0,B		;THE ITEM INDEX OF THE PROCESS
	JSR PC,EXITEM		;SHRINK THE PROCESS IF NECESSARY
	MOV ITM0A,A		;THE ADDRESS OF THE ITEM
	BIC #PFPFLG,PFLAGS(A)	;CLEAR THE FLOATING  POINT FLAG IN PROCESS
	CLZ			;ALWAYS SUCCEEDS
	JMP EMTRET

;.FLOAT
;ENABLES FLOATING POINT FOR THIS PROCEDURE
EFLOAT:	MOV ITM0A,A
	BIT #PFPFLG,PFLAGS(A)
	BNE EFLOT2
	MOV #PRSLFP,A		;SIZE OF PROCESS WITH FLOATING POINT
	MOV ITEM0,B		;THE ITEM INDEX OF THE PROCESS
	JSR PC,EXITEM		;EXPAND THE PROCESS TO INCLUDE SPACE FOR FLOATING POINT AC'S
	BNE EFLOT1		;IT FAILED
	JMP EMTRET
EFLOT1:	MOV B,A
	JSR PC,ITM0LD		;LOAD THE NEW PROCESS
	MOV #40300,PFPPS(A)	;START HIM WITH INT. DISABLED AND IN DOUBLE AND LONG MODE
	BIS #PFPFLG,PFLAGS(A)
EFLOT2:	CLZ 
	JMP EMTRET
;.MAP
;CREATE A PAGE FOR A SPHERE,
;THE FIRST BYTE IS THE SPHERE CAPABILITY TO THE DESTINATION SPHERE
;THE SECOND IS THE ACCESS INFO (READ, WRITE, AND PRIVATE OR PUBLIC COPY)
;THE THIRD IS THE SOURCE OF THE PAGE
;(FILE ACCESS CAP., -1 FOR FRESH PAGE, -2 FOR ABSOLUTE PAGE,
;OR -3 FOR JUST DELETE THIS PAGE)
;THE FOURTH IS THE UPT NO. OF THE PAGE TO CREATE
;(0-7 UPT NO. IS I SPACE, 10-17 IS D-SPACE, 20-27 IS I=D SPACE)
;THE FIFTH AND SIXTH ARE THE PAGE NO. IN SOURCE (IF FILE)
;THE SEVENTH IS THE START OF THE PAGE (IN 512. WORD BLOCKS)
;THE EIGHTH IS THE LENGTH "  "    "    "  "   "      "
EMAP:	SUB #10,P	;MAKE 4 STORAGE CELLS
	JSR PC,RETNSW	;GET THE SPHERE CAP AND FLAGS
	MOV A,(P)	;SAVE IT
	JSR PC,RETNSW	;GET THE SOURCE AND UPT NO.
	MOV A,2(P)	;SAVE IT
	JSR PC,RETNSW	;GET THE PAGE NO. AT SOURCE
	MOV A,4(P)	;SAVE IT
	JSR PC,RETNSW	;GET THE LENGTH AND START OF PAGE
	MOV A,6(P)	;SAVE IT
	MOV (P),B	;THE SPHERE CAP
	BIC #177400,B	;CLEAR THE EXTRA BITS
	MOV ITM1A,A	;THE ADDRESS OF THE ITEM
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ EMAP1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE SPHERE CAP
	MOV (A),B	;GET THE TYPE AND FLAGS
	CMPB B,#.SPCAP	;IS IT A SPHERE CAPABILITY
	BEQ EMAP2	;YES
	CMPB B,#.MSCAP	;IS IT A MASTER SPHERE CAPABILITY
	BEQ EMAP2	;YES
EMAP1:	ADD #10,P	;POP OFF THE ARGUMENTS
	JMP ERETSZ	;TELL HIM HE FAILS
EMAP2:	BIT #.SPCRW,B	;DOES HE HAVE CORE WRITE CAPABILITY
	BEQ EMAP1	;NOPE
	MOV 2(A),F	;THE SPHERE NO.
	MOV F,C		;THE SPHERE NO. FOR SUPTDL
	MOVB 3(P),B	;THE UPT NO.
	BLT EMAP1	;IT IS NEGATIVE
	CMP B,#30	;IS IT A LEGAL PAGE
	BGE EMAP1	;NOPE
	CMP B,#20	;IS IT A NORMAL PAGE (IE NOT AN I=D PAGE)
	BLT EMAP3	;YES
	SUB #20,B	;MAKE IT POINT TO THE I-SPACE PAGE FIRST
	JSR PC,SUPTDL	;DELETE THE UPT
	ADD #10,B	;MAKE IT POINT TO THE D-SPACE PAGE
EMAP3:	JSR PC,SUPTDL	;DELETE THE UPT
	CMPB 2(P),#-3	;IS IT A REQUEST FOR FLUSHING THE PAGE
	BEQ EMAPRT	;YES, THEN WE ARE DONE
	HALT		;HERE CREATE PAGES
;BRANCHES IN FROM ABOVE
EMAPRT:	ADD #10,P	;POP OFF THE ARGUMENTS
	CMP F,CURSPH	;DID WE CHANGE THIS SPHERE'S PAGES?
	BNE .+6		;NO DON'T WORRY ABOUT IT
	JSR PC,MAPRE1	;MAKE SURE HIS MAP GETS MODIFIED IMMEDIATELY
	JMP ERETCZ	;SUCESS

;.TTGIV
;GIVE TTY AWAY, THE FIRST ARGUMENT IS A MASTER SPHERE CAPABILITY
;THE SECOND IS A TELETYPECAPABILITY
ETTGIV:	JSR PC,RETNSW	;GET THE FIRST ARG
	MOV A,B		;THE MASTER SPHERE CAPABILITY
	BIC #177400,B	;CLEAR THE TOP BYTE
	MOV ITM1A,A	;THE ADDRESS OF THE SPHERE IN THE MAP
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ TTGIV1	;COULDN'T GET IT
	ADD B,A		;MAKE A POINT TO THE SPHERE CAP
	MOV (A),C	;THE TYPE AND FLAGS
	BEQ TTGIV1	;DOESN'T EXIST
	CMPB C,#.MSCAP	;IS IT A MASTER SPHERE CAP.
	BNE TTGIV1	;NOPE, CAN'T DO IT
	MOV 2(A),D	;THE SPHERE TO GIVE IT TO
	JSR PC,RETNSW	;GET THE SECOND ARG
	MOV A,B		;THE ARGUMENT
	BIC #177400,B	;CLEAR THE TOP BYTE
	MOV ITM1A,A
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ TTGIV1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE TTY CAP
	MOV (A),C	;TYPE AND FLAGS
	BEQ TTGIV1	;DOESN'T EXIST
	CMPB C,#.TTCAP	;IS IT A TTY CAPABILITY
	BNE TTGIV1	;NOPE
	MOV 2(A),A	;THE MASTER TTY ITEM NO.
	JSR PC,ITM2PL	;LOAD IT UP
	MOV ITM1A,B	;POINTER TO THE CURRENT SPHERE
	CMP B,TTITM(A)	;IS THIS SPHERE THE OWNER OF THE TTY
	BNE TTGIV2	;NOPE
	MOV TTYST(A),STTFG1(B)	;STORE THE CURRENT TTY STATUS
	MOV D,TTITM(A)	;CORRECT OWNER OF TTY POINTER
	MOV CURUSR,TTYU(A)
	JSR PC,ITM2PO	;POP THE ITEM STACK
	JMP ERETCZ	;SUCCESS
TTGIV2:	JSR PC,ITM2PO
TTGIV1:	JMP ERETSZ

;.TTGET
;GET THE TTY, THE ARGUMENT IS A TTY CAPABILITY
;HANGS UNTIL IT CAN GET THE TTY
ETTGET:	JSR PC,RETNSW	;GET THE CAPABILITY NO. OF A TTY CAP.
	MOV A,B		;GET THE TTY NO.
	BIC #177400,B	;CLEAR THE EXTRA BITS
	SAVE B		;IF WE GET FLUSHED
TTGET3:	MOV ITM1A,A
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ TTGIV1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE CAPABILITY
	CMPB (A),#.TTCAP	;IS IT A TTY CAP
	BNE TTGIV1	;NO, HE IS A LOSER
	MOV 2(A),A	;GET THE TTY ITEM NO.
	SAVE A		;IF WE GET STOPPED THIS IS NEEDED
	MOV ITEM1,C	;THE CURRENT SPHERE
	JSR PC,ITM1PL	;LOAD THE TTY ITEM
	MOV TTITM(A),A	;THE CURRENT OWNER OF THE TTY
	CMP C,A		;DO I ALREADY OWN IT
	BEQ TTGET4	;YES, SUCCEED
TTGET2:	JSR PC,ITM1LD	;LOAD THE ITEM
	MOV SMSSPT(A),A	;THE MASTER OF THIS SPHERE
	CMP A,C		;IS ITS SUPERIOR THE REQUESTOR
	BEQ TTGET1	;SUCESS
	CMP SYSSPR,A	;ARE WE AT THE ROOT OF THE SPHERE STRUCTURE
	BNE TTGET2	;LINK THROUGH TO THE NEXT SPHERE
	JSR PC,ITM1PO	;CLEAN UP THE STACK
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	REST A		;POP OFF GARBAGE
	REST B		;GET THE CAP NO OF THE TTY CAP
	BR TTGET3	;TRY AGAIN
TTGET1:	JSR PC,ITM1LD	;LOAD THE OWNER OF THE TTY
	REST A
	REST B		;GET RID OF CRAP
	JSR PC,ITM2PL	;LOAD UP THE TTY
	MOV ITM1A,B	;POINTER TO THE SPHERE THAT OWNS IT
	MOV TTYST(A),STTFG1(B)	;STORE THE FLAGS
	MOV CURUSR,TTYU(B)	;SET THE USER
	SAVE ITEM1	;THE GUY WHO USED TO OWN IT
	JSR PC,ITM1PO	;GET BACK TO CALLER
	MOV ITM1A,B
	REST SIFTTY(B)	;SET IN WHERE YOU GOT THE TTY
	MOV ITEM1,TTITM(A)	;SET IN THE OWNER OF THIS TTY
	MOV STTFG1(B),TTYST(A)	;SET IN THE OLD FLAGS
	JSR PC,ITM2PO
	JMP ERETCZ
TTGET4:	JSR PC,ITM1PO
	JMP ERETCZ
;.SLEEP:
;1 ARG IS TOP 2 WORDS ON STACK (LOW ORDER IS TOP WORD)
;NEGATIVE=>NEGATIVE OF SYSTEM TIME TO CONTINUE
;POSITIVE=>NUMBER OF 60THS TO SLEEP
ESLEEP:	MOV PUP(A),B	;GET HIS PDL POINTER
	MFPD (B)	;GET TOP WORD
	MOV (P),C	;SAVE IT IN C
	MTPD (B)+	;MAKE SURE WE CAN WRITE IT
	MFPD (B)	;GET HIGH ORDER WORD
	MOV (P),D	;SAVE IT IN D
	MTPD (B)	;MAKE SURE WE CAN WRITE IT
	MOV #4,PUPDLO(A)	;POP 2 THINGS IF SUCESSFUL
	TST D		;IS IT NEGATIVE?
	BLT ESLEE1	;YES, GO SEE IF IT'S TIME YET
	NEG C		;NEGATE DOUBLE WORD NUMBER
	ADC D
	NEG D
	SUB TIME,C	;NOW COMPUTE NEGATIVE TIME TO WAKE UP
	SBC D
	SUB TIME+2,D
	SAVE D		;NOW CLOBBER USER'S THING TO NEGATTIVE
	MTPD (B)	;CLOBBER HIGH ORDER
	SAVE C
	MTPD -(B)
ESLEE1:	JSR PC,ESLEEC	;CHECK IF TIME IS UP
	BLT ESLEE4	;NOPE SLEEP SOME MORE
	JMP ERETCZ	;TIME IS UP, GO AWAY
ESLEE4:	CMP #-1,B	;IS IT A LONGE TIME TO WAIT?
	BNE ESLEE2	;YES, MORE THAN 2**16 TICKS
	CMP #-LTIMEL*4,A	;WELL, IS IT LONG?
	BGT ESLEE2	;YUP, MORE THAN 4 LONG WAITS
	JSR PC,SFLUSH	;NOT LONG
	BR ESLEE3	;NOW TRY AGAIN
ESLEE2:	JSR PC,LFLUSH	;LONG TIME TO WAIT
ESLEE3:	JSR PC,ESLEEC	;WELL, TIME UP NOW?
	BLT ESLEE4	;NOPE
	JSR PC,RUNME	;ALL DONE
	JMP ERETCZ	;GO RETURN TO USER
ESLEEC:	MOV C,A		;COPY TIME TO WAKE UP
	MOV D,B
	ADD TIME,A
	ADC B
	ADD TIME+2,B
	RTS PC
;.QUNLK
;THE FIRST ARG IS THE CAPABILITY NO. OF THE QUE CAP
EQUNLK:	JSR PC,RETNSW	;GET THE FIRST ARG
	MOV A,B		;GET THE CAP. NO
	BIC #177400,B	;CLEAR THE SILLY BITS
	MOV ITM1A,A	;THE ADDRESS OF THE SPHERE
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ UNLCK1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE CAPABILITY
	CMPB (A),#.QUCAP	;IS IT A QUE CAPABILITY
	BNE UNLCK1	;NO
	MOV 2(A),A	;THE ITEM NO OF THE QUE
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,PCQUNL	;UNLOCK THE QUE
	JSR PC,ITM2PO	;POPTHE ITEM STACK
	JMP ERETCZ
UNLCK1:	JMP ERETSZ
;REMOVE THE GUY IN ITEM0 FROM THE QUE POINTED TO BY A
;IF HE HAS IT LOCKED, START SOMEONE ELSE, OTHERWISE JUST
;REMOVE HIM
PCQUNL:	SAVE A
	MOV QUECNT(A),F	;THE NUMBER OF PEOPLE ON THE QUE
	MOV F,A		;COPY THE COUNT
	MOV F,C		;COPY IT AGAIN
	ASL A		;TURN IT INTO A WORD INDEX
	ADD (P),A	;MAKE IT LESS RELATIVE
	ADD #QUEQUE,A	;MAKE A POINT TO THE START OF THE QUE
	MOV ITEM0,B	;THE PERSON TO LOOK FOR
QUNLK1:	CMP -(A),B	;IS HE HERE
	BEQ QUNLK2	;YES
	SOB C,QUNLK1	;TRY THE NEXT QUE ENTRY
	SEZ		;SAY HE WASN'T HERE
	RTS PC
QUNLK2:	SUB F,C		;THE NUMBER OF PEOPLE AFTER HIM
	NEG C		;MAKE THE COUNT POSITIVE
	SAVE C		;SAVE THE COUNT
	BEQ QUNLK4	;NOBODY AFTER HIM ON THE QUE
QUNLK3:	MOV 2(A),(A)+	;MOVE EVERYONE UP ONE SLOT ON THE QUE
	SOB C,QUNLK3
QUNLK4:	REST <C,A>
	DEC QUECNT(A)	;ONE LESS PERSON ON THE QUE
	MOV QUECNT(A),B	;THE NUMBER OF PEOPLE ON THE QUE
	SUB C,B		;GET THE NUMBER OF PEOPLE THAT WERE BEFORE HIM
	CMP B,QUENUM(A)	;DID HE HAVE THE QUE LOCKED
	BGE QUNLK6	;NO
	MOV QUENUM(A),C	;THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
	CMP QUECNT(A),C	;IS EVERY ONE ON THE QUE STARTED ALREADY
	BLT QUNLK6	;YES
	DEC C		;BECAUSE THE FIRST GUY HAS AN OFFSET OF 0
	ASL C		;TURN IT INTO A WORD INDEX
	ADD A,C		;MAKE THE POINTER LESS RELATIVE
	MOV QUEQUE(C),A	;GET THE GUY TO START
	JSR PC,ITM0PL
	MOV PPRTPT(A),A	;GET THE PROCESS TABLE ENTRY
	MOV #SFLSQ,B	;MOVE HIM TO THE SHORT FLUSH QUE
	JSR PC,TQUEUE	;DO THE MOVE
	JSR PC,ITM0PO
QUNLK6:	CLZ
	RTS PC
;.QULK,;THE FIRST ARG IS THE CAPABILITY NO OF THE QUE TO LOCK
EQULK:	JSR PC,RETNSW	;GET THE CAPABILITY NO
	MOV A,B
	BIC #177400,B	;CLEAR THE EXTRA BITS
	MOV ITM1A,A
	JSR PC,GCLSTA	;GET THE CAPABILITY
	BEQ UNLCK1	;FAILED
	ADD B,A		;MAKE A POINT TO THE CAP
	CMPB (A),#.QUCAP	;IS IT A QUE
	BNE UNLCK1	;NO
	MOV 2(A),A	;THE ITEM NO OF THE QUE
	JSR PC,ITM2PL	;LOAD IT
QULK5:	MOV QUECNT(A),C	;THE NUMBER OF PEOPLE ON THE QUE
	CMP C,QUEENO(A)	;IS THERE ROOM FOR ONE MORE
	BEQ QULK4	;NO, ENLARGE THE QUE
	INC QUECNT(A)	;ONE MORE PERSON ON THE QUE
	ASL C		;CHANGE IT INTO A WORD INDEX
	ADD A,C		;MAKE C POINT TO THE QUE ENTRY (ALMOST)
	MOV ITEM0,QUEQUE(C)	;PUT HIM ON THE QUE
	CMP QUECNT(A),QUENUM(A)	;DID HE SUCEED IN LOCKING IT
	BGT QULK1	;NO
	JSR PC,ITM2PO	;POP THE SPHERE
	JMP ERETCZ	;RETURN
QULK1:	MOV QUENUM(A),C	;THE NUMBER OF PEOPLE WHO CAN LOCK IT
	MOV ITEM0,B
	ADD #QUEQUE,A	;MAKE A POINT TO THE QUE
	CLR E		;FOR THE COUNT
QULK7:	CMP (A)+,B	;DO I ALREADY HAVE IT LOCKED
	BNE .+4		;WASN'T ME
	INC E		;INCREMENT THE COUNT
	SOB C,QULK7	;GET A FULL COUNT
	MOV ITEM2,B	;THE QUE NO.
	MOV #LPCLRT,A	;RUN A ROUTINE IF PCLOSER'ED
	JSR PC,LOCKSW	;LOCK A SWITCH
	MOV #PCQUNL,LCKWD1(A)	;UNLOCK THE QUE FOR HIM IF HE IS STOPPED
	MOV ITEM2,A	;FOR BELOW
QULK9:	JSR PC,ITM2PO	;PO IT
	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD THE QUE
	MOV QUENUM(A),C	;THE NUMBER OF PEOPLE THAT CAN LOCK THE QUE
	ADD #QUEQUE,A	;MAKE A POINT AT THE QUE
	MOV E,F		;COPY COUNT
QULK2:	CMP (A)+,B	;HAVE I MOVED TO THE LOCKED PORTION
	BNE QULK8		;NOT ME
	DEC F		;DECREMENT COUNT
	BMI QULK3	;I HAVE LOCKED IT AGAIN
QULK8:	SOB C,QULK2	;NOT HERE TRY THE NEXT ENTRY
	MOV ITEM2,A		;SAVE THE ITEM NO. OF THE QUEUE
	BR QULK9	;HAVEN'T LOCKED IT YET, FLUSH HIM
QULK3:	JSR PC, ITM2PO	;POP THE ITEM STACK
	JSR PC,RUNME	;I HAVE LOCKED IT
	JMP ERETCZ
	;MAY JUMP TO NEXT PAGE
	;MAY BE JUMPED INTO FROM ABOVE
QULK4:	MOV QUEENO(A),A	;THE NUMBER OF ENTRIES IN THE QUE
	SAVE ITEM2	;SAVE THE QUE'S ITEM NO
	JSR PC,ITM2PO	;POP THE ITEM STACK
	ASH #-6,A	;TURN IT INTO A ITEM SIZE
	INC A		;WE WANT TO MAKE IT ONE SIZE LOARGER
	MOV (P),B	;THE IUTEM NO FOR EXITEM
	JSR PC,EXITEM	;EXPAND THE QUE
	BNE QULK6	;SUCCEEDED
	REST A		;OH WELL, NO SPACE
	JMP ERETSZ
QULK6:	REST A		;THE QUE ITEM NO
	JSR PC,ITM2PL	;LOAD IT
	ADD #32.,QUEENO(A)	;MADE IT 16. ENTRIES LARGER
	BR QULK5	;GO TRY TO LOCK IT
	.SBTTL INVOKE CAPABILITY ROUTINES
CAPRXX:	BPT	;THE ZERO CAPABILITY
CAPRCC:	TST (P)+	;ONLY WANT TWO ARGS
	ASL C		;THE CAPABILITY TYPE TO CREATE
	CMP C,#CAPHGH	;IS HE ASKING FOR A NON-EXISTANT TYPE?
	BGE CAPRC1	;LOSER!
	ADD #CCTAB,C
CPYCA1:	MOV E,D	;CAP NUMBER
	REST <B>	;CAP DESTINATION
	SAVE <C>	;ADDRESS OF ROUTINE
	MOV ITEM1,C
	JSR PC,CRCLST
	BEQ CAPRC4	;THE C-LIST ENTRY WAS USED
	BCS CAPRC1	;FULL C-LIST
	ADD ITM1A,A	;MAKE A POINT ABSOLUTELY TO ENTRY
	REST <C,E>	;ROUTINE ADDRESS AND SECOND ARG
	SAVE <B,A>
	MOV #-1,(A)	;SAVE THIS SPACE
	MOV #LPCLRT,A
	MOV ITEM1,B
	JSR PC,LOCKSW
	MOV (P),LCKWD2(A)
	MOV #CAPRC5,LCKWD1(A)
	MOV C,A		;ROUTINE ADDRESS
	CLR C
	JSR PC,@A
;THE ROUTINE WE CALL IS EXPECTED TO RETURN:
;IN A THE CAP TYPE AND FLAGS
;IN B THE PRIMARY ITEM 
;THE SECONDARY ITEM IS NEVER RETURNED
;IN C THE FIRST MISC WORD
;THE SECOND MISC WORD IS NEVER RETURNED
;THE ROUTINE SHOULD SET Z IF IT FAILS, OTHERWISE CLEAR IT
	BEQ CAPRC3	;FAILURE
	REST F
	MOV A,(F)+	;THE TYPE AND FLAGS
	MOV B,(F)+	;THE PRIMARY ITEM
	CLR (F)+	;NO SECONDARY ITEM
	MOV C,(F)+	;THE 1ST MISC WORD
	CLR (F)		;NO SECOND MISC WORD
	REST <B>
	JSR PC,GIVPSW
	JMP ERETCZ	;SUCESS
CAPRC1:	CMP (P)+,(P)+
CAPRC2:	JMP BADEMT
CAPRC3:	CLR @(P)	;FREE CAP SLOT
CAPRC4:	REST <A,B>
	JMP ERETSZ	;FAIL
CAPRC5:	MOV LCKWD2(B),B
	CLR (B)		;RELEASE CAP SPACE
	RTS PC
	.STITL FILE ACCESS CAPABILITY ROUTINES
CAPRFA:	MOV #.FALB,B	;LOCK SWITCH
	MOV ITEM1,C
	SUB ITM1A,A
	JSR PC,LCKASW
	ADD ITM1A,A
	REST <B,E,F>
	SWAB B
	BIC #177400,B
	CMP B,FAGTFN
	BGT CAPRC2
	JMP @FATAB(B)

FACFLG:	BIC #<-.FARD-.FAWT-.FAAP-.FAMFL>-1,E
	MOV (A),B
	BIC E,(A)
	BIC #<-.FAMFL>-1,B
	BEQ FARTN
	BIT B,E
	BEQ FARTN
	MOV FAMFI(A),A		;CLEAR THE MFI LOCKED BIT
	JSR PC,ITM2LD
	BIC D,MFLAGW(A)
FARTN:	JMP ERETCZ

FASFLG:	BIC #<-.FAAP-1>,E
	BIS E,(A)
	BR FARTN

FASPTR:	MOV E,FAFPN(A)
	MOV F,FAFBP(A)
	BR FARTN

FARPTR:	MOV FAFBP(A),B
	JSR PC,GIVPSW
	MOV FAFPN(A),B
	JSR PC,GIVPSW
	BR FARTN

DIRADD:
DIRDEL:
MAKBIT:
	HALT
;MUTATE A FA CAP
DIRM.1:	MOV FAUPT(D),B
	JSR PC,UPTDEL		;MFI IN ITEM2
	INC MFREF(A)
	BIT #MFLOKB,MFLAGW(A)
	BEQ .+4
	SAVE <#MFLOKB>		;SWITCH FOR CLEARING FLAGS
	JSR PC,LSWPOP		;IT WOULD HAVE DELETED THIS ITEM
	MOV ITEM1,A
	JSR PC,DLITEM
	JSR PC,ITM1PO
	BR DIRM.2
DIRMUT:	CLR -(P)
	SAVE <E,F>	;FLAGS TO BE SET IN MFI
	JSR PC,DIRENT	;GET THE NAME AND HASH #
	BEQ DIRM.8
	JSR PC,GETBYT
	MOV C,4(P)
	MOV E,2(P)
	JSR PC,DIRFND	;SEARCH AROUND FOR IT
	BEQ DIRM.7	;COULDN'T FIND IT
	BCS DIRM.1	;MFI IN ITEM2
	MOV B,F		;PARENT BLK #
	MOV (P),B
	JSR PC,MAKMFI	;PUTS IT IN ITEM2
	BEQ DIRM.8
	MOV FAUPT(D),B
	JSR PC,UPTDEL
	CLR -(P)	;SET SWITCH
DIRM.2:	SAVE <ITEM2,D>
	MOV FAMFI(D),A
	JSR PC,MFIDEL	;DECREMENT COUNT
	REST <D,A>
	CLR FAFBP(D)
	CLR FAFPN(D)
	MOV A,FAMFI(D)
	JSR PC,ITM2LD
	MOV MFLAGW(A),C
	BIC #<-MFLOKB-MFILEB>-1,C
	BIC (P)+,C
	BIS C,(D)
	REST <F,E>
	MOV F,B
	JSR PC,GIVPSW
	MOV E,B
	JSR PC,GIVPSW
	JSR PC,RETNSW
	JSR PC,RETNSW
	MOV D,A
	CMPB (P)+,#'>
	BEQ DIRMUT
	BR FARTN
;BRANCHES IN FROM ABOVE
DIRM.7:	MOV ITEM1,A
	JSR PC,DLITEM
	JSR PC,ITM1PO
DIRM.8:	TST (P)+
	CMP (P)+,(P)+
DIRM.9:	JMP ERETSZ


;GET A BYTE OR WORD FROM USERS DATA SPACE
;(E)= PTR.
;(C)= WHERE BYTE IS RETURNED (INC E ALSO)
GETBYT:	MOV E,C
	BIC #1,C
	MFPD (C)
	BIT #1,E
	BEQ .+4
	SWAB (P)
	REST <C>
	INC E
	RTS PC

GETWRD:	JSR PC,GETBYT
	SAVE <C>
	JSR PC,GETBYT
	SWAB C
	CLRB C
	BISB (P)+,C
	RTS PC
;MAKE A MFI
;(A)= ADDRESS OF ITEM1
;(B)= FLAGS TO SET
;(D)= FA PTR.
;(E)= DISCRIPTOR PTR (IN ITEM 2)
;(F)= PARENT BLK #
MAKMFI:	SAVE <B>	;SAVE FLAGS
	MOV A,C
	MOV #40,B
	CLR (C)+
	SOB B,.-2	;CLEAR IT OUT
	MOV (E),B
	BIC #177700,B
	CMP B,#<100-MFELEN>/2
	BGT MAKM.3
	MOV A,C
	ADD #MFENHD,A
	MOV (E)+,(A)+
	SOB B,.-2		;MOVE THE DISCRIPTOR
	JSR PC,LSWPOP		;THIS CLEARS THE FUPT PROCESS PTR. (I HOPE)
	MOV F,MFPARB(C)		;PAR BLOCK #
	MOV FAMFI(D),A
	JSR PC,ITM2LD
	MOV MFBFPT(A),MFBFPT(C)
	MOV MFENHD(C),B		;IS IT A FILE OR DIRECTORY
	BIC #177477,B
	BIC #<-MFLOKB-MFIWSB>-1,(P)
	CMP B,#MFFILB
	BNE MAKM.1
	BIS #MFILEB,(P)
	MOV FAMFI(D),MFBKP(C)	;PARENT MFI #
	INC MFREF(A)
	BR MAKM.2
MAKM.1:	CMP B,#MFDIRB
	BEQ .+4
	BPT
	MOV #-1,MFBKP(F)
MAKM.2:	MOV ITEM1,A
	JSR PC,ITM1PO
	JSR PC,ITM2LD
	JSR PC,MFHASH		;LINK IT IN
	JSR PC,LSWPOP		;DELETES THE MFI ITEM
	MOV A,B
	MOV #LPCLRT,A
	JSR PC,LOCKSW		;IN CASE OF PCL
	MOV #MFDELP,LCKWD1(A)
	MOV ITM2A,A
	RTS PC
MAKM.3:	MOV ITEM1,A
	JSR PC,ITM1PO
	JSR PC,DLITEM
	REST <B>
	SEZ
	RTS PC
;READ A NAME INTO AN ITEM (PUT IT ON THE ITEM1 STACK)
;(A)= CAP PTR. (MOVED TO D)
;(B)= HASH CODE OF NAME
;(E)= NAME PTR.

DIRENT:	MOV A,D
	JSR PC,MAKITM	;MAKE AN ITEM AND LOCK SWITCH
	BEQ DIRE.4
	CLR B		;XOR ITO HERE
	ADD #MFNAME,A
DIRE.1:	JSR PC,GETBYT		;GET A BYTE INTO C
	XOR C,B
	MOVB C,(A)+
	BMI DIRE.3
	CMP A,#ITM1AD+100
	BLO DIRE.1	;GET MORE
DIRE.2:	MOV ITEM1,A
	JSR PC,DLITEM
	JSR PC,ITM1PO
	SEZ
	RTS PC
DIRE.3:	BIC #177741,B
	CLZ
DIRE.4:	RTS PC

;CREATE ITEM (LOCK SWITCH TO DELETE IT)
;RETURN ADDRESS IN A AND ITEM # IN B
;LOAD IT INTO ITEM1

MAKITM:	CLR A
	JSR PC,CRITEM
	BEQ MAKI.1
	MOV #LPCLRT,A
	SAVE <B>
	JSR PC,LOCKSW
	MOV #PCLDLI,LCKWD1(A)
	MOV (P),A
	JSR PC,ITM1PL
	REST <B>
MAKI.1:	RTS PC
;SEARCH HASH TABLE AND THEN DIRECTORY FOR NAMED FILE
;(B)= HASH CODE
;(D)= CAP PTR.
;#MFNAME= NAME PTR. OFFSET (IN ITEM1)
;SEZ IF NOT FOUND (AND SEC IF CAN BE ADDED)
;IF FOUND SEC IF MFI EXISTS

DIRF.1:	BIT #MFDWDB,MFLAGW(A)
	BNE DIRF.5	;KEEP LOCKING
	REST <D>
	SEC		;FOUND MFI
	CLZ
	RTS PC
DIRF.2:	JSR PC,ITM1PL
	BR DIRF.3+2
DIRF.3:	REST <D>
	CLC		;UTTER FAILURE
	SEZ
	RTS PC

DIRFND:	SAVE <D>
	MOV FAMFI(D),A
	JSR PC,ITM2LD
	JSR PC,MFIRDS
	JSR PC,MFIRDS	;FIND BLOCK # OF PARENT
	BEQ DIRF.3
	MOV MFHTAB(B),A
	BEQ DIRF.6	;NO MFI
DIRF.4:	JSR PC,ITM2LD
	CMP D,MFPARB(A)	:SAME PARENT?
	BNE DIRF.5	;NOT THIS MFI
	MOV A,E
	ADD #MFENHD,E
	JSR PC,NAMCMP
	BEQ DIRF.1	;THIS IS IT
DIRF.5:	MOV MFHLNK(A),A
	BNE DIRF.4	;KEEP ON LOOKING
DIRF.6:	MOV D,B		;NOT IN HASH TABLE
	REST <D>

;FALLS THROUGH
;FALLS IN FROM ABOVE
;ENTER HERE TO SEARCH DIRECTORY ONLY
;(B)= PARENT BLOCK #
;(D)= FA CAP PTR.
;MFNAME= OFFSET FOR NAME PTR. (IN ITEM1)

ENTFND:	MOV ITEM1,A	;ITEM # OF NAME
	JSR PC,ITM1PO	;IN CASE WE ARE FLUSHED
	CLR FAFBP(D)
	CLR FAFPN(D)
	JSR PC,DIRUPT	;MAP DIRECTORY INTO ITEM2
	BEQ DIRF.2
	MOV (E),F
	BIC #177700,F
	ASL F		;SKIP OVER HEADER
	ADD F,E
	ADD F,C
	BGE DIRF.2	;THIS IS A BUG
	JSR PC,ITM1PL	;LOAD UP NAME
DIRF.7:	JSR PC,NAMCMP
	BGT DIRF.8	;CONTINUE LOOKING
	BLT DIRF.9	;STOP LOOKING BUT NOT FOUND
	CCC		;FOUND IT (E) IS PTR.
	RTS PC
DIRF.8:	TST C
	BLT DIRF.7	;END OF DIRECTORY
DIRF.9:	SEZ		;NOT FOUND BUT CAN BE ADDED
	SEC
	RTS PC
;COMPARE TWO FILE NAME AND SET CONDITION CODES
;1ST NAME IS IN ITEM1 (WITH OFFSET MFNAME)
;SECOND IS POINTED AT BY (E)
;UPDATE (E) IF 1ST NAME IS > 2ND

NAMCMP:	SAVE <E>
	TST (E)+	;SKIP HEADER WORD
	MOV ITM1A,F
	ADD #MFNAME,F
NAMC.1:	TSTB (E)
	BMI NAMCGE
	TSTB (F)
	BMI NAMCLT
	CMPB (F)+,(E)+
	BEQ NAMC.1
	BLT NAMCLT
NAMCGT:	MOV @(P),E	;HEADER WORD
	BIC #177700,E	;SKIP OVER THIS ENTRY
	ASL E
	ADD (P),C
	ADD (P)+,E
	CLZ!CLN!CLV
	RTS PC
NAMCLT:	REST <E>
	SEN		;V AND Z CLEARED BY REST <E>
	RTS PC
NAMCGE:	TSTB (F)
	BPL NAMCGT	;2ND NAME ENDED FIRST
	CMPB (F),(E)
	BLT NAMCLT
	BGT NAMCGT
	REST <E>
	SEZ
	RTS PC
CAPRMS:	HALT
CAPRSP:	HALT
CAPRTT:	HALT
CAPRQU:	HALT
	.STITL CREATE CAPABILITY ROUTINES
CCPRXX:	BPT	;THE ZERO CAPABILITY
CCPRSP:	ADD #6,P
	JMP BADEMT	;CAN'T CREATE A SPHERE CAPABILITY, HAVE TO COPY FROM MASTER
CCPRCC:	CLR B
	MOV #.CCCAP,A	;THIS IS EASY
CCRTS:	RTS PC

;CREATE A MASTER SHPERE CAPABILITY
CCPRMS:	JSR PC,CRSPHR	;CREATE THE ACTUAL SPHERE
	BEQ CCRTS	;NO SPHERE AVAILABLE
	MOV A,B		;THE ITEM NO OF THE SPHERE
	MOV E,C		;ENTER ADDRESS IS 2ND ARG TO CALL
	MOV #MSPCBT!.MSCAP,A	;THE TYPE AND FLAGS
	RTS PC
;CREATE A PROCESS CAPABILITY
CCPRPR:	JSR PC,CRPROC	;CREATE THE ACTUAL PROCESS
	BEQ CCRTS	;NO PROCESS AVAILABLE
	MOV A,B		;FOR THE LOCK ROUTINE 
	JSR PC,ITM0PL	;LOAD IT UP
	MOV E,C	;GET THE STARTING ADRS FOR THE PROCESS
	MOV C,PUPC(A)	;PUT THE STARTING ADRS. INTO ITS USER PC
	JSR PC,ITM0PO	;GET BACK THE ORIGINAL PROCESS
	MOV #.PRCAP!.PRWRT,A	;ITS A PROCESS CAPABILITY
	RTS PC			;SUCCESS
CCPRTT:	CMP E,#NTTY	;IS IT A LEGAL TTY NO.
	BGT CCPRSP	;NOPE TO LARGE
	ASL E		;TURN IT INTO THE WORD INDEX
	TST TTYITM(E)	;IS THERE ALREADY A ITEM FOR THIS TTY
	BNE CCPRSP	;YES, THIS IS A BAD CALL THEN
	JSR PC,CRTTY	;CREATE THE TTY
	BEQ CCRTS	;IT FAILED FOR SOME REASON
	MOV #.TTCAP!.TTYI!.TTYO,A	;GIVE HIM I/O CAPABILITY
	RTS PC

;CREATE A QUE CAPABILITY
CCPRQU:	MOV E,C	;THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
	BLE CRQUE1	;MORE THAN ONE
	JSR PC,CRQUE	;CREATE THE QUE
	BEQ CCPRQ1	;FAILED
	CLR C		;NO DATA WORDS
	MOV #.QUCAP,A	;THE TYPE
CCPRQ1:	RTS PC

;CREATE A QUE ITEM, C CONTAINS THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
CRQUE:	MOV #QUELEN,A	;LENGTH OF QUE
	JSR PC,CRITEM	;CREATE THE ITEM
	BEQ CRQUE1+2	;FAILED
	MOV B,A		;THE ITEM NO
	JSR PC,ITM2PL	;LOAD TI
	MOV #ITQUE,(A)	;SET THE TYPE
	CLR QUECNT(A)	;NOONE ON THE QUE TO START
	MOV C,QUENUM(A)	;THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
	MOV #1,QUEREF(A)	;ASSUME THE GUY WHO CREATES IT IS GOING TO REFERENCE IT
	MOV #QUESZ/2,QUEENO(A)	;THE NUMBER OF ENTRIES IN THE QUE
	JSR PC,ITM2PO	;POP THE QUE
	CLZ
	RTS PC
CRQUE1:	SEZ
	RTS PC
;CREATE A FILE CAPABILITY
CCPRFA:	MOV #MFLEN,A
	JSR PC,CRITEM		;MAKE A MFI
	BEQ CRQUE1+2		;NONE LEFT
	SAVE <B>
	MOV #LPCLRT,A		;LOCK SWITCH FOR PC LOSERING
	JSR PC,LOCKSW
	MOV #MFDELP,LCKWD1(A)	;MFI DELETE ROUTINE
	REST <B>
	MOV B,A			;PUT IT IN ITM2
	JSR PC,ITM2LD
	MOV A,D
	MOV #40,F
CCFA.2:	CLR (D)+		;CLEAR MFI
	SOB F,CCFA.2
	MOV #MFDWDB,MFLAGW(A)	;DELETE WHEN DONE
	MOV #MFNAME,F
	ADD A,F			;PTR INTO ITEM
	JSR PC,GETWRD		;BITS HE WANTS SET
	BIC #<-MFIRTB-MFILEB-MFLOKB>-1,C	;MASK GARBAGE
	BIS C,MFLAGW(A)
CCFA.3:	JSR PC,GETBYT
	MOVB C,(F)+
	BMI CCFA.4		;END OF NAME
	CMP F,#<ITM2AD+100>
	BLO CCFA.3
	BR CCFA.6		;OR ELSE ENLARGE ITEM
CCFA3A:	BIS #MFFILB,MFENHD(D)	;SET FILE TYPE IN HEADER WORD
	BIC #MFIRTB,@#<ITM2AD+MFLAGW>
	RTS PC		;DONE FOR FILE
CCFA.4:	INC F		;COMPUTE ENTRY LEGNTH
	SUB #MFENHD,F
	SUB A,F
	ASR F
	BIS F,MFENHD(A)
	BIT #177700,F
	BNE CCFA.6		;ENTRY TOO LARGE
	JSR PC,MFHASH		;LINK IT INTO HASH TABLE
	MOV A,D
	MOV MFLAGW(A),A
	BIS #<.FACAP!.FARD!.FAWT>,A
	CLR C
	BIT #MFILEB,A
	BNE CCFA3A		;IT'S A DIRECTORY
;FALLS THROUGH FOR DIRECTORIES
;DO DIRECTORY HEADER NOW
	SAVE <A,B,C>
	MOV D,A
	BIS #MFDIRB,MFENHD(A)	;SET DIRECTORY ENTRY TYPE
	BIT #MFIRTB,MFLAGW(A)
	BNE CCFA10
	JSR PC,ADDBLK		;FIND BLOCK AND MUNG ENTRY
	BNE CCFA.7
CCFA.5:	REST <C,B,A>		;FAILURE
	;RELEASE BLOCK AND DUMP UPT
CCFA.6:	JSR PC,LSWPOP		;THIS WOULD HAVE CALLED MFDELP ON PC LOSERING
	MOV B,A			;MFI ITEM #
	JSR PC,MFIDEL		;GET RID OF IT
	SEZ
	RTS PC
CCFA.7:	CLR B
	CLR C			;SET UP BLOCK # 0
	MOV P,D			;PLACE TO PUT GIP TO FUPT
	CLR F
	JSR PC,MFMFPT		;SET UP FPT
	BEQ CCFA.5
	SUB #FAUPT,D
	JSR PC,MFMUPT		;SET UP FUPT
	BEQ CCFA.5
	MOV E,F			;CORE ADDRESS
	MOV 2(P),A		;MFI ITEM #
	JSR PC,ITM1PL
	ADD MFENHD,A		;TRANSFER ENTRY TO CHILD DIRECTORY
	MOV (A),C
	BIC #177700,C
	MOV #1000,B
	SUB C,B
	ASL B			;LAST WORD OF BLOCK IS FREE BYTES
	MOV B,1776(E)
CCFA.8:	MOV (A)+,(E)+		;MOVE IT
	SOB C,CCFA.8
	CLR (E)+		;ENDS WITH WORD OF ZERO
	BIC #300,(F)		;ITS NOW A HEADER ENTRY
	JSR PC,ITM1PO
CCFA.9:	JSR PC,LSWPOP		;CLEAR UPTPRP
	REST <C,B,A>
	RTS PC			;A NOT ZERO
CCFA10:		;SET UP A ROOT DIRECTORY
	HALT
;INVOKE A PROCESS CAPABILITY, FUNCTION 0-7 IS USER'S REGISTERS
;10 IS USERS PS, 11-16 IS USERS FPP REGISTERS 17 IS FLOATING POINT STATUS
;40 BIT CLEAR MEANS READ (CURRENT VALUE PUSHED ON USERS STACK)
;40 BIT SET MEANS WRITE (2ND DATA WORD IS PLACED IN USERS REGISTER)
;A FUNCTION OF 20 ALLOWS READ/WRITE OF THE AVAILABILITY OF FPP
;IF READ, THE WORD RETURNED IS EITHER 1 (FLOATING POINT ENABLED) OR
;0 (NO FLOATING POINT).  IF WRITE, THE SECOND WORD ON THE STACK MUST BE 
;EITHER 1 OR 0.
CAPRPR:	REST D		;GET THE FUNCTION BYTE
	ASH #-7,D	;TURN IT INTO A WORD INDEX
	BIC #177001,D	;CLEAR EXTRA BITS
	MOV D,C		;COPY IT
	BIC #100,C	;CLEAR THE READ/WRITE BIT
	BIT #100,D	;IS HE WRITING
	BEQ CPRPR1	;NOPE
	BIT #.PRWRT,(A)	;DOES HE HAVE WRITE ACCESS?
	BNE CPRPR1	;YES
CPRPR2:	ADD #4,P
	JMP BADEMT	;BARF
CPRPR1:	CMP C,#7*2	;IS IT A GENERAL REGISTER
	BLE PRREG	;YES
	CMP C,#10*2	;IS IT THE USER PSW
	BLE PRPSW	;YES
	CMP C,#16*2	;IS IT A FLOATING REG.
	BLE PRFLRG
	CMP C,#17*2	;IS IT THE FLOATING POINT STATUS
	BGE .+6		;NOPE
	JMP PRFPST
	CMP C,#20*2	;IS IT A REQUEST FOR FPP ENABLE
	BGT CPRPR2	;NOPE, MUST BE A BAD REQUEST
	JMP PRSIZE

PRREG:	MOV 2(A),A	;GET THE PROCESS ITEM NO.
	JSR PC,ITM0PL	;LOAD IT UP
	ADD C,A		;MAKE A POINT TO THE REG (WELL ALMOST)
	BIT #100,D	;READING?
	BNE REGWRT	;NOPE
	MOV PUREGS(A),B	;GET THE APPROPRIATE REG INTO B
PRRET1:	JSR PC,ITM0PO	;RESTORE THE CALLING PROCESS
	JSR PC,GIVPSW	;GIVE IT TO HIM
	ADD #4,P	;GET RID OF TWO ARGUMENTS
	JMP ERETCZ	;WE WIN
REGWRT:	REST PUREGS(A)	;SECOND ARG GOES INTO REGISTER	
PRRET0:	JSR PC,ITM0PO	;RESTORE THE CALLING PROCESS
	TST (P)+	;GET RID OF THIRD ARG
	JMP ERETCZ	;WE WIN
	;HERE IS PSW AND FLOATING REG READ

PRPSW:	BIT #100,D	;IS HE WRITING
	BEQ PRREG	;NOPE JUST TREAT IT LIKE A REGISTER
	MOV 2(A),A	;GET THE PROCESS ITEM NO.
	JSR PC,ITM0PL	;LOAD IT UP
	ADD C,A		;MAKE A POINT TO THE PSW (ALMOST)
	MOV PUREGS(A),B	;GET THE CURRENT PSW
	BIC #37,B	;THE BITS THE INVOKER CAN CHANGE
	BIC #177740,(P)	;DON'T LET HIM CHANGE THE TOP BITS
	BIS B,(P)	;COMBINE THE OLD WITH THE NEW
	BR REGWRT	;WRITE IT LIKE AN ORDINARY REG.

PRFLRG:	MOV (P),E	;RESTORE POINTER TO DATA
	MFPD (E)+	;MAKE SURE WE CAN GIVE IT TO HIM
	MFPD (E)+
	MFPD (E)+
	MFPD (E)+
	REST E		;POINTER TO DATA IS 2ND ARG
	SUB #2*11,C	;MAKE THIS AN INDEX TO A FLOATING REG
	ASH #2,C	;EACH REGISTER IS 4 WORDS
	MOV 2(A),A	;GET THE ITEM NO OF THE PROCESS EXAMINED
	JSR PC,ITM0PL	;LOAD IT UP
	BIT #PFPFLG,PFLAGS(A)	;DOES HE HAVE THE FPP ENABLED?
	BEQ PRFLT3	;NOPE
	BIT #100,D	;IS HE WRITING INTO THIS REG?
	BNE PRWRT	;YEP
	ADD C,A		;MAKE THE A POINT TO A FLOATING REG(ALMOST)
	ADD #PFPPRG+10,A	;MAKE IT ABSOLUTELY POINT TO THE APPROPRIATE REG
	SAVE <-(A),-(A),-(A),-(A)>	;SAVE THE FPP REGISTER
	JSR PC,ITM0PO	;RESTORE THE CALLING PROCESS
	MTPD (E)+	;GIVE HIM THE REGISTER IF YOU CAN
	MTPD (E)+
	MTPD (E)+
	MTPD (E)+
	TST (P)+	;GET RID OF THIRD ARG
	JMP ERETCZ	;SUCCEEDED DON'T RETURN ANYTHING
PRFLT3:	REST A		;POP OFF 3RD ARG
	JSR PC,ITM0PO	;GET BACK CALLING ITEM
PRFLT2:	JMP BADEMT	;GO TELL HIM

PRWRT:	JSR PC,ITM0PO	;IN CASE WE HANG
	MFPD (E)+	;GET THE REGISTER (IF WE CAN)
	MFPD (E)+
	MFPD (E)+
	MFPD (E)+
	MOV 2(A),A
	JSR PC,ITM0PL	;LOAD IT BACK UP AGAIN
	ADD C,A		;MAKE THE A POINT TO A FLOATING REG(ALMOST)
	ADD #PFPPRG+10,A	;MAKE IT ABSOLUTELY POINT TO THE APPROPRIATE REG
	REST <-(A),-(A),-(A),-(A)>	;PUT THE REGISTER AWAY
	TST (P)+	;GET RID OF EXTRA ARG
	JSR PC,ITM0PO	;GET BACK CALLING PROCESS
	JMP ERETCZ	;SUCCESS
PRFPST:	MOV 2(A),A	;GET THE ITEM NO. OF THE PROCESS
	JSR PC,ITM0PL	;LOAD IT UP
	BIT #PFPFLG,PFLAGS(A)	;DOES IT USE THE FPP
	BEQ PRFLT2	;NO LUSER
	BIT #100,D	;IS IT A WRITE
	BNE PRSTWT	;YES
	MOV PFPPS(A),B	;GET THE STATUS
	JMP PRRET1	;RETURN ONE ARG.
PRSTWT:	REST PFPPS(A)	;PUT THE SECOND ARG INTO FPP STATUS
	JMP PRRET0	;RETURN NO ARG
PRSIZE:	BIT #100,D	;IS HE WRITING
	BNE PWRT	;YEP
	MOV 2(A),A	;GET THE ITEM INDEX OF PROCESS
	CLR B		;ASSUME THAT THERE ISNT ANY FPP
	JSR PC,ITM0PL	;LOAD IT
	BIT #PFPFLG,PFLAGS(A)	;DOES HE HAVE FPP
	BNE PRSIZ1	;YES
	JMP PRRET1	;RETURN 1 ARG SAYING NO FLOATING POINT
PRSIZ1:	INC B		;SAY HE HAS FPP
	JMP PRRET1	;RETURN 1 ARG

PWRT:	REST E	;GET THE FIRST ARG
	CMP E,#1	;IS IT A LEGAL ARG
	BHI PRLOSE	;ITS TOO BIG
	BEQ PWRT1	;ITS A REQUEST FOR FPP
	MOV 2(A),B	;THE ITEM INDEX OF WHAT TO SHRINK
	MOV #PRSLNF,A	;TELL IT THE SIZE WE WANT
	JSR PC,EXITEM	;SHRINK THIS ITEM
	MOV B,A		;GET NEW ITEM INDEX
	JSR PC,ITM0PL	;LOAD IT UP
	BIC #PFPFLG,PFLAGS(A)	;SAY HE DOESN'T HAVE FPP
	JMP PRRET0	;RETURN SUCESSFUL
PWRT1:	SAVE A		;SAVE POINTER TO CAPABILITY
	MOV 2(A),B	;ITEM INDEX OF PROCESS INTO B
	MOV #PRSLFP,A	;THE LENGTH WE WANT IT TO BE
	JSR PC,EXITEM	;EXPAND THE PROCESS
	BEQ PWRT2	;IT FAILED
	REST A		;GET BACK POINTER TO CAPABILITY
	CLRB 2(A)	;CLEAR OUT OLD ITEM NO
	MOVB B,2(A)	;INSTALL NEW ITEM INDEX (RETAINING FLAGS)
	MOV B,A
	JSR PC,ITM0PL	;LOAD UP NEW ITEM
	BIS #PFPFLG,PFLAGS(A)	;SAY WE HAVE FPP
	MOV #40300,PFPPS(A)	;START WITH INT. DISABLED AND LONG AND DOUBLE
	JMP PRRET0	;RETURN NO ARG
PWRT2:	ADD #4,P	;POP OFF TWO RANDOM WORDS
	JMP ERETSZ
PRLOSE:	TST (P)+	;GET RID OF THE THIRD ARG
	JMP BADEMT
	.STITL COPY CAPABILITY ROUTINES
CPYXX:	BPT		;ZERO CAPABILITY
CPYQU:	HALT
;COPY PROCESS CAPABILITY, 2ND ARG SPECIFIES A MASK OF BITS TO
;BE CLEARED, NO BITS MAY BE SET.
CPYPR:	CLRB E		;MAKE SURE YOU ONLY TOUCH THE TOP BYTE
	BR CPYFA1	;CREATE THE SPERE CAP.

CPYFA:	BIC #<-.FARD-.FAWT-.FAAP>-1,E
	BIS #.FAMFL,E
CPYFA1:	MOV 2(F),B	;THE ITEM NO.
	JSR PC,SPRINC
	MOV (F),A	;THE FLAG WORD
	BIC E,A
	RTS PC

CPYCC:	CLR B
	MOV #.CCCAP,A	;SAY ITS A CREATE CAPABLITY
	RTS PC

;COPY TTY CAPABILITY, SAME AS COPY SPHERE
CPYTT:
;COPY SPHERE CAPABILITY, ARGS SAME AS PROCESS CALL
CPYSP:	MOV (F),A
	BR CPYMS1

;COPY A MASTER SPHERE CAPABILITY, BECOMES A SPHERE CAP. 2ND ARG
;SPECIFIES A MASK OF BITS TO BE CLEARED DURING THE COPY

CPYMS:	MOV #MSPCBT!.SPCAP,A
	TST 4(F)	;IS THIS THE FIRST COPY OF A MASTER SPHERE?
	BNE CPYMS1	;NOPE
	BIC #177400,E
	MOV D,10(F)	;MAKE THE MASTER SPHERE POINT TO ITSELF TEMPORARILY
	MOV ITEM1,4(F)	;SET IN THE ITEM NO.
CPYMS1:	MOV 2(F),B	;THE ITEM NO.
	JSR PC,SPRINC	;INCREMENT SPERE'S REFERENCE COUNTER
	CLRB E		;ONLY THE TOP BYTE IS SIGNIFICANT
	BIC E,A		;CLEAR THE CORRECT BITS
	MOV 2(P),E	;POINTER TO CAP DESTINATION
	MOV 2(F),B	;THE ITEM NO. OF SPHERE OF MS CAP
	MOV 4(F),4(E)	;POINTER TO NEXT SPHERE CAP
	MOV 10(F),10(E)	;REST OF POINTER TO NEXT CIRCULAR LIST ENTRY
	MOV ITEM1,4(F),	;THE FIRST SPHERE ON CIRCLE LIST IS THIS SPHERE
	MOV 4(P),10(F)	;THE CAP. NO IS IN B
	RTS PC
	.STITL GIVE CAPABILIY ROUTINES
GIVXX:	BPT
GIVSP:	SAVE <A,B,C,D>
		;A CONTAINS RELATIVE POINTER TO DEST. C-LIST ENTRY
		;B THE C-LIST NO. OF DEST
		;C THE SPHERE NO. OF DEST
	MOV E,B		;THE C-LIST NO. OF THE SOURCE C-LIST ENTRY
	MOV D,A	;THE POINTER TO THE SOURCE C-LIST ENTRY
	JSR PC,FNBKPT	;FIND THE PREVIOUS ENTRY IN CIRCULAR LIST
	MOV C,A		;THE PREVIOUS SPHERE
	MOV D,B		;THE PREVIOUS C-LIST NO
	JSR PC,ITM1PL	;LOAD IT UP
	JSR PC,GCLSTA	;FIND IT
	ADD A,B		;MAKE A POINT TO IT
	TST (B)		;IS IT HERE
	BNE .+4		;ITS THERE
	BPT
	CMP (B),#-1
	BEQ .-6
	MOV 2(P),4(B)	;CORRECT SPHERE POINTER
	MOV 4(P),10(B)	;CORRECT C-LIST POINTER
	JSR PC,ITM1PO	;POP THE SPHERE
	REST <D,C,B,A>
		;FALL THROUGH AND TRANSFER THE CAPABILITY

		;MAY FALL THROUGH FROM GIVE SPHERE ROUTINE
GIVCC:			;CREATE CAP. GIV IS SAME AS PROCESS CAP. GIVE
GIVFA:			;FA CAP GIVE JUST COPIES IT
GIVTT:
GIVPR:	JSR PC,GIVPSW	;GIVE HIM THE WORD, (CAN'T FAIL FROM HERE ON IN)
	SAVE A		;SAVE THE POINTER TO THE CAP TO GIVE
	MOV C,A		;THE DESTINATION SPHERE
	JSR PC,ITM2PL	;LOAD IT UP
	ADD (P)+,A	;MAKE A POINT TO THE C-LIST ENTRY
	MOV D,B		;POINTER TO THE CAPABILITY TO GIVE
	MOV (B)+,(A)+	;MOV THE CAPABILITY
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	JSR PC,ITM2PO	;POP THE ITEM
	CLR (D)		;GET RID OF IT
	ADD #4,P	;POP OFF THE TWO ARGS
	JMP ERETCZ
GIVMS:	HALT
GIVQU:	HALT

	.STITL DELETE CAPABILITY ROUTINES
DELXX:	BPT	;ZERO CAPABILITY
DELCC:	CLR (A)		;CLEAR THE FIRST WORD
	CLZ
	RTS PC
DELPR:	CLR (A)	;FLUSH THE CAPABILITY
	MOV 2(A),A	;GET THE ITEM INDEX
	JSR PC,PSTPIN	;STOP HIM FROM RUNNING
	SAVE A
	JSR PC,DLPROC	;DEC PROCESSES REF COUNT
	BEQ DELPR1	;WE DELETED THE PROCESS
	REST A		;GET THE PROCESS ITEM NO.
	JSR PC,PSTPDC	;DECREMENT HIS STOP COUNT
	CLZ
	RTS PC
DELPR1:	REST A		;GET BACK ITEM INDEX
	CLZ
	RTS PC

DELSP:	SAVE A
	MOV E,B		;THE CAP. NO. TO FLUSH
	JSR PC,FNBKPT	;FIND THE PREVIOUS ENTRY
	MOV (P),A	;GET THE ADDRESS BACK
	MOV 4(A),E	;THIS SPHERE'S POINTER
	MOV 10(A),F	;THE REST OF THE POINTER
	MOV C,A		;THE PREVIOUS ENTRY'S SPHERE
	JSR PC,ITM1PL	;LOAD IT UP
	JSR PC,GCLSTA	;GET APOINTER TO IT
	ADD A,B		;MAKE THE POINTER ABSOLUTE
	TST B		;DOES IT EXIST
	BNE .+4	;YES
	BPT
	MOV E,4(B)	;SPLICE OUT ENTRY WE ARE DELETING
	MOV F,10(B)
	JSR PC,ITM1PO	;POP THE SPHERE
	REST A
;DELETE TTY CAPABILITY, JUST DEC REFERENCE COUNT, AND FLUSH CAP.
DELTT:	CLR (A)		;FLUSH THE CAPABLITY
	MOV 2(A),A	;THE ITEM INDEX OF THE SPRERE
	JSR PC,SPRDEC	;DECREMENT SPHERE REF COUNT
	CLZ
	RTS PC
DELQU:	HALT
DELFA:	MOV FAUPT(A),B
	BEQ DLFA.1
	JSR PC,UPTDEL	;DELETE THE FUPT
DLFA.1:	MOV A,C		;DELETE THE FA CAP
	MOV FAMFI(A),A
	BIT #.FAMFL,(C)	;DID HE LOCK THE MFI
	BEQ DLFA.2
	JSR PC,ITM2LD	;LOAD THE MFI AND CLEAR THE LOCK BIT
	BIC #MFLOKB,MFLAGW(A)
	MOV ITEM2,A
DLFA.2:	CLR (C)
	JSR PC,MFIDEL	;DECREMENT REFERENCE COUNT
	CLZ
	RTS PC
;THIS ROUTINE DOES A .MSCAP DELETE. DEPTH COUNT IS INC WHEN YOU GO TO A LOWER SPHERE
;1.) DELETE SPHERE CAPABILITIES IN C-LIST
;2.) STOP ALL THE PROCESSES IN ALL THE INFERIOR SPHERES, AND THE SPHERE POINTED TO
;3.) LOCK A SWITCH THAT REVERSES THE PROCESS IF PCLOSERED
;4.) THEN GO TO THE BOTTOM OF THE TREE, DELETE THE ENTIRE C-LIST.
;5.) POP UP ONE LEVEL AND DELETE THE UPT'S IN THAT SPHERE
;6.) DELETE THE SPHERE ITEM CONTINUE UNTIL DEPTH COUNT IS -1.
;NOTE THAT TO STOP ALL THE PROCESSES, INVOLVES A COMPLETE SEARCH OF EACH C-LIST
;AND THAT TO GO TO THE BOTTOM OF THE TREE, INVOLVES STORING A RECORD OF THE MOST
;INFERIOR SPHERE.
DELMS:	MOV A,F		;FOR SPCPDL (THE POINTER TO THE CAPABILITY)
	JSR PC,SPCPDL	;DELETE THE CIRCULAR LIST OF SPHERE CAP
	MOV 2(F),A	;THE SPHERE AFFECTED
	JSR PC,ITM1PL	;LOAD THE SPHERE
	MOV #1,SPHREF(A) ;SET THE MSCAP REF CNT NOW WE ARE PCLABLE
			;NOW STOP ALL THE PROCESSES IN IFERIOR SPHERES
	MOV #-1,E	;SAY THAT WE WANT TO STOP THE MASTER SPHERE
	JSR PC,STPMS	;STOP OR START MASTER SPHERE
	MOV ITEM1,B	;THE SPHERE TO START
	MOV #LPCLRT,A	;RUN A ROUTINE WHEN PCLOSERED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCMSST,LCKWD1(A)	;THE ROUTINE TO RUN (STARTS UP THE SPHERE)
	MOV ITM1A,A	;THE ADDRESS OF THE SPHERE IN THE MAP
	CLR -(P)	;A FLAG THAT SAYS THAT WE HAVE DELETED THE INFERIOR SPHERE
	CLR -(P)	;A DEPTH COUNT
MSDEL5:	CLR E		;THE CURRENT C-LIST NO
	MOV #MNCLSE/NCLSEB,F	;THE NUMBER OF BLOCKS IN A C-LIST
MSDEL4:	MOV E,B		;THE CURRENT C-LIST NO.
	JSR PC,GCLSTA	;GET THE C-LIST ENTRY
	BEQ MSDEL1	;NO C-LIST ENTRY EXIST
	ADD A,B		;MAKE B POINT TO THE CAP.
	MOV #NCLSEB,C	;THE NUMBER OF C-LIST ENTRIES IN A BLOCK
MSDEL3:	CMPB (B),#.MSCAP	;IS IT A MASTER SPHERE CAP.
	BEQ MSDEL2	;YES, SAY WE ARE GOING DOWN
	TST (B)		;ANYONE HOME
	BEQ MSDEL7	;NOPE
	JSR F,ACSAV	;SAVE THE AC'S
	SAVE ITEM1	;SAVE THE ITEM NO
	JSR PC,ITM1PO	;POP IT IN CASE WE GET STOPPED
	MOV B,A		;MAKE A POINT TO THE CAP.
	MOV (A),B	;FIRST WORD OF CAP
	ASL B		;TURN IT INTO A WORD INDEX
	BIC #177001,B	;CLEAR THE EXTRA BITS
	JSR PC,@DELTAB(B)	;DELETE THE CAPABILITY
	BNE .+4		;SUCCEEDED
	BPT		;FAILED WHERE IT SOULDN'T
	REST A		;THE ITEM NO.
	JSR PC,ITM1PL	;LOAD IT BACK UP
	JSR F,ACRES	;RESTORE THE AC'S
MSDEL7:	ADD #CLSELN,B	;GET THE NEXT C-LIST ENTRY
	INC E		;UPDATE THE C-LIST NO
	SOB C,MSDEL3	;TRY THE NEXT C-LIST ENTRY
	BR .+6		;E IS ALREADY CORRECT
	;BRANCHES INTO NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
MSDEL1:	ADD #10,E	;MAKE E POINT TO THE NEXT BLOCK OF C-LIST
	SOB F,MSDEL4
	INC 2(P)	;SET THE FLAG SAYING ALL DONE HERE
	DEC (P)		;SAY WE ARE ONE LEVEL UP
	BMI MSDERT	;NEGATIVE SAYS WE ARE DONE
	MOV SMSSPT(A),A	;THE ITEM NO. OF THE SUPERIOR SPHERE
	JSR PC,ITM1LD	;LOAD UP THE SUPERIOR ITEM
	BR MSDEL5	;GET THE SUPERIOR SPHERE
MSDEL2:	TST 2(P)	;IS IT'S C-LIST DELETED
	BNE MSDEL6	;YES
	INC (P)		;INC THE DEPTH COUNT
	MOV 2(B),A	;THE SPHERE NO. OF THE INFERIOR SPHERE
	JSR PC,ITM1LD	;LOAD THAT SPHERE
	BR MSDEL5	;DELETE IT'S C-LIST
MSDERT:	JSR F,ACSAV	;IT EXPECTS THESE SAVED
	MOV ITEM1,A	;THE SPHERE NO. THAT WE ARE DELETING
	BR MSDEL9	;DELETE THE SPHERE'S UPTS
MSDEL6:	JSR F,ACSAV	;SAVE THE AC'S
	MOV B,F		;POINTER TO CAPABILIY
	JSR PC,SPCPDL	;DELETE ITS CIRCULAR LIST
	MOV 2(F),A	;THE ITEM NO. OF THE CAPABILITY
	CLR (F)		;NOW DELETE THE CAPABILITY ITSELF
	MOV #20,F	;THE NUMBER OF UPT'S
MSDEL9:	MOV A,C		;THE ITEM NO. OF THE SPHERE
	MOV ITEM1,E	;SAVE THIS FOR LATER
	JSR PC,ITM1PO	;POP THE SPHERE IN CASE WE GET STOPPED
MSDEL8:	MOV F,B		;GET THE UPT NO. TO DELETE
	DEC B		;MAKE IT BETWEEN 0-17
	JSR PC,SUPTDL	;DELETE THIS UPT
	SOB F,MSDEL8	;DO IT FOR ALL THE UPT'S
	MOV E,A		;THE SPHERE WE WERE IN BEFORE
	JSR PC,ITM1PL	;LOAD IT BACK UP
	MOV C,A		;THE SPHERE THAT WE ARE DELETING
	JSR PC,DLITEM	;DELETE THE SPHERE (WHEW)
	JSR F,ACRES	;RESTORE THE AC'S
	CLR 2(P)	;CLEAR THE FLAG
	TST (P)		;IS THIS THE LAST TIME
	BPL MSDEL7	;NOPE
	JSR PC,ITM1PO	;POP THE EXTRA STUFF
	ADD #4,P	;POP OFF THE FLAG WORDS
	MOV ITM0A,A	;THE ADDRESS OF THE PROCESS
	MOV PUP(A),B	;THE TOP OF THE USERS PDL
	MFPD (B)	;GET THE C-LIST NO. OF THE MSCAP AGAIN
	REST B		;THE CAPABILITY NO.
	BIC #177400,B	;CLEAR THE DELETE TAG
	MOV ITM1A,A	;THE ADDRESS OF THE SPHERE
	JSR PC,GCLSTA	;GET A POINTER TO THE C-LIST ENTRY
	ADD A,B		;MAKE B POINT TO IT
	CLR (B)		;DELETE THE ACTUAL CAP.
	CLZ
	RTS PC
;THIS ROUTINE TAKES POINTER TO CAPABILITY IN F, THE MSCAP NO. IN E
;IT DELETES THE CIRCULAR LIST ASSOCIATED WITH IT.
SPCPDL:	MOV ITEM1,A	;MAKE A BOGUS PUSH
	JSR PC,ITM2PL
	TST 4(F)	;IS THERE A CIRCULAR LIST
	BEQ SPCPDN	;NO
	MOV F,A		;RESTORE POINTER TO CAPABILITY
	BR SPCPD3	;A ALREADY POINT TO THE CAPABILITY AND DON'T WANT MSCAP TO GO AWAY
SPCPD4:	CMP ITEM2,ITEM1	;IS THIS THE SAME SPHERE AS WE STARTED WITH
	BEQ SPCPD2	;YES, DON'T BOTHER TO TEST THE C-LIST LOCK (WE ALREADY LOCKED IT)
	TST SCLSLK(A)	;IS THE C-LIST LOCKED?
	BEQ SPCPD2	;NO, JUST DELETE IT
	MOV SCLSLK(A),A	;THE PROCESS THAT LOCKED IT
	JSR PC,PSTPIN	;STOP HIM, (I WANT THAT C-LIST BAD)
	JSR PC,ITM0PL	;LOAD IT UP FOR PSTPDC
	JSR PC,PSTPDC	;RESTART HIM
	JSR PC,ITM0PO	;POP THE PROCESS
	MOV ITM2A,A	;GET THE ADDRESS BACK
	TST SCLSLK(A)	;IT HAD BETTER BE 0
	BEQ .+4		;IT IS
	BPT		;ERF, THE PERSON WHO WAS SUPPOSED TO LOCK IT DIDN'T
SPCPD2:	ADD B,A		;MAKE A POINT TO THE SPHERE CAPABILITY
SPCPD3:	CLR (A)		;MAKE THIS CAPABILITY GO AWAY
	MOV 10(A),B	;THE C-LIST NO. OF NEXT CAP.	
	MOV 4(A),A	;GET THE SPHERE POINTER TO THE NEXT CAPABILITY
	BNE .+4		;GOT IT
	BPT		;CIRCULAR LIST MUNGED
	CMP A,ITEM1	;IS THIS THE SAME SPHERE
	BNE SPCPD1	;NO
	CMP B,E		;SAME AS THE MSCAP?
	BEQ SPCPDN	;YES, WE ARE DONE
SPCPD1:	CMP A,ITEM1	;IS THIS THE CURRENT SPHERE
	BEQ SPCPD5	;YES, DON'T STOP IT
	MOV A,C		;SAVE FOR SPRSTP
	JSR PC,SPRSTP	;STOP THE SPHERE
	JSR PC,SPRSTR	;START IT
	MOV C,A		;RESTORE THE SPHERE NO.
SPCPD5:	JSR PC,ITM2LD	;LOAD THE NEXT SPHERE
	MOV ITM2A,A	;GET THE ADDRESS
	JSR PC,GCLSTA	;GET POINTER TO NEXT CAP
	BNE SPCPD4	;GO BACK AND TRY AGAIN
	BPT		;ERF, SOMETHING IS SCREWED
SPCPDN:	JSR PC,ITM2PO	;POP THE ITEM PUSHED
	CLR 4(F)	;MAKE SURE THERE IS NO CIRCULAR LIST
	CLR 10(F)	;DITTO
	RTS PC
TAKXX:	BPT	;THE ZERO CAPABILITY
TAKSP:	SAVE <A,B,C,D>
	MOV C,A		;THE SPHERE OF THE TAKEE
	SAVE ITEM1	;CURRENT SPHERE NO.
	JSR PC,ITM1PL	;LOAD IT UP
	ADD D,A		;MAKE A POINT TO THE CAP
	MOV E,B		;B IS THE C-LIST NO.
	JSR PC,FNBKPT	;GET BACK POINTER
	MOV C,A		;THE PREVIOUS SPHERE
	MOV D,B		;THE PREVIOUS C-LIST NO.
	JSR PC,ITM1LD	;LOAD IT UP
	JSR PC,GCLSTA	;GET THE CAPABILITY
	ADD A,B		;MAKE A POINT TO THE CAP.
	TST (B)		;IS IT THERE
	BNE .+4		;YEP
	BPT
	REST 4(B)	;THE CURRENT SPHERE IS WHERE THIS SHOULD POINT
	MOV 4(P),10(B)	;SET THE C-LIST NO. ALSO
	JSR PC,ITM1PO	;POP THE ITEM STACK
	REST <D,C,B,A>

TAKFA:
TAKTT:
TAKPR:
TAKCC:	JSR PC,GIVPSW	;GIVE THE USER THE C-LIST NO. OF DEST
	SAVE A		;SAVE POINTER TO WHERE THE CAP. IS GOING
	MOV C,A		;THE SPHERE TO TAKE FROM
	JSR PC,ITM2PL	;LOAD IT UP
	ADD D,A		;MAKE THE POINTER ABSOLUTE
	REST B		;POINTER TO DESTINATION
	SAVE A
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	CLR @(P)+	;FLUSH THE CAPABILITY
	JSR PC,ITM2PO
	ADD #4,P	;POP THE TWO ARGS
	JMP ERETCZ
;THIS ROUTINE MAKES SURE THAT THE SPHERE STRUCTURE ALWAYS POINTS DOWN
TAKMS:	SAVE <A,B,C>
	SAVE ITEM1	;THE SPHERE OF TAKER
	MOV C,A		;THE SPHERE OF TAKEE
	JSR PC, ITM1PL	;LOAD IT UP
	ADD D,A		;MAKE A POINT TO THE CAPABILITY TO BE TAKEN
	MOV 2(A),C	;THE SPHERE THAT THE MASTER SPHERE CAP. REFFERS TO
	REST A		;GET THE TAKER'S SPHERE NO.
	CMP C,A		;IS TAKING HIS OWN MASTER SPHERE CAPATILITY
	BEQ TAKMS1	;YES, DONT LET HIM
	CMP C,SYSSPR	;IS HE TAKING THE SYSTEM SPHERE'S MASTER CAP. TO ITSELF
	BEQ TAKMS1	;YES DONT ALLOW HIM TO
TAKMS2:	JSR PC,ITM1LD	;LOAD UP THE SPHERE
	MOV SMSSPT(A),A	;GET THIS SPHERES MASTER SPHERES NO
	CMP A,SYSSPR	;ARE WE AT THE ROOT OF THE SPHERE TREE
	BEQ TAKMS3	;YES
	CMP C,A		;IS IT A SUPERIOR OF THE TAKER
	BNE TAKMS2	;NOPE, GET THE NEXT SUPERIOR
TAKMS1:	JSR PC,ITM1PO
	ADD #12,P	;GET RID OF ALL THE GARBAGE
	JMP ERETSZ	;TELL HIM HE CAN'T TAKE THIS ONE
TAKMS3:	JSR PC,ITM1PO	;POP THE SPHERE
	JSR PC,SPRSTP	;STOP THE SPHERE THAT THE MS CAP. REFERS TO
	MOV C,B		;THE SPHERE THAT WE STOPPED
	MOV #LCKRTN,A	;RUN A ROUTINE WHEN UNLOCKED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCSPST,LCKWD1(A)	;START THE SPHERE WHEN IT IS NULOCKED
	MOV ITEM0,B	;SAY WE LOCKED THE C-LIST
	MOV #SCLSLK,A	;LOCK ITS C-LIST
	JSR PC,LCKASW	;LOCK IT IF YOU CAN
	MOV C,A		;THE SPHERE NO.
	JSR PC,ITM2PL	;LOAD IT
	MOV ITEM1,SMSSPT(A)	;UPDATE THE SUPERIOR SPHERE POINTER
	JSR PC,ITM2PO	;POP THE SPHERE
	REST <C,B,A>
	JMP TAKSP	;UPDATE THE CIRCULAR PINTERS AND TAKE THE CAPABILITY
TAKQU:	HALT

;INCREMENT SPHERE OR PROCESS REFERENCE COUNT, ITEM NO. IN C
;THIS DEPENDS ON THE SPHERE AND PROCESS REFERENCE COUNT BEING IN THE SAME PLACE
.IIF NZ SPHREF-PRSREF,.ERROR BARF IT WONT WORK
SPRINC:	SAVE A		;DON'T CLOBBER A
	MOV B,A		;GET THE ITEM NO.
	JSR PC,ITM1PL	;LOAD THE SPERE
	INC SPHREF(A)	;INC REFERENCE COUNT
	JSR PC,ITM1PO	;RELOAD ORIGINAL ITEM1
	REST A		;RESTORE IT
	RTS PC
;DECREMENT THE SPHERE'S REFERENCE COUNT, ITEM NO. IN A
SPRDEC:	JSR PC,ITM1PL	;LOAD THE SPHERE
	DEC SPHREF(A)	;DECREMENT THE REFERENCE COUNT
	BEQ SPRDC1	;NO ONE REFERS TO IT ANY MORE
	JSR PC,ITM1PO	;POP THE ITEM STACK
	RTS PC
SPRDC1:	MOV ITEM0,A	;SAVE THE ITEM NO.
	JSR PC,ITM1PO	 ;IN CASE WE GET STOPPED
	JSR PC,DLITEM	;DELETE THE ITEM
	RTS PC
	.STITL I-O ROUTINES
EWRDI:	MOV #WDITAB,F
	BR IOTYPE
EWRDO:	MOV #WDOTAB,F
	BR IOTYPE
EBYTI:	MOV #BTITAB,F
	BR IOTYPE
EBYTO:	MOV #BTOTAB,F
	BR IOTYPE
EBLKI:	MOV #BKITAB,F
	BR IOTYPE
EBLKO:	MOV #BKOTAB,F

IOTYPE:	JSR PC,RETNSW	;GET THE CAP NO. OF THE IO DEVICE
	TST A		;IF IT IS NEGATIVE, WAIT FOR COMPLETION
	SXT E		;SET A FLAG FOR I-O ROUTINES
	MOV A,B		;CAP NO.
	BIC #177400,B	;CLEAR THE EXTRA BITS
	MOV ITM1A,A	;START OF SPHERE
	JSR PC,GCLSTA	;GET THE CAPABILITY
	BEQ IOTYP1	;FAILED
	ADD B,A		;MAKE A POINT TO THE CAP.
	MOV A,D		;SAVE POINTER FOR IO ROUTINES
	MOV (A),B	;TYPE AND FLAGS OF CAP.
	BEQ IOTYP1	;NOTHING THERE
	CMPB #.TTCAP,B	;IS IT A TELTYPE CAPABILITY
	BEQ TTYIO
	CMPB #.FACAP,B	;IS IT A FILE ACCESS CAPABILITY
	BEQ DSKIO	;YES
IOTYP1:	JMP ERETSZ	;TELL HIM HE FAILED
	;BRANCHES INTO NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
DSKIO:	MOV D,A		;POINTER TO THE CAPABILITY
	SUB ITM1A,A	;MAKE IT RELATIVE TO THE START OF THE ITEM
	MOV #.FALB,B	;THE BIT TO LOCK
	MOV ITEM1,C	;LOCK IT IN THE CURENT SPHERE
	JSR PC,LCKASW	;LOCK THE SWITCH
	JMP @(F)		;THE DISK ROUTINES ARE FIRST IN TABLE
TTYIO:	MOV 2(D),A	;THE TTY ITEM NO.
	JSR PC,ITM2PL
	CMP ITEM1,TTITM(A)	;DO I CURRENTLY OWN IT
	BNE TTYIO1	;NOPE
	JSR PC,ITM2PO
	JMP @2(F)	;THE TTY ROUTINES ARE SECOND IN TABLE
TTYIO1:	MOV ITEM2,A	;SAVE IT FOR LATER
	JSR PC,ITM2PO
	TST E		;SHOULD I WAIT
	BMI .+6		;YES
	JMP ERETSZ	;FAIL
	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL
	CMP ITEM1,TTITM(A)	;DO I OWN IT NOW
	BNE TTYIO1	;NO, GO FLUSH YOURSEF AGAIN
	JSR PC,ITM2PO
	JSR PC,RUNME	;I THINK I HAVE GOT THE TTY
	BR TTYIO	;GO TRY AGAIN

;THIS ROUTINE TAKES A CHARACTER FROM THE TTY POINTED TO BY THE CAPABILITY POINTED TO BY D
;AND PUTS IT ON THE TOP OF THE USERS STACK
TTBTI:	BIT #.TTYI,B	;DOES HE HAVE INPUT ACCESS
	BEQ TTBTI1	;NOPE
	MOV 2(D),A	;GET THE TTY ITEM NO
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,TIOQ	;GET A CHAR
	BNE TTBTI2	;GOT ONE
TTBTI3:	JSR PC,ITM2PO
	TST E		;SHOULD WE WAIT
	BPL TTBTI1	;NOPE
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	MOV 2(D),A	;THE TTY ITEM NO
	JSR PC,ITM2PL	;LOAD IT
	JSR PC,TIOQ	;GET A CHAR
	BEQ TTBTI3	;COULDN'T
	JSR PC,ITM2PO
	JSR PC,RUNME	;I GOT ONE
TTBTI2:	MOV D,B		;THE CHAR
	JSR PC,GIVPSW	;GIVE IT TO THE USER
	JMP ERETCZ
TTBTI1:	JMP ERETSZ


;THIS ROUTINE  IS THE SAME AS THE TTBTI, EXCEPT IT RETURNS TWO CHARACTERS
;THE FIRST IN THE LOW ORDER BYTE, AND THE NEXT IN THE TOP ORDER BYTE
TTWDI:	BIT .TTYI,B	;DOES HE HAVE INPUT ACCESS
	BEQ TTWDI3	;NOPE
TTWDI4:	MOV 2(D),A	;THE TTY ITEM NO.
	JSR PC,ITM2PL	;LOAD IT UP
	MOV #2,B	;THE NUMBER OF CHARACTERS NEEDED
	JSR PC,CHARCK	;CHECK TO SEE IF THERE ARE ENOUGH
	BLT TTWDI1	;NOPE
	JSR PC,TIOQ	;GET A CHAR
	MOV D,B		;SAVE IT
	JSR PC,TIOQ	;GET THE SECOND CHAR
	SWAB D		;PUT IT INTO THE TOP BYTE
	BIS D,B		;PUT THEM BOTH IN THE SAME WORD
	JSR PC,ITM2PO
	JSR PC,GIVPSW	;GIVE THE WORD TO THE USER
	JMP ERETCZ	;RETURN SUCCESSFUL
TTWDI1:	TST E		;SHOULD WE WAIT
	BMI TTWDI2	;YES
	JSR PC,TIOQ	;GET A CHARACTER IF IT EXISTS
	BNE .+6		;GOT ONE
TTWDI3:	JMP ERETSZ
	MOV D,B		;THE CHAR
	JSR PC,ITM2PO	;POP THE TTY	
	JSR PC,GIVPSW	;GIVE THE CHAR TO THE USERR
ERETSC:	MOV ITM0A,A	;GET THE PROCESS ADDRESS
	CLR PUPDLO(A)	;NOTHING GETS POPPED
	SEZ!SEC
	JMP EMTRET
TTWDI2:	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	MOV 2(D),A	;THE TTY ITEM NO.
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,CHARCK	;ENOUGH CHAR. YET
	BLT TTWDI2	;NOPE
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,RUNME	;I THINK I HAVE GOT THEM
	BR TTWDI4
;THIS ROUTINE TAKES A BLOCK OF CHARACTER FROM THE TTY, THE FIRST THING ON
;THE STACK IS THE NEGATIVE OF THE BYTE COUNT, THE SECOND IS A POINTER TO WHERE THE DATA
;GOES IN THE USERS D-SPACE
TTBKI:	BIT #.TTYI,B	;DOES HE HAVE INPUT ACCESS
	BEQ TBKISZ	;NO
	JSR PC,RETNSW	;GET THE COUNT
	MOV A,C		;SAVE IT
	BEQ TBKICZ	;ITS 0, WE WIN
	BPL TBKISZ	;ITS POSITIVE, WE WANT A NEGATIVE COUNT
	JSR PC,RETNSW	;GET THE POINTER
	MOV A,F		;SAVE IT
	ASR A		;SEE IF IT IS AT AN ODD ADRESS
	BCC TBKI1	;IT IS OK
TBKI6:	DEC F		;MAKE B POINT TO THE PREVIOUS WORD
	MFPD (F)	;GET THE PREVIOUS WORD
	JSR PC,ITM2PL	;LOAD THE TTY ITEM
	BR TBKI5
TBKI1:	MOV 2(D),A	;THE TTY ITEM NO.
TBKI2:	MFPD (F)	;MAKE SURE WE CAN WRITE THIS WORD
	MOV (P),B	;IN CASE THIS IS THE LAST TIME
	JSR PC,ITM2PL	;LOAD THE TTY
	JSR PC,TIOQ	;GET A CHAR
	BEQ TBKI3	;FAILED
	MOV D,(P)	;SAVE THE FIRST CHAR
	INC C		;INCREMENT THE COUNT
	BEQ TBKIRT	;DONE IF ZERO
TBKI5:	JSR PC,TIOQ	;GET ANOTHER CHAR
	BEQ TBKI4	;FAILED
	MOVB D,1(P)	;PUT IT IN THE TOP BYTE
	MOV ITEM2,A	;SAVE IT FOR NEXT TIME
	JSR PC,ITM2PO	;POP THE TTY ITEM
	MTPD (F)+	;RETURN THE CHARACTERS
	INC C		;INC THE COUNT
	BEQ TBKICZ	;IF ZERO WE ARE DONE
	SAVE <A,B,C,F>
	MOV ITM0A,A	;GET THE ADDRESS OF ITEM
	MOV PUP(A),B	;THE PDL POINTER
	ADD PUPDLO(A),B	;CORRECT IT
	MTPD -(B)	;PUT BACK THE POINTER
	MTPD -(B)	;PUT BACK THE COUNT
	REST <B,A>
	BR TBKI2	;GO BACK FOR MORE
	;BRANCHES INTO NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
TBKI3:	MOV ITEM2,A	;SAVE IT FOR LATER
	JSR PC,ITM2PO	;POP THE TTTY
	TST E		;SHOULD WE WAIT
	BMI .+6		;YES
	JMP ERETSC	;SET THE CARRY AND RETURN
	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD THE TTY
	MOV #1,B	;THE NUMBER OF CHARACTER TO WAIT FOR
	JSR PC,CHARCK	;IS THERE A CHAR
	BLT TBKI3	;NOPE
	MOV ITEM2,A	;SAVE IT FOR LATER
	JSR PC,ITM2PO	;POP THTE TTY
	JSR PC,RUNME	;I THINK I HAVE GOT IT
	BR TBKI2	;GO GET THE CHAR
TBKIRT:	JSR PC,ITM2PO	;POP THE TTY
	CLRB B		;CLEAR THE BOTTOM BYTE OF THE THE CURRENT WORD
	BISB B,(P)	;GET THE RECIEVED CHAR
	MTPD (F)	;GIVE IT BACK, WITH ONE BYTE CHANGED
TBKICZ:	JMP ERETCZ	;RETURN SUCCESSFUL
TBKISZ:	JMP ERETSZ
TBKI4:	MOV ITEM2,A	;SAVE IT
	JSR PC,ITM2PO	;POP THE TTY
	CLRB B		;CLEAR THE BOTTOM BYTE OF THE CURRENT WORD
	BISB B,(P)	;SET IN THE ONE CHAR. RECIEVED
	MTPD (F)	;GIV IT BACK WITH BYTE MODIFIED
	INC F		;CORRECT BYTE POINTER
	MOV F,B		;GIVE HIM THE POINTER
	JSR PC,GIVPSW
	MOV C,B		;THE COUNT
	JSR PC,GIVPSW	;GIVE IT TO HIM
	TST E		;SHOULD WE WAIT
	BMI TBKI8		;YES
	JMP ERETSC	;TELL HIM WE WON PARTIALLY
TBKI7:	MOV ITEM2,A
	JSR PC,ITM2PO
TBKI8:	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD THE TTYY
	MOV #1,B	;WE WANT ONE CHAR (AT LEAST)
	JSR PC,CHARCK	;IS IT THERE
	BLT TBKI7	;NOPE
	MOV ITEM2,A	;SAVE FOR LATER
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,RUNME	;RUN ME, RUN ME
	BR TBKI6	;FIX THE POINTER AND GET THE CHAR
;THIS ROUTINE TAKES A BYTE OFF THE TOP OF THE USERS STACK AND OUTPUTS IT TO THE TTY
TTBTO:	BIT #.TTYO,B	;DOES HE HAVE OUTPUT ACCESS
	BNE .+6		;YES
	JMP ERETSZ
	JSR PC,RETNSW	;GET THE CHARACTER TO TRANSMIT
	MOV A,F		;SAVE IT
	MOV 2(D),A	;THE TTY ITEM NO
	JSR PC,ITM2PL	;LOAD IT UP
	MOV F,D		;THE CHAR
	JSR PC,TYO	;OUTPUT IT
	TST E		;SHOULD WE WAIT
	BMI TTBTO1	;YES
	JSR PC,ITM2PO
	JMP ERETCZ	;SUCESS
TTBTO1:	TST TOQN(A)	;ALL THE CHARACTERS GONE
	BEQ TTBTO2
TTBTO3:	MOV ITEM2,A
	JSR PC,ITM2PO	;POP THE TTY ITEM
	JSR PC,LFLUSH	;GET RID OF YOURSELF
	JSR PC,ITM2PL	;LOAD THE TTY ITEM
	BR TTBTO1	;GO BACK AND CHECK
TTBTO2:	TST TOPC(A)	;ANY MORE CHARACTERS TO BE PUT IN
	BNE TTBTO3	;YES
	JSR PC,ITM2PO	;POP THE TTY ITEM
	JSR PC,RUNME	;ITS OKAY TO RETURN TO THE USER NOW
	JMP ERETCZ	;TELL HIM HE WINS
;THIS ROUTINE TAKES A WORD OFF THE USERS STACK AND OUTPUTS IT TO THE TTY
TTWDO:	BIT #.TTYO,B	;DOES HE HAVE OUTPUT ACCESS
	BNE .+6		;NOPE
	JMP ERETSZ
	JSR PC,RETNSW	;GET THE CHARACTERS TO OUTPUT
	MOV A,F		;SAVE THEM
TWDO1:	MOV 2(D),A	;THE TTY ITEM NO
	JSR PC,ITM2PL	;LOAD IT
	CMP #TOQSZ-1,TOQN(A)	;IS THERE AT LEAST ROOM FOR ONE CHARACTER
	BLO TWDO2	;NOPE
	MOV F,D		;THE CHARACTERS TO TRANSMIT
	JSR PC,TYO	;TRANSMIT THE FIRST ONE
	SWAB F		;GET THE NEXT CHAR
	MOV F,D		;THE OTHER CHAR
	JSR PC,TYO	;SEND IT
	JSR PC,ITM2PO
	JMP ERETCZ	;SUCCESS
TWDO2:	MOV ITEM2,A	;SAVE THIS FOR LATER
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,LFLUSH	;FLUSH YOURSELF FOR A WHILE
	JSR PC,ITM2PL	;LOAD THE TTY
	CMP #TOQSZ-1,TOQN(A)	;IS THERE ROOM
	BLO TWDO2	;NOPE
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,RUNME	;I'VE GOT IT
	BR TWDO1	;BUT MAKE SURE

TTBKO:	BIT #.TTYO,B	;DOES HE HAVE OUTPUT ACCESS
	BNE .+6		;YES
TBKOSZ:	JMP ERETSZ
	JSR PC,RETNSW	;GET THE COUNT
	MOV A,C		;SAVE IT
	BEQ TBKOCZ	;NONE TO TRANSFER
	BPL TBKOSZ		;POSITIVE COUNT?
	JSR PC,RETNSW	;GET THE POINTER
	MOV A,F		;SAVE IT
	ASR A		;DOES IT POINT AT A BYTE
	BCC TBKO1	;NO
	MOV 2(D),A	;THE TTY ITEM NO
	DEC F		;MAKE IT POINT TO THE PREVIOUS WORD
	MFPD (F)	;GET THE WORD
	BR TBKO5	;PRETEND YOU HAVE GOTTEN A CHAR
TBKO1:	MOV 2(D),A	;THE TTY ITEM NO
TBKO2:	MFPD (F)	;GET THE TWO CHARACTERS
	JSR PC,ITM2PL	;LOAD THE TTY
	TST TOPC(A)	;IS THE QUE FULL
	BEQ .+6		;NO
	JSR PC,TBKO3	;COME BACK WHEN THERE IS ROOM
	MOVB (P),D	;THE FIRST CHARACTER
	JSR PC,TYO	;SEND IT
	INC F
	INC C		;INCREMENT THE COUNT
	BEQ TBKORT	;DONE
TBKO5:	TST TOPC(A)	;IS THE QUE FULL
	BEQ .+6		;YES
	JSR PC,TBKO3	;RETURN WHEN THERE IS ROOM
	MOVB 1(P),D	;THE SECOND CHAR
	JSR PC,TYO	;SEND THE CHAR
	TST (P)+	;POP OFF THE CHARACTERS
	INC F
	INC C		;INC THE COUNT
	BEQ TBKORT	;DONE
	MOV ITEM2,A	;SAVE IT FOR NEXT TIME
	JSR PC,ITM2PO	;POP THE TTY
	SAVE <A,B,C,F>
	MOV ITM0A,A	;GET THE ADDRESS OF ITEM
	MOV PUP(A),B	;THE PDL POINTER
	ADD PUPDLO(A),B	;CORRECT IT
	MTPD -(B)	;PUT BACK THE POINTER
	MTPD -(B)	;PUT BACK THE COUNT
	REST <B,A>
	BR TBKO2	;DO IT AGAIN
	;BRANCHES INTO NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
TBKORT:	JSR PC,ITM2PO	;POP THE TTY ITEM
TBKOCZ:	JMP ERETCZ
TBKO3:	BIT #1,F	;HAVE WE RESTORED THE POINTER YET
	BEQ TBKO4
	MOV ITEM2,A
	JSR PC,ITM2PO	;POP THE TTY
	MOV F,B		;THE POINTER
	JSR PC,GIVPSW	;GIVE THE POINTER BACK
	MOV C,B		;THE COUNT
	JSR PC,GIVPSW	;GIV IT BACK
	BR TBKO6
TBKO4:	MOV ITEM2,A	;SAVE IT FOR LATER
	JSR PC,ITM2PO	;POP THE TTY ITEM
TBKO6:	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD UP THE TTY ITEM
	TST TOPC(A)	;IS IT STILL FULL
	BNE TBKO4	;YES
	MOV ITEM2,A	;SAVE IT AGAIN
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,RUNME	;LET ME RUN
	JSR PC,ITM2PL	;LOAD THE TTY AGAIN
	RTS PC		;GO BACK TO CORRECT PLACE


;DSK INPUT ROUTINES (DON'T SEPERATE)
;(D)= PTR TO CAPIBILITY

DKWDI:	JSR PC,DKISET		;SET UP CORE AND POINTERS
				;(C)=NEG. BYTES AVAIL ON PAGE
				;(E)=CORE ADDRESS (F)=FA PTR
	BEQ DKBT.1		;EOF
	INC C
	BEQ DKWD.1		;WORD HANGS OVER PAGE BOUNDARY
	INC F			;UPDATE FA PTR
	MOVB 1(E),B
	SWAB B
	BR DKBT.3		;GET OTHER BYTE AND RETURN
DKWD.1:	MOVB (E),-(P)		;SAVE 1ST BYTE
	MOV #LCKRTN,A		;LOCK A SWITCH TO DEC PTR
	MOV ITEM1,B		;THE SPHERE
	JSR PC,LOCKSW
	MOV #MFPCL2,LCKWD1(A)
	MOV D,LCKWD2(A)
	SUB ITM2A,LCKWD2(A)	;OFFSET TO FA CAP
	JSR PC,DKPINC		;INCREMENT PTR
	JSR PC,DKISET		;NEW PAGE SO SET UP AGAIN
	BEQ DKBT.1		;EOF
	MOVB (E),B
	SWAB B
	BISB (P)+,B
	JSR PC,DKPINC		;THIS AND LOCKED SWITCH CANCEL
	BR DKBT.4		;RETURN WORD TO USER

DKBTI:	JSR PC,DKISET		;SET THINGS UP
	BNE DKBT.3		;EOF
DKBT.1:		;TEST FA FLAG WORD TO DETERMINE REASON FOR FAILURE
DKBT.2:	JMP ERETSZ
DKBT.3:	BISB (E),B
DKBT.4:	JSR PC,GIVPSW		;RETURN DATA
	JSR PC,DKPINC		;UPDATE FA PTR
	JMP ERETCZ		;RETURN TO SUCESS
;BLOCK INPUT ROUTINE
;(A)= WHERE TO PUT BYTES (USERS CORE)
;(B)= NEG. # BYTES TO TRANSFER
;(C)= NEG. # BYTES AVAILABLE ON PAGE
;(D)= CAP. PTR
;(E)= CORE ADDRESS OF DATA
;(F)= FA PTR

DKBKI:	JSR PC,RETNSW		;BYTE COUNT
	MOV A,B
	JSR PC,RETNSW		;USERS PTR
	MOV A,E			;CHECK WORD BOUNDARIES
	BIS FAFBP(D),E
	ASR E
	BCS DKBT.2		;ODD ADDRESS
DKBI.1:	JSR PC,DKISET		;SET UP PAGE
	BEQ DKBT.1		;EOF
	CMP C,B
	BLE DKBI.3		;BRANCH IF ENOUGH ON THIS PAGE
	NEG C
	ADD C,F
	ADD C,B
	ASR C			;WORD COUNT NOW
DKBI.2:	SAVE <(E)+>		;TRANSFER A CHUNK
	MTPD (A)+		;THIS SUCKS BUT I CAN'T CLOBBER P
	SOB C,DKBI.2
	JSR PC,DKUPDT		;UPDATE CALL AND FA PTR
	BR DKBI.1
DKBI.3:	NEG B			;LAST HUNK TO GRAB
	ADD B,F
	ASR B			;WORD COUNT NOW
DKBI.4:	SAVE <(E)+>
	MTPD (A)+
	SOB B,DKBI.4
	JSR PC,DKPI.1		;UPDATE FA PTR
	JMP ERETCZ		;DONE AT LAST
DKWDO:
DKBTO:
DKBKO:	HALT
;UPDATE THE USER'S CALL AND FA PTR FOR BLOCK TRANSFERS
;(A)= USER'S CORE PTR AND (B)= NEG. BYTE COUNT
;UPDATE FA COUNTER IN F

DKUPDT:	SAVE <B>
	MOV A,B
	JSR PC,GIVPSW		;PUT THEM BACK
	REST <B>
	JSR PC,GIVPSW
	JSR PC,RETNSW		;NOW POP THEM
	JSR PC,RETNSW		
	BR DKPI.1		;UPDATE FA PTR


;INCREMENTS FA PTR IN F 
;IF PAGE COUNT OVERFLOWS IT WRAPS AROUND

DKPINC:	INC F
DKPI.1:	BIT #20000,F
	BEQ DKPI.2
	CLR F			;NEW PAGE NOW
	INC FAFPN(D)		;INC PAGE #
DKPI.2:	MOV F,FAFBP(D)
	JMP LSWPOP	;DKISET SWITCH TO CLEAR UPTPRP

;PC LOSER ROUTINE TO CLEAR FUPT PROCESS POINTER

MFPCL1:	MOV LCKWD2(B),B
	JSR PC,UPTPLD		;LOAD THE FUPT
	CLR UPTPRP(B)
	JMP ITM2PO		;DOES RTS PC FOR US

;PC LOSER RROUTINE TO DECREMENT POINTER IN FA CAP

MFPCL2:	MOV LCKWD2(B),B
	ADD A,B			;NOW POINTS TO FA CAP
	DEC FAFBP(B)
	BGE MFPCL3
	MOV #17777,FAFBP(B)
	DEC FAFPN(B)
MFPCL3:	RTS PC

;PCL ROUTINE TO FREE SWAP SPACE
MFPCL4:	MOV LCKWD2(B),B
	JMP DSWPAL
;SET UP PAGE FOR DISK I/O
;(D)= CAPABILITY PTR
;RETURNS IN C NEG. BYTES AVAILABLE ON PAGE
;IN E CORE ADDRESS FA POINTS AT
;IN F FA PTR
;ALSO SETS UP FPT AND UPT IF NEEDED

DKISET:	CLR #<.FAHIF!.FAEOF>,(D)	;CLEAR EOF AND HIF FLAGS
	BIT #.FARD,(D)		;DOES HE HAVE ACESS?
	BEQ DKIS.1
	JSR PC,DKMUPT		;CHECK ACCESS CODES AND SET UP UPT
	BEQ DKIS.1
	TST C
	BLT DKIS.1		;NOTHING THERE?
	BIS #.FAEOF,(D)
	JSR PC,LSWPOP		;CLEAR FUPT PROCESS PTR
	SEZ			;THAT'S ALL FOLKS
DKIS.1:	RTS PC

;SET UP UPT FOR FA CAP POINTED TO BY D

DIRUPT:	SAVE <A,B>
	MOV FAMFI(D),A
	JSR PC,ITM2LD		;LOAD MFI
	BR DIRU.1
DKMUPT:	SAVE <A,B>
	MOV FAMFI(D),A
	JSR PC,ITM2LD		;LOAD MFI
	BIT #MFLOKB,MFLAGW(A)	;IS THE FILE LOCKED
	BEQ DIRU.1
	BIT #.FAMFL,(D)		;DID HE LOCK IT
	BEQ DIRU.3
DIRU.1:	MOV FAFBP(D),F		;GET BYTE OFFSET
	MOV FAFPN(D),C		;GET PAGE #
	MOV C,B
	SAVE <D>
	MOV F,D
	ASH #3,D
	ASHC #3,C		;MAKE IT A BLOCK NUMBER
	REST <D>		;FA POINTER
	JSR PC,MFMFPT		;SET UP FPT IF NECESSARY
	BEQ DIRU.3
	JSR PC,MFMUPT		;SWAP IT INTO ITEM2
	BEQ DIRU.2
	REST <B,A>
	CLZ
	RTS PC
DIRU.2:	JSR PC,FPTDEL
DIRU.3:	REST <B,A>
	SEZ
	RTS PC
;SET UP FLOATING UPT FOR FPT (ADDRESS IN A)
;USE (C) (SET UP BY  MFMFPT) TO COMPUTE BYTES ON PAGE
;(D) POINTS TO PLACE TO STORE UPT GIP
;IF (D)<>0 THEN DELETE FUPT IT POINTS AT
;SWAP IT IN AND PUT CORE ADDRESS IN E

MFMUPT:	ADD #FAUPT,D
	SAVE <F,C,D>		;ENTERS HERE
	ASH #-12,F		;BLOCK # WE WANT
	MOV @D,B		;GIP TO OLD UPT
	BEQ MFMU.5		;NO OLD THING TO CLEAN UP
	ADD #<100000+FUPTTB>,B	;COMPUTE FUPT ADDRESS
	MOVB UPTSRT(B),C	;COMPUTE START OF REFERENCED ENTRY
	BIC #177770,C
	CMP C,F
	BNE MFMU.4		;THIS FUPT IS NO GOOD
MFMU.1:	REST <D,C,F>		;SWAP IT IN NOW
	MOV #LCKRTN,A		;RUN ROUTINE WHEN UNLOCKED
	CLR B			;NO ITEM NUMBER
	JSR PC,LOCKSW
	MOV #MFPCL1,LCKWD1(A)	;THIS WILL CLEAR THE FUPT PROCESS PTR
	MOV (D),B
	MOV B,LCKWD2(A)		;ADDRESS OF FUPT
	JSR PC,UPTLD
	MOV ITEM0,UPTPRP(B)	;SET THIS FUPT'S PROCESS POINTER
	MOV (D),B
	JSR PC,SWPIN
	JSR PC,GIP2LD		;LOAD IT INTO ITEM2
	SUB #FAUPT,D
	TST C
	BLT MFMU.2		;DONE AT LAST
	ADD 1776(E),C
	SUB #2000,C
	CLZ
MFMU.2:	RTS PC
MFMU.3:	BIT #FPTWSB,FPTFLG(A)	;IS IT A WRITE TO SOURCE FPT
	BNE MFMU3A
	CLR B
	JSR PC,SWPAL		;ALLOCATE A SMALL SWAP SPACE
	BEQ MFMU3B
	MOV B,FPTSWA(A)
MFMU3A:	SAVE <F>
	BIS #10000,(P)		;LEGNTH FIELD
	JSR PC,MFUPAL		;START TO MAKE A FUPT
	MOV (P)+,UPTAR(C)
	MOV C,B
	ADD #<100000-FUPTTB>,B
	JSR PC,UPTLD		;LOAD UP A UPT
	BR MFMU12		;FINISH HACKING GIP
MFMU3B:	REST <D,C,F>
	SUB #FAUPT,D
	SEZ
	RTS PC
	;BRANCHES INTO NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
MFMU.4:	SAVE <A,F>		;KILL OLD FUPT
	MOV @D,B
	JSR PC,UPTDEL		;DELTE FUPT
	REST <F,A>
	CLR @(P)		;ITS ALL GONE NOW
MFMU.5:	CLR C			;LOCK THE FPT
	MOV #FPTLKB,B
	ADD #FPTFLG,A
	JSR PC,LCKASW		;LOOK AT THINGS AND MAKE A NEW FUPT
	MOV FPTUPT(A),B		;POINTS TO CIRCULAR LIST
	BEQ MFMU.3		;NO UPT'S
	JSR PC,UPTLD		;LOAD UPT INTO ITEM2
	MOV UPTAR(B),E
	MOV E,D
	BIC #UPMSSW,D		;START OF COMMON ENTRY
	BIC #UPMLSW,E
	ASH #-14,E		;LEGNTH OF ENTRY
	MOV D,C
	SUB F,C
	BLE MFMU.6		;IT MIGHT FIT
	ADD E,C			;HAVE TO CHANGE SIZE OF UPT
	MOV F,D			;NEW START OF UPT IN D
	BR MFMU.7
MFMU.6:	ADD E,C			;IT STILL MIGHT FIT
	BGE MFMU11		;IT FITS GO MAKE IT
	MOV F,C
	SUB D,C			;NEW SIZE OF UPT IN C
MFMU.7:	BIT #1,FPTSWA(A)	;IS IT ALREADY A LARGE SWAP AREA
	BNE MFMU.8
	BIT #FPTWSB,FPTFLG(A)	;IS IT WRITE TO SOURCE
	BNE MFMU.8
	MOV #1,B		; ALLOCATE BIG AREA
	JSR PC,SWPAL
	BNE MFMU3B
	SAVE <B,A>		;SAVE SWAP ADDRESS
	MOV #LPCLRT,A
	CLR B
	JSR PC,LOCKSW
	MOV #MFPCL4,LCKWD1(A)
	MOV 2(P),LCKWD2(A)
	REST A
	MOV FPTUPT(A),B
;STOP DISKS
	JSR PC,SWPINS		;SWAP IT IN AND STOP THE DISKS
	MOV FPTSWA(A),B
	MOV (P)+,FPTSWA(A)
	MOV F,PS		;START UP DISK INTERUPTS
;START DISKS
	JSR PC,LSWPOP
	JSR PC,DSWPAL		;RELEASE SMALL BLOCK

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

;STOP DISKS

MFMU.8:	MOV FPTUPT(A),B
	JSR PC,SWPOTS		;SWAP IT OUT IF IN CORE
MFMU.9:	TST FUPTFR
	BEQ MFMU13		;FLUSH UNTIL THERE IS A FUPT AVAILABLE
	ASH #14,C		;NOW CHANGE SIZE OF UPTS
	ADD D,C			;THE NEW UPTAR
	MOV FPTUPT(A),B
	JSR PC,UPTLD		;GET THE CIRCLE GOING
	MOV B,D			;SAVE BEGINNING OF CIRCULAR LIST
MFMU10:	MOV C,UPTAR(B)
	MOV UPTCLP(B),B
	JSR PC,UPTLD		;LOAD THE UPT
	CMP B,D
	BNE MFMU10		;NOT FULL CIRCLE YET
	MOV F,PS		;RESTART DISK INTERUPTS
;START DISKS

MFMU11:	JSR PC,MFUPAL		;START TO MAKE A FUPT
	MOV UPTAR(B),UPTAR(C)	;THESE ARE SHARED
	MOV UPTCLP(B),UPTCLP(C)	;LINK IT INTO LIST
MFMU12:	ADD #<100000-FUPTTB>,C	;MAKE A GIP
	MOV C,FPTUPT(A)
	MOV C,UPTCLP(B)		;FINISH LINKING IT IN
	MOV C,@0(P)		;NOW EVERYONE KNOWS ABOUT THE NEW FUPT
	JSR PC,LSWPOP		;UNLOCK THE FPT
	JMP MFMU.1		;SWAP IT IN NOW
MFMU13:	MOV F,PS		;RESTART DISK INTERUPTS
	MOV #FUPTFR,E
	JSR PC,MFLUSH		;FLUSH UNTIL A FUPT IS AVAILABLE
	BR MFMU.8
;ALLOCATE A FUPT
;(A)= ADDRESS OF FPT
;(F)= WHICH BLOCK WE WANT THE FUPT FOR
;PUT ITS ADDRESS IN C
;FILL IN UPTFPT, AND UPTDR


MFUPAL:	MOV FUPTFR,C
	BEQ MFAL.1		;FLUSH YOURSELF
	MOV (C),FUPTFR		;LINK IT OUT OF FREE LIST
	MOV A,D
	SEC			;COMPUTE FPT POINTER
	ROR D
	MOV D,UPTFPT(C)
	BIS #7100,F
	SWAB F			;ITS NOW A DR (I HOPE)
	MOV F,UPTDR(C)
	RTS PC
MFAL.1:	MOV #FUPTFR,E
	JSR PC,MFLUSH
	BR MFUPAL


MFLUSH:	JSR PC,LFLUSH		;FLUSH UNTIL @(E) IN NON ZERO
	TST (E)
	BEQ MFLUSH
	JSR PC,RUNME
	RTS PC
;SET UP FPT (IT MAY ALREADY EXIST) FOR BLOCK (OF FILE) IN C 
;(A)= ADDRESS OF MFI (IN ITEM2)
;(B)= FILE PAGE NUMBER
;(C)= BLOCK # TO SET UP UPT FOR
;(D)= FA CAP POINTER (SETS BITS @D ON EOF/HIF)
;RETURN ADDRESS OF FPT IN (A) AND SET UP (C) FOR MFMUPT

MFMFPT:	SAVE <D>		;IN CASE OF EOF OR HIF
	MOV MFIFPT(A),A		;LOOK DOWN LINKED LIST
	BEQ MFMF.2
MFMF.1:	CMP B,FPTPNO(A)		;IS THIS WHAT WE WANT
	BEQ MFMF.8		;GOT IT
	MOV FPTLNK(A),A
	BNE MFMF.1
MFMF.2:	MOV ITM2A,A
	MOV FPTFRE,MFIFPT(A)
	BEQ MFMF.Z		;NO FREE FPTS
	MOV FPTFRE,A		;FINISH LINKING IT IN AND OUT
	MOV FPTLNK(A),FPTFRE
	MOV #<FPTLEN/2>,D	;CLEAN IT OUT
	MOV A,E
MFMF.3:	CLR (E)+
	SOB D,MFMF.3		;IT EXISTS NOW
	MOV B,FPTPNO(A)
	MOV ITM2A,B
	MOV MFLAGW(B),FPTFLG(A)
	BIC #<177400-MFIWSB>,FPTFLG(A)
	SAVE <A,C>
	ADD #FPTSRC,A
	JSR PC,MFIRDS		;INIT MFRDIS
	BIC #7,C
	INC C
MFMF.4:	JSR PC,MFRDIS		;GET A BLOCK NUMBER
	BEQ MFEOF		;NONE LEFT
	SOB C,MFMF.4
	MOV #8,C
MFMF.5:	BIS #FPTBAS,D		;PUT BLOCK NUMBER INTO FPT
	MOV D,(A)+
	JSR PC,MFRDIS
	BEQ MFMF.9		;LAST BLOCK FOUND
	SOB C,MFMF.5
MFMF.6:	REST <C,A>		;HERE IF FPT CAN'T CONTAIN LAST BLOCK
	SAVE <A,C>
	BIC #177770,C
	ASL C
	ADD A,C			;GET BLOCK NUMBER
	CMP #-1,FPTSRC(C)
	BNE MFMF10		;NOT A HOLE
MFHIF:	BIS #.FAHIF,@4(P)	;SET BIT IN FA CAPABILITY

;BRANCHES INTO NEXT PAGE
;BRANCHES INTO PREVIOUS PAGE

MFEOF:	REST <C,A>
	BIS #.FAEOF,@(P)+	;EOF HANDLERR
	SEZ
	RTS PC
MFMF.Z:	REST <D>
	MOV #FPTFRE,E
	JSR PC,MFLUSH
	MOV ITM2A,A
	BR MFMFPT
MFMF.7:	REST <C,A>
MFMF.8:	SAVE <A,C>		;CHECK FOR READ FROM LAST FILE BLOCK
	BIC #177770,C
	ASL C
	ADD C,A
	CMP #-1,FPTSRC(A)
	BEQ MFHIF		;FELL INTO ANOTHER HOLE
	CMP #16,C		;BLOCK OFFSET FROM PAGE BEGIN
	BNE MFMF11		;SEE IF THERE IS ANOTHER BLOCK
	JSR PC,MFIRDS		;MFRDIS INITED HERE
	MOV (P),C		;BLOCK NUMBER
	INC C
	INC C
MFMF.9:	JSR PC,MFRDIS
	BEQ MFMF12		;IT IS THE LAST BLOCK
	SOB C,MFMF.9
MFMF10:	MOV F,C			;NOT THE LAST BLOCK OF FILE
	BIC #176000,C
	SUB #2000,C		;COMPUTE BYTES AVAILABLE ON BLOCK
	BR MFMF13
;IF C IS NOT 1 SOMETHING STRANGE HAPPENED TO THE DISCRIPTOR IN THE MFI
MFMF11:	MOV FPTSRC+2(A),C
	BIC #FPTBAS,C
	BNE MFMF10		;NOT LAST BLOCK OF FILE
MFMF12:	MOV ITM2A,B		;MUNG THROUGH MFI FOR MORE INFO
	BIT #MFWDLF,MFENHD(B)	;IS THERE A WORD LEFT
	BEQ MFMF14	
	MOV F,C
	BIC #176000,C		;(C)>0 MEANS MFMUPT COMPUTES BYTES AVAILABLE
MFMF13:	REST <D,D,D>		;PRESERVE STACK DICIPLINE
	CLZ			;DONE AT LAST
	RTS PC
MFMF14:	BIT #MFBTLF,MFENHD(B)	;IS THERE A BYTE LEFT
	BEQ MFMF10		;BLOCK IS FULL
	MOV F,C			;COMPUTE BYTES AVAILABLE
	BIC #176000,C
	SUB #1777,C
	BNE MFMF13		;DONE AT LAST
	BR MFEOF
;READS A DISCRIPTOR POINTED AT BY MFDPTR
;RETURNS A BLOCK NUMBER IN D 
;INITIALIZED BY MFIRDS

MFRDIS:	SAVE <B>
	TST MFDIST
	BNE MFGS.2		;ITS A HOLE
	INC MFBKNO
	DEC MFBKCT
	BLT MFRD.2		;YOU CAN'T HAVE THAT BLOCK
MFRD.1:	MOV MFBKNO,D
MFRD.0:	REST <B>
	CLZ
	RTS PC
MFRD.2:	CMP MFDPTR,MFEND	;NO BLOCKS LEFT TO COUNT
	BLO MFRD.4
MFRD.3:	REST <B>
	CLR MFBKCT
	RTS PC
MFRD.4:	MOVB @MFDPTR,D
	INC MFDPTR		;NEW POINTER
	MOV D,B
	BIC #177477,B		;WHAT KIND OF DISCRIPTOR
	BIC #177700,D		;WITH WHAT BLOCK COUNT
 	ASH #-5,B
	JMP @MFDTAB(B)		;ONE OF FOUR TYPES

MFG1SK:	TST D			;ZERO IS THE NULL DISC
 	BEQ MFRD.2		;READ ANOTHER
 	ADD D,MFBKNO		;SKIP AND GET
	CLR MFBKCT
	BR MFRD.1

MFSADD:	MOV MFDPTR,B
	ADD #2,B
	CMP B,MFEND
	BHIS MFRD.3		;NO DISCRIPTOR LEFT
	MOV B,MFDPTR
	MOVB -(B),MFBKNO+1	;SET ADDRESS AND GET SOME
	MOVB -(B),MFBKNO
	MOV D,MFBKCT
	BR MFRD.1

MFSKAG:	MOV D,B			;SKIP SOME AND GET SOME
	BIC #177770,B
	BIC #177707,D
	ASH #-3,D
	ADD D,MFBKNO
	MOV B,MFBKCT
	BR MFRD.1
	;BRANCHES INTO NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
MFGSOM:	MOV D,MFBKCT		;GET A BUNCH
	CMP #37,C
	BGE MFRD.1
	SUB #40,MFBKCT		;RON'S SKIP DISCRIPTOR
	MOV #1,MFDIST		;SET SWITCH
MFGS.1:	MOV #-1,D		;INDICATES HOLE IN FILE
	BR MFRD.0
MFGS.2:	DEC MFBKCT
	BGE MFGS.1
	CLR MFDIST		;CLEAR SWITCH
	BR MFRD.2		;GET ANOTHER DISCRIPTOR

;INITIALIZE MFRDIS
MFIRDS:	SAVE <A,B>
	CLR MFBKCT
	MOV #-1,MFBKNO
	CLR MFDIST
	MOV ITM2A,A		;MFI ADDRESS
	ADD #MFENHD,A		;FIND THE ENTRY
	MOV (A)+,B		;GET THE HEADER
	SAVE <A>
MFIR.1:	TSTB (A)+
	BGE MFIR.1		;SKIP OVER NAME
	MOV A,MFDPTR		;PTR INTO ENTRY
	MOV B,A
	BIC #177700,B		;GET LEGNTH IN WORDS
	BIC #177477,A		;GET TYPE
	CMP #MFFILB,A		;IS IT A FILE
	BNE MFIR.2
	SUB #2,B
MFIR.2:	ASL B
	ADD (P)+,B		;POINTS PAST END OF DISCRIPTOR
	MOV B,MFEND
	REST <B,A>
	RTS PC

;PUT A MFI INTO THE HASH TABLE
;(A) = ITM PTR (IN ITEM2)

MFHASH:	SAVE <D,E,F>
	MOV A,D
	ADD MFNAME,D
	CLR F
MFHS.1:	MOVB (D)+,E
	XOR E,F
	TST E
	BPL MFHS.1
	BIC #177741,F
	MOV MFHTAB(F),MFHLNK(A)	;LINK IT IN
	MOV ITEM2,MFHTAB(F)
	INC MFREF(A)
	REST <F,E,D>
	RTS PC
;DELETE A FPT (IF NO UPT'S ARE ATTACHED)
;ADDRESS IN A

FPTD.1:	MOV (A),A	;LOOK FURTHER DOWN LINKED LIST
	BNE .+4
	BPT
	ADD #FPTLNK,A
	BR FPTD.3

FPTDEL:	TST FPTUPT(A)
	BNE FPTD.4	;STOP UPTS HANG HERE
	BIT #FPTLKB,FPTFLG(A)
	BNE FPTD.4	;STOP SOMEONE IS ALREADY KILLING THIS
	BIS #FPTLKB,FPTFLG(A)	;LOCK IT UP
	MOV FPTSWA(A),B
	BEQ FPTD.2	;NO SWAP SPACE
	JSR PC,DSWPAL	;RELEASE THE SWAP BLOCK
FPTD.2:	MOV A,D
	MOV FPTMFI(A),A
	JSR PC,ITM2LD	;LOAD THE MFI
	ADD #MFIFPT,A
FPTD.3:	CMP (A),D	;DOES IT POINT TO ME
	BNE FPTD.1
	MOV FPTLNK(D),(A)	;LINK OUT FPT
	MOV FPTFRE,FPTLNK(D)	;LINK INTO FREE LIST
	MOV D,FPTFRE
FPTD.4:	RTS PC
;DELETE A MFI
;IF PC LOSERED ENTERS AT MFDELP
;ITEM NUMBER IS IN A (IF MFREF=0 IT'S NOT IN HASH TABLE)
;DECREMENT REFERENCE COUNT AND KILL IF ZERO

MFDELP:	MOV ITEM2,A	;SET UP FOR MFIDEL
	JSR PC,ITM2PO
	JSR PC,MFIDEL
	MOV #-1,A
	JMP ITM2PL	;DOES RTS PC FOR US

MFIDEL:	JSR PC,ITM2LD	;LOAD UP THE MFI
	TST MFREF(A)
	BNE MFID.2	;IT IS LINKED INTO THE HASH TABLE
MFID.1:	MOV ITEM2,A
	JMP DLITEM	;KILL IT (IT'S NOT IN HASH TABLE)
MFID.2:	DEC MFREF(A)
MFID.:	BNE MFID.	;IF NON ZERO DON'T DELETE IT
	HALT
;ADD A DISK BLOCK TO A FILE
;MFI IN ITM2 (PICK A DISK IF MFBFPT IS ZERO)
ADDBLK:	HALT
	.SBTTL START THE WORLD ROUTINE
GO:	RESET
	MOV #PDL,P	;SET UP THE PDL
	JSR PC,TYINIT	;INITIALIZE THE TTY'S
	JSR PC,MAPSET	;SET UP THE INTIAL MAP
	JSR PC,MEMTST	;SET UP MEMORY TABLES
	SAVE BEBRV	;FIND OUT WHICH CLOCK WE HAVE
	MOV #GOPC,BEBRV	;GO TO GOPC FOR PROGRAMMABLE CLOCK
	MOV #100,LCCS	;TRY TO START THE LINE CLOCK
	BR GOLC		;WON'T GET HERE IF UNSUCESSFUL
GOPC:	SPL 0		;IN CASE SET BY THE BREAK
	CMP (P)+,(P)+	;FLUSH SAVED THINGS
	CLR PCCB	;WE HAD BETTER HAVE A PROGRAMMABLE CLOCK!
	MOV #115,PCCS	;TRY LINE FEQUENCY, REPEAT INT, ETC.
GOLC:	REST BEBRV	;WE HAVE SET UP THE CLOCK
;INITIALIZE VARIOUS TABLES ON THE NEXT PAGE
	MOV #INITLS,A	;THINGS TO LINK INTO FREE LISTS
INTLST:	MOV (A)+,B	;GET THE TABLE ADDRESS
	BEQ INTLS1	;DONE WITH THESE THINGS
	MOV (A)+,C	;GET THE ADDRESS OF THE FREE POINTER
	MOV (A)+,D	;GET THE NUMBER OF THINGS
	MOV (A)+,E	;GET THE LENGTH OF THEM
	MOV B,(C)	;SET UP THE FREE POINTER
	MOV B,C		;COPY POINTER INTO TABLE
INTLS2:	ADD E,C		;POINTER TO NEXT ONE
	MOV C,(B)	;GET PUT INTO THIS ONE
	ADD E,B		;GO TO NEXT ONE
	SOB D,INTLS2	;HOWEVER MANY TIMES
	BR INTLST
INTLS1:	MOV #INITM1,A	;STUFF TO MAKE -1
INTM11:	MOV #-1,(A)+
	CMP #EINTM1,A
	BNE INTM11
	MOV #ITMBIT,A	;THE BIT TABLE POINTERS
	MOV #ITMBTP,B
	MOV #NITMBL,C
INTBT1:	MOV A,(B)+	;POINTER TO A BIT TABLE
	ADD #22,A	;FURTHER ON
	SOB C,INTBT1	;FOR SO MANY BIT TABLES
;FALL THROUGH TO NEXT PAGE TO START UP THE SYSTEM PROCESS, ETC.
;FALLS IN FROM PREVIOUS PAGE
;START UP THE SYSTEM PROCESS
	JSR PC,CRUSER	;CREATE A USER
	MOV B,CURUSR	;HE IS THE CURRENT USER
	MOV #2,PRTPRI(B)	;INCREASE HIS PRITORITY
	JSR PC,CRSPHR	;CREATE A SPHERE FOR HIM
	MOV A,SYSSPR	;THE SYSTEM SHPERE
	MOV A,C		;SAVE THE SPHERE ITEM#
	JSR PC,CRPROC	;CREATE A PROCESS
	MOV C,B		;PUT THE SPHERE ITEM IN THE RIGHT PLACE
	JSR PC,PUTPRS	;PUT THE PROCESS INTO THE SPHERE
	MOV A,D		;SAVE THE PROCESS ITEM
	JSR PC,ITM0LD	;MAKE PROCESS ITEM 0
	MOV A,C		;SAVE ADDRESS
	MOV B,A		;GET SPHERE ITEM #
	JSR PC,ITM1LD	;MAKE SPHERE ITEM1
	ADD #SUPTS,A	;GET A POINTER TO THE UPTS
	MOV #20,D	;THERE ARE 20 PAGES
	MOV #KERISD,E	;WE WILL COPY THE KERNEL MAP INTO THIS SPHERE
SYSJI1:	MOV (E)+,(A)+	;THE DR
	MOV KERISA-KERISD-2(E),(A)	;THE AR
	BIS #UPTABT,(A)	;AN ABSOLUTE PAGE
	ADD #UPTLEN-2,A
	SOB D,SYSJI1	;DO FOR 20 PAGES
	CLR B		;CAPABILITY ZERO
	JSR PC,AGCLAD	;GO GET THE ADDRESS
	MOV #.CCCAP,(A)	;A CREATE CAPABILITY CAPABILITY
	MOV #1,B	;CAPABILITY ONE
	JSR PC,AGCLAD	;GO GET THE ADDRESS
	MOV #.MSCAP,(A)	;MAKE IT A MASTER SPHERE CAPABILITY TO ITSELF (!!!!)
	BIS #MSPCBT!.SPFES,(A)+	;EVERYTHING AND NO ENTERS
	MOV SYSSPR,(A)	;THSI IS IT
	MOV #SYSJOB,PUPC(C)	;SET THE THINGS PROGRAM COUNTER
	MOV #SYSJPD,PUP(C)	;AND ITS PDL POINTER
	BIC #PSUPSB,PSTOP(C)	;CLEAR THE STOP BIT
	JSR PC,PSTPDC	;GO DECREMENT THE STOP COUNT AND PUT ON RUN Q
	CLR INITSW	;EXITING INIT CODE
	JMP SCHED	;GO GO GO!
	.SBTTL THE SYSTEM PROCESS(ES)
SYSJOB:	SAVE <#-1,#1,#.MSCAP*400>
	.INVOK
	BNE .+4
BADSPR:	BPT
	REST F
	SAVE <#-1,#3,#.PRCAP*400>
	.INVOK
	BNE .+4
BADPR:	BPT
	REST E
	SAVE <#-1,#-1,F>
	MOVB #201,1(P)
	.INVOK
	BNE .+4
BADCPY:	BPT
SYSGOO:	BPT
.BLKW 100

LSTILC=.	;PUT THIS AT THE LAST INSTRUCTION LOCATION
FSTFRB==<<<.!1777>+1>_-10.>&77	;FIRST FREE BLOCK
.MACRO PAD A,B
.PRINT /A B
/
.ENDM
.IF2
PAD ^/SYSTEM END =/,\.
PAD \<./4000>,^/K/
.ENDC
	.END GO
