.STITL TELETYPE MACROS

.MACR	ZEPT A,B
	Z==0
	.REPT	A
	B
	Z==Z+1
	.ENDR
.ENDM

.MACR	CONS	A,B,C
	A'B'C
.ENDM

	.STITL SYSTEM DISPATCH TABLE (BYTE ONE)

;FLAG DEFINITIONS
FSF==200	;SPECIAL INPUT
FOF==100	;SPECIAL OUTPUT
FQF==20		;QUOTING
SEPF==4		;SEPARATOR
WSF==2		;WORD SEPARATOR
NNUMF==40	;NOT A NUMBER
OPERF==10	;OPERATOR

DTBL:
.BYTE	NNUMF,FOF!NNUMF		;^@	;^A ECHOES AS CR
.BYTE	FSF!NNUMF,FSF!NNUMF	;^B IS CONVERTED TO %
				;^C COPYS NEXT CHARACTER
.BYTE	FSF!NNUMF,NNUMF		;^D DELETES NEXT CHARACTER	;^E
.BYTE	NNUMF,FSF!FOF!NNUMF	;^F	;^G BREAK
.BYTE	FOF!NNUMF,FOF!SEPF!WSF!NNUMF	;^H BACKSPACE	;^I TABULATE
.BYTE	FOF!SEPF!WSF!NNUMF,FOF!SEPF!WSF!NNUMF	;^J LINE FEED
				;^K TABULATE VERTICALLY
.BYTE	FOF!SEPF!WSF!NNUMF,FSF!FOF!SEPF!WSF!NNUMF	;^L FORM FEED
				;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	FSF!NNUMF,NNUMF		;^N GET NEXT WORD	;^O
.BYTE	NNUMF,FSF!NNUMF		;^P	;^Q SUPER-QUOTE
.BYTE	FSF!NNUMF,FSF!NNUMF	;^R COPY REST OF LINE
				;^S SKIP NEXT WORD
.BYTE	NNUMF,NNUMF		;^T	;^U
.BYTE	NNUMF,FSF!NNUMF		;^V	;^W ERASE LAST WORD
.BYTE	FSF!NNUMF,FSF!NNUMF	;^X CLARIFY INPUT
				;^Y EDIT PREVIOUS LINE
.BYTE	FSF!NNUMF,NNUMF		;^Z DESTROY INPUT BUFFER
				;^[ MAYBE ALTMODE
.BYTE	NNUMF,NNUMF		;^\	;^]
.BYTE	NNUMF,NNUMF		;^^	;^_ ANY BETTER IDEAS FOR THEM?
.BYTE	SEPF!WSF!NNUMF,NNUMF!SEPF!OPERF	;SP	;! COMMENT?
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;"	;# ACTION OF
.BYTE	NNUMF,NNUMF		;$	;%
.BYTE	NNUMF,NNUMF!OPERF	;&	;' (MAYBE LE)
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;( ARITHMETIC GROUPING
				;) DITTO
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;* MULTIPLY	;+ ADD
.BYTE	NNUMF,SEPF!NNUMF!OPERF	;,	;- SUBTRACT
 .BYTE	0,SEPF!NNUMF!OPERF
.BYTE	0,0	;0	;1
.BYTE	0,0	;2	;3
.BYTE	0,0	;4	;5
.BYTE	0,0	;6	;7
.BYTE	0,0	;8.	;9.
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF	;: THING OF	;; PROPERTY OF
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;<	;=
.BYTE	SEPF!NNUMF!OPERF,NNUMF	;>	;?
.BYTE	NNUMF,NNUMF		;@	;A
.BYTE	NNUMF,NNUMF		;B	;C
.BYTE	NNUMF,0
.BYTE	NNUMF,NNUMF		;F	;G
.BYTE	NNUMF,NNUMF		;H	;I
.BYTE	NNUMF,NNUMF		;J	;K
.BYTE	NNUMF,NNUMF		;L	;M
.BYTE	0,NNUMF
.BYTE	NNUMF,NNUMF		;P	;Q
.BYTE	NNUMF,NNUMF		;R	;S
.BYTE	NNUMF,NNUMF		;T	;U
.BYTE	NNUMF,NNUMF		;V	;W
.BYTE	NNUMF,NNUMF		;X	;Y
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF	;Z	;[
.BYTE	SEPF!NNUMF!OPERF,FSF!FQF!SEPF!WSF!NNUMF	;\ MODULO	;]
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;^	EXPONENTIATE, MAYBE
				;_ MAKE
.BYTE	NNUMF,NNUMF		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	NNUMF,NNUMF		;b LOWER CASE	;c LOWER CASE
.BYTE	NNUMF,NNUMF		;d LOWER CASE	;e LOWER CASE
.BYTE	NNUMF,NNUMF		;f LOWER CASE	;g LOWER CASE
.BYTE	NNUMF,NNUMF		;h LOWER CASE	;i LOWER CASE
.BYTE	NNUMF,NNUMF		;j LOWER CASE	;k LOWER CASE
.BYTE	NNUMF,NNUMF		;l LOWER CASE	;m LOWER CASE
.BYTE	NNUMF,NNUMF		;n LOWER CASE	;o LOWER CASE
.BYTE	NNUMF,NNUMF		;p LOWER CASE	;q LOWER CASE
.BYTE	NNUMF,NNUMF		;r LOWER CASE	;s LOWER CASE
.BYTE	NNUMF,NNUMF		;t LOWER CASE	;u LOWER CASE
.BYTE	NNUMF,NNUMF		;v LOWER CASE	;w LOWER CASE
.BYTE	NNUMF,NNUMF		;x LOWER CASE	;y LOWER CASE
.BYTE	NNUMF,NNUMF		;Z LOWER CASE	;LEFT BRACE
.BYTE	NNUMF,NNUMF		;VERTICAL BAR	;RIGHT BRACE
.BYTE	NNUMF,FSF!NNUMF		;TILDE	;RUBOUT

	.STITLE SYSTEM DISPATCH TABLE (BYTE TWO)
;NUMBERS POINT TO OTHER TABLES
;$ POINTS TO SYSTEM OBLIST

DTBL2:
.BYTE	0,0		;^@ 			;^A
.BYTE	36,0		;^B BECOMES %, PRINTS AS SPACE IN STRINGS
			;^C COPY NEXT CHARACTER
.BYTE 2,0		;^D DELETES NEXT CHAR	;^E
.BYTE	0,4		;^F 			;^G BREAK
.BYTE	2,10		;^H BACKSPACE		;^I TABULATE
.BYTE	12,14		;^J LINE FEED		;^K TABULATE VERTICALLY
.BYTE	16,6		;^L FORM FEED
			;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	10,0		;^N GET NEXT WORD		;^O
.BYTE	0,12		;^P 			;^Q SUPER-QUOTE
.BYTE	14,16		;^R 			;^S SKIP NEXT WORD
.BYTE	0,0		;^T	;^U
.BYTE	0,20		;^V	;^W ERASE LAST WORD
.BYTE	22,24		;^X CLARIFY INPUT	;^Y
.BYTE	26,0		;^Z DESTROY INPUT BUFFER
			;^[ MAYBE ALTMODE
.BYTE	0,0		;^\	;^]
.BYTE	0,0		;^^	;^_ WELL, ANY BETTER IDEAS FOR THEM?
.BYTE	0,0		;SP	;! COMMENT?
.BYTE	0,0		;"	;# ACTION OF
.BYTE	0,0		;$	;%
.BYTE	0,0		;&	;' (MAYBE LE)
.BYTE	0,0		;( ARITHMETIC GROUPING	;) DITTO
.BYTE	0,0	;* MULTIPLY	;+ ADD
.BYTE	0,0		;,	;- SUBTRACT
.BYTE	0,0		;.	;/ DIVIDE
.BYTE	0,0		;0	;1
.BYTE	0,0		;2	;3
.BYTE	0,0		;4	;5
.BYTE	0,0		;6	;7
.BYTE	0,0		;8.	;9.
.BYTE	0,0		;: THING OF	;; PROPERTY OF
.BYTE	0,0	;<	;=
.BYTE	0,0		;>	;?
.BYTE	0,0		;@	;A
.BYTE	0,0		;B	;C
.BYTE	0,0		;D	;E
.BYTE	0,0		;F	;G
.BYTE	0,0		;H	;I
.BYTE	0,0		;J	;K
.BYTE	0,0		;L	;M
.BYTE	0,0		;N	;O
.BYTE	0,0		;P	;Q
.BYTE	0,0		;R	;S
.BYTE	0,0		;T	;U
.BYTE	0,0		;V	;W
.BYTE	0,0		;X	;Y
.BYTE	0,32		;Z	;[
.BYTE	0,34	;\ MODULO	;]
.BYTE	0,0		;^ (MAYBE EXPONENTIATE)		;_ MAKE
.BYTE	0,0		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	0,0		;b LOWER CASE	;c LOWER CASE
.BYTE	0,0		;d LOWER CASE	;e LOWER CASE
.BYTE	0,0		;f LOWER CASE	;g LOWER CASE
.BYTE	0,0		;h LOWER CASE	;i LOWER CASE
.BYTE	0,0		;j LOWER CASE	;k LOWER CASE
.BYTE	0,0		;l LOWER CASE	;m LOWER CASE
.BYTE	0,0		;n LOWER CASE	;o LOWER CASE
.BYTE	0,0		;p LOWER CASE	;q LOWER CASE
.BYTE	0,0		;r LOWER CASE	;s LOWER CASE
.BYTE	0,0		;t LOWER CASE	;u LOWER CASE
.BYTE	0,0		;v LOWER CASE	;w LOWER CASE
.BYTE	0,0		;x LOWER CASE	;y LOWER CASE
.BYTE	0,0		;z LOWER CASE	;{ OPEN BRACE
.BYTE	0,0		;| VERTICAL BAR, MAYBE OR, MAYBE XOR
			;} CLOSE BRACE
.BYTE	0,30		;~ TILDE, LOGICAL NOT	;RBO	RUBOUT

.STITL TELETYPE PARAMATERS
DC0TBN==34
NDH==1		;NUMBER OF DH11'S
NDC==2		;NUMBER OF DC11'S
NKL==0		;NUMBER OF KL11'S
NKLTY==NKL	;NUMBER OF KL11 TTYS (1 TTY/KL11)
NDHTY==NDH*20	;NUMBER OF DH11 TTYS (16 TTYS/DH11)
NDCTY==NDC	;NUMBER OF DC11 TTYS (1 TTY/DC11)
NMODEM==1	;NUMBER OF MODEMS
NTBOX==1	;NUMBER OF THORTON BOXES
NTUR==2		;NUMBER OF TURTLES
NPLOT==1	;NUMBER OF PLOTTERS
NMBX==1		;NUMBER OF MUSIC BOXES
NTY==1		;THE SYSTEM CONSOLE
NTTYS==NDHTY+NDCTY+NKLTY+<4*NTBOX>+NTY	;TOTAL NUMBER OF TELETYPES


.STITL TELETYPE DISPATCH TABLES--DATA SPACE

;ALL FOLLOWING CODE CAN BE IN DATA SPACE ONLY!!!!!!!!!!


;DISPATCH TABLE FOR SPECIAL INPUT CHARS WITH EFFECT ON TYPEOUT LEVEL
TIICTB:	TOICC	;^C COPY NXT CHAR FROM EDIT TO TYI BUFFER
	TOICD	;^D DELETE NEXT CHAR FROM EDIT BUFFER
	RTSPC	;^G ADDRESS OF AN RTS PC
	TOICM	;^M POSSIBLE END OF LINE
	TOICN	;^N COPY NEXT WD FROM EDIT TO TYI BUFFER
	TOICQ	;^Q JUST ECHO
	TOICR	;^R COPY REST OF EDIT BUFFER TO TYI BUF
	TOICS	;^S SKIP NXT WD IN ED. BUF.
	TOICW	;^W RUB OUT UP TO PREVIOUS WD SEPERATOR
	TOICX	;^X CLARIFY INPUT
	TOICY	;^Y RECOVER PREVIOUS LINE
	RTSPC	;^Z ADDRESS OF AN RTS PC
	TOIRB	;RUBOUT
	TOIOB	;[ INCREMENT LIST COUNT
	TOICB	;] DECREMENT LIST COUNT
	TICB


;DISPATCH TABLE FOR CHARS SPECIAL ON OUTPUT
;(HAVE FOF ON IN DTBL(CHARACTER)
TOOCTB:	TOOCA	;^A PRINTS AS C.R.
	TOOCH	;^H BACKSPACE, DECREMENTS CHARNO
	TOTYOC	;^G PRINTS AS SELF
	TOOCM	;^M PRINTS AS CR, LF
	TOOCI	;^I (TAB) SPACES TO NEXT TAB STOP
	TOTYOC	;^J (LINEFEED) PRINTS AS SELF
	TOTYOC	;^K (VERTICAL TAB) PRINTS AS SELF
	TOTYOC	;^L (FORMFEED) PRINTS AS SELF


.STITL TELETYPE VARIABLES

	NFTY==0			;TTY NO. OF FIRST CONSOLE TTY
	NFDCTY==2*NTY		;TTY NO. OF FIRST DC11 TTY
	NFKLTY==2*<NTY+NDCTY>	;TTY NO. OF FIRST KL11 TTY
	NFDHTY==2*<NTY+NKLTY+NDCTY>	;TTY NO. OF FIRST DH11 TTY
	NTTY==NTY+NKLTY+NDCTY+NDHTY	;NO. OF TELETYPE PORTS
	NFLTTY==2*NTTY		;TTY NO. OF FIRST PSEUDO TTY

	.STITL	FLOATING TRAP VECTORS & DEVICE INFO

	FOO==.
	.=300	;START OF FLOATING VECTORS
;DC11 (BR5)
ZEPT	NDC,<
	CONS DC,\Z,<RS=174000+<Z*10>>	;RCV STATUS REG
	CONS DC,\Z,<RB=174002+<Z*10>>	;RCV BUFFER
	CONS DC,\Z,<TS=174004+<Z*10>>	;TRANSMIT STATUS
	CONS DC,\Z,<TB=174006+<Z*10>>	;TRANS BUF

	CONS DC,\Z,RV=.	;RCV VECTOR
	CONS DC,\Z,TV=.+4	;TRANS VECTOR
	CONS DC,\Z,RK
	240
	CONS DC,\Z,TK
	240
>
;KL11  (BR4)
ZEPT	NKL,<
	CONS KL,\Z,<RS=176500+<Z*10>>	;RCV STATUS REG
	CONS KL,\Z,<RB=176502+<Z*10>>	;RCV BUFFER
	CONS KL,\Z,<TS=176504+<Z*10>>	;RCV BUFFER
	CONS KL,\Z,<TB=176506+<Z*10>>	;TRANS BUF

	CONS KL,\Z,RV=.	;RCV VECTOR
	CONS KL,\Z,TV=.+4	;TRANS VECTOR
	CONS KL,\Z,RK
	200
	CONS KL,\Z,TK
	200
>

;DH11 (BR5)
ZEPT	NDH,<
	CONS DH,\Z,<SCR=160020+<Z*20>>	;SYSTEM CONTROL REGISTER
	CONS DH,\Z,<NRC=160022+<Z*20>>	;NEXT RECIEVED CHARACTER
	CONS DH,\Z,<LPR=160024+<Z*20>>	;LINE PARAMTER REGISTER
	CONS DH,\Z,<CAR=160026+<Z*20>>	;CORE ADDRESS REGISTER
	CONS DH,\Z,<BCR=160030+<Z*20>>	;BYTE COUNT REGISTER
	CONS DH,\Z,<BAR=160032+<Z*20>>	;BUFFER ACTIVE REGISTER
	CONS DH,\Z,<BRC=160034+<Z*20>>	;BREAK CONTROL REGISTER
	CONS DH,\Z,<SSR=160036+<Z*20>>	;SILO STATUS REGISTER
;CROCK
.=340
	CONS DH,\Z,RV=.
	CONS DH,\Z,TV=.+4
	CONS DH,\Z,RK
	240
	CONS DH,\Z,TK
	240
>
	.=FOO

;STANDARD DEVICE REGISTER BITS
%ER==1_15	;ERROR
%RDY==1_7	;READY
%INT==1_6	;INTERRUPT ENABLE
%CRDT==1_2	;CARRIER DETECT
%ENB==1		;ENABLE
%DTRDY==1	;DATA TERMINAL READY

LINEL:	60.	;LINE LENGTH

OMXRES=.-NFLTTY		;SO THAT THE INDEX OF A PSEUDO TTY NO. WILL POINT INTO
			;THIS TABLE AT THE RIGHT PLACE
	OMXNUL==OMXRES+1	;RH--RESET CHAR, LH--NULL CHAR
	.BYTE 21,0	;TBOX (DC0)
	.BYTE 0,40	;TURT 1
	.BYTE 0,40	;TU 2
	0	;MBX
	.BYTE 0,21	;DUMMY



TTYITM:	.BLKW NTTYS	;ITEM NUMBER OF THE TELETYPE ITEM THAT REFERS TO THIS TTY
TYINFO:	.BLKW NTTYS	;INFO ON TTY SPEED AND NO. OF CHAR TO PAD
	TYPAD==TYINFO+1	;NO. OF CHAR TO PAD TTY

TTYTBL:	.BLKW NTTYS	;CONTAINS FLAGS FOR TELETYPES
MXORF==100000	;MULTIPLEXOR FLAG
MXEEF==40000	;MULTIPLEXEE FLAG (THE BOTTOM BYTE IS MULTIPLEXOR NO.)
DH11F==20000	;DH11 FLAG
DC11F==10000	;DC11 FLAG
DL11F==4000	;DL11 FLAG
MODMF==2000	;MODEM FLAG
TTYF==1000	;TTY FLAG


DHMAX==3	;MAXIMUM # CHARS TO SEND TO EACH DH11 TELETYPE
DHBIT:		ZEPT 20,1_.RPCNT	;MASKS FOR THE DH11 BUFFER ACTIVE REGISTER
DHBUF:		ZEPT 20,DHOBUF+<DHMAX*.RPCNT>	;PNTR TO DHOBUF

DHOBUF:	.BLKB DHMAX*16.*NDH	;WHERE DH11 SENDS CHARS FROM

;BREAK VECTORS POINT TO THESE RECEIVE INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TKBRK:	SAVE <E,D>
	MOV	#NFTY,E
	MOV #TKS,D
	JMP	GENRBK
.ENDC


DC0RK:	SAVE <E,D>
	MOV #NFDCTY,E
	MOV #DC0RS,D
	JMP	GENRBK
DC1RK:	SAVE <E,D>
	MOV	#NFDCTY+2,E
	MOV #DC1RS,D
	JMP	GENRBK


.IFNZ	NTY+NKLTY+NDCTY
;GENRBK--
;GENERAL RECEIVE BREAK FOR TTYS, TBOXS, ETC.
;CALLED WITH	SAVE <E,D>
;		MOV #TTY INDEX,E
;		MOV #TTY STATUS REG,D
;		JMP GENBRK

GENRBK:	JSR	F,ACSAV
	MOV	D,F	
	MOV (F),D	;RG CONTENTS
	BIT	#%ER,D
	BNE	TGENER	;BR IF ERROR BIT ON
	MOV	2(F),D	;CHARACTER
	BIC	#177600,D	;ONLY 7 BITS
	BIT	#TIRST,TTYST(E)
	BEQ	.+6
	JSR	PC,TYIRT1	;RESET INPUT
	BIT #MXORF,TTYTBL(E)
	BEQ TYBRK
	JSR PC,MXRCV
	BR GENRB1
TYBRK:	JSR PC,TYRCV
GENRB1:	JSR	F,ACRES
	REST	<D,E>
	RTT

TGENER:		;PRINT ERROR MESSAGE
	BR	GENRB1

.ENDC

.IFNZ NDH
DH0RK:	JSR F,ACSAV
DH0RK2:	MOV DH0NRC,C		;GET THE CHARACTER
	BGE DH0RK3		;NO CHARACTER
	BIC #110200,C		;CLEAR SILLY BITS
	BIT #60000,C		;IS IT A BREAK?
	BEQ DH0RK1		;NOPE
	BIC #60377,C		;CLEAR CHARACTER AND BREAK BITS
	ADD #7,C		;BREAK
DH0RK1:	MOV C,E			;COPY IT
	SWAB E			;GET LINE NUMBER
	BIC #177760,E		;FLUSH CRAP
	ASL E			;CHANGE LINE NO. INTO A PARTIAL TTY INDEX
	ADD #NFDHTY,E		;MAKE THE INDEX CORRECT
	MOV C,D			;COPY AGAIN
	BIC #177600,D		;JUST THE CHARACTER
	BIT #TIRST,TTYST(E)	;RESET INPUT?
	BEQ .+6
	JSR PC,TYIRT1		;GO RESET IT
	BIT #MXORF,TTYTBL(E)	;IS IT A MULTIPLEXOR
	BEQ DHTTY		;NO
	JSR PC,MXRCV		;GO TO THE MULTIPLEXOR RECEIVE
	BR DH0RK2		;ANY MORE
DHTTY:	JSR PC,TYRCV		;GO TO THE TELETYPE RECEIVE
	BR DH0RK2		;ANY MORE?
DH0RK3:	JSR F,ACRES
	RTT
.ENDC

;MULTIPLEXOR RECIEVE INTERRUPT
MXRCV:	TST TTYITM(E)		;DOES HE HAVE AN ITEM
	BNE MXRCV4		;NOPE
;HERE CAUSE THE ITEM TO BE CREATED
MXRCV4:	MOV TTYITM(E),A		;GET THIS TTY'S ITEM NO. IN A
	JSR PC,ITM0PL		;LOAD THE TTY ITEM
	SAVE	E		;SAVE MULTIPLEXOR'S TTY NO.
	JSR	PC,MXGTY	;GET INDEX OF LOG DEV THIS CHAR BELONGS TO
	BEQ	MXRCV1		;FAIL, THIS CHAR DOESN'T BELONG TO ANYONE
	JSR PC,TYRCV1		;THE DEVICE BETTER NOT BE A MULIPLEXOR
	JSR PC,ITM0PO		;RESTORE THE PREVIOUS ITEM
MXRCV1:	REST E
MXRCV2:	SEZ
RTSPC:	RTS PC


MXGTY:	;GETS TTY # OF NEXT LOG. DEV. IN MX Q, UPDATES Q,
	;FAILS IF NOTHING IN QUEUE
	TST	TIQN(A)
	BLE	MXRCV2		;Q EMPTY, FAIL
	SAVE	D
	MOV TIQN(A),C		;THE NUMBER OF CHAR IN QUE
	MOV #TIQM,D		;RELATIVE POINTER TO BEGINNING OF QUE
	ADD A,D			;MAKE IT ABSOLUTE
	MOVB	(D)+,E		;GET THE IDENTIFIER CHAR
MXGTY1:	MOVB	(D)+,-2(D)	;MOVE REST OF Q UP ONE BYTE
	SOB C,MXGTY1
	DEC	TIQN(A)		;DEC MULTIPLEXOR'S CHAR COUNT
	REST	D
	CLZ
	RTS PC

;ADD CHAR IN D TO BOTTOM OF MX Q
;THIS SHOULD BE THE FIRST THING DONE WHEN SENDING A CHAR TO A MULTIPLEXEE
MXQLAD:	CMP TIQN(A),#TIQSZ	;IS THE MULTIPLEXOR'S QUE FULL
	BGE	MXRCV2		;YES GO AWAY
	MOV TIQI(A),B		;GET RELATIVE POINTER TO NEXT CHAR IN
	ADD A,B			;MAKE IT ABSOLUTE	
	MOVB D,(B)		;MOVE THE CHAR THERE
	INC TIQN(A)		;INCREMENT THE CHAR COUNT
	INC TIQI(A)		;INCREMENT THE CHAR IN POINTER
	CLZ
	RTS PC
.STITL TYPEIN--INTERRUPT LEVEL
;TELETYPE RECIEVE
;PROCESS CHAR IN D FOR TTY IN E
;CAN CLOBBER A,F

TYRCV:	TST TTYITM(E)		;DOES THIS TTY HAVE AN ITEM YET?
	BNE TYRCV4		;YES IT DOES
	;HERE DO THE THING TO CREATE AN ITEM IF APPROPRIATE
TYRCV4:	MOV TTYITM(E),A		;GET ITS ITEM INDEX
	JSR PC,ITM0PL		;LOAD THE TTY ITEM
	BIT #TILIPM,TTYST(A)		;IN LOGO LINE INPUT MODE?
	BEQ TYRCV1		;NO JUST PUT THE CHAR IN BUFFER
	MOV TTYU(A),F		;IS THERE A USER FOR THIS TTY
	BLT TYRCV1		;NOPE
	;HERE DETERMINE IF HE HAS TYPED A BREAK
TYRCV1:	CMP #TIBSZ,TIBN(A)		;IS NO. OF CHAR IN BUFFER=BUFFER SIZE
	BEQ TYRET		;YES GO AWAY
	MOV TIBI(A),C		;GET RELATIVE CHAR IN POINTER
	ADD A,C			;MAKE IT ABSOLUTE
	MOVB D,(C)		;PUT CHAR IN BUFFER
	INC TIBN(A)		;INC CHAR COUNT
	INC TIBI(A)		;INC CHAR IN POINTER
	CMP #TIBT,TIBI(A)	;ARE WE AT THE END OF THE BUFFER YET
	BHI TYRET	;NOPE
	MOV #TIBB,TIBI(A)	;RESET THE CHAR IN POINTER
TYRET:	JSR PC,ITM0PO		;RESTORE THE ORIGINAL ITEM0
TYRET1:	RTS PC


;THIS ROUTINE ASSUMES THE TTY ITEM IS IN ITM0
;AND THE ADR OF ITEM IN A
;THIS ROUTINE SHOULD JUST PUT CHARS IN BUFFER IF NOT IN LOGO INPUT MODE
TICP:	SAVE B
	BIT #TIRST,TTYST(A)	;SHOULD THE TTY BE RESET
	BEQ TICPLT		;NOPE
	JSR PC,TYIRT1		;RESET IT
TICPLT:	CMP #TIBT,TIBO(A)	;HAVE WE REACHED THE TOP OF THE INPUT BUFFER?
	BHI TICP7		;NO
	MOV #TIBB,TIBO(A)	;RESET THE POINTER AND CONTINUE
TICP7:	MOV TIBO(A),D		;GET RELATIVE ADR. OF THE NEXT CHAR.
	ADD A,D			;MAKE IT ABSOLUTE
	MOVB (D),D		;GET THE CHAR. INTO D
	INC TIBO(A)		;INC POINTER
	DEC TIBN(A)		;DECREMENT COUNT
	BIT #TILIPM,TTYST(A)
	BEQ TICP3
	BIT #TIQF,TTYST(A)	;TEST TO SEE IF WE ARE QUOTING THIS CHAR.
	BEQ TICP4		;WE AREN'T
	BIC #TIQF,TTYST(A)	;CLEAR QUOTING FLAG
	BIS #200,D		;SET PARITY BIT TO QUOTE
	BR TICP3		;DON'T CHECK FOR SPECIAL MEANING
TICP4:	BITB #FSF,DTBL(D)	;DOES IT HAVE SPECIAL MEANING?
	BEQ TICP3		;NOPE
	MOVB DTBL2(D),C		;GET INDEX OF CHAR. INTO SPECIAL CHAR. TABLES
	JSR PC,@TIICTB(C)	;GO DO SPECIAL THING
	BEQ TICPLB		;IF Z BIT SET DONT PUT THIS CHAR. INTO INPUT BUFFER
TICP3:	JSR PC,TYINQ		;PUT THIS CHAR. INTO INPUT BUFFER
	BEQ TICPRT		;FAILED SO GO AWAY
TICPLB:	TST TIBN(A)		;ANY MORE CHAR TO PROCESS
	BNE TICPLT		;YES THERE ARE
TICPRT:	JSR PC,TOCINT		;CAUSE AN OUTPUT INTERUPT (ECHO CHAR.)
TICP5:	REST B
	RTS PC


;PUT CHAR IN D INTO CONSOLE IN E'S INPUT QUE
TYINQ:	SAVE F
	BIT	#TICVM,TTYST(A)
	BEQ	TIINQ		;BR IF NOT CONVERTING LOWER TO UPPER CASE
	JSR	PC,TICVLU	;CONVERT
;PUT CHAR IN D INTO TTY IN E'S INPUT QUE
TIINQ:	CMP TIQN(A),#TIQSZ	;NO. OF CHAR IN BUFFER=SIZE OF BUFFER?
	BGE	TIINQ1		;BR IF QUE FULL
	MOV TIQI(A),F		;GET RELATIVE AADR. OF NEXT CHAR IN
	ADD A,F			;MAKE IT ABSOLUTE
	MOVB	D,(F)		;PUT THE CHAR. IN THE INPUT QUE
	INC	TIQI(A)		;INC POINTER
	INC	TIQN(A)		;INC COUNTER
	INC	TIQTON(A)	;INC NO. OF CHAR FOR ECHONG TO PROCESS
	INC TITQN(A)		;INC TOTAL NO. OF CHAR IN QUE
	REST F
	CLZ
	RTS PC

TIINQ1:	SEZ
	RTS PC

;THIS ROUTINE TAKES THE NO. OF CHAR DESIRED IN B AND
;RETURNS WITH CONDITION CODES SET IF ENOUGH CHAR
CHARCK:	BIT #TILIPM,TTYST(A)	;IN LINE INPUT MODE
	BNE CHRCK1	;YES
	CMP TIBN(A),B
	RTS PC
CHRCK1:	CMP TIEQTN(A),B
	RTS PC

;PUT A CHAR INTO THE OUTPUT BUFFER EXPECTS TTY IN ITEM2
;HANG IF FULL
TYO:	TST TOPC(A)	;IS THE OUTPUT BUFFER FULL
	BEQ TYO2	;NOPE
	SAVE D		;NEED A REGISTER
TYO1:	MOV ITEM2,D	;EXPECTS TTY IN ITEM2
	JSR PC,ITM2PO	;POP THE EXTRA ITEM
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	MOV D,A		;GET BACK THE ITEM NO
	JSR PC,ITM2PL	;LOAD IT UP
	TST TOPC(A)	;STILL FULL
	BNE TYO1	;YES
	JSR PC,RUNME	;GOT IT
	REST D		;RESTORE D TO ORIGINAL CONTENTS
	BR TYO		;JUST TO MAKE SURE
TYO2:	SAVE C
	JSR PC,TOTYO	;PUT THE CHARACTER INTO THE OUTPUT BUFFER
	REST C
	JSR PC,TOCINT	;CAUSE AN INTERUPT
	RTS PC

;*****TIOQ RUNS AT USER LEVEL ALSO******
;GET A CHAR FROM INPUT QUEUE
;THIS ROUTINE EXPECTS TTY ITEM IN ITEM2 AND ADDRESS IN A

TIOQ:	BIT #TILIPM,TTYST(A)	;IS IT IN LINE INPUT MODE
	BEQ TIOQ1	;NOPE
	TST TIEQTN(A)	;ANY CHARACTERS
	BLE TIINQ1		;NOPE
	MOV TIEQTO(A),D		;GET RELATIVE ADRS. OF CHAR
	ADD A,D			;MAKE IT ABSOLUTE
	MOVB (D),D		;GET THE CHAR
	BIC #177400,D		;CLEAR THE EXTRA BITS
	INC TIEQTO(A)		;INC THE POINTER
	DEC TIEQTN(A)		;DEC THE CHAR COUNT
	CLZ
	RTS PC
TIOQ1:	TST TIBN(A)	;ANY CHARACTERS
	BLE TIINQ1	;NOPE
	CMP #TIBT,TIBO(A)	;AT THE END OF THE BUFFER YET
	BHI TIOQ2
	MOV #TIBB,TIBO(A)	;RESET POINTER
TIOQ2:	MOV TIBO(A),D		;GET POINTER TO NEXT CHAR. OUT
	ADD A,D			;MAKE THE POINTER ABSOLUTE
	MOVB (D),D		;GET THE CHAR
	BIC #177400,D		;CLEAR THE EXTRA BITS
	DEC TIBN(A)		;UPDATE THE COUNT
	INC TIBO(A)		;UPDATE THE POINTER
	CLZ
	RTS PC



;IF CHAR IN D IS LOWER CASE, CONVERT TO UPPER
TICVLU:	TSTB	D
	BMI	TICVL1		;BR IF QUOTED
	CMP	D,#'_
	BLE	TICVL1		;BR IF UPPER CASE
	CMP	D,#177
	BEQ	TICVL1		;DON'T CASE RUBOUT
	SUB	#40,D
TICVL1:	RTS PC


;QUOTE NEXT CHAR
TICQ:	BIT	#TIQF,TTYST(A)
	BNE	TICQ1		;BR IF ^Q WAS PREVIOUS CHAR
	BIS	#TIQF,TTYST(A)
	RTS PC
TICQ1:	BIC	#TIQF,TTYST(A)
	RTS PC

;RESET TTY
TTYRT:	JSR	PC,TYORT	;RESET THE OUTPUT BUFFER
	JSR	PC,TYIRT	;RESET THE INPUT QUE
	JSR PC,TYBRT		;RESET THE INPUT BUFFER
	RTS PC
;RESET DEVCE
TTYRT1:	JSR PC,TYORT	;RESET THE OUTPUT BUFFER
	JSR PC,TYIRT1	;RESET THE INPUT QUE
	JSR PC,TYBRT	;RESET THE INPUT BUFFER
	RTS PC


;RESET TYPEOUT PNTRS
TYORT:	SAVE <A,F>
	BIT #MXEEF,TTYTBL(E)	;IS IT A MULTIPLEXEE
	BEQ TYORT1		;NOPE
	MOV TOQN(A),F		;GET THE NUMBER OF CHAR. IN THIS OUTPUT BUFFER
	MOVB TTYTBL(E),A	;GET THE MULTIPLEXOR TTY NO.
	MOV TTYITM(A),A		;GET THE MULTIPLEXOR ITEM INDEX
	JSR PC,ITM0PL		;LOAD THE MULTIPLEXOR TTY ITEM
	SUB F,TOQN(A)		;SUB THE NUMBER OF CHAR IN MXEE FROM MXOR
	JSR PC,ITM0PO		;RESTORE THE MULTIPLEXEE'S TTY ITEM
	MOV ITM0A,A		;RELOAD THE ITEM INDEX INTO A
TYORT1:	REST F
	CLR	TOQN(A)		;CLR CHAR COUNT
	MOV #TOQM,TOQI(A)	;RESET CHAR IN POINTER
	MOV #TOQM,TOQO(A)	;RESET CHAR OUT POINTER
	CLR	TOPC(A)		;CLR SAVED PC
	CLR	TOIPC(A)	;CLR SAVED PC
	REST A
	RTS PC

;*** TYIRT RUNS AT USER LEVEL ALSO ***
;RESET INPUT PNTRS
TYIRT:	BIC	#TIEDM!TIQF!TIRBM,TTYST(A)	;CLR MISC FLAGS
TYIRT1:	BIC	#TIRST,TTYST(A)	;RESET FLAG
	BIT #TILIPM,TTYST(A)	;ARE WE IN LINE INPUT MODE
	BNE TYIRT2		;YES
	CLR TIEQTN(A)		;RESET THE CHAR OUTPUT COUNT
	MOV #TIQM,TIEQTO(A)	;RESET THE CHAR OUT POINTER
TYIRT2:	CLR	TIQTON(A)		;CLR ECHOING COUNT
	CLR	TIQN(A)		;CLR CHAR COUNT
	MOV #TIQM,TIQI(A)	;RESET THE CHAR IN POINTER
	MOV #TIQM,TIQO(A)	;RESET THE CHAR OUT POINTER
	MOV #TIQM,TIQTO(A)	;RESET THE ECHOING CHAR POINTER
	MOV TIEQN(A),TITQN(A)	;THE NO. OF CHAR IN EDIT QUE IS TOTAL NO. OF CHAR
	CLR	TIBC(A)		;CLR BRACKET COUNT
	RTS PC

;RESET EDIT PNTRS
TYERT:	CLR	TIEQN(A)	;CLR CHAR COUNT
	MOV #TITQ,TIEQO(A)	;RESET CHAR OUT POINTER
	MOV TIQN(A),TITQN(A)	;NO. OF CHAR IN INPUT QUE IS TOTAL NO. OF CHAR
	RTS PC

TYBRT:	CLR TIBN(A)		;CLR CHAR COUNT
	MOV #TIBB,TIBO(A)	;RESET CHAR IN POINTER
	MOV #TIBB,TIBI(A)	;RESET CHAR OUT POINTER
	RTS PC


;*** USER AND INTERRUPT LEVEL ***

;IF NOT TRANSMITTING, CAUSE OUTPUT INTERRUPT
TOCINT:	SAVE E
	MOV TTLTTY(A),E	;GET THE LOGICAL TTY NO
	BIT	#MXEEF,TTYTBL(E)
	BNE	TOCIN3
	BIT	#TOTRAN,TTYST(A)
	BNE	TOCIN2		;BR IF TRANSMITTING
	BIT	#DH11F,TTYTBL(E)
	BEQ	TOCIN1		;BR IF NOT A DH11 TTY
	BIS	#100000,@TOTSR(A)	;SET TRANS INT BIT
	BR	TOCIN2
TOCIN1:	BIC	#100,@TOTSR(A)	;CLEAR AND SET INTERRUPT ENABLE
	BIS	#100,@TOTSR(A)
TOCIN2:	REST E
	RTS PC

TOCIN3:	SAVE <E,A>		;SAVE THE TTY NO. AND ADDRESS
	MOVB TTYTBL(E),E	;GET MULTIPLEXOR NO. OF THIS MULTIPLEXEE
	MOV TTYITM(E),A		;GET MULTIPLEXORS ITEM INDEX
	JSR PC,ITM0PL		;LOAD MULTIPLEXORS TTY ITEM
	JSR PC,TOCINT		;CAUSE THE MULTIPLEXOR TO INTERUPT
				;(THAT'S WHAT WE WANTED IN THE FIRST PLACE)
	JSR PC,ITM0PO		;RELOAD THE MULTIPLEXEE'S TTY ITEM
	REST <A,E>		;RESTORE THE TTY NO. AND ADDRESS
	RTS PC



.STITL TYPE OUT--INTERRUPT LEVEL

;BREAK VECTORS POINT TO THESE TRANSMIT INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TPBRK:	SAVE <E,D>
	MOV	#NFTY,E
	MOV TPS,D
	JMP	GENTBK
.ENDC

DC0TK:	SAVE <E,D>
	MOV #NFDCTY,E
	MOV DC0TS,D
	JMP	GENTBK
DC1TK:	SAVE <E,D>
	MOV	#NFDCTY+2,E
	MOV DC1TS,D
	JMP	GENTBK

.IFNZ NDH
DH0TK:	JSR F,ACSAV
	MOV #DH0SCR,B
	BIT #42000,(B)		;ANYTHING BAD IN THE STATUS REGISTER?
	;	BEQ .+6		NOPE
	;	JSR PC,DEVER	PRINT AN ERROR MESSAGE
	;	INCB 1(B)	RESET NXM
	BIC #100000,(B)		;RESET DONE
	ADD #12,B		;GET BAR ADDRESS
	CLR F			;F CONTAINS THE DH11 LINE NO.*2
	MOV #1,A		;A CONTAINS 1_LINE NO.
DHTK2:	BIT A,(B)		;THAT LINE TRANSMITING?
	BNE DHTK3		;YES
	MOV F,E			;COPY LINE NO.*2
	ADD #NFDHTY,E		;TURN IT INTO A TTY NO.
	SAVE A			;TRANSMIT ROUTINES CRUNCH A
	JSR PC,TYXMT		;SEND ANYTHING YOU GOT
	REST A
DHTK3:	TST (F)+		;NEXT LINE
	ASL A			;NEXT BAR BIT
	BNE DHTK2		;OUT OF LINES?
	JSR F,ACRES
	RTT
.ENDC

;GENERAL TRANSMIT BREAK
GENTBK:	JSR	F,ACSAV
	BIT	#%RDY,D
	BEQ	GENTB2		;BR IF NOT RDY, SPURIOUS INTERRUPT
GENTB1:	MOV TTYITM(E),A		;GET THE TTY ITEM
	BEQ GENTB2		;NO ITEM SPURIOUS INTERUPT
	JSR PC,ITM2PL		;LOAD IT UP
	JSR PC,TYXMT		;TRANSMIT CHARACTERS
	JSR PC,ITM2PO		;POP THE TTY ITEM
GENTB2:	JSR	F,ACRES
	REST <D,E>
	RTT

;GET NEXT MULTIPLEXOR OUTPUT CHARACTER
;FROM MULTIPLEXEE'S OUTPUT QUE INTO D
;CHAR IN MULTIPLEXOR'S OUTPUT QUE TELL WHICH ORDER TO SEND THEM
;SKIP ONE WORD IF SUCESSFULL
MXGOC:	TST	TOQN(A)		;ANY MULTIPLEXEE'S IN THE QUE (ANY CHAR TO SEND)
	BLE	MXGOC4		;BR IF NO CHARS TO SEND
	CMP TOQO(A),#TOQM+4	;ONLY 4 BYTE OUTPUT QUE?
	BLO	.+10		;BR IF OUTPUT PNTR NOT PAST END OF QUEUE
	MOV #TOQM,TOQO(A)	;RESET POINTER
	SAVE <E,A>		;SAVE THE TTY NO. AND ADDRESS OF THE MULTIPLEXOR'S TTY
	MOV TOQO(A),E		;GET POINTER TO CHAR IN MULTIPLEXOR OUTPUT QUE
	ADD A,E			;MAKE THE POINTER ABSOLUTE
	MOVB (E),E		;THE CHAR IS THE MULTIPLEXEE'S TTY NO.
	MOV TTYITM(E),A		;GET THE MULTIPLEXEE'S TTY ITEM INDEX
	JSR PC,ITM0PL		;LOAD THE MULTIPLEXEE'S TTY ITEM
	JSR	PC,TOSOP	;START OUTPUT
	BR	.+2		;OUTPUT Q FULL
	JSR PC,TYGOC		;GET A CHAR FROM THE MULTIPLEXEE'S OUTPUT QUE
	BR	MXGOC3		;NO CHARS
	REST <A,E>		;RESTORE TTY NO. AND ITEM INDEX OF MULTIPLEXOR'S TTY
	JSR PC,ITM0PO		;RELOAD THE MULTIPLEXOR'S TTY ITEM
	DEC	TOQN(A)		;DECREMENT MPXRS CHAR COUNT
MXGOC6:	INC	TOQO(A)		;INC MULTIPLEXOR'S POINTER
MXGOC5:	ADD	#2,@P		;SKIP RETURN
MXGOC2:	RTS PC

;MULTIPLEXOR HAS CHARS TO SEND, BUT CURRENT MULTIPLEXEE DOESN'T
MXGOC3:	MOVB	OMXNUL(E),D	;RETURN NULL CHAR FOR MULTIPLEXEE
	REST <A,E>		;RESTORE MULTIPLEXOR'S TTY NO. AND ITEM INDEX
	JSR PC,ITM0PO		;RESTORE MULTIPLEXOR'S TTY ITEM
	BR MXGOC6		;RETURN IN STYLE


;NO CHARACTERS FOR MULTIPLEXOR
MXGOC4:
	CMP TOQO(A),#TOQM
	BEQ MXGOC2
	MOV #TOQM,TOQO(A)
;THE NEXT INSTRUCTION IS A LOSSAGE IT ASSUMES THE THORTON BOX HAS A TTY
;NO. OF ITS OWN AND IT PRECEEDS THE DEVICES FOR IT
	MOVB	OMXRES(E),D	;SEND MULTIPLEXOR RESET CHARACTER
	BR	MXGOC5

;GET NEXT TTY OUTPUT CHARACTER
;SKIP ONE WD IF SUCCESSFUL
TYGOC:	BIT #TTYF,TTYST(A)
	BNE TYGOC1		;BR IF IN IMAGE MODE (DON'T PAD)
	TSTB TOPAD(A)
	BGE TYGOC4		;BR IF SOME PADDING LEFT
TYGOC1:	JSR PC,TOOQ		;GET CHAR FROM OUTPUT BUFFER
	BR TYGOC3		;BR IF BUFFER EMPTY
	BIT #TIMAGO,TTYST(A)
	BNE TYGOC2		;BR IF IN IMAGE MODE
	CMP D,#15
	BNE TYGOC2
	MOVB TYPAD(E),TOPAD(A)	;IF CR, SET UP PADDING
TYGOC2:	ADD #2,@P		;SKIP RETURN
TYGOC3:	RTS PC
;SEND PADDING CHAR INSTEAD OF NEXT CHAR FROM QUEUE
TYGOC4:	CLR	D
	DECB	TOPAD(A)	;DEC # OF PADS
	BR	TYGOC2


;REMOVE CHAR FROM CIRCULAR OUTPUT QUEUE AND RETURN IT IN D
;SKIP ONE WORD IF SUCCESSFUL
TOOQ:	TST	TOQN(A)
	BLE	TOOQ2		;BR IF NOTHING IN Q
	CMP TOQO(A),#TOQLM
	BLO TOOQ1
	MOV #TOQM,TOQO(A)
TOOQ1:	MOV TOQO(A),D	;GET THE POINTER
	ADD A,D		;MAKE IT ABSOLUTE
	MOVB (D),D	;GET CHAR
	INC	TOQO(A)		;INC PNTR
	DEC	TOQN(A)		;DEC CHARACTER COUNT
	ADD	#2,@P		;SKIP RETURN
TOOQ2:	RTS	PC

;TTY TRANSMIT INTERRUPT
;FIRST SEND CHARS IN OUTPUT Q
;THEN PROCESS CHARS IN INPUT Q
;CAN CLOBBER A&C
TYXMT:	BIC	#TOTRAN,TTYST(A)	;CLEAR XMT INT PENDING BIT
	BIT #TORST,TTYST(A)	;RESET THE OUTPUT
	BEQ .+6			;NOPE
	JSR PC,TYORT		;RESET THE BUFFER
	JSR	PC,TOSOP	;START OUTPUT
	BR	TYXMT3		;OUTPUT BUFFER FILLED AGAIN
TYXMT1:	JSR	PC,TOPIC	;PROCESS CHARS FROM INPUT BUFFER
TYXMT3:				;ACTUALLY SEND CHARACTERS!!!
	BIT	#DH11F,TTYTBL(E)
	BNE	TYXMT5		;BR IF DH11 TTY
	SAVE C
	BIT #MXORF,TTYTBL(E)	;IS IT A MULTIPLEXOR?
	BEQ TYXTTYî				;NOPE
	MOV #MXGOC,C		;JMP TO THE MULTIPLEXOR ROUTINES
	BR TYXMT6		;GO JUMP
TYXTTY:	MOV #TYGOC,C		;JMP TO THE TELETYPES ROUTINES
TYXMT6:	JSR PC,(C)		;GO JUMP TO THE APPROPRIATE ROUTINES
	BR	TYXMT4		;NONE
	MOV TOTSR(A),B		;POINTER TO TRANSMIT STATUS REG.
	MOV	D,2(B)		;PUT CHAR IN DEVICES OUTPUT BUFFER
	BIS	#TOTRAN,TTYST(A)	;SET XMT INT PENDING FLAG
TYXMT4:	REST C
	RTS PC

;START OUTPUT
;SKIP RETURN IF OUTPUT BUFFER NOT FULL
TOSOP:
	CMP TOQN(A),#TOQSZ
	BGE	TOSOP2		;BR IF Q FULL
	TST	TOPC(A)		;DID WE EXIT FROM MIDDLE OF PROCESSING CHAR TO OUTPUT Q
	BEQ	TOSOP1		;BR IF NO
	MOV	TOSVC(A),C	;RESTORE MISC AC'S
	MOV	TOSVD(A),D
	SAVE	TOPC(A)		;LOCATION TO JSR TO
	CLR	TOPC(A)
	JSR	PC,@(P)+	;CALL AS COROUTINE
	BR	TOSOP2		;OUTPUT Q FILLED AGAIN
TOSOP1:	ADD	#2,@P		;SKIP RETURN
TOSOP2:	RTS	PC


.IFG NDH
TYXMT5:	JSR	PC,DHSND	;TRANSMIT CHARS TO DH TTY
	RTS	PC

;TRANSMIT CHARS TO DH11 TTY
DHSND:	JSR	F,ACSAV
	TST -(P)		;CONTAINS NEGATIVE OF THE CHAR COUNT
	MOV E,F
	SUB #NFDHTY,F
	MOV	DHBUF(F),B	;WHERE CHARS ACTUALLY SENT FROM
	BIC #17,DH0SCR
	BIS F,DH0SCR		;SET LINE NUMBER
	MOV B,DH0CAR		;SET THE ADDRESS
	MOV	#DHMAX,C	;MAX NUM OF CHARS TO SEND
	SAVE A			;A CLOBBERED BELOW AND BY GET CHAR ROUTINES
DHSND1:	BIT #MXORF,TTYTBL(E)	;IS IT A MULTIPLEXOR
	BEQ DHSND4		;NO
	MOV #MXGOC,A		;MAKE SURE WE GO TO THE MULTIPLEXOR ROUTINES
	BR DHSND5
DHSND4:	MOV #TYGOC,A		;MAKE SURE WE GO TO THE TELETYPE ROUTINES
DHSND5:	JSR PC,(A)		;GO TO THE APPROPRIATE PLACE
	BR	DHSND6		;RETURN HERE IF NO CHARS
	MOVB	D,(B)+		;PUT CHAR IN BUFFER
	DEC 2(P)		;NEGATIVE CHAR COUNT
	SOB C,DHSND1		;MAX NUM OF CHARS TO SEND
	REST A			;RESTORE ADDRESS OF TTY ITEM
DHSND2:	TST (P)
	BGE	DHSND3		;BR IF NOTHING TO SEND
	MOV (P),DH0BCR		;SET BYTE COUNT
	BIS DHBIT(F),DH0BAR	;START LINE UP
	BIS	#TOTRAN,TTYST(A)	;SET XMT INT PENDING FLAG
DHSND3:	TST (P)+		;POP OF THE CHAR COUNT
	JSR	F,ACRES
	RTS	PC

DHSND6:	REST A
	BR DHSND2

.ENDC

;PROCESS CHARS IN INPUT BUFFER
TOPIC1:	INC	TIQTO(A)	;INC CHAR PNTR
	DEC	TIQTON(A)	;DEC CHAR COUNT
	JSR	PC,TOIEC	;ECHO CHAR
TOPIC:	TST	TOPC(A)
	BNE	TOICM4		;IF OUTPUT BUFFER FULL, GO AWAY
	TST	TIQTON(A)
	BLE	TOICM4		;NO CHARS LEFT TO PROCESS
	MOV TIQTO(A),D		;GET POINTER TO NEXT CHAR TO BE ECHOED
	ADD A,D			;MAKE POINTER ABSOLUTE
	MOVB (D),D		;GET THE CHAR
	BR TOPIC1		;ECHO IT

;^M POSSIBLE END OF LINE
TOICM:	BIT	#TILIPM,TTYST(A)
	BEQ	TOICM3		;BR IF NOT IN LINE INPUT MODE
	TST	TIBC(A)
	BGT	TOICM3		;BR IF INSIDE BRACKETS
	INC	TIQTO(A)	;INCREMENT CHAR ECHOING POINTER
	DEC	TIQTON(A)	;DEC CHAR ECHOING COUNT
	JSR	PC,TOIEC	;ECHO CHAR
	JSR PC,TYINQ		;PUT CR. INTO QUE (ECHOING IT)
	SAVE <A,B,C,F>
	MOV A,F			;SO THAT THE POINTER WILL BE ABSOLUTE
	ADD TIQI(A),F		;ADD THE RELATVE POINTER TO ABSOLUTE ADDRESS
	MOV #TITQ+1,B		;POINTER TO THE TOP OF QUE
	ADD A,B			;MAKE POINTER ABSOLUTE
	MOV TIQN(A),C		;GET NO. OF CHAR TO MOVE
	MOV C,TIEQN(A)		;THE NO. OF CHAR IN INPUT QUE IS THE NO. OF CHAR IN EDIT QUE
	MOVB -(F),-(B)		;MOV THE ENTIRE INPUT QUE TO EDIT QUE
	SOB C,.-2
	MOV B,TIEQO(A)		;POINTER TO WHERE LAST CHAR WENT IN IS POINTER TO WHERE
				;NEXT CHAR COMES OUT OF EDIT QUE
	REST <F,C,B,A>
	JSR	PC,TYIRT	;RESET INPUT BUFFER
	MOV TIEQN(A),TIEQTN(A)	;INITIALIZE POINTERS FOR LOGO LINE INPUT MODE
	MOV TIEQO(A),TIEQTO(A)	;TYI USES THESE POINTERS TO GET NEXT CHAR IN COMMAND LINE
	MOV #TICP5,(P)		;THIS CROCK SO THAT WE STOP PROCESSING CHARS
	JSR PC,TOCINT		;CAUSE AN OUTPUT INTERUPT FOR THE THINGS WE PUT IN AT THE TOP
	SEZ			;RETURN TO TICP5, WHICH WILL ALLOW US TO RETURN PROPERLY
TOICM4:	RTS	PC
TOICM3:	CLZ			;NOT REALLY SPECIAL
	RTS PC

;^Y EDIT PREVIOUS LINE
TOICY:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^Y?
	JSR	PC,TOIECS	;IF NO, JMP HERE, ECHO ^Y
	MOV	#15,D
	JSR	PC,TOIECS	;ECHO CR
	MOV	#'_,D
	JSR	PC,TOIEC	;ECHO _
	BIS	#TIEDM,TTYST(A)	;PUT TTY IN EDIT MODE
	SEZ
	RTS	PC

;^X CLARIFY INPUT
;TYPE CR, REST OF EDIT BUFFER, CR, INPUT BUFFER
TOICX:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^X?
	MOV	#15,D		;NO
	BIT	#TIEDM,TTYST(A)
	BEQ	TOICX2		;BR IF NOT EDITING
	TST	TIEQN(A)
	BLE	TOICX2		;BR IF NOTHING IN EDIT BUFFER
	MOV	TIEQO(A),B
	ADD A,B		;MAKE POINTER TO CHAR ABSOLUTE
TOICX1:	JSR	PC,TOIECS	;ECHO CHAR IN D (SKIPS LEVEL IF Q FULL)
	MOVB	(B)+,D		;GET NEXT EDIT CHAR
	CMP B,#TITQ
	BLO	TOICX1		;BR IF STILL CHARS TO PRINT
	BHI	TOICX5		;BR IF JUST PRINTED LAST CHAR
	CMP	D,#15
	BNE	TOICX1		;LAST CHAR NOT CR, PRINT IT, THEN PRINT CR.
TOICX5:	MOV	#15,D
TOICX2:	TST	TIQN(A)		;ANY CHAR IN INPUT QUE?
	BLE	TOICX4		;NOPE
	MOV #TIQM,B
	ADD A,B			;MAKE B POINT TO THE ABSOLUTE STARTING ADR OF QUE
TOICX3:	JSR	PC,TOIECS	;DID WE GET STOPPED BEFORE WHILE TRYING TO ECHO?
	MOVB	(B)+,D		;GET THE A CHAR FROM THE BOTTOM OF INPUT QUE
	CMP	B,TIQTO(A)	;ARE WE TO THE END OF THE CHARS
	BLOS	TOICX3		;BR IF MORE INPUT CHARS TO PRINT
TOICX4:	SEZ
	RTS PC


;ECHO CHAR FROM SPECIAL INPUT CHAR SUBR
TOIECS:	SAVE	A
	JSR	PC,TOIEC	;ECHO
TOIES1:	REST	A
	TST	TOPC(A)		;DID WE GET STOPPED TRYING TO ECHO
	BEQ	TOIECR		;NOPE WE SUCCEEDED
	MOV	(P)+,TOIPC(A)	;WHERE TO RETURN TO
	MOV	A,TOISVA(A)	;SAVE AC A
TOIECR:	RTS	PC

;ECHO RUBBED OUT CHAR
TOIRCS:	SAVE	A
	JSR	PC,TOPRB	;RUB OUT CHAR AND ECHO
	BR	TOIES1		;MAKE SURE WE DIDN'T GET STOPPED TRYING TO ECHO

;ENTER SUBR THAT TOIECS EXITED
TOIENT:	TST	TOIPC(A)	;DID WE GET STOPPED LAST TIME 
	BEQ	TOIEN1		;NOPE
	MOV	TOIPC(A),@P	;RETURN HERE INSTEAD OF CALLING ROUTINE
	CLR	TOIPC(A)	;SAY WE DIDN'T GET STOPPED THIS TIME
	MOV	TOISVA(A),A	;RESTORE RANDOM REGISTER
TOIEN1:	RTS	PC

;^C COPIES NEXT CHAR FROM EDIT QUEUE TO TYI QUEUE
TOICC:	BIT	#TIEDM,TTYST(A)	;ARE WE IN EDIT MODE
	BEQ	TOICC1		;BR IF NOT IN EDIT MODE
	JSR PC,TOICN4		;GET A CHAR FROM EDIT QUE INTO INPUT QUE
TOICC1:	SEZ
	RTS PC


;^N COPIES NEXT WORD FROM EDIT TO TYI Q

TOICN:	BIT #TIEDM,TTYST(A)	;ARE WE IN EDIT MODE
	BEQ TOICN3		;NOPE
TOICN5:	JSR PC,TOICN4		;GET A CHAR FROM EDIT QUE INTO INPUT QUE
	BEQ TOICN3		;FAILED
	JSR PC,TOISWS		;IS IT A SEPARATOR CHAR
	BEQ TOICN5		;NO, GO BACK AND GET NEXT CHAR
TOICN3:	SEZ			;REACHED SEPARATOR, RETURN SUCESSFUL
	RTS PC

TOICN4:	JSR PC,TOGED		;GET A CHAR FROM INPUT QUE
	BEQ TOICN3		;FAILED THERE SO FAIL HERE
	MOV TIQI(A),B		;GET POINTER TO NEXT CHAR IN INPUT QUE
	ADD A,B			;MAKE POINTER ABSOLUTE
	MOVB D,(B)		;PUT THE CHAR FROM EDIT QUE THERE
	JSR PC,TIBCK		;CHECK IF ITS A BRACKET
	INC TIQN(A)		;INC CHAR COUNT OF INPUT QUE
	INC TIQI(A)		;INC CHAR POINTER
	INC TIQTON(A)		;INC NO OF CHAR THAT HAVE TO BE ECHOED
	RTS PC

TIBCK:	CMP D,#'[		;IS IT A LEFT BRACKET
	BNE .+6			;NOPE
	INC TIBC(A)		;INC UNMATCHED BRACKET COUNT
	CMP D,#']		;IS IT A RIGHT BRAKET
	BNE .+6			;NOPE
	DEC TIBC(A)		;DECREMENT UNMATCHED BRACKET COUNT
	RTS PC


;^R COPY REST OF EDIT BUFFER TO INPUT BUFFER
TOICR:	BIT	#TIEDM,TTYST(A)
	BEQ	TOICC1	;BR IF NOT IN EDIT MODE
TOICR1:	JSR PC,TOICN4
	BEQ TOICC1
	BR TOICR1



;SKIP IF CHAR IN D IS WD SEPERATOR
TOISWS:	TSTB	D
	BMI	TOISW1	;BR IF QUOTED (HIGH BIT ON)
	BITB	#WSF,DTBL(D)
TOISW1:	RTS PC

;^D DELETES NEXT CHAR FROM EDIT QUEUE
TOICD:	BIT	#TIEDM,TTYST(A)
	BEQ	TOISW1	;BR IF NOT IN EDIT MODE
	JSR	PC,TOGED	;GET NXT EDIT CHAR
	BEQ TOISW1
	JSR PC,TOPRB	;ECHO RUBBED OUT CHAR
TOICD1:	SEZ
	RTS PC


;REPLACE ^B WITH %
TICB:	MOV #'%,D
	RTS PC


;^S SKIPS NXT WD IN EDIT QUEUE
TOICS:	BIT #TIEDM,TTYST(A)
	BEQ TOICD1
TOICS1:	JSR PC,TOGED
	BEQ TOICD1
	JSR PC,TOPRB
	JSR PC,TOISWS
	BNE TOICD1
	BR TOICS1


;^Q HAD EFFECT ON INPUT, DELETE FROM Q & ECHO
TOICQ:	JSR PC,TICQ
	JSR PC,TOIECS	;ECHO ^Q
	SEZ
	RTS PC
	
;RUBOUT RUBS OUT PREVIOUSLY PROCESSED CHAR
TOIRB:	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW2	;FAIL
	JSR	PC,TOPRB	;PRINT RUBBED OUT CHAR
	JSR	PC,TOIBCK	;CHECK FOR RUBBED OUT [ OR ]
	JSR PC,TOIOWP	;OVERWRITE RUBBED OUT CHAR
	SEZ
	RTS PC

TOICW2:	BIC	#TIRBM,TTYST(A)	;CLEAR RUB OUT MODE FLAG
	MOV	#15,D	;ECHO A C.R.
	JSR PC,TOIEC
	SEZ
	RTS PC

;^W RUBS OUT PREVIOUS WD
TOICW:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^W?
	JSR	PC,TOIQP	;NO, GET PREVIOUS CHAR
	BEQ	TOICW2	;FAIL
TOICW1:	JSR	PC,TOIBCK	;CHECK FOR BRACKET
	JSR	PC,TOIRCS	;PRINT CHAR
	JSR	PC,TOIOWP	;BLT OVER CHAR
	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW2
	JSR	PC,TOISWS	;SKIP IF WD SEPERATOR
	BEQ	TOICW1
TOICW3:	SEZ
	RTS PC

;[ INCS BRACKET COUNT
TOIOB:	INC TIBC(A)
	BGE	TOICB2
	BPT	;-BRACKETS
	BR TOICB2

;] DECS BRACKET COUNT IF THERE ARE ANY
TOICB:	TST	TIBC(A)
	BLE	TOICW3	;NO BRACKETS, IGNORE
	DEC	TIBC(A)	;DEC COUNT
TOICB2:	CLZ
	RTS PC


;GET PREVIOUS CHARACTER IN INPUT BUFFER AND SKIP
TOIQP:	SAVE	A
	MOV	TIQTO(A),A	;GET POINTER TO CURRENT CHARACTER
	DEC A
	CMP A,#TIQM
	BLO	TOIQP1	;BR IF NO PREVIOUS CHARACTER
	MOVB	(A),D
	REST	A
	CLZ
	RTS PC
TOIQP1:
	REST	A
	SEZ
	RTS	PC

;CHECK FOR RUBBED OUT [ & ]
TOIBCK:	CMP	D,#'[
	BNE	.+6
	DEC	TIBC(A)	;IF CHAR WAS [, DECREMENT BRACKET COUNT
	CMP	D,#']
	BNE	.+6
	INC	TIBC(A)	;IF RUBBED OUT A ], INC BRACKET COUNT
	RTS	PC

;OVERWRITE PREVIOUS CHARACTER
TOIOWP:	DEC TIQTO(A)
	DEC TIQN(A)
	DEC TITQN(A)
	DEC TIQI(A)
	RTS PC

;GET NEXT CHAR FROM EDIT BUFFER INTO D AND SKIP IF SUCCESSFUL
TOGED:	TST	TIEQN(A)
	BLE	TOGED2-2	;BR IF NOTHING LEFT IN EDIT BUFFER
	DEC	TIEQN(A)	;DEC CHAR COUNT
	MOVB	@TIEQO(A),D	;GET NEXT CHAR
	INC	TIEQO(A)
	CMP	D,#'[
	BNE	.+6
	INC	TIEBC(A)	;CHAR WAS [
	CMP	D,#']
	BNE	.+6
	DEC	TIEBC(A)	;CHAR WAS ]
	CMP	D,#15
	BNE	TOGED2	;NOT A CR
	TST	TIEBC(A)	;CR, TEST FOR END OF EDIT LINE
	BGT	TOGED2
	CLR	TIEQN(A)	;EOL, CLR THIS TO BE XTRA CAREFUL
	SEZ
TOGED2:	RTS	PC


;PRINT RUBBED OUT CHAR IN D ON E'S TTY
TOPRB:	BIT	#TIECM,TTYST(A)
	BEQ	TOGED2	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(A)
	BNE	TOIEC2	;ALREADY IN RUBOUT MODE
	BIS	#TIRBM,TTYST(A)
	BR	TOIEC1	;TYPE OPENING \


;ECHO CHARACTER IN D ON E'S TTY
TOIEC:	BIT	#TIECM,TTYST(A)
	BEQ	TOTYC1	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(A)
	BEQ	TOIEC2	;ALREADY NOT IN RUBOUT MODE
	BIC	#TIRBM,TTYST(A)
	;PRINT CLOSING \
;PRINT \:
TOIEC1:	MOV	D,C	;SAVE CHAR
	MOV	#'\,D
	JSR	PC,TOCINQ	;PUT \ INTO OUTPUT Q
	JSR	PC,TOEXT	;FILLED UP Q
	MOV	C,D	;RESTORE CHAR
TOIEC2:		;PRINT CHAR IN D

;FALLS THROUGH!!!
;FALLS IN!!!

;PROCESS CHAR IN D INTO TTY IN E'S OUTPUT BUFFER
;IF BUFFER FILLS SAVE ACS C,D,PC AND EXIT
TOTYO:	BIT	#TIMAGO,TTYST(A)
	BEQ	TOTYO1	;BR IF NOT IN IMAGE MODE
TOTYOC:	JSR	PC,TOINQ	;PUT CHAR IN OUTPUT BUFFER
	JSR	PC,TOEXT
	BIT #TTYF,TTYST(A)	;IS IT A TTY
	BEQ .+6			;NOPE
	JMP TOCLTO		;SEE IF THE LINE IS TOO LONG
	RTS PC

TOTYO1:	MOVB	D,C
	BMI	TOTYOC	;BR IF CHAR HAS IMAGE MODE BIT SET
	BITB	#FOF,DTBL(C)
	BNE	TOTYO3	;BR IF SPECIAL ON OUTPUT
	CMP	D,#40
	BLT	TOTYO4	;BR IF CONTROL CHAR
	JSR	PC,TOCINQ
	JSR	PC,TOEXT
TOTYO2:	JMP	TOCLTO	;CHECK FOR LINE TOO LONG

;SPECIAL ON OUTPUT
TOTYO3:	MOVB	DTBL2(C),C
	JMP	@TOOCTB(C)
;CONTROL CHAR
TOTYO4:	MOV	#'^,D
	JSR	PC,TOCINQ	;PRINT ^
	JSR	PC,TOEXT
	MOV	C,D
	ADD	#100,D
	JSR	PC,TOCINQ	;PRINT CHAR +100
	JSR	PC,TOEXT
	MOV	C,D
	BR	TOTYO2

;OUTPUT BUFFER FULL, SAVE STATE OF WORLD AND RETURN ONE LEVEL UP
TOEXT:	MOV	C,TOSVC(A)
	MOV	D,TOSVD(A)
	MOV	(P)+,TOPC(A)
TOTYC1:	RTS	PC

;^A PRINTS AS CR
TOOCA:	CLR	CHARNO(A)
	MOV	#15,D
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	MOV	#1,D
	RTS	PC

;^H BACKSPACE DECREMENTS CHARNO IF NOT AT BEGINNING OF LINE
TOOCH:	TST	CHARNO(A)
	BLE	TOOCH1
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	DEC CHARNO(A)
TOOCH1:	RTS	PC

;CHECK IF LINE TOO LONG, IF SO PRINT CRLF
TOCLTO:	CMP	CHARNO(A),LINEL
	BLT	TOOCM1	;BR IF NOT TOO LONG
;^M PRINTS AS CR LF
TOOCM:	MOV	D,C	;SAVE D
	CLR	CHARNO(A)	;CLR CHAR COUNT
	MOV	#15,D
	JSR	PC,TOINQ	;PRINT CR
	JSR	PC,TOEXT
	MOV	#12,D
	JSR	PC,TOINQ	;PRINT LINEFEED
	JSR	PC,TOEXT
	MOV	C,D
TOOCM1:	RTS	PC

;^I PRINTS SPACES TILL NEXT TAB STOP
TOOCI:	MOV	D,C
	MOV	#40,D
TOOCI1:	JSR	PC,TOCINQ
	JSR	PC,TOEXT
	BIT	#7,CHARNO(A)
	BNE	TOOCI1
	MOV	C,D
	RTS	PC

;*** INTERRUPT AND USER LEVEL ***

;PUT CHAR IN D INTO TTY IN E'S CIRCULAR OUTPUT QUEUE
;SKIP TWO WORDS IF SUCESSFULL
TOCINQ:	INC	CHARNO(A)
TOINQ:
	CMP TOQN(A),#TOQSZ
	BGE TOINQ2
	CMP TOQI(A),#TOQLM
	BLO TOINQ1
	MOV #TOQM,TOQI(A)
TOINQ1:	SAVE	E
	MOV TOQI(A),E	;GET POINTER TO CHAR IN
	ADD A,E		;MAKE IT LESS RELATIVE
	MOVB	D,(E)	;PUT CHAR IN BUFFER
	INC	TOQI(A)
	INC	TOQN(A)	;INC # OF CHARS IN OUTPUT BUFFER
	;	MOVB	MXNUM(A),E	;GET THIS TTY'S MULTIPLEXOR
	;	BMI	TOINQ4	;BR IF NOT PSEUDO OR MULTIPLEXED TTY
	;	INC	TOQN(A)	;INC MULTIPLEXOR'S CHARACTER COUNT
TOINQ4:	REST	E
	CMP TOQN(A),#TOQSZ
	BGE	TOINQ3	;BR IF Q FILLED NOW
	ADD	#4,@P	;SKIP RETURN TO SUCESS
TOINQ3:	RTS	PC

TOINQ2:	BPT	;TRIED TO PUT CHAR IN OUTPUT Q WHEN ALREADY FULL
	RTS	PC	;RETURN TO FAILURE

TIANTM:	500.	;TIME TO WAIT FOR CARRIER BEFORE HANGING UP
	.STITL INITIALIZE A TTY ROUTINES
CRTTY:	MOV #TTYLEN,A	;LENGTH OF TTY ITEM
	JSR PC,CRITEM	;CREATE THE ITEM
	BEQ CRTT1	;FAILED
	JSR PC,CLITEM	;CLEAR THE ITEM
	MOV ITEM1,TTITM(A)	;SET THE INITIAL OWNER
	INC TTYREF(A)	;INCREMENT THE REFERENCE COUNTER
	MOV E,TTLTTY(A)	;THE LOGICAL TTY NO.
	MOV B,TTYITM(E)	;SET THE TTY ITEM INTO THE SYSTEM VARIABLE
	MOV TTYTBL(E),C	;THE FLAGS FOR THIS TTY
	BIT #MXORF,C	;IS IT A MULTIPLEXOR
	BNE CRMXOR	;YES
	MOV CURUSR,TTYU(A)	;SAY THE CURRENT USER OWNS THIS TTY
	BIT #MXEEF,C	;IS IT A MULTIPLEXEE
	BNE CRMXOR	;YES
	JSR PC,TTYRT	;RESET THE TTY
	BIS #TIECM!TICVM,TTYST(A)	;SET INITIAL STATUS
CRTT2:	BIT #DH11F,C	;IS IT A DH11 TTY
	BNE CRDH11	;YES
	TST C		;IS IT THE SYSTEM CONSOLE
	BEQ CRSYS	;YES
	MOV #DC0TS,C	;THE ADDRESS OF THE FIRST TRANSMIT STATUS REG
	MOV #NFDCTY,D	;THE TTY NO. OF THE FIRST ORDINARY TTY
CRTT3:	CMP D,E		;IS THE TTY NO. CREATED THE CURRENT ONE
	BEQ CRTT4	;YES
	ADD #2,D	;GET THE NEXT TTY NO.
	ADD #10,C	;GET THE NEXT TRAN. STATUS REG.
	BR CRTT3
CRTT4:	MOV C,TOTSR(A)	;SET THE TRANSMIT REG. POINTER
CRTT5:	JSR PC,ITM0PO	;POP THE TTY ITEM
	CLZ
CRTT1:	RTS PC
CRSYS:	MOV #TPS,TOTSR(A)	;TRANSMIT REGISTER
	BR CRTT5
CRDH11:	MOV #DH0SCR,TOTSR(A)
	BR CRTT5
CRMXOR:	JSR PC,TTYRT1	;RESET THE BUFFERS
	BR CRTT2

CLKTTY:	CLR E
	MOV #NTTYS,B	;NUMBE OF TELETYPES
	MOV ITEM1,A	;FOR A BOGUS PUSH
	JSR PC,ITM1PL	;LOAD UP THE SAME THING AGAIN
CLKTT1:	MOV TTYITM(E),A	;DOES IT HAVE AN ITEM
	BEQ CLKTT2	;NOPE FORGET IT
	JSR PC,ITM1LD	;LOAD IT UP
	BIT #TILIPM,TTYST(A)	;IS HE IN LINE INPUT MODE
	BEQ CLKTT2	;NOPE FORGET IT
	TST TIBN(A)	;ANY CHAR
	BEQ CLKTT2	;NOPE, FORGET THIS ONE TOO
	JSR PC,TICP	;PROCESS ITS CHARACTERS
CLKTT2:	ADD #2,E	;GET THE NEXT TTY
	SOB B,CLKTT1	;GO CHECK IT OUT
	JSR PC,ITM1PO	;DONE, POP BOGUS ITEM
	RTS PC	;GO BACK TO CLOCK ROUTINE

	;SET INTERRUPT ENABLE FOR ALL TTYS
TYINIT:	MOV #100,TKS
	MOV #100,TPS
	RTS PC
