.STITL LOSS CHECKING ROUTINES
	FOO==%FNAM2
	VERN==VERN+%FNAM2


PARBRK:	BPT
	RTT
IOTBRK:	TST USER
	BLT BADTRP
	CMP P,#SPDLP
	BLOS BADTRP
	BIT #340,6(P)
	BNE BADTRP
	CLR PS
	SPUSH A
	CMP -(P),-(P)	;FOOL PRBTRP
	JSR	PC,PRBTRP
	CMP (P)+,(P)+
	SPOP A
	CLR ERPROC
	TST DEBSW
	BEQ IOTBR2
	SPUSH E
	MOV USER,E
	MOV UTTY(E),E
	TST TOTN(E)	;WAIT UNTIL THROUGH PRINTING
	BGT .-4
	SPOP E
	BPT	;BREAK IF DEBUGGING
IOTBR2:	.BUG.
BADTRP:	INC LOSSCT
	BEQ LOSER
	BGT LOST
	JSR	A,SPRINT	;ON SYS CONSOLE
	JSR	PC,PRBTRP	;PRINT MESSAGE
	SPREND
	CMP	(SP)+,(SP)+
	BPT
	RTT

EMTBRK:	BPT
LOSER:	PRTXT ^/I GIVE UP!/
LOST:	BPT
	BR .-2

PRBTRP:	BPRTXT ^/BAD TRAP: VECTOR /
	MOV 10(SP),A
	SUB #4,A	;MAKE IT REAL
	JSR PC,PRON
IOTBR1:	PRTXT ^/ TRAPPED FROM /
	MOV 14(SP),A
	JSR PC,PRON
	PRCR
	RTS	PC

SIMBPT:	HALT	;BPT TRAPS HERE IN SIMULATOR
	RTT
BEBRK:	TST P
	BEQ STKSRW
	SPUSH PS
	SPUSH #10
	BR IOTBRK	;FAKE AN IOT FROM LOC 6
STKSRW:	MOV #PFPDL,P	;HELP, I NEED A STACK!
	TST USER	;WAS IT IN USER CODE?
	BLT SYSSTK	;UGH, NO!
	BIT #340,2	;WAS IT IN AN INTERUPT ROUTINE?
	BNE SYSSTK	;UGH, YES!
	MOV #TYO,PCHR	;JUST THE USER LOSES
	JSR PC,STKCLB	;TELL HIM
	MOV UPDLP,P	;TRY TO RECOVER (UGH!)
	.BUG.
SYSSTK:	JSR PC,SPRINT	;MAKE IT PRINT ON SYS CONSOLE
	PRTXT ^/SYSTEM /
	JSR PC,STKCLB
	SPREND
	BPT
	SPL 0
	MOV #SPDLP,P	;IF THIS EVER WORKS
	JMP NEXTUS	;I'LL BE AMAZED

STKCLB:	PRTXT ^/STACK COLOBBERED AT /
	MOV 0,A
	JSR PC,PRON
	MOV #3,0
	MOV #-1,2
	JMP .CRLF
.HALT:	JSR PC,CKSST
	SPOP A
	SPUSH #0
	SPUSH A

PWRDWB:	JSR F,ACSAV
	JSR F,DEVSAV
	MOV #PWRUPB,PFBRV
	RESET
	HALT

PWRUPB:	JSR F,DEVRES
	JSR F,ACRES
	MOV #BEBRK,BEBRV
	MOV #PWRDWB,PFBRV
PWFNXM:
	RTT
PWRCLR:	JSR F,DEVSAV
	RESET
	RESET
	JSR F,DEVRES
	MOV #BEBRK,BEBRV
	SEZ
	RTS PC

DEVCLR:
	.IFNZ NDISP
	MOV #DISREL,NGREL
	.ENDC
	JSR PC,SEGSET
	MOV #100,LKS
	MOV #115,PCS
	JSR PC,TINITH
	MOV #100000,DKNRTY
	MOV #30.,DKPWFR
	MOV DSKCRB,A
	BEQ NODISK
	CMP #-1,10(A)
	BEQ RKREST
	JSR PC,DSKSG1
	BR NODISK
RKREST:	JSR PC,RKSG1
NODISK:	RTS PC
DEVSAV:	TST (P)+	;FLUSH SAVED F
	MOV #PWFNXM,BEBRV
	MOV SP,PFPDL
	MOV #PFPDL,SP
	SPUSH PPS
	.IFZ DHON
	.IFNZ NDM
	SPUSH DM0BAR
	.ENDC
	.ENDC
	SPUSH SSR0
	SPUSH PUREAR
	SPUSH PUREAR+2
	SPUSH PUREAR+4
	SPUSH TEMPDR	;THESE ARE THE SAME AS DISPAR+DR IF NEWDIS=1
	SPUSH TEMPAR
	MOV P,PWFPDL
	JMP (F)
DEVRES:	MOV PWFPDL,P
	JSR PC,DEVCLR
	SPOP TEMPAR
	SPOP TEMPDR
	SPOP PUREAR+4
	SPOP PUREAR+2
	SPOP PUREAR
	SPOP SSR0
	.IFZ DHON
	.IFNZ NDM
	SPOP DM0BAR
	.ENDC
	.ENDC
	SPOP PPS
	SPOP SP
	JMP (F)
	.STITL DISK STARTER

DSKSRT:
	MOV #SYSWPR,A	;LOOK FOR MOVING HEAD REQESTS
RKSR1:	BIT #100,14(A)
	BEQ RKSR2
	CMP #-1,10(A)
	BEQ RKSGO
RKSR2:	ADD #16,A
	CMP #16*MNUSRS+SYSWPR,A
	BHI RKSR1
	MOV #SYSWPR,A	;NEXT LOOK AT SYSTEM REQUESTS
DSKSR1:	BIT #100,14(A)
	BNE DSKSGO	;FOUND A REQUEST, GO DO IT
	ADD #16,A	;LOOK AT NEXT BLOCK
	CMP #16*MNUSRS+SYSWPR,A	;LAST BLOCK?
	BHI DSKSR1
	MOV SWPLST,A	;MOOBY SWAP OUT REQS?
	BNE DSKSGO
	RTS PC	;NO DISK REQUESTS EXTANT, BETTER LUCK NEXT TIME

DSKSGO:	MOV DKNRTY,DKRTYS	;SET NUMBER OF POSSIBLE RETRYS
	MOV A,DSKCRB	;ADDRESS OF BLOCK ABOUT TO BE SERVICED
	MOV (A),B
	BEQ DSKSG1	;BRANCH IF NO
	JSR PC,(B)	;RUN START ROUTINE
DSKSG1:	TST (A)+
	BIT #FDSCMS,4(A)
	BNE DBLECH
	MOVB 12(A),B
	BIC #70,B
	CMPB #DREADC,B
	BEQ DSKSG2
	BIT #FDSCMS,(A)
	BNE DBLECH
DSKSG2:	MOV #DSKS,B	;START OF DISK I/O WORDS
	MOV #400,(B)+
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
	.IFNZ MVONLY
	MOV C,-(P)
	MOV D,-(P)
	MOV (A)+,D
	MOV (A)+,C
	ASHC #-8.,C
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	ADD #20000,D
	MOV D,(B)+
	MOV (P)+,D
	MOV (P)+,C
	.IFF
	MOV (A)+,(B)+	;LOW ORDER DISK ADDRESS
	MOV (A)+,(B)+	;HIGH "      "     "
	.ENDC
	TST (A)+	;GO PAST UNUSED WORD
	MOV #DSKS,DSKRUN
	MOVB (A),B
.IIF NZ DSKCHK,	JSR PC,DSKGNR
	MOV B,DSKS	;SET FUNCTION, ENABLE INTERUPT, GO!!
	RTS PC

RKSGO:	MOV DKNRTY,DKRTYS
	MOV A,DSKCRB
	MOV (A),B
	BEQ RKSG1
	JSR PC,(B)
RKSG1:	TST (A)+
	MOV #RKWC,B
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
	MOV (A)+,(B)+	;DISK ADDRESS
	CMP (A)+,(A)+	;UNUSED WORDS
	MOV #RKCS,DSKRUN
	MOVB (A),B
	MOV B,RKCS
	RTS PC

DPROVK:	BIS #100,@DSKRUN
	RTS PC


.IFNZ DSKCHK
DSKGNR:	SPUSH F
	SPUSH E
	SPUSH D
	MOV DSKAE,E	;THE DISK EXTENTION
	BIC #177740,E	;CLEAR ALL BUT THE TRACK EXT.
	MOV DSKWC,F	;THE NUMBER OF WORDS
	NEG F		;MAKE IT POSITIVE
	MOV F,D
	ADD #17,D
	BIC #17,D
	ADD DSKA,D	;THE DISK ADDRESS
	BCC .+4
	INC E
	MOV D,DKSDA	;THIS IS WHAT THE DISK ADRESS SHOULD BE WHEN DONE
	MOV E,DKSAE	;THIS IS WHAT THE TRACK EXT. SHOULD BE
	MOV B,D		;THE DSKS (WITH MEM EXT)
	MOV DSKCA,E	;THE CORE ADDRESS
	BIC #177717,D	;CLEAR ALL BUT THE MEM EXT.
	ASL F		;TURN IT INTO A BYTE INDEX
	BCC .+6		;BRANCH IF IT DIDN'T OVERFLOW
	ADD #20,D	;INC THE MEM EXT
	ADD F,E		;WHAT THE CORE ADDRESS SHOULD BE
	BCC .+6		;DID IT OVERFLOW AGAIN
	ADD #20,D	;INC THE MEM EXT
	MOV D,DKSCS	;SAVE THE MEM EXT
	MOV E,DKSCA	;SAVE THE CORE ADDRESS
	SPOP D
	SPOP E
	SPOP F
	RTS PC		;DONE
.ENDC

;THIS CRETIN ROUTINE TAKES A RANDOM WORD ADDRESSED DISK
;REQUEST AND TRANSFORMS IT INTO SOMETHING THAT A SECTORIZED
;DISK WILL BE HAPPY WITH I.E.
;READING- IF TRANSFER DOES NOT START
;ON A SECTOR BOUNDARY, READ THE NEAREST SECTOR TO THE
;BEGGINING OF THE TRANSFER , THEN COPY THE WORDS NEEDED
;OUT OF A SPECIAL BUFFER, INTO THE USERS BUFFER
;IF THAT DOES NOT FINISH THE TRANSFER, READ THE REST
;OF THE WORDS NORMALLY
;WRITING (BLETCH!) IF TRANSFER DOES NOT START ON SECTOR
;BOUNDARY, READ FIRST SECTOR, COPY WORDS FROM USERS BUFFER
;INTO SPECIAL BUFFER, WRITE OUT THAT SECTOR. IF THAT
;DOESN'T FINISH THE TRANSFER, ROUND THE REQUEST TO
;A WHOLE NUMBER OF SECTORS AND DO A NOORMAL WRITE
;IF THAT DOES NOT FINISH THE TRANSFER, READ IN THE NEXT
;SECTOR, TRANSFER THE WORDS FROM THE USERS BUFFER TO THE
;SPECIAL BUFFER, AND WRITE THE SECTOR BACK OUT.
;THUS, IN THE WORST CASE, A WRITE REQUEST MAY REQUIRE
;2 READS AND 3 WRITES, OR A TOTAL OF 5(COUNT THEM!) TRANSFERS.
DBLECH:	CLR DBLFAK	;INDICATE WE SHOULD NOT FAKE INTERUPT RETURN
	MOV A,DBLASV	;TO MAKE THINGS LOOK RIGHT WHEN WE FINISH
DBLE14:	SPUSH C	;ENTER HERE TO PERFORM PRATIAL SECTOR TRANSFER
	SPUSH D	;AT BEG FOR READ ANN WRITE, AND AT END FOR WRITE(MAYBE)
	MOV #6,D	;FIRST, SAVE AWAY EITHER THE REAL REQUEST
	MOV #DBLPRO+2,B	;OR THE ONE WHICH IS IN PROGRESS
	MOV #DBLDO+2,C
DBLEC1:	MOV (A),(B)+	;THIS IS NOP ON SECOND ENTRY
	MOV (A)+,(C)+
	DEC D
	BNE DBLEC1
	SPOP D
	SPOP C
	BIT #FDSCMS,DBLPDA	;DOES IT BEGIN ON A SECTOR BOUNDARY?
	BNE .+6
	JMP DBLEC2
	BIC #FDSCMS,DBLDDA	;MOVE TO BEG OF SECTOR
DBLE16:	MOV #DSKFOO,DBLDCA	;ENTER HERE IF LESS THAN ONE SECTOR TRANSFER ON WRITE
	MOV #-FDSCSZ,DBLDWC
	MOV #DREADC,DBLDCM	;THIS IS A READ IN ANY CASE
	MOV #DBLDO,A
	MOV #DBLEC3,(A)	;SET UP PLACE TO RETURN
	BR DBLEC9

DBLEC3:	MOV DBLPDA,A	;GET PLACE WE REALLY WANT TO START AT
	BIC #-FDSCSZ,A	;MASK OFF HIGH BITS
	ASL A	;CHANGE TO CORE OFFSET
	ADD #DSKFOO,A	;REAL CORE ADDRESS
	MOV DBLPCA,B	;REAL BUFFER ADDRESS
	SPUSH TEMPAR
	SPUSH TEMPDR
	SPUSH B
	SPUSH A
	MOV DBLPCM,A
	ASH #-4,A
	BIC #177774,A
	ASHC #-6,A
	MOV #77406,TEMPDR
	MOV B,TEMPAR
	SPOP A
	SPOP B
	BIC #177700,B
	ADD #TEMPPG,B
	MOVB DBLPCM,DBLDDE+2
	BIC #70,DBLDDE+2
	CMPB #DREADC,DBLDDE+2
	BEQ DBLEC8	;YES
DBLEC5:	MOV (B)+,(A)+	;FROM REAL BUFFER TO SPECIAL
	INC DBLPDA	;INCREMENT THE DISK ADDRESS WE ARE AT
	BIT #FDSCMS,DBLPDA	;ARE WE AT THE END OF A SECTOR?
	BEQ DBLE10	;YES
	INC DBLPWC	;HAVE WE TRANFERED ALL THE WORDS WE NEED?
	BNE DBLEC5	;NO
	DEC DBLPWC
	BR DBLE10
DBLEC6:	MOV #DWRTEC,DBLDCM	;WRITE OUT THIS SECTOR
	MOV #DBLDO,A
	MOV #DBLEC7,(A)	;PALCE TO RETURN WHEN DONE
DBLEC9:	MOV A,DSKCRB	;THIS KLUDGE FAKES OUT THE WORLD
	TST DBLFAK	;SHOUDL WE FAKE INTERUPT RETURN?
	BNE DBLE20	;YES
	INC DBLFAK	;NO, BUT NEXT TIME
	JMP DSKSG1
DBLE20:	JSR PC,DSKSG1	;BY MAKING LIKE THE DISK IS STILL RUNNING
	TST (P)+	;AND EXITS THE INTERUPT ROUTINE
	SPOP B	;WITHOUT RETURNING TO IT
	SPOP A
	RTT

DBLE15:	MOV A,(B)	;COME HERE FOR A WRITE OF LESS THAN A SECTOR
	CMP #-FDSCSZ,A
	BEQ DBLE19
	BR DBLE16	;BEGINNING ON A SECTOR

DBLE11:
	SPOP TEMPDR
	SPOP TEMPAR
	JSR PC,DBLEC4	;CORRECT DSIK ADDRESS AND WORD COUNT
	BR DBLEC7
DBLE10:
	SPOP TEMPDR
	SPOP TEMPAR
	SPUSH #DBLEC6	;FAKE JSR PC,
DBLEC4:
	SUB #TEMPPG,B
	BIC #77,DBLPCA
	ADD B,DBLPCA
	BCC .+10
	ADD #20,DBLPCM
	TST DBLPDA	;DID WE PRODUCE A CARRY
	BNE .+6	;NO
	INC DBLPDE	;YES, INCREMENT EXTENSION
	INC DBLPWC	;DON'T NEGLECT WORD COUNT
	RTS PC

DBLEC8:	MOV (A)+,(B)+	;COME HERE FOR A READ
	INC DBLPDA
	BIT #FDSCMS,DBLPDA	;DONE WITH THIS SECTOR?
	BEQ DBLE11	;YES, GO MAKE CORRECTIONS
	INC DBLPWC
	BNE DBLEC8
	DEC DBLPWC
	BR DBLE11	;GO MAKE CORRECTIONS

DBLEC7:	TST DBLPWC	;ARE WE DONE?
	BNE DBLEC2	;NO, DO MULTI SECTOR TRANSFER
DBLE18:	MOV DBLASV,A	;REMEMBER HIM?
	CLRB 12(A)
	MOV -(A),B	;ADDRESS OF STOP ROUTINE
	BEQ .+4	;IF NO STOP ROUTINE
	JMP (B)	;LET IT DO THE RTS PC
	RTS PC	;OR WE'LL DO IT IF NONE

DBLEC2:	MOV #DBLPWC,B	;REMAINING WORD COUNT
	CLR A	;LEFTOVERS, IF ANYONE ASKS
	MOVB DBLPCM,DBLDDE+2
	BIC #70,DBLDDE+2
	CMPB #DREADC,DBLDDE+2
	BEQ DBLE17	;THEN THINGS ARE SIMPLE
	MOV (B),A	;IT IS WRITE, GET THE REAL WORD COUNT
	BIC #FDSCMS,(B)	;MAKE IT INTO A WHOLE NUMBER OF SECTORS
	ADD #FDSCSZ,(B)	;LESS ONE SECTOR
	BEQ DBLE15	;LESS THAN ONE SECTOR TO WRITE
	SUB (B),A	;NUMBER OF WORDS LEFTOVER
	CMP #-FDSCSZ,A	;EXACTLY ONE SECTOR?
	BNE DBLE17	;NO
	ADD A,(B)	;A WHOLE NUMBER OF SECTORS
DBLE19:	CLR A	;WITH NO LEFTOVERS
DBLE17:	MOV A,DBLDWC	;SAVE COUNT OF LEFTOVERS
	MOV #DBLE13,-(B)	;PALCE TO RETURN TO
	MOV B,A	;PLACE WHERE REQUEST IS
	BR DBLEC9

DBLE13:	MOV #DBLPWC,A	;ADDRESS OF LEFTOVER COUNT
	SPUSH B
	MOV (A),B
	NEG B
	ASL B
	ADD B,DBLPCA
	BCC .+10
	ADD #20,DBLPCM
	SPOP B
	SUB (A),DBLPDA	;AND DISK ADDRESS
	BCS .+6	;OPISITE OF ADC
	INC DBLPDE
	MOV DBLDWC,(A)	;SETUP FOR REMAINDER
	BEQ DBLE18	;TRANSFER REMAINDER
	JMP DBLE14	;NO REMAINDER
.STITL DISK REQUEST BLOCK GRABBER

SYDRBG:	SPUSH PS	;SAVE OLD PROSSESOR LEVEL
	MOV #340,PS	;LOCK OUT INTERUPTS
	MOV #SYSWPR,A	;LOOK FOR A FREE SYSTEM DISK REQUEST BLOCK
SDRBG1:	TST 14(A)	;IS IT FREE?
	BEQ SDRBG2
	ADD #16,A	;LOOK AT NEXT ONE
	CMP #16*MNUSRS+SYSWPR,A	;ANY MORE?
	BHI SDRBG1	;YES, SEE IF FREE
	SPOP PS	;NO MORE, WE HAVE LOST BIG
	BPT
	BR SYDRBG	;AND CERTAINLY WON'T UNLESS OUR PRIORITY IS <5
SDRBG2:	MOV #400,14(A)	;LABEL BLOCK AS IN USE, BUT NO REQUEST
	SPOP PS	;YOU CAN INTERUPT NOW.
	RTS PC


;USER ROUTINE TO FLUSH UNTIL DISK REQUEST POINTED TO BY A DONE

DSKWAI:	MOV USER,U
	JSR PC,DPROVK
DSKWA1:	TSTB (A)
	BNE DNDONE
	CLR (A)
	JSR PC,RUNME
	RTS PC
DNDONE:	MOV #FRDSKW,FLSRES(U)
	JSR PC,FLUSH
	BR DSKWA1
;GRABS A DISK BLOCK
;DISK BLOCK ADDR RETURNS IN B AND C
UBLKGR:	BIC #DSAMFL,FLAGS2
	MOV #DBITTB,A
	MOV #1,C
	MOV #-1,D
	CLR E
BLKGR1:	BIT C,(A)
	BNE BLKGR3
	INC D
	BGT BLKGR2
	BIS C,(A)
	MOV E,B
	MOV USER,U
	ADD UDSKAD(U),B
	MOV B,DBGRBD
BLKGR2:	CMP #2,D
	BLE BLKGR4
BLKGR3:	INC E
	ASL C
	BNE BLKGR1
	ROL C
	TST (A)+
	CMP #DBITBE,A
	BGE BLKGR1
	BIS #DSAMFL,FLAGS2
BLKGR4:	TST D
	BLT BLKGR5
	RTS PC
BLKGR5:	.BUG.

;FREES THE DISK BLOCK WHOSE LOW ORDER ADDR IS IN C
;BASE OF THIS DISK SPACE IS IN D
;ADDRESS OF THE APPRPRIATE BIT TABLE IS IN E
UBLKFR:	MOV USER,U
UBLKF1:	BIC #DSAMFL,FLAGS2
	SUB UDSKAD(U),C
	MOV #DBITTB,E
	MOV C,B
	BIC #177770,B
	ASR C
	ASR C
	ASR C
	ADD C,E
	BICB BMT(B),(E)
UBLKF2:	RTS PC

LCGRAB:	MOV USER,U
	CMP U,(D)
	BEQ LCGRA1
LCGRA2:	TST (D)
	BLT LCGRA1
	JSR PC,FLUSH
	BR LCGRA2
LCGRA1:	MOV U,(D)
	JSR PC,RUNME
	RTS PC

LCUGRB:	CMP USER,(D)
	BNE .+6
	MOV #-1,(D)
	SEZ
	RTS PC	.STITL DISK INTERUPT ROUTINE

DSKBRK:	SPUSH A
	SPUSH B
	MOV DSKS,A	;GET STATUS REGISTER
	TST A
	BLT DSKLOS

.IFNZ DSKCHK
DSKCK:	TST DSKCRB
	BNE .+4
	BR DSKBR9
	SPUSH D
	SPUSH E
	BIT #1,DKSCA	;IS THE CORE ADDRESS CORRECT
	BNE DSKCRT
	CMP DSKCA,DKSCA	;IS THE CORE ADDRESS THE SAME
	BNE BADCK	;NO
	CMP DSKA,DKSDA	;IS THE DISK ADDRESS THE SAME
	BNE BADCK	;NO
	MOV DKSAE,D	;THE THE SUPPOSED DISK EXTENSION
	MOV DSKAE,E	;GET THE ACTUAL
	XOR E,D	;CLEAR THE BITS THAT ARE THE SAME
	BIT #37,D	;THE EXTENSION BITS
	BNE BADCK	;SOME BITS WERE DIFFERENT
	MOV DKSCS,D	;GET THE SUPPOSED CORE EXTENSION
	MOV DSKS,E	;GET THE ACTUAL VALUES
	XOR E,D		;CLEAR THE BITS THAT ARE THE SAME
	BIT #60,D	;ARE THE BITS DIFFERENT
	BNE BADCK
DSKCRT:	SPOP E
	SPOP D
	BR DSKBR9
BADCK:	MOV #DSKS,E	;THIS IS A DBUGGING FEATURE
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	JSR F,ACSAV
	JSR A,SPRINT
	MOV #DKEPR,F
DKEPLP:	MOV (F),A
	BEQ EDKEPR
	JSR PC,PRONL
	PRTXT ^\/ IS \
	MOV @(F)+,A
	JSR PC,PRONL
	PRTXT ^/ SB /
	MOV @(F)+,A
	JSR PC,PRONL
	PRCR
	BR DKEPLP
EDKEPR:	SPREND
	JSR F,ACRES
	TST DEBSW
	BEQ .+4
	240
	ADD #14,P
	SPOP E
	SPOP D
	BR DSKLOS
.ENDC

DSKBR9:	MOV #400,DSKS
DSKBR2:	MOV DSKCRB,A	;POINTER TO FUNCTION WORD
	BEQ DSKBR1
	MOV (A),B
	BEQ .+4	;NO
	JSR PC,(B)	;YES, GO DO IT
	MOV DSKCRB,A
	CLR DSKCRB
	CLRB 14(A)	;REQUEST HAS BEEN SERVICED
DSKBR1:	JSR PC,DSKSRT	;LOOK FOR SOMETHING ELSE TO DO
DSKRET:	SPOP B
	SPOP A
	RTT

DSKLOS:	INC NRFERS
	BIT #40000,A	;IS IT FROZEN?
	BNE DSKLS1	;YES
	BIT #26000,A	;IS IT ONE OF WRITE CHECK, NED OR WRITE LOCKOUT?
	BEQ DSKRTY	;NO, MEANS IT IS ADDRESS PARITY OR
DKLOSE:	MOV #DKWLST,B
	JSR PC,PLOCS	;PRINT CONTENTS OF FOLLOWING ON SYS CONSOLE
			;DSKS
			;DSKAE
			;0
	HALT	;BIT THE BAG
	BR DSKRT1
DSKLS1:	BIT #2000,DSKAE	;NXM?
	BNE DKLOSE	;YES
DSKRTY:	INC DKRTYS	;HAVE WE BEEN THROUGH THIS BEFORE?
	BGE DKLOSE	;YES, TOO MANY TIMES
DSKRT1:	MOV #400,DSKS	;POWER CLEAR THE DISK
	MOV DSKCRB,A	;RETRY THE LAST OPERATION
	JSR PC,DSKSG1
	BR DSKRET

RKBRK:	SPUSH A
	SPUSH B
	MOV RKCS,A
	TST A
	BLT RKLOS
	CLR RKCS
	BR DSKBR2
RKLOS:	INC NRKERS
	BIT #66340,RKER	;BAD ERROR?
	BEQ RKSOFT
RKLOST:	MOV #RKWLST,B
	JSR PC,PLOCS	;PRINT FOLLOWING LOCS ON SYS CONSOLE
			;RKDS
			;RKER
			;RKCS
			;0
	HALT
	BR RKRT1
RKSOFT:	INC DKRTYS
	BGE RKLOST
RKRT1:	MOV #1,RKCS
	TSTB RKCS
	BGE .-4
	MOV DSKCRB,A
	JSR PC,RKSG1
	BR DSKRET
;	PUSH F
;	SPUSH ADDR
;	JSR PC,LSH7
;CONVERTS SECTOR ADDR IN D TO WORD ADDR IN ADDR AND ADDR+2
;D STAYS INTACT (AS OPPOSED TO PREVIOUS VERSION)
LSH7:	MOV P,F		;POINT F AT PUSHED ADDR
	TST (F)+	;(SKIP PUSHED PC)
	SPUSH D
	SPUSH A
	SPUSH C
	CLR C		;EXTEND SECTOR ADDR
	ASHC #7,C	;SHIFT 7 PLACES
	MOV (F)+,A	;ADDRESS TO PUT RESULT
	MOV D,(A)+	;LOW ORDER
	MOV C,(A)	;HIGH ORDER
	SPOP C
	SPOP A
	SPOP D
	SPOP F		;RETURN ADDRESS TO F
	TST (P)+	;POP ADDR
	RTS F		;RETURN, RESTORING F
;SPUSH #(ADDR OF 3-WORD BLOCK)
;JSR PC,DSKSEC
;	3-WORD BLOCK:
;POINTER TO CORE ADDRESS
;POINTER TO DISK SECTOR ADDRESS
;READ OR WRITE COMMAND
;	USES 4 WORDS ON PDL;
;	IF THIS INCREASES CHECK PPUSHL.
DSKSEC:	SPUSH E
	MOV 4(P),E	;E POINTS TO FIRST WORD OF 3-WD BLOCK
	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-200,(A)+	;ALWAYS THIS LONG
	MOV @(E)+,D
	SPUSH B
	SPUSH F
	MOV USER,F
	MOV SLOTAS(F),F
	MOV SLOTHA(F),B
	SUB #PURE,D
	ADD SLOTCA(F),D
	ADC B
	MOV D,(A)+
	ASH #4,B
	BIS B,6(A)
	SPOP F
	SPOP B
	MOV @(E)+,D	;DISK ADDRESS
	BIT #160000,D	;IS IT THE FIXED HEAD DISK?
	BNE DSKSC1	;NO
	SPUSH F
	SPUSH A		;PLACE TO PUT WORDED DISK ADDR
	JSR PC, LSH7
	ADD #4,A
	BR DSKSC3
DSKSC1:	SUB #20000,D	;MAKE IT INTO A REAL MOVING DISK ADDR
	SPUSH D
	BIC #17777,(SP)
	BIC #160000,D
	SPUSH C
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	SPOP C
	ADD (SP)+,D
	MOV D,(A)+
	MOV #-1,(A)+	;THIS IS A MOVING HEAD REQUEST
DSKSC3:
	TST (A)+
	BISB (E),(A)	;ENTER REQUEST BYTE
	JSR PC,DSKWAI	;WAIT FOR COMPLETION
	SPOP E
	SPOP (P)
	RTS PC
	.STITL NEW FILING

;USER PRIMITIVE ROUTINES

;DIRSET TAKES A LIST AND SETS THE CURRENT DIRECTORY

DSET:	JSR PC,SETNM	;GET NAME OF DIRECTORY
	BNE DSET1	;INPUT IS A LIST
SETDEF:	MOV DEFDIR,CURDIR	;SET CURRENT DIRECTORY
	MOV DEFDSK,WCHDSK	;WHICH DISK?
	RTS PC
DSET1:	JSR PC,SETDEF
DIRSET:	JSR PC,GNWRD	;GET A WORD FROM THE LIST
	BNE .+4		;ANY LEFT?
	RTS PC		;NONE LEFT, DONE
	JSR PC,DIRGET	;GET NEXT ITEM FROM LIST
	BR DIRSET	;AND CONTINUE WITH THE NEXT NAME


DIRGET:	MOV #NAME,E	;PLACE TO STORE THE NAME
	JSR PC,NFNGET	;GET A FILE NAME
	MOV #NAME,E
	CMPB #'^+200,(E)	;IS IT ^?
	BNE DIRGT1	;NOPE
	MOV CURDIR,E	;POINTER TO CURRENT DIRECTORY
	JSR PC,DBREAD	;SET DISK FOR READING
	MOV #DBUF,ENTBEG	;SET ADDRESS OF START OF ENTRY
	BR DIRGT9
DIRGT1:	TSTB (E)	;HAVE WE PASSED LAST CHAR OF NAME?
	BLT DIRGT2	;YES
	TSTB (E)+	;NO, FIND IT
	BGE .-2
	CMPB #';+200,-(E)	;IS THIS THE ROOT DIRECTORY?
	BNE UDREAD	;NO, SET UP DISK BLOCK FOR READ
	BISB #200,-(E)	;YES, SET CODE FOR FILE
	MOV #NDISKS,D	;NO. OF DISKS
	CLR A
DIRGT3:	MOV FDNAMP(A),B	;B NOW POINTS TO ADDRESS FOR NAME
	MOV #NAME,E
	TST DBITAD(A)	;BLOCK NO. OF BIT TABLE
	BLT DIRGT4	;NOT HERE- TRY OTHER DISK
DIRGT6:	CMPB (E)+,(B)	;COMPARE CHARACTERS OF NAME
	BNE DIRGT4	;MISMATCH
	TSTB (B)+	;ANY MORE CHARACTERS?
	BGE DIRGT6	;YES
	MOV A,WCHDSK	;SET DISK
	BR DIRGT8
DIRGT4:	TST (A)+	;NEXT DISK
	SOB D,DIRGT3	;TRY AGAIN
	ERROR+BDD	;NO MORE- BAD DIRECTORY
DIRGT2:	CMPB #';+200,(E)	;ROOT DIRECTORY?
	BNE UDREAD	;NO, A USER'S DIRECTORY
DIRGT8:	MOV #46,CURDIR	;YES, SET IT AS CURRENT DIRECTORY
	RTS PC
UDREAD:	MOV #NAME,E
	JSR PC,DIRSER	;LOOK FOR THAT NAME
	BNE .+4		;FIND IT?
	ERROR+NED	;NON EXISTENT DIRECTORY
DRREAD:	MOVB @ENTBEG,A	;GET TYPE OF ENTRY FOUND
	BIC #177477,A	;FLUSH EVERYTING BUT TYPE
	CMP #300,A	;IS IT A DIRECTORY?
	BEQ .+4
	ERROR+ENDR	;ENTRY NOT A DIRECTORY
DIRGT9:	JSR PC,DESSET	;SET UP NEW DIRECTORY
	MOV DSKADR,CURDIR	;AND MAKE THIS THE CURRENT DIRECTORY
	RTS PC
.DIRSET:
	BIT #7777,@S	;CHECK NAME OF DIRECTORY ON S-PDL
	BNE .DIRS1
	SPOPS A		;NOTHING TO DO
	SEZ
	RTS PC
.DIRS1:	JSR PC,DSET	;SET THE DIRECTORY
	JSR PC,DIRGET	;SET UP FILES
USEENT:	MOV CURDIR,DEFDIR	;THIS IS NOW DEFAULT DIRECTORY
	MOV WCHDSK,DEFDSK	;THIS IS NOW DEFAULT DISK
	SEZ
	RTS PC
.USE:	MOV WCHDSK,E	;CURRENT DISK
	MOV FDUSEA(E),CURDIR
	JSR PC,SETNM	;GET THE DIRECTORY NAME
	BNE .USE1	;INPUT IS A LIST (MORE TO COME)
.USE3:	MOV #NAME,E	;POINTER TO  NAME
	JSR PC,NFNGET	;GET THE NAME
.USE4:	MOV #NAME,E
	JSR PC,DIRSER	;LOOK FOR THE SUB-DIRECTORY
	BNE .USE2	;FOUND IT
	ERROR+NED	;NON-EXISTENT DIRECTORY
.USE2:	JSR PC,DRREAD	;MAKE SURE THIS IS A LEGIT. DIRECTORY
	BR USEENT	;SET NEW DISK AND DIRECTORY DEFAULTS
.USE1:	JSR PC,DIRSET	;MORE DIRECTORIES?
	BR .USE3	;SAME THING AGAIN
LOGIN:	MOV @S,A	;GET USER NAME OFF S-PDL
	SPUSHS A	;PUSH A COPY OF IT
	JSR PC,.USE	;SET DIRECTORY(IES)
	MOV USER,E	;ADDRESS OF USER TABLE
	ADD #UNAME,E	;ADDRESS OF CURRENT USER NAME
	JSR PC,NFNGET	;GET THE NAME
	MOV #NAME+4,E
	MOV #"IT+100000,-(E)	;SET FILE NAME "INIT"
	MOV #"IN,-(E)
	JSR PC,DIRSER	;IS IT THERE?
	BEQ LOGIN2	;NOPE, LOOK FOR MAIL
	JSR PC,GETFI1	;GET THE FILE AND CHECK ITS TYPE
	CMP #200,A	;IS IT A CASE OF MISTAKEN IDENTITY?
	BNE LOGIN2	;YES, INDEED
	JSR PC,.REDF4	;READ THE FILE
	JSR PC,.READ1
LOGIN2:	MOV #NAME+4,E	;SET UP NAME OF MAIL ENTRY
	MOV #"IL+100000,-(E)
	MOV #"MA,-(E)
	JSR PC,DIRSER	;IS THERE ANY MAIL?
	BEQ LOGIN1	;NO
	JSR PC,GETFI1	;GET A COPY OF THE NAME AND CHECK IT
	CMP #200,A	;ONCE AGAIN, MAKE SURE ITS A FILE
	BNE LOGIN1	;IT'S NOT, WE'RE THROUGH
LANGC	<PRTXT ^/PRINT MAIL?/>,<
	PRTXT ^/COURIER A IMPRIMER?/>
	JSR PC,QUEST	;GET THE REPLY
	BNE LOGIN1	;DOESN'T WANT IT- WE'RE THROUGH
	JSR PC,.REDF4	;READ THE MAIL FILE (ISN'T THIS A CRIME?)
	JSR PC,.POF1	;PRINT IT
LANGC	<PRTXT ^/DELETE MAIL?/>,<
	PRTXT ^/MESSAGE RECU?/>
	JSR PC,QUEST	;GET THE REPLY
	BNE LOGIN1	;LEAVE THE MAIL
	JSR PC,GCDIR	;GET THE FILE
	JSR PC,.DELT5	;DELETE IT
LOGIN1:	SEZ
	RTS PC		

.DELETE:
	MOV #WDIRSW,D	;LOCK WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB
	JSR PC,GETFIL	;GET THE ENTRY
	CMP #200,A	;IS IT A FILE?
	BEQ .+4		;IF YES, OK
	ERROR+CDE	;CAN'T DELETE THAT ENTRY
	CMP #46,CURDIR	;IS IT THE ROOT DIRECTORY?
	BNE .+6		;NO
	JSR PC,CKSST	;CHECK SYSTEM STATUS
.DELT5:	JSR PC,DESSET	;SET THE DESCRIPTOR
	JSR PC,.DELT3	;FREE THE BLOCK
	JSR PC,DELENT	;DELETE THE ENTRY
	JSR PC,WBITS	;WRITE BIT TABLE ONTO DISK
	MOV #WDIRSW,D	;WE'RE DONE, FREE THE WORLD UP
	JMP LCUGRB
WDELBL:	JSR PC,DESINC
.DELBL:	JSR PC,DESST	;SET UP DESCRIPTOR
	CLR FILFLG
.DELT3:	BIT #4000,DESSAV  ;IS THIS A SHARED BLOCK?
	BNE .DELT2	;YES, DON'T DELETE IT
	MOV DSKADR,A	;ADDRESS OF THE BLOCK
	TST DEOFBL	;ARE WE BEYOND THE LAST BLOCK?
	BGT .DELT2	;YES
	MOV WCHDSK,B	;NO, SET THE DISK
	INC NBLKFR(B)	;ADDRESS OF NEXT BLOCK
	JSR PC,BITGET	;GET THE APPROPRIATE BIT
	BICB BMT(B),(C)	;FREE THE BLOCK
	JSR PC,GNBLK	;GET THE NEXT BLOCK ADDRESS
	BR .DELT3
.DELT2:	RTS PC
DELENT:	MOV @ENTBEG,A	;GET FIRST WORD
	BIC #177700,A	;LENGTH OF ENTRY IN WORDS
	ASL A		;NOW IN BYTES
	MOV #DBUF+1776,D	;HOPEFULLY, THE NUMBER OF FREE BYTES
	ADD A,(D)	;CORRECT IT
	MOV ENTBEG,B	;BEGINNING OF ENTRY TO FLUSH
	MOV B,C
	ADD A,C		;BEGGINING OF NEXT ENTRY
	SUB (D),D	;END OF USEFUL INFORMATION
.DELT4:	MOV (C)+,(B)+	;COPY USEFUL STUFF OVER USELESS
	CMP B,D		;DONE?
	BLE .DELT4
	MOV (C)+,(B)+	;MAKE SURE
	MOV CURDIR,E	;WRITE OUT THE DIRECTORY
	JSR PC,DBWRTE
	RTS PC
MAIL:	SPUSH DEFDIR	;SAVE DEFAULT DIRECTORY
	SPUSH DEFDSK	;SAVE DEFAULT DISK
	JSR PC,.USE	;SET DIRECTORY TREE
	SPOP DEFDSK
	SPOP DEFDIR
	MOV #"MA,NAME	;SET ENTRY NAME TO "MAIL"
	MOV #"IL+100000,NAME+2
	JSR PC,.OPNA3	;OPEN MAIL FILE
	MOV #.WRTEC,PCHR	;CHARS. IN BUFFER INTO OUTPUT DEVICE
	PRTXTC ^/------/
LANGC	<PRTXT ^/MAIL FROM />,<
	PRTXT ^/EN PROVENANCE DE />
	MOV USER,A
	ADD #UNAME,A	;USER WHO SENT MAIL
	JSR PC,POIHD2	;PRINT THE NAME
	JSR PC,.CRLF	;CARRIAGE RETURN, LINEFEED
	JSR PC,UDATEG	;SET THE DATE
	SPUSH #1
	JSR PC,PRINT	;PRINT THE DATE
	JSR PC,.SPACE
	JSR PC,UTIMEG	;SET THE TIME
	SPUSH #1
	JSR PC,PRINT	;PRINT THE TIME
	SPUSH PRMTCH	;SAVE NORMAL PROMPT CHARACTER
	MOV #'_,PRMTCH	;NEW ONE IS "_"
	MOV #TYO,PCHR
MAIL2:	JSR PC,RDSTR	;READ A STRING
	BEQ MAIL3	;NO CHARACTERS TYPED
	MOV @S,B	;POINTER TO STRING
	JSR PC,.LOADB	;FIRST CHARACTER
	CMP #'.,B	;IS IT A PERIOD?
	BEQ MAIL1	;YES (NO MORE INPUT)
	JSR PC,.FILEP
	BR MAIL2
MAIL1:	SPOP PRMTCH	;GET BACK OLD PRMTCH ("?")
	MOV #.WRTEC,PCHR
	SPOPS A
	PRTXTC ^/------/
	MOV #TYO,PCHR
	JMP .WRTCL
MAIL3:	BIT #RBRKF,TFLAGS
	BEQ MAIL2
	MOV USER,U
	CLR BRAKE(U)
	JSR PC,BRAKR	;ALLOW TYPING
	PRTXTC ^/BREAK/
	BR MAIL2

.READ:	JSR PC,.READF
.READ1:	MOV #.READCH,GCHR
	MOV PC,REDFLG
	JSR PC,SAVEVL
	.IF NE WADESW
	PUSH #0	;NO. OF ARGS
	JSR PC,SAVPPS
	BIS #DORF,FLAGS
	BIS #1,CPDLP
	.ENDC
RMLOOP:	CMP #TYI,GCHR
	BEQ RMLOO1
	JSR PC,RDSTR
	BEQ RMLOO2
	JSR PC,READ
	BEQ RMLOOP	;NO TOKENS
	JSR PC,EVLINE
	BEQ RMWDW
	POPS A
	BR RMLOOP
RMWDW:	ERROR+WDW
RMLOO1:	TST TOPRNM	;DONE, PROC DEF PENDING?
	BEQ .+6
	JSR PC,END
	MOV #RET,PSTOPR
	.IF NE WADESW
	JSR PC,RESPPS
	POP B
	.ENDC
	JSR PC,RESEVL
	MOV B,FLAGS
	MOV CTP,C
	CLR D
	JMP PSTOP6
RMLOO2:	BIT #RBRKF,TFLAGS
	BEQ .+4
	ERROR+BRK
	CMP #TYI,GCHR
	BEQ RMLOO1
	BR RMLOOP

.WRITE:	JSR PC,.WRTEF
	MOV #.WRTEC,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	BR .+2
	CLR WRTFLG
	JSR PC,.WRTCL
	MOV #TYO,PCHR
	SEZ
	RTS PC

.READF:.OPENR:	JSR PC,GETFIL	;FIND THE ENTRY
.REDF5:	CMP #200,A	;IS IT A FILE?
	BEQ .+4		;YES
	ERROR+CRE	;CAN'T READ THAT ENTRY
.REDF4:	JSR PC,DESSET	;SET THE DESCRIPTOR
	MOV #1,FILFLG	;SET THE OPEN FILE FLAG FOR READ
.REDF1:	MOV #-1,A
	TST DEOFBL	;IS THIS THE LAST BLOCK OF FILE
	BGT .REDF2	;YES
	MOV DSKADR,E	;CURRENT SECTOR FOR THIS FILE
	JSR PC,DBREAD	;SET DISK FOR READING
	MOV #2000,A	;LENGTH OF BLOCK
	TST DEOFBL	;IS THIS THE LAST BLOCK OF FILE?
	BNE .REDF2	;YES, RETURN
	BITB #40,DESSAV+1	;IS LAST WORD OF BLOCK USED?
	BEQ .REDF3	;YES
	SUB DBUF+1776,A	;NUMBER OF BYTES USED
	BR .REDF2
.REDF3:	BITB #20,DESSAV+1	;IS LAST BYTE OF BLOCK USED?
	BEQ .REDF2	;YES
	DEC A		;NO,ONE LESS BYTE IS USED
.REDF2:	MOV A,DSKNCH	;NUMBER OF CHARACTERS IN DISK BUFFER
	SEZ
	RTS PC

;READ A CHARACTER
.READC:	TST FILFLG	;IS FILE OPEN FOR READING?
	BLE .REDC1	;NO
	TST DEOFBL	;LAST BLOCK OF FILE?
	BGT .REDC1	;YES
	TST DSKNCH	;ARE THERE ANY CHARS?
	BNE .REDC3	;YES
	JSR PC,.REDC3	;GET THE NEXT BLOCK IF IT EXISTS
	BR .READC	;GO CHECK IT OUT
.REDC3:	MOVB @DBUFPT,D	;CHARACTER POINTED TO BY DISK BUFFER POINTER
	INC DBUFPT	;NEXT CHARACTER
	DEC DSKNCH	;ONE LESS CHARACTER IN BUFFER
	BGT .REDC2	;ANY MORE CHARACTERS?
	JSR F,ACSAV	;SAVE REGISTERS
	JSR PC,GNBLK	;GET NEXT BLOCK
	JSR PC,.REDF1	;READ THE FILE
	JSR F,ACRES	;RESTORE REGISTERS
	RTS PC
.REDC1:	CLR FILFLG	;CLEAR FILE FLAG
	CLR REDFLG	;CLEAR READ FLAG
	CLR DSKNCH	;NO MORE CHARACTERS IN BUFFER
	MOV #EOFCHR,D	;D POINTS TO LAST CHARACTER OF FILE
.REDC2:	RTS PC
.OPENA:	JSR PC,DSET	;SETS DIRECTORY
	MOV #NAME,E	;NAME OF FILE
	JSR PC,NFNGET	;SET FILE NAME
.OPNA3:	MOV #NAME,E
	JSR PC,DIRSER	;FIND THE FILE
	.IFZ <ENG&FR>
	BEQ .WRTF2	;NOT HERE, WRITE A NEW ONE
	.IFF
	BNE .+6
	JMP .WRTF2
	.ENDC
	MOV @ENTBEG,A	;FOUND IT, THIS IS START OF  NTRY
	BIC #177477,A	;FLUSH ALL BUT TYPE
	CMP #200,A	;MAKE SURE IT'S A FILE
	BEQ .+4		;OK
	ERROR+CRE	;NOPE, CAN'T READ THAT ENTRY
	JSR PC,DESSET	;SET THE DESCRIPTOR
	JSR PC,DELENT	;FLUSH THE OLD ENTRY
.OPNA2:	JSR PC,.REDF1	;READ FILE INTO BUFFER
	TST DEOFBL	;ANY MORE BLOCKS LEFT?
	BGE .OPNA1	;NO
	JSR PC,GNBLK	;YES, GET ADDRESS OF  NEXT ONE
	BR .OPNA2	;READ IN NEXT BLOCK
.OPNA1:	MOV DSKADR,LBLKAD	;SAVE LAST BLOCK ADDRESS
	MOV DSKADR,DBGOT	;BACK POINTER TO START OF LAST BLOCK
	BIC #177477,DESSAV
	MOV CURDIR,WRTDIR	;SET CURRENT DIRECTORY TO BE WRITTEN
	MOV #2000,A	;START OF NEW BLOCK
	SUB DSKNCH,A	;GET AMOUNT OF FREE SPACE IN CURRENT BLOCK
	BEQ .WRTF1	;NONE LEFT
	ADD DSKNCH,DBUFPT	;BUFFER POINTER SET TO FIRST FREE BYTE
	MOV A,DSKNCH	;NEW NUMBER OF CHARACTERS IN BUFFER
	MOV #-1,FILFLG	;SET OPEN FILE FLAG FOR WRITE
	SEZ
	RTS PC
QUEST:	MOV USER,U	;SETS USER
	MOV UTTY(U),E	;USER TELETYPE NUMBER
	BIS #TIMAGI,TTYST(E)	;TTY STATUS TO INPUT IMAGE MODE
	BIC #TILIPM,TTYST(E)	;CLEAR LINE INPUT MODE
	JSR PC,GTYI	;GET THE CHARACTER
	SPUSH D		;SAVE IT
	JSR PC,.CRLF	;PRINT CR AND LINEFEED
	SPOP D		;GET CHARACTER
.IFNZ FR
	CMP #'O,D
	BEQ QUEST1
	CMP #'O+40,D
	BEQ QUEST1
.ENDC
.IFNZ ENG
	CMP #'Y,D	;IS IT "Y"?
	BEQ QUEST1
	CMP #'Y+40,D	;IS IT SMALL Y
.ENDC
QUEST1:	RTS PC

.WRTEF:.OPENW:	JSR PC,DSET	;SET DIRECTORY
	MOV #NAME,E	;GET ENTRY NAME
	JSR PC,NFNGET	;SET IT
	MOV #NAME,E
	JSR PC,DIRSER	;LOOK FOR ENTRY NAME
	BEQ .WRTF2	;NOT HERE
LANGC	<PRTXT ^/FILE ALREADY EXISTS.  DELETE IT?/>,<
	PRTXT ^/FICHIER DEJA EXISTANT. A DETRUIRE?/>
	JSR PC,QUEST	;GET REPLY
	BEQ .+4		;OK, DELETE IT
	ERROR+EAES	;ENTRY ALREADY EXISTS
	JSR PC,.DELT5	;DELETE OLD ENTRY
.WRTF2:	MOV #200,DESSAV	;SET DESCRIPTOR TO TYPE FILE
	JSR PC,DESWST	;SET DESCRIPTOR MODE FOR DISK HACKING
.WRTF1:	JSR PC,DBGET	;GET THE RIGHT DISK BLOCK
	MOV #2000,DSKNCH	;LENGTH OF BLOCK
	MOV #DBUF,DBUFPT	;PTR TO START OF DISK BUFFER
	MOV #-1,FILFLG		;SET OPEN FILE FLAG FOR WRITE
	MOV CURDIR,WRTDIR	;CURRENT DIRECTORY BEING WRITTEN
	SEZ
	RTS PC

.WRTEC:	DEC DSKNCH	;ONE LESS CHARACTER IN BUFFER
	BLT .WRTC1	;NO MORE LEFT
	MOVB D,@DBUFPT	;CURRENT CHARACTER INTO BUFFER
	INC DBUFPT	;POINTER TO NEXT BYTE
	RTS PC
.WRTC1:	JSR F,ACSAV	;SAVE REGISTERS
	MOV DBGOT,E	;BACK POINTER TO START OF BLOCK
	JSR PC,DBWRTE	;SET DISK BLOCK FOR WRITING
	JSR PC,.WRTF1	;GET THE BLOCK AND SET ALL THE VARIABLES
	JSR F,ACRES	;RESTORE THE REGISTERS
	BR .WRTEC

.WRTCL:	MOV DSKNCH,A	;NO. OF CHARACTERS IN BUFFER
	BEQ .WRCL1	;NO MORE LEFT
	CMP #1,A	;IS THERE JUST 1 LEFT?
	BEQ .WRCL2	;YES
	MOV A,DBUF+1776	;LAST WORD OF BLOCK HAS NO. OF CHARS USED
	BISB #40,DESSAV+1
.WRCL1:	MOV DBGOT,E	;BACK PTR TO START OF BLOCK
	JSR PC,DBWRTE	;SET BLOCK FOR WRITING
	MOV #WDIRSW,D	;LOCK IN WRITE SWITCH
	JSR PC,LCGRAB	;RUN THE DISK REQUEST
	MOV WRTDIR,CURDIR	;CURRENT DIR HAS BEEN WRITTEN
	JSR PC,DESINS	;INSERT DESCRIPTOR
	JSR PC,WBITS	;WRITE BIT TABLE ONTO DISK
	CLR FILFLG	;CLEAR FILE FLAG
	MOV #WDIRSW,D	;LOCK IN WRITE SWITCH
	JMP LCUGRB
.WRCL2:	BISB #20,DESSAV+1
	BR .WRCL1

.DELI:	MOV #WDIRSW,D	;LOCK IN WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB	;RUN THE DISK REQUEST
	JSR PC,GETFIL	;GET THE ENTRY
	CMP #300,A	;IS IT AN INDEX?
	BEQ .+4		;YES
.DELI1:	ERROR+CDE	; CAN'T DELETE THAT ENTRY
	JSR PC,DESSET	;SET THE DESCRIPTOR
	MOV DSKADR,E	;CURRENT SECTOR FOR FILE
	JSR PC,DBREAD	;SET THE BLOCK FOR READING
	MOV #DBUF,A	;POINTER TO DISK BUFFER
	MOV (A),B	;FIRST WORD OF BUFFER
	BIC #177700,B	;LENGTH OF ENTRY IN WORDS
	ASL B		;NOW IN BYTES
	ADD B,A		;SUPPOSED END OF ENTRY
	TST (A)		;IS SOMETHING THERE?
	BNE .DELI1	;OOPS!
	MOV CURDIR,E	;ADRESS OF CURRENT DIRECTORY
	JSR PC,DBREAD	;HACK BLOCK AT THIS ADDRESS FOR READ
	JMP .DELT5

.FILEP:	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT .+4		;YES
	ERROR+IFN	;NO, INVALID FILE NAME
	SPUSH PCHR
	MOV #.WRTEC,PCHR
	SPUSH #1
	JSR PC,PRINT	;PRINT THE CHARACTERS
.FILP1:	SPOP PCHR
	SEZ
	RTS PC

.FILER:	TST FILFLG	;IS FILE OPEN FOR READ?
	BGT .+4		;YES
	ERROR+IFN	;NO,INVALID FILE NAME
	SPUSH GCHR
	MOV #.READC,GCHR
	JSR PC,RQUEST
	SPOP GCHR
	CLZ
	RTS PC

.CLOSF:	MOV #TYI,GCHR	;RESET IT FOR TTY INPUT
	CLR REDFLG	;CLEAR READFLAG
	CLR WRTFLG	;CLEAR WRITE FLAG
	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT .WRTCL
	CLR FILFLG	;CLEAR FILE FLAG
	RTS PC

GETFIL:	JSR PC,DSET	;SET THE DIRECTORY
	MOV #NAME,E
	JSR PC,NFNGET	;WHAT FILE?
GETFI1:	MOV #NAME,E
	JSR PC,DIRSER	;FIND THE FILE
	BNE .+4		;FOUND IT
	ERROR+FNF	;FILE NOT FOUND
	MOV @ENTBEG,A	;WHAT TYPE OF ENTRY
	BIC #177477,A	;FLUSH ALL BUT TYPE
	RTS PC

.IFNZ AI
.XOR:	JSR PC,CKSST	;CHECK STATUS
	JSR PC,G1NARG	;GET AN ARGUMENT
	MOV B,XORF	;SET THE XOR FLAG
	RTS PC
.ENDC

.POI:	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO
	CLR DBGOT
	JSR PC,SETDEF	;SET DEFAULT DISK AND DIRECTORY
	JSR PC,GCDIR	;GET THE DIRECTORY
	MOV #DBUF,ENTBEG   ;ENTRY AT START OF DISK BUFFER
.POI1:	MOV @ENTBEG,A	;FIRST WORD OF ENTRY
	BEQ .POI3	;NO MORE ENTRIES BELOW THIS INDEX
	BIC #177477,A
	ASH #-5,A	;WHAT TYPE OF ENTRY?
	JSR PC,@POITAB(A)	;SERVICE THAT TYPE
.POI2:	MOV @ENTBEG,A
	BIC #177700,A	;LENGTH OF ENTRY IN WORDS
	ASL A		;NOW IN BYTES
	ADD A,ENTBEG	;START OF NEXT ENTRY
	BR .POI1

POIHED:	JSR PC,POFNM	;PRINT OUT HEADING
	JMP .CRLF	;CARRIAGE RETURN, LINEFEED
POILNK:	.BUG.		;NOT IMPLEMENTED
POIFLE:	SPACE		;INDENT TWO SPACES
	SPACE
	JSR PC,POFNM	;PRINT OUT FILE NAME
	SPACE
	JSR PC,DESSET	;SET DESCRIPTOR
	CLR -(P)	;HOLDS NUMBER OF BLOCKS OF CURRENT FILE
POIFL2:	TST DEOFBL	;LAST BLOCK OF FILE?
	BGT POIFL1	;YES
	INC (P)		;NO, INCREMENT NO. OF BLOCKS USED
	JSR PC,GNBLK	;GET ADDRESS OF NEXT BLOCK
	BR POIFL2	;CHECK AGAIN
POIFL1:	SPOP A		;NO. OF BLOCKS USED
	ADD A,DBGOT	;PTR TO LAST BLOCK OF ENTRY
	JSR PC,PRDN	;PRINT NO. OF BLOCKS USED BY FILE
	JMP .CRLF
POIDIR:	INC DBGOT	;NEXT BLOCK
	MOV #'I,D
	JSR PC,TYO	;PRINT "I" TO INDICATE INDEX
	SPACE
	BR POIHED	;PRINT OUT HEADING
.POI3:	MOV DBGOT,A	;TOTAL NUMBER OF BLOCKS USED
	JSR PC,PRDN
LANGC	<PRTXTC ^/ BLOCKS./>,<
	PRTXTC ^/ BLOCS./>
	MOV WCHDSK,A
	MOV NBLKFR(A),A	 ;NO. OF FREE BLOCKS
	JSR PC,PRDN
LANGC	<PRTXTC ^/ FREE BLOCKS./>,<
	PRTXTC ^/ BLOCS LIBRES./>
	SEZ
	RTS PC
POFNM:	MOV ENTBEG,A
	TST (A)+	;SKIP FIRST WORD OF ENTRY
POIHD2:	MOVB (A)+,D	;CHAR. OF FILE NAME
	BLT POIHD1	;NO MORE CHARACTERS
	JSR PC,@PCHR	;PRINT THE CHARACTER
	BR POIHD2	;LOOK FOR NEXT ONE
POIHD1:	JSR PC,@PCHR	;LAST CHARACTER
	RTS PC
POTHED:	CMP CURDIR,DEFDIR	
	BEQ POIHED	;PRINT OUT CURRENT DIRECTORY NAME
	RTS PC		;RETURN IF NOT THE SAME
.POTREE:
	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO	;FILE ALREADY OPEN
	CLR DBGOT
	JSR PC,SETDEF	;SET DEFAULT DISK AND DIRECTORY
	CLR DSKNSC	;NO CHARACTERS IN BUFFER
.POTR2:	JSR PC,GCDIR	;GET CURRENT DIRECTORY
	MOV #DBUF,ENTBEG   ;ENTRY AT START OF DISK BUFFER
.POTR1:	MOV @ENTBEG,F	;FIRST WORD OF ENTRY
	BEQ .POTR3
	BIT #300,F	;IS IT TYPE DIRECTORY?
	BEQ .POTR4	;YES
	MOV DSKNSC,A	;NO. OF SECTORS IN FILE
	BEQ .POTR4	;NO MORE
.POTR6:	JSR PC,.SPACE	;INDENT TWO SPACES
	JSR PC,.SPACE
	SOB A,.POTR6	;IS ENTRY ANOTHER LEVEL DOWN?
	BR .POTR4	;NO, PRINT THE NAME
.POTR3:	DEC DSKNSC	;ONE LESS SECTOR
	BLT .POI3	;DONE- PRINT OUT TOTAL NO. OF BLOCKS USED
	MOV (P),E
	SPOP CURDIR	;GET BACK PREVIOUS DIRECTORY
	POP ENTBEG	;GET BACK START OF OLD ENTRY
	JSR PC,DBREAD	;SET BLOCK FOR READING
	BR .POTR5
.POTR4:	BIC #177477,F	;FIND TYPE OF ENTRY
	ASH #-5,F
	JSR PC,@POTTAB(F)	;AND SERVICE APPROPRIATE TYPE
.POTR5:	MOV @ENTBEG,A	;FIRST WORD OF ENTRY
	BIC #177700,A
	ASL A		;NO. OF BYTES IN ENTRY
	ADD A,ENTBEG	;START OF NEXT ENTRY
	BR .POTR1	;GO GET IT

POTDIR:	JSR PC,POIDIR	;PRINT OUT INDEX
	INC DSKNSC	;ONE MORE SECTOR (ONE LEVEL DOWN)
	TST (P)+	;BYPASS TOP OF P-PDL
	PUSH ENTBEG	;SAVE START OF ENTRY
	SPUSH CURDIR	;SAVE CURRENT DIRECTORY
	JSR PC,DRREAD	;SET UP NEW CURRENT DIRECTORY
	BR .POTR2

.CRINDEX:
	JSR PC,DSET	;SET THE DIRECTORY
	MOV #NAME,E	;PTR TO INDEX NAME
	JSR PC,NFNGET	;GET THE NAME
.CRIN1:	JSR PC,GCDIR	;GET THE CURRENT DIRECTORY
	MOV #WDIRSW,D	;LOCK IN WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB	;RUN DISK REQUEST
	MOV #20300,DESSAV  ;DESCRIPTOR SET TO TYPE DIRECTORY
	JSR PC,DESWST	;DESCRIPTOR WRITE MODE SET TO SKIP
	JSR PC,DBGET	;GET THE DISK BLOCK
	JSR PC,DESINS	;INSERT THE DESCRIPTOR
	BIC #377,DESSAV	;CLEAR LOW-ORDER BYTE OF FIRST WORD
	JSR PC,DESWST
	MOV CURDIR,A
	JSR PC,DBGOTN
	MOV DBGOT,CURDIR	;BLOCK OF CURRENT DIRECTORY
	MOV #2000,DBUF+1776	;LENGTH OF ENTRY (BYTES)
	MOV #DBUF,ENTBEG	;START OF ENTRY
	JSR PC,DESINX
	JSR PC,WBITS	;WRITE BIT TABLE OUT
	MOV #WDIRSW,D
	JMP LCUGRB

.POF:	JSR PC,.READF
.POF1:	JSR PC,.READC
	CMP #EOFCHR,D
	BEQ .POF2
	JSR PC,@PCHR
	BR .POF1
.POF2:	CLR FILFLG
	RTS PC
.PREAD:.PWRIT:	ERROR+OOP

GNWRD:	;INPUT	POINTER TO LIST OF WORDS ON S
	;OUTPUT	-IF LIST IS NOT EMPTY,
	;	 POINTER TO  FIRST OF LIST ON TOP OF S
	;	 POINTER TO BF OF LIST NEXT
	;	 Z WILL BE CLEAR
	;	-IF LIST IS EMPTY, POP S AND SET Z
	;IF F LIST ISNT A WORD, WTA ERROR ISSUED
	JSR F,CACSAV
	MOV @S,B
	BIT #7777,B	;IS LIST EMPTY?
	BEQ GNWRD1
	JSR PC,.LOADB	;NO GET 1ST NODE
	MOV A,@S	;SAVE BF ON S
	PUSHS B		;YES - PUSH FIRST ON S
	JSR F,CACRES
	CLZ
	RTS PC
GNWRD1:	POPS A		;EMPTY LIST QUIT
	JSR F,CACRES
	SEZ
	RTS PC
NFNGET:		;INPUT	ADDRESS OF BLOCK IN E
		;	PTR TO LSTR ON S
		;OUTPUT	PUT 1ST 10. CHAR OF LSTR INTO BLOCK
		;	SET 200 BIT IN LAST CHAR, POP S
	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,B	;POINTER TO FILE NAME IN B
	MOV #LSTR,A	;DATA TYPE FOR CONVERSION
	JSR PC,CONVER	;MAKE NAME AN LSTR
	BNE .+4
	ERROR+IFN	;INVALID FILE NAME (CONVERSION FAILED)
	MOV B,@S	;POINTER TO NEW DATA ON STACK
	BIC #170000,B	;LEAVE DATA TYPE
	MOV B,GNCN	;"GET NEXT CHARACTER" NODE
	MOV #10.,C	;TAKES ONLY THIS MANY CHARACTERS
NFNG1:	JSR PC,GNC	;GET NEXT CHAR
	CMP #15,D	;UGH! (IS IT A CARRIAGE RETURN?)
	BEQ NFNG2	;YES- NO MORE CHARACTERS
	MOVB D,(E)+	;STORE THE NEXT CHARACTER
	MOV D,TEMP
	SOB C,NFNG1	;KEEP GOING UNTIL WE HIT TEN
NFNG2:	BISB #200,-(E)	;SET 200 BIT IN LAST CHAR AND QUIT
	JSR F,CACRES	;GET BACK THE OLD REGISTERS
	JSR PC,SPOPT
	RTS PC
SETNM:		;INPUT	LIST OR WoRD ON S
		;OUTPUT	IF WORD, OUTPUT WORD AND SET Z
		;	IF LIST, OUTPUT LzST AND BL OF LIST ON S
		;		PUT BL ON TOP AND CLEAR Z
		;	OTHERWISE ERROR
	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO	;FILE ALREADY OPEN
	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,C	;GET INPUT
	BIT #7777,C
	BNE .+4
	ERROR+IFN	;INVALID FILE NAME
	MOV C,B		;SEE IF IT'S A LIST
	BIC #7777,C
	CMP C,#LIST
	BEQ SETNM1	;YES, IT IS
SETNM2:	JSR F,CACRES	;OK, SET Z AND QUIT
	SEZ
	RTS PC
SETNM1:	JSR PC,COPYL	;COPY LIST - INPUT IN B
		;OUTPUT IN B;  C POINTS TO LAST NODE IN NEW LIST
		; E POINTS TO 2ND TO LAST NODE
	JSR PC,.LDP2
	MOV A,@S
	MOV E,C
	BEQ SETNM3	;NO BUTLAST
	JSR PC,.LDP1	;FIX UP  LINK
	BIC #7777,A
	JSR PC,.STP1
	BIS #LIST,B
SETNM4:	PUSHS B
	JSR F,CACRES
	CLZ
	RTS PC
SETNM3:	MOV #LSTR,B
	BR SETNM4
;LOWER LEVEL ROUTINES

;GCDIR GET CURRENT DIRECTORY
;READS IN BIT TABLE IF IT IS NOT ALREADY IN

GCDIR:	TST FDBITI	;IS THE BIT TABLE IN?
	BGE GCDIR1	;YES, GO AHEAD
	TST USER	;IS IT USER 0?
	BEQ GCDIR1	;HE IS ALLOWED ALWAYS
GCDIR4:	JSR PC,FLUSH	;EVERYONE ELSE
	TST FDBITI	;HAS TO WAIT FOR INITIALIZE TO FINISH
	BLT GCDIR4
	JSR PC,RUNME
GCDIR1:	MOV CURDIR,E
	JMP DBREAD
IDISKS:	TST FDBITI	;IS IT IN NOW?
	BGE GCDIR5	;NO, IT'S NOW OUR RESPONSIBLITY
	CLR WCHDSK
GCDIR2:	MOV #46,CURDIR	;GET THE ROOT DIRECTORY IN
	MOV #BITS,E	;THE NAME OF THE BIT TABLE
	JSR PC,DIRSER	;TRY TO FIND IT
	BNE IDISK1
	MOV #-1,DBITAD(F)
	BR IDISK2
IDISK1:	JSR PC,DESSET	;SETUP THE DESCRIPTOR
	MOV WCHDSK,F
	MOV DSKADR,DBITAD(F)	;ADDRESS OF THE BIT TABLE
	MOV FDNAMP(F),A
	MOV #DBUF+2,D
	MOVB (D)+,(A)+
	BGE .-2
	JSR PC,RBITS
	MOV @FDBITP(F),A
	MOV A,D
	DEC A
GCDIR3:	JSR PC,BITGET
	BITB BMT(B),(C)
	BEQ .+4
	DEC D
	DEC A
	BGE GCDIR3
	MOV WCHDSK,F
	MOV D,NBLKFR(F)
	MOV #-1,FDUSEA(F)
	MOV #USRFIL,E
	JSR PC,DIRSER
	BEQ IDISK2
	JSR PC,DESSET
	MOV WCHDSK,F
	MOV DSKADR,FDUSEA(F)
IDISK2:	ADD #2,WCHDSK
	INC FDBITI
	BNE GCDIR2
GCDIR5:	CLR WCHDSK
	RTS PC


;DIRSER  DIRECTORY SEARCH
;SEARCH CURRENT DIRECTORY FOR SPECIFIED FILE
;ENTER WITH POINTER TO FILE NAME IN E
;Z IS SET IF FOUND, ELSE CLEARED
DIRSER:	SPUSH E
	JSR PC,GCDIR	;GET CURRENT DIRECTORY
	MOV #DBUF,ENTBEG  ;DISK BUFFER ADDRESS IS START OF ENTRY
DIRSR1:	MOVB @ENTBEG,B	;B CONTAINS NO OF WORDS IN ENTRY
	BIC #177700,B
	ASL B		;LENGTH IN BYTES
	ADD B,ENTBEG
DIRSR4:	MOV (P),E
	MOV ENTBEG,B
	TST (B)+	;SKIP THE FIRT WORD
	BEQ DIRSR3	;FOUND THE END OF THE DIRECTORY
DIRSR2:	CMPB (B)+,(E)+	;COMPARE NAMES BYTE BY BYTE
	BNE DIRSR5	;MISMATCH
	TSTB -1(B)	;END OF NAMES?
	BGE DIRSR2	;NOT YET
	TST (P)+	;YES, FLUSH TEMP ON STACK
	CLZ
	RTS PC
DIRSR3:	TST (SP)+
	SEZ
	RTS PC
DIRSR5:	MOVB -(B),A	;MISMATCHED CHARACTER IN DIRECTORY
	MOVB -(E),E	;SAME THING IN DESIRED NAME
	BIC #177600,A	;GET RID OF CRAP
	BIC #177600,E	;SAME
	CMP A,E		;WHAT IS THE REAL RELATIONSHIP?
	BGT DIRSR3	;DIRECTORY>DESIRED, WE ARE PAST WHAT WE WANT
	BLT DIRSR1	;DESIRED>DIRECTORY, MAYBE IT'S FURTHER ON.
	TSTB (B)	;SAME, IS DIRECTORY SHORTER?
	BLT DIRSR1	;YES, MAYBE FURTHER ON.
	BR DIRSR3


;DESSET SET UP DESCRIPTOR

DESSET:	CLR DBCNT	;CLEAR DISK BLOCK COUNT
	CLR DSKADR	;CLEAR CURRENT SECTOR
	MOV #-1,DEOFBL
	MOV ENTBEG,A	;START OF NEW ENTRY
	MOV #DESSAV,B	;START OF OLD DESCRIPTOR
	MOV (A),C
	BIC #177700,C	;LENGTH OF NEW ENTRY IN WORDS
	CMP C,#31.	;MAKE SURE ITS NOT TOO LONG
	BLE .+4		;OK
	ERROR+BADD	;BAD DIRECTORY?
	MOV (A)+,(B)+	;WRITE OVER OLD STUFF
	SOB C,.-2
DESST:	MOV #DESSAV,A	;START OF NEW DESCRIPTOR
	MOV (A),D	;LENGTH IN BYTES
	BIC #177700,D
	MOV A,C
	MOV (A),E
	BIC #177477,E	;FLUSH ALL BUT TYPE
	CMP #200,E	;IS IT A FILE
	BNE .+6		;NO, DIRECTORY
	SUB #2,D	;YES, DATE IS NOT PART OF DESCRIPTOR
	ASL D		;NUMBER OF BYTES
	ADD D,C		;END OF DESCRIPTOR
DESST2:	TSTB -(C)	;GET RID OF TRAILING BLANKS
	BEQ .-2
DESST1:	MOV C,DESEPT	;REAL END OF ESCRIPTOR
	CMP #100,E
	BNE .+4
	ERROR+BADE	;BAD ENTRY TYPE
	TST (A)+	;SKIP FIRST WORD
	TSTB (A)+	;FIND END OF NAME
	BGE .-2
	BR GNBLK1


;GNBLK GET THE ADDRESS OF THE NEXT BLOCK INTO DSKADR
GNBLK:	INC DSKADR
	DEC DBCNT
	BLT GNBLK2
GNBLK3:	BNE GNBLK4	;MORE THAN THIS BLOCK LEFT
	CMP DESPNT,DESEPT	;AT END OF DESCRIPTOR?
	BLOS GNBLK4	;NO, HAPPY
	CLR DEOFBL	;READING LAST BLOCK
GNBLK4:	MOV #DBUF,DBUFPT
	RTS PC
GNBLK2:	MOV DESPNT,A	;NO BLOCKS LEFT TO COUNT, LOOK INTO DESCRIPTOR
GNBLK1:	CMP A,DESEPT
	BLOS GNBLK7
	MOV #1,DEOFBL
	RTS PC
GNBLK7:	MOVB (A)+,B
	MOV A,DESPNT	;NEW POINTER
	MOV B,C
	BIC #177477,B	;WHAT KIND OF BYTE?
	BIC #177700,C	;WITH WHAT DATA
	ASH #-5,B
	MOV #DESMOD,F
	JMP @GNBTAB(B)	;SERVICE THAT TYPE

GNBSKP:	TST C	;ZERO IS THE NULL BYTE
	BEQ GNBLK1	;REALLY ONLY FOR THE END OF DESCRIPTOR, BUT...
	ADD C,DSKADR
	MOV #DBGSKP,(F)
	CLR DBCNT
	BR GNBLK3

GNBCNT:	MOV #DBGCNT,(F)
	MOV C,DBCNT
	BR GNBLK3

GNBADR:	MOVB (A)+,DSKADR
	MOVB (A)+,DSKADR+1
	MOV A,DESPNT
	MOV #DBGADR,(F)
	MOV C,DBCNT
	BR GNBLK3

GNBSCN:	MOV C,B
	BIC #177770,B
	BIC #177707,C
	ASH #-3,C
	ADD C,DSKADR
	MOV #DBGSCT,(F)
	MOV B,DBCNT
	BR GNBLK3

DESWST:	MOV #NAME,A
	TSTB (A)+
	BGE .-2
	CLRB (A)
	MOV A,DESPNT
	MOV #-1,LBLKAD
	MOV #DBGSKP,DESMOD
	RTS PC

DBGET:	MOV WCHDSK,E
	JSR PC,BCHK
	MOV @FDBITP(E),E
	CLR A
DBGET1:	JSR PC,BITGET
	BITB BMT(B),(C)
	BEQ DBGET2
	INC A
	SOB E,DBGET1
	ERROR+DFU
DBGET2:	MOV WCHDSK,F
	DEC NBLKFR(F)
	MOV A,DBGOT
	BISB BMT(B),(C)
DBGOTN:	MOV A,B
	SUB LBLKAD,B
	MOV A,LBLKAD
	MOV #DESMOD,F
	DEC B
	BEQ DBGET3
	CMP B,#7
	BLE DBGET4
	CMP B,#77
	BLE DBGET5
	MOV DESPNT,B
	MOVB #200,(B)+
	MOVB LBLKAD,(B)+
	MOVB LBLKAD+1,(B)+
	MOV B,DESPNT
	MOV #DBGADR,(F)
	RTS PC
DBGET4:	ASH #3,B
	BIS #300,B
	MOV #DBGSCT,(F)
DBGET6:	MOVB B,@DESPNT
	INC DESPNT
	RTS PC
DBGET5:	MOV #DBGSKP,(F)
	BR DBGET6
DBGET3:	MOV DESPNT,A
	JMP @DESMOD

DBGSK1:	INC A
DBGSKP:	MOVB #100,(A)
	INC DESPNT
	MOV #DBGCNT,(F)
	RTS PC
DBGCNT:	MOVB -(A),B
	BIC #177700,B
	INC B
	BIT #100,B
	BNE DBGSK1
	INCB (A)
	RTS PC
DBGADR:	MOVB -3(A),B
	BIC #177700,B
	INC B
	BIT #100,B
	BNE DBGSKP
	INCB -3(A)
	RTS PC
DBGSCT:	MOVB -(A),B
	BIC #177770,B
	INC B
	BIT #10,B
	BNE DBGSK1
	INCB (A)
	RTS PC
BCHK:	JSR F,ACSAV
	MOV FDBITP(E),C
	MOV NBLKFR(E),A
	MOV (C)+,B
BCHK3:	MOV (C)+,D
	BEQ BCHK1
	CMP #-1,D
	BEQ BCHK2
BCHK6:	MOV #20,E
BCHK5:	ROR D
	BCS .+4
	DEC A
	DEC B
	BEQ BCHK4
	SOB E,BCHK5
	BR BCHK3
BCHK1:	CMP #20,B
	BGE BCHK6
	SUB #20,B
	SUB #20,A
	BR BCHK3
BCHK2:	CMP #20,B
	BGE BCHK6
	SUB #20,B
	BR BCHK3
BCHK4:	TST A
	BEQ .+6
BADBIT:	BPT
	BR .-2
	JSR F,ACRES
	RTS PC

DESINS:	CMP #46,CURDIR	;IS THIS THE ROOT DIRECTORY?
	BNE DESIN5
	BIT #SSF,FLAGS2	;YES, IS STATUS ON?
	BNE DESIN5
	JSR PC,WDELBL
	ERROR+DRF	;DIRECTORY FULL
DESIN5:	MOV #NAME,E
	JSR PC,DIRSER
	BEQ DESINX
	JSR PC,WDELBL
	ERROR+EAES
DESINX:	JSR PC,DESINC
	ASL A
	MOV #DBUF+1776,B
	SUB (B),B
	TST (B)+
	MOV B,C
	ADD A,C
	CMP #DBUF+1770,C
	BGT DESIN4
	JSR PC,.DELBL
	ERROR+DRF
DESIN4:	CLR (C)
DESIN2:	CMP B,ENTBEG
	BEQ DESIN3
	MOV -(B),-(C)
	BR DESIN2
DESIN3:	MOV #DESSAV,C
	SUB A,DBUF+1776
	ASR A
	MOV (C)+,(B)+
	SOB A,.-2
	MOV CURDIR,E
	JMP DBWRTE
DESINC:	MOV DESPNT,A
	BIT #1,A
	BEQ .+4
	CLRB (A)+
	MOV DESSAV,B
	BIC #177477,B
	CMP #200,B
	BNE DESIN1
	MOV #-1,(A)+
	MOV #-1,(A)+
DESIN1:	SUB #DESSAV,A
	ASR A
	ADD A,DESSAV
	RTS PC




;ENTER DBREAD AND DBWRTE WITH ADDRESS OF BLOCK TO HACK IN E
DBREAD:	MOV #DREADC,F
	BR .+6
DBWRTE:	MOV #DWRTEC,F
	MOV E,D
	SPUSH A
	SPUSH B
	SPUSH C
	JSR PC,SYDRBG	;GET THE REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-1000,(A)+	;ONE SIZE, ONE PRICE, ONE QUALITY!
	MOV #DBUF,(A)+	;AND ONE PLACE TO PUT IT
	MOV USER,B	;TO FIND THE APPROPRIATE SLOT
	MOV SLOTAS(B),B
	SUB #PURE,-(A)
	MOV SLOTHA(B),C
	ADD SLOTCA(B),(A)+
	ADC C
	ASH #4,C
	BIS C,6(A)
DBWRT1:	ASL D
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	MOV WCHDSK,C
	ADD FDDSKN(C),D
	MOV D,(A)+
	MOV #-1,(A)+
	TST (A)+
	BISB F,(A)
	JSR PC,DSKWAI
	SPOP C
	SPOP B
	SPOP A
	RTS PC

WBITS:	JSR PC,WBITS1
WCBITS:	MOV #DWRTCC,F
	BR .+6
RBITS:	MOV #DREADC,F
	BR .+6
WBITS1:	MOV #DWRTEC,F
	JSR PC,SYDRBG
	CLR (A)+
	MOV #-NBTTL,(A)+
	MOV WCHDSK,D
	MOV FDBITP(D),(A)+
	SUB #6,P
	MOV DBITAD(D),D
	BIC #60,6(A)
	BR DBWRT1

BITGET:	MOV A,B		;A CONTAINS THE BLOCK NUMBER
	MOV A,C		;B WILL CONTAIN THE BIT NUMBER
	BIC #177770,B	;THERE!
	ASH #-3,C	;AND C GETS THE BYTE NUMBER
	SPUSH B
	MOV WCHDSK,B
	CMP A,FDBITP(B)
	BLO .+4
	BPT
	ADD FDBITP(B),C
	ADD #2,C
	SPOP B
	RTS PC
READPT:	JSR PC,PINIT
	MOV #101,PRS
	MOV #PRGET,GCHR
	SEZ
	RTS PC
PINIT:	TST PGRAB
	BLT .+4
	ERROR+DIU
	MOV USER,PGRAB
	MOV #PBUF,PBFPTI
	MOV #PBUFE-1,PBFPTM
	CLR NPCHRS
	RTS PC
PRGET:	SPUSH U
	MOV USER,U
PRGET2:	TST NPCHRS
	BNE PRGET1
	JSR PC,FLUSH
	BR PRGET2
PRGET1:	JSR PC,RUNME
	SPOP U
	BIC #100,PRS
	DEC NPCHRS
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	MOVB @PBFPTM,D
	CMP #EOFCHR,D
	BNE .+10
	MOV #-1,PGRAB
	BIS #100,PRS
	RTS PC
PRBRK:	SPUSH A
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOV PRB,A
	TST PRS
	BGE PRBRK1
	MOV #EOFCHR,A
PRBRK1:	BIC #200,A
	BEQ PRBRK2
	MOVB A,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	CMP #PBUFE-PBUF,NPCHRS
	BNE .+10
	BIC #100,PRS
PRBRK2:	SPOP A
	INC PRS
	RTT
WRITEP:	JSR PC,PINIT
	JSR PC,FEED
	MOV #PPPUT,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	CLR WRTFLG
	MOV #TYO,PCHR
	MOV #EOFCHR,D
	MOV #10.,A
	JSR PC,FEED1
	JSR PC,FEED
	MOV #-1,PGRAB
	SEZ
	RTS PC

FEED:	MOV #100.,A
	CLR D
FEED1:	JSR PC,PPPUT
	DEC A
	BNE FEED1
	RTS PC

PPPUT:	SPUSH U
PPPUT2:	MOV USER,U
	CMP #PBUFE-PBUF,NPCHRS
	BNE PPPUT1
	JSR PC,FLUSH
	BR PPPUT2
PPPUT1:	JSR PC,RUNME
	SPOP U
	TST PPS
	BPL .+4
	ERROR+DNR
	CLR PPS
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOVB D,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	BIS #100,PPS
	RTS PC

PPBRK:	TST NPCHRS
	BEQ PPBRK1
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	DEC NPCHRS
	MOVB @PBFPTM,PPB
	RTT
PPBRK1:	CLR PPS
	RTT
	.STITL SCHEDULER


RUNME:	TST USER
	BGE RUNME1
RUNME2:	RTS PC	;SYSTEM CALLED RUNME

RUNME1:	TST FLSADR(U)	;IF HE WANTS TO RUN HE SHOULD JSR HERE
	BEQ RUNME2	;IF FLSADR IS ZERO, JUST KEEP RUNNING HIM
	MOV #-1,USER	;SYSTEM IS NOW USER
	JSR PC,UACSAV	;STORE HIS ACS
	CLR FLSADR(U)	;GUY IS NOW RUNABLE
	CLR FLSRES(U)
	INC NRABLU
	SPOP UPC(U)	;HE SHOULD START AFTER THE JSR PC,RUNME
NEXTU1:	CMP #SYSIDX,U	;IS IT THE SYSTEM JOB?
	BNE NEXTU2
	MOV P,SPDLP	;SET UP SYS JOB PDL
	MOV SJPDLP,P
	JMP RUNUS7

NEXTU2:	MOV SLOTAS(U),A	;IS HE ASSIGNED A SLOT?
	BLT NEXTU3	;NO, SEE IF WE CAN GET ONE
	TST SLOTST(A)	;YES, WHAT IS IT'S STATUS?
	BEQ NEXTUS	;GUY BEING SWAPPED IN
;WE GET HERE IF THE GUY IS IN CORE
	CMP #FRNEWU,FLSRES(U)	;RELOAD USER
	BNE NEXT14	;IN CORE AND NOT BEING GUNNED, RUN HIM
	CLR TIMUSD(U)
	MOV #UGO,FLSADR(U)	;RESTART HIM
NEXT16:	MOV A,SLOTAS(U)
	MOV U,SLOTU(A)
	MOV SLOTRB(A),C	;CORE ADDRESS OF ASSIGNED SLOT
	MOV #16,D
	JMP NEXT11	;GO DO A SPECIAL SWAPIN

NEXT14:	CLR FLSRES(U)
	JMP RUNUSR



;CALL TO GET INDEX OF NEXT USER TO RUN

NEXTUS:	MOV TTYUGO,U	;DID SOMEONE JUST TYPE CR?
	BGE NEXT15
	SUB #LUBLK,ULAST	;COUNT BACKWARDS
	BGE .+10	;DON'T GO NEG
	MOV #MNUSRS*LUBLK,ULAST	;LAST POSSIBLE USER INDEX
	MOV ULAST,U	;SEE IF THIS IS A GOOD GUY TO RUN
NEXT15:	MOV #-1,TTYUGO
	TST FLSADR(U)	;IF FLSADR IS ZERO, RUNABLE(???)
	BEQ NEXTU1	;RUN HIM.
	CMP #-1,FLSADR(U)	;-1 => NON EX USER
	BEQ NEXTUS
	SPUSH B
	MOV GUNU,B
	BLT NEX21B
	MUL #LUBLK,B
	CMP U,B
	BNE NEX21B
	SPOP B
	MOV #-1,GUNU
	MOV U,USER	;USER IS NOW USER
	MOV PC,BRAKE(U)
	JMP GOODBY

NEX21B:	SPOP B
NEXT21:	TSTB	FLSRES(U)
	BMI	NEXTUS
	MOV U,USER	;USER IS NOW USER
	JSR PC,UACRES	;RESTORE HIS ACS
	JMP @FLSADR(U)	;SEE IF HE SHOULD REALLY RUN



NEXTU3:	MOV PUSPSL,A	;SEE IF THERE IS A PREFERED SLOT
	BGE NEXTU6
NEXT20:	CLR A
	MOV NSLOTS,C
NEXTU4:	TST SLOTST(A)
	BLT NEXT16	;AN UNUSED SLOT!
	CMP #1,SLOTST(A)
	BGE NEXTU5	;GUY HASN'T RUN YET, DON'T SWAP HIM OUT
	TST NSWPU	;ARE THERE USERS BEING SWAPED?
	BEQ NEXTU6	;NO, SWAP ONE
	CMP NINU,#1	;IS THERE ONLY ONE USER IN CORE?
	BEQ NEXTUS	;YES, RUN HIM
NEXTU6:	MOV SLOTU(A),B	;USER THAT MAY BE SWAPED OUT
	BLT NEXT20
	CMP #FRTYIW,FLSRES(B)
	BEQ NEXT17
	MOV #LOCKUS,D
	MOV #NLOCKS,E
NEXT18:	CMP B,(D)+
	BNE NEXT19	;LOCKED IN CORE, DO NOT DISTURB
NEXT17:	TST PUSPSL
	BLT NEXTU5
	MOV #-1,PUSPSL
	BR NEXT20
NEXTU5:	TST (A)+
	SOB C,NEXTU4
	BR NEXTUS

NEXT19:	SOB E,NEXT18
	MOV #-1, PUSPSL	;IF THERE WAS A PREFERED SLOT, WE ARE DOING IT
	MOV SLOTU(A),B	;FOUND A GOOD SLOT, USER TO SWAP OUT INTO B
	MOV U,SLOTU(A)	;NEW OCCUPANT OF SLOT
	MOV #-1,SLOTAS(B)
	MOV A,SLOTAS(U)

;FALLS THROUGH

;FALLS IN

	CLR D
	MOV SLOTRB(A),C	;MOBY SWAP OUT BLOCK FOR THIS SLOT
	MOV #SWPOST,(C)+	;SWAP OUT USER START ROUTINE
	MOV USWCNT,(C)+	;WORD COUNT OF A USER SLOT
	MOV SLOTCA(A),(C)+	;SLOT CORE ADDRESS
	MOV USWPAD(B),(C)+	;LOW ORDER SWAP OUT ADDR OF U TO SWAP OUT
	MOV USWPAD+2(B),(C)+	;HIGH OORDER
	MOV B,(C)+	;SAVE USER GOING OUT FOR BRUCE
	MOV SLOTHA(A),E
	ASH #4,E
	BIS E,(C)
	BIS #DWRTEC,(C)+	;DISK WRITE COMMAND
	DEC NINU	;ONE LESS IN CORE
NEXT11:	CLR SLOTST(A)	;NOT IN YET: -1 TO SLOTST+2 OF GUY
	INC NSWPU	;ONE MORE MOVING AROUND
	MOV #SWPIST,(C)+	;SWAP IN USER START ROUTINE
	MOV USWCNT,(C)+	;SLOT WORD COUT
	MOV SLOTCA(A),(C)+	;SLOT CORE ADDRESS
	CMP #FRNEWU,FLSRES(U)
	BNE NEXT12
	MOV DCLRUS,(C)+	;DISK ADDRESS OF CLEAR USER
	MOV DCLRUS+2,(C)
	BIS #100000,(C)+
	CLR FLSRES(U)
	MOV #UGO,FLSADR(U)
	BR NEXT13

NEXT12:	MOV USWPAD(U),(C)+	;  "    "   
	MOV USWPAD+2(U),(C)+	;USER ADDRESS ON DISK
NEXT13:	MOV A,(C)+	;ADDRESS OF PLACE TO ZAP TO 1 WHEN DONE
	MOV SLOTHA(A),E
	ASH #4,E
	BIS E,(C)
	BIS #DREADC,(C)	;READ FROM DISK
	SUB #32,C	;BEGINING OF MOOBY SWAP REQ PAIR
	ADD D,C		;INDEX TO RIGHT ONE OF PAIR
	SPUSH PS
	MOV #340,PS	;NO INTS!
	MOV C,@SWPLEP
	ADD #2,SWPLEP	;GRONK ONTO REQ LIST
	SPOP PS
	JSR PC,DPROVK
	BR NEXT10

NEXTU7:	CMP #1,NUSERS
	BNE .+4
	WAIT
	MOV #-1,USER	;FLUSH ENTERS HERE, SYSTEM NOW USER
	BLT NEXT10
	MOV SLOTAS(U),A
	TST (A)	;IS HE REALLY IN?
	BLE NEXT10	;NO, NOT REALLY
	CMP #FRDSKW,FLSRES(U)	;IF JUST HUNG ON DISK
	BEQ NEXT10	;FORGET HIM
	MOV A,PUSPSL	;HE IS PREFERED OUT
	MOV U,PUSRSP
	BR NEXT10

NEXT10:	JMP NEXTUS
FLUSH:	TST USER
	BGE FLUSH4
	RTS PC

FLUSH4:	CLR 177570	;CLEAR DISPLAY REGISTER
	CLR DISPDR
	JSR PC,UACSAV	;STOP USER; STORE HIS ACS
	MOV FLSADR(U),A
	SPOP FLSADR(U)	;SAVE PC
	TST A	;IS THIS GUY ALREADY STOPED?
	BNE NEXTU7	;GO TRY ANOTHER GUY
	MOV #-1,USER
	MOV UTIME,A
	ADD A,JMTU(U)
	ASH #-5,A
	ADD A,TIMUSD(U)
	ADD A,TUTIME
	ADC TUTIME+2
	MOV #4,A
	MOV #LSTIM,B
	ADD U,B
	MOV #RSEC,C
FLUSH3:	MOVB (C)+,(B)+
	SOB A,FLUSH3
	TST FLSRES(U)
	BNE .+10
	MOV #FRRAND,FLSRES(U)
	DEC NRABLU
	CMP #SYSIDX,U
	BEQ FLUSH7
	CLR 177774
	MOV P,UPDLP	;SAVE USER'S POINTER
	MOV SPDLP,P	;SYSTEM PDL
FLUSH5:	JMP NEXTUS

FLUSH7:	MOV P,SJPDLP
	MOV SPDLP,P
	JMP NEXTUS
;RUNUSR, THE "MAIN LOOP"

RUNUSR:	CMP U,PUSRSP	;AM I THE GUY THEY WANT OUT?
	BNE .+10	;BRANCH IF NO
	MOV #-1,PUSPSL
	INC SLOTST(A)	;INDICATE THAT THIS GUY HAS BEEN RUN
	BVC .+10
	MOV #2,SLOTST(A)
	MOV SLOTAR(A),B
	MOV #PUREAR,C
	MOV B,(C)+
	ADD #200,B
	MOV B,(C)+
	ADD #200,B
	MOV B,(C)
	CLR DISPDR
	MOV DISAS(U),A
	BLT RUNUS8
	MOV DISAR(A),DISPAR
	MOV DISDR(A),DISPDR
RUNUS8:	MOV #PURE,BASEUS
	MOV P,SPDLP	;SAVE SYSTEM PDL POINTER
	MOV UPDLP,P	;GET USER PDL POINTER
RUNUS7:	MOV U,USER	;NOW HE'S REALLY THE GUY
	SPUSH UPC(U)	;PLACE TO START USER
	MOV QUANT,UQUANT	;RUN FOR 3 1/100TH'S????
	CLR UTIME
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
	CLR A		;DISPLAY USER # IN DISPLAY REG
	MOV USER,B
	DIV #L,A	;(71027 000056)
	MOV #1,B
	ASH A,B		;(72100)
	MOV B,177570
	JMP UACRES	;RESTORE USER ACS AND START USER


SCHEDP:	TST UQUANT	;SEE IF IT'S TIME TO FLUSH
	BLE .+4	;NOT YET
	RTS PC
	SPUSH U
	MOV USER,U
	MOV #FRSCED,FLSRES(U)
	JSR PC,FLUSH
	JSR PC,RUNME
	SPOP U
	RTS PC
.STITL CLOCK BREAK ROUTINE

CLKBRK:	SPUSH A
	SPUSH B
	SPUSH	C
	ADD #40,UTIME
	INC TIME+2
	BNE CLKTOV
	INC TIME
CLKTOV:	DEC UQUANT
	DEC N50THS	;HAS THIS BEEN ONE SECOND?
	BLE DATEC	;YES, CHANGE THE SECOND
	;NEXT FIVE LINES ARE FOR TESTING DISPLAY
CLKBR1:
	.IFZ NDISP
	BR CLKB11
	.ENDC
	.IFNZ NDISP
	DECB	DISTIM	;TIME (HO HUM) TO START THE DISPLAYS?
	BGT	CLKB11	;NO
	MOVB	#1,DISTIM
	MOV	#NDISP-1,C
	ASL	C	;TO USE AS INDEX
	CLR	B
CLKDIS:	CMP	B,C	;ALL DISPLAYS CHECKED?
	BGT	CLKB11
	MOV	DSTAT(B),A
	TST	(B)+
	TST	A
	BLT	CLKDIS	;THIS ONE INACTIVE
	MOV	A,NGCSR
	BIT	#TKRUN,NGCSR
	BNE	CLKDIS	;STILL RUNNING
	BIS #TKGO,A
	MOV A,NGCSR
	BR	CLKDIS
	.ENDC

DATEC:	JSR PC,DPROVK
	DEC DKPWFR
	BGT .+10
	MOV #-20.,DKNRTY
	MOV #CLKFRQ,N50THS
	MOV #MNUSRS,A
	CLR B
	SPUSH C
JMTUD2:	MOV JMTU(B),C
	BEQ JMTUD1
	ASR C
	ASR C
	ASR C
	INC C
	SUB C,JMTU(B)
	BGE .+6
	CLR JMTU(B)
JMTUD1:	ADD #LUBLK,B
	DEC A
	BNE JMTUD2
	SPOP C
	MOVB RMONTH,A
	MOVB DMON(A),DAYLIM
	MOV #SECLIM,A
	MOV #RSEC,B
DATEC1:	INCB (B)
	CMPB (A)+,(B)
	BGT CLKBR1
	CLRB (B)+
	BR DATEC1

CLKB11:
CLKBDM:	BIT	#1,TIME+2	;EVERY OTHER BREAK (=1/25 SEC)
	BNE	CLKQBK	;
	JSR U,ACSAV
	CLR E
	MOV #NLTY,B
TIBLP:	BIT #TILIPM,TTYST(E)
	BEQ TIBLPB
	TST TIBN(E)
	BEQ TIBLPB
	JSR PC,TICP
TIBLPB:	INC E
	INC E
	SOB B,TIBLP
	JSR U,ACRES

CLKQBK:	DEC	@CLKQT
CLKQB1:	TST	@CLKQT
	BNE	CLKQB2
	MOV	CLKQT,A
	MOV	2(A),CLKQT	;PUT NXT BLK AT TOP OF Q
	JSR	PC,@4(A)		;DO CURRENT REQUEST
	BR	CLKQB1
CLKQB2:	MOV	#-1,CLKINF
	SPOP	C
	SPOP B
	SPOP A
	RTT

CLKINE:	TST DEBSW
	BNE CLKIN2
	JSR	A,SPRINT
	BPRTXT	^/CLKQBK RAN CLKINE/
	PRCR
	SPREND
CLKIN1:	MOV #CLKINF,CLKQT
	MOV	#-1,CLKINF
	RTS	PC

CLKIN2:	BPT	;CLKQBK RAN OFF END OF CLK QUEUE
	BR CLKIN1
.STITL	CLOCK QUEUE ROUTINES

;CLKQAD --
;CLOCK QUEUE ADD
;WORKS ONLY AT CLK BRK LEVEL OR LOWER 
;ADD BLOCK POINTED TO BY A TO SYSTEM CLOCK QUEUE
;1ST WD # OF TICKS TO WAIT
;2ND WD EMPTY (USED BY SYSTEM)
;3RD WD ADDR TO JSR TO

CLKQAD:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST CLKQ ENTRY
	MOV	(C),D
	BR	CLKQA2

CLKQA1:	MOV	D,C	;PNT C TO NEXT BLK
	MOV	2(D),D	;PNT D TO ONE AFTER
	SUB	(C)+,(A)	;MAKE TIME IN A BLK REL TO C BLK
CLKQA2:	TST	2(D)
	BEQ	CLKQA3	;BR IF NO MORE BLKS LEFT 
	CMP	(A),(D)
	BHI	CLKQA1
CLKQA3:			;INSRT ABLK BETWEEN C BLK AND D BLK
	MOV	D,2(A)	;PNT A BLK TO D BLK
	MOV	A,(C)	;PNT C BLK TO A BLK
	SUB	(A),(D)	;MAKE D TIME REL TO A TIME

CLKQRS:	SPOP	D
	SPOP	PS
	SPOP	C
	RTS	PC

CLKQSV:	SPUSH	PS
	MOV	PCBRV+2,PS	;RUN AT CLK BK LEVEL
	SPUSH	D
	JMP	(C)

;CLKQDL--
;CLOCK QUEUE DELETE
;DELETE BLOCK POINTED TO BY A FROM CLOCK Q

CLKQDL:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST ENTRY
	BR	CLKQD2
CLKQD1:	MOV	(C),C	;GET NEXT ENTRY
	TST	(C)+	;MAKE IT POINT TO NEXT+1 ENTRY
	TST	(C)	
	BEQ	CLKQD3	;BRANCH IF NO MORE ENTRIES
CLKQD2:	CMP	A,(C)	;IS THIS THE ENTRY WE WANT
	BNE	CLKQD1	;NO
	ADD	(A),@2(A)	;INCREASE TIME IN NEXT BLK
	MOV	2(A),(C)	;CORRECT PNTR IN PREV BLOCK
CLKQD3:	JMP	CLKQRS


UTIMEG:	MOV #RHOUR+1,D
	CLR E
	BR UTIME1
UDATEG:	MOV #RYEAR+1,D
	MOV #1,E
UTIME1:	MOV #3,F
UTIME2:	MOVB -(D),B
	ADD E,B
	JSR PC,PSHNUM
	SOB F,UTIME2
	MOV #3,D
	JMP SENT.

PEEK:	CLR -(P)
	CLR E
	PRTXTC ^\USER	%TIM	FLSRES	TIMUSD	LSTIM\
	MOV NUSERS,F
PEEK1:	MOV (P),A
	JSR PC,PRDN
	SPACE
	MOV E,A
	ADD #UNAME,A
	JSR PC,POIHD2
	PRTXT ^\	\
	CLR A
	MOV JMTU(E),B
	DIV #144.,A
	JSR PC,PRDN
	PRTXT ^\	\
	MOV FLSRES(E),A
	JSR PC,PRON
	PRTXT ^\	\

	MOV TIMUSD(E),A
	JSR PC,PRDN
	PRTXT ^\	\
	MOV #LSTIM+3,B
	ADD E,B
	MOVB @B,A
	INC A
	JSR PC,PRDN
	SPACE
	MOV #3,C
	MOV #':,D
	BR .+6
PEEK4:	JSR PC,TYO	;PRINT :
	MOVB -(B),A
	JSR PC,PRDN
	SOB C,PEEK4
	PRCR
	ADD #LUBLK,E
	INC (P)
	DEC F
	BLE .+6
	JMP PEEK1
	MOV NRFERS,A
	BEQ PEEK2
	JSR PC,PRDN
	PRTXT ^\  FIXED HEAD ERRS  \
PEEK2:	MOV NRKERS,A
	BEQ PEEK3
	JSR PC,PRDN
	PRTXT ^\  MOVING HEAD ERRS\
PEEK3:	PRCR
	TST (P)+

;PEEK THORNTON BOX TYPE DEVICES
PEEKDV:
	MOV	#LDEVAR,A
PEEKD1:	CMP	(A)+,(A)+	;POINT TO NEXT NAME POINTER
	TST	(A)	;0 MARKS END OF LDEVAR NAMES
	BNE	PEEKD2
PEEKRT:	SEZ
	RTS	PC
PEEKD2:	MOV	2(A),B	;TELETYPE NUMBER OF DEVICE
	BIT	#100001,B	;NOT REALLY THERE IF NEG OR ODD
	BNE	PEEKD1	;BR IF NOT REALLY THERE
	JSR	PC,PKDEV	;DO THIS DEVICE
	BR	PEEKD1

;DO PEEK FOR ONE DEVICE.
PKDEV:	SPUSH	A
	MOV	(A),A	;NOW A POINTS TO ACTUAL NAME
	JSR	PC,PRAS	;PRINT STRING IN A
	PRTXT	^\: \
	MOV	TTYU(B),B	;USER WHO HAS DEVICE OPEN
	BGE	PKDEV1
	PRTXT	^\UNUSED\
	BR	PKDEV8
PKDEV1:	SPUSH	B	;SAVE USER
	CLR	A
	DIV	#L,A	;A _ USER NUMBER
	JSR	PC,PRDN
	SPACE
	SPOP	A	;USER
	ADD	#UNAME,A
	JSR	PC,POIHD2	;SOMEHOW THIS IS SUPPOSED TO PRINT USER NAME
PKDEV8:	PRCR
	SPOP	A
	RTS	PC

CLOCK:	MOV TIME,A
	MOV TIME+2,B
.IFZ FPPF
CLOCK1:	JMP R1I.N
.IFF
CLOCK1:	JSR PC,GRBAD
	BIS #INUM,C
	JMP ORTC

.ENDC
USRTIM:	MOV TUTIME+2,A
	MOV TUTIME,B
	BR CLOCK1

UWAIT:	JSR PC,G1IARG
	MOV	USER,U
UWAIT0:	SDPADD	TIME,TIME+2,B,C
	JSR	PC,UWAITS
	BEQ	SETRT	;BR IF WAIT DONE
UWAIT1:	JSR PC,FLUSH
UWAIT3:	TST BRAKE(U)
	BNE UWAIT2
	JSR	PC,UWAITS
	BNE	UWAIT1
UWAIT2:	JSR PC,RUNME
	BR SETRT	;SEZ RETURN

UWAITS:
	CMP	TIME,B
	BNE	UWATS1
	CMP	TIME+2,C
UWATS1:	BGE	SETRT	;BR IF TIME IS OVER AND SEZ RETURN
	CLZ	;HAVE TO WAIT SOME MORE
	RTS	PC


SETTV:	JSR PC,G1IARG
	SPUSH C
	BLT SETTV1
	JSR PC,G1IARG
	TST C
	BLT SETTV1
	CMP #6,C
	BLE SETTV1
	CMP #2,C
	BGE .+4
	DEC (P)
	CMPB (P),SECLIM(C)
	BGT SETTV1
	MOVB (P),RSEC(C)
	TST (P)+
SETRT:	SEZ
	RTS	PC
SETTV1:	ERROR+NTL


;WAITS UNTIL SPECIFIED DEVICE HAS NO CHARACTERS IN OUTPUT Q
TYOWAIT:
	JSR	PC,G1IARG	;B,C _ AM'T OF ADDITIONAL WAIT
	POPS	E	;DEVICE SPEC
	JSR	PC,DEVNUM	;E _ TTY NUMBER OR ERROR IF INVALID NAME
	CMP	E,#2*NLTY
	BLT	TWAIT1
	ERROR+TDE	;NOT VALID TTY NUMBER
;WAIT UNTIL USER'S CONSOLE HAS FINISHED OUTPUT
CTYOWAIT:
	MOV	USER,U
	MOV	UTTY(U),E
	BR	TWAIT0
;WAIT UNTIL MUSIC BOX HAS FINISHED OUTPUTTING
MUWAIT:
	MOV	#MBDN,E

TWAIT0:	JSR	PC,G1IARG	;B,C _ AM'T OF ADDITIONAL WAIT
TWAIT1:	MOV	USER,U
	JSR	PC,TWAITS
	BEQ	UWAIT0	;BR IF DEVICE DONE
;OTHERWISE, HAVE TO WAIT
TWAIT2:	JSR	PC,FLUSH	;BYE BYE
	TST	BRAKE(U)
	BNE	UWAIT2	;BREAKING, SO GO RUN HIM
	JSR	PC,TWAITS	;IS TTY DONE?
	BNE	TWAIT2	;BR IF DEVICE NOT DONE
;DEVICE DON. NOW WAIT ARG 60THS OF SECONDS
	SDPADD	TIME,TIME+2,B,C
	BR	UWAIT3

;CALL WITH E = TTY NUMBER
;SEZ RETURN IF TTY DONE
TWAITS:
	TST	TOQN(E)
	BNE	TWATS8	;BR IF OUTPUT Q NOT EMPTY
	TSTB	MXNUM(E)	;NOTHING IN BUFFER, BUT ANY IN HARDWARE BUFFER?
	BGE	SETRT	;BR IF DONE
	BIT	#TOTRAN,TTYST(E)	;IS TTY TRANSMITTING
	BNE	SETRT	;BR IF DONE
TWATS8:	CLZ	;NOT DONE
	RTS	PC
	.STITL	SWAP START+STOP ROUTINES

SWPOST:	CLR (A)
	ADD #16,SWPLST
.IFNZ AI
	TST XORF
	BNE SWPST1
	MOV 12(A),B
	CLR XORUSR(B)
	RTS PC
SWPST1:	JSR F,ACSAV	;SAVE THE AC'S
	MOV 2(A),D	;THE WORD COUNT
	MOV 4(A),F	;THE CORE ADDRESS
	MOV 14(A),E	;THE CONTROL REGISTER
	JSR PC,XORREG	;XOR THE TRANSFER
 	MOV (P),B	;THE OLD POINTER TO THE REQUEST BLOCK
	MOV 12(B),B	;THE USER INDEX
	MOV A,XORUSR(B)	;PUT THE CHECKSUM IN HIS VARIABLES
	JSR F,ACRES	;RESTORE THE REGS
.ENDC
	RTS PC

SWPIST:	MOV #SWPISP,(A)	;SWAP IN START, SET UP STOP
	RTS PC

SWPISP:	MOV 12(A),B
	MOV #1,SLOTST(B)
	SUB #2,SWPLEP
	SPUSH A
	MOV #SWPLST+2,A
	MOV #SWPLST,B
	MOV (A)+,(B)+
	BNE .-2
	INC NINU	;ONE MORE GUY IN
	DEC NSWPU	;ONE LESS GUY MOVING
	SPOP A
.IFNZ AI
	MOV 12(A),B
	MOV SLOTU(B),B
	TST XORF
	BEQ SWPIS2
	TST XORUSR(B)
	BNE .+4
SWPIS2:	RTS PC
	JSR F,ACSAV
	MOV 2(A),D	;THE WORD COUNT
	MOV 4(A),F	;THE CORE ADDRESS
	MOV 14(A),E	;THE CONTROL REGISTER
	JSR PC,XORREG	;XOR THE TRANSFER
 	MOV (P),B	;THE OLD POINTER TO THE REQUEST BLOCK
	BIT #100000,10(B)
	BNE SWPIS1
	MOV 12(B),B	;THE SLOT NUMBER
	MOV SLOTU(B),B	;THE UUSER INDEX
	CMP A,XORUSR(B)	;COMPARE THE CHECKSUMS
	BEQ .+4
	BPT		;THEY WERE DIFFERENT
SWPIS1:	JSR F,ACRES
.IFTF
	RTS PC

.IFT
XORREG:	NEG D		;MAKE THE WORD COUNT POSITIVE
	CLR A		;CHECKSUM COMPUTED IN A
	SPUSH TEMPAR	;GET A PAGE
	SPUSH TEMPDR
	MOV #77406,TEMPDR	;MAKE IT 4096. WORDS LONG
	ASH #-4,E	;GET THE EXTENDED MEMORY BITS
	ASHC #-6,E	;TURN THE CORE ADDRESS INTO 32. WORD BLOCKS
	BIC #170000,F	;CLEAR THE EXTRA BITS
	MOV F,TEMPAR	;SET UP THE BOTTOM OF THE PAGE
XOR1:	MOV #4096.,F	;THERE ARE 4096 WORDS IN A PAGE
	CMP D,F		;ARE THERE AT LEAST THAT MANY IN THE TRANSFER
	BHIS .+4	;YES
	MOV D,F		;CORRECT THE NUMBER OF WORDS
	MOV #TEMPPG,B	;THE START OF THE PAGE IN THE VIRTUAL CORE
XOR2:	MOV (B)+,C	;THE ACTUAL WORDS OF THE TRANSFER
	XOR C,A		;CREATE THE CHECKSUM
	SOB F,XOR2	;DO ALL THE WORDS
	ADD #128.,TEMPAR	;GET THE NEXT 4K. WORDS
	SUB #4096.,D	;CORRECT THE WORD COUNT
	BGT XOR1	;MORE WORDS LEFT
	SPOP TEMPDR
	SPOP TEMPAR
	RTS PC
.ENDC
	.STITL MISC ROUTINES

CACSAV:	JSR PC,PPUSHT	;CAREFUL AC SAVE
ACSAV:	MOV E,-(P)
	MOV D,-(P)
	MOV C,-(P)
	MOV B,-(P)
	MOV A,-(P)
	JMP (F)

CACRES:	JSR PC,PPOPT	;CAREFUL AC RESTORE
ACRES:	TST (P)+
	MOV (P)+,A
	MOV (P)+,B
	MOV (P)+,C
	MOV (P)+,D
	MOV (P)+,E
	RTS F

UACSAV:	MOV A,UACA(U)
	MOV B,UACB(U)
	MOV C,UACC(U)
	MOV D,UACD(U)
	MOV E,UACE(U)
	RTS PC

UACRES:	MOV UACA(U),A
	MOV UACB(U),B
	MOV UACC(U),C
	MOV UACD(U),D
	MOV UACE(U),E
	RTS PC



PPUSHT:	CMP P,#PPUSHL
	BLOS .+4
	RTS PC
	BIT #177000,P	;IS IT THE SYSYTEM PDL?
	BNE .+4
	RTS PC	;YES, IGNORE
	JMP PPSWPO	;PDL REALLY OVERFLOWED

PPOPT:	CMP P,PPOPL
	BHIS .+4
	RTS PC
	JMP PPSWPI

SPUSHT:	SUB #2,S
	CMP S,#SPUSHL
	BLOS .+4
	RTS PC
	JMP SPSWPO

SPOPT:	ADD #2,S
SPOPT1:	CMP S,SPOPL
	BHI .+4
	RTS PC
	JMP SPSWPI

.SPACE:	PRTXT ^\ \
	RTS PC

.CRLF:	.PRTXT <.BYTE 15,0>
	RTS	PC
	.STITL P AND S PDL SWAP OUTERS

PPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	SPUSH B	;SAVE ADDRESS
	SPUSH #PSWPWR
	JSR PC,DSKSEC	;WRITE OUT P-PDL BLOCK
			;FROM (PSWPAD)
			;OUT TO (DBGRBD)
			;DWRTEC
	SPOP IP
	BIT #PPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,PPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #PPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IP,A
	MOV PSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,P
	BHIS .-4
	ADD #PDSWOP,P	;PDL HAS MOVED!
	ADD #PDSWOP,PRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC


SPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	SPUSH B	;SAVE ADDRESS
	SPUSH #SSWPWR
	JSR PC,DSKSEC	;WRITE OUT S-PDL BLOCK
			;FROM (SSWPAD)
			;OUT TO (DBGRBD)
			;DWRTEC
	SPOP IS
	BIT #SPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,SPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #SPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IS,A
	MOV SSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,S
	BHIS .-6
	ADD #PDSWOP,S	;PDL HAS MOVED!
	ADD #PDSWOP,SPRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC

	.STITL P AND S PDL SWAPER INERS
PPSWPI:	BIT #PPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV PSWPAD,A
	MOV A,B
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,P
	BHI .-4
	SUB #PDSWOP,P
	SUB #PDSWOP,PRBAO
	MOV IP,C
	MOV C,DBGRBD
	SPUSH #PSWPRD
	JSR PC,DSKSEC	;READ IN P-PDL BLOCK
			;INTO (PSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #IP,D
	TST (D)
	BNE PSWPI2
	BIC #PPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW,
				; THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,PPOPL
PSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC

SPSWPI:	BIT #SPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV SSWPAD,A
	MOV A,B
	MOV (A),(B)
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,S
	BHI .-6
	SUB #PDSWOP,S
	SUB #PDSWOP,SPRBAO
	MOV IS,C
	MOV C,DBGRBD
	SPUSH #SSWPRD
	JSR PC,DSKSEC	;READ IN S-PDL BLOCK
			;INTO (SSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #IS,D
	TST (D)
	BNE SSWPI2
	BIC #SPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW,
				; THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,SPOPL
SSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC


	.STITL P AND S PDL POPPERS
PPTA:		;POP PP PDL TO (A) RELATIVE
		;USES A,F
	SPOP F
PPTA1:	CMP A,PRBAO
	BHIS PPTA3
	MOV PPOPL,P
	JSR PC,PPSWPI
	BR PPTA1
PPTA3:	SUB PRBAO,A
	SUB #IP,A
	NEG A
	CMP A,P
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,P
	JSR PC,PPOPT
	JMP @F
PSTA:		;POP S PDL TO (A) RELATIVE
		;USES A
	CMP A,SPRBAO
	BHIS PSTA3
	MOV SPOPL,S
	JSR PC,SPSWPI
	BR PSTA
PSTA3:	SUB SPRBAO,A
	SUB #IS,A
	NEG A
	CMP A,S
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,S
	JMP SPOPT1
.STITL INITIALIZE NODE SPACE
;ON ENTRY B = START OF FREE NODES NODE #
;	C = " " " " NODE ADDRESS
;	D = FIRST WORD AFTER END OF SLOT
INIT:	MOV USER,B
	MOV UASIZE(B),C	;SAVE USERS ASIZE
	MOV ASIZE,UASIZE(B)
	MOV ENDWLD,D
	MOV D,B
	SUB C,D	;COMPUTE TOP OF NODESP
	MOV D,NODTOP
	MOV D,A
	ADD #4,A
	SUB A,B
	CMP #20,B
	BGE INIT3
	MOV A,AFREE
	MOV A,AROVER
	CLR (A)+
	MOV B,(A)+
	CLR (A)
	MOV B,ASPACE
INIT3:	MOV #SOFN,B
	MOV #ASOFN,C
INIT4:	INC B
	INC NNGC
	BIT #10000,B	;HIGHEST POSSIBLE NODE ADR + 1
	BNE INIT2
	MOV B,(C)
	BIS #IDLE,(C)+
	CLR (C)+
	CMP D,C
	BHI INIT4
	BR .+8		;BACK UP PREVIOUS NODE IS LAST FREE
INIT2:	MOV #IDLE,(C)+
	CLR (C)+
	MOV NNGC,NNIFSL
	RTS PC

INIT1:	BIS #PADERF,FLAGS2	;SO OCTAL ERROR ADDR IS PRINTED
	JSR PC,SYDRBG	;GET A SYSTEM DISK REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-CLSLTL,(A)+
	MOV #SLOT1,(A)+	;SWAP OUT SLOT1
	MOV DCLRUS,(A)+	;GETS PUT INTO THE CLEAR USER PLACE
	MOV DCLRUS+2,(A)+
	CLRB 1(A)
	TST (A)+
	MOV #DWRTEC,(A)
STARTF:	MOV	NUSERS,NUSER2
	ASL	NUSER2
	JSR PC,SEGSET
	JMP	TINIT

SEGSET:	CLR SSR0
	MOV #KIDR,A
	MOV #20,B
	MOV #77406,(A)+
	SOB B,.-4
	MOV #10,C
SEGST1:	MOV B,20(A)
	MOV B,(A)+
	ADD #200,B
	SOB C,SEGST1
	MOV #SLOTDR,A
	MOV #PUREDR,B
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A),(B)
	MOV #7600,KDAR+16
	MOV #4,SSR3
	MOV #1,SSR0


.IFNZ FPPF
	LDFPS #40300
.ENDC

	RTS PC
	.STITL READ-EVAL LOOP DRIVER (THE ONE-USER MAIN LOOP)

UGO:	JSR PC,RUNME
	MOV USER,A
	BNE UGO2
	JSR PC,IDISKS
	MOV USER,A
UGO2:	ADD #UNAME,A
	MOV #'?+200,(A)
LANGC <	CPRTXT ^/WELCOME TO 11LOGO />,<
	CPRTXT ^/BIENVENUE A 11LOGO />
	.IFNZ FPPF
	PRTXT ^/FPP /
	.ENDC
	MOV LVERNF,A
	JSR PC,PRDN
	TST DEBSW
	BEQ UGO1	;IF DEBUG SWITCH IS ON
		;PRINT MESSAGE
	CPRTXT ^/LOGO BEING DEBUGGED!/
UGO1:	LANGC <PRTXT ^/ USER # />,<
	PRTXT ^/ UTILISATEUR # />
UGODBG:
	CLR A
	MOV USER,B
	DIV #LUBLK,A
	JSR PC,PRDN
	PRCR		;PRINT CR
	JSR PC,INIT
	MOV #DESSAV,E
	JSR PC,DIRSER
	BEQ MLOOP
	TST DEBSW
	BNE MLOOP
	JSR PC,.REDF4
	JSR PC,.POF1
MLOOP:	JSR	PC,UCHECK	;CHECK SOME USER VARIABLES
	JSR PC,SCHEDP
	BIC #HERRF,FLAGS2
	MOV	USER,U
	TST BRAKE(U)
	BEQ .+4
	ERROR+BRK
	JSR PC,GETSTR
	JSR PC,MREAD
	BEQ MLOOP	;NO TOKEN LIST
	JSR PC,EVLINE
	BEQ MWDW
	POPS A
	BR MLOOP
MWDW:	ERROR+WDW	;WHAT SHOULD I DOO WITH (S)

RUNRUG:	JSR PC,CKSST
	BPT
	SEZ
	RTS PC

SYSJOB:	JSR PC,FLUSH
	BR SYSJOB


;CHECK SOME USER VARIALBES -- DEBUGGING FEATURE
UCHECK:	TST	NODESP
	BNE	UCHEC1
	TST	NODESP+2
	BEQ	UCHEC2
UCHEC1:	TST	(P)+	;POP STACK SO IT LOOKS LIKE BUG CAME FROM CALLING ROUTINE
	.BUG.	;1ST 2 WORDS OF NODE SPACE NOT ZERO
UCHEC2:	RTS	PC
	.STITL GET A STRING
GSTR4:	PUSHS C
	PUSH GCHR
	SPUSH PCHR
	SPUSH PRMTCH
	CLR PRMTCH
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	JSR PC,.LOADC
	PUSHS B
	JSR PC,PRLN
	POPS B
	JSR PC,RDSTR
	BEQ GSTR5
GSTR7:	POPS A		;IGNORE ANY LINE TYPED IN
GSTR10:	POP PRMTCH
	SPOP PCHR
	SPOP GCHR
	POPS C
	JSR PC,.LOADC
	JSR PC,.LOADB	;PUT THINGS BACK AS THEY WERE
	BR GSTR3

GSTR5:	BIT #RBRKF,TFLAGS
	BEQ GSTR10
	POP PRMTCH
	ERROR+BRK
GETSTR:	TST FUNLEV	;ARE WE IN A PROC
	BEQ GSTR0	;NO
	BIT #BRKF,FLAGS	;ERROR, MAYBE
	BNE GSTR0	;YES
	MOV CLP,B	;NO, GET THIS NODE OF LLP
	BEQ GSTR9
	JSR PC,.LOAD
	BIT #7777,A	;IS IT LAST NODE
	BNE GSTR8
	SPOP A		;POP RETURN ADDR
	JMP PSTOP

GSTR9:	MOV CPLN,B
	JSR PC,GTLINE
	BNE .+4
	ERROR+LDE	;LINE ..(B).. DOESN'T EXIST
	MOV C,A
GSTR8:	CLR CLP
	MOV A,C
	JSR PC,.LOADC
	JSR PC,.LOAD	;OK, GET FIRST NODE OF LINE, = LINE #
	MOV B,CPLN
	BIT #TPSF,FLAGS
	BNE GSTR4
GSTR3:	MOV C,CLP
	MOV A,CTP	;IN CASE THERE IS NO GENERATION #
	MOV A,C
	JSR PC,.LOADC	;GET SECOND NODE
	CLR CLGN	; IF TYPE = SNUM, IT IS GEN #
	MOV A,C
	BIC #7777,C
	CMP #SNUM,C
	BNE GSTR6
	MOV B,CLGN	;IT IS
	MOV A,CTP
GSTR6:	BIS #LIST,CTP
	PUSHS CTP
	BIT #TRACEF,FLAGS2
	BEQ GSTRT
	CPRTXT ^\ #\
	MOV CPP,B
	JSR PC,PPNAME	;PRINT PNAME
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRCR
	JSR PC,PRLN
	PRCR
GSTRT:	RTS PC


GSTR0:
GSTR1:	JSR PC,RDSTR
	BNE GSTRT
GSTR2:	BIT #RBRKF,TFLAGS
	BEQ GSTR1
	ERROR+BRK
	.STITL MORE READ ROUTINES!!!
MREAD:	TST FUNLEV	;ARE WE IN PROC?
	BEQ MRD1	;NO
	BIT #BRKF,FLAGS	;YES, BUT ERROR?
	BEQ MRD3
MRD1:	CLR ILINEL
	JSR PC,READ	;CONVERT CHAR STRING TO TOKEN LIST
	BEQ MRD4	;NO TOKENS
	MOV @S,ILINEL
MRD3:	CLZ
MRD4:	RTS PC

CKSTG:	;CKECK IF DISC OR NODES ARE ALMOST GONE
	BIT #DSAMFL,FLAGS2
	BNE CKSTG1
	CMP NNIFSL,#NBN
	BHIS MRD4
	JSR PC,.GCOLL
	CMP NNIFSL,#NBN
	BHIS MRD4
CKSTG1:	CLR ERPROC
	ERROR+NSL
	.STITL EVAL 1 LINE

EVLINE:	MOV	USER,U	;EVALUATES 1 LINE ON S
	TST	BRAKE(U)
	BEQ .+4
	ERROR+BRK
	TST TOPRNM
	BNE EVLI4
EVLI6:	BIC #EVIFS,FLAGS
	CLR CO
	CLR CO+2
	CLR NOR
	CLR COF
	CLR LO
	CLR LO+2
	JSR PC,IGNT
EVLI1:	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,EVAL
	BEQ EVLI3	;NO OUTPUT, OK
	JSR PC,CKSTG
	SEZ
	RTS PC
EVLI3:	JSR PC,CKSTG
	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,GNT
	BIS #RTF,FLAGS
	BR EVLI1
EVLI4:	JSR PC,CKSTG
	MOV @S,B
	JSR PC,.LOAD
	MOV A,D
	BIC #7777,A
	CMP #SNUM,A
	BEQ EVLI5	;AN SNUM
	CMP #INUM,A
	BEQ EVLI8	;AN INUM
	CMP #LSTR,A
	BNE EVLI6	;NOT AN SNUM, INUM OR LSTR
	JSR PC,.CLSIN	;CONVERT LSTR TO INUM
	BEQ EVLI6	;NOT NO. OR TOO BIG
EVLI8:	BIT #SPDF,FLAGS	;IS THIS PROC DEF. BEING SKIPPED?
	BNE EVLI2
	JSR PC,.CINSN	;CONVERT INUM TO SNUM
	BEQ EVLI7	;TOO BIG
	TST B	;IS NO. TOO SMALL?
	BGT .+4
	ERROR+LNTS
	MOV D,A
	BIC #170000,A	;MAKE IT INTO AN SNUM
	BIS #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	MOV C,@S
EVLI5:	JSR PC,ADLN
EVLI2:	CLZ
	RTS PC
EVLI7:	ERROR+LNTB	;LINE # TOO BIG
	.STITL GET NEXT TOKEN

GNT:	MOV CT,A
	MOV CT+2,B
	BIT #RTF,FLAGS	;IS REPEAT TOKEN FLAG SET?
	BEQ GNT1
	BIC #RTF,FLAGS	;YES
	CMP #SFUN,A
	BNE GNT6
	TST B
	BNE GNT6
	BIS #CRF,FLAGS
GNT6:	RTS PC
GNT1:	BIC #PTLPF,FLAGS
	CMP #$LLPAR,B	;IS CT "("
	BEQ GNT3
	CMP #$LPAR,B
	BNE GNT3A
GNT3:	BIS #PTLPF,FLAGS	;YES, SET PTLPF
GNT3A:	MOV A,CTP	;GET LINK TO NEXT TOKEN
	BIT #7777,A
	BEQ GNT2	;ANY TOKENS LEFT
	JSR PC,.LOADA	;YES
	INC CTN
GNT3B:	CMP #$COMT,B
	BEQ SKPCOM
GNT4:	MOV A,CT
	MOV B,CT+2
	RTS PC
GNT2:	BIT #CRF,FLAGS
	BNE GNT5
	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR GNT4
GNT5:	ERROR+OOT	;OUT OF TOKENS
SKPCOM:	MOV A,CTP	;SKIP OVER A COMMENT
	BIT #7777,A
	BEQ GNT2	;END ON CR FOUND
	JSR PC,.LOADA
	INC CTN
	CMP #$COMT,B
	BNE SKPCOM	;DON'T STOP TILL CR OR CLOSING "!"
	BR GNT3A	;RETURN TOKEN AFTER CLOSING "!"

IGNT:	MOV @S,B	;INIT "GNT"
	BIT #7777,B
	BEQ IGNT1
	BIC #CRF,FLAGS
	MOV B,CTP
	JSR PC,.LOAD
IGNT2:	MOV A,CT
	MOV B,CT+2
	BIS #RTF,FLAGS
	MOV #1,CTN
	BR GNT3B
IGNT1:	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR IGNT2
	.STITL LOGO TYI/O
UTYI:	WAIT
	TST CHI
	BEQ UTYI
	MOVB CHI,D
	CLR	CHI
	BIC #177600,D
TYO:	JMP @ITYO

TYI:	JMP @ITYI
STYI:	WAIT
	TSTB TKS
	BPL STYI
	MOVB TKB,D
	BIC #177600,D
STYO:
UTYO:	TSTB TPS
	BPL .-4
	MOVB D,TPB
	CMP #15,D
	BNE UTYOR
	MOV #12,D
	JSR PC,STYO
	MOV #15,D
UTYOR:	RTS PC

;SPRINT-- START SYSTEM PRINT.  CALL WITH JSR A,
SPRINT:	SPUSH	USER
	SPUSH PCHR
	MOV	#-1,USER
	MOV #STYO,PCHR
	JMP	(A)
SPEND:	TST (P)+
	SPOP PCHR
	SPOP USER
	RTS A

;PRINT LOCATIONS ON SYSTEM CONSOLE
;CALL WITH
;	MOV #WDLIST,B
;	JSR PC,PLOCS
;WHERE	WDLIST:	LOCS TO BE PRINTED
;		0
PLOCS:	JSR	A,SPRINT	;START SYS PRINT
	BPRTXT	;RING BELL, C.R.
PLOCS1:	JSR	PC,PLOC
	TST	(B)+
	TST	(B)
	BNE	PLOCS1
	SPREND	;END SYSTEM PRINT
	RTS	PC

;PRINT (B)/ @(B)
PLOC:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	(B),U
PLOC1:	MOV	(U),D
	JSR	PC,PGEN1	;PRINT (U)/ (D)
	SPOP	U
	SPOP	D
	SPOP	A
	RTS	PC

;PRINT B/(B)
PLOCB:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	B,U
	BR	PLOC1
	.STITL	GARBAGE COLLECTOR
NNODES==4096.
GCBTL== NNODES/8./2.*2.	;GARBAGE COLLECT BIT TABLE LENGTH

MARKNI:	SPUSH A
	SPUSH B
	BR MARKN4
MARKN:	SPUSH A	;MARK NODE(B)
	SPUSH B
;DEBUGGING FEATURE
	JSR PC,.LOAD	;ARE WE MARKING AN IDLE NODE
	BIC #7777,A
	CMP #IDLE,A
	BNE .+4
	.BUG.
	MOV (P),B
;
MARKN4:	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;ALREADY MARKED?
	BEQ MARKN1	;NO
MARKN3:	SPOP B
	SPOP A
	SEZ
	RTS PC
MARKN1:	BISB B,(A)
MARKN2:	SPOP B
	SPOP A
	CLZ
	RTS PC
MARKDN:	;SKIP IF NODE (B) IS MARKED
	SPUSH A
	SPUSH B
	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;MARKED?
	BEQ MARKN3	;NO
	BR MARKN2	;YES-SKIP

MARKL:	PUSH A	;MARK LIST
	SPUSH B	;NODE ADDS IN B
	SPUSH C
	JSR	PC,MKLIST
	BR MARKV1

MARKV:	PUSH	A	;MARK VARIABLE
	SPUSH	B	;NODE ADDS IN B
	SPUSH	C
	CLR	A
	MOV	B,C
	JSR	PC,MARKF1	;TREAT POINTER AS A FIRST PTR
MARKV1:	SPOP C
	SPOP B
	POP A
MARKV2:	RTS PC

MARKF:	MOV A,C	;MARK FIRST OF A DATUM (NODE) IN A,,B
MARKF1:	BIT #DSAMFL,FLAGS2
	BEQ MARKF2	;DISK NOT ALMOST FULL
	TST FILFLG
	BEQ MARKF3
	MOV #DREADC,E
	JSR PC,GBITGS	;SET DISK BUFFER BACK UP
MARKF3:	TST SSAVEA	;TOP OF SPDL SWAPPED OUT FOR MARKING?
	BEQ MARKF4	;NO
	SPUSH #SSAVRD
	JSR PC,DSKSEC	;YES, SWAP IT BACK IN
			;INTO (SSWPAD)
			;FROM (SSAVEA) WHERE GCOLL PUTS IT
			;DREADC
	MOV SSAVEA,C	;FREE THE REQUEST BLOCK
	CLR SSAVEA	;CLEAR THIS: IT WORKS AS A FLAG
	JSR PC,UBLKFR	;(NOW FREE IT)
MARKF4:	CLR ERPROC
	.IFNZ NDISP
	ADD #2,S	;POP SNLIST OFF S PDL
	.ENDC
	ERROR+NSL
MARKF2:	BIC	#7777,C	;A TELLS WHAT TYPE OF DATUM IT IS
	SWAB	C
	ASR	C
	ASR	C
	ASR	C	;ALL THIS GIVES YOU THE TYPE*2
	JMP	@LMT(C)	;WHICH YOU MIGHT MARK ON

	.IFNZ NDISP
MKSNAP:	JSR	PC,MKDC	;MARK DISPLAY CODE
	.ENDC
MKLIST:	BIT	#7777,B	;IS THIS NODE REALLY HERE?
	BEQ	MARKV2	;NO. RETURN
MKL1:	PUSH	A	;SAVE BUTFIRST OF CURRENT (I.E. PARENT) NODE
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MKL2
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	JSR	PC,MARKBF	;MARK BUTFIRST OF  NEWTHIS NODE
MKL2:	POP A
	RTS PC

MKATOM:		;MARK ATOM CELL BUT NOTHING INSIDE IT
MKINUM:	JMP MARKNI

GCDIE:	ERROR+FBUG

MARKBF:	BIT	#7777,A	;MARK BUTFIRST OF LIST
	BEQ	MARKV2	;AT END OF LIST
MKBF1:	MOV	A,B
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MARKV2	;ALREADY MARKED, QUIT
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	BR	MARKBF	;MARK BUTFIRST OF  NEW NODE

GCOLL:.GCOLL:	JSR F,ACSAV
	PUSH GNCN
	SPUSH GNCN+2
	SPUSH TMPBLK
	MOV USER,U
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
;	TST FILFLG
;	BEQ .GCOL2
;	MOV #DWRTEC,E
;	JSR PC,GBITGS	;SAVE THE BUFFERS
.GCOL2:	MOV #GCBITS,A	;GARBAGE COLLECT
	MOV #GCBTL/2-1,B	;CLEAR BIT TABLE
	MOV #1,(A)+	;ALWAYS PROTECT NODE ZERO
.GCOL1:	CLR (A)+
	DEC B
	BGT .GCOL1
	CLR SSAVEA	;MAKE SURE THIS IS CLEAR
;NOW MARK EVERYTHING POINTED BY OBLIST.  DONT MARK OBLIST NODES YET
	JSR PC,GNOLEI
MKUOBJ:	JSR PC,GNOLE	;GET NEXT UOE PTR
	BEQ MKTPS
	MOV B,C
	JSR PC,.LOADC	;GET THE NODE
	MOV A,C
MKUOE:	BIT #7777,C	;ONE OTHER NODE?
	BEQ MKUOBJ	;NO
	MOV C,B	;YES
	JSR PC,MARKN	;MARK IT
	JSR PC,.LOADC
	MOV A,C
	BIC #7777,A
	CMP #FBIND,A
	BEQ MKFB	;FUNCTION BINDING
	CMP #VBIND,A
	BEQ MKVB	;VARIABLE BINDING
	CMP #ABIND,A
	BEQ MKARR
	CMP #SVBIND,A
	BEQ MKSVB	;SWAPPED VB
	.BUG.		;BUG
MKVB:	JSR PC,MARKV	;MARK VARIABLE
	BR MKUOE
MKFB:	JSR PC,MARKL
	BR MKUOE
MKSVB:	BR MKUOE
MKARR:	TSTB 5(B)	;IS IT A POINTER ARRAY?
	BNE MKUOE
	MOV B,F		;POINT TO BEG OF ARRAY
	MOV 2(B),-(P)	;PUSH COUNT
	SUB #HEADER,(P)
	ASR (P)
	ADD #HEADER,F
MKAR1:	MOV (F)+,B
	JSR PC,MARKV
	DEC (P)
	BNE MKAR1
	TST (P)+
	BR MKUOE

	;MARK FROM GCMKL LIST
MKTPS:	MOV #GCMKL,F
MKRNDM:	MOV (F)+,B	;POINTER TO POINTER
	BEQ MKSPDL	;LAST ONE
	MOV (B),B	;REAL NODE ADDRESS
	BEQ MKRNDM	;NOTHING THERE
	BIT #170000,B	;IS TYPE FIELD BLANK
	BEQ MKRND1	;YES, MAKE IT LIKE LIST
	JSR PC,MARKV	;MARK VARIABLE
	BR MKRNDM
MKRND1:	JSR PC,MKL1
	BR MKRNDM
	;MARK FROM S PDL
MKSPDL:	MOV #IS,E
MKSP1:	MOV -(E),B	;GET A S PDL WORD
	CMP E,S	;END OF S PDL?
	BLO MKSP2	;YES
	JSR PC,MARKV	;MARK S PDL WORD
	BR MKSP1
MKSP2:	TST IS
	BEQ MKSP4
MKSP3:	JSR PC,UBLKGR
	MOV B,SSAVEA
	SPUSH #SSAVWR
	JSR PC,DSKSEC	;SAVE TOP OF S-PDL ON DISK
			;FROM (SSWPAD)
			;OUT TO (SSAVEA)
			;DWRTEC
MKSP8:	TST IS
	BEQ MKSP6	;NO
MKSP5:	MOV IS,DBGRBD
	SPUSH #SSWPRD
	JSR PC,DSKSEC	;GET NEXT PIECE OF S-PDL
			;INTO(SSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #176,F
	MOV #IS,E
MKSP7:	MOV -(E),B	;MARK THIS PIECE OF S PDL
	JSR PC,MARKV
	DEC F
	BGT MKSP7
	BR MKSP8

MKSP6:	SPUSH #SSAVRD
	JSR PC,DSKSEC	;RESTORE TOP OF S-PDL
			;INTO (SSWPAD)
			;FROM (SSAVEA)
			;DREADC
	MOV SSAVEA,C
	CLR SSAVEA	;SWAPPED BACK IN
	JSR PC,UBLKFR
MKSP4:
;OK, NOW MARK ALL UOE'S THAT POINT TO FUNCION OR VARIABLE BINDING
	JSR PC,GNOLEI
MKOBL:	JSR PC,GNOLE	;GET NEXT UOE PTR IN B
	BEQ MKOBL6	;NONE LEFT
	MOV B,C
	JSR PC,.LOADC	;GET THE PNAME NODE
	MOV B,D
	BIT #7777,A	;DOES IT POINT TO ANYTHING?
	BNE MKOBL2	;YES, MARK IT
	MOV C,B	;NO WAS IT MARKED?
	JSR PC,MARKDN
	BEQ MKOBL3	;NO - LINK IT OUT
	BR MKOBL7	;YES - ALSO MARK PNAME & BUCKET PTR
MKOBL2:	; - MARK THE UOE ETC.
	MOV C,B	;  -THE UOE NODE
	JSR PC,MARKN
MKOBL7:	MOV D,B	;  -THE PNAME LSTR
	JSR PC,MARKL
	MOV GNCN+2,B	;  -THE BUCKET LIST NODE
	JSR PC,MARKN
	BR MKOBL
	;THIS UOE IS NOT MARKED AND POINTS TO NOTHING - LINK IT OUT
MKOBL3:	MOV TMPBLK,C	;GET PTR TO PREDECESSOR NODE
	BNE MKOBL4	;NONE, SO UHCT WAS PRED.
	MOV GNCN,-2(E)	;SO CHANGE IT
	BR MKOBL5
MKOBL4:	MOV GNCN,A	;CHANGE PTR IN PRED NODE
	JSR PC,.STP1
MKOBL5:	MOV C,GNCN+2	;SO GNOLE WILL WORK
	BR MKOBL
MKOBL6:



	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;IF GUY HAS DISPLAY
	BEQ	GCDIS2
	JSR PC,DSGCF		;GCOLL IT, TOO
GCDIS2:
GCDIS:
	.ENDC


		;OK NOW RETURN ALL IN MARKED NODES
		;RA ADDS OF LIT MAP
		;RB NODE ADDS
		;RC ACTUAL ADDER OF NODE
		;RD BIT MAP
		;RE POINT TO LIST OF FREE STORAGE RECYCLED NODES
		;RF NUMBER NODES LEFT TO CHECK
		;START COLLECTING AT LUNN(LOWEST UNPROTECTED NODE #)
	CLR E
	CLR NNGC
	MOV #NODESP,C	;NODE ZERO ADDRESS
	MOV NODTOP,F
	SUB C,F		;COMPUTE LEGNTH OF NODESP
	ASR F
	ASR F		;COMPUTE NUMBER OF NODES
	CLR B		;NODE ZERO
	MOV #GCBITS,A	;BIT TABLE ADDR
GCRT2A:	MOV (A)+,D	;GET NEXT WORD OF BIT MAP
	SEC
	ROR D

GCRT2:	BCS GCRT3
	CMP B,#LUNN
	BLOS GCRT3
	TST E		;WE HAVE A FREE NODE; IS FIRST FREE FOUND?
	BNE GCRT2B
	MOV B,FREE	;NO, THIS IS IT
	BR GCRT2C	;(NO LAST-FREE TO UPDATE)

GCRT2B:	BIS B,(E)	;ELSE: POINT LAST-FREE TO THIS NODE
GCRT2C:	MOV C,E		;THIS NODE IS NEW LAST-FREE
	MOV #IDLE,(C)+	;MAKE NEW IDLE NODE, POINTS NOWHERE
	CLR (C)+
	INC NNGC
	BR GCRT4
GCRT3:	CMP (C)+,(C)+
GCRT4:	INC B
	DEC F
	BLE GCRT5
	CLC
	ROR D
	BNE GCRT2
	BR GCRT2A
GCRT5:	MOV NNGC,NNIFSL
;DEBUGGING FEATURE
	BIT #PNNLF,FLAGS2
	BEQ GCRT6
	CPRTXT ^/[NODES LEFT /
	MOV NNGC,A
	JSR PC,PRDN
	PRTXTC ^/ ]/
;
GCRT6:
;	TST FILFLG
;	BEQ GCRT7	;NO
;	MOV #DREADC,E
;	JSR PC,GBITGS	;GET BACK THE BUFFERS
GCRT7:	POP TMPBLK
	SPOP GNCN+2
	SPOP GNCN
	JSR F,ACRES
	SEZ
	RTS PC

GBITGS:	MOV USER,U
	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+
	MOV #-DBUFL/2,(A)+
	MOV #GCBITS-PURE,(A)
	MOV SLOTAS(U),B
	MOV SLOTHA(B),C
	ADD SLOTCA(B),(A)+
	ADC C
	ASH #4,C
	MOVB C,6(A)
	MOV UDBFSV(U),(A)+
	MOV UDBFSV+2(U),(A)+
	TST (A)+
	BIS E,(A)
	JMP DSKWAI
	.STITL GET NEXT OBLIST ELEMENT
GNOLE:		;GET NEXT USER OBLIST ELEMENT - PTR
		;INPUT - VIA GNOLEI
		;OUTPUT - PTR TO THIS BUCKET IN B & GNCN
		;	   " " NEXT " " GNCN+2
		;	   " " PRED " " TMPBLK
		;	   IF NO PREV BUCKET, TMPBLK = 0
		;USES E.  SKIPS UNTIL NO UOE PTRS LEFT
	PUSH A
	MOV GNCN,B
	MOV GNCN+2,TMPBLK
GNOLE2:	MOV B,GNCN+2
	BIC #170000,B
	BEQ GNOLE1
	JSR PC,.LOAD	;GET NEXT PTR ON BUCKEN LIST
	MOV A,GNCN
	JMP SRETA
GNOLE1:	CLR TMPBLK
	MOV (E)+,B	;GET NEXT BUCKET LIST
	BGE GNOLE2
	JMP RETA	;DONE
GNOLEI:	MOV #UHCT,E
	CLR GNCN
	RTS PC
