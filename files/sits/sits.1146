.ABS
VERN==%FNAM2
%COMPAT==0		;SUPRESS INCOMPATABLE OP-CODE MESSAGES
NP==0		;NEW PAGING STUFF
.IIF P1,.IIF NZ NP,.PRINT /!! NP NOT ZERO !!
/
NTKDIS==5
NTVS==0
NTVCHN==0
.INSRT SITS;SITMAC >
;FLASK ^/1=> TVS, 0=> NONE/,TVS
TVS==1
.IFNZ TVS
NTVS==32.
NTVCHN==4
.ENDC
	.SBTTL INTERNAL REGISTER DEFINITIONS
.XCREF FOO,FOOBAR
;MEMORY SEGMENTATION UNIT
SSR0=177572
SSR1=177574
SSR2=177576
SSR3=172516
USRISD=177600
USRDSD=177620
USRISA=177640
USRDSA=177660
SUPISD=172200
SUPDSD=172220
SUPISA=172240
SUPDSA=172260
KERISD=172300
KERDSD=172320
KERISA=172340
KERDSA=172360

;SEGMENTATION REGISTER DEFINITION
SEGNRA==100000		;SEGMENTATION NON RESIDENT ABORT
SEGSLE==40000		;SEGMENT LENGTH ERROR
SEGRVI==20000		;READ ONLY VIOLATION
SEGTRP==10000		;SEGMENTATION TRAP
SEGPMO==177637		;PAGE MODE THAT CAUSED TRAP
SEGKER==0		;KERNEL MODE
SEGUSR==140		;USER MODE
SEGPNO==177741		;THE PAGE NO. MASK

;CONSOLE SWITCHES AND DISPLAY
CDISP=177570
CSWR=177570

;PROGRAM INTERUPT REQUEST REGISTER
PIRQ=177772

;STACK LIMIT REGISTER
STKLIM=177774

;PROCESSOR STATUS
PS=177776

;START OF PARITY REGISTERS
PARCSR=172100

RUGST==157000		;RUG STARTING LOCATION
;KERNAL MAP REGISTERS
I0AR=KERISA
I1AR=I0AR+2
I2AR=I1AR+2
I3AR=I2AR+2
I4AR=I3AR+2
I5AR=I4AR+2
I6AR=I5AR+2
I7AR=I6AR+2
RUGIAR=I6AR

I0DR=KERISD
I1DR=I0DR+2
I2DR=I1DR+2
I3DR=I2DR+2
I4DR=I3DR+2
I5DR=I4DR+2
I6DR=I5DR+2
I7DR=I6DR+2
RUGIDR=I6DR

VAR0AR=KERDSA
VAR1AR=VAR0AR+2
VAR2AR=VAR1AR+2
ITM0AR=VAR2AR+2
ITM1AR=ITM0AR+2
ITM2AR=ITM1AR+2
RUGDAR=ITM2AR+2
IOAR=RUGDAR+2

VAR0DR=KERDSD
VAR1DR=VAR0DR+2
VAR2DR=VAR1DR+2
ITM0DR=VAR2DR+2
ITM1DR=ITM0DR+2
ITM2DR=ITM1DR+2
RUGDDR=ITM2DR+2
IODR=RUGDDR+2

;INTERNAL TRAP VECTORS
BEBRV=4
ILLBRV=10
BPTBRV=14
IOTBRV=20
PWFBRV=24
EMTBRV=30
TRPBRV=34
PARBRV=114
PIRBRV=240
FPPBRV=244
SEGBRV=250
	.SBTTL DEVICE DEFINITIONS
;RF11 FIXED HEAD DISK
RFCS=177460	;CONTROL AND STATUS
RFWC=177462	;WORD COUNT
RFBA=177464	;BUSS ADDRESS
RFDA=177466	;DISK ADDRESS (LOW PART)
RFDAE=177470	;HIGH PART OF ADDRESS AND ERROR REGISTER
RFBRV=204

;RK11 MOVING HEAD DISK
RKDS=177400	;DRIVE STATUS REGISTER
RKER=177402	;ERROR REGISTER
RKCS=177404	;CONTROL AND STATUS REGISTER
RKWC=177406	;WORD COUNT
RKBA=177410	;BUSS ADDRESS
RKDA=177412	;DISK ADDRESS
RKBRV=220

;CONSOLE TELETYPE
;BREAK LEVEL 4
TKBRV=60	;CONSOLE KEYBOARD BREAK VECTOR
TKS=177560	;CONSOLE KEYBOARD STATUS
TKB=177562	;CONSOLE KEYBOARD DATA
TPBRV=64	;CONSOLE PRINTER BREAK VECTOR
TPS=177564	;CONSOLE PRINTER STATUS
TPB=177566	;CONSOLE PRINTER DATA


;PROGRAMMABLE CLOCK KW11-P
PCCS=172540	;CONTROL AND STATUS
PCCB=172542	;COUNT SET BUFFER
PCCN=172544	;COUNTER
PCBRV=104	;INTERUPT VECTOR

;LINE FEQUENCY CLOCK KW11-L
LCCS=177546	;CONTROL AND STATUS
LCBRV=100	;INTERUPT VECTOR

;TK DISPLAY
NGCSR=164040	;CONTROL AND STATUS
NGREL=164042	;RELOCATION

;PAPER TAPE PUNCH AND READER
PTRSR=177550	;PAPER TAPE READER STATUS
PTRBR=177552	;PAPER TAPE READER BUFFER
PTPSR=177554	;PAPER TAPE PUNCH STATUS
PTPBR=177556	;PAPER TAPE PUNCH BUFFER
PTRBRV=70	;VECTOR FOR READER
PTPBRV=74	;VECTOR FOR PUNCH
.SBTTL MACROS FOR DEFINING VARIOUS THINGS

;MACRO TO INITIALIZE DEFINITION OF SOME RANDOM THING
.MACRO DTHING
FOO==0
.ENDM

;MACRO TO DEFINE A WORD FOR SOME RANDOM THING
.MACRO DWORD A,B
.IIF P1,.IIF DF A,.ERROR A ALREADY DEFINED
A==FOO
.IF NB B
.IIF P1,.IIF DF B,.ERROR B ALREADY DEFINED
B==FOO+1
.ENDC
FOO==FOO+2
.ENDM

;MACRO TO INIT THE DEFINITION OF RANDOM FLAGS
.MACRO DFLAGS
BAR==1
.ENDM

;MACRO TO DEFINE A RANDOM FLAG BIT
.MACRO DFLAG FLAG
.IIF P1,.IIF DF FLAG,.ERROR FLAG ALREADY DEFINED
.IIF Z BAR,.ERROR FLAG TOO MANY FLAGS
FLAG==BAR
BAR==BAR_1
.ENDM

;MACRO TO ADD SOMETHING TO A REMOTE MACRO
.MACRO ADDMAC MAC,STUFF
MAC <
.MACRO MAC A,B,C
A>,<STUFF>,<B
C
.ENDM>
.ENDM

;MACRO FOR THE INITLS TABLE
.MACRO INITSL A,B,C
A
INITLS:
B
C
.ENDM

;MACRO FOR STORAGE ALLOCATION OF LIST SPACE
.MACRO LSTSTO A,B,C
A
LISTST:
B
C
.ENDM

.MACRO ALSTM FREENM,TABNAM,LENGTH,NUM
ADDMAC LSTSTO,<FREENM:	0
.IIF NB TABNAM,TABNAM:
.BLKB LENGTH*NUM
AILSTM FREENM,NUM,LENGTH>
.ENDM

.MACRO AILSTM FREENM,NUM,LENGTH
ADDMAC INITSL,<ILIST FREENM+2,FREENM,NUM,LENGTH>
.ENDM

;MACRO TO DEFINE A LIST STORAGE AREA
.MACRO ILISTS FREENM,TABNAM,NUM
ALSTM FREENM,TABNAM,\FOO,NUM
.ENDM


	.SBTTL SYSTEM PARAMETERS

;GENERALIZED ITEM POINTER DEFINITION
GIPBIT==100000	;SET IF IT IS A GENERALIZED ITEM POINTER
GIPSPR==40000	;BIT SET IF UPT IS IN A SPHERE
GIPITM==176000	;MASK FOR ITEM INDEX
GIPUPT==141777	;MASK FOR UPT NUMBER (IN SPHERE)
GIPFUP==140000	;MASK FOR FLOATING UPT TABLE OFFSET

;FOR THE ITEM LIST
NITEMS==255.	;MAXIMUM NUMBER OF ITEMS
NITMBL==8.	;MAXIMUM NUMBER OF BLOCKS ALLOCATED TO ITEM STROAGE
NITMPS==10	;MAXIMUM DEPTH OF ITEM PUSHES
NITALS==NITMBL*64.	;NUMBER OF FREE STROAGE NODES
		;CURRENTLY ALLOCATED FOR THE WORST CASE
;DEFINITION OF AN ITEM TABLE ENTRY
DTHING
DWORD ITLINK	;LINK WORD FOR FREE ENTRIES
ITMADR==ITLINK	;WHERE THE ADDRES OF THE ITEM IS KEPT
DWORD ITACCS,ITLNGT	;ACCESS CODE, LENGTH
ILISTS ITMFRE,ITMTAB,NITEMS
ITMTEL==FOO
ITACCD==6	;ITEM ACCESS CODE (READ-WRITE NO TRAP)

;ADDRESSES OF THE ITEM SLOTS
ITM0AD==<ITM0AR-KERDSA>_12.
ITM1AD==<ITM1AR-KERDSA>_12.
ITM2AD==<ITM2AR-KERDSA>_12.

;PROCESS AND USER PARAMETERS
NPROSS==80.	;MAXIMUM NUMBER OF PROCESSES AND USERS
PRPDLL==96.	;LENGTH OF THE PDL FOR THE PROCESS
;DEFINITION OF A PROCESS TABLE ENTRY
PRSTEL==14	;LENGTH OF A PROCESS TABLE ENTRY
PRTFRD==0	;FORWARD POINTER
PRTBCK==2	;BACK POINTER
PRTPPT==4	;PROCESS POINTER (OR TO ITEM IF USER)
PRTUPT==6	;USER POINTER (-1 FOR USER)
PRTJTM==10	;JTMU
PRTPRI==12	;HIS PRIORITY

;SPHERE PARAMTERS
MNCLSE==200	;MAXIMUM NUMBER OF C-LIST ENTRIES
NCLSEB==10	;NUMBER OF C-LIST ENTRIES PER BLOCK
CLSELN==12	;LENGTH OF A C-LIST ENTRY (NOTE THAT THE LENGTH OF A BLOCK=NCLSEB*CLSELN, WHATEVER IT IS)
;DEFINITION OF A C-LIST ENTRY
CLSETY==0	;TYPE
CLSEPI==2	;PRIMARY ITEM FOR ENTRY
CLSESI==4	;SECONDARY ITEM FOR ENTRY
CLSEM0==6	;FIRST RANDOM WORD FOR ENTRY
CLSEM1==10	;SECOND RANDOM WORD
.IFZ NP
;UPT ENTRY DEFINITION
UPTLEN==10	;LENGTH OF A UPT ENTRY
UPTDR==0	;DESCRIPTOR REGISTER (DON'T CHANGE!)
UPTDEI==100000	;THE DATA=INSTRUCTION BIT
UPMLRE==107777	;MASK FOR LEGNTH OF REFERENCED ENTRY
UPMSRE==174377	;MASK FOR START OF REFERENCED ENTRY
UPTACB==200	;TRAP OCCURED ON THIS PAGE
UPTWON==100	;PAGE MODIFIED AND NOT CORRECT AT SOURCE BIT
UPTMOD==40	;THE PAGE MODIFIED AND NOT CORRECT AT SWAP SPACE BIT
UPTNEW==20	;THE PAGE JUST CAME FROM SOURCE, (NOT CORRECT AT SWAP SPACE)
UPTEXP==10	;PAGE EXPANSION BIT (SET IF DOWNWARD EXPANSION)
UPTSMS==107460	;MASK TO CONVERT CONTENTS OF UPTDR FOR SEGMENTER
UPTSRT==1	;BOTTOM THREE BITS ARE START
UPTAR==2	;THE AR FOR THE SEGEMENT
UPTABT==100000	;THE ABSOLUTE PAGE BIT
UPTICR==10	;THE IN CORE BIT
UPASMS==170017	;THE MASK FOR THE ADDRESS FIELD
UPMSSW==177770	;MASK FOR START OF AREA TO BE SWAPPED
UPMLSW==107777	;MASK FOR LENGTH OF AREA TO BE SWAPPED
UPTCLP==4	;THE CIRCULAR LIST POINTER (GIP)
UPTFPT==6	;THE SWAP ADDRESS OR FPT POINTER (IF 100000 BIT SET)
;FORMAT OF A UPT SWAP ADDRESS (DON'T CHANGE THESE DEFINITIONS)
UPTLSB==1	;SET IF LARGE SWAP BLOCK
UPTBTM==177761	;BIT TABLE MASK
UPTBOM==100017	;OFFSET INTO BIT TABLE MASK
.ENDC
;THESE ARE FOR THE .RDMAP CALL
.PLENM==177770	;MASK FOR THE LENGTH OF THE PAGE
.PACCM==174377	;MASK FOR THE ACCESS
.PDEI==100000	;BIT FOR DATA = I PAGE
.PABS==40000	;BIT FOR ABSOLUTE PAGE
.PFIL==2000	;BIT FOR FILE PAGE


.IFZ NP
;FPT ENTRY DEFINITION
NFPTS==40.
DTHING
DWORD FPTLNK	;POINTER TO NEXT IN LINKED LIST
DWORD FPTSWA	;SWAP ADDRESS
DWORD FPTMFI	;MFI POINTER
DWORD FPTUPT	;GIP TO LINKED UPT'S
DWORD FPTPNO	;FILE PAGE NUMBER
DWORD FPTREF	;NUMBER OF PFPTS HANGING OFF THIS FPT
DWORD FPTFLG	;FLAG WORD, BOTTOM BYTE IS LOGICAL DISK #
FPTWSB==MFIWSB	;"WRITE TO SOURCE" BIT
FPTLKB==400	;LOCK BIT
FPTTSR==1000	;TEMPORARY WRITE TO SOURCE BIT
DWORD FPTSRC	;FIRST OF 8 WORDS CONTAINING BLOCK SOURCE ADDRESSES
FOO==FPTSRC+20
FPTBAS==100000	;"BLOCK AT SOURCE" BIT
ILISTS FPTFRE,,NFPTS

;FUPT ENTRY DEFINITION (FLOATING UPT)
;BEGINS LIKE UPT
NFUPTS==NFPTS	;MAYBE 2* OR SOME OTHER CONSTANT
DTHING
FOO==UPTLEN
DWORD UPTPRP	;PROCESS POINTER
ILISTS FUPTFR,FUPTTB,NFUPTS

;PFPT ENTRY DEFINITION
NPFPTS==40.	;PSEUDO-RANDOM MAX. # OF PFPTS
DTHING
DWORD PFPSWA	;SWAP ADDRESS FOR PFPT (IF 100000 BIT SET)
DWORD PFPPTR	;POINTS TO FPT
ILISTS PFPTFR,,NITALS+NPFPTS
.ENDC
	;FOR THE TELETYPE ITEM
TITQ==TOQM-1
TIQSZ==350.
TIBSZ==50.
TOQSZ==64.
TIBT==TIQM
TIQLM==TOQM
TOQLM==TOQM+TOQSZ

;FOR THE QUE ITEM
QUESZ==64	;THE SIZE OF THE QUE

;FOR THE PAPER TAPE ITEMS
PTRSZ==120.
PTPSZ==120.
.IFZ NP
	;DEFINITION OF A DISK REQUEST LIST ENTRY
DTHING
DWORD DRLINK
DWORD DSKGIP	;GIP TO THE DATA
DWORD DSKWD	;RANDOM WORD, INCLUDES FUNCTION
DSKFNT==177760	;MASK FOR THE FUNCTION
DWORD DSKRTN	;THE ROUTINE TO RUN WHEN TRANSFER DONE (OR NONE IF ZERO)
DWORD DSKBAD	;THE BUSS ADDRESS OF THE PAGE
ILISTS DSKFRE,,10.
DSKLEN==FOO
.ENDC

.IFZ NP
;FOR THE CST
MNCBLK==124.*2.	;MAXIMUM AMOUNT OF CORE IN 512 WORD BLOCKS
CSTSYB==100000	;THE "USED BY SYSTEM" BIT
CSTBEB==40000	;THE "BLOCK EXISTS" BIT
CSTFBB==20000	;THE "FIRST BLOCK OF PAGE" BIT
CSTFRB==10000	;THE FREE BIT
CSTCOM==176000	;THE CPT OFFSET MASK

;FOR THE CPT
NCPTTE==MNCBLK/4	;NUMBER OF CPT TABLE ENTRIES (ASSUME AVERAGE PAGE SIZE=2K)
CPTLEN==6	;LENGTH OF A CPT ENTRY
CPTLNK==0	;THE LINK
CPTUPP==2	;THE UPT POINTER
CPTADR==4	;THE CORE ADDRESS AND MISC BITS
CPTCRM==176000	;THE CORE ADDRESS MASK
CPTSYB==100000	;THE "USED BY SYSTEM BIT" IN THE CPTADR
CPTLCK==40000	;THE "LOCK THIS PAGE IN CORE" BIT
CPTMOV==20000	;THE "BEING MOVED" BIT
CPTWIN==10000	;THE "THIS PAGE IS A WINNER'S" BIT
.ENDC
;FOR THE LOCKED SWITCH LISTS
NLCKBL==NPROSS/2	;A GUESS
DTHING
DWORD LCKLNK	;THE LINK
DWORD LCKTIT	;TYPE AND ITEM
DWORD LCKWD1	;WORD ONE OF LOCK DATA
DWORD LCKWD2	;WORD TWO
ILISTS LCKFRE,,NLCKBL

;MISC SYSTEM PARAMETERS
LTIMEL==15.	;NUMBER OF TICKS BETWEEN CHECKING LONG FLUSHES
STIMEL==5.	;NUMBER OF TICKS BETWEEN SHORT FLUSH CHECKS
JTMUUT==6	;NUMBER OF TICKS BETWEEN JTMU UPDATES
JTMUAC==40	;ADDITIVE CONSTANT
JTMUDC==4	;DECAY CONSTANT
CLKL==1		;LEVEL CLOCK RUNS AT
CLKPIR==1_<CLKL+10>	;BIT FOR PIRQ
DMRL==3
DMRPIR==1_<DMRL+10>
IPRIOR==4	;PRIORITY TO SET A NEWLY CREATED PROCESS TO
IQUANT==4	;INTIAL QUANTUM
CQUANT==90.		;HOW OFTEN TO UPDATE THE CORE JTMUS
CDECAY==3.		;DECAYS BY 2/3 EACH TIME
	.SBTTL DEFINITIONS FOR VARIOUS TYPES OF ITEMS
;MACROS TO DEFINE ITEMS WITH

;THE START DEFINING ITEM MACRO
	.MACRO SITEMD SYM
FOO==2
ITMTFO==ITMTFO+1
SYM==ITMTFO
	.ENDM

;THE DEFINE SYMBOL MACRO
;IF SECOND ARG IS PRESENT, IT IS HOW MUCH SPACE TO RESERVE, IN BYTES
	.MACRO DITMS SYM,SIZE
SYM==FOO
	.IIF B SIZE,FOO==FOO+2
	.IIF NB SIZE,FOO==FOO+<SIZE>
	.ENDM

;THE DEFINE FLAG WORD MACRO
;SPACE IS RESERVED FOR THE FLAG WORD, AND FLAGS ARE DEFIND
;SEQUENTIALLY FROM THE RIGHT TO THE LEFT 
	.MACRO DFWORD SYM,BITS
FOOBAR==0
SYM==FOO
FOO==FOO+2
	.IRP X,<BITS>
X==1_FOOBAR
FOOBAR==FOOBAR+1
	.ENDM
	.ENDM

;THE DEFINE ITEM SIZE MACRO
;DEFINES A SYMBOL AS THE SIZE OF THE ITEM DEFINED SO FAR
	.MACRO DITMSZ SYM
SYM==FOO_-6
	.ENDM
ITMTFO==0	;THE TYPE OF THE LAST ITEM DEFINED
ITTYPE==0	;FOR ALL ITEMS, THE FIRST WORD IS THE TYPE
;DEFINITION OF A PROCESS ITEM
SITEMD ITPROC
;THE NEXT THREE SHOULD NOT BE MOVED
;WITHOUT MOVING THE COORESPONDING THREE IN THE USER DEFINITION
DITMS PRSREF		;REFERENCE COUNT
DITMS PPRTPT		;POINTER TO PROCESS TABLE
DITMS PQBIT		;THE QUEUE BIT
DITMS PTUSED,4		;TIME USED BY THIS PROCESS IN HALF-TICKS
DITMS PRSID1		;PROCESS ID LOW PART
DITMS PRSID2		;PROCESS ID HIGH PART
DITMS PFAULT		;IF NON-ZERO, WHAT KIND OF FAULT
DITMS PERRW		;ERROR WORD FOR SYSTEM CALLS
DITMS PERRAD		;SYSTEM ADDRES WHERE ERRRO TRAP HAPPENED FROM
DITMS PSPHRP		;POINTER TO SPHERE
DITMS PSPHCP		;CIRCULAR POINTER TO OTHER PROCESSES IN SPHERE
DITMS PLCKSL		;END OF THE LOCKED SWITCH LIST
DITMS PUPDLO		;OFFSET OF USER'S PDL IF CALL COMPLETES
DITMS PITM2		;PROCESS'S ITEM2
DITMS PUREGS,14		;THE USER'S REGISTER'S
DITMS PUP		;THE USER'S PDL POINTER
DITMS PUPC		;THE USER'S PC
DITMS PUPS		;THE USER'S PROCESSOR STATUS
DITMS PSREGS,14		;THE SYSTEM'S REGISTERS
DITMS PSP		;THE SYSTEM'S PDL POINTER
DITMS PSPC		;THE SYSTEM'S PC
DITMS PPDL,PRPDLL	;THE PROCESS'S PDL
DFWORD PFLAGS,<PFALTB,PFAILB,PFPFLG,PACSVF,PPCLSR>	;PROCESS FLAG WORD
DITMS PSTOPC		;STOP COUNT
DFWORD PSTOP,<PSPHSB,PSUPSB>	;STOP WORD
;PSPHSB INDICATES THE SPHERE HAS STOPPED THE PROCESS
;PSUPSB INDICATES SOME OTHER SUPERIOR PROCESS HAS STOPPED IT
DITMSZ PRSLNF		;SIZE WITH NO FLOATING POINT
DITMS PFPPRG,24.*2	;FLOATING POINT REGISTERS
DITMS PFPPS		;FLOATING POINT STATUS
DITMS PFEC		;FLOATING EXCEPTION CODE
DITMS PFEAP		;FLOATING EXCEPTION ADDRESS POINTER
DITMSZ PRSLFP		;LENGTH WITH FLOATING POINT

;DEFINITION OF A USER ITEM
SITEMD ITUSER
;THE NEXT THREE SHOULD NOT BE MOVED (SEE PROCESS)
DITMS USRREF		;THE REFERENCE COUNT
DITMS UPRTPT		;POINTER INTO PROCESS TABLE
DITMS UQBIT		;THE QUEUE BIT (HAD BETTER BE USER QUEUE)
DITMS UTUSED,4		;TIME USED BY THIS USER
DITMS USRNAM,10.	;USER NAME
DITMSZ USRLEN		;LENGTH OF A USER ITEM



;DEFINITION OF A SPHERE ITEM
SITEMD ITSPHR
;THE NEXT THREE SHOULD NOT BE MOVED (SEE USER)
DITMS SPHREF		;REFERENCE COUNT
DITMS SPRTPT		;THE SPHERE PROCESS TABLE POINTER
DITMS SQBIT		;THE QUEUE BIT (BETTER BE SPHERE QUE)
DITMS SCLSLK		;SPHERE C-LIST LOCK (CONTAINS THE ITEM NO. OF THE PROCESS THAT
			;LOCKED IT
DFWORD SFLAG,<ENFLT1,ENFLT2,FAULT1,FAULT2,FAULT3>	;ENABLE FAULTS ONE AND TWO
			;AND SAY WHETHER FAULT OR NOT
DITMS STTFG1		;TELETYPE FLAG WORD 1
DITMS STTFG2		;TTY FLAG WORD 2
DITMS SMTTY		;ITEM NO. OF MASTER TTY ITEM
DITMS SIFTTY		;ITEM NO. OF INFERIOR TTY SPHERE
DITMS SPHPRP		;POINTER TO FIRST PORCESS
DITMS SUSRPT		;POINTER TO USER ITEM RESPONSIBLE FOR THIS SPHERE
DITMS SMSSPT		;POINTER TO MASTER SPHERE OF THIS SPHERE
DITMS SCLSEP		;POINTER TO FIRST UNUSED LOCATION, RELATIVE TO ITEM
DITMS SUPTS,16.*UPTLEN	;THE UPT ENTRIES
DITMS SCLSTT,MNCLSE/NCLSEB	;THE INDEX OFFSETS TO THE C-LIST
DITMS SICLST,NCLSEB*CLSELN*2	;START WITH 2 BLOCKS OF C-LIST
DITMSZ SPHLEN

;DEFINITION OF A TELETYPE ITEM
SITEMD ITTTY
DITMS TTYREF	;REFERENCE COUNTER FOR TTY
DITMS TTITM	;ITEM THAT CURRENTLY OWNS THIS TTY
DITMS TTLTTY	;THE LOGICAL TTY NO. ASSOCIATED WITH THIS ITEM
DITMS TTYU	;USER NUMBER OF THE OWNER OF THIS TTY
DFWORD TTYST1,<TIRST,TIQF,TOTRAN,TIMAGI,TIMAGO,TIRBM,TIEDM,TIECM,TICVM,TILIPM,TORST,TERST,TICTM,TICTF,TMORM,TMORF>
;STATUS OF TTY - FIRST WORD
.TIRST==TIRST	;=> RESET THE TTY ON NEXT INPUT BREAK
.TIQF==TIQF	;=> SUPER QUOTE THE NEXT CHARACTER
.TOTRN==TOTRAN	;=> CURRENTLY TRANSMITTING
.TIMGI==TIMAGI	;=> INPUT IMAGE MODE
.TIMGO==TIMAGO	;=> OUTPUT IMAGE MODE
.TIRBM==TIRBM	;=> IN RUBOUT MODE
.TIEDM==TIEDM	;=> IN EDIT MODE
.TIECM==TIECM	;=> IN ECHO MODE
.TICVM==TICVM	;=> CONVERT FROM LOWER TO UPPER CASE MODE
.TLIPM==TILIPM	;=> LOGO INPUT MODE
.TORST==TORST	;=> RESET THE TTY ON NEXT OUTPUT BREAK
.TERST==TERST	;=> RESET THE TTY EDIT BUFFER ON THE NEXT OUTPUT COMMMAND
.TICTM==TICTM	;=> CONTROLIFY MODE
.TICTF==TICTF	;=> CONTROLIFY THE NEXT CHAR FLAG
.TMORM==TMORM	;=> ENABLE MORE PROCESSING
.TMORF==TMORF	;=> MORE BREAK TRIGGERED
DFWORD TTYST2,<TSCRL,TOEDM>
;TTY STATUS, SECOND WORD
.TSCRL==TSCRL	;=> SCROLL MODE. IF ZERO THEN WRAP MODE IS ASSUMED
.TOEDM==TOEDM	;=> MEANS THAT THE BYTE OUTPUT WILL GO TO THE EDIT BUFFER
DITMS TOTSR	;ADDR OF TRANSMIT STATUS REGISTER
DITMS TIBI	;POINTER TO WHERE NEXT CHAR. GOES IN, IN INPUT BUFFER
DITMS TIBO	;  "     "    "     "    "  COMES OUT  "   "     "
DITMS TIBN	;NUMBER OF CHAR. IN INPUT BUFFER
DITMS TIQI	;POINTER TO WHERE NEXT CHAR GOES IN, IN INPUT QUE
DITMS TIQO	;    "    "   "     "    " COMES OUT  "   "    "
DITMS TIQN	;NUMBER OF CHAR. IN INPUT QUE
DITMS TOQI	;POINTER TO WHERE NEXT CHAR. GOES IN, IN OUTPUT QUE
DITMS TOQO	;   "     "   "    "    "   COMES OUT  "    "     "
DITMS TOQN	;NUMBER OF CHAR. IN OUTPUT QUE
DITMS TIEQO	;POINTER TO WHERE NEXT CHAR COMES OUT, IN OUTPUT QUE
DITMS TIEQN	;NUMBER OF CHARACTERS IN EDIT QUE
DITMS TIBC	;NUMBER OF UNMATCHED LEFT BRACKETS IN INPUT QUE
DITMS TIEBC	;   "   "       "      "      "     "   "    "
DITMS TIQTO	;POINTER TO WHERE ECHO IS PROCESSING
DITMS TIQTON	;NUMBER OF CHAR THAT ECHO STILL HAS TO PROCESS
DITMS TIEQTN	;NUMBER OF CHAR THAT RDSTR HAS TO PROCESS
DITMS TIEQTO	;POINTER TO WHERE RDSTR IS PROCESSING
DITMS TITQN	;TOTAL NUMBER OF CHAR IN INPUT/EDIT QUE
DITMS TOPAD	;NUMBER OF CHAR LEFT TO SEND PAD
DITMS TOIPC	;SAVED PC FOR ECHO
DITMS TOISVA	;SAVED A FOR ECHO
DITMS TOPC	;SAVED PC FOR OUTPUT
DITMS TOSVC	;SAVED C FOR OUTPUT
DITMS TOSVD	;SAVED D FOR OUTPUT
DITMS CHARNO	;NUMBER OF CHAR PRINTED FROM LEFT EDGE OF PAGE
DITMS LINENO	;NUMBER OF LINES FROM TOP OF SCREEN
DITMS TLAST	;THE LAST CHAR TYPED
DITMS LINEL	;THE LENGTH OF A LINE
.IFNZ NTVS
DITMS TVCRLN	;BYTE ADDRESS OF THE CURSOR IN BUFFER
DITMS TVSCRL	;ADDRESS IN 64 BIT CHUNKS OF SCROLL START
DITMS TVLINE	;THE LINE NUMBER OF THE CURSOR (CHAR LINE NUMBER)
DITMS TVHIGH	;THE NUMBER OF CHAR LINES ON A SCREEN
DITMS TVFONT	;THE FONT NUMBER OF THIS TV
DITMS TVST	;TV STATUS (CONTENTS OF TVCNSL)
DITMS TVCUR	;INTERRUPT LEVEL CURSOR POSITION
DITMS TVBUF	;THE NUMBER OF THE TV BUFFER FOR THIS TV
DITMS TVNLSC	;THE NUMBER OF LINES TO SCROLL
DITMS TVHBIT	;THE HORIZONTAL BIT POSITION ON THE CURRENT LINE OF CURSOR
DITMS TVLCNT	;THE NUMBER OF LINES IN A CHAR - 1, USED BY BLINK FOR TVWC
DITMS TVMSK1	;THE LEFT SIDE OF THE CURSOR MASK
DITMS TVMSK2	;THE RIGHT SIDE OF THE CURSOR MASK, IN CASE CURSOR CROSSES WORD
DITMS TVSHCT	;SHIFT COUNT FOR THE CURSOR POSITION
DITMS TVCRSN	;BYTE ADDRESS OF THE BEGINNING OF LINE, LIKE TVCRLN
DITMS TVOFFL	;TOP LINE IN WRAP MODE, WHERE THE CURSOR GOES FROM BOTTOM
.ENDC
DITMS TIBB,TIBSZ	;INPUT BUFFER
DITMS TIQM,TIQSZ	;INPUT QUE
DITMS TOQM,TOQSZ	;OUTPUT QUE
DITMSZ TTYLEN

;DEFINITION OF A QUE ITEM
SITEMD ITQUE	;QUE ITEM
DITMS QUEREF	;REFERENCE COUNT OF THE ITEM
DITMS QUEENO	;NO OF ENTRIES IN QUE
DITMS QUECNT	;NO OF PEOPLE ON QUE
DITMS QUENUM	;THE NUMBER OF PEOPLE WHO CAN LOCK QUE
DITMS QUEQUE,QUESZ	;THE QUE
DITMSZ QUELEN
.IFZ NP
;DEFINITION OF A MASTER FILE ITEM
SITEMD ITMF		;TOP BYTE IS COUNT OF CAP WITH LOCK ON MFI
DITMS MFREF		;CAPABILITIES AND SPHERE UPTS (NOT FUPTS) INCREMENT THIS
			;ALSO INFERIOR FILE MFI'S
DITMS MFPREF		;CAPABILITIES AND INFERIORS
DITMS MFHLNK		;HASH LINK
DITMS MFIUPT		;SLOT FOR SYSTEM TO STORE FUPT
DITMS MFIFPT		;FIRST IN LIST OF LINKED FPT'S
DITMS MFLKSP		;SPHERE THAT HAS LOCKED THE MFI
DITMS MFBAKP		;ITEM NUMBER OF PARENT MFI IF A FILE
DITMS MFLAGW		;BOTTOM BYTE IS LOGICAL DSK #
MFDMTB==100000		;DIRECTORY EMPTY BIT
.FALNK==100000		;USER REQUEST FOR A LINK
MFDIRB==40000		;BIT SET IF DIRECTORY
.FADIR==40000		;USER REQUEST FOR DIRECTORY
MFIWSB==20000		;WRITE TO SOURCE (SAME AS FPTWSB)
.FAWSB==20000		;USER REQUEST FOR WRITE TO SOURCE
MFIRTB==10000		;ROOT DIR. BIT
.FARUT==10000		;USER REQUEST FOR ROOT DIRECTORY
MFLOKB==4000		;LOCKED BY USER BIT
.FALOK==4000		;USER REQUEST TO LOCK MFI
MFEBMB==2000		;ENTRY BEEN MUNGED
MFIBEB==1000		;MFI BEING ENLARGED BIT
MFOPNB==400		;FILE BEING OPENED BIT
MFDWDB==200		;DELETE WHEN DONE BIT
DITMS MFPDID		;DIRID OF PARENT DIRECTORY
DITMSZ MFLEN
MFELEN==FOO		;EXACT LEGNTH IN BYTES
DITMS MFENHD		;ENTRY HEADER
DITMS MFVERN
DITMS MFPGNO		;EOF PAGE NUMBER
DITMS MFBYTP		;EOF BYTE POINTER
.ENDC
MFPARE==0		;BITS IN ENTRY HEADER FLAG WORD
MFDIRE==1000
MFFILE==2000
;MFLSTE==3000
MFSLFE==4000
MFLNKE==5000
;TYPES 14 AND 16 ARE UNUSED

MFEOFB==100000		;SET IF EOF DATE AND TIME WORDS EXIST
MFACCB==40000		;SET IF ACCESS CODE EXIST
			;BIT 20000 IS UNUSED
MFSHRB==10000		;SET IF BLOCKS SHARED WITH OTHER FILE
			;BITS 7000 ARE USED BY ENTRY TYPES
MFLSTB==400		;SET IF EOF WORD POINTS TO EXISTING BLOCK

;DEFINITION OF CORE LINK ITEM, (WHEN A PAGE, IT LOOKS THE SAME)
SITEMD ITCL
DITMS CLREF		;THE REFERENCE COUNT
DITMS CLCONP		;POINTER TO THE CONSUMER
DITMS CLCNT		;THE AMOUNT OF VALID DATA IN ITEM
DITMS CLNUM		;THE NUMBER OF SLOTS IN THE BUFFER
DITMS CLDATI		;POINTER TO DATA IN
DITMS CLDATO		;POINTER TO DATA OUT
CLDATL==FOO		;THE LENGTH OF THE DATA WORDS



;DEFINITION OF A FONT ITEM
SITEMD ITFNT
DITMS FNTREF		;NOT REALLY USED FOR ANYTHING
DITMS FNWIDE		;WIDTH OF THIS FONT
DITMS FNHIGH		;HEIGHT OF THIS FONT
DITMS FNTEND		;POINTER TO THE END OF THE FONT
DITMS FNTLCL		;THE NUMBER OF TV LINES IN ONE CHAR LINE
DITMS FNMSK		;A RIGHT ADJUSTED MASK FOR CHARS IN THIS FONT
;THE SYSTEM COMPUTES THE NEXT 2 VARIABLES WHEN THE ITEM IS CREATED
DITMS FNLINE		;THE NUMBER OF CHAR LINES THAT FIT ON A SCREEN
DITMS FLFINC		;NUMBER OF BYTES IN ONE CHAR LINE
DITMS FNREM		;THE NUMBER OF BYTES AFTER LAST SCREEN LINE. MAY BE NEGATIVE.
DITMS FNLINL		;THE NUMBER OF CHARS PER LINE
DITMS FNLSC		;THE NUMBER OF LINES TO SCROLL
;VARIOUS PRECOMPUTED VARIABLES GO HERE
FOO==40			;THE DISPATCH TABLE ALWAYS STARTS AT 40
DITMS FNTPNT,400	;AND IS 128. WORDS LONG

;DEFINITION OF THE PAPER TAPE READER ITEM
SITEMD ITPTR
DITMS PTRREF		;REFERENCE COUNT
DITMS PTRDAI		;POINTER TO WHERE DATA GOES IN
DITMS PTRDAO		;POINTER TO WHERE DATA COMES OUT
DITMS PTRNO		;NUMBER OF BYTES IN BUFFER
DITMS PTRBUF,PTRSZ	;BUFFER FOR PAPER TAPE READER
PTREND==FOO		;TOP OF BUFFER
DITMSZ PTRLEN

;DEFINITION OF THE PAPER TAPE PUNCH ITEM
SITEMD ITPTP
DITMS PTPREF		;REFERENCE COUNT
DITMS PTPDAI		;POINTER TO WHERE DATA GOES IN
DITMS PTPDAO		;POINTER TO WHERE DATA COMES OUT
DITMS PTPNO		;NUMBER OF BYTES
DITMS PTPBUF,PTPSZ	;BUFFER FOR DATA
PTPEND==FOO		;TOP OF THE BUFFER
DITMSZ PTPLEN

.SBTTL MACROS FOR GENERATING CODE

.MACRO BUGC COND,CONTIN
.IF B CONTIN
	B'COND .+4
	BPT
.IFF
	B'COND .+10
	BPT
	JMP CONTIN
.ENDC
.ENDM

.MACRO FAULT TYPE
	TRAP+TYPE
.ENDM

.MACRO LBRLEM ADDR,COND,A,Q
	.IF IDN COND,A
	B'Q .+6
	JMP ADDR
	.ENDC
	.IF IDN COND,Q
	B'A .+6
	JMP ADDR
	.ENDC
.ENDM


.MACRO LBR COND,ADDR
	.IF1
	  .IFDF ADDR
	     .IFGE ADDR-.+376
	      .=.+2
	     .IFF
	      .=.+6
	      .IIF B COND,.=.-2
	     .ENDC
	  .IFF
	   .=.+6
	   .IIF B COND,.=.-2
	  .ENDC
	.IFF
	 LBRCSW==0
	  .IFLE ADDR-.
	     .IFGE ADDR-.+376
	      LBRCSW==1
	        .IF NB COND
	         B'COND ADDR
	        .IFF
	         BR ADDR
	        .ENDC
	     .ENDC
	  .ENDC
	  .IFZ LBRCSW
	     .IIF B COND,JMP ADDR
	     LBRLEM ADDR,COND,EQ,NE
	     LBRLEM ADDR,COND,LT,GE
	     LBRLEM ADDR,COND,LE,GT
	     LBRLEM ADDR,COND,HIS,LO
	     LBRLEM ADDR,COND,CS,CC
	     LBRLEM ADDR,COND,VS,VC
	  .ENDC
	.ENDC
.ENDM
;MACRO TO DO A BUG CHECK IN THE "NATURAL DIRECTION"
;THAT IS, IF THE CONDITION IS TRUE, BPT
.MACRO NBUGC COND
	RBRPP4 COND
	BPT
.ENDM

;MACRO TO BRANCH TO .+4 (PP4) ON THE OPPISITE OF THE SUPPLIED CONDITON
.MACRO RBRPP4 COND
	BRO .+4,COND,EQ,NE
	BRO .+4,COND,LT,GE
	BRO .+4,COND,LE,GT
	BRO .+4,COND,HIS,LO
	BRO .+4,COND,CS,CC
	BRO .+4,COND,VS,VC
.ENDM

;MACRO TO GENERATE BRANCH OF OPPISTIE CONDITION
.MACRO BRO ADDR,COND,A,Q
.IIF IDN COND,A,	B'Q ADDR
.IIF IDN COND,Q,	B'A ADDR
.ENDM

	.SBTTL TRAP VECTORS
	.MACRO TRAPV DEV,PRI
.=DEV'BRV
.IIF P2,.IIF NDF DEV'BRK,DEV'BRK==0
	DEV'BRK
.IIF NB PRI,	PRI_5
.IIF B PRI,	200
.ENDM
	.=0
	BPT
	.=4
	.REPT 77
	.+2
	BPT
	.ENDR

;TRAP VECTORS FOR INTERNAL DEVICES
TRAPV BE	;BUSS ERRORS
TRAPV ILL	;ILLEGAL INSTRUCTIONS
TRAPV BPT	;BREAKPOINTS
TRAPV IOT	;IOT
TRAPV PWF,7	;POWER FAILURE
TRAPV EMT	;EMT
TRAPV TRP	;TRAP
TRAPV PAR	;PARITY ERROR
TRAPV PIR,7	;PROGRAMMED INTERUPT
TRAPV FPP	;FLOATING POINT ERROR
TRAPV SEG	;SEGMENTATION ABORT OR TRAP

;TRAP VECTORS FOR OTHER DEVICES
TRAPV RF,5	;FIXED HEAD DISK
TRAPV RK,5	;MOVING HEAD DISK
TRAPV LC,6	;LINE CLOCK
TRAPV PC,6	;PROGRAMABLE CLOCK
TRAPV TK	;CONSOLE KEYBOARD
TRAPV TP	;CONSOLE PRINTER 
TRAPV PTR,4	;PAPER TAPE READER
TRAPV PTP,4	;PAPER TAPE PUNCH

;USER SYMBOLS FOR TRAP FAULTS
.IRP X,<BE,ILL,BPT,IOT,EMT,TRP,FPP,SLE,RDO,NXM>
.'X'TF==1+.IRPCN
.ENDM
.SBTTL ERROR DEFINITIONS
;MACRO TO GENERATE A CONDITIONAL ERROR TRAP
.MACRO ERRORC COND,ERR,F1,F2
	RBRPP4 COND
	ERROR ERR,F1,F2
.ENDM

;MACRO TO GENERATE AN ERROR TRAP
.MACRO ERROR ERR,F1,F2
ERRCOD==.E'ERR!TRPZBT
	EFLAG F1
	EFLAG F2
	TRAP ERRCOD
.ENDM

;MACRO TO HELP OUT ERROR
.MACRO EFLAG FLAG
.IIF IDN FLAG,SZ,ERRCOD==ERRCOD!TRPZBT
.IIF IDN FLAG,CZ,ERRCOD==ERRCOD&<-TRPZBT-1>
.IIF IDN FLAG,SV,ERRCOD==ERRCOD!TRPVBT
.IIF IDN FLAG,CV,ERRCOD==ERRCOD&<-TRPVBT-1>
.ENDM

TRPZBT==200
TRPVBT==100

;MACRO TO ASSIGN AN ERROR SYMBOL
.MACRO ERDEF CODE
.E'CODE==FOO
.ENDM

FOO==1

ERDEF NIT	;NO ITEM AVAILABLE
ERDEF BCT	;BAD CAPABILITY TYPE
ERDEF BAC	;BAD ACCESS
ERDEF BPN	;BAD PAGE NUMBER
	.=400
	.SBTTL SYSTEM VARIABLES AND TABLES

	.BLKW 200	;FOR THE SYSTEM PDL
PDL:
PARREG:	.BLKW 20	;FOR THE REAL PARITY REGISTERS

ABSLD:
.OFFSET 160000-.
ABSLOD:	MOV #ABLDPD,P	;REINIT THE PDL POINTER
	CLR D
	MOV #20000,E
	CLR (D)+
	SOB E,.-2
	CLR ABSCNT
	;C IS CHECKSUM
	;D IS CORE ADDRESS
	;E IS BYTE COUNT
ABSLOP:	CLR C
	JSR PC,GBYTE
	CMPB #1,A	;IS IT THE START OF A BLOCK?
	BNE ABSLOP	;NO, TRY AGAIN
	JSR PC,GBYTE
	TST A
	BNE ABSLOP	;SHOULD BE A ZERO NEXT
	JSR PC,GWORD	;GET THE COUNT
	MOV A,E		;SAVE IT
	JSR PC,GWORD	;GET THE ADDRESS
	MOV A,D
	ADD E,A		;CHECK THAT WE AREN'T OVERLOADING
	CMP #40000,A
	BHI .+4		;MUST BE UNDER 8K
	BPT
	CMP #6,E	;IS IT THE START BLOCK?
	BEQ ABSSRT	;YUP
	SUB #6,E	;THAT MANY ALREADY LOADED
ABSLP1:	JSR PC,GBYTE
	MOVB A,(D)+
	SOB E,ABSLP1
	JSR PC,GBYTE	;THE CHECKSUM
	TSTB C
	BEQ ABSLOP	;CHECKSUM GOOD
	BPT		;BAD CHECKSUM
ABSSRT:	JSR PC,GBYTE	;GET CHECKSUM
	TSTB C
	BEQ .+4
	BPT		;BAD CHECKSUM
	CMP -(P),-(P)	;EXTRA WORDS
	SAVE <SYSFCP>
	BIS #.DELCP,(P)	;DELETE CAPABILITY TO FILE
	$INVOK
	JMP (D)

GBYTE:	DEC ABSCNT
	BLT GBYTE1
	MOVB @ABSPNT,A
	INC ABSPNT
	ADD A,C
	RTS PC
GBYTE1:	MOV #2000,ABSCNT	;A BARFER LOAD
	MOV #ABSBRF,ABSPNT
	SAVE <#ABSBRF,#-2000,SYSFCP>
	$BLKI
	BR GBYTE

GWORD:	JSR PC,GBYTE
	SAVE A
	JSR PC,GBYTE
	MOVB A,1(P)
	REST A
	RTS PC
SYSFCP:	0
ABSPNT:	0
ABSCNT:	0
	.BLKW 10	;ROOM FOR THE PDL
ABLDPD::
ABSBRF:
ABSEND==.
.OFFSET 0
SSTATS::	;THE SYSTEM STATUS BLOCK
	VERN	;SYSTEM VERSION
TIME:	.BLKW 2	;TIME IN 60TH'S SINCE SYS START
SVCSR:	0	;THE CONSOLE SWITCHES
LOOKSW:	0	;NON-ZERO=>PAY ATTENTION TO SWITCHES
NSTATS==<.-SSTATS>/2
MFITST:	MFIRTB!12		;DATA BLOCK TO MAKE ROOT DIR
	BYTES <'R,'O,'O,'T,0,46,0>
.EVEN
MFIBIT:	ASCIZ <BITS>
MFISYS:	ASCIZ <. SYSSPR>
MFIDRD:	ASCIZ <DIRID>
MFIDSC:	ASCIZ <DESCR>
	.EVEN
RKDESR:	WORDS <0,0,12>
PATCH:
PAT:	.BLKW 140
SYSJPD:		;THE SYSTEM JOB'S PDL
%CSX:	.BLKW 4	;PLACE FOR SIMULATOR TO DO X'S
BMT:	BYTES <1,2,4,10,20,40,100,200>	;BIT MARK TABLE
	;FOR MARKING BIT TABLES, THE NTH ENTRY IS THE NTH BIT
INITSW:	-1	;ZERO AFTER EXITING INIT CODE
PRUNNG:	-1	;ITEM # OF RUNNING PROCESS, NEG=> IN SYSTEM
			;(THIS IS NOT SET TO -1 BY INTERUPT ROUTINES)
USRMOD:	-1	;IF A PROCESS IS RUNNING, NON-ZERO=> IN SYSTEM CODE
			;0=>IN USER'S CODE
SYSSPR:	-1	;ITEM NUMBER OF THE SYSTEM SPHERE
CURUSR:	-1	;PROCESS BLOCK INDEX OF THE RUNNING PROCESS'S USER
CURSPH:	-1	;ITEM INDEX OF SPHERE OF THE RUNNING PROCESS
NEWPRI:	.BLKW 2	;PROCESS ID OF NEXT PROCESS TO BE CREATED
STPSVP:	0	;SAVED P WHEN WE WENT TO START A PROCESS (FOR ERROR RECOVERY)
BPCLSR:	0	;NON-ZERO WHEN IN PROCESS OF PCLSRING THE GUY GETTING UNLOCKED
QUANT:	0	;NUMBER OF TICKS BEFORE THE RUNNING PROCESS SHOULD BE STOPPED
PQUANT:	IQUANT	;QUANTUM TO GIVE A PROCESS WHEN YOU START IT
TUSED:	0	;TIME THE PROCESS HAS USED SINCE LAST STARTED
STIMER:	0	;TIME TILL NEXT CHECK OF SHORT FLUSHES
LTIMER:	0	;TIME TILL NEXT CHECK OF LONG FLUSES
JTMUUP:	JTMUUT	;NUMBER OF TICKS TILL NEXT UPDATE OF JTMUS
.IFZ NP
;THESE ARE THE TABLES USED BY THE SWAP SCHEDULER
;PAGE HASH NODE DEFINITION
PGHLEN==2		;THE LENGTH IS 2 WORDS
			;FIRST IS LINK
			;SECOND IS SWAP ADDRESS
PGHND:	.BLKW NCPTTE*PGHLEN	;THE PLACE FOR THEM
NUMPGS:	.BLKW 10	;THIS CONTAINS THE NUMBER OF PAGES ALLOCATED FOR EACH SIZE
NUMPGL:	.BLKW 10	;THIS CONTAINS THE NUMBER OF PAGES LEFT DURING
			;ALLOCATION, OF EACH SIZE
PHSPRQ:	0		;POINTER TO SPHERE QUEUE IN EXILE
PHASHT:	.BLKW 128.	;HASH TABLE FOR PAGES
CORTIM:	0		;TIMER FOR CORE JTMU UPDATE
NWINRS:	0		;NUMBER OF WINNERS LEFT (WHEN 0, RUN SWAP SCHED ON NEXT PAGE FAULT)
.ENDC
RUGVEC:	0		;STORING PLACE FOR RUG'S VECTOR
RUGSTA:	0		;DITTO FOR RUG'S STATUS
.IIF Z NP,PIRDIS:	WORDS <PIRLOS,STOPPR,PIRLOS,PIRLOS,PIRLOS,PIRLOS,PIRLOS,PIRLOS>	;THE PIR DISPATCH
.IIF NZ NP,PIRDIS:	WORDS <PIRLOS,STOPPR,PIRLOS,DMRBRK,PIRLOS,PIRLOS,PIRLOS,PIRLOS>	;THE PIR DISPATCH
PIRBIT:	WORDS <0,1000,2000,4000,10000,20000,40000,100000>	;THE PIR BITS
	;LOCK TABLES AND DEFINTIONS
.MACRO LCKDEF A,B
A==FOO
B
FOO==FOO+2000
.ENDM
FOO==0
;LOCK DISPATCH TABLE
LCKDIS:	LCKDEF FOO,LSPERR	;THE ZERO LOCK SHOULD NOT OCCUR
	LCKDEF LONOFF,LSPONF	;ON/OFF LOCK
				;WORD 1 IS ABS ADDR OR OFFSET INTO ITEM
				;WORD 2 CONTAINS BIT(S) LOCKED IN WORD
	LCKDEF LPCLRT,LSPPCL	;RUN ROUTINE IF PCLSRED
				;WORD 1 IS ADDRESS OF ROUTINE
	LCKDEF LCKRTN,LSPRTN	;RUN ROUTINE WHEEVER UNLOCKED
				;WORD 1 IS ROUTINE ADDRESS
	LCKDEF LCKDEC,LSPDEC	;DECREMENT WORD WHEN UNLOCKED
				;WORD 1 IS ABS ADDR OR OFFSET INTO ITEM
				;WORD 2 IF NON-ZERO IS ADDR OF ROUTINE
				;TO RUN IF DEC RESULTS IN ZERO BYTE
;EMT DISPACTCH TABLES
.MACRO EMTD NAME
.IF NB NAME
M'NAME==FOO
.'NAME==FOO+EMT
$'NAME==FOO+200+EMT
	E'NAME
.IFF
	BADEMT
.ENDC
FOO==FOO+1
.ENDM

FOO==0
;REMEMBER THAT USER PROGRAMS DEPEND ON THESE TABLES
;NOT CHANGING ORDER
EMTDIS:
	EMTD NOOP	;NOP CALL
	EMTD FORK
	EMTD POOFF
	EMTD SLEEP
	EMTD SINK
	EMTD FLOAT
	EMTD INVOK
	EMTD QULK
	EMTD QUNLK
	EMTD TTGIV
	EMTD TTGET
	EMTD WRDI
	EMTD WRDO
	EMTD BYTI
	EMTD BYTO
	EMTD BLKI
	EMTD BLKO
	EMTD MAP
	EMTD ALLOC
	EMTD CRUSR
	EMTD RDMAP
	EMTD FONT
	EMTD SSTAT
	EMTD VIDSW
EMTHGH==FOO
.MACRO CLSTYD X
.'X'CAP==FOO
.=IVKCTB+<2*FOO>
	CAPR'X
.IRP Y,<CCPR,CPY,DEL,GIV,TAK>
.=.+CAPHGH-2
	Y''X
.ENDM
.IIF P1,CAPHGH==CAPHGH+2
.=IVKCTB+<CAPHGH*6>
FOO==FOO+1
.ENDM
.IIF P1,CAPHGH==0
FOO==0

;REMEMBER THAT USER PROGRAMS DEPEND ON THESE TABLES
;NOT CHANGING ORDER
IVKCTB:
CLSTYD XX	;THE ZERO CAPABILITY SHOULD NOT EXIST

CLSTYD CC	;CREATE CAPABILITY
;NO DATA WORDS

CLSTYD MS	;MASTER SPHERE
;FIRST ITEM IS THE SPHERE
;SECOND IS SPHERE (IF ANY) IN CIRCULAR LIST OF SPHERES HAVING SHPERE
;CAPABILITY TO THIS SPHERE
;FIRST MISC IS FAULT ENTRY ADDRESS
;SECOND MISC IS C-LIST NUMBER (IF ANY) FOR CIRCULAR LIST
;BITS ARE:
.SPFES==400	;SURPRESS ENTERS THROUGH HERE
.SPCLC==1000	;ALLOW COPY FROM C-LIST
.SPCLD==2000	;ALLOW DELETE FROM C-LIST
.SPCRR==4000	;ALLOW CORE READ
.SPCRW==10000	;ALLOW CORE WRITE
.SPCRE==20000	;ALLOW CORE EXECUTE
	;THESE FLAGS ARE FOR EMAP, DIFFERENT NAMES, SAME FUNCTION
	.CRPRI==2000	;PRIVATE PAGE
	.CRRD==.SPCRR
	.CRWRT==.SPCRW
	.CREX==.SPCRE
.SPCAD==40000	;ALLOW C-LIST APPEND
MSPCBT==.SPCAD!.SPCLC!.SPCLD!.SPCRR!.SPCRW!.SPCRE	;ALL SET IN SPHERE

CLSTYD SP	;SPHERE (NON-MASTER I.E. COPY OF MASTER)
;SAME PROPERTIES AS MASTER SPHERE, EXCEPT SOME BITS MAY NOT BE SET
;AND THERE IS NO ENTRY ADDRESS
;HERE ARE THE FUNCTIONS FOR THE .SPCAP AND .MSCAP INVOK'S
.SPPTT==0	;PUT THE PROCESS INTO SPHERE
.SPCLR==1	;READ THE C-LIST

CLSTYD PR	;PROCESS CAPABILITY
;WORDS ARE ASSIGNED AS IN MASTER SPHERE AND ENTER ADDRESS IS STARTING ADDRESS
;BITS ARE:
.PRWRA==10000	;ALLOW WRITING OF INFORMATION

CLSTYD TT	;TELETYPE CAPABILITY (NO DATA WORDS)
;FLAGS ARE
.TTYO==10000	;ALLOW OUTPUT TO TTY
.TTYI==20000		;ALLOW INPUT FROM TTY

CLSTYD FA	;FILE ACCESS CAPABILITY
FAMFI==2	;FIRST WORD IS MFI PTR
FAFPN==4	;SECOND IS FILE PAGE NUMBER
FAUPT==6	;THIRD IS GIP FOR FUPT
FAFBP==10	;FOURTH IS BYTE PTR IN FILE PAGE (SEE 2ND WORD)

.FARD==4000	;FILE READ ACCESS
.FAWT==10000	;FILE WRITE ACCESS
.FAAP==20000	;FILE APPEND ACCESS
.FAAC==40000	;ACCESS CODES ACCESS
.FALB==100000	;LOCK BIT
.FAWD=40000	;SET IF FIRST BYTE OF DKWDO IS WRITTEN
		;CAN'T EQUAL .FAAP OR .FAWT
.IFZ NP
.MACRO MFAERT TYPE		;DEFINE A DISK ERROR TYPE
FOOBAR==FOOBAR+1
.FA'TYPE==FOOBAR			;DEFINE THE ERROR SYMBOL
.ENDM
FOOBAR==0
MFAERT EOF	;END OF FILE
MFAERT HIF	;HOLE IN FILE
MFAERT NSS	;NO SWAP SPACE
MFAERT NDB	;NO DISK BLOCKS
MFAERT DTL	;DISCRIPTOR TOO LARGE
MFAERT ACV	;ACCESS CODE VIOLATION
MFAERT IPB	;ILLEGAL PAGE BOUNDARY
MFAERT FNF	;FILE NOT FOUND
MFAERT BFN	;BAD FILE NAME
MFAERT WBE	;WORD BOUNDARY ERROR
MFAERT WTE	;WRONG TYPE OF ENTRY
MFAERT DIF	;DIRECTORY IS FULL
MFAERT BPG	;BAD PAGE
MFAERT RAN	;RANDOM ERROR
.ENDC

CLSTYD QU	;THE QUE CAPABILITY
		;NO FLAGS

CLSTYD CL	;CORE LINK CAPABILIY
;FIRST ITEM IS GIP TO THE BUFFER
;FLAGS ARE
.CLCONS==400	;I AM THE CONSUMER FLAG

CLSTYD DS	;DISPLAY CAPABILITY
;IT HAS AN ITEM IF IT IS A TV DISPLAY, THE ITEM WORD IS 0 IF TV.
;THE FIRST MISCELLANEOUS WORD IS THE INDEX OF THE DISPLAY. FOR
;TK DISPLAYS, THIS NUMBER IS THE WORD INDEX INTO THE TKD TABLES.
;FOR TV DISPLAYS, IT IS STILL A WORD INDEX, AND SINCE THE TV TABLES
;ARE BYTE TABLES, THE NUMBER MUST BE DIVIDED BY 2 AND HAVE NFTVDS
;SUBTRACTED FROM IT BEFORE USE.

CLSTYD TR	;PAPER TAPE READER
;NO FLAGS, ITEM IS THE PTR ITEM

CLSTYD TP	;PAPER TAPE PUNCH
;NO FLAGS, ITEM IS PTP ITEM
	;DISPATCH TABLES
CCTAB=IVKCTB+CAPHGH	;THE CREATE CAPABILITY TABLE
CPYTAB=CCTAB+CAPHGH	;THE COPY CAPABILIY TABLE
DELTAB=CPYTAB+CAPHGH	;THE DELETE TABLE
GIVTAB=DELTAB+CAPHGH	;THE GIVE AWAY TABLE
TAKTAB=GIVTAB+CAPHGH
	;GENERAL FUNCTIONS FOR INVOKE
.MACRO GENFUN NAME
	NAME'CAP
	.'NAME'CP==400*<200+FOO>
	FOO==FOO+1
.ENDM

FOO==0
GENDIS:	GENFUN DEL	;DELETE THE CAPABLITY
	GENFUN CPY	;COPY THE CAPABILITY
	GENFUN GIV	;GIVE THE CAPABILIITY AWAY
	GENFUN TAK	;TAKE THE CAPABILITY (GIMMEE,GIMMEE)
GENHGH==FOO*2

;THIS IS THE DISPATCH TABLE FOR I-O DEVICES

.IRP OP,<WDI,WDO,BTI,BTO,BKI,BKO>	;INITIALZE TABLES FOR THESE TRANSFER TYPES
OP'TAB:
.IRP DEV,<DK,TT,CL,TR,TP>
DEV'IDX==.IRPCN
	DEV''OP
.ENDM
.ENDM

;THESE ARE THE TABLES FOR THE PROCESS INVOK
.MACRO PRINVK FUN,CNT
.PR'FUN==FOO
.IFB CNT
FOO==FOO+1
PR'FUN
.IFF
FOO==FOO+CNT
.REPT CNT
PR'FUN
.ENDR
.ENDC
.ENDM

FOO==0
PRIVTB:	PRINVK REG,8	;8 REGISTERS
	PRINVK PSW	;PROGRAM STATUS WORD
	PRINVK FREG,6	;6 FLOATING POINT REGISTERS
	PRINVK FPST	;FLOATING POINT STATUS WORD
	PRINVK FPEN	;ENABLE FLOATING POINT
	PRINVK STOP	;THE STOP WORD OF THE PROCESS
	PRINVK ERR	;THE ERROR WORD
	PRINVK FAUL	;THE FAULT WORD (OR WORDS)
PRHGH==FOO*2
.PRRD==0		;THE READ FUNCTION
.PRWRT==40		;THE WRITE FUNCTION

;FOR THE TTY INVOK
.MACRO TTIVK FNC
.'FNC==NTTFNC
FNC
NTTFNC==NTTFNC+1
.ENDM

.TTWRT==40
.TTIBK==400		;TTY I/O FLAG SPECIFING AN INPUT TYPE BREAK
.TTMBK==10000		;TTY FLAG SPECIFYING A MORE BREAK
.TTWD==40000		;FLAG SAYING THAT FIRST BYTE DONE ON WORD OUTS
.TTEDM==1000		;SAYING THAT THIS OUTPUT IS TO GO TO THE EDIT BUFFER

NTTFNC==0
;THESE FUNCTIONS WRITE IF THE .TTWRT BIT IS SET AND READ OTHERWISE
TTIVTB:	TTIVK TTMOV	;MOVE INTO TTY STATUS WORD (ALWAYS WRITE)
	TTIVK TTBIS	;BIS INTO TTY STATUS (ALWAYS WRITE)
	TTIVK TTBIC	;BIC INTO TTY STATUS (ALWAYS WRITE)
	TTIVK TTRD	;READ THE TTY STATUS (ALWAYS READ)
	TTIVK TTCNO	;READ OR SET THE CHARNO VARIABLE 
	TTIVK TVATC	;ATTACH A DISPLAY BUFFER TO A TTY
	TTIVK TVCL	;CLEAR THE SCREEN
	TTIVK TTBRK	;READ THE LAST BREAK CHAR TYPED, HANG IF NONE
	TTIVK TVREV	;REVERSE WHITE AND BLACK ON SCREEN
	TTIVK TTMV2	;SET TTYST2
	TTIVK TTSPD	;SET THE SPEED AND LINE PARAMETERS (DH11 ONLY)
	TTIVK TTTYP	;RETURN THE TYPE OF THE TTY TO THE USER
	TTIVK TVFNT	;CHANGE THE FONT OF THE TV TTY
	TTIVK TTBS2	;BIS INTO TTY STATUS 2
	TTIVK TTBC2	;BIC INTO TTY STATUS 2
	TTIVK TVSET	;READ OR SET TVLINE AND TVCUR
	TTIVK TVOFF	;READ OR SET TVOFFL
	TTIVK TVRFN	;READ CHAR WIDTH IN BITS AND LINE HEIGHT IN TVLINES

.MACRO TDSIVK FUNCTION
	.WORD FUNCTION
.'FUNCTION==TVDSIM+100
TVDSIM==TVDSIM+1
.ENDM

TVDSIM==0
;TV DISPLAY INVOKES
TVDSIT:	TDSIVK TVDSRC		;READ THE CURSOR
	TDSIVK TVDSSC		;SET THE CURSOR
	TDSIVK TVDSNL		;DRAW A NULL LINE
	TDSIVK TVDSIL		;IOR A LINE
	TDSIVK TVDSXL		;XOR A LINE
	TDSIVK TVDSCL		;CLEAR A BLOCK OF THE SCREEN

;VIDEO SWITCH MODES
.VIABS==0	;ABSOLUTE MODE
.VILOT==1	;LOGICAL TTY NUMBER MODE
.VILOD==2	;LOGICAL DISPLAY NUMBER MODE
.VICAM==3	;CAPABILITY MODE
;INITALIZE TABLES
.MACRO ILIST AD,FREE,NUM,LEN
WORDS <AD+LEN,FREE,NUM-2,LEN>
.ENDM


;FOR THE ITEM TABLE
.IRPC X,<012>
ITEM'X:		-1		;ITEM CURRENTLY IN PAGE ITM0
ITM'X'A:	ITM'X'AD	;ADDRESS OF ITEM IN ITEM'X
ITM'X'D:	0		;PUSH DEPTH
ITM'X'P:	ITM'X'PD	;PDL POINTER FOR ITM'X
	.BLKW NITMPS		;PDL FOR ITM'X'
ITM'X'PD::
.ENDM
;TABLES AND SYMBOLS FOR THE FILE SYSTEM

;MACRO TO DEFINE FILE ACCESS CAPABILITY FUNCTIONS
.MACRO MFADCF SYMBOL
.FA'SYMBOL==FOO
MFA'SYMBOL
FOO==FOO+1000
.ENDM
.IFZ NP
MFHTAB:	.REPT 20
	0
	.ENDR			;MFI HASH TABLE (INIT TO 0)
MFBKCT:	0			;BLOCK COUNT FOR DISCRIPTOR HACKING
MFBKNO:	0			;CURRENT BLOCK FOR DISCRIPTOR HACKING
MFDIST:	0			;CURRENT TYPE FOR DISCRIPTOR HACKING
MFDPTR:	0			;POINTER INTO MFI AT DISCRIPTOR
MFOLDE:	0			;NAMCMP MAKES THIS POINT TO ENTRY BEFORE LAST ENTRY
MFEND:	0			;POINTER PAST END OF DISCRIPTOR

	37			;PART OF TABLE
ADDEND:	WORDS <77,7>		;DISCRIPTOR TABLE FOR ADDING BLOCKS
.ENDC
FOO==0
FATAB:
MFADCF CF			;CLEAR FLAGS
MFADCF RE			;RETURN EOF WORDS
MFADCF SP			;SET POINTER
MFADCF RP			;RETURN POINTER
MFADCF DL			;DELETE ENTRY
MFADCF AD			;ADD ENTRY
MFADCF MU			;MUTATE CAPABILITY
MFADCF MB			;SET UP BIT TABLE FOR ROOT DIR
MFADCF MD			;SET UP DIRID TABLE FOR ROOT DIR
MFADCF RI			;RETURN INFORMATION ABOUT THE FILE
MFADCF DI			;RETURN INFORMAITON ABOUT THE DISK
MFADCF PA			;APPEND THIS PAGE TO THE FILE
.IFZ NP
FAGTFN==<FOO-1000>/400		;GREATEST LEGAL FUNCTION
MFDTAB:	MFG1SK			;DISCRIPTOR HANDELING TABLE
	MFGSOM
	MFSADD
	MFSKAG

NDISKS==5			;NUMBER OF LOGICAL DISKS
MFTDSK==12			;TEMPORARY FILES GO ON THIS DISK
MFBITS:	.BLKW	NDISKS+1		;BIT TABLE FUPTS SIT HERE
MFDIRD:	.BLKW	NDISKS+1		;DIRID FUPTS SIT HERE
MFREBK:	.BLKW	NDISKS+1		;NUMBER OF FREE BLOCKS ON DISK
.ENDC

ITMATB:	.BLKW 200	;ITEM ALLOCATE TABLE (ONE WORD PER SIZE)
			;THESE POINT INTO ITMALS
ITMBAL:	.BLKW 1		;ITEM BLOCK STORAGE ALLOCATE LOCK
INITM1::		;INITIALIZE FOLLOWING AREA TO -1
ITMBNF:	.BLKW NITMBL	;NUMBER OF BLOCKS FREE IN THIS BIG BLOCK
ITMBST:	.BLKW NITMBL	;ADDRESS OF FIRST BLOCK OF THIS BIG BLOCK
ITMBTP:	.BLKW NITMBL	;POINTERS TO BEGGININGS OF BIT TABLES
	.BLKW 1		;THIS IS THE BACKWARDS-SEARCHING FENCE FOR THE 1ST BIT TABLE
ITMBIT:	.BLKW 11*NITMBL	;8 WORD BIT TABLE FOR EACH BIG BLOCK
				;AND A FENCE BETWEEN THE BLOCKS
EINTM1::	;END OF STUFF TO INIT TO -1
;THE LOCKED SWITCH LISTS
.IFZ NP
	.STITL DISK VARIABLES
DSK0RQ:	.BLKW 1		;POINTER TO THE FIRST DISK REQUEST

DSKRD==4		;DISK FUNCTION FOR READ
DSKWRT==2		;DISK FUNCTION FOR WRITE
DSKWCK==6		;FOR INTERNAL DISK USE ONLY
DSKWCH==10		;DISK FUNCTION FOR WRITE AND THEN WRITE CHECK

NSPDSK==1		;NUMBER OF DISKS THAT WE SWAP ON

;THE FORMAT FOR THE BIT TABLES IS:
;1) THE START OF THE SWAP SPACE IN 512 WORD DISK BLOCKS
;2) THE LENGTH OF THE SWAP SPACE (NUMBER OF VALID BITS IN BIT TABLE)
;3) WHICH LOGICAL DISK THE SPACE IS ON. NOTE THAT THE FASTER
;   DISK SHOULD BE FIRST

;THESE ARE THE POINTERS TO THE LARGE SPACE SWAPPING BIT TABLES
LSPBTP:	0		;NEVER USED
	.BLKW NSPDSK*2	;TWO SWAP AREAS ON EACH DISK

;THESE ARE THE POINTERS TO THE SMALL SPACE SWAPPING BIT TABLES
SSPBTP:	0		;NEVER USED
	.BLKW NSPDSK*2
	0		;THIS IS TO STOP THE SWAP ALLOCATE ROUTINES
;THIS IS THE STORAGE FOR THE SWAPPING BIT TABLES
BITTAB:	.BLKW 30*NSPDSK	;ARBITRARY CONSTANT,  THE MAXIMUM SIZE OF THE BIT TABLES
			;IT IS VERY IMPORTANT THAT THE UNUSED BITS OF THE LAST WORD
			;OF THESE TABLES BE ALL ONES (SEE SWPAL4)
BITEND==.		;THE END OF THE BIT TABLES
BTRATO:	WORDS <3,0>	;THE FIRST NUMBER IS THE NUMBER OF LARGE SWAP AREAS TO ALLOCATE
			;FOR EVERY ONE OF THE SECOND NUMBER(512 WORD BLOCKS)
.ENDC
.IFZ NP
;THIS IS WHERE DSKGRB PUTS THE NEXT TRANSFER
DKNCS:	0		;FIRST WORD IS CNT-STATUS REG
DKNWC:	0		;SECOND IS WORD COUNT
DKNBA:	0		;THIRD IS MEMORY ADD
DKNDA:	0		;FOURTH IS DISK ADDRESS
DKNDAE:	0		;FIFTH IS DAE OR -1 IF RK11
DKNRP:	0		;SIXTH IS EITHER #RFDAE+2 OR #RKDA
DKNFLG:	0		;FLAG WORD FOR THIS TRANSFER
DKNCST:	0		;POINTER TO THIS TRANSFER'S CST ENTRY
DKNITM:	0		;THE PROCESSES ITEM THAT MADE THE REQUEST
DKNRT:	0		;ROUTINE TO RUN WHEN DONE
DKNGIP:	0		;THE GIP
CURTRN:	.BLKW 6		;THIS CONTAINS A COPY OF THE CURRENT REQUESTS DISK REGISTERS
			;IN THE SAME FORMAT AS DKN--
DSKFLG:	0		;FLAG WORD FOR THE INTERRUPT ROUTINES (USUALLY DESCRIBES
DSKCST:	0		;POINTER INTO THE CST OF THE CURRENT TRANSFER)
DSKITM:	0		;SAME AS DKNITM, BUT FOR CURRENT TRANSFER
DSKRT:	0		;SAME AS DKNRT, BUT FOR CURRENT TRANSFER
FPTPR==100000		;MEANS THAT WE ARE IN THE MIDDLE OF PROCESSING FPT
			;AND BOTTOM BYTE IS THE BLOCK NO AND CNT
WRTSR==40000		;WRITE TO SOURCE BIT
WRTCHK==20000		;WRITE CHECK WHEN THIS PART IS DONE
PFPTFL==10000		;PROCESSING PFPT
FPTCNT==177770		;MASK FOR THE CNT
FPTPAG==177707		;MASK FOR THE PAGE OFFSET
FPTOFF==177077		;MASK FOR THE FPT OFFSET
RETRYS:	0		;NUMBER OF RETRYS LEFT ON THIS TRANSFER
NRETRY==30.		;NUMBER OF RETRYS TO ALLOW
NRKERS:	0		;NUMBER OF RK11 ERRORS
NRFERS:	0		;NUMBER OF RF11 ERRORS

DSKTB:
.IRP X,<BAD,RF,RK,RK,RK,RK>	;ADD MORE DISKS HERE
	X'DSK
.ENDM
DATAB:
.IRP X,<BAD,RF,RK0,RK1,RK2,RK3>	;ADD MORE DISKS HERE
	X'DAC
.ENDM
.ENDC
	;FOR THE PROCESS TABLE
;MACRO FOR DEFINING A QUEUE
.MACRO DEFQ NAME
NAME'Q:	.BLKW 2
NAME'QB==1_FOO
	1_FOO
FOO==FOO+1
.ENDM
QLEN==6		;THE LENGTH OF A QUEUE POINTER
QBIT==4		;POSITION OF QUEUE BIT WITHIN THE POINTER
FOO==0		;INITALIZE THE QUEUE NUMBER
FIRSTQ==.
DEFQ RUN	;GUYS WHO CAN BE RUN IMMEDIATELY
DEFQ PAGW	;GUYS WAITING FOR PAGES TO BE SWAPPED IN
DEFQ SWPB	;GUYS WHO ARE SWAP BLOCKED
DEFQ SFLS	;GUYS IN SHORT WAITS
DEFQ LFLS	;GUYS IN LONG WAITS
DEFQ STOP	;GUYS WHO ARE STOPPED
DEFQ USER	;FOR CONFORMITY, USERS ARE KEPT HERE
DEFQ SPHR	;FOR CONFORMITY SPHERES ARE KEPT HERE
NQS==FOO
PFREEQ:	WORDS <PRSTAB,0,0>	;FREE PROCESS BLOCKS LIST POINTER
FOO==PRSTAB+PRSTEL
FOOBAR==PFREEQ
PRSTAB:	.REPT NPROSS
	FOO
	FOOBAR
FOO==FOO+PRSTEL
FOOBAR==.-4
	.=.+PRSTEL-4
	.ENDR
	WORDS <0,FOOBAR>
	.BLKB PRSTEL-2	;THE LAST PROCESS BLOCK MUST GO HERE

DTHING		;THE PROCESS ACTIVATE BLOCKS
DWORD ACTLNK	;LINK WORD
DWORD ACTITM	;PROCESS ITEM
DWORD ACTPI1	;ID WORD 1
DWORD ACTPI2	;ID WORD 2
ILISTS ACTFRE,,10.	;TEN OUGHT TO BE PLENTY
ACTLST:	0	;LIST TO ACTIVATE
.IFZ NP
;MEMORY TABLES
CST:	.BLKW MNCBLK	;ONE WORD PER BLOCK
	-1		;FENCE FOR PAGFRE
.IFZ NP
MEMIAT:	WORDS <1,0,0,2,0,1,0,3>	;INTIAL CORE ALLOCATIONS
FMMALT:	.BLKW 8		;ONE WORD PER PAGE SIZE (FOR FREE PAGES)
.ENDC
UMMALT:	.BLKW 8		;SAME FOR USED PAGES
CPT:	0	;UNUSED WORD
	.BLKB NCPTTE*CPTLEN	;THE ACTUAL CPT ENTRIES
CPTEND::
;SWAP VARIABLES AND TABLES
NUMBLKS:	0
TIMTSS:	0
	SWPTIM==10.	;HOW OFTEN TO RUN THE SWAP SCHEDULE
.ENDC
PTRITM:	0		;PAPER TAPE READER ITEM NO.
PTPITM:	0		;PAPER TAPE PUNCH ITEM NO.
.IIF NZ NP,.INSRT DISKS >
.SBTTL LIST SPACE
LSTSTO		;ACTUAL LIST STORAGE
INITSL		;STUFF TO INIT IT
0
ITMAFR==PFPTFR	;SINCE THESE SHARE TABLES
;DISPLAY VARIABLES
;AND PARAMTERS
.IFNZ NTKDIS
DISMAL==2
DISBIG==4
TKDLEN:	WORDS <DISMAL,DISMAL,DISMAL,DISMAL,DISBIG>
.IIF NE .-TKDLEN-<2*NTKDIS>,.ERROR BAD TKDLEN TABLE LENGTH
TKDITM:	.BLKW 8.	;THE ITEMS FOR THE DISPLAYS
TKDOWN:	.BLKW 8.	;IF DISPLAY OWNED
TKDPDA:	0		;PDL ADDRESS
TKDPDL:	0		;THE ITEM FOR THE DISPLAY PDLS
TKRELS:	0		;THE RELOCATION REGISTER FOR THE DISPLAY
TKDRUN:	WORDS <-1,-1,-1,-1,-1,-1,-1,-1>	;THE RUN FLAGS
TKDPDP:	WORDS <40,130,220,310,400,470,560,650>	;PDL POINTERS FOR EACH DISPLAY
DPUSHJ==100000
DSTOP==140400
TKRUN==4000
TKGO==10000
TKSTOP==20000
.ENDC

.IFNZ NTVS
NFTVDS==NTKDIS		;THE FIRST TV IS THE ONE AFTER THE TK DISPLAYS

;THIS TABLE CONTAINS THE REFERENCE COUNTS FOR EACH OF THE TVS. THE BUFFER
;FOR A TV SHOULD BE RELEASED WHEN THE REFERENCE COUNT REACHES ZERO. THE
;REFERENCE COUNT CAN BE INCREMENTED FOR EACH TTY ITEM WHICH REFERS TO
;THIS TV AND FOR EACH DISPLAY CAPABILITY TO THE TV.
TVDSRF:
.REPT NTVS
.BYTE 0
.ENDR

;TVDSBF CONTAINS THE BUFFER NUMBER OF EACH TV. THIS NUMBER IS -1 WHEN
;THERE IS NO BUFFER ALLOCATED TO A PARTICULAR TV.
TVDSBF:
.REPT NTVS
.BYTE -1
.ENDR

;TVBUFF SHOWS WHICH BUFFERS HAVE BEEN ALLOCATED. IF THE VALUE IS -1,
;THEN THE BUFFER IS FREE.  OTHERWISE, IT CONTAINS THE NUMBER OF THE
;TV WHICH USES THIS BUFFER.
TVBUFF:
.REPT NTVCHN
.BYTE -1
.ENDR
.ENDC


;TV DISPLAY CURSOR (OR TURTLE) VARIABLES
;Y POSITIONS
TVDSCY:	.REPT NTVCHN
	.WORD 0
	.ENDR

	;X POSITIONS
TVDSCX:	.REPT NTVCHN
	.WORD 0
	.ENDR

;FONT TABLE CONTAINS THE ITEM OF EACH FONT
NFONTS==2		;INITIALLY, THERE CAN BE TWO FONTS
FNTITM:	.BLKW NFONTS
ACLRP:	ACLRB
ACLRB:	.BLKW 20
ACLRBE::
.INSRT STYI >
.IIF NZ NP,.INSRT DISK >
	.STITL SWAPPING ROUTINES
;THIS ROUTINE TAKES A GIP IN B, AND CLEARS THE ADDRESS FIELDS OF THE UPTS IN CIRC LIST
ADRCLR:	MOV B,@ACLRP
	ADD #2,ACLRP
	MOV (P),@ACLRP
	ADD #2,ACLRP
	CMP #ACLRBE,ACLRP
	BNE .+10
	MOV #ACLRB,ACLRP
	SAVE B
	JSR PC,GIPCHK		;CHECK THAT THIS GUY IS NOT BEING SWAPPED
	JSR PC,UPTPLD		;BOGUS PUSH LOAD
	BR ADRCL3			;SKIP OVER LOAD
ADRCL1:	JSR PC,GIPCHK
	JSR PC,UPTLD		;LOAD NEXT UPT
ADRCL3:	BIC #<-UPASMS-1>,UPTAR(B)	;CLEAR ADDRESS FIELD
	MOV UPTCLP(B),B		;POINTER TO NEXT UPT
	BEQ ADRCL2		;NO MORE
	CMP B,(P)		;IS IT SAME AS FIRST
	BNE ADRCL1		;NO, CLEAR THE NEXT ONE'S
ADRCL2:	REST B			;GET BACK GIP
	JSR PC,ITM2PO		;POP UPT
	RTS PC

GIPCHK:	SAVE A
	MOV DSK0RQ,A
GIPCH3:	BEQ GIPCH1
	CMP B,DSKGIP(A)
	BNE .+4
	BPT
	MOV (A),A
	BR GIPCH3
GIPCH1:	CMP B,DKNGIP
	BNE .+4
	BPT
	REST A
	RTS PC

;THIS ROUTINE TAKES A CORE ADDRESS IN A, AND PUTS IT INTO THE UPTS IN CIRC LIST
ADRSET:	SAVE B
	JSR PC,UPTPLD
	BR ADRST3
ADRST1:	JSR PC,UPTLD		;LOAD NEXT UPT
ADRST3:	BIC #<-UPASMS-1>,UPTAR(B)	;CLEAR ADDRESS FIELD
	BIS A,UPTAR(B)		;SET IN NEW ONE
	MOV UPTCLP(B),B		;GET NEXT UPT
	BEQ ADRST2		;NO MORE
	CMP B,(P)		;SAME AS FIRST
	BNE ADRST1		;NOPE
ADRST2:	REST B
	JSR PC,ITM2PO		;POP UPT
	RTS PC
;THIS ROUTINE TAKES A GIP IN B, AND CLOBBERS A AND C.
;IT ALLOCATES CORE FOR THE PAGE IN B.  EXPECTS SPHERE THAT IS ASKING FOR IT
;TO BE IN ITEM1, BECAUSE IT CAN HANG.
PAGALL:	TST NWINRS		;ANY WINNERS LEFT?
	BGT PAGOK		;YES
	JSR F,ACSAV		;SAVE AC'S
	JSR PC,SWAPSC		;MAKE A SWAP SCHEDULE
	JSR F,ACRES		;GET BACK YOUR AC'S
PAGOK:	SAVE <B,D>
	JSR PC,UPTPLD		;LOAD THE UPT
	MOV UPTAR(B),B		;THE AR OF IT
	JSR PC,ITM2PO		;POP THE SPHERE
	BIT #<-UPASMS-1>,B		;IS IT IN CORE
	LBR NE,PAGAL8		;YES, NOTHING TO DO
	BIC #UPMLSW,B		;GET THE LENGTH
	SWAB B
	ASH #-3,B		;PUT IT INTO A WORD INDEX
PAGAL7:	MOV ITM1A,C
	MOV SPRTPT(C),C
	MOV FMMALT(B),A		;GET THE FIRST OF THE FREE LIST FOR IT
	BEQ PAGAL9
	MOV CPT(A),FMMALT(B)	;LINK OUT FREE PAGE
	TST PRTPRI(C)		;IS HE A WINNER
	BLT .+10		;NO
	BIS #CPTWIN,CPT+CPTADR(A)	;SAY IT BELONGS TO WINNER
	MOV UMMALT(B),CPT(A)	;LINK INTO LIST
	MOV A,UMMALT(B)		;PUT IT ON THE USED LIST
	MOV CPTADR+CPT(A),A	;THE CPT CORE ADDRESS
	MOV 2(P),B		;THE GIP
	BR PAGAL6		;SET THE ADDRESS INTO YOURS
PAGAL9:	TST PRTPRI(C)		;IS HE A WINNER
	BGE PAGAL2		;YES
PAGAL1:	JSR PC,SWAPB		;SWAP BLOCK YOURSELF
	TST PRTPRI(C)		;AM I STILL A LOSER
	BLT PAGAL1		;YES
	JSR PC,RUNME		;RUNME
	REST <D,B>
	LBR ,PAGALL		;MAKE SURE I AM STILL A WINNER
PAGAL2:	MOV #<UMMALT-CPT>,A	;MAKE THE FIRST LINK ACCESS THE USED LIST
	ADD B,A			;MAKE A POINT TO THE ONE OF THE RIGHT SIZE
PAGAL3:	MOV CPT(A),D		;GET THE NEXT ENTRY
	BEQ PAGAL4		;DOESN'T EXIST
	BIT #CPTWIN!CPTLCK,CPTADR+CPT(D)	;DOES IT BELONG TO A WINNER
	BNE PAGA11		;GRAB THIS ONE
	CMP #-1,CPTUPP+CPT(D)	;IS THIS A PAGE WITHOUT A GOOD UPT POINTER
	BNE PAGAL5		;NO
;IT IS PROBABLY A BUG THAT THESE PAGES EXIST, BUT WILL FIGURE IT OUT LATER
PAGA11:	MOV D,A			;POINTER TO NEXT ENTRY
	BR PAGAL3		;TRY IT
PAGAL4:	ADD #2,B		;TRY NEXT SIZE
	CMP B,#20		;THE LARGEST SIZE
	BLT PAGAL7		;TRY NEXT SIZE
	REST <D,B>		;SO THAT WE CAN START AGAIN
	JSR PC,PAGEW		;WAIT FOR A WHILE
	JSR PC,RUNME		;TRY AGAIN
	JMP PAGALL		;JUST CALL YOURSELF
	;BRANCHES INTO NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
PAGAL5:	MOV CPTUPP+CPT(D),C	;THE LOSER WHO USED TO OWN IT
	BEQ PAGA12
	BIT #GIPSPR,C		;IS IT A SPHERE UPT
	BNE PAGA12		;YES
	ADD #FUPTTB+100000,C	;POINT TO THE UPT
	CMP UPTPRP(C),PRUNNG	;BELONG TO ME
	BEQ PAGA11		;TRY ANOTHER ONE
PAGA12:	BIS #CPTWIN,CPTADR+CPT(D)	;SAY IT BELONGS TO A WINNER (IT MUST)
	MOV #LPCLRT,A		;RUN IT IF WE ARE PCLOSERED
	CLR B			;NO ITEM
	JSR PC,LOCKSW		;GET A SWITCH
	MOV #FREBLK,LCKWD1(A)	;FREE THE BLOCK JUST GRABBED IF WE LOSE
	MOV D,LCKWD2(A)		;POINTER TO THE CPT ENTRY
	MOV CPTUPP+CPT(D),B	;POINTER TO THE LOSER WHO USED TO OWN IT
	BEQ PAGA10		;NO ONE?
	JSR PC,PAGPCL		;PCLOSER ANYONE WHO LOOKS AT ME!
	MOV #CPTUDT,C		;UPDATE THE CPTMOVING BIT WHEN DONE
	MOV ITEM0,A		;PROCESS
	ASH #4,A		;PUT INTO RIGHT BITS
	BIS #DSKWRT,A		;DO A SWAP OUT
PAGL10:	MOV 2(P),CPT+CPTUPP(D)	;I OWN IT NOW!
	JSR PC,DSKRQ		;PLACE THE REQUEST
	JSR PC,DSKWT
	BEQ PAGL10		;TRY AGAIN
	JSR PC,ADRCLR		;CLEAR HIS ADDRESS
PAGA10:	JSR PC,LSWPOP		;POP THE SWITCH
	MOV 2(P),B		;THE CURRENT GIP
	MOV CPTADR+CPT(D),A	;THE ADDRESS
PAGAL6:	BIC #CPTCRM,A		;GET THE CORE ADDRESS
	ASH #4,A		;PUT INTO THE RIGHT BITS
	JSR PC,ADRSET		;SET IN THE ADDRESS
PAGAL8:	REST <D,B>		;DONE, JUST RETURN
	RTS PC

;THIS ROUTINE TAKES A GIP IN B AND FREES THE CORE ASSOCIATED WITH IT.
CORFRE:	SAVE <A,B,C>
	JSR PC,UPTPLD		;LOAD THE UPT
	MOV UPTAR(B),B		;THE AR
	JSR PC,ITM2PO		;POP THE ITEM PUSHED BY UPTPLD
	BIC #UPASMS!10,B	;GET THE CORE ADDRESS
	BEQ CORRET		;NO PAGE, MIGHT AS WELL LEAVE
	ASH #-3,B		;TURN IT INTO AN INDEX INTO CST
	BR PAGFR1		;FREE THE PAGE

;THIS ROUTINE WHEN GIVEN AN OFFSET INTO THE CST IN B, WILL FREE THE PAGE
PAGFRE:	SAVE <A,B,C>
PAGFR1:	ADD #CST,B	;MAKE B POINT DIRECTLY TO THE ENTRY FOR THIS PAGE
	CLR A		;A COUNT
	BIT #CSTSYB,(B)+	;IS IT USED BY THE SYSTEM
	BUGC EQ		;ERF, DON'T FREE SYSTEM'S CORE
PAGCNT:	BIT #CSTFBB!CSTSYB,(B)+	;IS THE NEXT BLOCK THE START OF ANOTHER PAGE
	BNE PAGFR2	;YES, FREE THIS BLOCK
	INC A		;INC THE COUNT
	BR PAGCNT	;GO TRY THE NEXT BLOCK
PAGFR2:	MOV A,C		;COPY THE COUNT - 1
	INC C		;MAKE C THE COUNT OF BLOCKS
	ASL A		;TURN THE COUNT INTO AN INDEX
	SUB A,B		;MAKE B POINT BACK TO THE START + 4
	SUB #4,B	;B NOW POINTS TO THE START
	BIS #CSTFRB,(B)+	;SET THE FREE BIT
	SOB C,.-4	;IN ALL THE CST ENTRIES FOR THIS PAGE
	MOV -(B),B	;THE CST ENTRY
	BIC #CSTCOM,B	;CLEAR ALL BUT THE CPT OFFSET
	MOV A,C		;THE COUNT *2
	ADD #<UMMALT-CPT>,C	;MAKE C POINT TO THE USED LIST OF THIS SIZE
PAGFR4:	CMP CPT(C),B	;DOES IT POINT TO THIS BLOCK
	BEQ PAGFR3	;YES
	MOV CPT(C),C	;GET THE POINTER
	BNE PAGFR4	;THERE IS ANOTHER ONE, CHECK IT OUT
	BPT		;IT WASN'T ON THE USED LIST!!!!!
PAGFR3:	CLR CPT+CPTUPP(B)	;CLEAR THE OWNER POINTER
	MOV CPT(B),CPT(C)	;LINK IT OUT OF THE USED LIST
	MOV FMMALT(A),CPT(B)	;MAKE B POINT TO THE START OF THE FREE LIST
	MOV B,FMMALT(A)	;LINK IT IN
CORRET:	REST <C,B,A>
	RTS PC
;THIS IS A PCLOSER ROUTINE THAT TAKES A BLOCK AND PUTS IT BACK ON THE FREE LIST
;IT EXPECTS A CPT NUMBER OF THE BLOCK IN LCKWD2(B)
FREBLK:	MOV LCKWD2(A),B	;THE CPT NUMBER
	MOV B,A		;SAVE POINTER TO CPT ENTRY
	MOV CPT+CPTADR(B),B	;THE ADDRESS
	BIC #CPTCRM,B	;CLEAR ALL BUT THE CORE ADDRESS
	ASL B		;TURN INTO CST OFFSET
	JSR PC,PAGFRE	;FREE THE PAGE
	CLR CPTUPP+CPT(A)	;NO ONE OWNS IT
FREBK1:	RTS PC

;THIS ROUTINE ALLOCATES BLOCKS OF SWAPPING SPACE.  IF B IS ZERO, IT ALLOCATES
;A SMALL BLOCK OF SPACE, ELSE A LARGE BLOCK.  IT RETURNS THE SWAP ADDRESS IN B
SWPAL:	SAVE <A,C,D>
	TST B		;ALLOCATE A LARGE BLOCK
	BNE LSWPAL	;YES
	SAVE #SSPBTP+2	;POINT TO THE POINTERS TO THE SMALL BIT TABLES
	BR SWPAL1	;ALLOCATE THE SPACE
LSWPAL:	MOV #1,B	;SAY WE ARE LOOKING AT BIG SPACES
	SAVE #LSPBTP+2
SWPAL1:	REST A
	MOV (A)+,C	;GET POINTER TO BIT TABLE
	BNE SWPAL2	;ANOTHER BIT TABLE
	TST B		;WAS HE ASKING FOR A SMALL SPACE
	BEQ LSWPAL	;YES CHECK THE BIG SPACES
	REST <D,C,A>	;NO SWAP SPACES LEFT
	SEZ
	RTS PC
SWPAL2:	SAVE A		;SAVE POINTER TO NEXT BIT TABLES
	TST (C)+	;PASS THE START WORD
	MOV (C)+,D	;GET THE LENGTH
	TST (C)+	;SKIP THE DISK NO. FOR NOW
	MOV D,A		;THE LENGTH IN BITS
	BIC #17,D	;CLEAR THE LOW ORDER BITS
	SUB D,A		;CALCULATE THE NUMBER LEFT OVER
	ASH #-4,D	;GET THE NUMBER OF WORDS IN THE TABLE
	BEQ SWPAL8
SWPAL3:	CMP (C)+,#-1	;ALL THE SWAP SPACES USED?
	BNE SWPAL4	;NOPE
	SOB D,SWPAL3	;GO BACK IF THERE IS MORE
SWPAL8:	TST A		;ANY LEFT OVERS
	BEQ SWPAL1	;NOPE
	BR .+4		;THIS TIME THE POINTER IS CORRECT ALREADY
SWPAL4:	TST -(C)	;GET POINTER TO CORRECT WORD
	MOV #100000,D	;BIT TO TEST
	MOV #16.,A	;CHECK ALL THE BITS
SWPAL5:	BIT D,(C)	;IS THIS BLOCK FREE
	BEQ SWPAL6	;YES
	CLC		;CLEAR THE CARRY SO THAT WE DON'T LOSE
	ROR D		;GET THE NEXT BIT
	SOB A,SWPAL5
	BR SWPAL1	;NO GOOD BLOCKS LEFT OVER
	;BRANCHES INTO THE NEXT PAGE
		;BRANCHED INTO FROM PREVIOUS PAGE
SWPAL6:	BIS D,(C)	;TAKE THIS BIT
	MOV (P),D	;POINTER TO THE NEXT BIT TABLE
	MOV -(D),D	;GET THE POINTER TO THE BIT TABLE
	SUB #6,C	;THE NUMBER OF TYPE WORDS AT THE START
	SUB D,C		;GET THE NUMBER OF WORDS TESTED
	ASH #3,C	;GET THE NUMBER OF BITS TESTED
	BIC #17,C	;CLEAR THE EXTRA BITS
	DEC A		;CORRECT THE BIT NO.
	ADD A,C		;THE NUMBER OF THE (BIT) WE SNARFED
	ASH #4,C	;PUT IT INTO THE OFFSET FIELD
	BIC #17,C
	ADD C,B		;SET THE BOTTOM BIT IF LARGE SPACE
	REST D		;POINTER TO THE CURRENT BIT TABLE + 1
	TST -(D)	;MAKE IT CORRECT
	BIT #1,B	;SMALL BIT TABLE
	BNE SWPAL7	;LARGE
	SUB #SSPBTP,D	;GET THE OFFSET INTO THE TABLE
	BR .+6
	;FALLS THROUGH TO NEXT PAGE
	;FALLS IN FROM PREVIOUS PAGE
SWPAL7:	SUB #LSPBTP,D	;THE OFFSET INTO TABLE	
	BIS D,B		;SET IN THE BIT TABLE NUMBER
	REST <D,C,A>
	CLZ
	RTS PC


;THIS ROUTINE DEALLOCATES SWAP SPACE.  IT TAKES THE SWAP ADDRESS OF THE SPACE TO
;FREE IN B.
DSWPAL:	SAVE <A,C>
	BIT #1,B	;IS IT A LARGE BLOCK?
	BEQ DSWPL1	;NO
	MOV #LSPBTP,C	;POINT TO THE LARGE BLOCK BIT TABLES
	BR .+6
DSWPL1:	MOV #SSPBTP,C	;POINT TO THE SMALL BLOCK BIT TABLES
	MOV B,A		;COPY THE SWAP ADDRESS
	BIC #UPTBTM,A	;CLEAR THE BIT TABLE MASK
	ADD A,C		;MAKE C POINT TO THE BIT TABLE POINTER
	MOV (C),C	;POINTER TO THE BIT TABLE
	BUGC NE		;THE BITTABLE DOESN'T EXIST
	BIC #UPTBOM,B	;CLEAR ALL BUT THE BIT TABLE MASK
	ASH #-4,B	;GET THE BIT TABLE OFFSET
	CMP B,2(C)	;IS THIS A VALID BIT
	BUGC LE
	ADD #6,C	;MAKE C POINT TO THE FIRST DATA BIT
	MOV B,A		;COPY THE OFFSET
	ASH #-3,A	;GET THE BYTE OFFSET
	ADD A,C		;MAKE C POINT TO THE CORRECT BYTE
	BIC #177770,B	;MAKE B THE OFFSET IN BYTE
	BICB BMT(B),(C)	;CLEAR THE BIT
	REST <C,A>
	RTS PC
;THIS ROUTINE TAKES A GIP IN B TO THE THING TO MOVE.
;A CONTAINS FUNCTION AND FLAGS, C THE ROUTINE TO RUN WHEN FINISHED
;IF THE PAGE IS WHERE IT IS SUPPOSED TO BE, DONT PLACE THE REQUEST
;AND SET Z
DSKRQ:	TST DSKFRE		;ANY FREE BLOCKS
	BNE DSKRQ2		;YES
DSKRQ1:	JSR PC,LFLUSH		;WAIT FOR ONE
	TST DSKFRE		;ANY YET
	BEQ DSKRQ1
	JSR PC,RUNME
	BR DSKRQ
DSKRQ2:	SAVE <A,B,C,PS>		;SAVE THE WORLD AND STATUS
	JSR PC,UPTPLD		;LOAD THE CURRENT UPT
	MOV UPTAR(B),C		;THE ADDRESS REGISTER
	BIC #UPASMS,C		;CLEAR ALL BUT THE ADDRESS
	ASH #-3,C		;TURN IT INTO CST OFFSET
	MOV CST(C),C		;GET THE CST ENTRY
	BIC #CSTCOM,C		;GET THE CPT OFFSET
	ADD #CPT,C		;MAKE C POINT DIRECTLY TO IT
DSKRQ3:	BIT #CPTMOV,CPTADR(C)	;IS IT MOVING
	BEQ DSKRQ5		;NO
	MOV ITEM2,A		;SAVE THE UPT'S ITEM
	JSR PC,ITM2PO		;POP THE UPT
DSKRQ4:	JSR PC,LFLUSH		;WAIT FOR IT TO STOP MOVING
	BIT #CPTMOV,CPTADR(C)	;HAS IT STOPPED
	BNE DSKRQ4		;NO
	JSR PC,RUNME		;I THINK I HAVE IT
	JSR PC,ITM2PL		;LOAD UP THE UPT AGAIN
	MOV 6(P),A		;GET BACK THE FUNCTION
	TST DSKFRE		;MAKE SURE WE STILL HAVE A REQUEST BLOCK
	BNE DSKRQ3		;STILL HAVE ONE
	REST <PS,C,B,A>		;RESTORE THE WORLD
	JSR PC,ITM2PO
	BR DSKRQ1		;WAIT FOR ONE TO BECOME AVAILABLE
DSKRQ5:	MOV 6(P),A		;GET THE FUNCTION
	BIC #DSKFNT,A		;CLEAR ALL BUT THE FUNCTION
	BIT #UPTICR,UPTAR(B)	;IS IT IN CORE
	LBR EQ,RQOUT		;NO
	CMP #DSKRD,A		;IS IT A READ
	BNE DSKRQ7		;NO, EVERYTHING IS FINE
DSKRQ6:	JSR PC,ITM2PO		;POP THE UPT
	REST <PS,C,B,A>		;RESTORE THE WORLD
	RTS PC
DSKRQ7:	SAVE <#120,C,D>
	CLR CPTUPP(C)		;IT IS BEING SWAPPED OUT, CLEAR THE CPT'S POINTER TO UPT
	MOV UPTFPT(B),A		;THE SWAP ADDRESS
	BGE DSKRQ8		;IT ISN'T A FPT OR PFPT
	ASL A			;MAKE A POINT TO THE FPT
	TST FPTSWA(A)		;IS IT A PFPT
	BMI DSKRQ8		;YES
	BIT #FPTWSB!FPTTSR,FPTFLG(A)	;IS IT TEMPORARY WRITE TO SOURCE
	BEQ DSKRQ8		;NO
	MOV #160,D		;THE W+M+N BITS
	MOV #140,4(P)		;THE W+M BITS
	BR .+6

DSKRQ8:	MOV #120,D		;THE W+N BITS
	MOV 12(P),B		;THE CURRENT UPT
	CLR C			;THE INCLUSIVE OR'S OF A,W,M, AND N BITS
DSKRQ9:	JSR PC,UPTLD		;LOAD THE UPT
	BIS UPTDR(B),C		;SET IN THE BITS
	BIC D,UPTDR(B)		;CLEAR THE CORRECT BITS
	MOV UPTCLP(B),B		;THE NEXT UPT
	BEQ DSKR10		;NO MORE
	CMP 12(P),B		;IS IT THE ORIGINAL ONE
	BNE DSKRQ9		;NO, FIX IT UP
DSKR10:	MOV 12(P),B		;THE ORIGINAL UPT
	JSR PC,UPTLD		;LOAD IT UP
	MOV (P),D		;GET BACK REGISTER
	MOV C,(P)		;TEMP STORE
	MOV 2(P),C		;POINTER TO CPT
	REST (P)		;MAKE THE TOP OF STACK THE BITS
	BIT (P)+,(P)+		;EITHER W OR N BITS SET
	BNE DSKR11		;PLACE THE REQUEST
	MOV 6(P),A		;GET THE FUNCTION
	MOV 4(P),B		;GET BACK GIP
	JSR PC,UPTSET		;CLEAR THE IN CORE BITS
	BIC #177771,A		;CLEAR EXTRA BITS
	CMP A,#DSKRD		;IS IT A READ
	BEQ DSKRQ6		;YES
	JSR PC,UPTLD		;LOAD IT
	MOV UPTFPT(B),A		;THE FPT POINTER
	BPL DSKRQ6		;JUST SWAP AREA
	ASL A			;GET TO THE FPT
	BIT #FPTWSB!FPTTSR,FPTFLG(A)	;WAS IT SUPPOSED TO BE WRITE TO SOURCE
	BEQ DSKRQ6		;NOPE OKAY
	MOV UPTAR(B),B		;GET UPTAR
	MOV B,C			;COPY IT
	BIC #UPMLSW,B		;GET THE LENGTH
	SWAB B
	ASH #-4,B		;INTO THE CORRECT BITS
	INC B			;CORRECT IT SINCE 0=1
	BIC #UPMSSW,C		;GET THE START
	ASL C			;INTO WORD OFFSET
	ADD C,A			;POINT TO THE BLOCK THAT STARTS IT
	ADD #FPTSRC,A		;MAKE IT ABSOLUTE
	BIS #FPTBAS,(A)+	;SET THE BLOCK AT SOURCE
	SOB B,.-4		;DO IT FOR ALL
	JMP DSKRQ6		;DONE
RQOUT:	CMP A,#DSKRD		;IS IT A READ REQUEST
	BNE DSKRQ6		;NO, FLUSH IT
	MOV 4(P),CPTUPP(C)	;FIX THE CPT POINTER TO UPT
DSKR11:	SPL 5			;STOP THE DISK
	BIS #CPTMOV,CPTADR(C)	;SAY THE PAGE IS MOVING
	MOV DSKFRE,B		;GET THE FREE BLOCK
	BUGC NE			;THERE BETTER BE ONE
	MOV (B),DSKFRE		;LINK THROUGH
	MOV (P),PS		;RESTORE THE LOW PRIORITY
	CLR (B)+		;CLEAR THE FORWARD POINTER
	MOV 4(P),(B)+		;SET IN THE GIP
	MOV 6(P),A		;THE FUNCTION
	MOV A,(B)+		;SET IN THE FUNCTION
	MOV 2(P),(B)+		;SET IN THE ROUTINE TO RUN WHEN DONE
	MOV CPTADR(C),(B)		;SET IN THE ADDRESS
	BIC #CPTCRM,(B)+	;CLEAR EXTRA STUFF
	SUB #DSKLEN,B		;MAKE B POINT TO THE START AGAIN
	SPL 5			;STOP THE DISK AGAIN
	MOV #DSK0RQ,C		;THE POINTER TO THE DISK REQUEST LIST
DSKR12:	TST (C)			;IS THIS THE END
	BEQ DSKR13		;YES
	MOV (C),C		;GET NEXT REQUEST
	BR DSKR12		;TRY THE NEXT ONE
DSKR13:	MOV B,(C)		;LINK THIS ONE ON
	TST CURTRN		;IS THE DISK RUNNING
	BNE DSKR14		;YES
	BIC #100,RKCS		;THIS WILL CAUSE THE DISK TO INTERRUPT
	BIS #100,RKCS		;SET THE INTERRUPT ENABLE
DSKR14:	REST PS			;RESTORE LOW PRIORITY
	MOV 2(P),B		;THE GIP
	JSR PC,UPTSET		;SET OR CLEAR THE IN CORE BIT
	JSR PC,ITM2PO		;POP THE UPT
	REST <C,B,A>		;RESTORE THE REGISTERS
	RTS PC
;THIS ROUTINE TAKES THE SAME THINGS AS DSKRQ, AND CHECKS TO SEE THAT
;THE TRANSFER FINISHED CORRECTLY. IF NOT, RETURNS WITH Z SET
DSKWT:	SAVE B
	JSR PC,UPTPLD
	MOV UPTAR(B),B		;THE AR
	BIC #UPASMS,B		;CLEAR ALL BUT THE ADDRESS
	ASH #-3,B		;TURN INTO CST OFFSET
	MOV CST(B),B		;THE CST ENTRY
	BIC #CSTCOM,B		;GET CPT OFFSET
	JSR PC,ITM2PO		;POP UPT
	BIT #CPTMOV,CPT+CPTADR(B)	;IS IT MOVING
	BEQ DSKWT1		;NO, GO ON
DSKWT3:	JSR PC,PAGEW		;WAIT FOR THE DISK TO WAKE US UP
	BIT #CPTMOV,CPT+CPTADR(B)	;IS IT MOVING
	BNE DSKWT3		;YES
	JSR PC,RUNME		;MAKE SURE WE ARE WOKEN UP CORRECTLY
DSKWT1:	MOV (P),B		;GET BACK UPT POINTER
	SAVE A
	JSR PC,UPTPLD		;LOAD THE UPT
	BIC #DSKFNT,A		;CLEAR ALL BUT THE FUNCTION
	BIT #UPTICR,UPTAR(B)	;IS IT IN CORE
	BNE RQINCO		;YES
	CMP A,#DSKRD		;WAS IT A READ
	BEQ RQRTRY		;YES, RETRY IT
DSKWT2:	JSR PC,ITM2PO		;POP UPT
	REST <A,B>		;RETURN SUCCESSFUL
	RTS PC
RQINCO:	CMP A,#DSKRD		;WAS IT A READ
	BEQ DSKWT2		;YES, WE WON
RQRTRY:	JSR PC,ITM2PO		;POP UPT
	REST <A,B>
	SEZ			;SAY WE LOST
	RTS PC
;THESE ROUTINES ALL TAKE A GIP IN B TO WHAT SHOULD BE SWAPPED
SWPIN:	JSR PC,SAVAWB		;SAVE THE A&B BITS
	SAVE <A,B,C>		;SAVE THE REGISTERS
SWPIN1:	MOV B,C			;COPY UPT POINTER
	JSR PC,UPTPLD		;LOAD IT UP
	CMP B,#ITM2AD+SUPTS+<UPTLEN*10>	;IS IT A DATA PAGE
	BLO SWPIN4		;NO
	BIT #UPTDEI,UPTDR(B)	;IS IT D=I
	BEQ SWPIN4		;NO, FORGET IT
	SUB #20000,C		;CLEAR THE DATA BIT IN THE GIP
SWPIN4:	JSR PC,ITM2PO		;POP THE ITEM
	MOV C,B			;NEW GIP
	SAVE B
	JSR PC,PAGALL		;ALLOCATE CORE IF NEEDED
	MOV #DSKRD,A		;SAY THAT IT IS A READ REQUEST
	MOV ITEM0,C		;THE PROCESS ITEM NO. (WHO TO WAKE UP WHEN DONE)
	ASH #4,C		;PUT IT INTO THE CORRECT BITS
	BIS C,A			;SET IT INTO THE FUNCTION WORD
	MOV #CPTUDT,C		;UPDATE THE CPT WHEN FINISHED
	JSR PC,DSKRQ		;PLACE THE REQUEST
	JSR PC,DSKWT		;WAIT FOR IT TO FINISH
	BEQ SWPIN1		;IT WAS SWAPPED OUT AGAIN WHILE WE WERE WAITING
	JSR PC,UPTPLD		;LOAD IT UP
	MOV UPTFPT(B),A		;POINTER TO SWAP ADDRESS OR FPT
	BPL SWPIN2		;IT IS A SWAP ADDRESS
	ASL A			;MAKE A POINT TO THE FPT OR PFPT
	MOV PFPPTR(A),A		;POINTER TO SWAP SPACE (IS IT FPT)
	BPL SWPIN2		;YES
	SAVE E			;GET THIS REGISTER
	ASL A			;MAKE ABSOLUTE POINTER TO FPT
	MOV A,E			;SAVE IT FOR LATER
	MOV FPTMFI(A),A		;POINTER TO THE MFI
	JSR PC,MFIDLP		;DELETE IT IF REFERENCE COUNT IS 0
	BPL SWPIN3		;DIDN'T DELETE IT
	MOV #-1,FPTMFI(E)	;SAY NO MORE MFI
SWPIN3:	DEC FPTREF(E)		;DECREMENT THE REF COUNT
	BGT .+6			;STILL NOT 0
	JSR PC,FPTDEL		;DELETE THE FPT IF NO UPT'S
	REST E			;RESTORE REGISTERS
	MOV (P),B		;POINTER TO UPT
	JSR PC,UPTLD		;LOAD IT UP
	MOV UPTFPT(B),A		;POINTER TO PFPT
	ASL A			;POINT TO IT DIRECTLY
	MOV PFPSWA(A),UPTFPT(B)	;MAKE THE UPT POINT TO THE SWAP SPACE DIRECTLY
	MOV PFPTFR,(A)		;LINK THE PFPT ONTO THE FREE LIST
	MOV A,PFPTFR		;FINISH THE JOB
SWPIN2:	JSR PC,ITM2PO		;POP THE UP
	REST <B,C,B,A>		;RESTORE THE REGS
	RTS PC			;RETURN


SWPOT:	JSR PC,SAVAWB		;SAVE A&W BITS
	SAVE <A,B,C>
SWPOT1:	JSR PC,PAGPCL		;PC-LOSER EVERY ONE NEAR THESE PAGES
	JSR PC,UPTPLD		;LOAD IT UP
	MOV UPTAR(B),A		;GET THE OLD ADDRESS
	JSR PC,ITM2PO		;POP OFF THE GIP
	BIC #170017,A		;IS THERE A CORE ADDRESS
	BEQ SWPOT2		;NO MUST BE OUT ALREADY
	MOV 2(P),B		;GET BACK THE GIP
	MOV #DSKWRT,A		;SAY A WRITE FUNCTION
	MOV ITEM0,C		;THE PROCESS TO WAKE UP WHEN DONE
	ASH #4,C		;PUT IT INTO THE CORRECT BITS
	BIS C,A			;FIX UP THE FUNCTION WORD
	MOV #CPTUDT,C		;ROUTINE TO RUN WHEN DONE
	JSR PC,DSKRQ		;PLACE THE REQUEST
	JSR PC,CORFRE		;FREE THE CORE
	JSR PC,DSKWT		;WAIT FOR IT TO FINISH
	BEQ SWPOT1		;FAILED TRY AGAIN
	JSR PC,ADRCLR		;CLEAR THE ADDRESS
SWPOT2:	REST <C,B,A>		;RESTORE THE REG.
	RTS PC
	.STITL ALLOCATION ROUTINES
;THIS ROUTINE ALLOCATES BIT TABLES
;(A) IS THE FIRST FREE SMALL POINTER SLOT, (B) IS THE SAME FOR LARGE SWAP AREAS
;(C) IS THE FIRST FREE WORD IN BIT TABLE STORAGE
;2(P) IS THE LENGTH, 4(P) IS THE START, 6(P) IS THE LOGICAL DISK NO.
BTABLE:	JSR F,ACSAV	;SAVE THE AC'S
	MOV BTRATO,F	;THE RATIO OF LARGE SWAP SPACES/SMALL SWAP SPACES
	ASH #3,F	;MULTIPLY IT BY 8.
	ADD BTRATO+2,F	;ADD THE NUMBER OF SMALL SWAP SPACES
	MOV 22(P),A	;THE START OF THE SWAPPING AREA
	MOV 20(P),E	;THE LENGTH OF THE SWAP AREA
	MOV E,D		;FOR THE DIVIDE
	CLR C		;FOR THE DIVIDE
	DIV F,C		;DETERMINE THE NUMBER OF LARGE AREAS TO LOCATE
	BEQ SMALAL	;NO BIG BLOCKS ALLOCATE 512 WORD ONES
LRGAL:	TST BTRATO	;SHOULD BE ALLOCATE ANYTHING
	BEQ SMALAL	;NOPE
	SAVE <D,C>
	MUL BTRATO,C	;THE NUMBER OF LARGE SWAP AREAS
	MOV D,C		;DITTO
	MOV C,F		;THE LENGTH OF THIS TABLE
	MOV 10(P),(B)+	;SET UP POINTER TO BITTABLE
	MOV B,6(P)	;UPDATE THE POINTER TO NEXT LARGE BIT TABLE
	MOV -(B),B	;MAKE B POINT TO THE ACTUAL STORAGE
	MOV 22(P),D	;THE LOGICAL DISK NO.
	ASH #3,C	;GET THE NUMBER OF BLOCKS WE ARE ALLOCATING
	JSR PC,BTALLO	;ALLOCATE THE BIT TABLE
	REST <F,D>
	ADD C,A		;UPDATE THE POINTER TO THE START
	BR SMALA1	;ALLOCATE SMALL BIT TABLES
SMALAL:	CLR F		;SAY THERE IS NO CONTRIBUTION FROM THE RATIO
	MOV 4(P),B	;POINTER TO THE FIRST ALLOCATED SPACE
SMALA1:	CLR E		;FOR THE MULTIPLY
	MUL BTRATO+2,F	;THE NUMBER OF SMALL SWAP AREAS
	ADD D,F		;ADD THE REMAINDER TO THE NUMBER TO ALLOCATE
	BEQ BTABRT
	MOV (P),E	;POINTER TO FIRST SMALL SLOT
	MOV B,(E)+	;MAKE THE POINTER POINT TO THE STORAGE
	MOV E,(P)	;UPDATE POINTER TO THE NEXT SMALL BIT TABLE
	MOV 16(P),D	;THE LOGICAL DISK NO.
	JSR PC,BTALLO	;ALLOCATE THE BIT TABLE
BTABRT:	MOV B,4(P)	;UPDATE THE POINTER TO FREE STARAGE
	JSR F,ACRES	;RESTORE THE AC'S
	RTS PC		;RETURN
;THIS ROUTINE TAKES A POINTER TO THE STORAGE IN B, RETURNS POINTER TO FIRST FREE 
;WORD IN STORAGE IN B.  TAKES NUMBER OF BITS TO ALLOCATE IN F, DOESN'T CLOBBER IT
;TAKES START OF THE FIELD IN A, IT ALSO TAKES THE LOGICAL DISK NO. IN D
BTALLO:	SAVE <C,D>
	MOV A,(B)+	;SET IN THE START FIELD
	MOV F,(B)+	;SET IN THE LENGTH
	MOV (P),(B)+	;SET IN THE LOGICAL DISK NO.
	MOV F,E		;THE LENGTH
	ASH #-4,E	;THE NUMBER OF WORDS TO ALLOCATE
	BIT #17,F	;WERE ANY OF THE LOW ORDER BITS SET
	BEQ .+4		;NO, THE COUNT IS CORRECT
	INC E		;CORRECT THE COUNT
	ASL E		;TURN IT INTO A BYTE INDEX
	ADD E,B		;UPDATE POINTER TO END OF BIT TABLE
	ASH #3,E	;TURN THE COUNT INTO NUMBER OF BITS ALLOCATE
	SUB F,E		;GET THE NUMBER OF EXTRA BITS
	BEQ BTALRT	;NONE, RETURN
	MOV #-1,C	;SET ALL THE BITS
	CLR D		;CLEAR THE MASK
	NEG E		;GET THE NEGATIVE OF THE NUMBER OF EXTRA BITS
	ASHC E,C	;SET THE NUMBER OF HIGH ORDER BITS = TO THE NUMBER OF EXTRA BITS
	MOV D,-2(B)	;SET IT INTO THE LAST WORD OF THE BIT TABLE
BTALRT:	CMP B,#BITEND	;ARE WE AT THE END OF THE BIT TABLE
	BUGC LE		;PASSED THE END, BARF!!
	REST <D,C>
	RTS PC
	.STITL DISK INTERRUPT ROUTINES
RKBRK:	JSR F,ACSAV	;SAVE THE AC'S
	MOV RKCS,A	;GET THE STATUS REGISTER
	TST A
	BLT .+6		;THERE WAS AN ERROR
	JMP DSKBRK
	INC NRKERS	;SAY THERE WAS ONE MORE ERROR
	BIT #66340,RKER	;A BAD ERROR
	BEQ RKSOFT
RKHARD:	HALT
	MOV #-NRETRY-1,RETRYS	;TRY AGAIN
	BR .+6
RKSOFT:	INC RETRYS	;INCREMENT THE RETRYS
	BGE RKHARD
	MOV #1,RKCS	;CONTROL RESET
	MOV #CURTRN+10,A
	MOV #RKDA+2,B
	JSR PC,RKDSK1
	BR RETRY
DSKLOS:	INC NRFERS	;INCREMENT THE NUMBER OF ERRORS
	BIT #40000,A	;IS IT FROZEN
	BNE DSKLS1	;YES
	BIT #26000,A	;IS IT WRITE CHECK,NED, OR WRITE LOCKOUT
	BEQ DSKLS2	;NO, MUST BE PARITY
RFHARD:	BPT
DSKLS1:	BIT #2000,RFDAE	;NXM?
	BNE RFHARD	;YES
DSKLS2:	INC RETRYS
	BGE RFHARD	;TRIED TO MANY TIMES
	MOV #400,RFCS	;POWER CLEAR THE DISK
RETRY:	JSR F,ACRES	;RESTORE AC'S
	RTT		;GET OUT

RFBRK:	JSR F,ACSAV
	MOV RFCS,A	;THE STATUS REGISTER
	TST A
	BLT DSKLOS	;THERE WAS AN ERROR
;THIS ROUTINE IS CALLED BY THE INDIVIDUAL DISK BREAK ROUTINES
;IT UPDATES THE CPT (IF NECESSARY) AND SETS UP NEXT TRANSFER
DSKBRK:	TST CURTRN	;IS THIS THE FIRST TIME
	BEQ DSKBR1	;YES
	BIT #FPTPR!WRTCHK,DSKFLG	;DONE WITH PREVIOUS TRANFER
	BNE DSKBR1	;NO WAY
MOV DSKRT,A	;GET THE ROUTINE TO RUN
	BEQ DSKBR1	;NONE
	MOV #DSKFLG,C	;ROUTINES EXPECT IT
	JSR PC,(A)	;DO IT
DSKBR1:	MOV #DKNRP,A	;POINTER TO THE POINTER TO THE DISK REGISTERS
	MOV (A),B	;GET THE POINTER TO THE DISK REGISTERS
	BNE DSKBR2	;GOT ONE
	JSR PC,DSKGRB	;GET ME A DISK BLOCK
	MOV #DKNRP,A	;SAME AS ABOVE
	MOV (A),B	;GET THE LOGICAL DISK NO.
	BNE DSKBR2	;GOT ONE
	CLR CURTRN	;TELL IT THERE IS NO TRANSFER
	BR DSKBRT	;RETURN
DSKBR2:	JSR PC,@DSKTB(B)	;JUMP TO THE RIGHT ROUTINE
	MOV #-NRETRY,RETRYS	;SET UP THE NUMBER OF RETRYS ALLOWED
	MOV #DKNCS,A	;POINT TO START OF THE TRANSFER
	MOV #CURTRN,B	;POINT TO THE CURRENT TRANSFER STORAGE
	MOV #12,C	;THE NUMBER OF THINGS TO COPY
	MOV (A)+,(B)+	;COPY THE TRANSFER
	SOB C,.-2	;DO IT FOR ALL THE WORDS
	CLR DKNGIP
	JSR PC,DSKGRB	;PROCESS ANOTHER DISK REQUEST
DSKBRT:	JSR F,ACRES	;THE INTERRUPT ROUTINES PUSHED THEM
	RTT
;THESE ROUTINES ARE DISPATCHED TO, TO FILL THE DISK REGISTERS FROM DKNCS . . .
BADDSK:	BPT		;THERE IS NO DISK 0
	BR .-2
RFDSK:	MOV #RFDAE,B	;POINTER TO DISK REGISTERS
	MOV #DKNDAE,A	;POINTER TO DAE IN DKN LIST
	MOV (A),(B)	;TRANSFER THE DAE
	BR RKDSK1	;TRANSFER THE REST

RKDSK:	MOV #DKNDAE,A	;POINTER TO THE DKN LIST
	MOV #RKDA+2,B	;POINTER TO THE DISK REGISTERS
	BIT #60,DKNCS	;IS A MEMORY EXTENSION BIT ON?
	BNE RKDSK1	;YES
	CMP #LSTILC,DKNBA	;DOES IT START BEFORE SITS ENDS?
	BLOS RKDSK1	;NO
	BPT
RKDSK1:	MOV -(A),-(B)	;TRANSFER THE DA,BA,WC,CS
	MOV -(A),-(B)
	MOV -(A),-(B)
	MOV -(A),-(B)
	RTS PC

;THESE ROUTINES USED TO COMPUTE THE DISK ADDRESS AND BUSS EXTENTION
;CALLED WITH STARTING BLOCK NO. IN B, AND POINTER TO THE REQUEST IN C
BADDAC:	BPT		;NO DISK 0
	BR .-2
RK3DAC:	SAVE #60000
	BR RKDAC
RK2DAC:	SAVE #40000
	BR RKDAC
RK1DAC:	SAVE #20000	;THE CONSTANT TO ADD TO DA
	BR RKDAC	;GO ON AS NORMAL DISK 0
RK0DAC:	CLR -(P)	;DONT ADD ANYTHING
RKDAC:	CLR A		;FOR THE DIVIDE
	ASL B		;2 SECTORS/BLOCK
	DIV #12.,A	;A = NO. OF TRACKS, B = NO. OF SECTORS
	ASH #4,A	;PUT THE TRACKS IN THE RIGHT SPOT
	ADD B,A		;GET THE TOTAL DISK ADDRESS (WITHOUT THE DISK NO.)
	BIS (P)+,A	;SET IN THE DISK NO.
	MOV A,DKNDA	;SET IT INTO THE DISK ADDRESS
	RTS PC

RFDAC:	CMP DSKWD(C),#DSKWCH	;IS IT A WRITE CHECK AND THEN CHECK
	BNE RFDA1	;NO
	MOV #DSKWRT,DSKWD(C)	;FIX IT (RF HAS NO WRITE CHECK)
	BIC #WRTCHK,DKNFLG
RFDA1:	CLR A		;FOR THE SHIFT
	ASHC #9.,A	;GET THE DISK ADDRESS
	MOV A,DKNDAE	;THE DISK ADDRESS EX.
	MOV B,DKNDA	;THE DISK ADDRESS
	RTS PC

;THIS ROUTINE PROCESSES A REQUEST OF THE LIST.
;NOTE THAT THIS ROUTINE CANNOT PUSH ANYTHING AT THE START BECAUSE IT JUMPS OFF TO FPTGRB
;AND FPTINT, WHO DONT EXPECT ANYTHING ON STACK EXCEPT RETURN ADDRESS
DSKGRB:	MOV DSK0RQ,C	;POINTER TO THE FIRST REQUEST
	BNE DSKGR1	;WE GOT ONE
	CLR DKNRP	;SAY NO TRANSFER
	RTS PC
DSKGR1:	MOV DSKFLG,F	;THE FLAGS FOR THE PREVIOUS TRANSFER
	BIT #WRTCHK,F	;WAS IT A WRITE THEN CHECK FUNCTION
	BEQ DSKGR2		;NO,
	BIC #17,DKNCS	;CLEAR OUT THE OLD FUNCTION
	BIS #DSKWCK,DKNCS	;SET IN THE WRITE CHECK FUNCTION
	BIT #FPTPR,F	;ARE WE PROCESSING AN FPT
	BNE .+10		;YES, DON'T TOUCH A THING
	BIC #WRTCHK,DKNFLG	;CLEAR ALSO THE WRITE CHECK FUNCTION
	RTS PC
DSKGR2:	BIT #FPTPR,F	;ARE WE IN THE PROCESS OF CRUNCHING FPT
	BEQ .+6		;YES
	JMP FPTGRB	;DO THE FPT'S STUFF
DSKGR4:	MOV DSKGIP(C),DKNGIP
	MOV DSKRTN(C),DKNRT	;SET UP ROUTINE TO RUN
	MOV DSKWD(C),B	;GET THE FUNCTION WORD
	BIC #DSKFNT,DSKWD(C)	;CLEAR ALL BUT THE FUNCTION
	ASH #-4,B	;GET ONLY THE TOP BITS
	MOV B,DKNITM	;THEY ARE THE ITEM OF THE PROCESS
	MOV DSKGIP(C),B	;THE UPT POINTER
	JSR PC,UPTPLD	;LOAD IT
	MOV UPTAR(B),A	;GET THE ADDRESS OF THE PAGE
	BIC #UPASMS,A	;CLEAR ALL BUT THE CORE ADDRESS
	ASH #-3,A	;GET THE NUMBER IN 512 WORD BLOCKS * 2
	MOV A,DKNCST	;SET UP CST POINTER
	TST UPTFPT(B)	;IS IT AN FPT
	BGE .+6		;NO
	JMP FPTINT	;INITIALIZE THE FPT
	MOV B,F		;COPY POINTER TO UPT
	MOV UPTAR(F),B	;GET THE AR AGAIN
	MOV B,D		;COPY IT
	CLR C		;FOR THE ASHC
	BIC #UPASMS,D	;GET THE NUMBER OF 512 BLOCKS.
	ASHC #6,C	;GET THE CORE ADDRESS AND MEMORY EX.
	MOV D,DKNBA	;STORE THE BUSS ADDRESS
	ASH #4,C	;PUT MEMEX INTO CORRECT BITS.
	MOV C,DKNCS	;SET UP CONTROL STATUS
	MOV DSK0RQ,C	;PONTER TO THE REQUEST
	BIC #UPMSSW,B	;CLEAR ALL BUT THE OFFSET TO SWAPPING PAGE.
	MOV UPTFPT(F),A	;GET THE SWAP ADDRESS
	JSR PC,SWPPR	;GET THE DA,DAE, RP
	MOV UPTAR(F),A	;GET THE LENGTH AGAIN
	JSR PC,ITM2PO	;POP UPT
	BIC #UPMLSW,A	;CLEAR ALL BUT THE MASTER LENGTH
	ASH #-3,A	;GET THE LENGTH IN WORDS
	ADD #512.,A	;ALWAYS ONE BLOCK
	NEG A		;DISK WANTS NEGATIVE WORD COUNT
	MOV A,DKNWC	;SET UP WORD COUNT
	MOV DSKWD(C),A	;THE FUNCTION
	MOV (C),DSK0RQ	;LINK OUT THE REQUEST
	MOV DSKFRE,(C)	;AND LINK IT INTO FREE LIST
	MOV C,DSKFRE
	CMP A,#DSKWCH	;IS IT WRITE THEN CHECK?
	BEQ DSKGR3	;YES
	BIS #101,A	;SET THE INTERRRUPT ENABLE, AND GO BITS
	BIS A,DKNCS	;SET INTO THE CONTROL REG.
	RTS PC
DSKGR3:	MOV #WRTCHK,DSKFLG	;WRITE CHECK
	BIS #DSKWRT+101,DKNCS	;SAY WRITE ,GO AND INTERRUPT ENABLE
	RTS PC

FPTINT:	MOV UPTAR(B),F	;GET THE SWAPPING INFO
	MOV F,D		;COPY IT
	BIC #UPMLSW,F	;GET THE SWAPPED LENGTH
	SWAB F		;GET LOW BITS
	ASH #-4,F	;GET THE LENGTH
	BIC #UPMSSW,D	;GET THE START OFFSET
	ASL D
	SAVE <F,D>	;FOR CHECKING LATER
	ASH #5,D	;GET IT INTO THE CORRECT BITS
	BIS D,F		;SET THE TWO FIELDS TOGETHER
	BIS #FPTPR,F	;SAY WE ARE PROCESSING FPT
	MOV UPTFPT(B),D	;POINTER TO THE FPT OR PFPT
	ASL D		;GET THE FPT OR PFPT ADDRESS
	TST FPTSWA(D)	;IS IT A PFPT
	BPL FPTIN1	;NO
	MOV PFPPTR(D),D	;POINTER TO THE FPT
	ASL D		;POINT DIRECTLY TO THE FPT
	BIS #PFPTFL,F	;SAY THIS IS A PFPT
	BIS #UPTNEW,(D)	;SAY THIS IS A NEW PAGE
FPTIN1:	MOV D,DSKGIP(C)	;REPLACE THE GIP POINTER
	ADD (P)+,D	;POINT TO THE STARTING BLOCK (ALMOST TRUE)
	REST A		;COUNT OF BLOCKS
	INC A		;0 IS ONE BLOCK
	ADD #FPTSRC,D	;POINT DIRECTLY TO THE BLOCKS
	CMP DSKWD(C),#DSKRD	;IS IT A READ?
	BNE FPTIN4	;NO, FORGET IT
FPTIN2:	TST (D)+	;IS IT AT SOURCE
	BPL FPTIN3	;NO, FORGET IT
	BIS #UPTNEW,(B)	;SAY NEW PAGE
	BR FPTIN4	;DONE WITH THIS STUFF
FPTIN3:	SOB A,FPTIN2	;TRY ALL THE BLOCKS
FPTIN4:	BIT #PFPTFL,F	;IS IT A PFPT
	BNE FPTIN5	;DONT WRITE TO SOURCE FOR ANY REASON
	MOV DSKGIP(C),A	;POINT TO THE FPT
	BIT #FPTWSB!FPTTSR,FPTFLG(A)	;IS IT WRITE TO SOURCE, OR TEMP WRITE TO SOURCE
	BEQ FPTIN5	;NO
	BIC #FPTTSR,FPTFLG(A)	;CLEAR THE TEMP WRITE TO SOURCE
	BIS #WRTSR,F	;SET THE WRITE TO SOURCE BIT
FPTIN5:	MOV F,DKNFLG	;SET UP THE FLAGS
	JSR PC,ITM2PO	;POP THE UPT ITEM

;FALL INTO THE NORMAL ROUTINE

;EXPECTS THE FLAGS FOR THIS TRANSFER IN F
FPTGRB:	MOV DKNCST,B	;THE CST FOR THE PREVIOUS TRANSFER
	MOV F,D		;COPY FLAGS
	BIC #FPTPAG,D	;CLEAR ALL BUT THE PAGE OFFSET
	CLR A		;FOR THE ASHC
	ASHC #2.,A	;GET THE BUSS ADDRESS IN A AND B
	ADD D,B		;ADD IN THE FPT OFFSET
	ADC A		;IN CASE OF OVERFLOW	
	ASHC #7.,A	;FINISH SHIFTING
	MOV B,DKNBA	;SET IN THE BUSS ADDRESS
	ASH #4,A	;GET THE MEM EX. BITS IN THE RIGHT PLACE
	MOV A,DKNCS	;GET THE CONTROL STATUS
	MOV DSKGIP(C),A	;POINTER TO THE FPT
	MOV F,D		;COPY THE FLAGS
	BIC #FPTOFF,D	;CLEAR ALL BUT THE FPT OFFSET
	ASH #-5,D	;SHIFT IT INTO THE BOTTOM
	ADD A,D		;MAKE D POINT TO THE NEXT BLOCK
	CMP DSKWD(C),#DSKRD	;IS IS A REQUEST FOR READ
	BEQ FPTRD	;YES
	BIT #WRTSR,F	;ARE WE WRITING TO SOURCE
	BNE FPTWR1	;YES
	BIT #FPTBAS,FPTSRC(D)	;IS IT AT SOURCE
	BEQ FPTRD1	;NO, JUST SWAP OUT WHAT WE CAN
	;DROPS AND BRANCHES INTO NEXT PAGE
;DROPPED AND BRANCHED INTO FROM PEVIOUS PAGE.  HERE WE ARE WRITING TO SOURCE
FPTWR1:	MOV FPTSRC(D),B	;THE BLOCK NO.
	BPL FPTWR3	;THE BLOCK IS NOT AT SOURCE
	ADD #FPTSRC,D	;MAKE D POINT TO THE BLOCKS
	MOV #-1,E	;JUST CHECK THE SOURCE BIT
	JSR PC,FNDTOP	;FIND THE FIRST BLOCK THAT ISN'T AT SOURCE.
	MOV DKNFLG,F	;GET THE NEW FLAGS
	BIT #FPTPR,F	;DO WE STILL HAVE AN FPT
	BNE FPTGRB	;YES, START ALL OVER AGAIN
	MOV #DKNFLG,C	;POINTER TO THE FLAGS
	MOV DKNRT,A	;ROUTINE TO RUN
	BNE .+6
	JMP DSKGRB	;NONE
	JSR PC,(A)	;DO THE STUFF
	JMP DSKGRB	;TRY ANOTHER ONE
FPTWR3:	SAVE A
	MOV FPTFLG(A),A	;THE LOGICAL DISK NO.
	BIC #177600,A	;CLEAR EXTRA BITS
	MOV A,DKNRP	;SAVE THE DISK TYPE
	JSR PC,@DATAB(A)	;CACULATE THE DISK ADDRESS
	REST A
	CLR E		;MAKE SURE THE BLOCKS ARE CONTIGUOUS
	JSR PC,FNDTOP	;GET THE LARGEST TRANSFER WE CAN MAKE
	MOV F,E		;COPY COUNT
	ADD #FPTSRC,D	;MAKE D POINT DIRECTLY TO BLOCKS
	MOV #FPTBAS,A	;SET THE BLOCK AT SOURCE BIT
	BIS A,(D)+	;SET IT IN ALL THE BLOCKS
	SOB E,.-2
FPTWC:	ASH #9.,F	;GET THE WORD COUNT
	NEG F		;GET WHAT THE DISK WANTS (-WC)
	MOV F,DKNWC	;STORE IT AWAY
FPTCS:	MOV DSKWD(C),F	;THE FUNCTION
	CMP F,#DSKWCH	;IS IT A WRITE THEN CHECK
	BNE FPTCS1	;NO
	BIS #DSKWRT+101,DKNCS	;SAY IT IS A WRITE AND SET GO AND INTERRUPT
	BIS #WRTCHK,DKNFLG	;SAY THE NEXT TRANSFER IS WRITE CHECK
	RTS PC
FPTCS1:	BIS F,DKNCS	;SET IN THE FUNCTION
	BIS #101,DKNCS	;SET IN THE GO BIT AND INTERRUPT
	RTS PC		
;BRANCHED INTO FROM PREVIOUS PAGE
;HERE WE ARE READING IN.		
FPTRD:	BIT #FPTBAS,FPTSRC(D)	;IS IT AT SOURCE
	BEQ FPTRD1	;NO, USE THE SWAP ADDRESS
	CLR E		;MAKE SURE THE BLOCKS ARE CONTIGUOUS
	JSR PC,FNDTOP	;FIND THE LARGEST CONTIGUOUS AREA START POINTED TO BY A
	MOV FPTSRC(D),B	;GET THE FIRST BLOCK NO.
	BIC #FPTBAS,B	;CLEAR THE BLOCK AT SOURCE BIT
	MOV FPTFLG(A),A	;THE LOGICAL DISK NO.
	BIC #177600,A	;CLEAR THE EXTRA BITS
	MOV A,DKNRP	;SAVE WHAT KIND OF DISK FOR LATER
	JSR PC,@DATAB(A)	;GET THE DA AND DAE
	MOV F,E		;COPY THE COUNT
	BIT #PFPTFL,DKNFLG	;IS IT A PFPT
	BNE FPTWC	;YES, DONT MODIFY ANYTHING
	MOV #FPTBAS,A	;THE BLOCK AT SOURCE BIT
	ADD #FPTSRC,D	;MAKE D POINT DIRECTLY TO THE BLOCKS
	BIC A,(D)+	;CLEAR THE BLOCK AT SOURCE BITS
	SOB E,.-2	;CLEAR THEM ALL
	BR FPTWC	;DONE SO SOON?	
FPTRD1:	MOV #-1,E	;JUST CHECK THE BAS BITS
	JSR PC,FNDTOP	;FIND THE MAXIMUM LENGTH TRANSFER
	MOV D,B		;COPY POINTER TO BLOCK
	SUB A,B		;MAKE D THE BLOCK NO.*2
	ASR B		;GET THE OFFSET
	MOV FPTSWA(A),A	;THE SWAP ADDRESS
	JSR PC,SWPPR	;GET THE DAE,DA,RP
	BR FPTWC	;FINISH IT UP	
;THIS ROUTINE TAKES A SWAP ADDRESS IN A, AND AN OFFSET IN B (THE START OF REFERENCED
;ENTRY IN B.  SETS UP DKNDA,DKNDAE, AND DKNRP.
SWPPR:	BIT #UPTLSB,A	;IS IT A LARGE BLOCK
	BNE LSWPPR	;YES
	MOV #SSPBTP,D	;POINT TO SMALL BIT TABLES
	CLR B		;CLEAR THE OFFSET (CANT BE ONE)
	CLR -(P)	;EACH BIT IS ONE BLOCK
	BR SWPPR1	;FIND THE BIT AND OFFSET
LSWPPR:	MOV #LSPBTP,D	;POINT TO LARGE BIT TABLESP
	SAVE #3		;SAY THAT EACH BIT IS 8 BLOCKS
SWPPR1:	MOV A,E		;COPY IT
	BIC #UPTBTM,E	;CLEAR ALL BUT THE BIT TABLE NO.
	ADD E,D		;MAKE D POINT TO THE BIT TABLE
	MOV (D),E	;POINTER TO THE ACTUAL BIT TABLE
	BUGC NE		;THERE WAS A BIT TABLE
	MOV 4(E),DKNRP	;THIS IS THE LOGICAL DISK NO.
	BIC #UPTBOM,A	;CLEAR ALL BUT THE BIT OFFSET
	ASH #-4,A	;GET IT INTO THE LOW BITS
	ASH (P)+,A	;SHIFT IT THE SIZE OF THE BLOCK (WILL BE 0 OR 3)
	ADD A,B		;ADD THE OFFSET OF THIS TRANSFER
	ADD (E),B	;ADD THE START OF THE SWAP AREA (B CONTAINS DISK ADDRESS)
	MOV 4(E),A	;GET BACK THE DISK NO.
	JMP @DATAB(A)	;CALCULATE THE DAE AND DA
;THIS ROUTINE EXPECTS FPTSRC(D) TO POINT TO THE FIRST BLOCK OF THIS REQUEST
;IT ALSO EXPECTS DKNFLG TO REFLECT THE TRUE STATUS OF THE REQUEST  RETURNS COUNT IN F,
;IF E = 0 CHECK THE SOURCE BLOCK NO., IF E = -1 JUST CHECK TO SEE
;THAT THE BAS BITS ARE THE SAME.
FNDTOP:	SAVE <A,C,D>
	ADD #FPTSRC,D	;POINT TO THE BLOCKS DIRECTLY
	MOV #1,F	;ALWAYS GRAB ONE BLOCK
	MOV DKNFLG,A	;THE NUMBER OF THINGS TO CHECK
	BIC #FPTCNT,A	;CLEAR ALL BUT THE COUNT
	BEQ FNTNX1	;NO MORE THAN ONCE
	MOV (D)+,B	;THE FIRST BLOCK ENTRY
FNTPLP:	TST E		;CHECK THE BLOCK NUMBERS
	BEQ FNTLP1	;YES
	MOV (D)+,C	;GET THE NEXT BLOCK
	XOR B,C		;CHECK THE BAS TO MAKE SURE THE SAME
	BIT #FPTBAS,C	;ARE THEY DIFFERRENT
	BNE FNDIFF	;YES
FNTNXT:	INC F		;SAY ANOTHER BLOCK
	SOB A,FNTPLP	;TRY AGAIN
FNTNX1:	MOV DSK0RQ,A	;POINTER TO THE DISK REQUEST
	MOV (A),DSK0RQ	;LINK IT OUT
	MOV DSKFRE,(A)	;LNK IT ONTO FREE LIST
	MOV A,DSKFRE
	BIC #FPTPR,DKNFLG	;NO MORE FPT
	BR FNDONE	;DONE WITH THIS ONE
FNTLP1:	INC B		;MAKE B WHAT THE NEXT ENTRY SHOULD BE
	CMP (D)+,B	;CHECK TO SEE IF THEY AGREE
	BEQ FNTNXT	;TRY THE NEXT ONE
FNDIFF:	DEC A		;GET THE NUMBER LEFT
	BIC #-FPTCNT-1,DKNFLG	;CLEAR OLD COUNT FIELD
	BIS A,DKNFLG	;SET IN THE NEW COUNT
	MOV F,A		;COPY NUMBER TAKEN
	ASH #3,A	;PUT IT INTO THE FPTPAG FIELD
	ADD A,DKNFLG	;MAKE IT POINT TO THE CORRECT BLOCK NEXT TIME
	ASH #3,A	;FOR THE FPTOFF FIELD
	ADD A,DKNFLG	;FIX IT UP
FNDONE:	REST <D,C,A>	;RESTORE THE REG.
	RTS PC

	
;THIS ROUTINE TAKES GIP IN B, AND TRANSFER TYPE IN A, AND SETS OR CLEARS THE UPT'S
;UPTICR AS APPROPRIATE.  ALSO ASSUMES THAT ITEM2 CAN BE WRITTEN OVER
UPTSET:	SAVE <A,F,B>
	BIC #177771,A	;CLEAR THE EXTRA BITS
	MOV #1,F	;SET FLAG
	CMP #DSKWCH,A	;IS IT A WRITE AND THEN CHECK
	BNE .+4		;NOPE
	CLR F		;CLEAR FLAG
	CMP #DSKWRT,A	;IS IT A WRITE
	BNE .+4
	CLR F		;CLEAR FLAG
UPTLP:	JSR PC,UPTLD	;LOAD THE UPT
	TST UPTCLP(B)	;IS IT IN A CIRCULAR LIST
	TST F		;IS IT A WRITE
	BNE UPTLP1	;NO
	BIC #UPTICR,UPTAR(B)	;CLEAR THE IN CORE BIT
	BR .+10
UPTLP1:	BIS #UPTICR,UPTAR(B)	;SET THE IN CORE BIT
	MOV UPTCLP(B),B	;GET THE NEXT POINTER
	CMP (P),B	;DOES IT POINT TO THE ORIGINAL ONE
	BNE UPTLP	;NOPE TRY THE NEXT ONE
	REST <B,F,A>
	RTS PC
;THESE ARE ROUTINES CALLED BY THE DISK ROUTINES, WHEN A TRANSFER FINISHES

;THIS ROUTINE UPDATES THE CPTMOV BIT, AND WAKES UP PROCESS IF THERE IS ONE
;EXPECTS C TO POINT TO THE CORRECT FLAG WORD
CPTUDT:	MOV <DSKCST-DSKFLG>(C),A	;POINTER TO CPT OF THIS PAGE
	MOV CST(A),A	;THE CST ENTRY
	BIC #CSTCOM,A	;CLEAR ALL BUT THE CPT OFFSET
	BIC #CPTMOV,CPT+CPTADR(A)	;CLEAR THE PAGE MOVING BIT
;FALL INTO WAKE UP ROUTIN

RUNPAG:	MOV <DSKITM-DSKFLG>(C),A	;GET THE PROCESS
	BEQ RUNPG1	;NONE
	JSR PC,ITM0PL	;LOAD IT UP
	SAVE <C,B>
	MOV PRSID1(A),B
	MOV PRSID2(A),C
	MOV ITEM0,A
	JSR PC,PRSWAK
	REST <B,C>
	JSR PC,ITM0PO	;POP THE PROCESS
RUNPG1:	RTS PC

;THIS IS THE SYSTEM CALL THAT SETS UP THE SWAPPING BIT TABLES.  BASICALLY, THE SYSTEM
;SHPERE GETS CAPABILITIES TO ALL THE ROOT DIRECTORIES OF ALL THE DISKS.  IT THEN COPIES
;THEM AND TURNS THE COPIES INTO FILE CAPABILITIES TO THE DESCRIPTOR FILES OF THE DISKS
;IT THEN DOES BLKIN'S AND READS THE FIRST 5 WORDS OF THE DESCRIPTOR FILE, OF ALL THE 
;FILES. IT THEN CALLS THIS ROUTINE WITH THE DISK NO, THEN THE STARTING ADDRESS, AND
;THEN THE NUMBER OF BLOCKS
EALLOC:	CMP CURSPH,SYSSPR	;IS THIS THE SYSTEM SPHERE
	BEQ .+6
	JMP ERETSZ	;ONLY THE SYSPR CAN DO THIS
	JSR PC,RETNSW	;GET THE NUMBER OF BLOCKS
	MOV A,F		;THE NUMBER OF BLOCKS IN THIS SWAP SPACE
	JSR PC,RETNSW	;THE STARTING ADDRESS
	MOV A,E		;SAVE IT
	JSR PC,RETNSW	;GET THE DISK NO.
	SAVE <A,E,F>	;FOR BTABLE
	MOV #SSPBTP+2,A	;POINTER TO WHERE THE FIRST SMALL BIT TABLE POINTER
	MOV #LSPBTP+2,B	;POINTER TO WHERE THE FIRST LARGE BITTABLE POINTER
	TST (A)+	;ANY ONE HOME
	BNE .-2		;YES, TRY THE NEXT SPOT
	TST -(A)	;BACK UP TO THE FREE SLOT
	TST (B)+	;THE SAME FOR THE LARGE SPACES
	BNE .-2
	TST -(B)	;BACK UP LIKE I SAID
	MOV #BITTAB,C	;THE START OF THE ACTUAL STORAGE FOR THE TABLES
ALOC2:	TST (C)		;IS THIS SPACE USED
	BEQ ALOC1
	MOV 2(C),D	;THE LENGTH IN BITS
	ADD #17,D	;MAKE IT ROUND UP
	ASH #-4,D	;NUMBER OF WORDS IN THIS TABLE
	ADD D,C		;POINT TO THE NEXT ONE
	ADD D,C		;BECAUSE D IS NUMBER OF WORDS, AND C IS BYTE POINTER
	BR ALOC2	;TRY AGAIN
ALOC1:	JSR PC,BTABLE	;ALLOCATE A BIT TABLE
	ADD #6,P	;POP THE PREVIOUS INFO
ALOCRT:	JMP ERETCZ	;SUCCEED


;.RDMAP => READ THE MAP OF A SPHERE INTO THE USERS CORE.
;FIRST ARGUMENT IS THE SPHERE CAPABILITY OF THE MAP TO READ
;SECOND ARGUMENT IS A POINTER INTO THE USERS CORE, WHERE TO PUT
;MAP INFO.  IT RETURNS 16 WORDS IN THE FOLLOWING FORMAT.
;BOTTOM 3 BITS ARE THE LENGTH OF THE PAGE., THE TOP BIT IS D=I, NEXT IS ABS
;NEXT IS FILE PAGE BIT.
ERDMAP:	JSR PC,RETNSW		;GET THE SPHERE CAPABILITY
	MOV A,B			;COPY IT
	BIC #177400,B		;CLEAR THE EXTRA BITS
	MOV ITM1A,A		;THE CURRENT SPHERE
	JSR PC,GCLSTA		;FIND THE CPABILITY
	BEQ RDMAP1		;FAILED
	ADD A,B			;POINT TO THE CAPABILITY DIRECTLY
	CMPB (B),#.MSCAP	;IS IT A MS CAPABILITY
	BEQ RDMAP2		;YES, EVERYTHING IS OKAY
	CMPB (B),#.SPCAP	;IS IT A SPHERE CAPABILITY
	BEQ RDMAP2		;YES, IT IS OKAY SO FAR
RDMAP1:	JMP ERETSZ		;FAILED
RDMAP2:	BIT #.SPCRR!.SPCRW,(B)	;DOES HE HAVE ACCESS
	BEQ RDMAP1		;NO
	MOV 2(B),A		;THE SPHERE TO READ THE MAP FROM
	JSR PC,ITM2LD		;LOAD IT UP
	JSR PC,RETNSW		;GET THE POINTER INTO HIS CORE
	MOV #20,B		;THE NUMBER OF WORDS WE ARE RETURNING
	MOV A,C			;COPY IT
RDMAP3:	MFPD (A)		;MAKE SURE ALL THE WORDS ARE WRITABLE
	MTPD (A)+
	SOB B,RDMAP3
	MOV ITM2A,A		;POINTER TO THE UPTS
	MOV #20,B		;NUMBER OF THEM
	ADD #SUPTS,A		;POINT TO THE UPT'S DIRECTLY
RDMAP4:	MOV (A),D		;THE REFERENCED ENTRY
	MOV D,E			;COPY IT
	ASH #-12.,D		;SHIFT IT WAY DOWN
	BIC #.PLENM,D		;CLEAR ALL BUT THE LENGTH FIELD
	BIC #177760,E		;CLEAR ALL BUT THE ACCESS INFO
	SWAB E			;PUT IT INTO THE TOP BYTE
	BIS E,D			;SET IT IN
	BIT #UPTDEI,(A)		;IS IT D=I
	BEQ RDMAP5			;NO
	BIS #.PDEI,D		;SET THE D=I BIT
	BR RDMAP5		;DONE WITH THIS PAGE
	TST UPTCLP(A)		;IS IT A FPT PAGE?
	BEQ RDMAP5		;NO
	BIS #.PFIL,D		;SET IN THE FILE BIT
RDMAP5:	SAVE D			;THE INFO WORD
	MTPD (C)+		;RETURN IT TO HIM	
	ADD #UPTLEN,A		;POINT TO THE NEXT ONE
	SOB B,RDMAP4		;DO ALL THE PAGES
	JMP ERETCZ		;DONE
;.MAP
;CREATE A PAGE FOR A SPHERE,
;THE FIRST BYTE IS THE SPHERE CAPABILITY TO THE DESTINATION SPHERE
;THE SECOND IS THE ACCESS INFO (READ, WRITE, AND PRIVATE OR PUBLIC COPY)
;THE THIRD IS THE SOURCE OF THE PAGE
;(FILE ACCESS CAP. OR SPHERE CAP, -1 FOR FRESH PAGE, -2 FOR ABSOLUTE PAGE,
;OR -3 FOR JUST DELETE THIS PAGE)
;THE FOURTH IS THE UPT NO. OF THE PAGE TO CREATE
;(0-7 UPT NO. IS I SPACE, 10-17 IS D-SPACE, 20-27 IS I=D SPACE)
;THE FIFTH AND SIXTH ARE THE PAGE NO. IN SOURCE (IF FILE)
;THE SEVENTH IS THE START OF THE PAGE (IN 512. WORD BLOCKS)
;THE EIGHTH IS THE LENGTH-1"  "    "    "  "   "      " 
;IF IT IS A REQUEST FOR A PUBLIC PAGE, AND IT IS PART OF A FILE AND HE
;IS ASKING FOR WRITE ACCESS, CLEAR THE BYTE AND WORD LEFT FLAGS IN MFI
;IF IT IS ANOTHER SPHERE, AND IT IS A REQUEST FOR A PUBLIC PAGE, AND HE
;IS ASKING FOR WRITE ACCESS, EXPAND THE PAGE, AND LINK THE UPT'S TOGETHER
EMAP:	SUB #10,P	;MAKE 4 STORAGE CELLS
	MOV P,D		;GET POINTER TO THE STORAGE
	MOV #4,B	;THE NUMBER OF ARGS
EMAP1:	JSR PC,RETNSW	;GET THE SPHERE CAP AND FLAGS
	MOV A,(D)+	;SAVE IT
	SOB B,EMAP1
	MOV (P),B	;THE SPHERE CAP
	BIC #177400,B	;CLEAR THE EXTRA BITS
	MOV ITM1A,A	;THE ADDRESS OF THE ITEM
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ EMAP2	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE SPHERE CAP
	MOV (A),B	;GET THE TYPE AND FLAGS
	CMPB B,#.SPCAP	;IS IT A SPHERE CAPABILITY
	BEQ EMAP3	;YES
	CMPB B,#.MSCAP	;IS IT A MASTER SPHERE CAPABILITY
	BEQ EMAP3	;YES
EMAP2:	ADD #10,P	;POP OFF THE ARGUMENTS
	JMP ERETSZ	;TELL HIM HE FAILS
EMAP3:	BIT #.SPCRW,B	;DOES HE HAVE CORE WRITE CAPABILITY
	BEQ EMAP2	;NOPE
	MOVB 3(P),B	;THE UPT NO.
	BLT EMAP2	;NEGATIVE
	CMP B,#30	;IS IT A LEGAL PAGE
	BGE EMAP2	;NO
	CMP B,#20	;IS IT I=D
	BLT .+6		;NO
	SUB #10,B	;MAKE IT POINT TO THE D PAGE
	ASH #10.,B	;SET IT INTO CORRECT PLACE
	MOV 2(A),F	;THE SPHERE AFFECTED
	BIS B,F		;MAKE A GIP
	BIS #GIPSPR!GIPBIT,F
	MOV F,B		;GIP TO THE UPT TO DELETE
	CMPB 2(P),#-4	;IS IT A PAGE EXPAND REQUEST?
	LBR EQ,PAGEXP	;YES
	BITB #20,3(P)	;IS IT I=D
	BEQ EMAP4	;NO JUST DELETE CURRENT PAGE
	JSR PC,UPTDL	;DELETE IT
	SUB #<10_10.>,F	;MAKE IT POINT TO THE I UPT
	MOV F,B		;COPY IT AGAIN

EMAP4:	JSR PC,UPTDL	;DELETE THE UPT
	MOVB 2(P),B	;THE SOURCE
	CMP B,#-3	;IS IT REQUEST FOR JUST FLUSHING PAGE
	BNE .+6		;NO
	JMP EMAPRT	;JUST RETURN
	MOV (P),A	;THE ACCESS
	BIC #377,A	;CLEAR THE LOW BYTE
	CLR E		;IN CASE THERE IS NO ACCESS
	BIT #.CRRD,A	;ASKING FOR READ ACCESS
	BEQ .+6		;NO,
	MOV #2,E	;SAY READ ONLY ACCESS
	BIT #.CRWRT,A	;ASKING FOR WRITE ACCESS
	BEQ .+6		;NO
	MOV #6,E	;SAY WRITE ACCESS
	BIT #.CREX,A	;ASKING FOR EXECUTE ONLY ACCESS
	BEQ EMAP5	;NO
	CMPB 3(P),#10	;BETTER BE AN I SPACE PAGE
	BGE EMAP2	;NO, BETTER LOSE
EMAP5:	TSTB B
	BGE EMAP6	;ITS A CAPABILITY
	MOVB 6(P),D	;THE START
	BLT BADMAP	;NO NEGATIVE START
	MOVB 7(P),C	;THE LENGTH OF THE BLOCK TO CREATE
	BLT BADMAP	;NO NEGATIVE LENGTHS
	ADD C,D		;GET THE SUM OF THE LENGTH AND START
	BVS BADMAP	;OVER FLOW
	CMP D,#10	;IS THE SUM OF THE START AND LENGTH OVER 10
	BGE BADMAP	;YES, LOSE LOSE
	CMP B,#-1	;IS IT A REQUEST FOR A FRESH PAGE
	LBR EQ,MAPFRS	;YES
	CMP B,#-2	;IS IT REQUEST FOR ABSOLUTE PAGE
	BEQ MAPABS	;GET AN ABSOLUTE PAGE
BADMAP:	ADD #10,P
	JMP BADEMT	;TSK TSK, BAD FUNCTION
EMAP6:	MOV ITM1A,A	;GET THE ADDRESS
	JSR PC,GCLSTA	;GET THE OFFSET OF THE CAPABILITY
	BEQ BADMAP	;COULDN'T GET IT
	ADD B,A		;MAKE A POINT DIRECTLY TO IT
	MOV (A),B	;THE FLAGS WORD OF THE CAPABILITY
	BEQ BADMAP	;NO CAPABILITY
	CMPB B,#.FACAP	;IS IT A FILE ACCESS CAPABILITY
	BEQ MAPFIL	;YES
	CMPB B,#.DSCAP	;IS IT A DISPLAY CAPABILITY
	LBR EQ,MAPDS	;YES
	CMPB B,#.SPCAP	;IS IT A SPHERE
	BEQ MAPSPR	;YES
	CMPB B,#.MSCAP	;IS IT A MASTER SPHERE
	LBR NE,BADMAP	;NO, BAD LUCK
	;FALLS INTO NEXT PAGE
	;DROPS IN
MAPSPR:	MOVB 1(P),D	;GET THE ACCESS BYTE 
	SWAB D		;GET IT INTO TOP BYTE
	XOR D,B		;GET THE XOR OF ACCESS INTO B
	BIT D,B		;ANY DIFERRENT
	LBR NE,BADMAP	;YES, LOSER
	BIT #.CRPRI,D	;DOES HE WANT PRIVATE
	BNE MPSPRI	;YES
	CMP 4(P),#17	;IS HE ASKING FOR A LEGAL PAGE?
	BHI BADMAP	;NO	
	MOV 2(A),A	;GET THE SPHERE
	JSR PC,ITM1PL	;LOAD IT UP
	ADD #SUPTS,A	;POINT TO THE FIRST UPTS
	MOV 4(P),D	;THE PAGE NO.
	MUL #UPTLEN,D	;GET THE LENGTH OF THE OFFSET
	ADD D,A		;POINT TO THE UPT IN SPHERE
	BIT #UPTDEI,(A)	;IS IT A DATA=INSTRUCTION PAGE
	BEQ MAPSP2	;NO
	CMP A,#ITM1AD+SUPTS+<UPTLEN*10>	;IS IT POINTING TO A DATA?
	BLO MAPSP2	;NOPE, JUST COPY IT
	SUB #<UPTLEN*10>,A	;POINT TO THE I SPACE PAGE
MAPSP2:	MOV F,B		;POINTER TO PAGE TO CREATE
	JSR PC,UPTPLD	;LOAD IT UP
	MOV #UPTLEN/2,C	;THE LENGTH IN WORDS
	MOV B,D		;COPY POINTER TO UPT
	MOV (A)+,(D)+	;COPY UPT
	SOB C,.-2
	BIC #UPTDEI,-UPTLEN(D)	;DONT WANT THE NEW PAGE D=I UNLESS HE ASKS
	MOV -UPTLEN+UPTCLP(A),-UPTLEN+UPTCLP(D)
	MOV F,-UPTLEN+UPTCLP(A)	;MAKE COPIED POINT TO THE COPY
	JSR PC,ITM1PO	;POP THE SPHERE WE COPIED
	MOV UPTFPT(B),A	;GET THE SWAP ADDRESS
	BPL MAPSP1	;IT IS OKAY AS IS
	ASL A		;INTO A FPT POINTER
	MOV FPTMFI(A),A	;POINT TO THE MFI
	JSR PC,ITM1PL	;LOAD IT UP
	INC MFREF(A)	;INCREMENT THE REF COUNTS
	JSR PC,ITM1PO	;POP IT OFF
MAPSP1:	JMP MAPFR2	;TAKE CARE OF I=D, ETC.	
MPSPRI:	BPT
MAPABS:	CMP #6,E	;WRITE ACCESS?
	BEQ BADMAP	;NO WAY
	TSTB C		;GOOD LENGTH?
	BLT BADMAP	;NEGATIVE LENGTH
	CMP C,#7
	BGE BADMAP	;BAD LENGTH
	SWAB C		;GET IT INTO THE RIGHT BITS
	ASH #4,C
	BIS E,C		;SET IN ACCESS
	MOV #UPTABT,A	;WHERE TO BUILD THE AR
	MOV 4(P),B	;THE START IN 512. WORDS BLOCKS
	BLT BADMAP	;NEGATIVE
	ASH #4,B	;PUT IT INTO THE CORRECT BITS
	BVS BADMAP	;TO LARGE
	BIT #UPASMS,B	;IS IT TO LARGE
	LBR NE,BADMAP	;YES
	BIS B,A		;SET IT IN
	MOV F,B
	JSR PC,UPTPLD	;LOAD THE UPT
	MOV C,(B)+	;SET IN UPTDR
	MOV A,(B)+	;SET IN UPTAR
	JMP MAPFR2	;CHECK FOR I=D, ETC.
	

;HERE SET UP THE DISPLAY'S PAGES AS ABSOLUTE PAGES
MAPDS:	MOV 2(A),C	;THE ITEM OF THE DISPLAY
	MOV F,B		;THE PLACE TO PUT IT
	JSR PC,UPTPLD	;LOAD IT UP
	MOV B,D		;COPY POINTER TO UPT
	MOV ITMTAB+ITACCS(C),(D)	;SET IN THE DR
	BIC #17,(D)	;CLEAR THE ACCESS
	BIS E,(D)+	;SET IN REQUESTED ACESS
	MOV ITMTAB(C),(D)	;SET IN THE AR
	BIS #UPTABT,(D)	;SET THE ABSOLUTE PAGE BIT
	JMP MAPFR2	;TAKE CARE OF D=I ETC.
;A POINTS TO THE FA CAP.
;F IS GIP TO THE UPT TO CREATE
;E HAS ACCESS REQUESTED
;ASSUMES THE POSITION OF THE READ WRITE ACCESS BITS IS SAME IN SPHERE AND FA CAP
MAPFIL:	SAVE <E,F>
	MOVB 13(P),E		;THE LENGTH
	BGE MAPFL4		;ORDINARY LENGTH
	CMP E,#-1		;IS IT A REQUEST FOR ALL THE BLOCKS ON THE PAGE
	BEQ MAPFL4		;YES, IT IS OKAY
	ADD #4+10,P		;POP OFF THE ARGUMENTS AND PUSHED E AND F
	JMP ERETSZ		;LOSE
MAPFL4:	MOVB 12(P),C		;THE START
	SWAB C
	ASL C
	ASL C			;MAKE IT INTO A BYTE COUNT
	SAVE C			;FAKE A CAP
	CLRB (P)		;CLEAR LOW BITS
	CLR -(P)		;NO FUPT YET
	MOVB 14(P),-(P)		;GET THE PAGE NUMBER
	CLRB 1(P)		;CLEAR THE TOP BYTE
	SAVE <FAMFI(A),(A)>	;COPY REST OF CAPABILITY
	MOV P,D			;POINTER TO CAPABILITY
	BIT #.CRPRI,16(P)	;IS THIS REQEST FOR PRIVATE PAGE
	BEQ MAPPUB		;NO JUST MAKE IT A PUBLIC PAGE
	MOV FAMFI(A),A
	JSR PC,ITM2LD		;LOAD MFI
	JSR PC,MFMFPT		;MAKE SURE THERE IS AN FPT FOR THAT PAGE
	LBR EQ,MAPFL1		;FAILED
	ADD #12,P		;POP OFF FAKE CAPABILITY
	MOVB 13(P),B		;THE LENGTH
	JSR PC,SWPAL		;ALLOCATE SWAP SPACE
	LBR EQ,MAPNSS		;NO SWAP SPACE
	MOV #LPCLRT,A		;RUN A ROUTINE IF PCLOSERED
	MOV B,C			;SAVE THE SWAP SPACE
	CLR B			;NO ITEM
	JSR PC,LOCKSW		;GET A SWITCH
	MOV #MFPCL4,LCKWD1(A)	;RUN A ROUTINE TO DEALLOCATE SWAP SPACE IF PCLOSERED
	MOV C,LCKWD2(A)		;THE SWAP ADDRESS
MAPPR1:	MOV PFPTFR,A		;GET A PFPT
	BNE MAPPR2		;GOT ONE
	MOV #PFPTFR,A		;POINTER TO FREE LST
	JSR PC,MFLUSH		;WAIT FOR ONE TO APPEAR
	BR MAPPR1
MAPPR2:	MOV (A),PFPTFR		;LINK IT OUT
	MOV C,PFPSWA(A)		;SET IN THE SWAP ADDRESS
	SEC			;TO SET THE TOP BIT
	ROR E			;MAKE IT INTO A FPT POINTER
	MOV E,PFPPTR(A)		;SET IN THE FPT POINTER
	ASL E			;GET IT BACK INTO A ABSOLUTE ADDRESS
	INC FPTREF(E)		;ONE MORE PFPT
	SEC
	ROR A			;CHANGE PFPT POINTER TO LOOK LIKE FPT POINTER
	MOV A,D			;SAVE IT
	MOV FPTMFI(E),A		;THE MFI
	JSR PC,ITM2LD		;LOAD IT UP
	INC MFREF(A)		;INCREMENT THE REFERENCE COUNT
	MOVB 13(P),C		;THE LENGTH
	BGE MAPPR3		;SPECIAL PROCESSING IF NEGATIVE
	ADD #FPTSRC+20,E
	MOV #7,C		;COUNT OF BLOCKS EXISTING ON FIRST PAGE
	TST -(E)		;NOW BACK UP LOOKING FOR EXISTING BLOCK
	BNE .+4
	SOB C,.-4		;KEEP BACKING UP
MAPPR3:	REST <F,E>		;THE ACCESS AND POINTER TO WHO IT BELONGS
	SAVE D			;MAPSSP EXPECTS THE SWAP ADDRESS ON THE STACK
	JMP MAPSS1		;SET UP THE UPT, WITH THE PFPT POINTER AS SWAP ADDRESS

MAPPUB:	CLR F			;DONT WANT IT SWAPPED IN PARTICULARLY
	JSR PC,DKURIO		;GET THE CREATE A FUPT FOR IT
				;(CREATES IT WITH THE MAXIMUM ACCESS)
	BEQ MAPFL1		;ANY DISK ROUTINE ERRORS?
	MOV FAMFI(D),A		;POINTER TO MFI
	JSR PC,ITM2PL		;LOAD IT UP
	INC MFREF(A)		;INCREMENT MFI'S REFERENCE COUNT
	MOV FAUPT(D),B		;THE FUPT POINTER
	ADD #10,P		;POP OFF THE CAPABILITY
	MOV B,(P)		;FANCY SAVE OF B
	JSR PC,UPTLD		;LOAD IT UP, BETTER BE A FUPT
	MOV B,D			;COPY POINTER TO FUPT
	MOV 2(P),B		;POINTER TO THE UPT TO CREATE
	JSR PC,UPTLD		;MAKE B POINT TO IT
	SAVE B			;SAVE POINTER TO IT
	MOV #UPTLEN/2,C		;NUMBER OF WORDS IN UPT
	MOV (D)+,(B)+		;COPY THE UPT
	SOB C,.-2
	MOV 2(P),B		;POINTER TO THE FUPT
	JSR PC,UNLNK		;UNLINK THE UPT
	MOV 2(P),D		;THE FUPT POINTER
	ADD #<100000+FUPTTB>,D	;MAKE IT ABSOLUTE

	MOV FUPTFR,(D)		;LINK IT ONTO FREE LIST
	MOV D,FUPTFR
	REST (P)		;CRUNCH FUPT POINTER
	TST C			;ARE THERE ANY LEFT
	BNE MAPFL2		;YES, JUST LINK THIS ONE IN
	REST B			;GET BACK POINTER TO THE UPT
	MOV (P),UPTCLP(B)	;MAKE IT POINT TO ITSELF
	BR MAPFL3		;DONE FIXING IT UP
MAPFL2:	MOV C,B			;A UPT IN THE CIRCULAR LIST
	JSR PC,UPTPLD		;LOAD IT UP
	MOV UPTCLP(B),D		;GET THE THING IT POINT TO
	MOV 2(P),UPTCLP(B)		;MAKE IT POINT TO THE NEW UPT
	JSR PC,ITM2PO		;POP THE ITEM
	REST B			;POINTER TO THE UPT CREATED
	MOV D,UPTCLP(B)		;CIRCULAR LIST ALL SET UP
MAPFL3:	MOV UPTFPT(B),E		;THE FPT POINTER
	ASL E			;MAKE IT ABSOLUTE
	MOV (P),FPTUPT(E)	;SET IN THE NEW UPT POINTER
	REST <F,E>
	BR MAPFR2		;TAKE CARE OF IT IF IT IS D=I
MAPFL1:	ADD #12+10+4,P	;POP OFF CAPABILITY,E,F, AND ARGUMENTS
	JMP ERETSZ	;LOSER
MAPNSS:	ADD #10,P	;POP OFF ARGS
	MOV #.FANSS,ITM0AD+PERRW	;NO SWAP SPACE
	JMP ERETSZ	;FAILED

MAPFRS:	CLR B
	TST C
	BEQ .+4		;MAKE A SMALL SWAP SPACE
	INC B		;GET A LARGE ONE
	JSR PC,SWPAL	;ALLOCATE SOME SWAP SPACE
	BEQ MAPNSS	;FAILED
	SAVE B		;SAVE THE SWAP ADDRESS
MAPSS1:	MOV F,B		;GIP TO THE UPT TO CREATE
	JSR PC,UPTPLD	;LOAD IT UP
	REST UPTFPT(B)	;SET IN THE SWAP ADDRESS
	MOV F,UPTCLP(B)	;SET IN THE CIRCULAR LIST POINTER
	;FALLS INTO NEXT PAGE
	;FALLS IN FROM PREVIOUS PAGE
	MOVB 6(P),D	;GET THE START
	SWAB D		;GET IT INTO THE CORRECT BYTE
	SWAB C		;SET THE REFERENCED AREA
	ASH #4,C	;GET THE LENGTH INTO THE CORRECT BITS
	MOV D,UPTDR(B)	;SET IN THE DR THE START FIELD
	BIS C,UPTDR(B)	;SET IN THE LENGTH FIELD
	SWAB D		;GET IT BACK INTO THE LOW BYTE
	BIS D,C		;MAKE UP THE AR
	MOV C,UPTAR(B)	;SET IT INTO THE UPT
MAPFR2:	BIC #7,UPTDR(B)	;CLEAR OUT THE ACCESS FIELD
	BIS E,UPTDR(B)	;SET IN THE ACCESS CODES
	MOVB 3(P),C	;GET THE PAGE NO. AGAIN
	CMP C,#20	;IS IT A D=I PAGE
	BLT MAPFR1	;NOPE
	BIS #UPTDEI,(B)	;SET THE I=D BIT
	MOV #UPTLEN/2,C	;THE LENGTH OF THE UPT
	MOV (B)+,<UPTLEN*10>-2(B)	;COPY THE UPT ENTRY
	SOB C,.-4	;COPY ALL THE WORDS
MAPFR1:	JSR PC,ITM2PO	;POP THE SPHERE
EMAPRT:	ADD #10,P	;POP OFF THE ARGUMENTS
	BIC #GIPITM,F	;CLEAR ALL BUT THE SPHERE NO.
	CMP F,CURSPH	;DID WE CHANGE THIS SPHERE'S PAGES?
	BNE MAPFR3	;NO DON'T WORRY ABOUT IT
EMAPR1:	JSR PC,SAVAWB	;SAVE CURRENT A&W BITS
	JSR PC,MAPRE1	;MAKE SURE HIS MAP GETS MODIFIED IMMEDIATELY
MAPFR3:	JMP ERETCZ	;SUCESS

PAGEXP:	CMPB #20,3(P)	;I=D
	BGT PAGEX1	;NO
	SUB #<10_10.>,F	;TURN IT TO POINT TO I PAGE
	MOV F,B		;GET THE GIP
	JSR PC,UPTLD	;LOAD IT UP
	BIT #UPTDEI,(B)	;IS IT D=I PAGE
	BNE PAGEX2	;YES, EVERYTHING IS FINE
EXPFAL:	JMP BADEMT	;FAIL MISERABLY
PAGEX1:	MOV F,B		;THE GIP TO THE PAGE
	JSR PC,UPTLD	;LOAD IT
	BIT #UPTDEI,(B)	;IS IT D=I
	BNE EXPFAL	;YES THIS FAILES
PAGEX2:	TST UPTFPT(B)	;IS IT SWAP PAGE
	BMI EXPFAL	;THIS SHOULD BE CHANGED LATER TO EXPAND FILE PAGES
	MOVB 6(P),C	;THE START
	BLT EXPFAL	;NEGATIVE (BLETCH)
	MOVB 7(P),D	;GET THE LENGTH
	BLT EXPFAL	;NEGATIVE?
	ADD C,D		;GET COMBINED START AND LENGTH
	CMP D,#10	;IS IT TO LARGE
	BGE EXPFAL	;FAILED
	SAVE D		;SAVE TOTAL END
	MOV UPTAR(B),C	;GET THE MASTER LENGTH AND START
	MOV C,D		;COPY IT
	BIC #UPMSSW,C	;CLEAR EXTRA BITS
	BIC #UPMLSW,D	;DITTO FOR LENGTH
	SWAB D		;INTO THE RIGHT BITS
	ASH #-4,D
	ADD C,D		;GET THE TOTAL END
	CMP D,(P)+	;IS MASTER END LESS THAN THE NEW END?
	BLT PAGEX5	;YES, NEED NEW SWAP SPACE
	CMPB C,6(P)	;IS MASTER START < NEW START
	BLE PAGEX3	;YES, NO NEED TO CHANGE SWAP AREA
	BIT #UPTLSB,UPTFPT(B)	;IS IT ALREADY LARGE SWAP AREA?
	BNE PAGEX3	;YES, CURRENT SWAP AREA IS LARGE ENOUGH
PAGEX5:	SAVE UPTFPT(B)	;THE SWAP SPACE TO FREE
	JSR PC,SWPAL	;ALLOCATE SWAP SPACE
	MOV #LPCLRT,A	;RUN ROUTINE TO FREE SWAP SPACE IF PCLOSERED
	SAVE B		;THE SWAP SPACE POINTER
	CLR B		;NO ITEM
	JSR PC,LOCKSW	;LOCK A SWITCH
	MOV #MFPCL4,LCKWD1(A)	;FREE THE SWAP SPACE
	MOV (P),LCKWD2(A)	;THE SWAP SPACE TO FREE
	MOV F,B		;GET POINTER TO PAGE
	JSR PC,SWPIN	;SWAP IT IN
	;DROPS INTO NEXT PAGE
	;FALLS IN FROM PREVIOUS PAGE
PAGEX4:	JSR PC,UPTLD	;LOAD THE UPT
	MOV (P),UPTFPT(B)	;UPDATE SWAP POINTER
	MOV UPTCLP(B),B	;THE NEXT UPT
	CMP B,F		;IS IT THE FIRST UPT?
	BNE PAGEX4	;NO TRY NEXT ONE
	TST (P)+	;POP OFF THE SWAP ADDRESS
	JSR PC,UPTLD	;LOAD IT UP
	BIS #UPTWON,(B)	;SAY THAT IS WAS WRITTEN ON (NEW SWAP SPACE, SO SHOULD BE SWAPPED OUT)
	REST B		;GET BACK THE OLD SWAP SPACE
	JSR PC,DSWPAL	;FREE OLD SWAP SPACE
;HERE WE HAVE THE CORRECT SWAP SPACE (WHATEVER THAT IS)
PAGEX3:	MOV F,B		;THE GIP
	JSR PC,SWPOT	;SWAP IT OUT (SO THAT NEW LENGTH FITS INTO CORE
	JSR PC,UPTLD	;LOAD IT UP
	MOVB 6(P),A	;THE START
	MOVB 7(P),C	;THE LENGTH
	ASH #4,C	;INTO THE CORRECT BITS
	BIS A,C		;SET IN THE START
	SWAB C		;THE NEW START AND LENGTH FOR THIS UPT
	BIC #73400,(B)	;CLEAR THE OLD START AND LENGTH
	BIS C,(B)	;SET IN THE NEW
	MOV F,C		;THE GIP TO UPT JUST CHANGED
	JSR PC,SWPCAL	;CALCULATE NEW MASTER LENGTH AND START
	CMPB #20,3(P)	;IS IT I=D
	BGT PAGEX6	;NO
	MOV C,B		;GET POINTER TO PAGE
	JSR PC,UPTLD	;LOAD IT UP
	MOV UPTLEN*10(B),C	;GET THE D SPACE BITS
	BIC #-1-360,C	;CLEAR ALL BUT THEM
	BIS C,(B)	;NO SET THEM INTO I PAGE
	MOV #UPTLEN/2,C	;GET THE LENGTH OF UT
	MOV (B)+,<UPTLEN*10>-2(B)	;COPY IT UP
	SOB C,.-4	;ALL THE WORDS
PAGEX6:	ADD #10,P	;POP OFF JUNK
	JMP EMAPR1	;SUCESS

	.STITL FILE ACCESS CAPABILITY ROUTINES
CAPRFA:	MOV #.FALB,B			;LOCK SWITCH
	MOV ITEM1,C
	MOV A,D				;FA CAP PTR.
	SUB ITM1A,A
	JSR PC,LCKASW
	REST <B,E,F>
	SWAB B
	BIC #177401,B
	CMP B,#FAGTFN
	LBR GT,CAPRC2
	JMP @FATAB(B)

MFARE:	MOV FAMFI(D),A			;RETURN EOF POINTER
	JSR PC,ITM2LD
	MOV MFPGNO(A),E
	CLR F
	ASHC #-3,E
	ADD MFBYTP(A),F
	MOV F,B
	JSR PC,GIVPSW
	MOV E,B
	JSR PC,GIVPSW
	BR MFARTN

MFACF:	BIC #<-.FARD-.FAWT-.FAAP-.FAAC>-1,E	;CLEAR ACESS FLAGS
	BIC E,(D)
	BR MFARTN

MFASP:	MOV F,FAFBP(D)			;SET FILE POINTER
	BIC #160000,FAFBP(D)
	ASHC #3,E
	MOV E,FAFPN(D)
	BR MFARTN

MFARP:	MOV FAFPN(D),A			;RETURN POINTER
	CLR B
	ASHC #-3,A
	ADD FAFBP(D),B
	JSR PC,GIVPSW
	MOV A,B
	JSR PC,GIVPSW
MFARTN:	JMP ERETCZ

;DELETE AN ENTRY FROM A DIRECTORY
;(D)= CAPABILITY TO DIRECTORY
;(E)= POINTER TO NAME OF ENTRY TO DELETE

MFIFNF:	MOV #.FAFNF,ITM0AD+PERRW
	BR MFADL1
MFADL6:	JSR PC,MFDELP			;CLEAN UP THE DEFUNCT MFI
MFAD20:	TST (P)+
MFIRAN:	MOV #.FARAN,ITM0AD+PERRW
	BR MFADL1
MFIWTE:	MOV #.FAWTE,ITM0AD+PERRW
MFADL1:	JMP ERETSZ
MFADL2:	MOV A,(P)			;FOUND IT IN HASH TABLE
	MOV C,A
	JSR PC,ITM2LD
	BIT #MFDIRB,MFLAGW(A)
	BEQ MFAD21			;YOU CAN ALWAYS DELETE A FILE
	BIT #MFDMTB,MFLAGW(A)
	BEQ MFIRAN			;DIRECTORY WASN'T EMPTY
MFAD21:	BIS #MFDWDB,MFLAGW(A)
	BR MFADL5			;DELETE ENTRY

MFADL:	MOV FAMFI(D),A			;ENTERS HERE
	JSR PC,ITM2LD
	BIT #MFDIRB,MFLAGW(A)
	BEQ MFIWTE			;CAN'T DELETE FROM A FILE
	JSR PC,DIRENT
	BEQ MFADL1			;BAD NAME
	SAVE B				;THE HASH CODE
	MOV ITM2A,A
	CMP #-3,MFVERN(A)		;SHOULD WE INSERT THE DEFAULT VERSION NUMBER
	BNE .+10
	MOV #-1,MFVERN(A)		;DEFAULT IS <
	MOV ITEM2,A
	JSR PC,DKDRIO
	BEQ MFAD20			;COULDN'T READ DIRECTORY
	JSR PC,LSWPOP
	MOV FAUPT(D),B
	JSR PC,MFSWAL			;LOCK IT IN CORE
	JSR PC,ITM2LD
	MOV #ITM2AD+MFENHD,B
	REST E				;GET BACK THE HASH CODE
	BR MFAD22				;SKIP THE RESTORE OF POINTER
MFADL3:	REST 2(B)			;FIX UP THE VERSION NUMBER AGAIN
MFAD22:	JSR PC,DRLOOK			;FIND THE ENTRY
	BUGC NE,MFIRAN			;SHOULD BE LOCKED IN CORE
	BMI MFIFNF			;FILE NOT FOUND
	SAVE A				;SAVE POINTER INTO THE DIRECTORY
	MOV FAUPT(D),A			;POINTER TO THE DIRECTORY
	JSR PC,ITM1PL			;LOAD IT UP
	MOV (P),A			;GET BACK THE POINTER TO THE ENTRY
	MOV 2(A),C			;GET THE EXACT VERSION NUMBER
	JSR PC,ITM1PO			;POP THE DIRECTORY
	MOV (P),A			;GET BACK POINTER INTO DIR.
	MOV 2(B),(P)			;SAVE IT FOR FIXING LATER IF FLUSHED
	MOV C,2(B)			;THE EXACT VERSION NUMBER INTO THE TEMP MFI
	JSR PC,HTLOOK			;TRY LOOKING IT UP
	BMI MFADL3			;WE WERE FLUSHED
	BNE MFADL2			;FOUND IN HASH TABLE
	MOV A,(P)			;NOW, SAVE THE DIR. POINTER
	MOV FAUPT(D),A
	JSR PC,ITM1PL
	REST A
	JSR PC,MAKMFI			;OPEN THE ENTRY
	BEQ MFADL1			;FAILED
	MOV ITM2A,A
	BIT #MFDIRB,MFLAGW(A)
	BEQ MFADL4			;YOU CAN ALWAYS DELETE A FILE
	BIT #MFDMTB,MFLAGW(A)
	BEQ MFIRAN			;DIRECTORY WASN'T EMPTY

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

MFADL4:	JSR PC,RLSBLK			;RELEASE BLOCKS AND DELETE DIRID ENTRY
	MOV #ITM2AD+MFENHD,B
	JSR PC,DRLOOK			;FIND THE ENTRY AGAIN
	BUGC PL,MFADL6			;IT WAS HERE A MINUTE AGO
	SAVE <A>
	JSR PC,MFDELP			;DELETE THE TEMPORARY MFI
MFADL5:	REST <B>			;POINTS TO ENTRY TO DELETE
	MOV FAUPT(D),A
	SAVE FAMFI(D)			;THE PARENT MFI
	JSR PC,ITM1PL			;LOAD DIRECTORY
	REST A
	JSR PC,ITM2LD			;LOAD PARENT MFI
	MOV (B),E
	INC E				;ROUND UP TO WORD BOUNDARY
	BIC #177401,E			;LEGNTH OF ENTRY TO DELETE
	MOV B,C
	ADD E,C				;POINTER TO NEXT ENTRY
	MOV MFBYTP(A),F
	TST MFPGNO(A)
	BEQ .+6
	ADD #20000,F			;TOTAL LEGNTH OF DIRECTORY
	SUB F,E				;NEW LEGNTH OF DIRECTORY
	NEG E
	MOV E,MFBYTP(A)
	CLR MFPGNO(A)			;CHANGE EOF WORDS
	MOV E,ITM1AD+MFBYTP-MFENHD	;CHANGE IT IN THE DIRECTORY ALSO
	CLR ITM1AD+MFPGNO-MFENHD
	BIS #MFLSTB,MFENHD(A)
	BIS #MFEBMB,MFLAGW(A)		;SET SOME BITS
	ADD ITM1A,F			;MAKE F ABSOLUTE EOF
	SUB C,F				;NUMBER OF BYTES LEFT AT END OF DIR
	ASR F				;INTO WORDS
	BEQ MFADL8			;ENTRY MUST BE THE LAST (NOTHING TO MOVE)
	MOV (C)+,(B)+			;WRITE OVER ENTRY TO BE DELETED
	SOB F,.-2
MFADL8:	MOV ITM2A,C
	MOV (C),E
	INC E				;ROUND UP TO WORD BOUNDARY
	BIC #177401,E			;LEGNTH OF SELF ENTRY
	ADD E,C
	MOV (C),E
	INC E				;ROUND UP TO WORD BOUNDARY
	BIC #177401,E			;LEGNTH OF PARENT ENTRY
	ADD E,C
	CMP E,B				;ANY OTHER ENTRIES LEFT?
	BLO .+10
	BIS #MFDMTB,MFLAGW(A)		;THE DIRECTORY IS EMPTY
	JSR PC,ITM1PO			;POP THE DIRECTORY
	JSR PC,MFSETW			;SET THE WRITTEN ON BIT
	JMP ERETCZ
;ADD AN ENTRY TO THE DIRECTORY WHOSE CAPABILITY IS IN (D)

MFAAD:	MOV FAMFI(D),A
	JSR PC,ITM2LD
	BIT #MFDIRB,MFLAGW(A)
	BNE MFIAD1			;ONLY WORKS FOR DIRECTORIES
	MOV #.FAWTE,PERRW+ITM0AD	;WRONG TYPE OF ENTRY
	BR MFIAD4
MFIAD1:	BIT #.FAAP,(D)
	BNE MFIAD2
	MOV #.FAACV,ITM0AD+PERRW
	BR MFIAD4
MFIAD2:	BIT #.FALNK,F
	BNE MFIAD4			;LINKS NOT IMPLEMENTED
	JSR PC,DIRENT			;GET THE REST OF USER'S DATA
	BEQ MFIAD4			;BAD DATA FROM LOSER
	MOV ITM2A,A			;ALMOST MFI LEFT IN ITEM2 BY DIRENT
	CMP #-1,MFVERN(A)
	BNE .+12 			;ILLEGAL TO WRITE FOO <
	MOV #.FABFN,#ITM0AD+PERRW
	BR MFIAD3			;FAILED
	CMP #-3,MFVERN(A)
	BNE .+10
	MOV #-2,MFVERN(A)		;DEFAULT IS FOO >
	BIS #MFDWDB,MFLAGW(A)
	BIS #MFFILE,MFENHD(A)
	BIT #.FADIR,F
	BNE .+6
	JMP MFIAD6			;SKIP IF INSERTING A FILE
	BIS #MFDIRB!MFIWSB,MFLAGW(A)
	BIC #7000,MFENHD(A)		;WE HAVE TO ALLOCATE DIRID AND DISK BLOCK
	BIS #MFDIRE,MFENHD(A)		;NOW SET UP THE DIRID ENTRY
	MOV MFLAGW(A),C
	BIC #177600,C			;LOGICAL DISK NUMBER
	MOV MFDIRD(C),B			;GIP TO DIRID TABLE
	JSR PC,MFSWAL			;LOCK THE DIRID TABLE IN CORE
	MOV A,F				;SAVE POINTER TO MFI
	JSR PC,UPTPLD
	BIS #UPTMOD!UPTWON,UPTDR(B)	;SET WRITTEN ON BIT
	MOV UPTFPT(B),B			;POINTS TO FPT
	ASL B
	MOV FPTMFI(B),A			;MFI ITEM NUMBER
	JSR PC,ITM2LD			;UPTPLD PUSHED ITEM2
	MOV MFBYTP(A),B			;EOF OF DIRID TABLE
	CMP B,#1776
	BLT MFIAD5			;BRANCH IF OK

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE
					;TRY TO MAKE ROOM IN DIRID TABLE
	ASR B				;NUMBER OF WORDS IN DIRID TABLE
	MOV MFDIRD(C),A
	JSR PC,ITM1PL			;LOAD THE DIRID FILE
	MOV A,E				;GET RID OF SPACES IN THE TABLE
MFIA14:	TST (A)+
	BEQ MFIA15			;ZERO'S ARE HOLES IN THE TABLE
	MOV -2(A),(E)+
MFIA15:	SOB B,MFIA14			;FINISH UP THE TABLE
	JSR PC,ITM1PO
	MOV ITM2A,A
	SUB ITM1A,E			;NEW EOF WORD
	MOV E,MFBYTP(A)			;CHANGE EOF WORD
	CMP E,#1776
	BLT MFIAD5			;WE MADE SOME ROOM
	MOV #.FARAN,ITM0AD+PERRW	;DIRID TABLE OVERFLOWED
MFIAD3:	JSR PC,MFDELP			;DELETE THE PARTIALLY COMPLETED MFI
MFIAD4:	JMP ERETSZ			;FAILED
MFIAD5:	ADD #2,MFBYTP(A)
	BIS #MFEBMB,MFLAGW(A)
	JSR PC,ITM2PO			;GET TEMPORARY MFI BACK
	MOV MFDIRD(C),A
	JSR PC,ITM1PL			;LOAD THE DIRID FILE
	ADD B,A				;ABSOLUTE EOF
	MOV -2(A),(A)			;DIRID FOR NEW DIRECTORY
	INC (A)				;NEXT DIRID
	MOV (A),MFVERN(F)		;PUT IT IN MFI
	JSR PC,ITM1PO			;DONE WITH DIRID
	MOV MFBITS(C),B
	SAVE <FAMFI(D),D>		;THE PARENT ITEM NO.
	CLR -(P)
	CLR -(P)
	CLR -(P)
	SAVE <ITEM2,#.FAAC!.FAAP!.FAWT!.FARD>	;FAKE CAPABILITY
	MOV P,D				;MAKE D POINT TO IT
	MOV ITM2A,A			;POINTER TO THE MFI
	JSR PC,MFSWAL			;LOCK BITS IN CORE
	JSR PC,ADDBLK			;THIS IS NOW THE SELF ENTRY (WITH ONE BLOCK)
	BEQ MFIA18			;FAILED
	MOV #1,A			;DIRECTORY DOESN'T EXIST YET
	JSR PC,MFOPEN			;MAP NEW DIRECTORY BLOCK INTO ITEM1 (PTR IN A)
	BNE MFIA19			;OPEN SUCEEDED
MFIA18:	ADD #12,P			;POP OFF JUNK
	REST D
	TST (P)+
	BR MFIAD3			;GO FAIL
MFIA19:	ADD #12,P			;POP OFF CAPABILITY
	REST D
	MOV (B)+,C			;POINTS TO SELF ENTRY
	BIC #7000,C
	BIS #MFSLFE,C
	MOV C,(A)+			;HEADER WORD
	INC C				;ROUND UP TO NEXT WORD
	BIC #177401,C			;BYTE COUNT
	ASR C
	DEC C				;ALREADY DID HEADER WORD
	MOV (B)+,(A)+			;MOVE THE SELF ENTRY
	SOB C,.-2

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

	MOV A,B				;SAVE POINTER
	REST A
	JSR PC,ITM2PL			;LOAD UP PARENT MFI
	CLR F
	JSR PC,MFIRDS			;THIS WILL FIND DISCRIPTOR IN PARENT ENTRY
	MOV MFDPTR,C			;POINTS TO MIDDLE BYTE OF 3 BYTE DISCRIPTOR
	ADD #-10-MFENHD-ITM2AD,C	;LEGNTH OF NEW PARENT DISCRIPTOR
	MOV C,(B)			;PARENT ENTRY HAS NO EOF DATE OR TIME WORDS
	BIS #<MFPARE>!MFLSTB,(B)+	;WRITE PARENT HEADER
	MOV MFVERN(A),(B)+		;PARENTS VERSION NUMBER
	ADD #MFENHD+14,A		;SKIP HEADER,DIRID,EOF,DATE AND TIME WORDS
	SUB #4,C			;ALREADY DID HEADER AND DIRID
	MOVB (A)+,(B)+
	SOB C,.-2			;MOVE THE PARENT ENTRY
	CLRB (B)+			;ONE EXTRA IN CASE OF ODD BOUNDARY
	BIC #1,B
	SUB ITM1A,B			;EOF WORD
	MOV B,ITM1AD+6
	JSR PC,ITM2PO			;POP PARENT MFI
	MOV ITM2A,A
	MOV B,MFBYTP(A)			;EOF WORD
	BIC #MFEBMB,MFLAGW(A)		;WE ARE ABOUT TO WRITE THE ENTRY NOW
	MOV MFIUPT(A),B
	JSR PC,ITM1PO			;POP THE PUSHED DIRECTORY
	SAVE B
	JSR PC,UPTPLD			;LOAD IT UP
	BIS #UPTWON!UPTMOD,(B)		;SAY WE WROTE ON THIS PAGE
	JSR PC,ITM2PO
	REST B
	JSR PC,SWPOT			;SO MFIDEL CAN'T FAIL LATER
MFIAD6:	MOV #ITM2AD+MFENHD,B
	MOV (B),E			;PUT LEGNTH OF ENTRY IN E
	INC E				;ROUND UP TO WORD BOUNDARY
	BIC #177401,E
	BIT #MFDIRB,MFLAGW(A)
	BEQ .+6
	SUB #10,E			;SKIP EOF,DATE AND TIME WORDS
	JSR PC,MFDRSZ			;MAKE SURE THERE IS ENOUGH ROOM
	BEQ MFIA20			;FAILED
MFIAD7:	JSR PC,DRLOOK			;POINTER TO WHERE TO INSERT ENTRY RETURNED IN A
	BNE .+6				;WINNER
MFIA20:	JMP MFIAD3			;ABISMAL FAILURE
	MOV PS,C			;REMEMBER IF WE FOUND IT OR NOT
	JSR PC,MFDRSZ			;MAKE SURE THE ROOM IS STILL THERE
	BEQ MFIA20			;FAILED
	BMI MFIAD7			;GOT FLUSHED TRY AGAIN
	SAVE <FAMFI(D),A>		;SAVE MFI NUMBER BEFORE PUSHING ITEM1
	MOV FAUPT(D),A
	JSR PC,ITM1PL			;LOAD DIRECTORY WE WANT TO ADD TO
	REST <A>			;B ALREADY POINTS INTO DIRECTORY
	MOV C,PS
	BMI MFIAD9			;DIDN'T FIND IT
	CMP #-2,2(B)			;LOOK AT VERSION NUMBER OR DIRID
	BEQ MFIA16
MFIA13:	MOV #.FABFN,#ITM0AD+PERRW	;ENTRY ALREADY EXISTS
	JSR PC,ITM1PO
	TST (P)+			;CLEAN UP JUNK
	JMP MFIAD3			;FAILED

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

MFIA16:	MOV 2(A),2(B)			;WE ARE NOW WRITING > ENTRY
	INC 2(B)
	BVS MFIA13			;VERSION NUMBER OVERFLOWED
	MOV (A),C
	INC C				;ROUND UP TO WORD BOUNDARY
	BIC #177401,C
	ADD C,A				;SKIP OVER OLD ENTRY
	CLR C				;FLAG INDICATES WRITING FILE ENTRY
	BR MFIA11			;GO WRITE THE NEW ENTRY
MFIAD9:	MOV (B),C			;DRLOOK DID NOT FIND IT
	BIC #170777,C			;TYPE OF ENTRY
	CMP #MFLNKE,C
	BEQ MFIA11			;C IS NOT ZERO
	CMP #MFDIRE,C
	BEQ MFIA11			;C IS NOT ZERO
	CLR C				;SET FLAG FOR FILES
	CMP #-2,2(B)
	BNE MFIA11
	INC 2(B)			;CHANGE TO NO VERSION NUMBER
MFIA11: SAVE <A,B>			;NOW INSERT THE ENTRY IN THE DIRECTORY
	MOV 4(P),A
	JSR PC,ITM2PL			;LOAD DIRECTORY MFI
	TST F				;SET BY MFDRSZ
	BNE .+10
	BIC #MFLSTB,MFENHD(A)		;USED UP ALL THE SPACE THERE WAS
	ADD E,MFBYTP(A)			;INCREMENT EOF WORD
	MOV MFBYTP(A),B			;GET COPY OF EOF
	BIT #20000,B
	BEQ MFIA12
	CLR MFBYTP(A)			;OVERFLOWED BYTE COUNT
	MOV #1,MFPGNO(A)

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

MFIA12:	BIS #MFEBMB,MFLAGW(A)		;JUST MUNGED IT
	MOV ITM1A,A			;POINT TO THE DIRECTORY
	MOV B,MFBYTP-MFENHD(A)		;SET IN THE EOF INTO THE DIRECCTORY
	ADD A,B				;ABSOLUTE NEW EOF
	MOV B,A
	SUB E,A				;ABSOLUTE OLD EOF
	MOV A,F
	SUB 2(P),F
	ASR F				;WORD COUNT
	BEQ MFIA17			;NOTHING TO COPY
	MOV -(A),-(B)			;MOVE TOP OF DIRECTORY UP
	SOB F,.-2
MFIA17:	JSR PC,ITM2PO			;NOW NEW ENTRY IS IN ITEM2
	REST <A,B>			;POINTERS FOR NEW ENTRY
	TST (P)+			;NO LONGER NEEDED
	MOV (A)+,F			;HEADER WORD
	TST C
	BEQ MFIA21
	BIC #MFEOFB,F			;DIRECTORY ENTIES DONT HAVE EOFS
	SUB #10,F			;SKIP EOF,DATE AND TIME WORDS
MFIA21:	MOV F,(B)+			;PUT IT IN DIRECTORY
	INC F				;ROUND UP TO WORD BOUNDARY
	BIC #177401,F
	MOV (A)+,(B)+			;MOV VERSION NUMBER/DIRID
	ASR F				;WORD COUNT
	SUB #2,F			;JUST MOVED TWO WORDS
	TST C
	BEQ .+6
	ADD #10,A			;SKIP EOF DATE AND TIME WORDS
	MOV (A)+,(B)+
	SOB F,.-2			;INSERT THE ENTRY
	JSR PC,ITM1PO
	MOV ITM2A,A
	BIC #MFDWDB,MFLAGW(A)		;DON'T WORRY ABOUT PC-LOSERING ANYMORE
	JSR PC,MFSETW	;INDICATE THE DIR HAS BEEN WRITTEN
	JSR PC,MFDELP			;KILL THE TEMPORARY ITEM
	JMP ERETCZ			;SUCESSFUL
;MUTATE A FA CAP

MFAMU1:	TST (P)+			;FLUSH THE OLD VERSION NUMBER
	MOV (P),A
	JSR PC,DLITEM			;DELETE TEMPOARY ITEM
	JSR PC,LSWPOP			;WOULD HAVE DELETED THE ITEM
	MOV C,A
	CLR (P)				;TEMP ITEM NO LONGER EXISTS
	SAVE <A>			;SAVE ITEM NUMBER OF NEW MFI
	JSR PC,ITM2LD
	MOV #MFOPNB,B			;LOCK THE .OPEN SWITCH
	MOV #MFLAGW,A			;WINS WITHOUT FLUSHING SINCE HTLOOK WINS
	JSR PC,LCKASW
	BR MFAMU4
MFAMU:	MOV FAMFI(D),A			;DON'T MUTATE A FILE CAP.
	JSR PC,ITM2LD
	BIT #MFDIRB,MFLAGW(A)
	BEQ MFAM11			;CANT MUTATE FROM FILE
	JSR PC,DIRENT			;GET A FILE NAME FROM USER
	BEQ MFAMU6
	SAVE <C,E,F,ITEM2>
	MOV B,E
	MOV #ITM2AD+MFENHD,B
	CMP #-3,2(B)			;SHOULD DEFAULT VERSION NUMBER BE INSERTED
	BNE .+10
	MOV #-2,2(B)			;DEFAULT IS >
	BR .+6
MFAMU3:	REST 2(B)			;RESTORE THE VERSION NUMBER
	JSR PC,DRLOOK			;LOOK FOR IT IN DIRECTORY
	BLE MFAMU7			;FAILED
	SAVE A				;SAVE THE POINTER TO THE DIR
	MOV FAUPT(D),A			;POINTER TO THE DIRECTORY
	JSR PC,ITM1PL			;LOAD IT UP
	MOV (P),A			;GET BACK THE POINTER TO THE ENTYR
	MOV 2(A),C			;GET THE ACTUAL VERSION NUMBER TO LOOK FOR
	MOV C,(P)			;FOR RESTORING IT LATER
	JSR PC,ITM1PO			;POP DIRECTORY
	MOV C,2(B)			;LOOK FOR THIS EXACT VERSION NUMBER
	JSR PC,HTLOOK			;LOOK AGAIN IN HASH TABLE
	BGT MFAMU1			;GOT IT
	BLT MFAMU3			;WE WAS FLUSHED
	TST (P)+			;DONT NEED WHAT THE VERSION NUMBER USED TO BE
	MOV A,C				;POINTER TO ENTRY
	MOV FAUPT(D),A
	JSR PC,ITM1PL			;LOAD UP DIRECTORY
	MOV C,A				;START OF ENTRY
	JSR PC,MAKMFI
	BEQ MFAMU8
	SAVE <(P)>			;ITEM NUMBER OF NEW MFI
	BIT #MFDIRB,ITM2AD+MFLAGW
	BEQ MFAMU2			;DON'T DECREMENT REFERENCE COUNT SINCE
					;JUST CREATED INFERIOR FILE MFI

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

MFAMU4:	JSR PC,MFIDEL			;DECREMENT OLD MFI
	BEQ MFAMU9			;FAILED
MFAMU2:	REST <A>			;THIS IS FAMFI
	TST (P)+			;WE CAN'T FAIL NOW
	CLR FAFBP(D)			;CHANGE OLD CAP TO NEW
	CLR FAFPN(D)
	MOV A,FAMFI(D)
	JSR PC,ITM2LD
	MOV #<.FARD!.FAWT!.FAAP!.FAAC!.FACAP>,(D)
	JSR PC,LSWPOP			;MFDELP OR .OPEN BIT LOCK
	BIT #MFOPNB,MFLAGW(A)
	BNE MFAM10			;BRANCHES IF NEW MFI
	INC MFREF(A)			;INCREMENT COUNTS SINCE
	INC MFPREF(A)			;MAKING NEW CAP TO OLD MFI
MFAM10:	BIC #MFOPNB,MFLAGW(A)
	CMP ITEM1,MFLKSP(A)
	BNE .+6
	INCB 1(A)			;INCREMENT LOCKING COUNT
	REST <F,E>
	MOV F,B
	JSR PC,GIVPSW			;UPDATE USERS POINTERS
	MOV E,B
	JSR PC,GIVPSW
	JSR PC,RETNSW
	JSR PC,RETNSW
	TSTB (P)+
	BNE MFAMU			;KEEP MUTATING
MFAMU5:	JMP ERETCZ
MFAMU9:	TST (P)+			;POP JUNK
MFAMU7:	MOV (P),A
	JSR PC,DLITEM
MFAMU8:	ADD #10,P
MFAMU6:	JMP ERETSZ
MFAM11:	JMP MFIWTE
;MAKE THIS FILE THE BIT TABLE FOR IT'S PARENT DIRECTORY

MFAMB:	MOV FAMFI(D),A
	JSR PC,ITM2LD
	BIT #MFDIRB,MFLAGW(A)
	BNE MFAM11			;ITS NOT A FILE
	JSR PC,DKDRIO			;MAKE A FUPT
	JSR PC,LSWPOP			;CLEAR ITS PROCESS PTR
	MOV FAMFI(D),A
	JSR PC,ITM2LD
	MOV MFBAKP(A),A
	JSR PC,ITM2PL			;LOAD UP PARENT MFI
	BIT #MFIRTB,MFLAGW(A)
	BEQ MFAMB1			;NOT A ROOT DIRECTORY
	MOV MFLAGW(A),C
	BIC #177600,C
	TST MFBITS(C)
	BNE MFAMB1			;ALREADY HAS A BIT TABLE
	MOV FAUPT(D),A
	CLR FAUPT(D)			;SO IT WONT GO AWAY
	MOV A,MFBITS(C)			;PUT THE FUPT IN THE TABLE
	JSR PC,ITM2LD			;LOAD UP THE BIT FILE
	MOV (A)+,B			;NUMBER OF BLOCKS ON THIS DISK
	INC B
	ASH #-4,B			;NUMBER OF WORDS IN BIT TABLE
	CLR E				;COUNT OF FREE BLOCKS
MFAMB2:	MOV (A)+,F			;GET A WORD FROM THE BIT TABLE
	CMP #-1,F
	BEQ MFAMB4			;NO FREE BLOCKS HERE
	SEC				;WHEN THIS IS SHIFTED OUT GET ANOTHER WORD
MFAMB3:	ROR F
	BCS .+4				;THIS BLOCK IS USED
	INC E				;GOT A FREE ONE
	TST F
	BNE MFAMB3			;FINISH UP THIS WORD
MFAMB4:	SOB B,MFAMB2			;GET ANOTHER WORD
	MOV E,MFREBK(C)			;PUT NUMBER OF FREE BLOCKS IN TABLE
	JSR PC,ITM2PO
	MOV ITM2A,A
	INC MFREF(A)			;SO IT CANT GO AWAY BEFORE THE ROOT
	BR MFAMU5			;GOOD RETURN
MFAMB1:	JSR PC,ITM2PO
	BR MFAM11
;MAKE THIS FILE THE DIRID TABLE FOR ITS PARENT DIRECTORY

MFAMD:	MOV FAMFI(D),A
	JSR PC,ITM2LD
	BIT #MFDIRB,MFLAGW(A)
	BNE MFAMD2			;ITS NOT A FILE
	JSR PC,DKDRIO			;MAKE A FUPT
	JSR PC,LSWPOP			;CLEAR ITS PROCESS PTR
	MOV FAMFI(D),A
	JSR PC,ITM2LD
	MOV MFBAKP(A),A
	JSR PC,ITM2PL			;LOAD UP PARENT MFI
	BIT #MFIRTB,MFLAGW(A)
	BEQ MFAMD1			;NOT A ROOT DIRECTORY
	MOV MFLAGW(A),C
	BIC #177600,C
	TST MFDIRD(C)
	BNE MFAMD1			;ALREADY HAS A DIRID TABLE
	MOV FAUPT(D),MFDIRD(C)
	JSR PC,ITM2PO
	MOV ITM2A,A
	INC MFREF(A)			;SO IT CANT GO AWAY BEFORE THE ROOT
	CLR FAUPT(D)			;SO IT WONT GO AWAY
	JMP ERETCZ			;GOOD RETURN
MFAMD1:	JSR PC,ITM2PO
MFAMD2:	JMP MFIWTE

;APPEND A PAGE TO A FILE
;FIRST ARG IS CAPABILITY TO FILE		
;SECOND IS THE PAGE NO.
MFAPA:	CMP E,#20			;IS IT A LEGAL PAGE
	BHIS MFAAP8			;NO
MFAAP4:	MOV E,F				;COPY IT
	MUL #UPTLEN,F			;FIND THE PAGE
	ADD #ITM1AD+SUPTS,F
	MOV (F),B			;GET THE DR
	BIC #360,B			;SEE IF IT EXISTS
	BNE MFAP12				;IT DOES
MFAAP8:	MOV #.FABPG,ITM0AD+PERRW	;BAD PAGE
	JMP ERETSZ
MFAWTE:	MOV #.FAWTE,ITM0AD+PERRW	;WRONG TYPE OF ENTRY
	JMP ERETSZ
MFAACV:	MOV #.FAACV,ITM0AD+PERRW	;ACCESS VIOLATION
	JMP ERETSZ
MFAP12:	BIT #UPTDEI,B			;IS D=I
	BEQ MFAAP3			;NO
	CMP F,#ITM1AD+SUPTS+<UPTLEN*10>	;IS IT THE D PAGE OF THE PAIR
	BLO MFAAP3			;NO
	SUB #<UPTLEN*10>,F		;POINT TO THE I SPACE
MFAAP3:	MOV (F),B			;GET THE START
	BIC #UPMSRE,B			;IT BETTER BE 0
	BNE MFAAP8
	MOV FAMFI(D),A			;MFI ITEM NO.
	JSR PC,ITM2LD			;LOAD IT UP
	BIT #MFDIRB,MFLAGW(A)		;IS IT A DIRECTORY
	BNE MFAWTE			;YES???
	BIT #.FAAP,(D)			;CAN I APPEND
	BEQ MFAACV			;NO
	MOV #MFLAGW,A			;LOCK THE APPENDING SWITCH
	MOV #MFIBEB,B
	MOV ITEM2,C
	JSR PC,LCKASW
	MOV ITM2A,A			;POINT TO THE MFI
	BIT #1777,MFBYTP(A)		;AM I ALREADY ON BLOCK BOUNDARY
	BEQ MFAAP1			;YES
	BIS #MFEBMB,MFLAGW(A)		;CHANGING THE ENTRY
	ADD #2000,MFBYTP(A)		;ROUND UP THE BYTE POINTER TO NEXT BLOCK
	CMP MFBYTP(A),#20000		;DID I ROUND TO NEXT PAGE
	BLO MFAAP1			;NO
	INC MFPGNO(A)			;SAY THERE IS ANOTHRE PAGE
	CLR MFBYTP(A)			;NO EXTRA BYTES OR BLOCKS
MFAAP1:	BIC #1777,MFBYTP(A)		;CLEAR TO GET ONTO A BLOCK BOUNDARY
	BIC #MFLSTB,MFENHD(A)		;CLEAR 
	TST MFBYTP(A)			;AM I ON A PAGE BOUNDARY
	BEQ MFAAP2			;YES, DONT DO A THING
	JSR PC,MFIEXP			;EXPAND THE ITEM FOR A HOLE TYPE DESCRIPTOR
	MOV #20000,B			;THE LENGTH IN BYTES OF A FULL PAGE
	SUB MFBYTP(A),B			;SUBTRACT THE NUMBER WE ALREADY HAVE
	ASH #-10.,B			;TURN INTO THE NUMBER OF BLOCKS NEEDED
	DEC B				;BECAUSE 0=1?
	BIS #140,B			;SET IN THE HOLE TYPE DESRCIPTOR
	MOVB MFENHD(A),C		;FIND THE END OF THE ENTRY
	ADD #ITM2AD+MFENHD,C		;POINT TO IT DIRECTLY
	MOVB B,(C)+			;SET IN THE HOLE DESCRIPTOR
	CLRB (C)+			;AND CLEAR NEXT BYTE FOR LUCK
	INCB MFENHD(A)			;SAY ANOTHER BYTE EXISTS
	BIS #MFEBMB,MFLAGW(A)		;AND ENTRY HAS BEEN MUNGED AGAIN
	CLR MFBYTP(A)			;ON A PAGE BOUNDARY NOW
	SAVE F				;THE POINTER TO THE UPT
	MOV MFPGNO(A),F			;GET THE LAST PAGE NO.
	INC MFPGNO(A)			;INCREMENT IT FOR CORRECT EOF
	JSR PC,MFPTFX			;FIX UP THE OLD FPT
	REST F				;GET BACK POINTER TO UPT
MFAAP2:	MOVB MFENHD+ITM2AD,A		;FIND THE LENGTH OF THE ENTRY
	ADD #MFELEN+25.,A		;HAVE TO BE ABLE TO ADD 8. 3BYTE DESCRIPTORS+1
	ASH #-6,A			;GET NUMBER OF 32. WORD BLOCKS
	MOV ITEM2,B			;ITEM TO EXPAND
	JSR PC,EXITEM			;MAKE IT LARGER
	BNE MFAP13
	MOV #.FARAN,ITM0AD+PERRW	;RANDOM ERROR
	JMP ERETSZ
MFAP13:	MOV ITEM2,A			;LOAD IT BACK UP
	JSR PC,ITM2LD
	MOV MFLAGW(A),B			;GET THE DISK THAT THIS ONE IS ON
	BIC #177600,B
	MOV B,C
	MOV MFBITS(B),B			;GET THE BITTABLE FUPT FOR THIS DISK
	SAVE B
	JSR PC,UPTPLD			;LOAD IT UP
	BIS #UPTMOD!UPTWON,(B)		;SAY WE MODIFIED IT
	REST B
	JSR PC,ITM2PO			;POP HT EUPT
	JSR PC,MFSWAL			;SWAP IT IN AND LOCK IT
	MOV UPTCLP(F),B			;SWAP IN THE CURRENT PAGE
	JSR PC,SWPIN
	;FALLS INTO NEXT PAGE
	;FALLS IN FROM PREVIOUS PAGE
MFAAP5:	MOV FPTFRE,E			;ALLOCATE A FPT
	BNE MFAAP6
MFAAP7:	JSR PC,LFLUSH
	TST FPTFRE
	BEQ MFAAP7
	JSR PC,RUNME
	BR MFAAP5
MFAAP6:	MOV (F),A			;GET THE DR
	BIC #UPMLRE,A
	ASH #-12.,A			;FIND ITS LENGTH
	CMP A,MFREBK(C)			;ARE THERE ENOUGH FREE BLOCKS ON THIS DISK
	BLO MFAAP9			;YES
	MOV #.FANSS,ITM0AD+PERRW	;SAY NOT ENOUGH ROOM
	JMP ERETSZ
MFAAP9:	SAVE F				;POINTER TO THE UPT
	INC A				;THE NUMBER OF BLOCKS TO ADD
	MOV MFBITS(C),B			;POINTER TO THE BIT TABLE
MFAP10:	SAVE <A,B>
	JSR PC,LOCKSW			;BECAUSE ADDBK WANTS TO POP ONE
	REST B				;GET BACK POINTER TO BIT TABLE
	MOV ITM2A,A			;POINT TO THE MFI
	ADD #2000,MFBYTP(A)		;FIX UP THE BYTE POINTER
	JSR PC,ADDBK			;ADD A BLOCK
	REST A				;GET BACK COUNT
	SOB A,MFAP10			;TRY UNTIL ENOUGH ADDED
	MOV ITM2A,A
	BIC #MFLSTB,MFENHD(A)		;THE LAST BLOCK DOESN'T EXIST
	MOV MFPGNO(A),FAFPN(D)		;SET UP THE PAGE NO.
	JSR PC,MFMFPT			;MAKE A FPT FOR IT
	MOV ITM2A,A
	CMP MFBYTP(A),#20000		;HAS IT OVERFLOWED PAGE
	BNE MFAP14			;NO IT IS CORRECT
	INC MFPGNO(A)			;SAY NEXT PAGE
	CLR MFBYTP(A)			;NO BYTES
MFAP14:	MOV MFBYTP(A),FAFBP(D)		;SET UP THE CAPABILITY
	MOV MFPGNO(A),FAFPN(D)		;ALSO TGHE PAGE NO.
	REST F				;GET BACK UPT POINTER
	BIT #MFIWSB,MFLAGW(A)		;IS IT WRITE TO SOURCE?
	BEQ MFAP11			;NO
	MOV UPTFPT(F),B			;THE OLD SWAP SPACE
	JSR PC,DSWPAL			;DEALLOCATE IT
	CLR UPTFPT(F)			;NO SWAP SPACE
MFAP11:	MOV UPTFPT(F),FPTSWA(E)		;SET IN THE OLD SWAP ADDRESS
	MOV UPTCLP(F),FPTUPT(E)		;MAKE THE FPT POINT TO THE UPTS
	MOV E,C				;COPY POINTER TO FPT
	ADD #FPTSRC,C			;POINT TO THE BLOCKS
	MOV #10,B
	BIC #FPTBAS,(C)+		;CLEAR ALL THE BAS BITS
	SOB B,.-2
	BIS #UPTWON!UPTMOD,(F)		;SAY WE HAVE WRITTEN AND MODIFIED THESE PAGES
	CLR C				;THIS WILL COUNT NUMBER OF SPHERE UPT
	MOV E,A				;COPY POINTER TO FPT
	SEC				;SET THE TOP BIT ON ROR
	ROR A				;TURN INTO SWAP ADDRESS POINTER
	MOV F,B				;COPY THE POINTER TO UPT
	ADD #ITM2AD-ITM1AD,F		;TURN IT INTO ONE LOADED BY UPTLD
UPTLP2:	MOV A,UPTFPT(B)			;CHANGE THE SWAP ADDRESS
	MOV UPTCLP(B),B			;GET THE NEXT ONE
	TST ITEM2			;IS IT FUPT
	BMI .+4				;YES
	INC C				;SAY ANOTHER SPHERE UPT
	JSR PC,UPTLD			;LOAD IT UP
	CMP ITEM2,ITEM1			;IS IT IN THE SAME SPHERE AS THE FIRST
	BNE UPTLP2			;NO, CHANGE IT
	CMP B,F				;IS IT THE SAME ONE
	BNE UPTLP2			;NO, CHANGE IT
	MOV FAMFI(D),A			;GET THE MFI FOR THIS FILE
	JSR PC,ITM2LD			;LOAD IT BACK UP
	ADD C,MFREF(A)			;INCREMENT THE REF COUNT FOR EACH SPHERE UPT
	JMP ERETCZ			;DONE
;RETURN A BLOCK OF DATA ABOUT THE FILE THIS IS A CAPABILITY TO
;(F)= POINTS TO DESTINATION OF DATA
;(E)= NEGATIVE OF THE MAXIMUM NUMBER OF BYTES TO GIVE USER

MFARI:	TST E				;IS IT NEGATIVE
	BPL .+4
	NEG E				;MAKE IT POSITIVE
	ASR E				;WE ONLY GIVE USER WORDS
	BNE MFARI9
	MOV #400,E			;GIVE HIM ALL THERE IS
MFARI9:	SAVE (D)			;CAP. FLAGS
	MTPD (F)+			;GIVE USER FLAGS
	MOV FAMFI(D),A
	JSR PC,ITM2LD			;LOAD UP MFI
	DEC E				;WORD COUNT
	BEQ MFARI6
	SAVE MFLAGW(A)
	MTPD (F)+
	ADD #MFENHD,A			;NOW POINTS TO ENTRY IN MFI
	MOV 6(A),B			;EOF BYTE POINTER
	ADD #1777,B			;ROUND IT UP
	BIT #MFLSTB,(A)			;DOES THE LAST BLOCK EXIST
	BEQ .+4
	INC B				;CATCH TRICKY BOUNDARY PROBLEM
	BIC #1777,B
	MOV 4(A),C			;EOF PAGE NUMBER
	ASH #3,C			;BLOCK COUNT NOW
	ADD C,B
	DEC E				;WORD OCUNT
	BEQ MFARI6
	SAVE B				;LEGNTH OF FILE IN BLOCKS
	MTPD (F)+
	DEC E				;WORD OCUNT
	BEQ MFARI6
	SAVE 10(A)			;DATE
	MTPD (F)+
	DEC E				;WORD OCUNT
	BEQ MFARI6
	SAVE 12(A)
	MTPD (F)+
	JSR PC,MFNDNM			;MAKE A POINT TO NAME
	CLR C
	CLR B				;END OF NAME FLAG
	SAVE #MFSENB			;SET UP CO-ROUTINE LINKAGE
MFARI1:	BISB (A)+,C
	BHI MFARI2
	BIC #200,C			;CLEAR HIGH BIT
	INC B				;SET DONE FLAG

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

MFARI2:	JSR PC,@(P)+			;GIVE HIM A BYTE
	TST B
	BEQ MFARI1			;STILL MORE NAME
	CLR (P)				;POP CO-ROUTINE LINKAGE
	CLR -(P)			;ONE ZERO IS SENT AND THE OTHER MARKS THE END
	TST C				;ANYTHING LEFT?
	BEQ .+4
	SAVE C				;GET THIS BYTE
	MOV ITM2A,A
	BIT #MFDIRB,MFLAGW(A)
	BNE MFARI5			;DIRECTORIES HAVE NO VERSION NUMBERS
	MOV MFVERN(A),B			;VERSION NUMBER
	BLT MFARI5			;NO VERSION NUMBER FOR THIS FILE
	SAVE <#' ,#' ,#'#>		;SKIP TWO SPACES AND SEND A #
MFARI4:	CLR A
	DIV #12,A			;GET A DIGIT
	ADD #60,B			;CHANGE TO ASCII
	SAVE B				;WE HAVE TO REVERSE THE ORDER OF THE DIGITS
	MOV A,B
	BNE MFARI4			;MORE DIGITS
MFARI5:	DEC E				;WORD COUNT
	BEQ MFARI8
	MOVB 2(P),1(P)			;PUT TWO BYTES INTO A WORD
	MTPD (B)+			;GIVE USER BYTES OFF THE STACK
	TST (P)+			;POP OTHER BYTE
	BNE MFARI5
	TST (P)				;IS THERE A ZERO LEFT
	BNE .+4
	TST (P)+			;POP THE ZERO
	JMP ERETCZ			;RETURN TO SUCESS
MFARI8:	TST  (P)+
	BNE MFARI8			;CLEAN UP THE STACK
	TST (P)
	BNE MFARI6
MFARI7:	TST (P)+			;POP CO-ROUTINE LINKAGE
MFARI6:	CCC
	SEV
	JMP EMTRET
;CO-ROUTINE TO PUT BYTES INTO USER'S SPACE
MFSENB:	SWAB C
	JSR PC,@(P)+			;THIS IS A CO-ROUTINE
	SWAB C
	DEC E				;WORD OCUNT
	BEQ MFARI7
	SAVE C
	MTPD (F)+
	CLR C
	JSR PC,@(P)+			;RETURN FROM CO-ROUTINE
;RETURN THE DISK NUMBER AND FREE BLOCK COUNT ON USER'S STACK

MFADI:	MOV FAMFI(D),A
	JSR PC,ITM2LD			;LOAD UP MFI
	MOV MFLAGW(A),B
	BIC #177600,B			;LOGICAL DISK NUMBER
	JSR PC,GIVPSW			;GIVE HIM THE WORD
	MOV MFREBK(B),B
	JSR PC,GIVPSW			;GIVE HIM NUMBER OF FREE BLOCKS
	JMP ERETCZ			;SUCESSFUL RETURN
	.STITL	RANDOM CAPABILITY ROUTINES

CAPRMS:
CAPRSP:	CMPB 1(P),#.SPCLR	;IS IT A READ OF THE C-LIST
	BEQ CAPRS1	;YES
	TSTB 1(P)	;IS IT ZERO
	BNE CPRSP1	;NO, BAD FUNCTION
	MOV A,F		;COPY POINTER TO THE SPHERE CAPABILITY
	MOV 2(P),B	;THE PROCESS CAPABILITY POINTER		
	MOV ITM1A,A	;POINTER TO THE SPHERE IN THE MAP
	JSR PC,GCLSTA	;FIND THE C-LIST
	BEQ CPRSP1	;COULDN'T FIND IT
	ADD B,A		;POINT TO THE CAPABILITY DIRECTLY
	CMP 2(A),ITEM0	;IS IT THIS CURRENT PROCESS
	BEQ CPRSP1	;CAN'T DO IT.
	BIT #.SPCAD,(F)	;CAN I ADD TO THE SPHERE
	BEQ CPRSP1	;NOPE
	BIT #.PRWRA,(A)	;CAN I MOVE THIS PROCESS
	BEQ CPRSP1	;NOPE
	MOV 2(A),A	;GET THE PROCESS NO.
	MOV 2(F),B	;THE SPHERE NO.
	JSR PC,PUTPRS	;PUT THE PROCESS INTO THAT SPHERE
	BEQ CPRSP1	;FAILED, MUST BE RUNNING OR TO MANY PROCESSES
CAPRS3:	ADD #6,P	;POP THE OTHER ARGUMENTS
	JMP ERETCZ	;DONE
CPRSP1:	ADD #6,P
	JMP ERETSZ
CAPRS1:	CLR F		;WHERE TO PUT WHAT FROM THERE
	MOV 2(P),B	;THE C-LIST NUMBER TO INVESTIGATE
	BIT #177400,B	;ANY BIT NUMBERS?
	BNE CPRSP1	;WELL NO CAPABILITY THERE
	MOV 2(A),A	;THE SPHERE TO READ FROM
	JSR PC,ITM1PL	;LOAD IT UP
	MOV ITM1A,A	;THE PLACE TO INVESTIGATE IT AT
	JSR PC,GCLSTA	;GET THE C-LIST ENTRY
	BEQ CAPRS4	;FAILED
	ADD A,B		;POINT TO IT
	MOVB (B),F	;COPY IT
	BGE CAPRS2	;THERE IS CAPABILITY THERE
CAPRS4:	CLR F
CAPRS2:	MOV F,B
	JSR PC,GIVPSW	;GIVE HIM THE CAPABILITY
	JSR PC,ITM1PO
	BR CAPRS3

CAPRQU:	BPT
CAPRCL:	TST (P)+	;GET RID OF FIRST ARGUMENT
	MOV A,F		;COPY POINTER TO CAPABILITY
	REST D		;IF < 0 GRAB CONSUMER, ELSE RELEASE IT
	BMI CAPCL2	;TRY TO GRAB IN
	BIT #.CLCONS,(F)	;IS HE THE CONSUMER
	BEQ CAPCL1	;NO, RETURN SUCCESSFUL
	MOV 2(F),A	;THE POINTER TO THE CL
	JSR PC,ITM2LD	;LOAD IT UP
	CLR CLCONP(A)	;CLEAR THE CONSUMER POINTER
	BIC #.CLCONS,(F)	;CLEAR THE CONSUMER BIT
CAPCL1:	TST (P)+	;POP OFF OTHER ARG
	JMP ERETCZ	;RETURN SUCESSFULP
CAPCL2:	BIT #.CLCONS,(F)	;AM I THE CONSUMER ALREADY
	BNE CAPCL1	;YES, WIN
	MOV 2(F),A	;THE POINTER TO THE CL
	JSR PC,ITM2LD	;LOAD IT UP
	TST CLCONP(A)	;IS SOME ONE ELSE CONSUMER
	BNE CAPCL3	;YES, FAIL
	MOV ITEM0,CLCONP(A)	;SAY I AM THE CONSUMER
	BIS #.CLCONS,(F)	;SET THE BIT THAT SAYS SO
	BR CAPCL1	;RETURN SUCCESSFULL
CAPCL3:	TST (P)+	;POP OFF THIRD ARG
	JMP ERETSZ	;FAIL MISERABLY

;THIS CALL USES THE SAME CONVENTIONS ON READ/WRITE SELECT AS CAPRPR (40 BIT MEANS
;WRITE, CLEAR MEANS READ)  IF WRITE, 40 => MOV,41 => BIS,42 => BIC.
CAPRTT:	MOVB 1(P),B	;THE FUNCTION
	MOV B,C		;COPY IT
	BIC #40,B	;CLEAR THE WRITE BIT
	CMP B,#NTTFNC	;IS IT LEAGL
	BLOS CAPRT4	;YES
	ADD #6,P
	JMP ERETSZ
CAPRT4:	TST (P)+
	MOV 2(A),A	;THE TTY ITEM
	JSR PC,ITM2LD	;LOAD IT UP
CAPRT3:	CMP ITEM1,TTITM(A)	;DO I OWN THE TTY
	BEQ CAPRT1	;YES
CAPRT2:	JSR PC,LFLUSH	;WAIT FOR IT
	MOV ITM2A,A	;POINT TO THE TTY
	CMP ITEM1,TTITM(A)	;DO I OWN IT NOW
	BNE CAPRT2	;NO
	JSR PC,RUNME	;LETS GO
	BR CAPRT3	;MAKE SURE
CAPRT1:	ASL B		;CONVERT FUNCTION NUMBER TO WORD OFFSET
	JMP @TTIVTB(B)	;DISPATCH TO TTY INVOKE FUNCTION
CAPRT5:	TST (P)+	;FLUSH THIRD ARG
	JMP ERETCZ	;RETURN SUCESS FUL

;THIS SUBROUTINE CAN BE CALLED TO FORCE THE INVOK TO WAIT UNTIL THE
;OUTPUT BUFFER IS EMPTY
TOWAIT:	TST TOQN(A)	;IS THERE ANYTHING IN OUTPUT QUE?
	BEQ TOWAI2	;NO
TOWAI1:	JSR PC,LFLUSH	;GO AWAY FOR A WHILE
	TST TOQN(A)	;IS THE QUE EMPTY YET?
	BNE TOWAI1	;NO, WAIT SOME MORE
	JSR PC,RUNME	;GO AHEAD
	BR TOWAIT	;MAKE SURE
TOWAI2:	RTS PC

;RESET THE TTY'S IF WANTED
TTRST:	BIT #TORST,2(P)		;RESET OUTPUT?
	BEQ TTRST1		;NO
	BIC #TORST,2(P)		;TURN THE BIT OFF
	SAVE PS
	SPL 7
	MOV TTLTTY(A),E		;THE LOGICAL TTY NUMBER
	JSR PC,TYORT		;RESET OUTPUT
	REST PS
TTRST1:	BIT #TIRST,2(P)		;RESET INPUT?
	BEQ TTRST2		;NO
	BIC #TIRST,2(P)
	SAVE PS
	SPL 7
	JSR PC,TYIRT1		;RESET INPUT QUE
	JSR PC,TYBRT		;RESET INPUT BUFFER
	REST PS
TTRST2:	RTS PC

;MISCELLANEOUS TTY INVOKES
TTMOV:	JSR PC,TTRST	;RESET TTY'S IF DESIRED
	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	REST TTYST1(A)	;DO A MOVE INTO THE TTYST1 WORD
	BR CAPRT5
TTBIS:	JSR PC,TTRST	;RESET TTY'S IF DESIRED
	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	BIS (P)+,TTYST1(A)	;DO A BIS ON THE WORD
	BR CAPRT5
TTBIC:	JSR PC,TOWAIT		;WAIT FOR BUFFER TO CLEAR
	BIC (P)+,TTYST1(A)	;DO A BIC ON THE STATUS WORD
	BR CAPRT5
TTBS2:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	BIS (P)+,TTYST2(A)	;SET BITS IN TTYST2
	BR CAPRT5
TTBC2:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	BIC (P)+,TTYST2(A)	;CLEAR BITS IN TTYST2
	BR CAPRT5
TTRD:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	MOV TTYST1(A),B	;GET THE WORD
	BR TTCNO1	;GIVE HIM THE WORD AND RETURN
TTCNO:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	MOV CHARNO(A),B	;GET THE WORD
TTCNO1:	ADD #4,P
	JSR PC,GIVPSW	;GIVE IT TO HIM
	JMP ERETCZ	;SUCCESSFUL RETURN
TTMV2:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	REST TTYST2(A)	;SET TTYST2
	BR CAPRT5
TTTYP:	MOV TTLTTY(A),E	;THE LOGICAL TTY NO.
	MOV TTYTBL(E),B	;THE INFO ABOUT WHAT KIND OF TTY IT IS
	BR TTCNO1	;RETURN IT TO THE USER
TTSPD:	MOV TTLTTY(A),E	;THE LOGICAL TTY NO.
	BIT #DHF,TTYTBL(E)	;IS IT A DH11?
	BNE .+6		;YES, EVERYTHING IS OKAY
	JMP ERETSZ	;CANT SET ANYONE ELSE'S SPEED
TTSPD1:	SPL 5		;STOP IT FROM CHANGING
	BIT #TOTRAN,TTYST1(A)	;IS IT TRANSMITTING?
	BEQ TTSPD3	;NO, WE CAN MUNG IT
TTSPD2:	SPL 0		;LOWER PRIORITY
	JSR PC,SFLUSH	;WAIT FOR A SHORT TIME
	SPL 5
	BIT #TOTRAN,TTYST1(A)	;TRANSMITTING?
	BNE TTSPD2	;YES
	SPL 0
	JSR PC,RUNME	;IT HAS STOPPED FOR A WHILE
	BR TTSPD1	;NOW TRY TO CHANGE THE SPEED
TTSPD3:	SUB #NFDHTY,E	;GET THE DH LINE NO.
	ASR E		;INTO A NUMBER
	BIC #17,DH0SCR	;CLEAR THE LINE NO.
	BIS E,DH0SCR	;SET IN THE NEW ONE
	REST C		;GET THE SPEED
	BIC #37700,DH0LPR	;ZERO THE OLD SPEED
	BIS C,DH0LPR	;SET IN THE NEW
	SPL 0		;BACK TO LOW LEVEL
	JMP ERETCZ	;AND RETURN


;THIS TTY INVOK CAN BE USED TO IMPLEMENT CONTROL Z TYPE BREAKS. THE IDEA
;IS THAT THE USER JOB HAS A PROCESS WHICH SIMPLY MAKES THIS CALL TO CHECK
;FOR ONE OF THE BREAK CHARS.  THE PROCESS HANGS UNTIL THE CALL SUCCEEDS
;WHICH DEPENDS ON THE ARGUMENT TO THE CALL.  TWO CONDITIONS CAN MAKE THE
;CALL SUCCEED WHICH CORRESPOND TO THE TWO ARUGMENTS TO THE CALL.  THE
;FIRST ARGUMENT IS A PAIR OF BYTES. IF ANY OF THE TYPED IN CHARS HAPPENS
;TO EQUAL ONE OF THESE BYTES THEN THE CALL SUCCEEDS.  THE SECOND ARG IS
;A NUMBER SUCH THAT IF ANY OF THE TYPED IN CHARS IS LESS THAN THIS NUMBER
;THEN THE CALL ALSO SUCCEEDS.  A TYPICAL NUMBER MIGHT BE 40, IN WHICH CASE,
;THE CALL WOULD SUCCEED ANY TIME A CONTROL CHAR WAS TYPED. THE ACTUAL CHAR
;TYPED IS RETURNED ON THE USER'S STACK.  NOTE TWO INHERENT BUGS IN THIS CODE:
;FIRST, SINCE THE LAST CHAR IS CHECKED AT LONG-FLUSHED FREQUENCEY, A CHAR
;COULD POTENTIALLY GO BY WITHOUT BEING CHECKED, EG THE USER IS TYPING VERY FAST.
;SECOND, IF TWO PROCESSES MAKE THIS CALL, THEN THE FIRST ONE TO SUCCEED WILL
;CLEAR THE LAST CHAR WORD, SO THAT THE OTHER CANNOT SUCCEED.
TTBRK:	REST B		;SECOND ARG IS A PAIR OF CHARS TO CHECK FOR
	MOV B,C		;MAKE A COPY
	SWAB C		;GET THE HIGH BYTE CHAR
	BIC #177600,B	;CLEAN OFF THE CRUFT
	BIC #177600,C	;AGAIN
	REST E		;THIRD ARG IS THE NUMBER
	JSR PC,TTBCHK	;SHOULD WE BREAK HERE?
	BEQ TTBRK2	;NO
TTBRK1:	JSR PC,GIVPSW	;TTBCHK RETURNS VALUE IN B
	JMP ERETCZ	;SUCCEED
TTBRK2:	JSR PC,LFLUSH	;GO AWAY FOR A WHILE
	JSR PC,TTBCHK	;SHOULD WE BREAK HERE
	BEQ TTBRK2	;NO
TTBRK3:	JSR PC,RUNME	;AS IT SAYS...
	BR TTBRK1	;RESTART TO MAKE SURE

;THIS SUBROUTINE CHECKS IF THE BREAK PROCESS SHOULD BE RELEASED FOR ANY
;REASON AND SETS UP THE CHAR TO RETURN TO THE USER IS IT SHOULD. IT CLEARS
;Z IF THE BREAK SHOULD COMPLETE.  EXPECTS CHECK CHARS IN B AND C, AND THE
;CHECK NUMBER IN E, LOW BYTE, FLAGS IN HIGH BYTE.
TTBCHK:	MOV TLAST(A),F	;GET THE LAST CHAR TYPED
	BEQ TTBCH0	;JUST CHECK FOR MORE BREAK
	CLR TLAST(A)	;SO WE DON'T GET THIS AGAIN
	CMPB F,B	;IS IT ONE OF THE BYTES TO CHECK FOR?
	BEQ TTBCH1	;YES
	CMPB F,C	;HOW ABOUT THE OTHER CHAR?
	BEQ TTBCH1	;YUP
	CMPB F,E	;IS IT PERHAPS LESS THAN THE NUMBER?
	BLT TTBCH1	;YES
TTBCH0:	BIT #.TTMBK,E	;DOES HE WANT TO DO MORE BREAKS?
	BEQ TTBCH3	;NO
	BIT #.TMORM,TTYST1(A)	;IS MORE PROCESSING ENABLED?
	BEQ TTBCH3	;NO, HANG AROUND FOR A WHILE
	BIT #.TMORF,TTYST1(A)	;IS MORE TRIGGERED?
	BEQ TTBCH3	;NO, HANG AROUND
	MOV #.TTMBK,B	;TELL THE CALLER THIS IS A MORE BREAK
	BR TTBCH2
TTBCH1:	MOV F,B		;GET THE CHAR
	BIC #177400,B	;CLEAR THE HIGH BYTE
	BIS #.TTIBK,B	;TELL HIM THIS IS AN INPUT BREAK
	CLR TLAST(A)	;FLUSH THE OLD LAST CHAR
TTBCH2:	CLZ		;SUCCEED
	RTS PC
TTBCH3:	SEZ		;FAIL
	RTS PC

.IFNZ NTVS
;TV INVOKES  WHICH ARE ACTUALLY INVOKES OF TTY CAPABILITY
;TVATC ATTACHES A TV DISPLAY TO A TTY AND KEYBOARD.  THE SECOND
;ARGUMENT TO THE INVOKE IS THE CAPABILITY INDEX OF THE DISPLAY.
TVATC:	REST B		;GET THE DISPLAY CAPABILITY NUMBER
	MOV #ITM1AD,A	;GET THE SPHERE ADDRESS IN B
	JSR PC,GCLSTA	;GET THE OFFSET OF THE CAPABILITY INTO SPHERE
	BEQ TVATC1	;BAD INVOK
	ADD B,A		;GCLSTA RETURNS THE OFFSET IN B
	CMPB (A),#.DSCAP ;MAKE SURE ITS A DISPLAY CAP
	MOV CLSEM0(A),B	;GET THE NUMBER OF THIS DISPLAY
	ASR B		;CONVERT FROM WORD OFFSET TO NUMBER
	SUB #NFTVDS,B	;MAKE SURE IT'S A TV DISPLAY
	BLT TVATC1	;ITS NOT, BAD INVOKE
	CMP B,#NTVS	;IN CASE THE CAP IS SCREWED UP
	BUGC LT
	MOV #ITM2AD,A	;ADDRESS OF THE TTY ITEM
	MOVB TVDSBF(B),C	;GET THE BUFFER NUMBER OF THIS DISPLAY
	BUGC GE		;IT HAD BETTER HAVE A BUFFER ASSIGNED
	CMP C,#NTVCHN	;IN CASE IT'S SCREWED UP
	BUGC LT
	MOV C,TVBUF(A)	;GIVE THIS TV TTY A BUFFER
	INCB TVDSRF(B)	;ONE MORE THING IS REFERENCING THIS BUFFER
	MOV TTLTTY(A),B	;GET THE LOGICAL TTY NUMBER
	MOVB #-15.,TVBLNK(B)	;TURN ON THE CURSOR FOR THIS TV
	ADD #2,P	;POP THE THIRD ARG
	JMP ERETCZ	;SUCCEED
TVATC1:	ADD #2,P	;CLEAN UP
	JMP ERETSZ	;FAIL
.IFF
TVATC:	ADD #4,P
	JMP ERETSZ
.ENDC

.IFNZ NTVS
;THE FOLLOWING INVOKE CAN BE USED TO CLEAR AND GENERALLY RESET THE SCREEN
TVCL:	JSR PC,TOWAIT	;WAIT UNTIL THE OUTPUT BUFFER CLEARS
	SAVE PS
	SPL 7		;TEMPORARILY
	JSR PC,TVINIT	;INITIALIZE TV VARIABLES, PUSH THE FONT IN ITEM 1
	BEQ TVCL1	;IN CASE TVINIT FAILS
	JSR PC,TVCS	;CLEAR THE SCREEN
	CLR CHARNO(A)	;CURSOR IN POSITION 0. NOTE A SET UP BY TVINIT
	CLR LINENO(A)	;CLEAR THE LINE NUMBER
	JSR PC,ITM1PO	;POP THE FONT ITEM, SET UP BY TVINIT
	REST PS		;BACK TO NORMAL PRIORITY
	ADD #4,P	;CLEAN OFF THE ARGUMENTS
	JMP ERETCZ	;SUCCEED
TVCL1:	REST PS		;BACK TO NORMAL PRIORITY
	ADD #4,P	;POP THE ARGUMENTS
	JMP ERETSZ	;FAIL
.IFF
TVCL:	ADD #4,P
	JMP ERETSZ
.ENDC

;THIS INVOK IS USED FOR REVERSING WHITE AND BLACK ON SCREEN
.IFNZ NTVS
TVREV:	SAVE PS
	SPL 7
	JSR PC,TVINIT	;INITIALIZE THE TV VARIABLES
	BEQ TVREV1	;IN CASE TVINIT FAILS
	JSR PC,REVSCR	;DO THE REVERSE
	JSR PC,ITM1PO	;POP THE FONT ITEM SET UP BY TVINIT
	REST PS
	ADD #4,P	;CLEAN UP
	JMP ERETCZ	;SUCCEED
TVREV1:	REST PS
	ADD #4,P	;CLEAN UP
	JMP ERETSZ	;FAIL
.IFF
TVREV:	ADD #4,P
	JMP ERETSZ
.ENDC	
	
;CHANGE THE FONT OF A TV
.IFNZ NTVS
TVFNT:	JSR PC,TOWAIT	;WAIT UNTIL THE BUFFER CLEARS
	REST B		;THE NUMBER OF THE FONT THAT HE WANTS
	BLT TVFNT1	;ERROR, NO NEGATIVE FONT NUMBERS
	CMP B,#NFONTS	;IS IT GREATER THAN THE NUMBER OF FONTS?
	BGE TVFNT1	;YES, ERROR
	ASL B		;CONVERT TO WORD INDEX
	MOV FNTITM(B),A	;GET THE FONT ITEM FOR THIS FONT
	BLE TVFNT1	;NONE
	JSR PC,ITM1PL	;LOAD IT UP
	MOV ITM2A,C	;ADDRESS OF THE TTY ITEM
	MOV FNHIGH(A),D	;NUMBER OF LINES IN A CHAR
	DEC D		;THIS IS USED FOR LOADING TVWC BY BLINK ETC
	NEG D		;ALLOW 1 FOR LOADING TVRWIN. TVWC EXPECTS NEGATIVE COUNT.
	MOV D,TVLCNT(C)	;LINES IN CHAR MINUS ONE
	MOV FNLINE(A),TVHIGH(C)	;NUMBER OF CHAR LINES ON THE SCREEN
	MOV FNLINL(A),LINEL(C)	;NUMBER OF CHARS PER LINE
	MOV FNLSC(A),TVNLSC(C)	;NUMBER OF LINES TO SCROLL
	JSR PC,ITM1PO	;POP THE FONT ITEM
	MOV B,TVFONT(C)	;SET IN THE NUMBER FOR THIS FONT
	MOV C,A		;COPY TTY ITEM ADDRESS
	CLR -(P)	;PUSH A DUMMY ARGUMENT
	JMP TVCL	;AND DO A CLEAR SCREEN BEFOR RETURNING
TVFNT1:	ADD #2,P	;POP THE NULL ARG
	JMP ERETSZ	;FAIL
.IFF
TVFNT:	ADD #4,P	;POP THE ARGS
	JMP ERETSZ	;FAIL
.ENDC
.IFNZ NTVS
TVSET:	JSR PC,TOWAIT	;WAIT FOR BUFFER TO CLEAR
	BIT #40,C	;DOES HE WANT READ?
	BNE TVSET1	;NO WRITE
	MOV TVCUR(A),B	;THE CHAR POSITION ON LINE
	JSR PC,GIVPSW	;GIVE IT TO HIM
	MOV TVLINE(A),B	;THE LINE NUMBER OF CURSOR
	JSR PC,GIVPSW	;GIVE IT TO HIM
	ADD #4,P	;POP THE ARGS
	JMP ERETCZ	;SUCCEED
TVSET1:	REST C,D	;TVLINE AND TVCUR
	CMP C,TVHIGH(A)	;MAKE SURE IT'S LEGAL
	BGE TVSET2	;TOO HIGH
	CMP D,LINEL(A)	;LENGTH OF A LINE
	BGE TVSET2	;CANNOT PUT IT THERE
	SAVE PS
	SPL 7		;SO THE CURSOR WILL NOT GET CONFUSED
	MOV C,TVLINE(A)	;SET THE TVLINE
	MOV D,TVCUR(A)	;AND THE CHAR NO.
	JSR PC,TVINIT	;LOAD UP FONT ITM ETC
	BEQ TVSET3	;IN CASE INIT FAILS
	JSR PC,RSCUR	;RESET THE VARIABLES
	JSR PC,ITM1PO	;POP THE FONT ITEM
	REST PS		;BACK TO NORMAL PRIORITY
	JMP ERETCZ	;SUCCEED
TVSET3:	REST PS		;BACK TO NORMAL PRIORITY
TVSET2:	JMP ERETSZ	;FAIL
.IFF
TVSET:	ADD #4,P
	JMP ERETSZ	;FAIL
.ENDC
.IFNZ NTVS
TVOFF:	JSR PC,TOWAIT		;WAIT UNTIL BUFFER CLEARS
	BIT #.PRWRT,C		;DOES HE WANT TO READ OR WRITE
	BNE TVOFF1		;WRITE
	MOV TVOFFL(A),B		;GET TVOFFL
	JSR PC,GIVPSW		;RETURN IT TO USER
	ADD #4,P		;POP THE ARGUMENTS
	JMP ERETCZ		;SUCCEED
TVOFF1:	MOV (P),TVOFFL(A)	;FIRST ARG GOES INTO TVOFFLE
	JMP TVCL		;NOW CLEAR THE SCREEN BEFORE RETURNING
.IFF
TVOFF:	ADD #4,P
	JMP ERETSZ		;FAIL
.ENDC

;RETURN THE WIDTH OF CHAR AND TV LINES PER CHAR LINE FOR CURRENT FONT
TVRFN:	ADD #4,P		;NO ARGUMENTS
.IFNZ NTVS
	JSR PC,TVINIT		;LOAD UP THE FONT
	BEQ TVRFN1		;IN CASE THERE IS NO FONT
	MOV FNWIDE(B),E		;WIDTH OF A CHAR
	MOV FNTLCL(B),F		;NUMBER OF TV LINES IN 1 CHAR LINE
	JSR PC,ITM1PO		;POP THE FONT ITEM
	MOV E,B
	JSR PC,GIVPSW		;RETURN THE WIDTH
	MOV F,B
	JSR PC,GIVPSW		;RETURN THE HEIGHT
	JMP ERETCZ		;SUCCEED
TVRFN1:	JMP ERETSZ		;FAIL
.IFF
	JMP ERETSZ
.ENDC

CAPRDS:	.IFZ NTKDIS+NTVS
	BPT
	.IFF
	BITB #100,1(P)	;IS THIS AN OLD STYLE DISPLAY?
	BNE CAPRD5	;NO
	.ENDC
CAPRD3:	.IFZ NTKDIS
	BPT
	.IFF
	TST (A)		;IS THIS AN OLD DISPLAY?
	LBR LT,BADEMT	;NO, NEW ONE
	SAVE <A>	;POINTER TO CAP
	MOV TKDPDL,A	;THE PDLS ETC
	JSR PC,ITM2PL	;LOAD THEM TOO
	REST <A,D>
	SWAB D		;GET THE FUNCTION
	TSTB D
	BEQ CAPRD1	;GO START THE DISPLAY
	CMPB #1,D	;IS IT ONE?
	BEQ CAPRD2	;YES, STOP THE DISPLAY
	ADD #4,P
	JSR PC,ITM2PO
	JMP BADEMT	;NAUGHTY!
CAPRD2:	JSR PC,TKDSP	;STOP IT
CAPRD4:	ADD #4,P
	JSR PC,ITM2PO
	JMP ERETCZ	;WIN
CAPRD1:	JSR PC,TKDSP	;MAKE SURE IT IS STOPPED
	ASL C
	BIC #177760,C	;CONVERT DISPLAY NUMBER TO AN INDEX
	ADD ITM2A,C	;POINT TO THE FIRST WORD EXECUTED FOR THIS DISPLAY
	MOV (P),A	;THE START ADDRESS
	BIS #DPUSHJ,A	;IT IS A PUSHJ
	MOV A,(C)
	BIC #100000,TKDRUN(D)	;START IT ON INT LEVEL
	BR CAPRD4
.ENDC

;TV DISPLAY INVOKES. THESE ARE CALLED WITH A NEGATIVE
;FUNCTION NUMBERS.
CAPRD5:	.IFZ NTVS
	BPT
	.IFF
	MOV CLSEM0(A),C		;GET LOGICAL DISPLAY NUMBER
	BUGC GE			;MUST BE POSITVE
	ASR C			;TV DISPLAYS USE BYTE DATA
	SUB #NFTVDS,C		;GET THE TV NUMBER
	BLT CAPRD6		;IT'S A TK DISPLAY!!!
	CMP C,#NTVS		;MAKE SURE IT'S LEGAL
	BUGC LT			;TOO BIG
	MOVB TVDSBF(C),E	;GET THE BUFFER OF THIS TV
	ASL E			;FOR NOW, WORD OFFSET
	MOVB 1(P),B		;THE FUNCTION HE WANTS
	TST (P)+		;POP THE FIRST ARG
	REST <C,D>		;THE OTHER TWO ARGS
	BIC #100,B		;MAKE INTO SMALL INTEGER
	CMP B,#TVDSIM		;IS IT A LEGAL FUNCTION?
	BGE CAPRD6		;NO!
	ASL B			;OK, SO MAKE INTO WORD OFFSET
	JSR PC,@TVDSIT(B)	;NOW EXECUTE THE FUNCTION
	BEQ CAPRD6		;IN CASE SOMETHING WENT WRONG
	JMP ERETCZ		;EVERTHING'S OK, WE'RE DONE
CAPRD6:	JMP ERETSZ		;OH OH, SOMETHING WENT WRONG


;READ THE CURSOR (OR TURTLE) POSITION
TVDSRC:	MOV TVDSCX(E),B		;THE X POSITION
	JSR PC,GIVPSW		;GIVE IT TO HIM
	MOV TVDSCY(E),B		;THE Y POSITION
	JSR PC,GIVPSW		;LAY IT ON HIM
	CLZ			;SUCCEED
	RTS PC

;SET THE CURSOR POSITION
;TVDSSC CHECKS THE NEW CURSOR POSITION AND UPDATES IT IF IT'S LEGAL
TVDSSC:	TST C			;MAKE SURE IT'S POSITIVE
	BLT TVDSS1		;BAD
	CMP C,#455.		;IS IT TOO HIGH?
	BGE TVDSS1		;YES
	TST D			;THIS ALSO CANNOT BE NEGATIVE
	BLT TVDSS1		;BAD
	CMP D,#576.		;IT X TOO HIGH?
	BGE TVDSS1		;YES!
	MOV C,TVDSCY(E)		;THE NEW Y
	MOV D,TVDSCX(E)		;AND THE NEW X
	CLZ			;OK
	RTS PC
TVDSS1:	SEZ			;SOMETHING WENT WRONG
	RTS PC

;TVDSNL DRAWS A LINE WITH THE PEN UP. IE, IT SETS THE CURSOR
;TO A RELATIVE POSITION JUST LIKE THE REAL LINE DRAWERS
TVDSNL:	SAVE <C,D>		;GET SOME REGISTERS
	MOV TVDSCY(E),A		;OLD Y POSITION
	MOV TVDSCX(E),B		;OLD X POSITION
	ADD A,C			;OLD X + DELTA X
	ADD B,D			;OLD Y + DELTA Y
	JSR PC,TVDSSC		;TRY TO UPDATE THE CURSOR
	BEQ TVDSN1		;SOMETHING WRONG WITH NEW POSITION
	REST <D,C>		;PUT THE INCREMENTS BACK
	CLZ			;SUCCEED
	RTS PC
TVDSN1:	ADD #4,P		;POP THE STUFF WE SAVED
	SEZ			;FAIL
	RTS PC

;TVDSIL IOR'S A LINE ON THE SCREEN
TVDSIL:	JSR PC,TVDSNL		;UPDATE THE CURSOR
	BEQ TVDSX2		;SOMETHING WENT WRONG
	ASR E			;GET THE TV BUFFER NUMBER
	BIS #TVIOR,E		;IOR MODE
	BR TVDSX1		;DRAW THE LINE AND RETURN

;TVDSXL XOR'S A LINE ON THE SCREEN
TVDSXL:	JSR PC,TVDSNL		;UPDATE THE CURSOR
	BEQ TVDSX2		;SOMETHING WRONG
	ASR E			;GET THE BUFFER NUMBER
	BIS #TVXOR,E		;XOR MODE
TVDSX1:	JSR PC,DRAW		;DRAW THE LINE
	CLZ			;SUCCEED
	RTS PC
TVDSX2:	SEZ			;FAIL
	RTS PC

;TVDSCL CLEARS AN AREA OF THE SCREEN
TVDSCL:	JSR PC,TVDSNL		;UPDATE THE CURSOR, CHECK BOUNDS
	BEQ TVDSX2		;FAIL
	ASR E			;THE TV BUFFER NUMBER
	JSR PC,SCRCLR		;CLEAR THE SCREEN
	CLZ			;SUCCEED
	RTS PC

.ENDC
	.STITL CREATE CAPABILITY ROUTINES
CCPRXX:	BPT	;THE ZERO CAPABILITY
CCPRSP:	ADD #6,P
	JMP BADEMT	;CAN'T CREATE A SPHERE CAPABILITY, HAVE TO COPY FROM MASTER
CCPRCC:	CLR B
	MOV #.CCCAP,A	;THIS IS EASY
CCRTS:	RTS PC

;CREATE A MASTER SHPERE CAPABILITY
CCPRMS:	JSR PC,CRSPHR	;CREATE THE ACTUAL SPHERE
	BEQ CCRTS	;NO SPHERE AVAILABLE
	MOV A,B		;THE ITEM NO OF THE SPHERE
	MOV E,C		;ENTER ADDRESS IS 2ND ARG TO CALL
	MOV #MSPCBT!.MSCAP,A	;THE TYPE AND FLAGS
	RTS PC
;CREATE A PROCESS CAPABILITY
CCPRPR:	JSR PC,CRPROC	;CREATE THE ACTUAL PROCESS
	BEQ CCRTS	;NO PROCESS AVAILABLE
	MOV A,B		;FOR THE LOCK ROUTINE 
	JSR PC,ITM0PL	;LOAD IT UP
	MOV E,C	;GET THE STARTING ADRS FOR THE PROCESS
	MOV C,PUPC(A)	;PUT THE STARTING ADRS. INTO ITS USER PC
	JSR PC,ITM0PO	;GET BACK THE ORIGINAL PROCESS
	MOV #.PRCAP!.PRWRA,A	;ITS A PROCESS CAPABILITY
	RTS PC			;SUCCESS
CCPRTT:	CMP E,#NTTYS	;IS IT A LEGAL TTY NO.
	BGT CCPRT1	;NOPE TO LARGE
	ASL E		;TURN IT INTO THE WORD INDEX
	TST TTYITM(E)	;IS THERE ALREADY A ITEM FOR THIS TTY
	BGT CCPRT1	;YES, THIS IS A BAD CALL THEN
	BIT #MXEEF,TTYTBL(E)	;IS IT A MULTIPLEXOR?
	BEQ CCPRT2	;NO
	SAVE E		;THE TTY NUMBER
	MOVB TTYTBL(E),E	;GET THE NUMBER OF THE MULTIPLEXOR TTY
	MOV TTYITM(E),A	;IS THERE A TTY FOR THE MULTIPLEXOR
	BNE CCPRT3	;YES, JUST CREATE THE MULTIPLEXEE
	JSR PC,CRTTY	;CREATE THE TTY
	BEQ CCPRT5	;FAILED
	;HERE PUT IN SOMETHING TO CLEAN UP IF IT LOSES
	MOV B,A		;THE ITEM NO. OF MXOR
	JSR PC,ITM2LD	;LOAD IT UP
	ADD TOQI(A),A	;POINT TO START OF OUTPUT QUEUE
	MOV #NFNLTY,D	;POINT TO PSEUDO TTYS
	MOV #NNLTY,B	;NUMBER OF TTY'S TO CHECK
CCPRT7:	CMPB TTYTBL(D),E	;IS IT THE MULTIPLEXOR?
	BNE CCPRT8	;NOT THIS ONE
	MOVB D,(A)+	;PUT IT INTO QUEUE
CCPRT8:	TST (D)+	;SKIP THIS TTY NEXT TIME
	SOB B,CCPRT7
	BR CCPRT6	;NOW OPEN UP THE MULTIPLEXEE
CCPRT3:	JSR PC,ITM2LD	;LOAD UP THE TTY
	TST TTYU(A)	;IS IT REALLY OWNED OR JUST OPENED BY THE SYSTEM
	BEQ CCPRT4	;OPENED BY THE SYSTEM
	CMP TTYU(A),CURUSR	;IS IT OPENED BY THE CURRENT USER
	BNE CCPRT1	;NO, SO HE LOSES ON THE OPEN
CCPRT4:	INC TTYREF(A)	;INCREMENT ITS REFERENCE COUNT
CCPRT6:	REST E		;GET BACK THE MULTIPLEXEE'S TTY NO.
CCPRT2:	JSR PC,CRTTY	;CREATE THE TTY
	BEQ CCPRT1	;IT FAILED FOR SOME REASON
	MOV #.TTCAP!.TTYI!.TTYO,A	;GIVE HIM I/O CAPABILITY
	RTS PC
CCPRT5:	TST (P)+
CCPRT1:	SEZ
	RTS PC

;CREATE A QUE CAPABILITY
CCPRQU:	MOV E,C	;THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
	JSR PC,CRQUE	;CREATE THE QUE
	BEQ CCPRQ1	;FAILED
	CLR C		;NO DATA WORDS
	MOV #.QUCAP,A	;THE TYPE
CCPRQ1:	RTS PC

;CREATE A QUE ITEM, C CONTAINS THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
CRQUE:	MOV #QUELEN,A	;LENGTH OF QUE
	JSR PC,CRITEM	;CREATE THE ITEM
	BEQ CRQUE2	;FAILED
	MOV B,A		;THE ITEM NO
	JSR PC,ITM2PL	;LOAD TI
	MOV #ITQUE,(A)	;SET THE TYPE
	CLR QUECNT(A)	;NOONE ON THE QUE TO START
	MOV C,QUENUM(A)	;THE NUMBER OF PEOPLE WHO CAN LOCK THE QUE
	MOV #1,QUEREF(A)	;ASSUME THE GUY WHO CREATES IT IS GOING TO REFERENCE IT
	MOV #QUESZ/2,QUEENO(A)	;THE NUMBER OF ENTRIES IN THE QUE
	JSR PC,ITM2PO	;POP THE QUE
	CLZ
	RTS PC
CRQUE1:	SEZ
CRQUE2:	RTS PC

CCPRTR:	TST PTRITM	;IS THERE ONE ALREADY
	BNE CRQUE1	;YES, LOSER
	MOV #PTRLEN,A	;GET THE LENGTH
	JSR PC,CRITEM	;CREATE THE ITEM
	BEQ CRQUE2	;FAILED FOR RANDOM REASON
	MOV B,A		;GET THE ITEM NO.
	JSR PC,ITM2PL	;LOAD IT UP
	MOV #ITPTR,(A)+	;SET IN THE TYPE
	MOV #1,(A)+	;THE REFERENCE COUNT
	MOV #PTRBUF,(A)	;THE START OF THE BUFFER
	MOV (A)+,(A)+	;SET IN THE DATA OUT POINTER
	CLR (A)+	;NOTHING IN BUFFER CURRENTLY
	JSR PC,ITM2PO	;POP IT
	MOV B,PTRITM	;SAY THIS IS THE PTR ITEM
	MOV #1,PTRSR	;SET THE INTERRUPT ENABLE
	CLR C		;NO SECONDARY ITEM
	MOV #.TRCAP,A
	RTS PC

CCPRTP:	TST PTPITM	;PAPER TAPBE ITEM
	BNE CRQUE1	;FAIL THERE ALREADY IS ON
	MOV #PTPLEN,A	;GET THE LENGTH
	JSR PC,CRITEM	;CREATE THE ITEM
	BEQ CRQUE2	;FAILED
	MOV B,A		;COPy THE ITEM NO.
	JSR PC,ITM2PL	;LOAD IT UP
	MOV #ITPTP,(A)+	;TYPE
	MOV #1,(A)+	;REFERENCE COUNT
	MOV #PTPBUF,(A)	;THE POINNTER TO START
	MOV (A)+,(A)+	;SET IT IN
	CLR (A)+	;NOTHING IN THE BUFFER
	JSR PC,ITM2PO	;POP IT
	MOV #.TPCAP,A	;THE TYPE OF CAPABLITY
	CLR C		;NOTHING
	MOV B,PTPITM	;THE ITEM IS NOW HERE
	RTS PC

;CREATE A CORE LINK CAPABILITY, LENGTH OF BUFFER IN E
CCPRCL:	MOV E,A		;COPY LENGTH
	BLE CRQUE1	;BAD LENGTH
	ADD #CLDATL,A	;ADD THE NUMBER OF DATA WORDS
	ASH #-6,A	;GET THE LENGTH IN 32. WORD BLOCKS
	CMP A,#1	;IS IT MORE THAN 2 BLOCKS
	BGT CRCL1	;YES, MAKE AN FUPT FOR IT
	JSR PC,CRITEM	;CREATE AN ITEM
	BEQ CCPRQ1	;FAILED
	MOV B,A		;COPY THE ITEM NO. CREATED
	JSR PC,ITM2PL	;LOAD IT UP
	MOV #ITCL,(A)+	;SET IN THE TYPE
	MOV B,C		;GET THE ITEM NO.
CRCL2:	MOV #1,(A)+	;SET IN THE REFENCE COUNT
	CLR (A)+	;SAY THERE IS NO CONSUMER
	CLR (A)+	;CLEAR THE COUNT OF VALID DATA
	MOV E,(A)+	;SET IN THE NUMBER OF ENTRIES
	MOV #CLDATL,(A)	;SET IN THE DATA IN POINTER
	MOV (A)+,(A)	;SET IN THE DATA OUT POINTER
	SAVE B
	JSR PC,CLSETW	;SET THE W BIT IF NEEDED
	JSR PC,ITM2PO	;POP THE ITEM
	MOV #.CLCAP,A	;THE TYPE
	BIT #GIPBIT,C	;IS IT IN A SPHERE
	BNE CRCL4		;NO	
	REST B
	CLZ
	RTS PC
CRCL4:	MOV (P),B		;THE GIP TO THE FUPT
	JSR PC,UPTPLD	;LOAD IT UP
	MOV #-1,UPTPRP(B)	;SAY NO ONE OWNS IT NOW
	JSR PC,ITM2PO	;PP THE ITEM
	REST B
	CLZ
	RTS PC
	;BRANCHES INTO THE NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
CRCL1:	ASH #-7,A			;GET THE LENGTH IN 512. WORD BLOCKS
	MOV A,B				;COPY LENGTH
	MOV A,D
	JSR PC,SWPAL			;GET SOME SWAP SPACE
	MOV #LPCLRT,A			;RUN ROUTINE IF PCLOSERED
	MOV B,C				;SAVE THE SWAP SPACE POINTER
	CLR B				;SAY THERE IS NO ITEM
	JSR PC,LOCKSW			;GET A LOCK
	MOV #MFPCL4,LCKWD1(A)		;RUN ROUTINE WHICH DELETES SWAP SPACE
	MOV C,LCKWD2(A)			;SET IN POINTER TO SWAP SPACE
	BR .+6				;SKIP FIRST INSTRUCTION
CRCL3:	JSR PC,MFLFUP			;FLUSH UNTIL FUPT IS AVAILABLE
	MOV FUPTFR,B			;GET FREE LIST START
	BEQ CRCL3			;NONE, TRY AGAIN LATER
	MOV (B),FUPTFR			;GET THE FUPT
	MOV C,UPTFPT(B)			;SET IN THE SWAP ADDRESS
	MOV D,C				;THE LENGTH IN 512. WORD BLOCKS
	SWAB C				;GET IT INTO THE RIGHT BITS
	ASH #4,C
	MOV C,UPTDR(B)			;SET IT IN
	MOV C,UPTAR(B)			;SET IT IN ALSO
	BIS #6,UPTDR(B)			;SET IN READ WRITE ACCESS
	MOV B,C				;COPY POINTER
	SUB #<100000+FUPTTB>,B		;GET THE GIP TO THE THING CREATED
	MOV B,UPTCLP(C)			;SET IN THE CIRCULAR LIST POINTER	
	MOV #LPCLRT,A			;RUN ROUTINE IF WE LOSE
	CLR B				;NO ITEM
	JSR PC,LOCKSW			;GET A LOCK
	MOV #FUPTF,LCKWD1(A)		;ROUTINE LINKS FUPT BACK INTO FREE LIST
	MOV C,LCKWD2(A)			;THE ADDRESS OF FUPT
	MOV UPTCLP(C),B			;POINTER TO FUPT
	MOV B,C				;ROUTINE ABOVE EXPECTS IT
	JSR PC,SWPIN			;SWAP IT IN
	JSR PC,LSWPOP			;POP THE LOCK ABOVE
	JSR PC,LSWPOP			;POP THE OTHER LOCK
	MOV B,A				;GET POINTER TO IT
	JSR PC,ITM2PL			;LOAD IT UP
	MOV #ITCL,(A)+			;NOT REALLY NEEDED.
	BR CRCL2

CLSETW:	TST ITEM2			;IS IT FUPT
	BMI .+4				;YES
CLSET1:	RTS PC
	MOV ITEM2,B			;THE ITEM NO.
	CMP B,#-1			;IS THERE ANY ITEM2
	BEQ CLSET1			;NO
	JSR PC,UPTPLD			;LOAD IT UP
	BIS #UPTWON,(B)			;SAY IT IS WRITTEN ON
	JSR PC,ITM2PO			;POP IT
	RTS PC

FUPTF:	MOV LCKWD2(B),A			;POINTER TO THE FUPT TO FREE
	MOV FUPTFR,(A)			;LINK IT IN
	MOV A,FUPTFR			;MAKE IT PART OF THE FREE LIST
	RTS PC

PRPFIX:	MOV LCKWD2(B),A	;POINTER TO THE FUPT TO FIX
	MOV #-1,UPTPRP(A)		;FIX IT UP
PRPFX1:	RTS PC
;CREATE A FILE CAPABILITY
CCPRFA:	JSR PC,GETWRD			;FLAGS TO SET
	MOV C,F
	CLR D				;(D) NOT A CAPABILITY
	JSR PC,DIRENT			;GET FILE NAME ETC.
	BEQ CCFA.5			;FAILED
	INC E				;SKIP TERMINATOR BYTE
	MOV ITM2A,A
	CMP #-3,MFVERN(A)		;SHOULD WE INSERT DEFAULT VERSION NUMBER
	BNE .+10
	MOV #-1,MFVERN(A)		;DEFAULT IS NO VERSION NUMBER
	BIT #MFLOKB,F
	CMP ITEM1,MFLKSP(A)		;IS THIS MFI LOCKED
	BNE CCFA.1
	INCB 1(A)			;INCREMENT THE LOCK COUNT
CCFA.1:	BIT #MFIRTB,F
	BEQ CCFA.6			;TEMP FILE/DIR
	CMP ITEM1,SYSSPR		;ONLY THE SYSTEM SPHERE CAN CREATE ROOT MFIS
	BNE CCFA.5			;NOT THE SYTEM SPHERE?
	BIC #<177400-MFIRTB>,F
	BIS #MFDIRB!MFIWSB,F
	MOV F,MFLAGW(A)			;FLAG WORD
	ADD #MFENHD,A
	BIS #MFDIRE!MFLSTB,(A)	;DIRECTORY ENTRY TYPE
	MOV (A),B
	BIC #177600,B
	ADD A,B
	MOVB #200,(B)+			;PUT A DISCRIPTOR THERE
	JSR PC,GETWRD			;GET THE BLOCK NUMBER
	MOVB C,(B)+
	SWAB C				;PUT THE ADDRESS INTO SET ADDRESS DISCRIPTOR
	MOVB C,(B)+
	SUB A,B
	BIT #177400,B
	BNE CCFA.5			;YOU LOSE ITS TOO BIG
	MOVB B,(A)
	CLR A				;THE DIRECTORY SHOULD ALREADY EXIST
	JSR PC,MFOPEN			;OPEN THE DIRECTORY
	BEQ CCFA.4			;FAILED

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

CCFA.2:	JSR PC,MFIEXP			;PRUNE THE MFI
	JSR PC,MFHASH			;PUT IT IN THE HASH TABLE
	MOV #.FACAP!.FARD!.FAWT!.FAAP!.FAAC,A
	CLR C
	MOV ITEM2,B			;RETURN SUCESSFULLY
	RTS PC
CCFA.4:	JSR PC,ITM2LD			;FAILED CLEAN UP JUNK
	JSR PC,MFDELP
CCFA.5:	SEZ
	RTS PC
CCFA.6:	BIC #<-1-MFLOKB-MFIWSB>,F	;USERS FLAG WORD
	BIS #MFDWDB!MFTDSK,F
	MOV F,MFLAGW(A)			;MAKE A TEMPORARY FILE
	BIS #MFFILE,MFENHD(A)	;SET TYPE IN HEADER
	BR CCFA.2			;PUT IT IN THE HASH TABLE AND RETURN

;CREATE DISPLAY CAPABILITY
CCPRDS:	.IFZ NTKDIS+NTVS
	SEZ
	RTS PC		;NO DISPLAYS
.ENDC
.IFNZ NTVS
	TST E		;DOES HE WANT THE ONE ASSOCIATED WITH TTY?
	BGE CCPRD7	;NO
	MOV E,B		;THIS HAS THE CAP INDEX OF TTY IN HIGH BYTE
	BIC #177600,B	;CLEAN OFF THE 377
	MOV #ITM1AD,A	;ADDRESS OF THE SPHERE
	JSR PC,GCLSTA	;GET THE OFFSET OF THE CAPABILITY INTO SPHERE
	BEQ CCPR15	;Z SET MEANS BAD CAPABILITY NUMBER PASSED TO GCLSTA
	ADD B,A		;THE OFFSET IS RETURNED IN B, GET THE ADDRESS OF CAP
	CMPB (A),#.TTCAP	;MAKE SURE IT WAS A TTY
	BEQ .+6	;IT WASN'T SO FAIL
CCPR15:	JMP CCPR12
	MOV CLSEPI(A),A	;GET THE TTY ITEM NUMBER
	JSR PC,ITM2PL	;LOAD IT UP
	MOV TTLTTY(A),C	;GET THE LOGICAL TTY NUMBER OF THIS TTY
	JSR PC,ITM2PO	;POP THE TTY ITEM
	BIT #TVF,TTYTBL(C)	;IS IT A TV?
	BNE CCPRD8
	BIT #40000,E	;DOE SHE WANT A TV?	
	BNE CCPRD5	;LOSE
	TST TYDISP(C)	;DOES IT EXIST
	BLT CCPRD5	;NO
	BIC #377,E	;CLEAR OUT THE TTY NO.
	BIS TYDISP(C),E	;GET TK DISP NEAR TTY
.ENDC
.IFZ NTKDIS
	SEZ
	RTS PC		;NO TK DISPLAYS
.IFF

	MOV #DISMAL,A		;START LOOKING FOR A SMALL ONE
	BIT #400,E
	MOV #DISBIG,A	;HE REALLY WANTS A BIG ONE
	CLR B		;INDEX TO DISPLAY TABLES
	MOV #NTKDIS,C	;NUMBER OF BUFFERS AVAILABLE
CCPRD3:	CMP #-1,TKDRUN(B)	;AVAILABLE?
	BNE CCPRD1	;NOPE
	CMP A,TKDLEN(B)	;ADEQUATE SIZE?
	BGE CCPRD2	;YES!
CCPRD1:	TST (B)+	;NEXT!
	SOB C,CCPRD3
CCPRD5:	SEZ		;RAN OUT OF POSSIBLITES
	RTS PC
CCPRD2:	MOVB E,C	;GET THE DISPLAY NUMBER HE WANTS
	BGE CCPRD4	;HE KNOWS WHICH HE WANTS
	BPT		;HERE GET THE ONE NEAR HIS TTY
CCPRD4:	TSTB TKDOWN(C)	;IS THAT DISPLAY FREE?
	BNE CCPRD5	;NOPE, YOU LOSE
	MOVB #1,TKDOWN(C)	;USED NOW!
	JSR PC,TKDSTP	;MAKE SURE IT IS STOPPED
	BIS #100000,C	;OWNED, BUT DON'T START IT YET
	MOV C,TKDRUN(B)	;IT BELONGS TO HIM
	MOV B,C		;INDEX TO TABLES IS FIRST MISC WORD
	MOV TKDITM(C),D	;THE ITEM FOR THE DISPLAY
	MOV ITMTAB(D),B	;GET THE ADDRESS IN 32 WORD BLOCKS
	SUB TKDPDA,B	;SUBTRACT START OF DISPLAY WORLD IN 32 WORD BLOCKS
	ASH #5,B
	JSR PC,GIVPSW	;RETURN THE OFFSET IN WORDS
	MOVB ITLNGT+ITMTAB(D),B	;LENGTH IN 32 WORDS
	INC B		;MINUSE ONE
	ASH #5,B	;MAKE IT WORDS
	JSR PC,GIVPSW	;RETRUN IT
	MOV D,B		;SO THE ITEM GETS SAVED
	MOV #.DSCAP,A	;AND THE TYPE
	RTS PC
TKDSP:	MOV 6(A),D	;THE DISPLAY INDEX
	BIS #100000,TKDRUN(D)	;SO INT LEVEL WON'T START IT
	MOV TKDRUN(D),C	;THE DISPLAY NUMBER
TKDSTP:	SAVE <C>
	BIC #177400,C	;JUST THE DISPLAY
	BIS #TKSTOP,C
	MOV C,NGCSR
	REST <C>
	RTS PC
.ENDC
.IFNZ NTVS
CCPRD7:	MOVB E,C	;NUMER OF THE DISPLAY HE WANTS
	CMPB C,#NFTVDS+NTVS	;THERE ARE ONLY THIS MANY DISPLAYS
	BGE CCPR12	;TOO HIGH! FAIL.
	SUB #NFTVDS,C	;CONVERT TO PHYSICAL TV NUMBER FOR INDEX TO TABLES
	BLT CCPR12	;TOO LOW! FAIL
	BR CCPRD9
CCPRD8:	BIT #40000,E	;DOE SHE WANT A TV?
	BEQ CCPR12	;NOPE, LOSE
	SUB #NFTV,C	;GET THE PHYSICAL NUMBER OF THE KEYBOARD
	ASR C		;THIS WILL BE THE SAME AS THE NUMBER OF THE TV
CCPRD9:	MOVB TVDSBF(C),D;DOES THIS TV ALREADY HAVE A BUFFER?
	BGE CCPR11	;YES, IT MUST ALREADY HAVE A TV BUFFER
	MOV #NTVCHN,B	;THE NUMBER OF TV CHANNELS OR BUFFERS
	CLR D		;OFFSET INTO THE TVBUFF TABLE
CCPR10:	TSTB TVBUFF(D)	;IS THIS BUFFER FREE?
	BLT CCPR11	;YES (-1 MEANS FREE)
	INC D		;TRY THE NEXT BUFFER
	SOB B,CCPR10	;ANY MORE BUFFERS LEFT?
	BR CCPR12	;NO, NO BUFFERS AVAILABLE SO FAIL
CCPR11:	MOVB D,TVDSBF(C);ALLOCATE THIS BUFFER (D) TO THIS TV (C)
	MOVB C,TVBUFF(D);SAY THAT THIS BUFFER IS ALLOCATED
	INCB TVDSRF(C)	;ONE MORE PERSON IS REFERENCING THIS TV
	ASL C		;HO HUM
	MOV TVMAP(C),B	;GET THE CHANNEL NUMBER OF THIS TV
	ASR C
	SWAB B		;IT GOES IN THE HIGH BYTE
	BISB TVDSBF(C),B ;SET IN THE BUFFER NUMBER FOR THIS TV
	MOV B,VIDSW	;SWITCH THE TV TO BUFFER ON VIDEO SWITCH
	CLR B		;FOR NOW, THE ADDRESS OF A TV BUFFER IS IRRELEVENT
	JSR PC,GIVPSW	;RETURN A ZERO, JUST FOR COMPATABILITY
	MOV #100000,B	;A TV BUFFER HAPPENS TO BE 16K WORDS LONG
	JSR PC,GIVPSW	;MIGHT AS WELL GIVE IT TO HIM ANYWAY
	ADD #NFTVDS,C	;FIRST RANDOM WORD IN CAP IS LOGICAL DISPLAY NUMBER
	ASL C		;IT SHOULD BE A WORD INDEX INTO TABLES
	CLR B		;RETURN THE FACT THAT THERE IS NO ITEM FOR TV DISPLAY
	MOV #.DSCAP,A	;THIS WILL BE A DISPLAY CAPABILITY
	RTS PC		;NOTE THAT THE PREVIOUS INST. CAUSED Z CLEARED
CCPR12:	SEZ		;FAIL
	RTS PC
.ENDC
	.STITL PROCESS CAPABILITY ROUTINES
;INVOKE A PROCESS CAPABILITY, FUNCTION 0-7 IS USER'S REGISTERS
;10 IS USERS PS, 11-16 IS USERS FPP REGISTERS 17 IS FLOATING POINT STATUS
;40 BIT CLEAR MEANS READ (CURRENT VALUE PUSHED ON USERS STACK)
;40 BIT SET MEANS WRITE (2ND DATA WORD IS PLACED IN USERS REGISTER)
;A FUNCTION OF 20 ALLOWS READ/WRITE OF THE AVAILABILITY OF FPP
;IF READ, THE WORD RETURNED IS EITHER 1 (FLOATING POINT ENABLED) OR
;0 (NO FLOATING POINT).  IF WRITE, THE SECOND WORD ON THE STACK MUST BE 
;EITHER 1 OR 0.  A FUNCTION OF 21 ALLOWS WRITE AND READ OF THE SUPERIOR STOP BIT.
;IF WRITE, 0 MEANS START THE PROCESS, 1 MEANS STOP IT.  READ, NON ZERO MEANS STOPPED
;FUNCTIONS 23-25 MEAN READ AND WRITE THE FAULT WORDS 1-3
;FUNCTION 24 READS AND WRITES THE ERROR WORD
CAPRPR:	REST C		;GET THE FUNCTION BYTE
	ASH #-7,C	;TURN IT INTO A WORD INDEX
	BIC #177001,C	;CLEAR EXTRA BITS
	MOV C,D		;COPY IT
	ASR D		;SHIFT IT BACK DOWN
	BIC #.PRWRT*2,C	;CLEAR THE READ/WRITE BIT
	BIT #.PRWRT,D	;IS HE WRITING
	BEQ CPRPR1	;NOPE
	BIT #.PRWRA,(A)	;DOES HE HAVE WRITE ACCESS?
	BNE CPRPR1	;YES
CPRPR2:	ADD #4,P
	JMP BADEMT	;BARF
CPRPR1:	CMP C,#PRHGH	;IS IT TO HIGH
	BGE CPRPR2	;YES
	MOV 2(A),A	;ITEM OF THE PROCESS
	JSR PC,ITM2LD	;LOAD IT UP
	JMP @PRIVTB(C)	;DO THE FUNCTION

PRREG:	ADD C,A		;MAKE A POINT TO THE REG (WELL ALMOST)
	ADD #PUREGS,A	;POINT TO THE REGISTER IN DOUBT
PRRET:	BIT #.PRWRT,D	;READING?
	BNE REGWRT	;NOPE
	MOV (A),B	;GET THE APPROPRIATE REG INTO B
PRRET1:	JSR PC,GIVPSW	;GIVE IT TO HIM
	ADD #4,P	;GET RID OF TWO ARGUMENTS
	JMP ERETCZ	;WE WIN
REGWRT:	REST (A)	;SECOND ARG GOES INTO REGISTER	
PRRET0:	TST (P)+	;GET RID OF THIRD ARG
	JMP ERETCZ	;WE WIN
	;HERE IS PSW AND FLOATING REG READ

PRPSW:	ADD #PUPS,A	;POINT TO THE PSW
	MOVB 1(A),1(P)	;DONT LET HIM CHANGE MODE
	BIC #340,(P)	;OR PRIORITY
	BR PRRET	;RETURN IT OR WRITE IT

PRFREG:	MOV (P),E	;GET POINTER TO DATA
	MFPD (E)+	;MAKE SURE WE CAN GIVE IT TO HIM
	MFPD (E)+
	MFPD (E)+
	MFPD (E)+
	ADD #10,P	;POP OFF THE STUFF
	REST E		;POINTER TO DATA IS 2ND ARG
	SUB #2*.PRFREG,C	;MAKE THIS AN INDEX TO A FLOATING REG
	ASH #2,C	;EACH REGISTER IS 4 WORDS
	BIT #PFPFLG,PFLAGS(A)	;DOES HE HAVE THE FPP ENABLED?
	BEQ PRFLT3	;NOPE
	BIT #.PRWRT,D	;IS HE WRITING INTO THIS REG?
	BNE PRWRT	;YEP
	ADD C,A		;MAKE THE A POINT TO A FLOATING REG(ALMOST)
	ADD #PFPPRG+10,A	;MAKE IT ABSOLUTELY POINT TO THE APPROPRIATE REG
	SAVE <-(A),-(A),-(A),-(A)>	;SAVE THE FPP REGISTER
	MTPD (E)+	;GIVE HIM THE REGISTER IF YOU CAN
	MTPD (E)+
	MTPD (E)+
	MTPD (E)+
PRFLT2:	TST (P)+	;THIRD ARG NOT USED
	JMP ERETCZ
PRFLT4:	TST (P)+
PRFLT3:	REST A		;POP OFF 3RD ARG
	JMP ERETSZ
PRWRT:	MFPD (E)+	;GET THE REGISTER (IF WE CAN)
	MFPD (E)+
	MFPD (E)+
	MFPD (E)+
	ADD C,A		;MAKE THE A POINT TO A FLOATING REG(ALMOST)
	ADD #PFPPRG+10,A	;MAKE IT ABSOLUTELY POINT TO THE APPROPRIATE REG
	REST <-(A),-(A),-(A),-(A)>	;PUT THE REGISTER AWAY
	BR PRFLT2	;RETURN

PRFPST:	BIT #PFPFLG,PFLAGS(A)	;DOES IT USE THE FPP
	BEQ PRFLT4	;NO LUSER
	ADD #PFPPS,A	;POINT TO THE REGISTER
	BIT #.PRWRT,D	;IS IT A WRITE
	LBR ,PRRET	;TRANFER THE PROCESSOR STATUS

PRFPEN:	BIT #.PRWRT,D	;IS HE WRITING
	BNE FPPWRT	;YEP
	CLR B		;ASSUME THAT THERE ISNT ANY FPP
	BIT #PFPFLG,PFLAGS(A)	;DOES HE HAVE FPP
	BEQ .+4		;NOTHING HERE
	INC B		;SAY HE HAS FPP
	JMP PRRET1	;RETURN 1 ARG

FPPWRT:	MOV ITEM2,B	;WE WANT THE ITEM TO DO IT TO
	REST E		;GET THE FIRST ARG
	CMP E,#1	;IS IT A LEGAL ARG
	BHI PRLOSE	;ITS TOO BIG
	BEQ PWRT1	;ITS A REQUEST FOR FPP
	BIT #PFPFLG,PFLAGS(A)	;DOES HE ALREADY HAVE IT
	BEQ PWRT2	;NO, WHY BOTHER
	MOV ITEM2,B	;THE ITEM INDEX OF WHAT TO SHRINK
	MOV #PRSLNF,A	;TELL IT THE SIZE WE WANT
	JSR PC,EXITEM	;SHRINK THIS ITEM
	MOV ITEM2,A	;GET BACK THE ITEM
	JSR PC,ITM2LD	;LOAD IT BACK UP IN ITS NEW FORM
	BIC #PFPFLG,PFLAGS(A)	;SAY HE DOESN'T HAVE FPP
	JMP PRRET0	;RETURN SUCESSFUL
PWRT1:	BIT #PFPFLG,PFLAGS(A)	;DOES HE ALREADY HAVE IT
	BNE PWRT2	;YES
	MOV #PRSLFP,A	;THE LENGTH WE WANT IT TO BE
	JSR PC,EXITEM	;EXPAND THE PROCESS
	BEQ PRLOSE	;IT FAILED
	MOV ITEM2,A	;THE NEW ITEM
	JSR PC,ITM2LD	;LOAD IT UP
	BIS #PFPFLG,PFLAGS(A)	;SAY WE HAVE FPP
	MOV #40300,PFPPS(A)	;START WITH INT. DISABLED AND LONG AND DOUBLE
PWRT2:	JMP PRRET0	;RETURN NO ARG
PRLOSE:	TST (P)+	;POP OFF THIRD ARG
	JMP ERETSZ

PRSTOP:	ADD #PSTOP,A	;POINT TO THE STOP WORD
	BIT #.PRWRT,D	;IS IT A WRITE
	BNE PRSTP1	;YES
	MOV (A),B	;GET THE STOP WORD
	JMP PRRET1	;RETURN IT TO HIM
PRSTP1:	CMP (P),#1	;IS IT A ONE
	BHI PRLOSE	;FAIL
	BEQ PRSTP2	;STOP IT	
	BIT #PSUPSB,(A)	;IS HE STOPPED BY A CAPABILITY
	BEQ PRSTP3	;NO, JUST RETURN
	BIC #PSUPSB,(A)	;CLEAR THE BIT
	MOV ITEM2,A	;THE PROCESS
	JSR PC,ITM0PL	;LOAD IT UP
	JSR PC,PSTPDC	;DECREMENT THE STOP COUNT
	JSR PC,ITM0PO	;POP IT
PRSTP3:	TST (P)+	;POP OFF THE ARG
	JMP PRRET0	;DONE
PRSTP2:	BIT #PSUPSB,(A)	;HAS SOMEONE ELSE ALREADY STOPPED IT
	BNE PRSTP3	;SOMEONE BEAT US TO IT.
	BIS #PSUPSB,(A)	;SET THE STOP BIT
	MOV ITEM2,A	;THE PROCESS TO STOP
	JSR PC,PSTPIN	;STOP IT
	ADD #4,P	;POP ARGS
	JMP ERETCZ

PRFAUL:	SUB #.PRFAUL*2,C	;CREATE AN OFFSET
	ADD C,A		;POINT TO IT
	ADD #PFAULT,A	;GET THE FIRST FAULT WORD
	BIT #.PRWRT,D	;IS IT A WRITE REQUEST
	BNE PRFAUW	;WRITE REQUEST
	MOV (A),B	;GET THE FAULT WORD
	JMP PRRET1	;RETURN IT
PRFAUW:	TST (P)		;WRITING A ZERO?
	BEQ PFAUW1	;YES
PFAUW2:	JMP PRRET	;CAUSE THE WRITE
PFAUW1:	TST (A)		;IS IT FAULTED ALREADY
	BEQ PFAUW2	;NO
	MOV PSPHRP-PFAULT(A),B	;POINTER TO THE SPHERE
	JSR PC,FALTFX	;FIX THE FAULT
	JMP REGWRT

PRERR:	ADD #PERRW,A
	BR PFAUW2	;DO THE READ/WRITE

CAPRTR:	CAPRTP:	JMP EIVOK1

CPYXX:	BPT		;ZERO CAPABILITY
CPYCL:	MOV #.CLCONS,E	;CLEAR THE CONSUMER FLAG ON COPY
	MOV 2(F),A	;POINTER TO CORE LNK
	JSR PC,ITM2LD	;LOAD IT UP
	BR CPYFA1	;INCREMENT THE REFERENCE COUNT
CPYTR:
CPYTP:
CPYQU:	CLR E		;NO FLAGS TO CLEAR
	BR CPYFA1	;INCREMENT THE REFERENCE COUNT
;COPY PROCESS CAPABILITY, 2ND ARG SPECIFIES A MASK OF BITS TO
;BE CLEARED, NO BITS MAY BE SET.
CPYPR:	BIC #377,E	;MAKE SURE YOU ONLY TOUCH THE TOP BYTE
	BR CPYFA1	;CREATE THE SPERE CAP.

CPYFA:	BIS #<-.FARD-.FAWT-.FAAP-.FAAC>-177400,E
	CLRB E
	MOV FAMFI(F),A
	MOV A,B		;SUPERIOR ROUTINE WANTS THIS
	JSR PC,ITM2LD
	CMP ITEM1,MFLKSP(A)
	BNE .+6
	INCB 1(A)
	INC MFPREF(A)
CPYFA1:	JSR PC,SPRINC
	MOV (F),A	;THE FLAG WORD
	BIC E,A
	RTS PC

CPYCC:	CLR B
	MOV #.CCCAP,A	;SAY ITS A CREATE CAPABLITY
	RTS PC

;COPY TTY CAPABILITY, SAME AS COPY SPHERE
CPYTT:
;COPY SPHERE CAPABILITY, ARGS SAME AS PROCESS CALL
CPYSP:	MOV (F),A
	BR CPYMS1

;COPY A MASTER SPHERE CAPABILITY, BECOMES A SPHERE CAP. 2ND ARG
;SPECIFIES A MASK OF BITS TO BE CLEARED DURING THE COPY

CPYMS:	MOV #MSPCBT!.SPCAP,A
	TST 4(F)	;IS THIS THE FIRST COPY OF A MASTER SPHERE?
	BNE CPYMS1	;NOPE
	MOV D,10(F)	;MAKE THE MASTER SPHERE POINT TO ITSELF TEMPORARILY
	MOV ITEM1,4(F)	;SET IN THE ITEM NO.
CPYMS1:	MOV 2(F),B	;THE ITEM NO.
	JSR PC,SPRINC	;INCREMENT SPERE'S REFERENCE COUNTER
	BIC #377,E	;ONLY THE TOP BYTE IS SIGNIFICANT
	BIC E,A		;CLEAR THE CORRECT BITS
	MOV 2(P),E	;POINTER TO CAP DESTINATION
	MOV 2(F),B	;THE ITEM NO. OF SPHERE OF MS CAP
	MOV 4(F),4(E)	;POINTER TO NEXT SPHERE CAP
	MOV 10(F),10(E)	;REST OF POINTER TO NEXT CIRCULAR LIST ENTRY
	MOV ITEM1,4(F)	;THE FIRST SPHERE ON CIRCLE LIST IS THIS SPHERE
	MOV 4(P),10(F)	;THE CAP. NO IS IN B
	RTS PC

;COPY OF DISPLAY CAPABILITY IS NOT ALLOWED
CPYDS:	SEZ
	RTS PC
	.STITL GIVE CAPABILIY ROUTINES
GIVXX:	BPT
GIVFA:	SAVE <A>
	MOV FAMFI(D),A
	JSR PC,ITM2LD
	CMP MFLKSP(A),ITEM1
	BNE .+6
	DECB 1(A)	;DECREMENT NUMBER OF LOCKING CAPABILITIES
	CMP MFLKSP(A),C
	BNE .+6
	INCB 1(A)	;INCREMENT NUMBER OF LOCKING CAPABILITIES
	TSTB 1(A)
	BNE .+6
	CLR MFLKSP(A)	;CLEAR THE LOCK
	REST <A>
	BR GIVPR	;FA CAP GIVE JUST COPIES IT
GIVSP:	SAVE <A,B,C,D>
		;A CONTAINS RELATIVE POINTER TO DEST. C-LIST ENTRY
		;B THE C-LIST NO. OF DEST
		;C THE SPHERE NO. OF DEST
	MOV E,B		;THE C-LIST NO. OF THE SOURCE C-LIST ENTRY
	MOV D,A	;THE POINTER TO THE SOURCE C-LIST ENTRY
	JSR PC,FNBKPT	;FIND THE PREVIOUS ENTRY IN CIRCULAR LIST
	MOV C,A		;THE PREVIOUS SPHERE
	MOV D,B		;THE PREVIOUS C-LIST NO
	JSR PC,ITM1PL	;LOAD IT UP
	JSR PC,GCLSTA	;FIND IT
	ADD A,B		;MAKE A POINT TO IT
	TST (B)		;IS IT HERE
	BUGC NE		;ITS THERE
	CMP (B),#-1
	BEQ .-6
	MOV 2(P),4(B)	;CORRECT SPHERE POINTER
	MOV 4(P),10(B)	;CORRECT C-LIST POINTER
	JSR PC,ITM1PO	;POP THE SPHERE
	REST <D,C,B,A>
		;FALL THROUGH AND TRANSFER THE CAPABILITY

		;MAY FALL THROUGH FROM GIVE SPHERE ROUTINE
GIVCC:			;CREATE CAP. GIV IS SAME AS PROCESS CAP. GIVE
GIVTP:
GIVTR:
GIVTT:
GIVQU:
GIVCL:
GIVPR:
GIVDS:	JSR PC,GIVPSW	;GIVE HIM THE WORD, (CAN'T FAIL FROM HERE ON IN)
	SAVE A		;SAVE THE POINTER TO THE CAP TO GIVE
	MOV C,A		;THE DESTINATION SPHERE
	JSR PC,ITM2PL	;LOAD IT UP
	ADD (P)+,A	;MAKE A POINT TO THE C-LIST ENTRY
	MOV D,B		;POINTER TO THE CAPABILITY TO GIVE
	MOV (B)+,(A)+	;MOV THE CAPABILITY
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	MOV (B)+,(A)+
	JSR PC,ITM2PO	;POP THE ITEM
	CLR (D)		;GET RID OF IT
	ADD #4,P	;POP OFF THE TWO ARGS
	JMP ERETCZ
GIVMS:	SAVE <A,D>
	MOV C,A		;THE SPHERE THAT WE ARE GIVING TO
	JSR PC,ITM2PL	;A BOGUS PUSH
	MOV 2(D),D	;THE SPHERE THAT THE MS REFERS TO
	MOV SMSSPT(A),A	;JUST CHECK THIS ONE'S SUPERIOR
GIVMS1:	CMP A,D		;IS THE SUPERIOR SPHERE, THE ONE THE MS REFERS TO
	BEQ GIVMS2	;YES, WE MUST FAIL
	CMP A,SYSSPR	;IS IT THE SYSTEM SPHERE
	BEQ GIVMS3	;YES, THEN GIVING IT AWAY IS FINE
	JSR PC,ITM2LD	;LOAD UP THE SUPERIOR SPHERE
	MOV SMSSPT(A),A	;GET THIS ONES SUPERIOR SPHERE
	BR GIVMS1	;GO BACK AND CHECK IT OUT
GIVMS2:	ADD #10,P	;POP OFF THE ARGS AND PUSHED REG.
	JSR PC,ITM2PO	;POP THE PUSHED SPHERE
	JMP ERETSZ	;FAILED (MAYBE SHOULD BE A FAULT)
GIVMS3:	MOV D,A		;THE SPHERE THE MS REFERS TO
	JSR PC,ITM2LD	;LOAD IT UP
	MOV C,SMSSPT(A)	;FIX ITS MASTER SPHERE POINTER
			;(HERE FIX USER POINTER ALSO?)
	JSR PC,ITM2PO	;POP THE SPHERE
	REST <D,A>	
	BR GIVSP	;NOW GIVE IT AWAY LIKE A SPHERE
	.STITL DELETE CAPABILITY ROUTINES
DELXX:
DELCC:	CLR (A)		;CLEAR THE FIRST WORD
	CLZ
	RTS PC
DELPR:	CLR (A)	;FLUSH THE CAPABILITY
	MOV 2(A),A	;GET THE ITEM INDEX
	JSR PC,PSTPIN	;STOP HIM FROM RUNNING
	SAVE A
	JSR PC,DLPROC	;DEC PROCESSES REF COUNT
	BEQ DELPR1	;WE DELETED THE PROCESS
	REST A		;GET THE PROCESS ITEM NO.
	JSR PC,ITM0PL	;LOAD IT UP
	JSR PC,PSTPDC	;DECREMENT HIS STOP COUNT
	JSR PC,ITM0PO	;POP THE PROCESS
	CLZ
	RTS PC
DELPR1:	REST A		;GET BACK ITEM INDEX
	CLZ
	RTS PC

DELSP:	SAVE A
	MOV E,B		;THE CAP. NO. TO FLUSH
	JSR PC,FNBKPT	;FIND THE PREVIOUS ENTRY
	MOV (P),A	;GET THE ADDRESS BACK
	MOV 4(A),E	;THIS SPHERE'S POINTER
	MOV 10(A),F	;THE REST OF THE POINTER
	MOV C,A		;THE PREVIOUS ENTRY'S SPHERE
	JSR PC,ITM1PL	;LOAD IT UP
	JSR PC,GCLSTA	;GET APOINTER TO IT
	ADD A,B		;MAKE THE POINTER ABSOLUTE
	TST B		;DOES IT EXIST
	BUGC NE		;YES
	MOV E,4(B)	;SPLICE OUT ENTRY WE ARE DELETING
	MOV F,10(B)
	JSR PC,ITM1PO	;POP THE SPHERE
	REST A

DELTP:	SAVE A		;SAVE POINTER TO CAP
	MOV 2(A),A	;THE ITEM
DELTP3:	JSR PC,ITM2PL	;LOAD IT UP
	CMP #1,PTPREF(A)	;IS THIS THE LAST ONE?
	BNE DELTR1	;NO, JUST DELETE IT
	TST PTRNO(A)	;ANY CHARACTERS LEFT TO PUNCH?
	BEQ DELTP4	;NO
DELTP1:	MOV ITEM2,A	;COPY ITEM NO.
	JSR PC,ITM2PO	;POP IT
	JSR PC,LFLUSH	;WAIT A LONG TIME
	JSR PC,ITM2PL	;LOAD IT
	CMP #1,PTPREF(A)	;ANOTHER CAP?
	BNE DELTP2	;YES
	TST PTRNO(A)	;CHARACTERS LEFT?
	BNE DELTP1	;YES
DELTP2:	MOV ITEM2,A
	JSR PC,ITM2PO	;CLEAN UP A BIT
	JSR PC,RUNME
	BR DELTP3	;CHECK TO MAKE SURE
DELTP4:	CLR PTPITM
	BR DELTR1
DELTR:	SAVE A		;SAVE POINTER TO CAP
	MOV 2(A),A	;GET THE TR ITEM
	JSR PC,ITM2PL	;LOAD IT UP
	CMP #1,PTRREF(A)	;REF COUNT 1
	BNE .+6		;NO
	CLR PTRITM	;NO MORE PTR
DELTR1:	JSR PC,ITM2PO	;POP IT
	REST A		;GET BACK A AND DROP IN TO DELETE IT

;DELETE QUE CAPABILITY, JUST DEC REFERENCE COUNT, AND FLUSH CAP.
DELQU:	CLR (A)		;FLUSH THE CAPABLITY
	MOV 2(A),A	;THE ITEM INDEX OF THE SPRERE
	JSR PC,SPRDEC	;DECREMENT SPHERE REF COUNT
	CLZ
	RTS PC

;DELETE CORE LINK JUST FLUSH IT AND CHECK REFERENCE COUNT
DELCL:	BIT #.CLCONS,(A)	;AM I THE CONSUMER
	BEQ DELQU		;YES
	SAVE A
	MOV 2(A),A		;THE ITEM OR GIP
	JSR PC,ITM2PL
	CLR CLCONP(A)		;SAY THERE IS NO MORE CONSUMER
	JSR PC,ITM2PO
	REST A
	BR DELQU

;DELETE TTY CAP, WAIT FOR END OF TRANSMISSION IF LAST CAPABILITY,
;THEN FLUSH ITEM AND CAPABILITY
DELTT:	MOV A,F			;COPY THE TTY CAPABILITY POINTER
	MOV 2(A),A		;GET THE TTY ITEM NO.
	JSR PC,ITM2LD		;LOAD IT UP
DELTT1:	CMP TTYREF(A),#1	;AM I THE LAST
	BGT DELTT6		;NO
	SPL 7			;STOP TTY, AND CLOCK
	BIT #TOTRAN,TTYST1(A)	;IS HE TRANSMITTING
	BEQ DELTT4		;NO
DELTT2:	SPL 0			;RESTORE LOW PRIORITY
	JSR PC,LFLUSH		;LONG, LONG FLUSH
	CMP TTYREF(A),#1	;CHECK IF SOMEONE ELSE COPIED THIS ONE
	BGT DELTT3		;YES, DONE?
	SPL 7
	BIT #TOTRAN,TTYST1(A)	;TRANSMITTING
	BNE DELTT2		;YES
DELTT3:	SPL 0
	JSR PC,RUNME		;TRY ME AGAIN
	BR DELTT1		;JUST TO MAKE SURE
DELTT4:	SPL 7			;UNINTERRUPTABLE
	MOV TTLTTY(A),E		;THE LOGICAL TTY NO.
	CLR TTYITM(E)		;CLEAR THE ITEM NO.
.IFNZ NTVS
	BIT #TVF,TTYTBL(E)	;IS THIS A TV
	BEQ DELTT7		;NO
	TST TVBUF(A)		;THE BUFFER NUMBER OF THIS TV
	BLT DELTT7		;NO BUFFER ASSIGNED TO THIS TV
	MOV E,B			;THE LOGICAL TTY NUMBER
	SUB #NFTV,B		;GET THE PHYSICAL NUMBER OF THIS TV
	ASR B			;THIS IS A BYTE OFFSET
	JSR PC,DELTV		;DECREMENT THE REFERENCE COUNT FOR THIS TV
	CLR TVSTAT(E)		;TURN OFF BLINK AND INTERRUPT BITS
DELTT7:
.ENDC
	SPL 0			;CANT BE BOTHERER ANY MORE
	MOV ITEM2,A		;DELETE THE TTY ITEM
	JSR PC,DLITEM		;DELETE IT
DELTT5:	CLR (F)			;FLUSH THE CAPABILITY
	CLZ
	RTS PC
DELTT6:	DEC TTYREF(A)		;SAY ONE LESS CAPABILITY
	BR DELTT5		;FLUSH IT	

	
DELFA:	MOV A,D
	JSR PC,MFIDEL		;DECREMENT REFERENCE COUNT
	BEQ DLFA.2		;FAILED
	BCS DLFA.1		;THE MFI IS GONE
	MOV FAMFI(D),A		;CORRECT THE LOCK COUNT ON THIS MFI
	JSR PC,ITM2LD		;LOAD THE MFI AND CLEAR THE LOCK BIT
	CMP ITEM1,MFLKSP(A)
	BNE DLFA.1
	DECB 1(A)
	BNE DLFA.1
	CLR MFLKSP(A)
DLFA.1:	CLR (D)
	CLZ
	RTS PC
DLFA.2:	BPT			;CAN'T CLOSE THIS FILE

;DELETE DISPLAY CAP
DELDS:	.IFZ NTKDIS+NTVS
	BPT		;CAN'T EXIST!
.IFF
	MOV CLSEM0(A),B	;GET THE TABLE INDEX
.ENDC
.IFNZ NTVS
	CMP B,#NFTVDS*2	;IS IT A TV DISPLAY?
	BGE DELDS1	;YES
.ENDC
.IFZ NTKDIS
	BPT		;THERE SHOULDN'T BE ANY TK DISPLAYS
.IFF	
	MOV TKDRUN(B),C
	MOV #-1,TKDRUN(B)	;RETURN THE DISPLAY
	JSR PC,TKDSTP	;STOP THE DISPLAY
	BIC #177770,C
	CLRB TKDOWN(C)
	CLR (A)		;FLUSH THE ACTUAL CAPABILITY
	CLZ
	RTS PC
.ENDC
.IFNZ NTVS
DELDS1:	ASR B		;CONVERT TO BYTE INDEX
	SUB #NFTVDS,B	;CONVERT TO PHYSICAL TV NUMBER
	JSR PC,DELTV	;IF REFCOUNT IS ZERO, THEN RELEASE THE BUFFER
	BEQ DELDS2	;IN CASE TVDEL LOSES FOR SOME REASON
	CLR (A)
	CLZ		;SUCCEED
	RTS PC
DELDS2:	SEZ		;FAIL
	RTS PC

;DELTV DECREMENTS THE REFERENCE COUNT OF A TV AND RELEASES THE BUFFER
;OF THAT TV WHEN THE REF COUNT REACHES ZERO. IT EXPECTS THE PHYSICAL
;TV NUMBER IN B
DELTV:	SAVE A
	TST B
	BLT DELTV2	;THERE ARE NO NEGATIVE TV'S
	CMP B,#NTVS	;IS THIS ONE A LEGAL TV
	BGE DELTV2	;NO
	DECB TVDSRF(B)	;DECREMENT THE REFERENCE COUNT
	BGT DELTV1	;IF NOT ZERO, THEN WE'RE DONE
	MOVB TVDSBF(B),A ;GET THE BUFFER NUMBER OF THE TV
	BLT DELTV2	;THIS SHOULD NOT BE NEGATIVE
	CMP A,#NTVCHN	;IS THIS WITHIN THE TABLE?
	BGE DELTV2	;NO, FAIL
	SAVE B
	ASL B		;CONVERT TO WORD INDEX
	MOV TVMAP(B),B	;GET THE RIGHT CONSOLE 
	BIS #17*400,B	;THE SOURCE IS THE BLANK CHANNEL
	MOV B,VIDSW	;CONNECT THIS CONSOLE TO THE BLANK CHANNEL
	REST B
	MOVB #-1,TVDSBF(B)	;SAY THAT THIS TV HAS NO BUFFER
	MOVB #-1,TVBUFF(A)	;SAY THAT THIS BUFFER HAS NO TV
DELTV1:	REST A
	CLZ
	RTS PC
DELTV2:	REST A
	SEZ
	RTS PC
.ENDC

DELMS:	SAVE A		;SAVE POINTER TO CAP FOR END OF ROUTINE
	CLR -(P)
	MOV A,F		;FOR SPCPDL
	JSR PC,SPCPDL
	MOV 2(F),A	;THE ITEM OF THIS SPHERE
	JSR PC,ITM1PL	;PUSH ONCE ONLY!
	MOV ITEM1,A
DELMS2:	JSR PC,ITM1LD	;LOAD IT UP
	SUB D,SPHREF(A)	;FLUSH THE REFERENCES WE FLUSHED
	CMP #1,SPHREF(A)	;WE SHOULD BE THE ONLY ONE LEFT
	BUGC EQ		;BUG IF NOT ZERO
	MOV #-1,E	;FLAG TO STOP ALL PROCESSES
	JSR PC,STPMS	;STOP!!!
DELMS9:	CLR D		;POINTER INTO C-LIST
	JSR PC,GNMSCP	;GET THE NEXT MSCAP
	BEQ DELMS1	;NONE, CAN FLUSH SPHERE AT THIS LEVEL NOW
	INC (P)		;ONE MORE SPHERE DOWN
	MOV 2(B),A	;POINTER TO THE ITEM
	MOV B,F		;FOR THE CALL TO SPCPDL
	MOV D,E		;THE CAP NUMBER
	JSR PC,SPCPDL	;DELETE THE CIRC LIST
	BR DELMS2	;GO LOAD IT UP AND LOOK FOR MSCAPS IN IT
DELMS1:	MOV #-1,A	;NEED TO PUSH THE ITEM TO USE IT
	JSR PC,ITM0PL
DELMS3:	MOV ITM1A,A	;ADDRESS OF SPHERE
	MOV SPHPRP(A),A	;GET POINTER TO FIRST PROCESS
	BEQ DELMS4	;NONE LEFT
	JSR PC,ITM0LD	;LOAD IT UP
	JSR PC,REMPRS	;REMOVE IT FROM THE SPHERE
	BR DELMS3	;GET THEM ALL!
DELMS4:	JSR PC,ITM0PO
	CLR D		;C-LIST ENTRY COUNTER
	MOV ITM1A,A
DELMS5:	JSR PC,GNCLST	;GET THE NEXT REAL ONE
	BEQ DELMS6		;NO MORE
	JSR F,ACSAV	;SAVE THE AC'S
	SAVE ITEM1	;SAVE THE ITEM NO
	ADD #CLSELN,B	;POINT PAST IT
	SAVE <-(B),-(B),-(B),-(B),-(B)>	;SAVE THE CAPABILITY
	MOV P,A		;POINT TO IT
	JSR PC,ITM1PO	;POP IT IN CASE WE GET STOPPED
	MOV (A),B	;FIRST WORD OF CAP
	ASL B		;TURN IT INTO A WORD INDEX
	BIC #177001,B	;CLEAR THE EXTRA BITS
	JSR PC,@DELTAB(B)	;DELETE THE CAPABILITY
	BUGC NE		;SUCCEEDED
	ADD #CLSELN,P	;POP OFF STUFF
	REST A		;THE ITEM NO.
	JSR PC,ITM1PL	;LOAD IT BACK UP
	JSR F,ACRES	;RESTORE THE AC'S
	CLR (B)		;MAKE IT NXM
	INC D
	BR DELMS5
DELMS6:	MOV ITEM1,C	;THE ITEM THE GIP WILL BE IN
	JSR F,ACSAV
	CLR B		;THE PAGE WE WANT
	JSR PC,ITM1PO
DELMS7:	SAVE <C,B>
	JSR PC,SUPTDL	;FLUSH THAT ONE
	REST <B,C>
	INC B		;NEXT ONE
	CMP #20,B	;GOT TO THE LAST ONE YET?
	BNE DELMS7	;NOPE
	JSR F,ACRES
	MOV C,A		;THE SPHERE WE HAVE NOW FLUSHED
	JSR PC,ITM1PL	;LOAD IT UP FOR A SEC
	MOV SMSSPT(A),F	;GET THE SUPERIOR SPHERE INDEX
	MOV SPRTPT(A),A	;POINTER TO THE PROCESS BLOCK FOR THE SPHER
	MOV #PFREEQ,B	;MOVE IT TO THE FREE QUQUE
	JSR PC,TQUEUE
	JSR PC,ITM1PO	;OK, NOW TO FLUSH THIS SPHERE!
	MOV C,A		;THE ITEM NUM
	JSR PC,DLITEM	;GONE!!!
	MOV F,A		;NOW LOAD THE SUPERIOR
	JSR PC,ITM1PL
	DEC (P)		;AT TOP LEVEL?
	BLT DELMS8	;YES, GO FINISH UP
	CLR D		;GET THE FIRST MSCAP IN THE SUPERIOR
	JSR PC,GNMSCP
	CLR (B)		;FLUSH CAP TO SPHERE WE JUST FLUSHED
	BR DELMS9	;GO FIND ANY OTHER MSCAPS
DELMS8:	JSR PC,ITM1PO
	REST <B,B>	;FLUSH COUNT, GET POINTER TO CAP
	CLR (B)		;FLUSHED!
	CLZ
	RTS PC
;THIS ROUTINE TAKES POINTER TO CAPABILITY IN F, THE MSCAP NO. IN E
;IT DELETES THE CIRCULAR LIST ASSOCIATED WITH IT.
SPCPDL:	SAVE A
	CLR D
	MOV ITEM1,A	;MAKE A BOGUS PUSH
	JSR PC,ITM2PL
	TST 4(F)	;IS THERE A CIRCULAR LIST
	BEQ SPCPDN	;NO
	MOV F,A		;RESTORE POINTER TO CAPABILITY
	BR SPCPD3	;A ALREADY POINT TO THE CAPABILITY AND DON'T WANT MSCAP TO GO AWAY
SPCPD4:	CMP ITEM2,ITEM1	;IS THIS THE SAME SPHERE AS WE STARTED WITH
	BEQ SPCPD2	;YES, DON'T BOTHER TO TEST THE C-LIST LOCK (WE ALREADY LOCKED IT)
	TST SCLSLK(A)	;IS THE C-LIST LOCKED?
	BLE SPCPD2	;NO, JUST DELETE IT
	MOV SCLSLK(A),A	;THE PROCESS THAT LOCKED IT
	JSR PC,PRSPCL	;STOP HIM, (I WANT THAT C-LIST BAD)
	JSR PC,ITM0PL	;LOAD IT UP FOR PSTPDC
	JSR PC,ITM0PO	;POP THE PROCESS
	MOV ITM2A,A	;GET THE ADDRESS BACK
	TST SCLSLK(A)	;IT HAD BETTER BE 0
	BUGC EQ		;IT IS
SPCPD2:	ADD B,A		;MAKE A POINT TO THE SPHERE CAPABILITY
	CLR (A)		;MAKE THIS CAPABILITY GO AWAY
	INC D		;KEEP COUNT OF FLUSHED CAPS
SPCPD3:	MOV 10(A),B	;THE C-LIST NO. OF NEXT CAP.	
	MOV 4(A),A	;GET THE SPHERE POINTER TO THE NEXT CAPABILITY
	BUGC NE		;GOT IT
	CMP A,ITEM1	;IS THIS THE SAME SPHERE
	BNE SPCPD1	;NO
	CMP B,E		;SAME AS THE MSCAP?
	BEQ SPCPDN	;YES, WE ARE DONE
SPCPD1:	CMP A,ITEM1	;IS THIS THE CURRENT SPHERE
	BEQ SPCPD5	;YES, DON'T STOP IT
	MOV A,C		;SAVE FOR SPRSTP
	JSR PC,SPRSTP	;STOP THE SPHERE
	JSR PC,SPRSTR	;START IT
	MOV C,A		;RESTORE THE SPHERE NO.
SPCPD5:	JSR PC,ITM2LD	;LOAD THE NEXT SPHERE
	MOV ITM2A,A	;GET THE ADDRESS
	JSR PC,GCLSTA	;GET POINTER TO NEXT CAP
	BNE SPCPD4	;GO BACK AND TRY AGAIN
	BPT		;ERF, SOMETHING IS SCREWED
SPCPDN:	JSR PC,ITM2PO	;POP THE ITEM PUSHED
	CLR 4(F)	;MAKE SURE THERE IS NO CIRCULAR LIST
	CLR 10(F)	;DITTO
	REST A
	RTS PC
	.STITL TAKE CAPABILITY ROUTINES
TAKXX:	BPT	;THE ZERO CAPABILITY
TAKFA:	SAVE <A>
	MOV FAMFI(D),A
	JSR PC,ITM2LD
	CMP MFLKSP(A),C
	BNE .+6
	DECB 1(A)	;DECREMENT NUMBER OF LOCKING CAPABILITIES
	CMP MFLKSP(A),ITEM1
	BNE .+6
	INCB 1(A)	;INCREMENT NUMBER OF LOCKING CAPABILITIES
	TSTB 1(A)
	BNE .+6
	CLR MFLKSP(A)	;CLEAR THE LOCK
	REST <A>
	BR TAKCC

TAKSP:	SAVE <A,B,C,D>
	MOV C,A		;THE SPHERE OF THE TAKEE
	SAVE ITEM1	;CURRENT SPHERE NO.
	JSR PC,ITM1PL	;LOAD IT UP
	ADD D,A		;MAKE A POINT TO THE CAP
	MOV E,B		;B IS THE C-LIST NO.
	JSR PC,FNBKPT	;GET BACK POINTER
	MOV C,A		;THE PREVIOUS SPHERE
	MOV D,B		;THE PREVIOUS C-LIST NO.
	JSR PC,ITM1LD	;LOAD IT UP
	JSR PC,GCLSTA	;GET THE CAPABILITY
	ADD A,B		;MAKE A POINT TO THE CAP.
	TST (B)		;IS IT THERE
	BUGC NE		;YEP
	REST 4(B)	;THE CURRENT SPHERE IS WHERE THIS SHOULD POINT
	MOV 4(P),10(B)	;SET THE C-LIST NO. ALSO
	JSR PC,ITM1PO	;POP THE ITEM STACK
	REST <D,C,B,A>
TAKTP:	TAKTR:	TAKTT:	TAKPR:	TAKCL:	TAKQU:	TAKDS:	;THESE JUST TRANSFER CAPABILITY
TAKCC:	JSR PC,GIVPSW	;GIVE THE USER THE C-LIST NO. OF DEST
	SAVE A		;SAVE POINTER TO WHERE THE CAP. IS GOING
	MOV C,A		;THE SPHERE TO TAKE FROM
	JSR PC,ITM2PL	;LOAD IT UP
	ADD D,A		;MAKE THE POINTER ABSOLUTE
	REST B		;POINTER TO DESTINATION
	SAVE A
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	CLR @(P)+	;FLUSH THE CAPABILITY
	JSR PC,ITM2PO
	ADD #4,P	;POP THE TWO ARGS
	JMP ERETCZ
;THIS ROUTINE MAKES SURE THAT THE SPHERE STRUCTURE ALWAYS POINTS DOWN
TAKMS:	SAVE <A,B,C>
	SAVE ITEM1	;THE SPHERE OF TAKER
	MOV C,A		;THE SPHERE OF TAKEE
	JSR PC, ITM1PL	;LOAD IT UP
	ADD D,A		;MAKE A POINT TO THE CAPABILITY TO BE TAKEN
	MOV 2(A),C	;THE SPHERE THAT THE MASTER SPHERE CAP. REFFERS TO
	REST A		;GET THE TAKER'S SPHERE NO.
	CMP C,A		;IS TAKING HIS OWN MASTER SPHERE CAPATILITY
	BEQ TAKMS1	;YES, DONT LET HIM
	CMP C,SYSSPR	;IS HE TAKING THE SYSTEM SPHERE'S MASTER CAP. TO ITSELF
	BEQ TAKMS1	;YES DONT ALLOW HIM TO
TAKMS2:	JSR PC,ITM1LD	;LOAD UP THE SPHERE
	MOV SMSSPT(A),A	;GET THIS SPHERES MASTER SPHERES NO
	CMP A,SYSSPR	;ARE WE AT THE ROOT OF THE SPHERE TREE
	BEQ TAKMS3	;YES
	CMP C,A		;IS IT A SUPERIOR OF THE TAKER
	BNE TAKMS2	;NOPE, GET THE NEXT SUPERIOR
TAKMS1:	JSR PC,ITM1PO
	ADD #12,P	;GET RID OF ALL THE GARBAGE
	JMP ERETSZ	;TELL HIM HE CAN'T TAKE THIS ONE
TAKMS3:	JSR PC,ITM1PO	;POP THE SPHERE
	JSR PC,SPRSTP	;STOP THE SPHERE THAT THE MS CAP. REFERS TO
	MOV C,B		;THE SPHERE THAT WE STOPPED
	MOV #LCKRTN,A	;RUN A ROUTINE WHEN UNLOCKED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCSPST,LCKWD1(A)	;START THE SPHERE WHEN IT IS NULOCKED
	MOV ITEM0,B	;SAY WE LOCKED THE C-LIST
	MOV #SCLSLK,A	;LOCK ITS C-LIST
	JSR PC,LCKASW	;LOCK IT IF YOU CAN
	MOV C,A		;THE SPHERE NO.
	JSR PC,ITM2PL	;LOAD IT
	MOV ITEM1,SMSSPT(A)	;UPDATE THE SUPERIOR SPHERE POINTER
	JSR PC,ITM2PO	;POP THE SPHERE
	REST <C,B,A>
	JMP TAKSP	;UPDATE THE CIRCULAR PINTERS AND TAKE THE CAPABILITY
;INCREMENT SPHERE OR PROCESS REFERENCE COUNT, ITEM NO. IN C
;THIS DEPENDS ON THE SPHERE AND PROCESS REFERENCE COUNT BEING IN THE SAME PLACE
.IIF NZ SPHREF-PRSREF,.ERROR BARF IT WONT WORK
SPRINC:	SAVE A		;DON'T CLOBBER A
	MOV B,A		;GET THE ITEM NO.
	JSR PC,ITM1PL	;LOAD THE SPERE
	INC SPHREF(A)	;INC REFERENCE COUNT
	JSR PC,ITM1PO	;RELOAD ORIGINAL ITEM1
	REST A		;RESTORE IT
	RTS PC
;DECREMENT THE SPHERE'S REFERENCE COUNT, ITEM NO. IN A
SPRDEC:	JSR PC,ITM1PL	;LOAD THE SPHERE
	DEC SPHREF(A)	;DECREMENT THE REFERENCE COUNT
	BEQ SPRDC1	;NO ONE REFERS TO IT ANY MORE
	JSR PC,ITM1PO	;POP THE ITEM STACK
	RTS PC
SPRDC1:	MOV ITEM1,A	;SAVE THE ITEM NO.
	JSR PC,ITM1PO	;IN CASE WE GET STOPPED
	BIT #GIPBIT,A	;IS IT A GIP
	BNE SPRDC2	;YES, MUST BE A FUPT
	JSR PC,DLITEM	;DELETE THE ITEM
	RTS PC
SPRDC2:	SAVE B
	MOV A,B		;COPY THE FUPT
	JSR PC,UPTDEL	;DELETE IT
	REST B		;GET B BACK
	RTS PC		;RETURN
	.STITL I-O ROUTINES
EWRDI:	MOV #WDITAB,F
	BR IOTYPE
EWRDO:	MOV #WDOTAB,F
	BR IOTYPE
EBYTI:	MOV #BTITAB,F
	BR IOTYPE
EBYTO:	MOV #BTOTAB,F
	BR IOTYPE
EBLKI:	MOV #BKITAB,F
	BR IOTYPE
EBLKO:	MOV #BKOTAB,F

IOTYPE:	JSR PC,RETNSW	;GET THE CAP NO. OF THE IO DEVICE
	MOV A,B		;CAP NO.IF  IT IS NEGATIVE, WAIT FOR COMPLETION
	MOV A,E		;CONTAINS FLAGS IN HIGH BYTE
	BIC #177600,B	;CLEAR THE FLAG BITS
	MOV ITM1A,A	;START OF SPHERE
	JSR PC,GCLSTA	;GET THE CAPABILITY
	BEQ IOTYP1	;FAILED
	ADD B,A		;MAKE A POINT TO THE CAP.
	MOV A,D		;SAVE POINTER FOR IO ROUTINES
	MOV (A),B	;TYPE AND FLAGS OF CAP.
	BEQ IOTYP1	;NOTHING THERE
	CMPB #.TTCAP,B	;IS IT A TELTYPE CAPABILITY
	BEQ TTYIO
	CMPB #.FACAP,B	;IS IT A FILE ACCESS CAPABILITY
	BEQ DSKIO	;YES
	CMPB #.CLCAP,B	;IS IT A CORE LINK
	BEQ CLIO	;YES
	CMPB #.TPCAP,B	;IS IT A PAPER TAPE PUNCH CAP
	BEQ PTPIO	;YES
	CMPB #.TRCAP,B	;IS IT PAPER TAPE READER
	BEQ PTRIO	;YES
;THESE ARE FOR MEANINGLESS OPERATIONS (OUTPUT TO THE TAPE READER)
TRBKO:	TRWDO:	TRBTO:	
TPBKI:	TPWDI:	TPBTI:
IOTYP1:	JMP ERETSZ	;TELL HIM HE FAILED
	;BRANCHES INTO NEXT PAGE
	;BRANCHED INTO FROM PREVIOUS PAGE
PTRIO:	JMP @TRIDX*2(F)		;NOTHING TO DO
PTPIO:	JMP @TPIDX*2(F)		;DITTO
DSKIO:	MOV D,A			;POINTER TO THE CAPABILITY
	SUB ITM1A,A		;MAKE IT RELATIVE TO THE START OF THE ITEM
	MOV #.FALB,B		;THE BIT TO LOCK
	MOV ITEM1,C		;LOCK IT IN THE CURENT SPHERE
	JSR PC,LCKASW		;LOCK THE SWITCH
	JSR PC,RETPSW
	MOV A,B			;SAVE FOR DINNER
	BIC #-1-.FAAP,A		;APPEND OR WRITE
	BNE .+6
	BIS #.FAWT,A
	JMP @DKIDX*2(F)		;THE DISK ROUTINES ARE FIRST IN TABLE
TTYIO:	MOV 2(D),A		;THE TTY ITEM NO.
	JSR PC,ITM2LD
	CMP ITEM1,TTITM(A)	;DO I CURRENTLY OWN IT
	BNE TTYIO1		;NOPE
	JMP @TTIDX*2(F)	;THE TTY ROUTINES ARE SECOND IN TABLE
TTYIO1:	JSR PC,LFLUSH	;FLUSH YOURSELF
	CMP ITEM1,TTITM(A)	;DO I OWN IT NOW
	BNE TTYIO1	;NO, GO FLUSH YOURSEF AGAIN
	JSR PC,RUNME	;I THINK I HAVE GOT THE TTY
	BR TTYIO	;GO TRY AGAIN
CLIO:	MOV 2(D),A	;THE CORE LINK POINTER
	BIT #GIPBIT,A	;IS IT A GIP (MEANS IT IS AN FUPT)
	BEQ CLIO1	;NO, JUST GO AHEAD
	SAVE <B,F>
	MOV A,B		;POINTER TO FUPT
	JSR PC,UPTPLD	;LOAD IT UP
	MOV ITEM0,UPTPRP(B)	;SAY I USE THIS FUPT
	MOV B,F		;SAVE POINTER TO IT
	JSR PC,ITM2PO	;POP IT
	SAVE A		;THE FUPT POINTER
	MOV #LCKRTN,A	;RUN THIS ROUTINE WHEN UNLOCKED
	CLR B		;SAY THERE IS NO ITEM
	JSR PC,LOCKSW	;LOCK A SWITCH
	MOV #PRPFIX,LCKWD1(A)	;PUT IN THE ROUTINE TO RUN
	MOV F,LCKWD2(A)	;POINTER TO THE FUPT TO FIX
	REST B		;THE FUPT POINTER
	JSR PC,SWPIN	;SWAP IT IN
	REST <F,B>	;NOW WE WILL GET PC-LOSERED IF IT GOES OUT AGAIN
CLIO1:	JMP @CLIDX*2(F)	;THE CORE LINK ROUTINES ARE THIRD IN THE TABLES
	.STITL CORE LINK ROUTINES
CLGTBY:	TST CLCNT(A)	;ARE THERE ANY BYTES
	BEQ CLGTB1	;NO, RETURN SEZ
	MOV CLDATO(A),D	;POINTER TO THE DATA OUT
	ADD A,D		;MAKE THE POINTER ABSOLUTE
	MOVB (D),D	;GET THE BYTE
	DEC CLCNT(A)	;DECREMENT THE BYTE COUNT
	INC CLDATO(A)	;INCREMENT THE POINTER
	SAVE B		;GET A REGISTER
	MOV CLNUM(A),B	;THE NUMBER OF ENTRIES IN BUFFER
	ADD #CLDATL,B	;GET THE TOTAL MAXIMUM OFFSET
	CMP CLDATO(A),B	;ARE WE AT THE END OF THE BUFFER
	BLT .+10
	MOV #CLDATL,CLDATO(A)	;RESET THE DATA OUT POINTER
	JSR PC,CLSETW	;SET THE W BIT
	REST B
CLGTB1:	RTS PC

CLCHAR:	MOV CLCNT(A),B	;GET THE NUMBER OF CHARACTERS LEFT
	RTS PC

CLDPBY:	CMP CLCNT(A),CLNUM(A)	;ANY SPACE LEFT
	BEQ CLGTB1	;NO
	SAVE B
	MOV CLDATI(A),B	;THE DATA IN POINTER
	ADD A,B		;MAKE THE POINTER ABSOLUE
	MOVB D,(B)	;PUT IN THE BYTE
	INC CLCNT(A)	;SAY ANOTHER CHARACTER
	INC CLDATI(A)	;INCREMENT POINTER TO NEXT
	MOV CLNUM(A),B	;GET THE NUMVER OF SLOTS
	ADD #CLDATL,B	;GET THE TOTAL OFFSET
	CMP CLDATI(A),B	;ARE WE AT THE END
	BLT .+10
	MOV #CLDATL,CLDATI(A)	;RESET THE POINTER
	JSR PC,CLSETW	;SET THE W BIT
	REST B
	RTS PC
CLO:	JSR PC,CLDPBY	;DEPOSITE THE BYTE
	BEQ CLO1	;FAILED
	RTS PC
CLO1:	MOV ITEM2,A	;THE CL
	JSR PC,ITM2PO	;POP THE CL
	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD IT UP
	CMP CLCNT(A),CLNUM(A)	;IS IT STILL FULL
	BEQ CLO1	;YES
	MOV ITEM2,A
	JSR PC,ITM2PO
	JSR PC,RUNME	
	JSR PC,ITM2PL
	BR CLO

STIOQ:	JSR PC,TIOQ	;GET A CHARACTER
	BIT #TILIPM,TTYST1(A)	;AM I IN LOGO INPUT MODE
	BEQ STIOQ1	;NO
	CLR E		;CLEAR THE WAIT FLAG
STIOQ1:	RTS PC
	.STITL TTY AND CORE LINK INPUT ROUTINES
;THIS ROUTINE TAKES A CHARACTER FROM THE TTY POINTED TO BY THE CAPABILITY POINTED TO BY D
;AND PUTS IT ON THE TOP OF THE USERS STACK
TRBTI:	SAVE <#TRGTBY,#TRCHAR>
	BR TTBTI1	;LOAD IT UP
CLBTI:	SAVE <#CLGTBY,#CLCHAR>	;GET A BYTE
	BIT #.CLCONS,B	;AM I THE CONSUMER
	BEQ TTBTI4	;NO, ERROR
	BR TTBTI1
TTBTI:	SAVE <#STIOQ,#CHARCK>
	BIT #.TTYI,B	;DOES HE HAVE INPUT ACCESS
	BEQ TTBTI4	;NOPE
TTBTI1:	MOV 2(D),A	;GET THE TTY ITEM NO
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,@(P)	;GET THE NUMBER OF CHARACTERS INTO B
	TST B		;EOF?
	BMI TTBTI6
	CMP B,#1	;CAN WE GET ONE
	BLT TTBTI3	;NOPE
	JSR PC,@2(P)	;GET IT
	MOV D,B		;THE CHAR
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,GIVPSW	;GIVE IT TO THE USER
	ADD #4,P
	JMP ERETCZ
TTBTI3:	MOV (P),C	;GET THE ADDRESS OF THE CHARACTER RETURNING ROUTINE
TTBTI5:	MOV ITEM2,A	;SAVE THE ITEM NO.
	JSR PC,ITM2PO	;POP THE ITEM
	TST E		;SHOULD WE WAIT
	BMI TTBTI4	;NOPE
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	JSR PC,ITM2PL	;LOAD THE TTY OR CL
	JSR PC,(C)	;IS THERE A CHARACTER
	CMP B,#1	;ANY CHARACTERS
	BLT TTBTI5	;NO
	JSR PC,ITM2PO
	JSR PC,RUNME	;I CAN GET ONE NOW
	BR TTBTI1	;GO GET IN
TTBTI4:	ADD #4,P
	JMP ERETSZ
TTBTI6:	JSR PC,ITM2PO	;POP THE ITEM
	ADD #4,P
	JMP ERETSC
;THIS ROUTINE  IS THE SAME AS THE TTBTI, EXCEPT IT RETURNS TWO CHARACTERS
;THE FIRST IN THE LOW ORDER BYTE, AND THE NEXT IN THE TOP ORDER BYTE
TRWDI:	SAVE <#TRGTBY,#TRCHAR>
	BR TTWDI1
CLWDI:	SAVE <#CLGTBY,#CLCHAR>	;GET A BYTE
	BIT #.CLCONS,B	;IS HE A CONSUMER
	BEQ TTWDI3	;NO
	BR TTWDI1
TTWDI:	SAVE <#STIOQ,#CHARCK>
	BIT #.TTYI,B	;DOES HE HAVE INPUT ACCESS
	BEQ TTWDI3	;NOPE
TTWDI1:	MOV 2(D),A	;THE TTY ITEM NO.
TTWDI7:	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,@(P)	;CHECK TO SEE IF THERE ARE ENOUGH
	TST B		;EOF?
	BMI TTBTI6	;YES
	CMP B,#2	;2 BYTES LEFT
	BLT TTWDI2	;NOPE
	JSR PC,@2(P)	;GET A BYTE
	MOV D,B		;SAVE IT
	BIC #177400,B	;CLEAR THE HIGH BYTE
	JSR PC,@2(P)	;GET ANOTHER BYTE
	SWAB D		;PUT IT INTO THE TOP BYTE
	BIC #377,D	;CLEAR THE LOWER BYTE
	BIS D,B		;PUT THEM BOTH IN THE SAME WORD
	JSR PC,ITM2PO
	JSR PC,GIVPSW	;GIVE THE WORD TO THE USER
	ADD #4,P
	JMP ERETCZ	;RETURN SUCCESSFUL

	CMP B,#1
	BEQ TTWDI4	;THERE IS A CHARACTER
	JSR PC,ITM2PO
TTWDI3:	ADD #4,P
	JMP ERETSZ
TTWDI4:	JSR PC,@2(P)
	MOV D,B		;THE CHARACTER
	JSR PC,ITM2PO	;POP THE TTY	
	JSR PC,GIVPSW	;GIVE THE CHAR TO THE USERR
	ADD #4,P
ERETSC:	MOV ITM0A,A	;GET THE PROCESS ADDRESS
	CLR PUPDLO(A)	;NOTHING GETS POPPED
	SEZ!SEC
	JMP EMTRET
TTWDI2:
TTWDI5:	MOV ITEM2,D	;SAVE THE ITEM NO.
	MOV (P),C	;THE ADDRESS OF THE ROUTINE THAT RETURNS NUMBER OF BYTES
TTWDI6:	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	MOV D,A		;GET BACK THE CL-TTY
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,(C)	;GET NUMBER OF CHARACTERS
	CMP B,#2	;ENOUGH CHARACTERS YET
	BLT TTWDI6	;NOPE
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,RUNME	;I THINK I HAVE GOT THEM
	BR TTWDI7
;THIS ROUTINE TAKES A BLOCK OF CHARACTER FROM THE TTY, THE FIRST THING ON
;THE STACK IS THE NEGATIVE OF THE BYTE COUNT, THE SECOND IS A POINTER TO WHERE THE DATA
;GOES IN THE USERS D-SPACE
TRBKI:	SAVE <#TRGTBY,#TRCHAR>
	BR BKICOM
CLBKI:	SAVE <#CLGTBY,#CLCHAR>	;GET A BYTE
	BIT #.CLCONS,B	;AM I THE CONSUMER
	BEQ TBKISZ	;NO LOSER
	BR BKICOM
TTBKI:	SAVE <#STIOQ,#CHARCK>
	BIT #.TTYI,B	;DOES HE HAVE INPUT ACCESS
	BEQ TBKISZ	;NO
BKICOM:	JSR PC,RETNSW	;GET THE COUNT
	MOV A,C		;SAVE IT
	BEQ TBKICZ	;ITS 0, WE WIN
	BPL TBKISZ	;ITS POSITIVE, WE WANT A NEGATIVE COUNT
	JSR PC,RETNSW	;GET THE POINTER
	MOV A,F		;SAVE IT
	ASR A		;SEE IF IT IS AT AN ODD ADRESS
	BCC TBKI2	;IT IS OK
	MOV 2(D),A	;THE ITEM NO.
TBKI1:	DEC F		;MAKE B POINT TO THE PREVIOUS WORD
	MFPD (F)	;GET THE PREVIOUS WORD
	SAVE (P)
	MTPD (F)	;MAKE SURE WE CAN WRITE IT
	JSR PC,ITM2PL	;LOAD THE TTY ITEM
	BR TBKI4
TBKI2:	MOV 2(D),A	;THE TTY ITEM NO.
TBKI3:	MFPD (F)	;MAKE SURE WE CAN WRITE THIS WORD
	SAVE (P)	;SAVE IT
	MTPD (F)	;MAKE VBERY SURE WE CAN WRITE IT
TBKI11:	JSR PC,ITM2PL	;LOAD THE TTY
	JSR PC,@2(P)	;CAN I GET A CHAR
	CMP B,#1	;IS THERE ONE
	BLT TBKI5	;FAILED
	JSR PC,@4(P)	;GET THE CHARACTER	
	MOVB D,(P)	;SAVE THE FIRST CHAR
	INC C		;INCREMENT THE COUNT
	BEQ TBKIRT	;DONE IF ZERO

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

TBKI4:	JSR PC,@2(P)	;ARE THERE CHAR.
	CMP B,#1
	BLT TBKI9	;NOPE
	JSR PC,@4(P)	;GET THE CHARACTER
	MOVB D,1(P)	;PUT IT IN THE TOP BYTE
	MOV ITEM2,A	;SAVE IT FOR NEXT TIME
	JSR PC,ITM2PO	;POP THE TTY ITEM
	MTPD (F)+	;RETURN THE CHARACTERS
	INC C		;INC THE COUNT
	BEQ TBKICZ	;IF ZERO WE ARE DONE
	SAVE <A,B,C,F>
	MOV ITM0A,A	;GET THE ADDRESS OF ITEM
	MOV PUP(A),B	;THE PDL POINTER
	ADD PUPDLO(A),B	;CORRECT IT
	MTPD -(B)	;PUT BACK THE POINTER
	MTPD -(B)	;PUT BACK THE COUNT
	REST <B,A>
	BR TBKI3	;GO BACK FOR MORE
TBKI5:	JSR PC,ITM2PO
TBKI6:	ADD #4,P
	JMP ERETSC	;SET THE CARRY AND RETURN
TBKI7:	SAVE C
	MOV 4(P),C	;THE CHARACTER CHECKING ROUTINE
TBKI8:	MOV ITEM2,A	;SAVE THE ITEM NO.
	JSR PC,ITM2PO	;POP IT
	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD THE TTY
	JSR PC,(C)	;ANY CHARACTERS
	CMP B,#1
	BLT TBKI8	;NOPE
	MOV ITEM2,A	;SAVE IT FOR LATER
	JSR PC,ITM2PO	;POP THTE TTY
	JSR PC,RUNME	;I THINK I HAVE GOT IT
	REST C		;GET BACK RANDOM REG
	BR TBKI11	;GO GET THE CHAR

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

TBKIRT:	JSR PC,ITM2PO	;POP THE TTY
	MTPD (F)	;GIVE IT BACK, WITH ONE BYTE CHANGED
TBKICZ:	ADD #4,P	;POP OFF GARBAGE
	JMP ERETCZ	;RETURN SUCCESSFUL
TBKISZ:	ADD #4,P
	JMP ERETSZ
TBKI9:	MOV ITEM2,A	;SAVE IT
	JSR PC,ITM2PO	;POP THE TTY
	MTPD (F)	;GIV IT BACK WITH BYTE MODIFIED
	INC F		;CORRECT BYTE POINTER
	MOV F,B		;GIVE HIM THE POINTER
	JSR PC,GIVPSW
	MOV C,B		;THE COUNT
	JSR PC,GIVPSW	;GIVE IT TO HIM
	TST B		;EOF ERROR?
	BMI TBKI6	;YES
	SAVE C
	MOV ITM0A,C	;POINT TO THE PROCESS
	ADD #4,PUPDLO(C)	;CORRECT THE OFFSET
	MOV 2(P),C	;THE CHARACTER CHECKING ROUTINE
	BR TBKI12
TBKI10:	MOV ITEM2,A
	JSR PC,ITM2PO
TBKI12:	JSR PC,LFLUSH	;FLUSH YOURSELF
	JSR PC,ITM2PL	;LOAD THE TTYY
	JSR PC,(C)	;ARE THERE CHARACTERS
	CMP B,#1
	BLT TBKI10	;NOPE
	MOV ITEM2,A	;SAVE FOR LATER
	JSR PC,ITM2PO	;POP THE TTY
	JSR PC,RUNME	;RUN ME, RUN ME
	REST C
	JMP TBKI1	;FIX THE POINTER AND GET THE CHAR
	.STITL CORE LINK AND TTY OUTPUT ROUTINES
;THIS ROUTINE TAKES A BYTE OFF THE TOP OF THE USERS STACK AND OUTPUTS IT TO THE TTY
TPBTO:	SAVE <#TPO>
	BR TTBTO2
CLBTO:	SAVE <#CLO>
	BR TTBTO2
TTBTO:	SAVE <#TYO>
	BIT #.TTYO,B	;DOES HE HAVE OUTPUT ACCESS
	BNE TTBTO2	;YES
TTBTO1:	TST (P)+
	JMP ERETSZ
TTBTO2:	JSR PC,RETNSW	;GET THE CHARACTER TO TRANSMIT
	MOV A,F		;SAVE IT
	MOV 2(D),A	;THE TTY ITEM NO
	JSR PC,ITM2PL	;LOAD IT UP
	MOV F,D		;THE CHAR
	JSR PC,@(P)	;SEND THE CHARACTER
TTBTO3:	JSR PC,ITM2PO
	TST (P)+	;POP OFF THE ARGUMENT
	JMP ERETCZ	;SUCESS
;THIS ROUTINE TAKES A WORD OFF THE USERS STACK AND OUTPUTS IT TO THE TTY
TPWDO:	SAVE #TPO
	BR TTWDO2
CLWDO:	SAVE #CLO
	BR TTWDO2
TTWDO:	SAVE #TYO
	BIT #.TTYO,B	;DOES HE HAVE OUTPUT ACCESS
	BNE TTWDO2		;NOPE
TTWDO1:	ADD #2,P
	JMP ERETSZ
TTWDO2:	JSR PC,RETNSW	;GET THE CHARACTERS TO OUTPUT
	MOV A,F		;SAVE THEM
TTWDO3:	MOV 2(D),A	;THE TTY ITEM NO
TTWDO4:	JSR PC,ITM2LD	;LOAD IT
	BIT #.TTWD,E ;HAVE WE SENT THE FIRST BYTE YET?
	BNE TTWDO5	;YES
	MOVB F,D	;COPY THE BYTE
	JSR PC,@(P)	;SEND IT
	BIS #.TTWD,E ;FIRST BYTE WRITTEN BIT
	MOV F,B		;PUT BACK THE OUTPUT WORD
	JSR PC,GIVPSW	;GIVE BACK TO USER
	MOV E,B		;PUT FLAGS AND CAP NUMBER BACK THE WAY THEY WERE
	JSR PC,GIVPSW	;GIVE BACK TO USER
	JSR PC,RETNSW	;THIS IS THE WAY WE WERE CALLED
	BR TTWDO2	;NOW SEND THE SECOND CHAR	
TTWDO5:	SWAB F		;GET THE NEXT CHAR
	MOVB F,D	;THE OTHER CHAR
	JSR PC,@(P)	;SEND IT ALSO
	ADD #2,P	;POP THE ADDRESS
	JMP ERETCZ	;SUCCESS


;CL AND TTY BLOCK OUTPUT
TPBKO:	SAVE #TPO
CLBKO:	SAVE #CLO
	BR TBKO1
TTBKO:	SAVE #TYO
	BIT #.TTYO,B	;DOES HE HAVE OUTPUT ACCESS
	BNE TBKO1
TBKOSZ:	ADD #4,P
	JMP ERETSZ
TBKO1:	MOV 2(D),A	;THE TTY ITEM
	JSR PC,ITM2LD	;LOAD IT UP
	JSR PC,RETNSW	;GET THE COUNT
	MOV A,C		;SAVE IT
	BEQ TBKOCZ	;NONE TO TRANSFER
	BPL TBKOSZ	;POSITIVE COUNT?
	JSR PC,RETNSW	;GET THE POINTER
	MOV A,F		;SAVE IT
	MOV ITM2A,A	;GET THE ADDRESS OF THE TTY ITEM
	BIT #1,F	;DOES POINTER POINT TO A BYTE?
	BEQ TBKO2	;NO, IT POINTS TO A WORD
	DEC F		;MAKE IT POINT TO THE PREVIOUS WORD
	MFPD (F)	;GET THE WORD
	INC F		;GET BACK TO THE CORRECT POINTER
	BR TBKO4	;PRETEND YOU HAVE ALREADY SENT A CHARACTER
TBKO2:
TBKO3:	MFPD (F)	;GET THE TWO CHARACTERS
	MOVB (P),D	;THE FIRST CHARACTER
	JSR PC,@2(P)
	INC F
	INC C		;INCREMENT THE COUNT
	BEQ TBKORT	;DONE
	JSR PC,TBKRSP	;RESET THE POINTERS IN USER SPACE

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

TBKO4:	MOVB 1(P),D	;THE SECOND CHAR
	JSR PC,@2(P)	;PUT THE CHAR IN THE BUFFER
	INC F		;THE POINTER
	INC C		;INC THE COUNT
	BEQ TBKORT	;DONE
	JSR PC,TBKRSP	;RESET THE POINTERS IN USER SPACE
	TST (P)+	;POP OFF THE CHARACTERS
	BR TBKO3	;DO IT AGAIN
TBKORT:	TST (P)+	;POP OFF THE CHARACTERS
TBKOCZ:	ADD #2,P	;POP OFF THE ROUTINE ADDRESSES
	JMP ERETCZ

;THIS SUBROUTINE RESETS THE POINTERS SO THAT IS WE GET PC-LUSERED, WE'RE OK
TBKRSP:	SAVE <A,B,C,F>
	MOV ITM0A,A	;GET THE ADDRESS OF ITEM
	MOV PUP(A),B	;THE PDL POINTER
	ADD PUPDLO(A),B	;CORRECT IT
	MTPD -(B)	;PUT BACK THE POINTER
	MTPD -(B)	;PUT BACK THE COUNT
	REST <B,A>
	RTS PC

	.STITL DISK I/O ROUTINES
;DSK INPUT ROUTINES (DON'T SEPERATE)

;BLOCK INPUT ROUTINE
;(A)= WHERE TO PUT BYTES (USERS CORE)
;(B)= NEG. # BYTES TO TRANSFER
;(C)= NEG. # BYTES AVAILABLE ON PAGE
;(D)= CAP. PTR
;(E)= CORE ADDRESS OF DATA

DKBKI:	JSR PC,RETNSW		;BYTE COUNT
	MOV A,B
	JSR PC,RETNSW		;USERS PTR
	MOV A,E			;CHECK WORD BOUNDARIES
	BIS B,E
	BIS FAFBP(D),E
	ASR E
	BCS DKBT.6		;ODD ADDRESS
	TST B
	BEQ DKBI.5
DKBI.1:	JSR PC,DKISET		;SET UP PAGE
	BEQ DKBT.7		;EOF
	CMP C,B			;COMPARE BYTES AVAILABLE AND NEEDED
	BLE DKBI.3		;BRANCH IF ENOUGH ON THIS PAGE
	NEG C			;BYTES AVAILABLE
	MOV C,F			;SAVE THE COUNT
	ASR C			;WORD COUNT NOW
DKBI.2:	SAVE <(E)+>		;TRANSFER A CHUNK
	MFPD (A)		;GOOD OLD DEC
	TST (P)+		;HELPS US OUT AGAIN
	MTPD (A)+		;THIS SUCKS BUT I CAN'T CLOBBER P
	SOB C,DKBI.2
	JSR PC,DKUPDT		;UPDATE CALL AND FA PTR
	BR DKBI.1		;GET SOME MORE
DKBI.3:	NEG B			;LAST HUNK TO GRAB
	MOV B,F			;SAVE THE COUNT
	ASR B			;WORD COUNT NOW
DKBI.4:	SAVE <(E)+>
	MFPD (A)		;GOOD OLD DEC
	TST (P)+		;HELPS US OUT AGAIN
	MTPD (A)+		;GIVE USER SOME WORDS
	SOB B,DKBI.4
	ADD F,FAFBP(D)
	JSR PC,DKPI.1		;UPDATE FA PTR
DKBI.5:	JMP ERETCZ		;DONE AT LAST
;WORD IN ROUTINE
;(D)= FA CAP POINTER
;RETURN WORD ON USERS STACK

DKWDI:	JSR PC,DKISET		;(C)=NEG. BYTES AVAIL ON PAGE
				;(E)=CORE ADDRESS 
	BEQ DKBT.7		;EOF
	INC C
	BEQ DKWI.1		;WORD HANGS OVER PAGE BOUNDARY
	INC FAFBP(D)		;UPDATE FA PTR
	MOVB 1(E),B		;GET SECOND BYTE
	SWAB B
	CLRB B
	BR DKBT.3		;GET OTHER BYTE AND RETURN
DKWI.1:	MOVB (E),-(P)		;SAVE 1ST BYTE
	JSR PC,DKPINC		;INCREMENT PTR
	MOV #LCKRTN,A		;LOCK A SWITCH TO DEC PTR
	MOV ITEM1,B		;THE SPHERE
	JSR PC,LOCKSW
	MOV #MFPCL2,LCKWD1(A)	;WILL DEC FA CAP PTR WHEN UNLOCKED
	MOV D,LCKWD2(A)
	SUB ITM1A,LCKWD2(A)	;OFFSET TO FA CAP
	JSR PC,DKISET		;NEW PAGE SO SET UP AGAIN
	BEQ DKBT.7		;EOF
	MOVB (E),1(P)		;GET SECOND BYTE
	REST <B>
	JSR PC,LSWPOP		;DECREMENT THE FA CAP PTR.
	INC FAFBP(D)		;THIS AND LOCKED SWITCH CANCEL
	BR DKBT.4		;RETURN WORD TO USER
;BYTE IN ROUTINE

DKBTI:	CLR B			;GIVE THE USER A BYTE
	JSR PC,DKISET		;SET THINGS UP
	BEQ DKBT.7		;EOF
DKBT.3:	BISB (E),B		;HERE IS HIS BYTE
DKBT.4:	JSR PC,GIVPSW		;RETURN DATA
DKBT.5:	JSR PC,DKPINC		;UPDATE FA PTR
	JMP ERETCZ		;RETURN TO SUCESS
DKBT.6:	MOV #.FAWBE,ITM0AD+PERRW ;ODD ADDRESS ERROR
DKBT.7:	CMP #.FAEOF,ITM0AD+PERRW
	BEQ ERETZV		;SET V IF EOF
	JMP ERETSZ		;ALL BAD RETURNS ON DSKIO PASS THROUGH HERE
ERETZV:	MOV ITM0A,A		;IF THE CALL FAILS
	CLR PUPDLO(A)		;NOTHING GETS POPPED
	SEV!SEZ
	JMP EMTRET
;DISK OUTPUT ROUTINES (DON'T SEPERATE)

;WORD OUT ROUTINE
;(A)=APPEND OR REGULAR WRITE FLAG
;(B)=USER'S CALL WORD

DKWDO:	MOV A,F			;APPEND FLAG
	JSR PC,RETNSW
	JSR PC,DKOSET		;SET UP THE PAGE FOR OUTPUT
	BEQ DKBT.7		;FAILED
	BIT #.FAWD,B
	BNE DKWO.2		;FIRST BYTE ALREADY DONE
	MOVB A,(E)+		;WRITE A BYTE
	INC C			;NEG BYTES AVAILABLE
	BEQ DKWO.3		;HANGS OVER BOUNDARY
	INC FAFBP(D)
DKWO.2:	SWAB A
	MOVB A,(E)		;WRITE THE SECOND BYTE
	BR DKBT.5		;CLEAN UP
DKWO.3:	BIS #.FAWD,B		;SET THE FIRST BYTE WRITTEN BIT
	MOV B,C			;SAVE IT
	MOV A,B
	JSR PC,GIVPSW		;PUT DATA BACK ON STACK
	MOV C,B
	JSR PC,GIVPSW		;PUT CALL WITH BIT SET ON STACK
	JSR PC,RETNSW		;USERS CALL
	JSR PC,DKPINC		;CLEAN UP
	MOV F,A			;APPEND FLAG
	BR DKWDO		;DO SECOND BYTE
;BYTE OUT

DKBTO:	MOV A,F			;APPEND FALG
	JSR PC,RETNSW		;SOURCE BYTE
	JSR PC,DKOSET		;SET UP THE PAGE FOR WRITING
	BEQ DKBT.7		;FAILURE
	MOVB A,(E)		;WRITE THE BYTE
	BR DKBT.5		;DONE
;BLOCK OUT
;(A)= DESTINATION ADDRESS
;(B)= NEGATIVE BYTE COUNT
;(C)= NEGATIVE BYTES AVAILABLE FROM THIS FUPT
;(D)= FA CAP. POINTER
;(E)= SOURCE ADDRESS

DKBKO:	MOV A,F			;APPEND FLAG
	JSR PC,RETNSW		;BYTE COUNT
	MOV A,B
	JSR PC,RETNSW		;SOURCE ADDRESS
	MOV A,E			;CHECK WORD BOUNDARIES
	BIS B,E
	BIS FAFBP(D),E
	ASR E
	BCS DKBT.6		;BOUNDARY ERROR
	TST B			;NEWGATIVE WORD COUNT
	BPL DKBO.5		;BAD AARGUMENT
	SAVE <F>		;SAVE USERS FLAG
DKBO.1:	MOV (P),F		;RESTORE FLAG
	JSR PC,DKOSET		;SET UP FUPT
	BEQ DKBO.5		;FAILED
	CMP C,B			;BYTES AVAILABLE
	BLE DKBO.3		;LAST TRANSFER
	NEG C
	MOV C,F			;SAVE COUNT
	ASR C			;WORD COUNT
DKBO.2:	MFPD (A)+
	REST <(E)+>		;DO THE TRANSFER
	SOB C,DKBO.2
	JSR PC,DKUPDT		;UPDATE THE POINTERS
	BR DKBO.1		;WRITE SOME MORE
DKBO.3:	TST (P)+		;POP FLAGS
	NEG B			;THIS IS THE END
	MOV B,F			;SAVE COUNT
	ASR B			;WORD COUNT
DKBO.4:	MFPD (A)+		;LAST TRANSFER
	REST <(E)+>		;DO IT
	SOB B,DKBO.4
	ADD F,FAFBP(D)		;UPDATE THINGS
	JSR PC,DKPI.1
	JMP ERETCZ		;DONE
DKBO.5:	TST (P)+
	JMP DKBT.7		;FAILED
;UPDATE THE USER'S CALL AND FA PTR FOR BLOCK TRANSFERS
;(A)= USER'S CORE PTR AND (B)= NEG. BYTE COUNT
;(F)= NUMBER OF BYTES JUST TRANSFERED

DKUPDT:	ADD F,B			;ADD BYTES JUST PROCESSED TO NEG COUNT
	ADD F,FAFBP(D)		;UPDATE FA CAP PTR
	SAVE <B>
	MOV A,B
	JSR PC,GIVPSW		;PUT USER'S DATA BACK
	REST <B>
	JSR PC,GIVPSW
	JSR PC,RETNSW		;NOW GET USER'S DATA BACK
	JSR PC,DKPI.1		;UPDATE FA PTR
	JSR PC,RETNSW
	RTS PC
;INCREMENTS FA PTR IN F 
;IF PAGE COUNT OVERFLOWS IT WRAPS AROUND
;UPDATE FA CAP PTR AND EOF WORDS
DKPINC:	INC FAFBP(D)
DKPI.1:	BIT #20000,FAFBP(D)	;CHECK FOR PAGE OVERFLOW
	BEQ DKPI.2
	BIC #20000,FAFBP(D)	;NEW PAGE NOW
	INC FAFPN(D)		;INC PAGE #
DKPI.2:	MOV FAMFI(D),A
	JSR PC,ITM2LD
	CMP FAFPN(D),MFPGNO(A)
	BHI DKPI.3		;CHANGE EOF
	BLO DKPI.4		;DON'T CHANGE IT
	CMP FAFBP(D),MFBYTP(A)
	BLOS DKPI.4		;DON'T CHANGE IT
DKPI.3:	MOV FAFPN(D),MFPGNO(A)	;CHANGE EOF WORDS
	MOV FAFBP(D),MFBYTP(A)
	BIT #1777,FAFBP(D)	;NEW BLOCK?
	BNE .+10		;NO
	BIC #MFLSTB,MFENHD(A)	;CLEAR BLOCK EXISTS BIT
	BIS #MFEBMB,MFLAGW(A)	;WE JUST CHANGED THE EOF WORDS
DKPI.4:	JMP LSWPOP		;CLEAR THE FUPT PROCESS PTR

;PC LOSER ROUTINE TO CLEAR FUPT PROCESS POINTER

MFPCL1:	MOV LCKWD2(B),B
	JSR PC,UPTPLD		;LOAD THE FUPT
	CLR UPTPRP(B)
	JMP ITM2PO		;DOES RTS PC FOR US

;PC LOSER RROUTINE TO DECREMENT POINTER IN FA CAP

MFPCL2:	MOV LCKWD2(B),B
	ADD A,B			;NOW POINTS TO FA CAP
	DEC FAFBP(B)
	BGE MFPCL3
	MOV #17777,FAFBP(B)	;PAGE UNDERFLOW
	DEC FAFPN(B)
MFPCL3:	RTS PC

;PCL ROUTINE TO FREE SWAP SPACE
MFPCL4:	MOV LCKWD2(B),B
	JMP DSWPAL

;LOCKED SWITCH ROUTINE TO RESTORE MFBYTP, AND MFLSTB
MFPCL5:	BIC #MFLSTB,MFENHD(A)	;CLEAR LAST BLOCK EXISTS BIT
	BR MFPCL7
MFPCL6:	BIS #MFLSTB,MFENHD(A)	;SET LAST BLOCK EXISTS BIT
MFPCL7:	MOV LCKWD2(B),MFBYTP(A)
	CLR MFPGNO(A)		;THIS IS ZERO FOR DIRECTORIES
	RTS PC

;UNMUTATES FILE CAPABILITY BACK FROM BEING PARENT DIRECTORY
MFPCL8:	SAVE <E>		;THIS ROUTINE POPS THE NEXT ONE ALSO
	MOV LCKWD2(B),E		;RELATIVE ADDRESS OF FA CAPABILITY
	JSR PC,LSWPOP		;THIS CHANGES THE CAPABILITY
	REST <E>
	RTS PC

MFPCL9:	ADD A,E			;E SET BY ROUTINE ABOVE
	MOV LCKWD2(B),FAMFI(E)	;CHANGE MFI ITEM #
	RTS PC

;CLEANS UP FPT IF NECESSARY
MFPC10:	SAVE <E>
	MOV LCKWD2(B),E		;ADDRESS OF FPT
	JSR PC,FPTDEL		;TRY TO DELETE IT
	REST <E>
	RTS PC
;SET UP PAGE FOR DISK INPUT
;(D)= CAPABILITY PTR
;RETURNS IN C NEG. BYTES AVAILABLE ON PAGE
;IN E CORE ADDRESS FA POINTS AT
;IN F THE BYTE POINTER

DKISET:	BIT #.FARD,(D)		;DOES HE HAVE ACESS?
	BEQ DKIS.4
	CLR E			;SIZE OF FUPT
	MOV #-1,F		;SO DKURIO WILL SWAP IT IN
	JSR PC,DKURIO		;CHECK ACCESS CODES AND SET UP UPT
	BEQ DKIS.2		;FAILED
	SAVE <A>
	MOV FAMFI(D),A
	JSR PC,ITM2LD		;LOAD UP MFI
	MOV FAFBP(D),F
	MOV F,E			;THIS FUPT IS ONLY A BLOCK LONG
	BIC #176000,E		;BYTE OFFSET INTO BLOCK
	MOV F,C			;COMPUTE BYTE LEFT IN FUPT
	ADD #2000,C
	BIC #1777,C		;NEXT HIGHEST BLOCK BOUNDARY
	CMP FAFPN(D),MFPGNO(A)	;CHECK FOR EOF ON THE SAME BLOCK AS POINTER
	BNE DKIS.1
	CMP C,MFBYTP(A)		;KEEP CHECKING
	BLT .+6
	MOV MFBYTP(A),C		;UPS! HIT THE EOF
DKIS.1:	SUB F,C			;COMPUTE BYTES AVAILABLE
	NEG C			;NEGATE COUNT
	BGE DKIS.3		;EOF
	MOV FAUPT(D),A
	JSR PC,ITM2LD		;LOAD UP THE FUPT
	ADD A,E			;FA CAP POINTER MAPS TO THIS CORE
	REST <A>
	CLZ			;WINNING RETURN
DKIS.2:	RTS PC
DKIS.3:	TST (P)+		;LOSING RETURN
	JMP MFEOF
DKIS.4:	MOV #.FAACV,ITM0AD+PERRW
	SEZ			;LOSING RETURN
	RTS PC
;SET UP PAGE FOR DISK OUTPUT
;(D)= CAPABILITY PTR
;RETURNS IN C NEG. BYTES AVAILABLE ON PAGE
;IN E CORE ADDRESS FA POINTS AT

DKOSET:	SAVE <A,B,F>
	BIT F,(D)		;EITHER APPEND OR WRITE ACCESS
	BEQ DKOS.5		;NO ACCESS
	MOV FAMFI(D),A
	JSR PC,ITM2LD		;LOAD MFI
	BIT #MFDIRB,MFLAGW(A)
	BEQ DKOS.1
	JMP MFIWTE		;USER CAN'T WRITE ON DIRECTORY
DKOS.1:	JSR PC,ADDBLK		;CHECK THAT LAST BLOCK EXISTS
	BEQ DKOS.4		;NO BLOCKS LEFT
	MOV ITM2A,A
	BIT #.FAAP,(P)
	BEQ DKOS.2		;REGULAR WRITE
	MOV MFPGNO(A),FAFPN(D)
	MOV MFBYTP(A),FAFBP(D)	;MOVE POINTER TO EOF FOR APPEND
DKOS.2:	MOV #-1,F		;ASK FOR FUPT TO BE SWAPPED IN
	CLR E			;SIZE OF FUPT
	JSR PC,DKURIO		;GO MAKE THE FUPT
	BEQ DKOS.4 		;FAILED TO GET FILE BLOCK
	MOV FAMFI(D),A
	JSR PC,ITM2LD		;LOAD MFI
	MOV FAFBP(D),C		;GET BYTE POINTER
	BIT #.FAAP,(P)
	BEQ DKOS.3		;REGULAR WRITE
	CMP MFBYTP(A),C
	BNE DKOS.1		;WE'RE NOT AT EOF ANYMORE
	CMP MFPGNO(A),FAFPN(D)	;APPENDING TO FILE
	BNE DKOS.1		;WE'RE NOT AT EOF ANYMORE
DKOS.3:	BIC #176000,C		;COMPUTE BYTES AVAILABLE ON BLOCK
	MOV C,E			;POINTER INTO BLOCK
	SUB #2000,C		;NEGATIVE BYTE COUNT
	JSR PC,MFSETW		;SET WRITTEN ON BITS IN FUPT
	MOV FAUPT(D),A
	JSR PC,ITM2LD		;LOAD THE FUPT
	ADD A,E			;MAKE POINTER ABSOLUTE
	REST <F,B,A>
	CLZ			;GOOD RETURN
	RTS PC			;WE WON
DKOS.5:	MOV #.FAACV,ITM0AD+PERRW
DKOS.4:	ADD #6,P		;WE LOST
	SEZ
	RTS PC
;SET UP UPT FOR FA CAP POINTED TO BY D
;IT SHOULD START AT BLOCK INTO WHICH FA CAP POINTS
;(E)= LEGNTH (IN BLOCKS MINUS 1) OF FUPT TO MAKE
;IF (E) < 0 THEN MAP IN ENTIRE FIRST PAGE OF FILE
;(F)= IF NEGATIVE SWAP IT IN

DKURIO:	SAVE <A,B,F,E>		;IF F >= 0 THEN DONT SWAP IT IN
	MOV FAMFI(D),A
	JSR PC,ITM2LD		;LOAD MFI
	TST MFLKSP(A)		;IS THIS MFI LOCKED
	BEQ DKUR.1		;NOT LOCKED
	CMP ITEM1,MFLKSP(A)
	BEQ DKUR.1		;THIS SPHERE LOCKED THE FILE
	BR DKUR.6		;IT'S LOCKED YOU LOSE
DKDRIO:	CLR FAFBP(D)		;ENTRY FOR MAPPING IN ENTIRE FILE OF
	CLR FAFPN(D)		;ONE PAGE OR LESSER LEGNTH
	SAVE <A,B,#-1,(P)>	;REGISTERS AND FLAGS
	MOV FAMFI(D),A
	JSR PC,ITM2LD		;LOAD MFI
DKUR.1:	JSR PC,MFMFPT		;SET UP FPT IF NECESSARY
	BEQ DKUR.6		;FAILED
	MOV (P),A		;SIZE OF FUPT
	BGE DKUR.2		;SPECIAL PROCESSING IF NEGATIVE
	MOV E,B			;WE WANT ALL THE BLOCKS ON THE PAGE
	ADD #FPTSRC+20,B
	MOV #7,A		;COUNT OF BLOCKS EXISTING ON FIRST PAGE
	TST -(B)		;NOW BACK UP LOOKING FOR EXISTING BLOCK
	BNE .+4
	SOB A,.-4
	MOV A,(P)		;SIZE OF FUPT
DKUR.2:	JSR PC,MFMUPT		;MAKE THE FUPT
	BEQ DKUR.5		;NO SWAP SPACE
	JSR PC,LSWPOP		;DELETE FPT IF NOT REFERENCED
	TST (P)+
	TST (P)+		;SHOULD IT BE SWAPPED IN
	BGE DKUR.4		;DON'T SWAP IT IN
	MOV #LCKRTN,A		;RUN ROUTINE WHEN UNLOCKED
	CLR B			;NO ITEM NUMBER
	JSR PC,LOCKSW
	MOV #MFPCL1,LCKWD1(A)	;THIS WILL CLEAR THE FUPT PROCESS PTR
	MOV FAUPT(D),B
	MOV B,LCKWD2(A)		;ADDRESS OF FUPT
	JSR PC,UPTLD
	MOV ITEM0,UPTPRP(B)	;SET THIS FUPT'S PROCESS POINTER
	MOV FAUPT(D),B		;SWAP IT IN NOW
	JSR PC,SWPIN
DKUR.4:	REST <B,A>		;RETURN TO SUCESS
	CLZ
	RTS PC
DKUR.5:	JSR PC,LSWPOP		;CLEAN UP FPT IF NECESSARY
DKUR.6:	CMP (P)+,(P)+		;POP STACK
	REST <B,A>		;FAILING RETURN
	SEZ
	RTS PC
;SET UP FLOATING UPT FOR FPT (SIZE IN BLOCKS IN A) AND PUT IT IN FAUPT(D)
;(D)= FACAP PTR (IF FAUPT(D) IS NOT 0 THEN DELETE FUPT IT POINTS AT)
;(E)= FPT ADDRESS TO AHNG IT OFF OF

				;NO CIRCUYLAR LIST EXISTS YET
MFMU.1:	MOV (P),C		;SIZE OF FUPT
	BIT #FPTWSB,FPTFLG(E)	;IS IT A WRITE TO SOURCE FPT
	BNE MFMU.2
	MOV C,B			;SIZE OF SWAP SAPCE NEEDED
	JSR PC,SWPAL		;ALLOCATE SWAP SPACE
	BEQ MFNSS		;FAILED
	MOV B,FPTSWA(E)		;SET SWAP ADDRESS INTO FPT
MFMU.2:	JSR PC,MFUPAL		;START TO MAKE A FUPT
	BIS F,C
	MOV C,UPTAR(A)
	MOV A,B			;MAKE IT POINT TO ITSELF
MFMU.3:	ADD #<100000-FUPTTB>,A	;MAKE A GIP
	MOV A,FPTUPT(E)		;SET FPT'S LINK TO CIRCULAR LIST
	MOV A,UPTCLP(B)		;FINISH LINKING IT IN
	MOV A,FAUPT(D)		;NOW EVERYONE KNOWS ABOUT THE NEW FUPT
	JSR PC,LSWPOP		;UNLOCK THE FPT
MFMU.4:	REST <A>		;CHECK THAT ALL BLOCKS REALLY EXIST
	ASL F			;START OFFSET FOR FUPT
	ADD E,F
	ADD #FPTSRC,F		;FIRST BLOCK OF FUPT
	INC A			;NOW COUNT OF BLOCKS WANTED
MFMU.5:	TST (F)
	BEQ MFEOF		;THIS BLOCK DOES NOT EXIST
	CMP (F)+,#-1
	BEQ MFHIF		;THIS IS A HOLE IN THE FILE
	SOB A,MFMU.5
	CLZ			;SUCESSFUL RETURN
	RTS PC
MFHIF:	MOV #.FAHIF,ITM0AD+PERRW
	BR MFMU11
MFEOF:	MOV #.FAEOF,ITM0AD+PERRW
	BR MFMU11
MFIPB:	MOV #.FAIPB,ITM0AD+PERRW
	BR .+10
MFNSS:	MOV #.FANSS,ITM0AD+PERRW
	TST (P)+
MFMU11:	SEZ			;FAILING RETURN
	RTS PC

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

MFMUPT:	SAVE <A>		;ENTERS HERE
	MOV A,C			;SAVE COPY OF LEGNTH FOR MFCUPT
	MOV FAFBP(D),F
	SWAB F			;COMPUTE OFFSET FOR FUPT
	ASR F
	ASR F
	BIC #177770,F		;START OF REFERENCED AREA
	ADD F,A			;CHECK PAGE BOUNDARY
	CMP #10,A
	BLE MFIPB		;OVERFLOW
	JSR PC,MFCUPT		;CHECK TO SEE IF THIS FUPT IS WHAT WE WANT
	BNE MFMU.4		;GOT IT
	BIT #MFOPNB,ITM2AD+MFLAGW
	BNE MFMU.6		;SLOT IS RESERVED
	MOV ITM2AD+MFIUPT,A	;SWITCH MFI AND FA CAP FUPTS
	MOV FAUPT(D),ITM2AD+MFIUPT
	MOV A,FAUPT(D)
	JSR PC,MFCUPT		;CHECK THE OTHER ONE
	BNE MFMU.4		;GOT A GOOD ONE
MFMU.6:	MOV ITM2A,A
	JSR PC,MFUPTD		;KILL OLD FUPT

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

MFMU.7:	CLR C			;NOW MAKE A NEW FUPT
	MOV #FPTLKB,B
	MOV E,A			;LOCK THE FPT
	ADD #FPTFLG,A
	JSR PC,LCKASW
	MOV FPTUPT(E),B		;POINTS TO CIRCULAR LIST
	BEQ MFMU.1		;NO OTHER UPT'S ON THIS FPT
	MOV (P),C		;NEW LEGNTH OF AREA
	JSR PC,UPTFIT		;DOES IT FIT
	BEQ MFMU10		;DONT CHANGE ANYTHING
	BIT #1,FPTSWA(E)	;WE HAVE TO ENLARGE ACTIVE PART OF PAGE
	BNE MFMU.8		;ALREADY A BIG SWAP AREA
	BIT #FPTWSB,FPTFLG(E)
	BNE MFMU.8		;WRITE TO SOURCE
	JSR PC,SWPAL		;B =/ 0 RETURNED BY UPTFIT
	BEQ MFNSS		;NO SPACE
	MOV #LPCLRT,A
	SAVE <B>		;SWAP SPACE ADDRESS
	CLR B
	JSR PC,LOCKSW		;RELEASE THE NEW SPACE IF PCLOSERED
	MOV #MFPCL4,LCKWD1(A)
	MOV (P),LCKWD2(A)
	MOV FPTUPT(E),B		;NOW CHANGE THE SWAP SPACE
	JSR PC,SWPIN		;SWAP IT IN AND WAIT FOR IT TO STOP
	MOV FPTSWA(E),B		;CHANGE THE FPT SWAP ADDRESS
	REST <FPTSWA(E)>
	JSR PC,LSWPOP		;THIS WOULD DELETE NEW SWAP PAGE
	JSR PC,DSWPAL		;RELEASE SMALL BLOCK
	MOV FPTUPT(E),B		;GET A UPT
	JSR PC,UPTPLD		;LOAD IT UP
	BIS #UPTWON,(B)		;MAKE SURE IT GETS SWAPPED OUT NEXT TIME
	JSR PC,ITM2PO		;POP THE UPT
MFMU.8:	MOV FPTUPT(E),B		;NOW CHANGE THE AR THROUGHOUT THE CIRCULAR LIST
	JSR PC,SWPOT		;SWAP IT OUT AND WAIT FOR IT TO STOP
	TST FUPTFR
	BNE MFMU.9		;FLUSH UNTIL THERE IS A FUPT AVAILABLE
	JSR PC,MFLFUP		;FLUSH YOURSELF
	BR MFMU.8		;TRY AGAIN
	MOV UPTCLP(B),B		;MOVE ALONG CIRCULAR LIST
MFMU.9:	JSR PC,UPTLD		;GET THE CIRCLE GOING
	MOV C,UPTAR(B)		;CHANGE THE AR
	CMP UPTCLP(B),FPTUPT(E)	;HAVE WE COME FULL CIRCLE YET
	BNE MFMU.9-4		;CIRCLE SOME MORE
MFMU10:	MOV (P),C		;NEW LEGNTH FOR DR
	JSR PC,MFUPAL		;ALLOCATE A FUPT (CANT FAIL)
	MOV UPTCLP(B),UPTCLP(A)	;LINK IT INTO THE CIRCULAR LIST
	MOV UPTAR(B),UPTAR(A)	;THESE ARE SHARED
	JMP MFMU.3		;FINISH LINKING IT AND CHECK IT AGAIN
;ALLOCATE A FUPT AND RETURN ADDRESS IN (A)
;(E)= ADDRESS OF FPT
;(F)= START OF REFERENCED ENTRY
;CLOBBERS C

MFAL.1:	JSR PC,MFLFUP		;WAIT FOR A FREE FUPT
MFUPAL:	MOV FUPTFR,A
	BEQ MFAL.1		;FLUSH YOURSELF
	MOV (A),FUPTFR		;LINK IT OUT OF FREE LIST
	SEC			;COMPUTE FPT POINTER
	ROR E
	MOV E,UPTFPT(A)		;PUT FPT POINTER INTO FUPT
	ASL E			;CHANGE IT BACK
	SWAB C			;LEGNTH OF REFERENCED AREA
	ASH #4,C		;PUT LEGNTH INTO DR LEGNTH FIELD
	SWAB F			;START OF REFERENCED AREA
	MOV C,UPTDR(A)		;FILL IN THE FUPT DR
	BIS #6,UPTDR(A)		;GIVE HIM ACCESS
	BIS F,UPTDR(A)		;SET THE START OF REFERENCED AREA IN DR
	SWAB F			;CHANGE IT BACK
	RTS PC
;CHECK TO SEE IF FAUPT(D) IS WHAT WE WANT
;(C)= LEGNTH WE WANT
;(D)= FA CAPBAILITY (POINTS TO START OF FUPT)
;(E)= ADDRESS OF FPT WHERE FUPT WILL HANG

MFCUPT:	MOV FAUPT(D),B
	BEQ MFCU.1		;NONE THERE
	JSR PC,UPTLD		;LOOK AT ITS START AND LEGNTH FIELDS
	MOV UPTFPT(B),A
	ASL A			;NOW POINTS TO FPT
	CMP A,E			;DOES IT POINT TO THE RIGHT FPT
	BNE MFCU.1		;IMPOSTER!
	MOVB UPTSRT(B),B	;NOW CHECK NOW CHECK START AND LEGNTH FIELDS
	MOV B,A			;START AND LEGNTH FIELDS
	BIC #177770,B		;START FIELD
	CMP B,F
	BNE MFCU.1		;THIS IS NO GOOD
	ASH #-4,A
	BIC #177770,A		;LEGNTH FIELD
	CMP A,C
	BNE MFCU.1		;NO GOOD
	CLZ			;FOUND IT HURRAY!
	RTS PC
MFCU.1:	SEZ			;NOT THE FUPT WE WANT
	RTS PC
;CHECK IF A UPT WILL FIT WITH CIRCULAR LIST (GIP IN B)
;IF IT DOESN'T CLR Z AND PUT NEW UPTAR IN C
;NEW START IN F AND NEW LEGNTH IN C

UPTFIT:	JSR PC,UPTLD
	CLR -(P)		;FLAG (ZERO IF IT FITS)
	SAVE <C,B>		;NEW LEGNTH AND UPT ADDRESS
	MOV UPTAR(B),A
	MOVB UPTAR+1(B),B
	BIC #177770,A		;OLD COMMON START
	ASH #-4,B
	BIC #177770,B		;OLD COMMON LEGNTH
	ADD A,B			;OLD TOP BLOCK
	ADD F,C			;NEW TOP BLOCK
	CMP A,F			;COMPARE OLD START AND NEW START
	BLE .+10		;OLD START IS OKAY
	INC 4(P)		;UPT MUST BE EXPANDED DOWN
	MOV F,A			;NEW START
	CMP B,C			;COMPARE OLD TOP AND NEW TOP
	BGE .+10		;OLD TOP IS OKAY
	INC 4(P)		;UPT MUST BE EXPANDED UPWARD
	MOV C,B			;NEW TOP BLOCK
	TST 4(P)		;DOES AR HAVE TO BE CHANGED?
	BEQ UPTF.1		;NO CHANGE
	SUB A,B			;NEW LEGNTH
	ASH #4,B
	SWAB B			;MAKE AN AR FROM THE NEW START AND LEGNTH
	BIS A,B			;SET IN THE START
	MOV B,2(P)		;RETURN THE AR IN REG. C
UPTF.1:	REST <B,C>
	TST (P)+		;SET CONDITION CODES
	RTS PC
;FLUSH UNTIL SOMETHING BECOMES AVAILABLE
MFLFPT:	SAVE <A>
	MOV #FPTFRE,A		;FLUSH UNTIL FPT IS AVAILABLE
	BR MFLUSH
MFLFUP:	SAVE <A>
	 MOV #FUPTFR,A		;FLUSH UNTIL FUPT IS AVAILABLE
MFLUSH:	JSR PC,LFLUSH		;FLUSH UNTIL @(A) IS NON ZERO
	TST (A)
	BEQ MFLUSH
	JSR PC,RUNME
	REST <A>
	RTS PC
;SET UP FPT FOR FA CAP (MFI IN ITEM2)
;(D)= FA CAP POINTER
;LOCK SWITCH TO TRY TO DELETE FPT WHEN UNLOCKED

MFMF.1:	JSR PC,MFLFPT		;WAIT FOR A FREE FPT
MFMFPT:	MOV FAFPN(D),F		;DOES A FPT FOR THIS PAGE ALREADY EXIST
	MOV MFIFPT(A),E		;LOOK DOWN LINKED LIST
	BEQ MFMF.3		;GO MAKE THE FPT
MFMF.2:	CMP F,FPTPNO(E)		;IS THIS WHAT WE WANT
	BEQ MFMF.6		;GOT IT
	MOV (E),E		;KEEP LOOKING
	BNE MFMF.2
MFMF.3:	MOV FPTFRE,E		;GET A FREE FPT
	BEQ MFMF.1		;FLUSH UNTIL ONE IS AVAILABLE
	MOV (E),FPTFRE		;LINK IT OUT OF FREE LIST
	MOV E,C			;SET UP THE FPT
	MOV MFIFPT(A),(C)+	;FPT LINK
	CLR (C)+		;SWAP ADDRESS
	MOV FAMFI(D),(C)+	;MFI NUMBER
	CLR (C)+		;UPT LINK
	MOV F,(C)+		;PAGE NUMBER
	CLR (C)+		;PFPT REFERENCE COUNT
	MOV MFLAGW(A),(C)
	BIC #<177400-MFIWSB>,(C)+
	MOV E,MFIFPT(A)		;LINK FPT TO MFI
	MOV #10,B
	MOV C,A
	CLR (A)+		;CLEAR SOURCE ADDRESSES
	SOB B,.-2
	JSR PC,MFIRDS		;INIT MFRDIS (F)=PAGE NUMBER
MFMF.4:	BEQ MFMF.7		;NONE LEFT
	MOV #10,B		;TRY TO GET AN ENTIRE PAGE OF BLOCKS
MFMF.5:	BIS #FPTBAS,F		;SET BLOCK AT SOURCE BIT
	MOV F,(C)+		;SET BLOCK NUMBER INTO SOURCE ADDRESS SLOT
	JSR PC,MFRDIS		;GET ANOTHER BLOCK NUMBER
	BEQ MFMF.6		;DONE BUT CHECK FOR LAST BLOCK
	SOB B,MFMF.5
MFMF.6:	MOV #LCKRTN,A
	CLR B			;LOCK SWITCH TO CLEAN UP FPT IF NECESSARY
	JSR PC,LOCKSW
	MOV #MFPC10,LCKWD1(A)
	MOV E,LCKWD2(A)		;FPT ADDRESS
	CLZ
	RTS PC			;RETURN SUCESSFULLY
MFMF.7:	JMP MFEOF		;THE PAGE DOESN'T EXIST
;INITIALIZE MFRDIS (F)=PAGE NUMBER TO SKIP TO
;ITEM2 CONTAINS MFI TO READ DISCRIPTOR OF

MFIRDS:	SAVE <A,B>
	CLR MFBKCT		;SET UP DATA FOR MFRDIS
	MOV #-1,MFBKNO
	CLR MFDIST
	MOV #ITM2AD+MFENHD,A	;FIND END OF DISCRIPTORS
	MOV (A),B
	BIC #177400,B
	ADD A,B
	MOV B,MFEND
	JSR PC,MFNDNM		;GET POINTER TO NAME
	TSTB (A)+		;SKIP PAST NAME
	BPL .-2
	MOV A,MFDPTR		;FIRST DISCRIPTOR BYTE
	ASH #3,F		;SKIP THIS MANY BLOCKS
	MOV F,A			;SAVE BLOCK COUNT
MFIR.3:	JSR PC,MFRDIS		;MUNCH A NEW DISCRIPTOR
	BEQ MFIR.6		;LOST
	TST A
	BEQ MFIR.5		;WON
	MOVB MFBKCT,B		;CHECK ON HOW MANY MORE ARE AVAILABLE
	CMP A,B
	BLE MFIR.4		;GOT ENOUGH
	DEC A			;WE JUST GOT ONE BLOCK
	SUB B,A			;SOME BUT NOT ENOUGH
	CLRB MFBKCT
	TSTB MFDIST
	BLT MFIR.3		;BLOCK NUMBER DOESN'T CHANGE IF HOLE IN FILE
	ADD B,MFBKNO		;UPDATE BLOCK NUMBER
	BR MFIR.3		;GET MORE
MFIR.4:	SUB A,B			;WE ONLY NEED TO SKIP (A) BLOCKS
	MOVB B,MFBKCT		;UPDATE BLOCK COUNT
	TSTB MFDIST
	BLT MFIR.5		;HOLE IN FILE
	ADD A,MFBKNO		;UPDATE BLOCK NUMBER
MFIR.5:	MOV MFBKNO,F		;RETURN THE BLOCK NUMBER IN F
	REST <B,A>
	CLZ			;SUCESSFUL RETURN
	RTS PC
MFIR.6:	REST <B,A>
	SEZ			;ENCONTERED END OF FILE
	RTS PC
;READS A DISCRIPTOR POINTED AT BY MFDPTR
;RETURNS NEXT BLOCK NUMBER IN F 
;INITIALIZED BY MFIRDS

MFRDIS:	SAVE <B>
	TSTB MFDIST
	BLT MFGS.2		;ITS A HOLE IN THE FILE
	INC MFBKNO
	DECB MFBKCT		;DECREMENT THE BLOCK COUNT
	BLT MFRD.2		;YOU CAN'T HAVE THAT BLOCK
MFRD.1:	MOV MFBKNO,F		;RETURN SUCESSFULLY
MFRD.0:	REST <B>
	CLZ
	RTS PC
MFRD.2:	CMP MFDPTR,MFEND	;NO BLOCKS LEFT TO COUNT
	BLO MFRD.4		;BUT THERE ARE MORE DISCRIPTOR BYTES
	DEC MFBKNO		;SET IT BACK TO LAST LEGAL BLOCK
MFRD.3:	REST <B>
	MOV MFBKNO,F		;FAILING RETURN
	CLRB MFBKCT
	RTS PC
MFRD.4:	MOVB @MFDPTR,F		;GET THE NEW DISCRIPTOR BYTE
	INC MFDPTR		;INCREMENT THE POINTER
	MOV F,B
	BIC #177477,B		;WHAT KIND OF DISCRIPTOR
	BIC #177700,F		;WITH WHAT BLOCK COUNT
 	ASH #-5,B
	CLRB MFBKCT
	MOVB B,MFDIST		;SAVE DISCRIPTOR TYPE
	JMP @MFDTAB(B)		;ONE OF FOUR TYPES

MFG1SK:	ADD F,MFBKNO		;SKIP AND GET ONE BLOCK
	CLR MFBKCT
MFRD.5:	MOVB MFBKCT,MFBKCT+1	;SAVE BLOCK COUNT FOR ADDBLK
	BR MFRD.1		;RETURN

MFSADD:	MOV MFDPTR,B		;SET ADDRESS AND GET SOME
	ADD #2,B		;THIS IS A THREE BYTE DISCRIPTOR
	CMP B,MFEND
	BUGC LOS,MFRD.3		;NO DISCRIPTOR LEFT
	MOV B,MFDPTR
	MOVB -(B),MFBKNO+1	;SET ADDRESS
	MOVB -(B),MFBKNO
	MOV F,MFBKCT		;GET THIS MANY BLOCKS
	BR MFRD.5		;RETURN

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

MFSKAG:	MOV F,B			;SKIP SOME AND GET SOME
	BIC #177770,B		;GET THIS MANY
	BIC #177707,F		;SKIP THIS MANY
	ASH #-3,F
	ADD F,MFBKNO
	MOV B,MFBKCT
	BR MFRD.5		;RETURN

MFGSOM:	BISB F,MFBKCT		;GET A BUNCH
	CMP #37,F
	BGE MFRD.5		;RETURN
	SUB #40,MFBKCT		;RON'S SKIP DISCRIPTOR
	MOVB MFBKCT,MFBKCT+1	;SAVE THE COUNT
	MOVB #-2,MFDIST		;SET SWITCH
MFGS.1:	MOV #-1,F		;INDICATES HOLE IN FILE
	BR MFRD.0		;RETURN
MFGS.2:	DECB MFBKCT		;COME HERE TO GIVE OUT HOLES
	BGE MFGS.1		;RETURN
	CMP MFDPTR,MFEND
	BLO MFRD.4		;NO DISCRIPTOR BYTES LEFT
	BR MFRD.3		;GET ANOTHER DISCRIPTOR

;PARSE ENTRY TO FIND WHERE NAME STARTS

MFNDNM:	SAVE B			;(A)= POINTER TO ENTRY
	MOV (A)+,B		;HEADER WORD
	TST (A)+		;SKIP VERSION NUMBER
	ROL B			;NOW TEST BITS IN HEADER WORD
	BCC .+6
	ADD #10,A		;SKIP EOF DATE AND TIME
	ROL B
	BCC MFND.2
MFND.1:	ADD #2,A		;SKIP ACCESS CODES
	TSTB (A)+
	BLT MFND.1		;MORE ACCESS CODES?
MFND.2:	REST B
	RTS PC			;DONE
;PUT A MFI INTO THE HASH TABLE

MFHASH:	JSR B,MFHASS		;GET HASH CODE INTO REG F
	MOV MFHTAB(F),MFHLNK(A)	;LINK IT IN
	MOV ITEM2,MFHTAB(F)
	INC MFREF(A)		;INCREMENT THE REFERENCE COUNTS
	INC MFPREF(A)
	REST <F,E,B>		;RETURN
	RTS PC

MFHASS:	SAVE <E,F,B>		;PUT THE HASH CODE INTO REG. F
	MOV #ITM2AD+MFENHD,A
	JSR PC,MFNDNM		;FIND WHERE NAME STARTS
	CLR F			;PUT HASH CODE IN HERE
MFHS.1:	MOVB (A)+,E
	XOR E,F
	BPL MFHS.1		;NAME ENDS WITH NEG. BYTE
	BIC #177741,F		;CLEAR UNNECESSARY BITS
	MOV ITM2A,A		;RESTORE REG A
	RTS PC
;TAKE A MFI OUT OF THE HASH TABLE (IT'S IN ITEM2)

MFUNHS:	JSR B,MFHASS		;PUT HASH CODE INTO REG. F
	MOV A,E			;SAVE POINTER TO MFI
	MOV ITEM1,A
	JSR PC,ITM1PL		;PUSH THE ITEM FOR THE SEARCH LOOP
	MOV F,A
	ADD #MFHTAB,A		;LOOK IN THE HASH TABLE
MFUN.2:	CMP (A),ITEM2
	BEQ MFUN.3		;THIS IS THE MFI WE WANT
	MOV (A),A		;CONTINUE LINKING THROUGH LIST
	JSR PC,ITM1LD
	ADD #MFHLNK,A
	BR MFUN.2		;GO TO TOP OF SEARCH LOOP
MFUN.3:	MOV MFHLNK(E),(A)	;UNLINK THE MFI
	JSR PC,ITM1PO		;CLEAN UP THE ITEM STACK
	MOV E,A
	DEC MFREF(A)		;DECREMENT THE REFERENCE COUNTS
	DEC MFPREF (A)
	REST <F,E,B>
	RTS PC			;RETURN
;DELETE A FPT (IF NO UPT'S ARE ATTACHED)
;AND REFFERENCE COUNT IS ZERO
;ADDRESS IN E

FPTD.1:	MOV (A),A		;LOOK FURTHER DOWN LINKED LIST
	BUGC NE
	ADD #FPTLNK,A
	BR FPTD.3

FPTDEL:	SAVE <A>
	TST FPTUPT(E)
	BNE FPTD.4		;STOP UPTS HANG HERE
	BIT #FPTLKB,FPTFLG(E)
	BNE FPTD.4		;STOP SOMEONE IS ADDING A UPT
	MOV FPTSWA(E),B
	BEQ FPTD.2		;NO SWAP SPACE
	JSR PC,DSWPAL		;RELEASE THE SWAP BLOCK
FPTD.2:	MOV FPTMFI(E),A
	BEQ FPTD.4		;NO MFI EXISTS
	JSR PC,ITM2PL		;LOAD THE MFI
	ADD #MFIFPT,A		;NOW LINK IT OUT OF THE LIST
FPTD.3:	CMP (A),E		;DOES IT POINT TO ME
	BNE FPTD.1
	MOV FPTLNK(E),(A)	;LINK OUT FPT
FPTD.5:	MOV FPTFRE,FPTLNK(E)	;LINK INTO FREE LIST
	MOV E,FPTFRE
	JSR PC,ITM2PO		;POP THE MFI
FPTD.4:	REST <A>		;RETURN
	RTS PC
;DELETE FAUPT(D) AND CLEAN UP FPT
;(A)= ADDRESS OF MFI IN ITEM2
;IF ENTERED AT MFUPTK DON'T TRY TO PUT IT IN SLOT

MFUPTD:	BIT #MFOPNB,MFLAGW(A)
	BNE MFUPTK		;SLOT IS RESERVED
	TST MFIUPT(A)
	BNE MFUPTK		;SLOT IS FULL
	MOV FAUPT(D),MFIUPT(A)	;PUT IT IN SLOT
	BR MFUD.1		;RETURN
MFUPTK:	MOV FAUPT(D),B
	BEQ MFUD.2		;NO UPT
	JSR PC,UPTDEL		;RETURN FPT ADDRESS IF IT WAS LAST UPT
	TST B			;SHOULD WE DELETE THE FPT
	BEQ MFUD.1		;RETURN
	SAVE <E>
	MOV B,E
	JSR PC,FPTDEL		;TRY TO DELETE THE FPT
	REST <E>
MFUD.1:	CLR FAUPT(D)		;CLEAR OUT THE SLOT
MFUD.2:	RTS PC
;PCL ROUTINE TO DELETE A MFI IN ITEM2 (MFREF=0 -> NOT IN HASH TABLE)

MFDELP:	MOV ITM2A,A
	TST MFREF(A)		;NOT IN HASH TABLE IF ZERO
	BEQ .+6
	JSR PC,MFUNHS		;REMOVE IT FROM HASH TABLE
	MOV MFIFPT(A),E		;DELETE THE FPT WHICH MAY HANG HERE
	BEQ MFDP.2		;NO FPT HANGS HERE
	MOV FPTUPT(E),B		;DELETE THE FUPT WHICH MAY HANG ON THIS FPT
	BEQ MFDP.1		;NO FUPT ON THIS FPT
	JSR PC,CORFRE		;DESTROY THIS CORE BEFORE READING
	ADD #<100000+FUPTTB>,B
	MOV FUPTFR,(B)
	MOV B,FUPTFR		;RELEASE FUPT
	CLR FPTUPT(E)
MFDP.1:	JSR PC,FPTDEL		;DELETE FPT
MFDP.2:	BIT #MFDWDB,MFLAGW(A)	;IS THIS A DELETE WHEN DONE FILE
	BEQ MFDP.3
	JSR PC,RLSBLK		;FREE DISK BLOCKS
MFDP.3:	MOV ITEM2,A
	JMP DLITEM		;DELETE THE ITEM AND RETURN
;RELEASE THE BLOCKS OF THIS MFI'S DISCRIPTOR AND DELETE DIRID ENTRY
RLSBLK:	MOV ITM2A,C		;MFI ITEM #
	BIT #MFSHRB,MFENHD(C)
	BNE RLSB.3		;SHARED BLOCKS DON'T DELETE
	MOV MFLAGW(C),B		;LOOK UP THE BIT AND DIRID FUPTS IN TABLE
	BIC #177600,B		;SAVE THE GIPS
	SAVE <MFBITS(B),MFDIRD(B)>
RLSB.5:	MOV 2(P),B		;GIP TO BIT TABLE
	JSR PC,SWPIN		;GET BIT TABLE
	BIT #MFDIRB,MFLAGW(A)
	BEQ RLSB.4		;SKIP THIS IF A FILE
	MOV (P),B		;DELETE THE DIRID ENTRY
	JSR PC,SWPIN		;SWAP DIRID TABLE IN
	MOV 2(P),B		;BITS GIP
	JSR PC,UPTPLD
	BIT #UPTICR,UPTAR(B)	;IS BITS STILL HERE?
	BEQ RLSB.5		;UGH TRY AGAIN
	JSR PC,ITM2PO		;UPTPLD PUSHED THIS
	MOV (P),A		;DIRID GIP
	MOV A,B
	JSR PC,UPTPLD		;LOAD FUPT TO SET WRITTEN ON BIT
	BIS #UPTMOD!UPTWON,UPTDR(B)
	JSR PC,ITM2PO		;UPTPLD PUSHED THIS
	JSR PC,ITM1PL		;LOAD DIRID AND ZERO ENTRY
	CMP ITM2AD+MFVERN,(A)+	;FIND THE DIRID NUMBER
	BNE .-4			;UGH MAKE THIS BINARY SEARCH
	CLR -(A)		;ZERO ENTRY
	JSR PC,ITM1PO
	MOV 2(P),B		;BITS GIP
RLSB.4:	CMP (P)+,(P)+		;NOW FREE THE DISK BLOCKS
	MOV B,A
	JSR PC,UPTPLD
	BIS #UPTMOD!UPTWON,UPTDR(B)	;SET FUPT WRITTEN ON BIT
	JSR PC,ITM2PO		;UPTPLD PUSHED THIS
	JSR PC,ITM1PL		;LOAD IT UP
	TST (A)+		;FIRST WORD IS SIZE OF TABLE
	CLR F
	JSR PC,MFIRDS		;GET  FIRST BLOCK #
	BEQ RLSB.6		;NO MORE BLOCKS
	SAVE <E,C>
	MOV ITM2AD+MFLAGW,C
	BIC #177600,C
	ADD #MFREBK,C		;MUST UPDATE FREE BLOCK COUNT IN TABLE
RLSB.1:	CMP #-1,F
	BEQ RLSB.2		;IT A HOLE SKIP IT
	MOV F,E			;COMPUTE OFSET AND BIT MASK
	ASH #-3,E
	ADD A,E			;BYTE ADDRESS
	BIC #177770,F
	BICB BMT(F),(E)		;CLEAR BIT TABLE
	INC (C)			;DECREMENT FREE BLOCK COUNT
RLSB.2:	JSR PC,MFRDIS		;GET ANOTHER BLOCK AND CONTINUE
	BNE RLSB.1
	REST <C,E>
RLSB.6:	MOV ITEM1,B		;NOW SWAP OUT THE BIT TABLE
	JSR PC,ITM1PO		;POP BIT TABLE
	JSR PC,SWPOT
RLSB.3:	RTS PC
;DECREMENT MAIN REFERENCE COUNT ONLY AND DELETE ITEM IF ZERO
;SET C IF YOU DELETE THE MFI
;(A)= ITEM NUMBER

MFID.1:	JSR PC,LFLUSH		;WAIT FOR BIT TO CLEAR
	JSR PC,RUNME
	BR MFID.2
MFIDLP:	MOV A,C			;SAVE ITEM NUMBER
	MOV #MFOPNB,B
	JSR PC,ITM2LD		;LOAD UP MFI
MFID.2:	CCC
	DEC MFREF(A)
	BNE MFID.6		;DONE
	INC MFREF(A)		;IN CASE OF PCL
	BIT B,MFLAGW(A)
	BNE MFID.1		;WAIT FOR BIT TO CLEAR
	BIT #MFDWDB,MFLAGW(A)
	BEQ MFID.7		;CHECK PARENT DIRECTORY
	MOV #MFLAGW,A		;THIS IS A DELETE WHEN DONE FILE
	JSR PC,LCKASW		;LOCK THE MFI (ALREADY KNOW THE BIT IS FREE) AND
MFID.3:	JSR PC,RLSBLK		;RELEASE THE DISK BLOCKS
MFID.4:	JSR PC,LSWPOP		;UNLOCK THE MFI
MFID.5:	JSR PC,MFUNHS		;REMOVE FROM HASH TABLE
	MOV ITEM2,A
	JSR PC,DLITEM		;DELETE THE ITEM
	CCC
	SEC			;INDICATES WE DELETED THE MFI
MFID.6:	RTS PC			;DONE
MFID.7:	BIT #MFDIRB,MFLAGW(A)	;IF A FILE FIX UP PARENT REFERENCE COUNTS
	BNE MFID.5		;NO NEED TO MUNG DIRECTORIES FURTHER
	MOV MFBAKP(A),A
	JSR PC,ITM2PL		;LOAD UP PARENT DIRECTORY MFI
	CMP #1,MFREF(A)
	BLO MFID.9		;JUST DECREMENT THE COUNTS
	JSR PC,MFID.5		;UNHASH AND DELETE THE PARENT MFI
MFID.8:	JSR PC,ITM2PO
	BR MFID.5		;NOW UNHASH AND DELETE THE FILE
MFID.9:	DEC MFREF(A)		;DECREMENT THE PARENT'S COUNTS
	DEC MFPREF(A)
	BR MFID.8		;FINISH OFF THE FILE
;DECREMENT BOTH REFERENCE COUNTS OF MFI AND CLOSE FILE IF MFPREF IS ZERO
;CLOSE PARENT DIRECTORY IF APPROPRIATE
;SET C IF DELETED THE MFI AND SET Z IF FAILED
;(D)= CAPABILITY TO FILE (CLEAR ITS UPT SLOT)

MFDL.0:	JSR PC,LFLUSH		;WAIT FOR MFOPNB TO CLEAR
	JSR PC,RUNME
	BR MFIDEL
MFDL.1:	JSR PC,MFUPTD		;DELETE FUPT
MFIDEL:	MOV FAMFI(D),A
	JSR PC,ITM2LD		;LOAD UP THE MFI
	CMP #1,MFPREF(A)
	BHIS MFDL.3		;CLOSE FILE
	TST FAUPT(D)		;IS THE CAPABILITIES SLOT EMPTY
	BNE MFDL.1		;DELETE IT
MFDL.2:	DEC MFPREF(A)
	DEC MFREF(A)		;DECREMENT COUNTS AND WIN
	RTS PC
MFDL.3:	MOV #MFOPNB,B		;CLOSE THE MFI
	BIT B,MFLAGW(A)
	BNE MFDL.0		;WAIT FOR EXCLUSIVE USE OF MFI
	MOV #MFLAGW,A
	MOV ITEM2,C
	JSR PC,LCKASW		;NOW ONLY ONE CAP CAN EXIST
	MOV ITM2A,A		;AND WE HAVE IT HERE
	BIT #MFDWDB,MFLAGW(A)	;IS IT A DELETE WHEN DONE FILE
	BEQ MFDL.5		;BRANCH IF NOT
	JSR PC,MFUPTD		;KILL FUPT
	MOV MFIUPT(A),FAUPT(D)	;CLEAN OUT THE SLOT ALSO
	CLR MFIUPT(A)
	JSR PC,MFUPTK
	CMP #1,MFREF(A)		;SHOULD THE MFI BE DELETED
	BHIS MFID.3		;RELEASE BLOCKS, POP SWITCH, UNHASH  AND DELETE MFI
MFDL.4:	JSR PC,LSWPOP		;DON'T DELETE IT
	BR MFDL.2		;DEC COUNTS AND RETURN

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

MFDL.5:	BIT #MFDIRB,MFLAGW(A)	;CLOSE A FILE/DIRECTORY
	BEQ MFDL10		;FILES ARE TRICKIER
	BIT #MFEBMB,MFLAGW(A)	;HAS THE ENTRY BEEM MUNGED
	BEQ MFDL.6		;NO NEED TO CHANGE DIRECTORY
	JSR PC,DKDRIO		;SWAP IN DIRECTORY
	BEQ MFDL.9		;FAILED
	JSR PC,LSWPOP		;CLEAR FUPT PROCESS POINTER
	MOV ITM1A,B		;DIR. ENTRY TO BE CHANGED IS SELF ENTRY
	MOV FAMFI(D),C		;MFI # OF ENTRY BEING WRITTEN
	JSR PC,MFENWT		;REWRITE THE SELF ENTRY
	SAVE PS			;FOR CONDITIONS
	MOV FAMFI(D),A		;THE MFI
	JSR PC,ITM2LD		;LOAD IT	
	REST PS			;GET BACK COND
	BEQ MFDL.9		;FAILED
	BMI MFDL.5		;DIR. WAS ENLARGED TRY AGAIN
MFDL.6:	JSR PC,MFUPTD		;KILL FUPT
	MOV MFIUPT(A),FAUPT(D)	;CLEAN OUT SLOT ALSO
	CLR MFIUPT(A)
	JSR PC,MFUPTK		;DELETE FUPT
	CMP #1,MFREF(A)
	BLO MFDL.4		;DEC COUNTS AND RETURN
	JMP MFID.4		;POP SWITCH, UNHASH AND DELETE MFI

MFDL.8:	TST (P)+
	JSR PC,LSWPOP		;RESTORE CAPABILITY
MFDL.9:	JSR PC,LSWPOP		;UNLOCK MFI
	SEZ
	RTS PC			;FAILED

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE
				;FILE ENTRY MUST BE WRITTEN INTO PARENT DIRECTORY
MFDL10:	JSR PC,MFUPTK		;KILL THE UPT'S FOR THIS FILE
	MOV MFIUPT(A),FAUPT(D)	;GET THE ONE IN THE MFI TO
	CLR MFIUPT(A)		;CLEAR OUT THE SLOT
	JSR PC,MFUPTK		;KILL THEM ALL
	JSR PC,MFAMUT		;LOCK SWITCH TO UNMUTATE CAP.
	SAVE <ITEM2>		;MFI # OF ENTRY BEING CHANGED
MFDL11:	MOV ITM2A,B
	MOV MFBAKP(B),FAMFI(D)	;NOW MUTATE THE CAPABILITY
	BIT #MFEBMB,MFLAGW(B)	;THAT WAS EASY
	BEQ MFDL12		;ENTRY NOT CHANGED SO SKIP ALL THIS
	ADD #MFENHD,B
	JSR PC,DRLOOK		;FIND THE ENTRY IN THE DIR.
	BEQ MFDL.8		;FAILED
	BUGC PL,MFDL.8		;ENTRY NOT THERE !!??
	MOV A,B			;POINTS TO ENTRY TO BE CHANGED
	MOV (P),C		;MFI # OF ENTRY BEING REWRITTEN
	JSR PC,MFENWT		;REWRITE THE ENTRY
	BEQ MFDL.8		;FAILED
	BPL MFDL12		;GOT IT
	MOV (P),A		;MFI # OF ENTRY BEING CHANGED
	JSR PC,ITM2LD		;THE DIRECTORY WAS ENLARGED SO
	BR MFDL11		;TRY AGAIN
MFDL12:	REST <A>		;MFI # OF FILE BEING CLOSED
	JSR PC,ITM2LD
	JSR PC,MFUPTD		;KILL FUPT
	MOV MFIUPT(A),FAUPT(D)	;CLEAN OUT MFI UPT SLOT
	CLR MFIUPT(A)
	CMP MFREF(A),#1
	BHI MFDL13		;FILE NOT GOING TO BE DELETED
	JSR PC,MFIDEL		;FIX UP PARENT'S REFERENCE COUNT
	JSR PC,LSWPOP		;RESTORE CAPABILITY
	MOV FAMFI(D),A		;LOAD UP FILE MFI
	JSR PC,ITM2LD		;AND NOW KILL IT
	JMP MFID.4		;POP SWITCH, UNHASH AND DELETE MFI
MFDL13:	JSR PC,MFUPTK		;KILL FUPT
	JSR PC,LSWPOP		;RESTORE CAPABILITY
	MOV FAMFI(D),A		;RELOAD THE FILE MFI
	JSR PC,ITM2LD
	JMP MFDL.2		;DECREMENT COUNTS AND RETURN
;ROUTINE TO REWRITE ENTRY IN DIRECTORY
;(B)= POINTER TO ENTRY TO BE CHANGED (FUPT FOR DIRECTORY IS IN FAUPT(D))
;(C)= ITEM # OF MFI WHOSE ENTRY IS BEING CHANGED
;(D)= CAPABILITY TO DIRECTORY THE ENTRY RESIDES IN
;SEZ IF FAILED     SEN IF DIRECTORY ENLARGED AND RESTART NEEDED

MFENWT:	MOV FAUPT(D),A		;THE DIRECTORY
	JSR PC,ITM1PL		;LOAD IT UP
	MOV C,A
	JSR PC,ITM2LD		;LOAD MFI WITH ENTRY WE WANT
	MOV MFENHD(A),E
	INC E			;ROUND IT UP
	BIC #177401,E		;MAKE IT WORDS
	MOV (B),F		;THE OLD LENGTH
	JSR PC,ITM1PO		;POP IT
	INC F
	BIC #177401,F		;ROUND IT
	SUB F,E			;THE DELTA LENGTH IN WORDS
	BEQ MFEN.4		;NO NEED TO ADD ANYTHING
	JSR PC,MFDRSZ		;MAKE DIRECTORY THE CORRECT SIZE
	BLE MFEN.3		;WE WERE FLUSHED OR FAILED
	MOV FAMFI(D),A		;THE DIRECTORY MFI
	JSR PC,ITM2LD		;LOAD IT UP
	TST F			;BYTES STILL LEFT IN DIRECTORY
	BNE .+10
	BIC #MFLSTB,MFENHD(A)	;USED IT ALL UP
	MOV MFBYTP(A),F		;OLD EOF
	ADD E,F			;NEW EOF
	MOV F,MFBYTP(A)
	BIT #20000,F
	BEQ MFEN.1		;SITLL LESS THAN ONE PAGE LONG
	CLR MFBYTP(A)		;OVERFLOWED BYTE POINTER
	MOV #1,MFPGNO(A)
MFEN.1:	BIS #MFEBMB,MFLAGW(A)	;WE JUST MUNGED IT
	ADD ITM1A,F		;ABSOLUTE NEW EOF
	MOV FAUPT(D),A
	JSR PC,ITM1PL		;LOAD DIRECTORY
	MOV ITM2A,A		;POINT TO THE MFI OF THE DIR
	MOV MFBYTP(A),ITM1AD+MFBYTP-MFENHD	;SET IN THE EOF POINTER
	MOV MFPGNO(A),ITM1AD+MFPGNO-MFENHD
	MOV (B),A		;LEGNTH OF CURRENT ENTRY
	INC A
	BIC #177401,A		;ROUND UP TO WORD BOUNDARY
	NEG A			;SUBTRACT THIS LEGNTH SINCE THIS ENTRY DOESN'T MOVE
	ADD F,A			;ADD ABSOLUTE EOF
	SUB B,A			;SUBTRACT ABSOLUTE START OF CURRENT ENTRY
	ASR A			;WORD COUNT OF TOP OF DIRECTORY TO BE MOVED
	NEG E			;MAKE A TRICKY SUBTRACT
	ADD F,E			;ABSOLUTE OLD EOF
	MOV -(E),-(F)		;MOVE THE TOP OF THE DIRECTORY
	SOB A,.-2
	MOV C,A
	JSR PC,ITM2LD		;LOAD THE ENTRY'S MFI
MFEN.2:	MOV #ITM2AD+MFENHD,A	;POINTS TO ENTRY IN MFI
	MOV (A),E
	BIC #177400,E
	INC E			;ROUND UP TO WORD BOUNDARY
	ASR E			;ENTRY LEGNTH
	DEC E			;CAUSE WE WILL DO SOME HACKERY WITH TYPE
	SAVE (A)+		;SKIP THE TYPE
	BIC #7000,(P)		;CLEAR THE TYPE OF MFI'S (DIRECTORY HAS CORRECT TYPE)
	BIC #170777,(B)		;LEAVE ONLY THE DIRECTORY TYPE
	BIS (P)+,(B)+		;SET IN THE FLAGS BUT NOT THE TYPE
	MOV (A)+,(B)+		;DO IT
	SOB E,.-2
	MOV ITM2A,A
	BIC #MFEBMB,MFLAGW(A)	;WE JUST UNMUNGED IT
	JSR PC,ITM1PO
	JSR PC,MFSETW		;SET WRITTEN ON BIT IN FUPT
	CLZ
MFEN.3:	RTS PC
MFEN.4:	MOV FAUPT(D),A		;THE SIZE OF THE ENTRY DIDN'T CHANGE
	JSR PC,ITM1PL		;LOAD DIRECTORY
	BR MFEN.2		;NOW REWRITE THE ENTRY
;MAKE DIRECTORY LARGE ENOUGH FOR (E) MORE BYTES
;(D)= CAP TO DIRECTORY
;(E)= NUMBER OF BYTES TO BE ADDED
;(F)= RETURN BYTES STILL LEFT AFTER APPENDING HERE
;SEN IF FLUSHED (ADDING BLOCKS)  SEZ IF FAIL

MFDRSZ:	CLR -(P)
	SAVE <A,ITEM2,B,C,D,E,E>		;SAVE FLAG AND REGISTERS
	MOV FAMFI(D),A
	JSR PC,ITM2LD			;LOAD DIRECTORY MFI
	TST MFPGNO(A)
	BEQ MFDRS2			;CAN'T ADD MORE IF IT IS ALREADY ONE PAGE
MFDRS1:	MOV #.FADIF,ITM0AD+PERRW	;NO MORE DIRECTORY SPACE
	BR MFDRS3			;RETURN TO FAILURE
MFDRS2:	CLR E				;BLOCK COUNTER
	CLR F				;PAGE NUMBER
	JSR PC,MFIRDS
	INC E				;COUNT BLOCKS IN DIRECTORY
	JSR PC,MFRDIS
	BNE .-6
	SWAB E				;CHANGE BLOCK TO BYTE COUNT
	ASL E
	ASL E
	MOV E,F				;NOW SIZE OF DIRECTORY IN BYTES
	SUB MFBYTP(A),E			;SUBTRACT BYTES USED
	SUB E,(P)			;SUBTRACT HOW MANY WE WANT
	BGT MFDRS4			;NOT ENOUGH ENLARGE DIRECTORY
	INC 16(P)			;SET FLAG FOR GOOD RETURN
MFDRS3:	REST <F,E,D,C,B,A>
	JSR PC,ITM2LD
	REST A
	TST (P)+			;SET CONDITION CODES
	RTS PC
MFDRS4:	CMP #20000,F
	BEQ MFDRS1			;EXCEEDS MAXIMUM SIZE FOR DIRECTORY
	MOV FAMFI(D),B			;ITEM NUMBER OF DIRECTORY
	MOV #LCKRTN,A
	JSR PC,LOCKSW			;LOCK SWITCH TO RESTORE EOF WORDS
	MOV A,B
	MOV ITM2A,A			;POINTS AT MFI OF DIRECTORY TO BE ENLARGED
	MOV MFBYTP(A),LCKWD2(B)
	MOV #MFPCL6,LCKWD1(B)		;SETS MFLSTB AND MFBYTP WHEN POPPED
	BIT #MFLSTB,MFENHD(A)
	BNE .+10
	MOV #MFPCL5,LCKWD1(B)		;CLEARS BIT AND RESTORES MFBYTP
	MOV F,MFBYTP(A)			;SET EOF TO PHYSICAL END OF DIRECTORY
	BIC #MFLSTB,MFENHD(A)		;SO ADDBLK WILL ADD THE BLOCK
	JSR PC,ADDBLK			;DO IT
	BEQ MFDRS5			;FAILED
	DEC 16(P)			;INDICATE WE ENLARGED THE DIRECTORY
	JSR PC,LSWPOP			;RESTORE MFBYTP
	BIS #MFLSTB,ITM2AD+MFENHD	;LSWPOP MIGHT HAVE CLEARED IT
	BR MFDRS3			;RETURN
MFDRS5:	JSR PC,LSWPOP			;RESTORE MFBYTP
	BR MFDRS3			;RETURN TO FAILURE
;SETS WRITTEN ON BIT IN FAUPT(D)

MFSETW:	SAVE <B>
	MOV FAUPT(D),B
	JSR PC,UPTPLD			;LOAD UP FUPT
	BIS #UPTMOD!UPTWON,UPTDR(B)	;SET THE BIT
	REST <B>
	JMP ITM2PO			;POP UPT AND RETURN

;LOCK SWITCHES TO RESTORE FAMFI OF CAP.

MFAMUT:	SAVE <A,B,D>
	MOV #LCKRTN,A			;CLOSE A FILE
	MOV ITEM1,B
	CMP D,#PDL			;IS THE CAPABILITY ON THE PDL (MSDEL)
	BHI .+4				;NO
	CLR B
	JSR PC,LOCKSW			;LOCK SWITCH TO UNMUTATE CAP.
	MOV #MFPCL9,LCKWD1(A)
	MOV FAMFI(D),LCKWD2(A)		;MFI #
	MOV #LCKRTN,A
	CLR B
	JSR PC,LOCKSW			;THIS SWITCH UNLOCKS THE OTHER
	MOV #MFPCL8,LCKWD1(A)
	CMP D,#PDL			;IS IT ON THE PDL
	BLO .+6				;YES, THE ADDRESS IS CORRECT
	SUB ITM1A,D
	MOV D,LCKWD2(A)			;RELATIVE ADDRESS OF CAPABILITY
	REST <D,B,A>
	RTS PC
;GET A BYTE OR WORD FROM USERS DATA SPACE
;(E)= PTR.
;(C)= WHERE BYTE IS RETURNED (INC E ALSO)
GETBYT:	MOV E,C
	BIC #1,C
	MFPD (C)
	REST <C>
	BIT #1,E
	BEQ .+4
	SWAB C
	INC E
	BIC #177400,C
	RTS PC

GETWRD:	JSR PC,GETBYT
	SAVE <C>
	JSR PC,GETBYT
	SWAB C
	BISB (P)+,C
	RTS PC
;MAKE A MFI
;COPY ENTRY FROM DIRECTORY TO MFI AND FIX MFDIRB
;THEN IF IT IS A DIRECTORY GET THE SELF ENTRY
;(A)= ADDRESS OF ENTRY TO OPEN (IN ITEM1)
;(D)= FA PTR.
:PUT MFI IN ITEM2 (MOST THINGS FILLED BY DIRENT)

MAKMFI:	MOV (A),E			;HEADER WORD
	MOV E,B
	BIC #170777,B
	BIC #177400,E
	INC E
	ASR E				;ENTRY SIZE IN WORDS
	MOV #ITM2AD+MFENHD,C
	MOV (A)+,(C)+			;MOVE THE ENTRY
	SOB E,.-2
	JSR PC,ITM1PO			;POP DIRECTORY
	MOV ITM2A,C
	CMP #MFFILE,B
	BEQ MAKM.2			;IT'S A FILE
	CMP #MFDIRE,B
	BUGC EQ,MAKM.4			;NOT A FILE OR DIRECTORY??
	BIS #MFDIRB!MFIWSB,MFLAGW(C)
MAKM.2:	JSR PC,MFHASH			;HASH IT IN
	BIT #MFDIRB,MFLAGW+ITM2AD
	BEQ MAKM.3
	CLR A				;THE DIRECTORY ALREADY EXISTS
	JSR PC,MFOPEN			;OPEN A DIRECTORY
	BEQ MAKM.4
MAKM.3:	JSR PC,MFIEXP			;TRIM THE MFI
	CLZ
	RTS PC
MAKM.4:	JSR PC,MFDELP			;WE LOST CLEAN UP
	SEZ
	RTS PC
;OPEN MFI IN ITEM2
;MAP THE FIRST BLOCK OF A FILE INTO ITEM1 WITHOUT FA CAP
;ONLY WORKS WITH EVERYONE ELSE LOCKED OUT
;MFDELP ROUTINE SHOULD RUN IF PCLOSERED
;PUT RESULTING FUPT INTO SPECIAL SLOT IN MFI AND FIX UP FPT
;IF (A) = 0  THEN DIRECTORY ALREADY EXISTS ELSE IT IS BEING CREATED

MFOPEN:	SAVE <A,D>			;FLAG (IF ZERO DIRECTORY EXISTS)
	MOV ITEM2,A
	CLR -(P)			;PUSH A FA CAP ON STACK
	CLR -(P)
	CLR -(P)
	SAVE <A>			;MFI NUMBER
	CLR -(P)
	MOV P,D				;POINTER TO FA CAP
	MOV #-1,F
	CLR E
	JSR PC,DKURIO			;SET UP FUPT
	BEQ MFOP.1
	JSR PC,ITM2LD
	MOV A,B
	ADD #6,P
	REST <A>			;GIP
	TST (P)+
	MOV A,MFIUPT(B)			;SAVE FUPT IN MFI'S SLOT
	JSR PC,ITM1PL
	ADD #MFENHD,B
	REST <D>
	TST (P)+
	BNE MFOP.3			;THIS DIRECTORY DOESN'T EXIST YET
	MOV (A),C
	BIC #177400,C
	INC C				;ROUND UP TO WORD BOUNDARY
	ASR C
	MOV (A)+,(B)+			;MOV SELF ENTRY INTO MFI
	SOB C,.-2
	MOV (A),F
	INC F				;ROUND UP TO WORD BOUNDARY
	BIC #177401,F			;LEGNTH OF PARENT ENTRY
	ADD F,A
	SUB ITM1A,A			;SUMMED LEGNTH OF SELF AND PARENT ENTRIES
	CMP A,ITM2AD+MFBYTP
	BLT MFOP.2			;DIRECTORY NOT EMPTY
	TST ITM2AD+MFPGNO
	BNE MFOP.2			;NOT EMPTY
	BIS #MFDMTB,ITM2AD+MFLAGW
MFOP.2:	JSR PC,ITM1PO
	JSR PC,LSWPOP			;FLUSH DIRECTORY
	CLR F
	JSR PC,MFPTFX			;FIX UP FPT
	CLZ
MFOP.3:	RTS PC
MFOP.1:	ADD #12,P
	REST <D,A>
	SEZ
	RTS PC

;FIX UP FPT WITH PAGE NUMBER IN F (AFTER ADDING BLOCKS)

MFPTFX:	MOV #ITM2AD+MFIFPT-FPTLNK,A
MFPX.1:	MOV FPTLNK(A),A		;REALLY MFIFPT(A)
	BEQ MFPX.4		;DONE
	CMP FPTPNO(A),F
	BNE MFPX.1		;KEEP LOOKING
	ADD #FPTSRC,A
	MOV #10,C
	JSR PC,MFIRDS		;GET THE FIRST BLOCK
	BR .+6
MFPX.2:	JSR PC,MFRDIS
	BEQ MFPX.4		;DONE
	MOV (A)+,B
	BIC #100000,B
	BIC #100000,F
	CMP B,F
	BEQ MFPX.3		;DON'T CHANGE ANYTHING YET
	BIS #100000,F
	MOV F,-2(A)
MFPX.3:	SOB C,MFPX.2
MFPX.4:	RTS PC
;START CREATING A MFI FOR USER'S DATA (MAKMFI FINISHES THE JOB)
;PUT NAME AND VARIOUS DATA WORDS INTO AN ITEM (LOAD ITEM2)
;RETUN IN (B) HASH CODE OF FILE NAME
;RETURN IN (C) TERMINATOR CHARACTOR
;(D)= FA CAPABILITY OR ZERO
;(E)= USER'S CORE POINTER
;(F)= USERS FLAGS

DIRENT:	JSR PC,MAKITM			;MAKE AN ITEM AND LOCK SWITCH
	CLR B				;XOR HASH CODE INTO HERE
	CLR -(P)			;FLAG SET IF A SPACE IS FOUND
	ADD #MFENHD,A
	CLR (A)+			;HEADER WORD
	MOV #-3,(A)+			;INDICATES NO VERSION NUMBER SPECIFIED
	ADD #10,A			;SKIP EOF DATE AND TIME WORDS
DIRE.0:	JSR PC,GETBYT
	BEQ DIRE.8			;ZERO FOUND
	CMPB C,#' 			;IS IT A SPACE
	BEQ DIRE.0			;SKIP PRECEDING SPACES
DIRE.1:	CMPB C,#'"
	BEQ DIRE.3			;QUOTED CHAR.
DIRE1A:	CMPB C,#' 			;IS IT A SPACE
	BNE DIRE1B
	INC (P)				;FOUND SPACE SET FLAG
	JSR PC,GETBYT			;SKIP SPACES BETWEEN NAME AND POSSIBLE VERSION #
	BEQ DIRE.6			;DONE
	BR DIRE1A
DIRE1B:	CMPB C,#'>
	BEQ DIRE.5			;GREATER THAN CONVENTION
	CMPB C,#'<
	BEQ DIRE5A			;LESS THAN CONVENTION
	CMPB C,#'#
	BNE DIRE3A
	SAVE <D>
	CLR D				;COMPUTE VERSION NUMBER IN HERE

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

DIRE.2:	JSR PC,GETBYT			;GET A DIGIT
	BEQ DIRE2B			;DONE
	SUB #60,C			;CONVERT ASCII TO OCTAL
	BLT DIRE2A			;TERMINATOR CHARACTER
	CMP #12,C
	BLE DIRE2A			;TERMINATOR CHARACTER
	MUL #12,D			;PROCESS ANOTHER DIGIT
	BVS DIRE.7			;OVERFLOW
	ADD C,D
	BR DIRE.2			;GET ANOTHER DIGIT
DIRE2A:	ADD #60,C			;FIX UP TERMINATOR CHAR.
DIRE2B:	MOV D,ITM2AD+MFVERN		;STORE VERSION NUMBER
	REST <D>
	BR DIRE.6			;NOW CHECK WHAT WE GOT

DIRE.7:	REST <D>
DIRE.8:	MOV #.FABFN,ITM0AD+PERRW	;ILLEGAL FILE NAME ERROR
	TST (P)+
	MOV ITEM2,A
	JSR PC,DLITEM
	SEZ
	RTS PC

;BRANCHES INTO NEXT PAGE
;BRANCHES IN FROM ABOVE

DIRE.3:	JSR PC,GETBYT			;GET THE QUOTED CHAR.
DIRE3A:	TST (P)				;CHECK FOR SPACES ENCOUNTERED
	BNE DIRE.6			;CONTINUE
DIRE.4:	CMP A,#ITM2AD+MFENHD+400	;STORE THE CHARACTER
	BHIS DIRE.8			;NAME TOO BIG FAIL
	MOVB C,(A)+
	XOR C,B
	JSR PC,GETBYT			;GET ANOTHER BYTE
	BNE DIRE.1			;AND PROCESS IT
	BR DIRE.6			;DONE GETTING NAME
DIRE5A:	INC ITM2AD+MFVERN		;LEAST VERSION NUMBER = -1
DIRE.5:	INC ITM2AD+MFVERN		;GREATEST VERSION NUMBER = -2
	JSR PC,GETBYT			;GET THE TERMINATOR CHAR.
DIRE.6:	CMP #ITM2AD+MFPGNO,A
	BEQ DIRE.8			;DIDN'T GET ANYTHING
	DEC E				;BACK POINTER TO BEFORE THE TERMINATOR
	BIC #177741,B			;HASH CODE
	BISB #200,-1(A)			;SET BIT AT END OF NAME
	SUB #ITM2AD+MFENHD,A		;COUNT IS EXACT BYTE COUNT
	MOV B,(P)			;SAVE HASH CODE (CLOBBER FLAG)
	MOV ITM2A,B
	BIS #MFEOFB,A			;EOF DATE AND TIME WORDS EXIST
	BIS A,MFENHD(B)			;SET LEGNTH INTO HEADER
	MOV #ITMF,(B)			;NOW FILL IN SOME DATA WORDS
	ADD #MFLAGW,B
	BIT #MFLOKB,F
	BEQ DIRE6C
	BIS #MFLOKB,(B)
	MOV ITEM1,MFLKSP-MFLAGW(B)	;LOCK THE MFI FOR THE USER
DIRE6C:	TST D
	BEQ DIRE6A			;THIS HAS NO PARENT
	MOV FAMFI(D),A
	MOV A,MFBAKP-MFLAGW(B)		;ITEM # OF PARENT
	JSR PC,ITM0PL			;LOAD UP PARENT
	MOVB MFLAGW(A),(B)		;GET THE DISK NUMBER
	TST BITTAB
	BEQ DIRE6B			;SWAP SPACE NOT ALLOCATED
	BIT #MFIWSB,F			;TEST USER'S FLAG
	BEQ DIRE6D			;USER WANT'S SWAP SPACE
	CMP SYSSPR,CURSPH
	BNE DIRE6D			;ONLY SYSTEM SPHERE CAN DEMAND SWAP TO SOURCE
DIRE6B:	BIS #MFIWSB,(B)
DIRE6D:	BIS #MFOPNB,(B)+		;SET FILE BEING OPENED BIT
	MOV MFVERN(A),(B)+		;PARENTS DIRID
	JSR PC,ITM0PO			;POP PARENT
DIRE6A:	REST <B>
	CLZ
	RTS PC
;CREATE ITEM (LOCK SWITCH TO DELETE IT)
;RETURN ADDRESS IN A AND LOAD IT INTO ITEM2

MAKI.1:	JSR PC,LFLUSH
	JSR PC,RUNME
MAKITM:	MOV #4,A
	JSR PC,CRITEM
	BEQ MAKI.1
	MOV #LPCLRT,A
	SAVE <B>
	JSR PC,LOCKSW
	MOV #MFDELP,LCKWD1(A)
	REST <A>
	JSR PC,ITM2LD
	MOV #240,C
	MOV A,B
	CLR (B)+			;CLEAR IT OUT
	SOB C,.-2
	RTS PC
;SEARCH DIRECTORY FOR NAMED FILE
;(A)=RETURN HERE POINTER TO ENTRY IF FOUND
;(D)=CAP TO DIRECTORY
;(B)=POINTER TO ENTRY (SEZ IF FAIL, SEN IF NOT FOUND AND CAN BE ADDED)
DRLOOK:	CLR -(P)			;INITIALIZE FLAG
	CLR -(P)			;AND POINTER INTO DIR
	SAVE <E,F>
	MOV ITEM2,A
	JSR PC,DKDRIO			;SWAP IN DIRECTORY
	BEQ DRLO.3			;FAILED
	JSR PC,LSWPOP			;CLEAR FUPT PROCESS POINTER
	DEC 6(P)
	JSR PC,ITM2LD			;FIX UP ITEM2
	MOV FAUPT(D),A
	JSR PC,ITM1PL			;LOAD UP DIRECTORY
	MOV 6(A),C			;EOF WORD
	ADD A,C				;ABSOLUSTE EOF
	TST 4(A)			;MFPGNO
	BNE .+6
	MOV #1,F			;FLAG FOR HACKED COMPARE
	MOV (A),E
	INC E				;ROUND UP TO WORD BOUNDARY
	BIC #177401,E
	ADD E,A				;SKIP SELF AND PARENT ENTRIES
DRLO.1:	MOV (A),E
	INC E				;ROUND UP TO WORD BOUNDARY
	BIC #177401,E
	BEQ DRLO.2
	ADD E,A				;SKIP OLD ENTRY
	CMP A,C
	BHIS DRLO.2			;EOF
	JSR PC,NAMCMP			;COMPARE THE NAMES
	BGT DRLO.1			;CONTINUE SEARCH
	BLT DRLO.2			;NOT THERE
	MOVB 1(A),E			;GET THE TYPE
	BIC #177761,E			;CLEAR EXTRA BITS
	CMP #MFLNKE_-8.,E		;LINK?
	BEQ DRLO.6			;NO VERSION # THEN
	CMP #MFDIRE_-8.,E		;DIRETORY?	
	BEQ DRLO.6			;NONE THERE EITHER
	CMP #MFSLFE_-8.,E		;SELF?
	BEQ DRLO.6
;IF NONE OF THE ABOVE, MUST HAVE VERSION #
	TST 2(B)			;DOES WHAT WE ARE LOOKING FOR HAVE A VERSION?
	BGE DRLO.5			;GO CHECK IT
	CMP #-1,2(B)			;LOOKING FOR <?
	BEQ DRLO.6			;YOU GOT IT!
	MOV #1,6(P)			;FOUND SOMETHING AT LEAST!
	MOV A,4(P)			;AND HERE IT IS
	BR DRLO.1			;GO LOOK FOR SOMETHING MORE FLAVORFUL
DRLO.5:	CMP 2(B),2(A)			;WELL, IS THIS IT, OR IS IT GONE BY?
	BGT DRLO.1			;MAYBE FURTHER ON
	BLT DRLO.2			;PAST ANY HOPE
DRLO.6:	MOV A,4(P)			;THIS IS THE PLACE!
	MOV #1,6(P)			;FOUND IT
DRLO.2:	JSR PC,ITM1PO
DRLO.4:	REST <F,E>
	TST 2(P)			;DID WE REALLY FIND ANTHING?
	BGT DRLO.9				;YES, WE GOT IT
	MOV A,(P)			;NO, POINT TO NEXT BEST THING
DRLO.9:	REST A				;THIS IS OUR POINTER
	TST (P)+
	RTS PC
DRLO.3:	JSR PC,ITM2LD
	BR DRLO.4
;SEARCH HASH TABLE FOR MFI LIKE THAT IN ITEM2
;(B)=POINTER TO ENTRY IN ITEM2
;(C)=ITEM # OF MFI IF FOUND
;(E)=HASH CODE
;SEZ IF NOT FOUND, SEN IF FLUSHED AND NOT FOUND

HTLO.1:	BIT #MFDWDB,MFLAGW-MFENHD(A)
	BNE HTLO.4			;KEEP LOOKING
	CMPB MFLAGW-MFENHD(A),MFLAGW-MFENHD(B)	;DISK NO. THE SAME?
	BNE HTLO.4			;NO, KEEP LOOKING
	BIT #MFOPNB,MFLAGW-MFENHD(A)
	BNE HTLO.2			;FLUSH UNTIL OPEN OR CLOSED
	MOV ITEM1,C			;THIS IS THE MFI WE WANT
	BR HTLO.5
HTLO.2:	JSR PC,ITM1PO
	JSR PC,LFLUSH			;WAIT FOR IT TO BE OPENED
	JSR PC,RUNME
	DEC C
	BR HTLO.6
HTLOOK:	CLR C				;CLEAR FLAG
	SAVE <F,A>
HTLO.6:	CLR F				;FLAG FOR LITERAL COMPARE
	MOV #-1,A
	JSR PC,ITM1PL			;PUSH SOMETHING
	MOV MFHTAB(E),A
	BEQ HTLO.5
HTLO.3:	JSR PC,ITM1LD			;SEARCH THE HASH TABLE
	ADD #MFENHD,A
	CMP MFPDID-MFENHD(B),MFPDID-MFENHD(A)
	BNE HTLO.4			;WRONG PARENT
	JSR PC,NAMCMP			;COMPARE THE NAMES AND VERSION #'S
	BNE HTLO.4			;NOPE!
	CMP 2(A),2(B)			;EQUAL VERSION #?
	BEQ HTLO.1			;YUP!
HTLO.4:	MOV MFHLNK-MFENHD(A),A
	BNE HTLO.3
HTLO.5:	JSR PC,ITM1PO			;IT WASN'T THERE
	REST <A,F>
	TST C
	RTS PC
;COMPARE TWO ENTRIES AND SET CONDITION CODES
;(B)=FIRST ENTRY (CAN BE RESULT OF DIRENT) (A)=SECOND ENTRY (MUST BE TOTALLY LEGAL)
;IF NAME MATCHES AND NOT LAST ENTRY UPDATE MFOLDE

NAMCMP:	SAVE <#1,A,B>
	JSR PC,MFNDNM			;FIND THE 2ND NAME
	MOV A,B
	MOV (P),A
	JSR PC,MFNDNM			;FIND THE 1ST NAME
NAMC.1:	TSTB (B)			;THE POINTERS ARE NOW REVERSED
	BMI NAM2ND			;THE 2ND HAS ENDED
	TSTB (A)
	BMI NAM1ND			;1ST ENDED FIRST
	CMPB (A)+,(B)+
	BGT NAMCGT
	BEQ NAMC.1
NAMCLT:	DEC 4(P)
NAMCEQ:	DEC 4(P)
NAMCGT:	REST <B,A>
	TST (P)+
	RTS PC
NAM1ND:	MOVB (A),A			;GET THE LAST BYTE OF FIRST NAME
	BIC #177600,A			;CLEAR THE SIGN EXTEND
	CMPB A,(B)+
	BGT NAMCGT			;IT IS GREATER THAN THE CURRENT ONE
	BR NAMCLT			;OTHERWISE IT IS LESS THAN
NAM2ND:	TSTB (A)
	BPL NAMCGT			;THE 2ND ENDED FIRST
	CMPB (A),(B)
	BGT NAMCGT
	BLT NAMCLT
	BR NAMCEQ
;ADD A DISK BLOCK TO A FILE WHOSE MFI IS IN ITEM2

ADDB0A:	JSR PC,LSWPOP
ADDBLK:	BIT #MFLSTB,MFENHD(A)
	BNE ADDB3B			;NO NEED TO ADD THE BLOCK
	MOV #MFLAGW,A
	MOV #MFIBEB,B
	MOV ITEM2,C
	JSR PC,LCKASW			;ONLY ONE PERSON CAN DO THIS AT A TIME
	MOV ITM2A,A
	MOV MFLAGW(A),B
	BIC #177600,B
	MOV MFBITS(B),B
	JSR PC,SWPIN			;SWAPIN BIT TABLE
	SAVE B
	JSR PC,MFIEXP			;MAKE SURE MFI IS BIG ENOUGH
	BIT #MFLSTB,MFENHD(A)
	BNE ADDB3A			;NO NEED TO ADD THE BLOCK
	JSR PC,UPTPLD
	BIT #UPTICR,UPTAR(B)
	BEQ ADDB0A			;TRY AGAIN
	BIS #UPTMOD!UPTWON,UPTDR(B)	;SET WRITTEN ON BIT FOR THIS FUPT
	REST B
	JSR PC,ITM2PO
ADDBK:	MOV MFPGNO(A),F
	INC F
	JSR PC,MFIRDS			;READ DISCRIPTOR TO EOF
	JSR PC,GETNBK			;(F)=LAST BLOCK (B)=GIP FOR BIT TABLE
	BEQ MFNDB			;NO BLOCKS YOU LOSE
	MOV FAMFI(D),A			;THE MFI
	JSR PC,ITM2LD			;LOAD IT UP
	MOV MFEND,C
	TST MFDIST			;BE CAREFULL (THIS HOLE CAN BE FILLED LATER)
	BLT ADDB.5			;MAKE A SET ADDRESS DISC
	TST MFPGNO(A)
	BNE ADDB0B			;IF FIRST BLOCK OF DIRECTORY MAKE A SET ADD DISC
	BIT #MFDIRB,MFLAGW(A)
	BEQ ADDB0B			;NOT A DIRECTORY
	TST MFBYTP(A)
	BEQ ADDB.5			;FIRST BLOCK OF DIRECTORY
	CMP #2000,MFBYTP(A)
	BEQ ADDB.1			;SECOND BLOCK START NEW DIRCRIPTOR
ADDB0B:	MOV F,E				;BEST BLOCK AVAILABLE
	SUB MFBKNO,E
	DEC E
	BNE ADDB.1			;MAKE A NEW DISCRIPTOR
	MOV MFDIST,E
	BEQ ADDB.0			;ADD A GET SOME DISCRIPTOR
	SUB #4,E
	BNE .+6				;OFFSET INTO TABLE OF MASKS
	DEC C
	DEC C				;SET ADDRESS IS 3 BYTES LONG
	INCB -(C)
	BITB ADDEND(E),(C)
	BNE ADDB.3			;DONE
	DECB (C)			;OVERFLOWED SO RESET
	MOV MFEND,C			;MAKE A GET SOME DISCRIPTOR
ADDB.0:	MOV #100,E
	BR ADDB.2
ADDB.1:
;	DEC E	PUT THIS LINE BACK IN IF MORE EFFICIENT DISC. ARE IMPLEMENTED
; I.E. THE SKIP FIELD OF A DISCRIPTOR IS ACTUALLY ONE LESS THAN THE NUMBER
; BLOCKS THAT SHOULD BE SKIPPED

	CMP #7,E
	BLO ADDB.4
	ASH #3,E			;SKIP AND GET SOME
	BIS #300,E
;FALLS INTO NEXT PAGE
;ENTERS FROM ABOVE
ADDB.2:	MOVB E,(C)+
ADDB2A:
	SUB #<ITM2AD+MFENHD>,C
	BIT #177400,C
	BNE ADDB.6			;DISCRIPTOR TOO LARGE 
	MOVB C,MFENHD(A)
ADDB.3:	BIS #MFLSTB,MFENHD(A)
	BIS #MFEBMB,MFLAGW(A)
	MOV MFLAGW(A),F
	BIC #177600,F			;THE DISK NUMBER
	DEC MFREBK(F)			;ONE LESS FREE BLOCK
	MOV MFPGNO(A),F
	JSR PC,MFPTFX			;FIX UP FPT IF IT EISTS
ADDB3A:	JSR PC,LSWPOP
ADDB3B:	CLZ
	RTS PC
ADDB.4:	CMP #77,E
	BHIS ADDB.2			;SKIP AND GET ONE
ADDB.5:	MOVB #200,(C)+			;SET ADDRESS
	MOVB F,(C)+
	SWAB F
	MOVB F,(C)+			;PUT IN BLOCK NUMBER
	SWAB F
	BR ADDB2A			;CHANGE HEADER WORD
ADDB.6:	MOV B,A				;RELEASE BLOCK AND LOSE
	JSR PC,ITM2LD			;LOAD UP BIT TABLE
	MOV F,C
	ASH #3,C
	ADD C,A				;COMPUTE OFFSET INTO BIT TABLE
	TST (A)+			;SKIP FIRST WORD
	BIC #177770,F
	BICB BMT(F),(A)
MFDTL:	MOV #.FADTL,ITM0AD+PERRW
	BR ADDB.7
MFNDB:	MOV #.FANDB,ITM0AD+PERRW
ADDB.7:	JSR PC,LSWPOP
	SEZ
	RTS PC
;MAKE SURE THERE IS ROOM FOR 4 DISC. BYTES IN MFI IN ITEM2

MFIEXP:	SAVE <B,A>
MFIEX1:	MOV ITEM2,B			;THE MFI ITEM NO.
	MOVB MFENHD+ITM2AD,A
	BIC #177400,A			;THE EXACT LEGNTH OF THE ENTRY
	ADD #MFELEN+4,A
	ASH #-6,A			;CONVERT TO BLOCK LEGNTH
	JSR PC,EXITEM
	BEQ MFIEX2
	REST <A,B>
	RTS PC
MFIEX2:	JSR PC,LFLUSH
	JSR PC,RUNME
	BR MFIEX1			;TRY AGAIN
;SWAP IN UPT AND LOCK IN CORE (GIP IN B)

MFSL.1:	REST <A,B,C>
	JSR PC,LFLUSH
	JSR PC,RUNME
MFSWAL:	SAVE <C,B,A>
	JSR PC,SWPIN			;SWAP IT IN
	JSR PC,UPTPLD
	MOV UPTAR(B),A
	JSR PC,ITM2PO
	BIC #UPASMS!10,A
	ASH #-3,A			;INDEX IN CST
	MOV CST(A),A			;CPT OFFSET
	BIC #CSTCOM,A
	ADD #CPT+CPTADR,A
	MOV #CPTLCK,B
	BIT B,(A)
	BNE MFSL.1			;ALREADY LOCKED
	CLR C
	JSR PC,LCKASW
	REST <A,B,C>
	RTS PC
;FIND A GOOD BLOCK (B)=BITS GIP (F)=LAST BLOCK NUMBER
GETNBK:	CLR -(P)			;FLAG
	SAVE <A,B,E>
	MOV B,A
	JSR PC,ITM2LD			;BIT TABLE
	INC F				;START SEARCH HERE
	MOV (A)+,B			;TOTAL LEGAL BLOCKS
	CMP F,B				;DID WE WRAP
	BLT .+4
	CLR F
	MOV F,E
	ASH #-3,F			;CALCULATE OFFSET IN BIT TABLE
	ADD F,A
	BIC #177760,E			;CALCULATE MASK
	MOV #1,F
	BIC F,A				;GET TO WORD BOUNDARY
	ASH E,F
	DEC F				;DON'T LOOK AT THESE BLOCKS YET
	TST -(P)
	MOV (A),E
	BIS F,E				;IGNORE SOME BLOCKS
	CMP #-1,E
	BNE GTNB.2			;GOT ONE
	TST (A)+
	MOV A,(P)			;STOP WHEN WE GET HERE AGAIN
	ASH #-3,B
	ADD #ITM2AD+2,B			;WRAP WHEN WE GET HERE
	BR .+6				;DON'T STOP UNTIL NEXT TIME AROUND
GTNB.1:	CMP A,(P)
	BEQ GTNB.5			;NO FREE BLOCKS
	CMP A,B
	BLO .+6
	MOV #ITM2AD+2,A			;WRAP AROUND
	CMP #-1,(A)+
	BEQ GTNB.1
	MOV -(A),E			;GOT ONE
GTNB.2:	INC 8(P)			;FLAG SHOWS SUCESS
	MOV A,F
	SUB #ITM2AD+2,F			;MAKE IT A BLOCK NUMBER
	ASH #3,F
	CLR B
GTNB.3:	ROR E
	BCC GTNB.4			;THIS IS IT
	INC B
	BR GTNB.3
GTNB.4:	ADD B,F				;MARK THE BLOCK
	MOV #1,E
	ASH B,E				;BIT TO SET
	BIS E,(A)
GTNB.5:	TST (P)+
	REST <E,B,A>
	TST (P)+			;FLAG
	RTS PC
ACSAV:	SAVE <E,D,C,B,A>
	JMP (F)

ACRES:	TST (P)+
	REST <A,B,C,D,E>
	RTS F

	.SBTTL ITEM TABLE ROUTINES
.IIF NZ ITMADR!ITLINK,.ERROR NO, IT WON'T WORK WITH ITLINK OR ITADDR NON-ZERO
;CREATE AN ITEM OF SPECIFIED SIZE
;THE SIZE IS PUT INTO A; THE ITEM'S INDEX RETURNS IN B
;THE Z BIT IS SET IF THE ITEM CANNOT BE CREATED; OTHERWISE, IT IS CLEARED
;THIS MAKES NO ATTEMPT TO COMPRESS EXISTING ITEMS TO PRODUCE CONTIGOUS FREE SAPCE
;THAT FEATURE IS OF SOMEWHAT QUESTIONALBE VALUE, BUT MIGHT BE ADDED LATER
CRITEM:	CMP #200,A	;CHECK THAT NO ONE ASKS FOR A BLOCK>4K
	BUGC GT
	MOV ITMFRE,B	;ATTEMPT TO GET A FREE ITEM
	BEQ CRITM1	;NO MORE AVAILABLE, GO LOSE
	SAVE <C,D>
CRITM8:
;	TSTB ITACCS(B)	;IS THIS ITEM TABLE ENTRY REALLY FREE?
;	BUGC EQ		;OOPS!!
	MOV A,C		;GET THE LENGTH
	ASL C		;CONVERT IT TO AN INDEX
	ADD #ITMATB,C	;INTO THE ALLOCATE TABLE
	CLR D		;FOR THE LEFTOVER COUNT
CRITM3:	TST (C)+	;IS THERE A FREE ITEM BLOCK OF THIS SIZE?
	BNE CRITM2	;YES, GO USE IT
	TST (D)+	;ONE MORE TO FREE WHEN WE FINALLY FIND
			;A BLOCK BIGGER THAN WHAT WE REALLY WANTED
	CMP #ITMATB+400,C	;ARE WE ALREADY OFF THE TOP?
	BNE CRITM3	;NOPE, NOT YET
;IF WE GET HERE WE HAVE TO ALLOCATE A NEW BIG BLOCK
	TST ITMBAL	;IS SOMEONE ELSE ALREADY ALLOCATING?
	BEQ CRIT11	;NO, GO LOCK THE SWTICH
CRIT13:	JSR PC,SFLUSH	;WAIT FOR THE OTHER GUY TO BE DONE
	TST ITMBAL	;DONE YET?
	BNE CRIT13	;NOPE
	JSR PC,RUNME	;DONE, NOW  SEE IF HE LEFT ENGOUGH FOR US
CRIT16:	MOV ITMFRE,B	;HAVE TO GET ANOTHER ITEM
	BEQ CRIT12	;MAYBE OTHER PEOPLE TOOK THEM ALL
	BR CRITM8	;NOPE
CRIT11:	SAVE A		;LOCK SWTCH SO NO ONE ELSE GETS TO THIS CODE
	MOV #ITMBAL,A
	MOV #-1,B	;USE ALL THE BITS
	CLR C		;THE SWITCH IS INOT IN AN ITEM
	JSR PC,LCKASW	;IN CASE WE HANG WAITING FOR A BLOCK
	MOV #NITMBL,B	;FIND A FREE ITEM BLOCK SLOT
	MOV #ITMBST,C
CRIT10:	TST (C)+	;NEGATIVE INDICATES FREE
	BLT CRITM9	;FOUND ONE!
	SOB B,CRIT10	;KEEP TRYING
	JSR PC,LSWPOP	;LOSE, NO SPACE TO PUT ANOTHER BLOCK
	REST A
CRIT12:	REST <D,C>
CRITM1:	SEZ		;INDICATE FAILURE
	RTS PC
;NO, THIS ISN'T THE END OF THE ROUTINE!
CRITM2:	MOV (B),ITMFRE	;NOW THE ITEM POINTED TO BY THIS ONE IS
			;THE BEGINNING OF THE FREE LIST
	MOVB A,ITLNGT(B)	;SET IN THE LENGTH
	MOVB #ITACCD,ITACCS(B)	;AND THE ACCESS CODE
	SAVE <E,F>
	MOV -(C),E	;GET A POINTER TO THE NODE FOR THE FREE BLOCK
	MOV (E),(C)	;SPLICE OUT THIS NODE
	MOV 2(E),F	;ADDRESS OF THE BLOCK
	MOV F,(B)	;PUT IT AWAY IN THE ITEM
	MOV F,C		;COPY IT
	BIC #170000,F	;GET THE ADDRESS PART
	SAVE F		;AND SAVE IT FOR LATER
	TST D		;IS THERE ANY LEFTOVER?
	BEQ CRITM4	;NO, JUST GO FREE THE NODE
	TST -(D)	;CORRECT D, IT'S OVERENTHUSIASTIC
	MOV ITMATB(D),(E)	;PUT THE NODE INTO THE LIST FOR THE LEFTOVER SIZE
	MOV E,ITMATB(D)		;THERE!
	ADD A,2(E)	;ADD THE AMOUNT USED TO THE ADDRESS
	INC 2(E)	;SINCE ZERO IS ONE(?)
	BR CRITM5	;NOW GO USE WHAT WE GOT
CRITM4:	MOV ITMAFR,(E)	;LINK IT BACK TO THE FREE LIST
	MOV E,ITMAFR
	CLR 2(E)
CRITM5:	JSR PC,BITSET	;GRAB THE BLOCKS WE WANT
	TST (P)+	;FLUSH THE ADDRESS FROM THE STACK
	SUB #ITMTAB,B
	REST <F,E,D,C>
	CLZ
	RTS PC
CRITM9:	CMP #20,(P)	;IS HE ASKING FOR MORE THAN 512 WORDS?
	BLE CRIT23	;YES, MAKE SURE WE GET AT LEAST THAT MUCH
	MOV #FMMALT+6,A	;START BY LOOKING FROM 2K UPWARDS
	MOV #5,B	;2K, 2.5K, 3K, 3.5K 4K
CRIT17:	JSR PC,CRIT22	;GO SEE IF WE CAN GOBBLE IT
	TST (A)+	;NEXT!
	SOB B,CRIT17	;FOR THE 5 DIFFERNET SIZES
	MOV #10,B	;OK, I'LL TAKE ANY SIZE
CRIT18:	TST -(A)	;ANY?
	JSR PC,CRIT22	;CAN I HAVE SOME?
	SOB B,CRIT18
	MOV #3,A	;HERE, SWAP SOMETHING OUT!
;	JSR PC,SWAPO
;	BR CRITM9
	BPT		;CAN'T WIN UNLESS WE CAN SWAP OUT

CRIT23:	MOV (P),A	;FIGURE OUT WHAT HTE MIMUM HE NEEDS IS
	ASH #-4,A	;THIS IS 512 WORD BLOCKS
	MOV #10,B
	SUB A,B		;HOW MANY SAME OR LARGER SIZES ARE THERE?
	ASL A		;CHANGE TO INDEX
	ADD #FMMALT,A	;TO FREE MEMORY TABLES
CRIT24:	JSR PC,CRIT22	;SEE IF FREE
	TST (A)+	;NEXT
	SOB B,CRIT24
	MOV #7,A	;MIGHT AS WELL GO WHOLE HOG
;	JSR PC,SWAPO
;	BR CRIT23
	BPT		;BETTER SWAP SOMETHING OUT!

CRIT19:	SAVE A
CRIT20:	BIT #CPTMOV,CPTADR+CPT(D)	;IS IT MOVING?
	BEQ CRIT21	;NO, TAKE IT AWAY
	MOV D,A		;SAVE POINTER TO PREVIOUS
	ADD #CPT,A	;ALWAYS A CORE ADDR
	MOV CPT(D),D	;LINK THROUGH
	BNE CRIT20	;TRY NEXT ONE
	REST A		;NO MORE GIVE UP
	SEZ		;PAGE ALLOCATE HAS TO KNOW IT LOST
	RTS PC
CRIT21:	MOV CPT(D),(A)	;TAKE OFF THE FREE LIST
	REST A
	SUB #FMMALT,A	;MAKE IT RELATIVE
	MOV UMMALT(A),CPT(D)	;POINT IT TO A USED LIST
	MOV D,UMMALT(A)		;CLOBBER THE USED POINTER
	CLZ
CRIT25:	RTS PC		;YES, DONE
CRIT22:	MOV (A),D	;IS THERE ANYTHING THERE?
	BEQ CRIT25	;NO, BETTER LUCK NEXT TIME
	JSR PC,CRIT19
	BNE .+4
	RTS PC
	MOV CPT+CPTADR(D),B	;THE ADDRESS OF THING WE GOBBLED
	ASH #4,B	;CONVERT TO AN AR-STYLE
	BIC #170017,B
	ASR A
	SUB A,NUMBLKS
	ASH #4,A	;THE LENGTH
	BIS #17,A	;CONVERT TO DR-STYLE
	TST (P)+		;FLUSH RETURN ADDRESS
	JSR PC,LSWPOP
;DONE ALLOCATING CORE
;FALL THROUGH TO NEXT PAGE
;FALLS IN FROM PREVIOUS PAGE
	MOV B,-(C)	;B GETS THE ADDRESS
	SUB #ITMBST,C	;UN-RELATIVE IT
	MOV A,ITMBNF(C)	;A GETS THE NUMBER OF BLOCKS GOBBLED
	MOV ITMAFR,D	;GET AN ALLOCATE NODE
	BUGC NE		;THERE SHOULD ALWAYS BE ONE AVAILABLE
	MOV (D),ITMAFR	;SPLICE IT OUT OF THE FREE LIST
	SAVE C		;SAVE FOR LATER
	ASH #11.,C	;PUT IT INTO THE HIGH FOUR BITS
	ADD B,C		;COMBINE THE BLOCK ADDRESS AND THE BIG BLOCK NUMBER
	MOV C,2(D)	;AND SAVE IT IN THE NODE
	ASL A		;CONVERT SIZE OF BLOCK TO WORD OFFSET
	MOV ITMATB(A),(D)	;SPLICE THIS NODE
	MOV D,ITMATB(A)	;INTO LIST FOR THIS SIZE
	ASR A		;RESTORE A
	REST C		;GET THE INDEX INTO THE BLOCK VARIABLES
	MOV ITMBTP(C),C	;ADDRESS OF THE BIT TABLE FOR THIS BLOCK
	MOV C,D		;COPY POINTER TO BIT TABLE
	MOV #8.,B	;THERE ARE 8 WORDS
CRIT14:	MOV #-1,(C)+	;FIRST, SET ALL BLOCKS AS USED
	SOB B,CRIT14	;DO 8 TIMES
	INC A		;0 IS ONE BLOCK!
	ASH #-4,A	;COVERT TO 512 WORD BLOCKS
CRIT15:	CLR (D)+	;THERE WILL ALWAYS BE AT LEAST ONE
	SOB A,CRIT15	;DO UP TO 8 TIMES
	REST A
	JMP CRIT16	;NOW GO TRY THE WHOLE THING AGAIN!
;THIS ISN'T THE END EITHER
;DELETE THE ITEM WHOSE ITEM NUMBER IS IN A
;A GETS CLOBBERED
;THIS MAKES NO ATTEMPT TO RETURN AN EMPTY BIG BLOCK
;THAT FEATURE SHOULD BE ADDED AS SOON AS POSSIBLE (PROBABLY)
DLITEM:	JSR F,ACSAV
	CLR -(P)	;SAVE A STACK WORD FOR TEMP
	ADD #ITMTAB,A	;RELOCATE INDEX TO BE ACTUAL ADDRESS
	TSTB ITACCS(A)	;IS THIS ITEM FOR REAL?
	BUGC NE		;OOPS!
	MOV (A),E	;GET THE ADDRESS AND BLOCK # OF THE ITEM
	MOVB ITLNGT(A),(P)	;SAVE THE LENGTH ON THE STACK
	MOV ITMFRE,(A)	;PUT THE NEWLY-FREED NODE ON THE HEAD OF THE
	CLRB ITACCS(A)	;MARK IT AS FREE
	MOV A,ITMFRE	;FREE LIST. IT WON'T BE FREE LONG!
	INC (P)		;CORRECT FOR OFFSET
	MOV (P),F
	MOV E,A
	JSR PC,BITCLR	;CLEAR THE BITS OF THE BLOCK WE ARE FREEING
	MOV #-1,C	;NOW SEE IF THE SPACE BEFORE THE BLOCK IS FREE
	DEC E		;LOOK BEFORE THE BLOCK
	JSR PC,CNTFRE	;GO SEE IF THERE'S ANYTHING WE CAN FREE
	MOV E,F		;SAVE THE REAL BEGGING ADDRESS
	ADD (P),E	;GO TO THE END OF THE SO-FAR FREE BLOCK
	MOV #1,C	;NOW SEARCH FORWARD
	JSR PC,CNTFRE	;GO SEE IF ANYTHING THERE AND FREE WHATEVER YOU FIND
	MOV F,C		;GET THE REAL BEGGINING OF THE BLOCK
	JSR PC,BLKFRE	;FREE THE BLOCK WE HAVE FOUND
	TST (P)+	;FLUSH THE COUNT FROM THE STACK
	JSR F,ACRES
	RTS PC
;EXPAND OR CONTRACT ITEM WHOSE INDEX IS IN B
;TO THE SIZE IN A
;CLEAR Z IF SUCCESSFUL, OTHERWISE SET Z
EXITEM:	JSR F,ACSAV
EXITM4:	TSTB ITACCS+ITMTAB(B)	;IS THIS ITEM FOR REAL?
	BUGC NE		;OOOPS!
	CMPB A,ITLNGT+ITMTAB(B)	;WHAT IS THE RELATION OF THE DESIRED LENGTH
				;TO THE CURRENT LENGHT?
	BGT EXITM2	;NEED TO ADD MORE TO THE ITEM
	BEQ EXITM1	;THE ITEM IS ALREADY THE DESIRED LENGTH
			;GET HERE TO REMOVE EXTRA STUFF FROM ITEM
	MOVB ITLNGT+ITMTAB(B),F	;GET THE CURRENT LENGTH
	SUB A,F		;DIFFERENCE BETWEEN CURRENT AND DESIRED
	SAVE F		;SAVE THE NUMBER OF BLOCKS TO BE FREED
	MOV ITMADR+ITMTAB(B),E	;ADDRESS OF THE ITEM
	MOVB A,ITLNGT+ITMTAB(B)	;SET THE NEW LENGTH INTO THE ITEM
	ADD A,E		;GET TO THE END OF THE DESIRED PART
	INC E		;CORRECT IT
	MOV E,A		;MAKE THE ROUTINE HAPPY
	JSR PC,BITCLR	;CLEAR THE NEWLY FREED AREA
	MOV E,F		;SAVE THE ADDRESS OF THE BLOCK WE ARE ABOUT TO FREE
	ADD (P),E	;END OF AREA WE KNOW TO BE FREE
	MOV #1,C	;SEARCH FORWARD
	JSR PC,CNTFRE	;LOOK FOR FREE BLOCKS AND FREE THOSE YOU FIND
	MOV F,C		;PUT ADDRESS OF BLOCK INTO THE RIGHT PLACE
	JSR PC,BLKFRE	;PUT FREE BLOCKS ON FREE LIST
	TST (P)+	;GET RID OF COUNT ON PDL
EXITM1:	JSR F,ACRES
	CLZ
	RTS PC
;CONTINUED NEXT WEEK (ACTUALLY, NEXT PAGE)
;GET HERE IF MORE SPACE NEEDED FOR ITEM
EXITM2:	MOV ITMADR+ITMTAB(B),E	;ADDRESS OF START OF ITEM
	MOVB ITLNGT+ITMTAB(B),A	;GET CURRENT SIZE
	ADD A,E		;TO GET END OF CURRENT BLOCK
	INC E		;CORRECT IT
	MOV E,D		;NOW FIND WHICH BLOCK
	ASH #-11.,D
	BIC #177741,D	;WORD INDEX
	MOV #1,C	;NOW SEARCH FORWARD FOR FREE BLOCKS
	JSR PC,CNTBLK
	BLT EXITM3	;FORGET THIS IF THERE AREN'T ANY
	MOV (P),C	;GET THE DESIRED COUNT
	INC A		;CORRECT THE AMOUNT FOUND
	SUB A,C		;C=AMOUNT NEEDED-EXTRA FOUND
	MOVB ITLNGT+ITMTAB(B),F	;THE AMOUNT WE ALREADY HAVE
	CMP C,F		;WILL THE TOTAL BE ENOUGH?
	BGT EXITM3	;NO, FORGET IT
	ADD A,F		;YES, WHAT IS THAT TOTAL?
	MOVB F,ITLNGT+ITMTAB(B)	;THAT IS THE NEW ITEM LENGTH
	MOV A,F		;SAVE THE NUMBER OF BLOCKS WE ARE STEALING
	DEC A		;UNCORRECT IT
	JSR PC,FINDEL	;DELETE IT FROM THE FREE LIST
	MOV F,A		;GET THE COUNT BACK
	MOV E,C		;MAKE THE ROUTINE HAPPY
	SAVE E		;HAPPY!!??
	JSR PC,BITSET	;INDICATE THOSE BLOCKS IN USE
	TST (P)+	;GET RID OF THE GARBAGE
	MOV (P),A	;NOW, HOW MUCH DID WE REALLY WANT?
	MOV 2(P),B	;FOR WHAT ITEM?
	BR EXITM4	;GO FLUSH ANY EXTRA WE TOOK
;GET HERE IF THE BLOCK CAN'T BE EXPANDED NICELY
EXITM3:	MOV (P),A	;GET THE DESIRED SIZE
	JSR PC,CRITEM	;GET AN ITEM OF THE RIGHT SIZE
	BNE EXITM6	;GOT IT, GO USE IT
	JSR PC,ACRES	;LOSE, RESTORE AC'S AND GET OUT
	SEZ
	RTS PC
;TO BE CONTINUED (NEXT PAGE)
EXITM6:	MOV B,A		;LOAD THE NEW ITEM INTO THE MAP
	JSR PC,ITM0PL	;PUSH AND LOAD
	MOV A,C		;SAVE THE ADDRESS IT WAS LOADED AT
	MOV 2(P),D	;THE ITEM WE WANT TO EXPAND (COPY)
	MOV D,A		;LOAD IT INTO THE MAP TOO
	JSR PC,ITM1PL	;PUSH AND LOAD
	MOVB ITLNGT+ITMTAB(D),F	;GET THE LENGTH OF THE OLD THING
	INC F		;CORRECT IT
	ASH #5,F	;CONVERT TO WORDS
	MOV (A)+,(C)+	;COPY THE BLOCK
	SOB F,.-2
	JSR PC,ITM0PO	;POP ITEM0
	JSR PC,ITM1PO	;POP ITEM1
	MOV B,A		;SAVE THE NEW ITEM INDEX
	ADD #ITMTAB,D	;MAKE AN ACTUAL ADDRESS
	ADD #ITMTAB,B
	MOV #ITMTEL/2,F	;NUMBER OF WORDS TO EXCAHNGE
EXITM5:	MOV (B),E
	MOV (D),(B)+
	MOV E,(D)+
	SOB F,EXITM5	;EXCAHNGE OLD AND NEW ITEMS
	JSR PC,DLITEM	;DELETE THE NEW ITEM SLOT WITH THE OLD ITEM CONTENTS!!
	BR EXITM1	;RETURN SUCESSFULLY, IF SOMEWHAT WEARILY


;CLEAR ITEM WHOSE INDEX IS IN B
;IT'S LENGTH IS IN A. IT IS ALSO LOADED INTO ITEM0
;AND ITEM0'S PDL IS PUSHED. A IS CLOBBERED TO THE ADDRESS OF THE ITEM
CLITEM:	SAVE C		;FOR THE WORD COUNT
	MOV A,C		;THE BLOCK COUNT
	INC C		;CORRECTED
	ASH #5,C	;CONVERT TO WORDS
	MOV B,A		;THE ITEM TO CLEAR
	JSR PC,ITM0PL	;GETS LOADED
	ADD C,A		;POINT A TO THE END OF THE ITEM
	ADD C,A		;SINCE C IS A WORD COUNT
	CLR -(A)	;CLEAR TE ITEM, CORRECTING A
	SOB C,.-2	;CLEAR ALL THE WORDS
	REST C
	RTS PC
;SET THE BITS IN THE ITEM BLOCK BIT TABLE
;THE STARTING ADDRESS IS EXPECTED IN C AND 2(P)
;THE COUNT OF BLOCKS (UNCORRECTED) IS EXPECTED IN A (IT SHOULD NOT BE -1)
;CLOBBERS C,D,E AND F
BITSET:	ASH #-11.,C	;GET THE BIG BLOCK NUMBER
	BIC #177741,C
	DEC ITMBNF(C)	;CORRECT FOR 0=1
	SUB A,ITMBNF(C)	;THAT MANY FEWER BLOCKS AVAILABLE
	MOV 2(P),E	;GET THE ADDRESS BACK
	BIC #170000,E	;CLEAR BIG BLOCK BITS
	MOV A,D		;AND A COUNT WE CAN MUNGE
	SUB ITMBST(C),E	;CONVERT TO BLOCK WITHIN BIG BLOCK
	ASHC #-3.,E	;FIGURE IT OUT YOURSELF
	ASH #-13.,F
	BIC #177770,F
	ADD ITMBTP(C),E	;MAKE IT POINT INTO THE BIT TABLE
	INC D		;SINCE 0=1
BITST1:	BISB BMT(F),(E)	;SET THE BIT
	INC F		;CHANGE THE BIT NUMBER
	BIT #7,F	;HAVE WE JUMPED A BYTE?
	BNE BITST2	;NOT YET
	CLR F		;NEW BIT NUMBER
	INC E		;AND NEW BYTE NUMBER
BITST2:	SOB D,BITST1	;DO FOR HOWEVER MANY LITTLE BLOCKS
	RTS PC
;CLEAR BITS IN THE BIT TABLE FOR THE ITEM BLOCK
;EXPECTS THE STARTING ADDRESS IN A AND THE COUNT (CORRECTED) IN F
;CLOBBERS A,B,D AND F
BITCLR:	MOV A,D		;COPY IT
	ASH #-11.,D	;TO GET THE BLOCK #
	BIC #177741,D	;CLEAR BITS THAT MAY BE SET BY ASH
	BIC #170000,A	;GET RID OF THE BLOCK NUMBER
	SUB ITMBST(D),A	;AND MAKE RELATIVE TO START OF BLOCK
	ASHC #-3,A	;KNOCK THE BIT ADDRESS OFF THE END
	ASH #-13.,B	;AND PUT IT IN IT'S PLACE
	BIC #177770,B	;OH FOR A LSH!
	ADD ITMBTP(D),A	;ADDRESS IN THE BIT TABLE
	ADD F,ITMBNF(D)	;MORE FREE SPACE!
;THIS IS WHERE THE RETURN BIG BLOCK STUFF SHOULD GO
BITCL1:	BICB BMT(B),(A)	;THIS BLOCK NOW FREE
	INC B		;GO TO NEXT BIT ADDRESS
	BIT #7,B	;TO NEXT BYTE?
	BNE BITCL2	;NOT YET
	CLR B		;ZEROTH BIT
	INC A		;IN THE NEXT BYTE
BITCL2:	SOB F,BITCL1	;CLEAR UNTIL DEAD
	RTS PC
;PUT AN ENTRY ON THE APPROPRIATE FREE LIST FOR THE BLOCK WE HAVE FREED
;EXPECTS THE COUNT (CORRECTED) ON 2(P), THE ADDESS OF THE BLOCK IN C
;CLOBBERS A AND B
BLKFRE:	MOV 2(P),A	;AND IT'S LENGTH
	DEC A		;SIGH
	ASL A		;CONVERT THE LENGTH INTO A WORD INDEX
	ADD #ITMATB,A	;NOW, THE ADDRESS IN THE ALLOCATE TABLE
	MOV ITMAFR,B	;GET THE FIRST FREE ALLOCATE NODE
	BUGC NE		;WE SHOULD NEVER RUN OUT OF THESE!
	MOV (B),ITMAFR	;SPLICE IT OUT
	MOV (A),(B)	;SPLICE INTO THE LIST FOR THIS SIZE BLOCK
	MOV B,(A)	;AND FIX THE POINTER TO THE LIST
	MOV C,2(B)	;FINALLY, THE LOCATION OF THE NEWLY FREED BLOCK
	RTS PC


;THIS ROUTINE IS SPECIAL FOR DLITEM
;IT FINDS FREE SPACE A TACKS IT ON TO EXISTING FREE SPACE
;NOTE THAT THE WORD AT 2(P) IS EXPECTED TO CONTAIN THE COUNT
;OF BLOCKS THAT HAVE BEEN FOUND TO BE FREE
;CLOBBERS A AND B ADDS THE NUMBER OF BLOCKS IT FINDS TO 2(P)
CNTFRE:	JSR PC,CNTBLK	;AND IF SO, HOW MUCH?
	BLT CNTFR1	;NONE FREE THERE!
	ADD A,2(P)	;SOME THERE, ADD TO PREVIOUS AMOUNT
	INC 2(P)	;SIGH
FINDEL:	JSR PC,FINBLK	;FIND THE BLOCK THAT IS FREE
DELBLK:	MOV (A),(B)	;SPLICE THE NODE OUT OF THE LIST
	MOV ITMAFR,(A)	;AND PUT THE FREED NODE ON THE FREE LIST
	MOV A,ITMAFR	;NEW START OF FREE LIST
CNTFR1:	RTS PC
;FIND A BLOCK OF A PARTICULAR SIZE THAT BEGINS AT A CERTAIN LOCATION
;SIZE IN A
;LOCATION IN E
;POINTER TO NODE IS RETURNED IN A
;POINTER TO PREVIOUS NODE IS RETURNED IN B
;(IT IS A BUG FOR THERE TO BE NO SUCH BLOCK!!!)
FINBLK:	ASL A		;CONVERT THIS INTO A POINTER
	ADD #ITMATB,A	;INTO THE ALLOCATE VECTOR
FINBL1:	MOV A,B		;THE OLD ONE
	MOV (A),A	;THE ONE IT POINTS TO
	BUGC NE		;MUST BE THERE!!
	CMP 2(A),E	;IS THIS THE ONE?
	BNE FINBL1		;NOPE
	RTS PC		;YES, WE'RE ALL SET
;FIND HOW MANY BLOCKS ARE FREE STARTING AT A GIVEN BLOCK AND
;LOOKING IN A GIVEN DIRETION
;E CONTAINS THE ABSOULUTE BLOCK NUMBER
;D CONTIANS THE INDEX OF THE BLOCK IT IS IN
;C CONTAINS THE DIRECTION (1=> FORWARD, -1=> BACKWARDS)
;A GETS -1 OR THE LENGTH OF WHAT'S FOUND
;CONDITON CODES ARE SET BY TST A, I.E. N IS CLEAR IF ANYTHING FOUND
;E GETS THE ADDRESS OF THE FIRST BLOCK IN THE CHUNK
CNTBLK:	SAVE <F,B,E>
	MOV #-1,A	;THE INTIAL COUNT
	BIC #170000,E	;GET RID OF BLOCK #
	SUB ITMBST(D),E	;MAKE IT RELATIVE TO START OF BLOCK
	BLT CNTBL2	;NO BLOCKS BEFORE BLOCK!
	ASHC #-4,E	;GET THE BIT NUMBER
	ASH #-12.,F	;AND THE WORD NUMBER
	BIC #177760,F	;MAKE SURE THE BIT NUMBER IS RIGHT
	ASL E		;MAKE A WORD ADDRESS
	MOV #1,B	;THE FIRST BIT
	ASH F,B		;SHIFT BY THE BIT NUMBER
	ADD ITMBTP(D),E	;THE REAL BIT TABLE ADDRESS
CNTBL1:	BIT B,(E)	;IS THIS ONE FREE?
	BNE CNTBL2	;THEN WE'RE DONE
	INC A		;ANOTHER ONE FREE
		;SHIFT ONE WAY OR THE OTHER
	CLC		;CLEAR THE WAY FOR THE ROTATES
	TST C		;WHICH WAY?
	BLT CNTBL4	;RIGHT
	ROL B		;LEFT
	BR CNTBL5
CNTBL4:	ROR B		;RIGHT
CNTBL5:	BNE CNTBL1	;NOT DONE WITH WORD YET
	ADD C,E		;ADJUST ADDRESS
	ADD C,E		;IT IS A WORD ADDRESS
	MOV #1,B	;RESET THE BIT
	TST C		;UNLESS WE ARE LOOKING BACKWARDS
	BGT CNTBL1	;NOPE, FORWARDS
	MOV #100000,B	;OOPS, BACKWARDS
	BR CNTBL1
CNTBL2:	REST E
	TST C		;THIS IS OK FOR FORWARDS SEARCH
	BGT CNTBL3
	SUB A,E		;BUT MUST BE CORRECTED FOR BACKWARD
CNTBL3:	REST <B,F>
	TST A		;TO SET THE CONDITION CODES
	RTS PC

;ROUTINES TO LOAD ITEMS INTO THE MAP AND TO PUSH AND POP THE ITEM STACKS

.IRPC X,<012>	;CONSTRUCT ROUTINES FOR EACH OF THE ITEM PAGES
;PUSH THE CURRENT ITEM FOR THIS PAGE ON THE STACK
;AND LOAD THE ITEM WHOSE INDEX IS IN A
ITM'X'PL:	SUB #2,ITM'X'P		;DECREMENT THE STACK POINTER
	MOV ITEM'X,@ITM'X'P		;STORE CURRENT ITEM ON STACK
	INC ITM'X'D			;INDICATE PUSHED ONE MORE LEVEL
;FALL INTO THE LOAD ITEM ROUTINE

;LOAD ITEM WHOSE INDEX IS IN A INTO AN ITEM PAGE
;RETURN THE ADDRESS THAT THE ITEM WAS LOADED INTO IN A
ITM'X'LD:
	SAVE PS
	SPL 7
	MOV A,ITEM'X		;THIS IS NOW THE CURRENT ITEM
	BLT ITM'X'L1			;NOT REALLY AN ITEM
	MOV ITMTAB(A),ITM'X'AR		;SET THE AR
	MOV ITMTAB+ITACCS(A),ITM'X'DR	;AND THE DR
ITM'X'L2:
	REST PS
	MOV #ITM'X'AD,A		;AND THE ADDRESS
	RTS PC
ITM'X'L1:	CMP A,#-1
	BNE ITM'X'L3		;ITS A GIP
	CLR ITM'X'DR		;MAKE THE ITEM NXM
	BR ITM'X'L2		;GO FINISH
ITM'X'L3:	SAVE <B,A>	;SAVE REG AND GIP AND LOAD UP A UPT
	MOV #-1,ITEM'X		;SO WHEN WE POP ITEM2 WE WIN
	JSR PC,ITMGIP
	REST <ITEM'X>		;SET ITEM FIRST TO AVOID TIMING SCREW
	MOV A,ITM'X'DR		;CAN ONLY RECURSE ONE LEVEL
	MOV B,ITM'X'AR
	REST <B>		;RESTORE REGISTER
	BR ITM'X'L2

;POP THE TOP ITEM OFF THE STACK
ITM'X'PO:	SAVE A	;DON'T CLOBBER A
	DEC ITM'X'D	;INDICATE POPED ONE LEVEL
	BUGC GE		;DID WE OVER POP?
	MOV @ITM'X'P,A	;GET THE OLD THING
	ADD #2,ITM'X'P	;FLUSH ITFROM THE PDL
	JSR PC,ITM'X'LD	;LOAD THE OLD ITEM
	REST A
	RTS PC
.ENDM
ITMGIP:	SAVE <C,D>
	MOV A,B
	JSR PC,UPTPLD		;RETURN ADDRESS OF UPT IN B
	MOV B,A			;ADDRESS TO RETURN
	MOV UPTAR(A),B
	MOV B,C
	BIC #UPASMS,B		;ITM'X'AR
	BNE ITMGI2
	CLR A
	BR ITMGP1
ITMGI2:	MOV UPTDR(A),A		;GET THE DR
	MOV A,D			;COPY IT
	BIC #UPMSSW,C		;GET THE MASTER START
	BIC #UPMSRE,D		;GET THE REFERENCED START
	SWAB D			;GET IT INTO THE LOW BITS
	SUB C,D			;GET THE OFFSET INTO THE PAGE
	ASH #4,D		;GET INTO THE RIGHT BITS
	ADD D,B			;FIX UP ADDRESS FIELD
	BIC #UPTSMS,A
	BIS #7406,A
ITMGP1:	REST <D,C>
	JSR PC,ITM2PO		;UPTPLD PUSHED THIS
	RTS PC
	.SBTTL PROCESS HACKING ROUTINES
;CREATE PROCESS AND PUT IT ON THE STOPPED QUQUE
;RETURN ITEM NUMBER IN A AND CLEAR Z IF SUCESSFUL
;OTHERWISE SEET Z
;RETURN ADDRESS OF PROCESS TABLE ENTRY IN B
CRPROC:	MOV #PRSLNF,A	;SIZE OF A PROCESS WITHOUT THE FLOATING POINT
	JSR PC,CRITEM	;GET AN ITEM FOR IT
	BEQ CRPRO1	;NO ITEM, TOUGH LUCK
	JSR PC,CLITEM	;CLEAR IT AND PUT IT IN ITEM0
	MOV #ITPROC,(A)	;SET THE TYPE
	BIS #PSUPSB,PSTOP(A)	;STOPPED!
	INC PSTOPC(A)		;ONE FOR THE BIT
	MOV #-1,PSPHRP(A)	;NO SPHERE AS OF NOW
	MOV #-1,PITM2(A)	;NO ITEMS EITHER
	MOV #174000,PUPS(A)	;THE USER MODE PS
	INC NEWPRI		;GET TO NEXT RPOCESS ID #
	BNE .+6
	INC NEWPRI+2
	MOV NEWPRI,PRSID1(A)	;SET THE PROCESS ID
	MOV NEWPRI+2,PRSID2(A)

;NOTE THAT CRUSER ENTERS HERE
;AND INTIALIZES THE VARIABLES THAT IT HAS IN COMMON WITH PROCESSES
CRUSR1:	INC PRSREF(A)	;PRESUMABLY, THE GUY ASKING FOR IT WILL REFERENCE IT
	MOV PFREEQ,PPRTPT(A)	;THE PROCESS BLOCK WE WILL SOON GOBBLE
	JSR PC,ITM0PO	;NOW WE POP THE ITEM STACK
	MOV PFREEQ,A	;GET A PROCESS TABLE ENTRY
	BNE CRPRO2	;GOT ONE!
	MOV B,A		;AFTER ALL THAT WORK
	JSR PC,DLITEM	;WE HAVE TO GIVE UP
CRPRO1:	SEZ		;FAILURE
	RTS PC
CRPRO2:	MOV B,PRTPPT(A)	;SAVE THE ITEM # OF THE PROCESS IN THE PROCESS TABLE
	MOV #IPRIOR,PRTPRI(A)	;EVERYONE STARTS OUT WITH THIS
	SAVE B		;SAVE THE ITEM NUM
	MOV CURUSR,B	;THE CURRENT USER BLOCK
	CMP #-1,CURUSR	;ONLY THE VERY FIRST TIME (I HOPE)
	BEQ CRPRO3
	MOV PRTJTM(B),PRTJTM(A)	;START HIM AT A DISADVANTAGE
CRPRO3:	MOV B,PRTUPT(A)		;THE USER CREATING THIS IS THE PROCESS'S USER
	MOV #STOPQ,B	;MOVE FROM THE FREE Q TO THE STOPPED Q
	JSR PC,TQUEUE
	MOV A,B
POPACZ:	REST A		;ITEM NUM
	CLZ		;SUCESS
	RTS PC


;KEEP THIS NEAR CRPROC
;CREATE A USER
;RETURN ITEM NUMBER IN A, ADDRESS OF PROCESS TABLE ENTRY IN B
;CLEAR Z IF SUCESSFUL, OTHERWISE SET IT
CRUSER:	MOV #USRLEN,A	;THE LENGTH OF A USER
	JSR PC,CRITEM	;DO IT!
	BEQ CRPRO1	;FAIL
	JSR PC,CLITEM	;CLEAR THE ITEM
	MOV #ITUSER,(A)	;SET THE TYPE
	JSR PC,CRUSR1	;USE A LOT OF CODE FROM CRPROC
;NOTE THAT THIS WILL LEAVE THE USER ON THE STOP QUEUE
;WHICH WILL CAUSE A PROBLEM IF THE SCHEDULER RUNS
;WHICH IT SHOULDN'T
	BEQ CRPRO1	;FAILURE
	SAVE A		;SAVE THE ITEM INDEX
	MOV B,A		;THE PROCESS TABLE ADDRESS
	MOV #USERQ,B	;THE PLACE WHERE A USER BELONGS
	JSR PC,TQUEUE	;TRANSFER TO USER QUEUE
	MOV A,B
	BR POPACZ	;SUCCESS

;DECREMENT REFERENCE COUNT OF PROCESS IN A
;WIPE IT OUT IFCOUNT REACHES ZERO
DLPROC:	SAVE B
	JSR PC,ITM0PL
	DEC PRSREF(A)	;ONE LESS REFERENCE
	BNE DLPRO1	;SOMEONE ELSE STILL REFERENCES IT
	JSR PC,REMPRS	;REMOVE IT FROMTHE SPHERE
	MOV ITM0A,A
	MOV PPRTPT(A),A	;THE PROCESS TABLE ENTRY FOR IT
	MOV #PFREEQ,B	;MAKE THE PROCESS TABLE ENTRY FREE
	JSR PC,TQUEUE
	MOV ITEM0,A
	JSR PC,DLITEM	;FLUSH THE ACTUAL PROCESS
	JSR PC,ITM0PO
	REST B
	SEZ		;SAY YOU DELETED IT
	RTS PC
DLPRO1:	JSR PC,ITM0PO
	REST B
	CLZ		;SAY YOU DIDN'T DELETE THE PROCESS
	RTS PC

;TRANFER PROCESS TABLE ENTRY IN A
;FROM IT'S PRESENT QUEUE TO THE ONE IN B
TQUEUE:	SAVE <C,PS>
	SPL 7
;MUST SPL 7 HERE IF THE INT LEVEL LOOKS AT QUEUES BACKWARDS
	MOV (A),C	;THE FORWARD POINTER OF THE ENTRY TO BE MOVED
	MOV C,@PRTBCK(A)	;CORRECT THE FORWARD POINTER OF THE PREVIOUS ENTRY
	TST C		;IS THERE A NEXT ENTRY?
	BEQ .+10	;NO, DON'T DO ANYTHING TO IT!
	MOV PRTBCK(A),PRTBCK(C)	;CORRECT THE BACK POINTER OF THE NEXT ENTRY
;MAY SPL 0 HERE, THE ENTRY IS IN LIMBO FOR THE TIME BEING
	MOV (B),C	;GET THE CONTENTS OF THE QUEUE POINTER
	MOV C,(A)	;POINT THE THING BEING MOVED AT THE BEGGINING OF THE QUEUE
	MOV B,PRTBCK(A)	;CORRECT BACK POINTER OF THING WE ARE MOVING
;SPL 7 HERE IF YOU DID ABOVE
	TST C		;IS THERE AN OLD FIRST ENTRY?
	BEQ .+6		;NO, DON'T DO ANYTHING TO IT!
	MOV A,PRTBCK(C)	;FIX BACK POINTER OF OLD FIRST ENTRY ON NEW QUEUE
	MOV A,(B)	;FIX QUEUE POINTER ITSELF
;SPL 0
	SAVE A
	MOV PRTPPT(A),A	;GET THE ITEM NUMBER OF THE THING
	JSR PC,ITM0PL
	CLR PQBIT(A)
	BIS QBIT(B),PQBIT(A)	;SET THE RIGHT Q-BIT
	JSR PC,ITM0PO
	REST A
	REST <PS,C>
	RTS PC
;PUT THE PROCESS WHO'S ITEM IS IN A
;INTO THE SPHERE WHOS ITEM IS IN B
;SHOULD FAIL FOR RUNNING PROCESS OR TOO MANY PROCESSES IN SPHERE (NOT YET)
;CLEARS Z ON SUCESS
PUTPRS:	SAVE <A,B>
	JSR PC,ITM0PL	;PUT THE PROCESS INTO ITEM 0
	TST PSTOPC(A)	;IS IT STOPPED?
	BEQ PUTPR2	;NO, CAN'T MOVE IT THEN
	JSR PC,REMPRS	;GET IT OUT OF ANY SPHERE IT IS IN
	MOV (P),A	;GET THE SPHERE INDEX
	JSR PC,ITM1PL	;LOAD IT UP
	MOV ITM0A,B	;ADDRESS OF THE PROCESS
	BIT #FAULT1!FAULT2!FAULT3,SFLAG(A)	;IS THERE A FAULT HAPPENING
	BEQ PUTPR1
	BIS #PSPHSB,PSTOP(B)	;SAY I AM PART OF IT
	INC PSTOPC(B)
PUTPR1:	MOV SPHPRP(A),PSPHCP(B)	;POINT PROCESS TO BEG OF OLD LIST
	MOV (P),PSPHRP(B)	;TELL PROCESS WHO IT BELONGS TO
	MOV 2(P),SPHPRP(A)	;LINK IT INTO THE LIST
	INC PRSREF(B)		;INCREMENT THE REFERENCE COUNT
	REST <B,A>
	JSR PC,ITM0PO
	JSR PC,ITM1PO
	CLZ
	RTS PC
PUTPR2:	JSR PC,ITM0PO	;POP ITEM 0
	REST <B,A>
	SEZ	;SAY WE CAN'T DO IT
	RTS PC
;REMOVE PROCESS IN ITEM0 (ADDRESS IN A) FROM WHATEVER SPHERE IT IS IN
;CLOBBERS B AND A
REMPRS:	MOV PSPHRP(A),A	;POINTER TO SPHERE THIS BELONGS TO
	BLE REMPR1	;WHEW, NO SPHERE, IT'S EASY
	JSR PC,ITM1PL	;GET THE SPHERE IT'S IN
	MOV ITM0A,B	;ADDRESS OF THE PROCESS ITEM
	CMP SPHPRP(A),ITEM0	;DOES IT POINT DIRECTLY TO THE PROCESS?
	BNE REMPR3	;NO, GO SEARCH FO RIT
	MOV PSPHCP(B),SPHPRP(A)	;SPLICE IT OUT OF THE LIST
	BR REMP10	;SKIP THIS LOAD
REMPR5:	MOV PSPHRP(A),A	;GET THE SPHERE BACK
	JSR PC,ITM1LD	;LOAD IT UP
REMP10:	BIT #FAULT1!FAULT2!FAULT3,SFLAG(A)	;WAS IT STOPPED FOR FAULT
;	BEQ REMPR9	;NO
	BR REMPR9	;WELL BRUCE, I DON'T KNOW WHAT THIS CRAP IS FOR!!-RON
	DEC PSTOPC(B)	;RESTART IT
	BIC #PSPHSB,PSTOP(B)	;CLEAR THE SPHERE STOPPING IT BIT.
	BGT REMPR8	;WAS STOPPED FOR ANOTHER REASON
	INC PSTOPC(B)	;STOP IT AGAIN BUT SAY SUPERIOR STOPPED IT
	BIS #PSUPSB,PSTOP(B)	;OKAY FOR NOW
REMPR8:	ADD #PFAULT,B	;POINT TO THE FIRST PHAULT WORD
	TST (B)+	;CHECK THE THREE PHAULT WORDS
	BNE REMPR7
REMPR9:	JSR PC,ITM1PO	;RESTORE ITEM 1
	MOV ITM0A,A	;ADDRESS OF PROCESS
	CLR PSPHRP(A)	;NO LONGER IN SPHERE
	MOV ITEM0,A	;THE PROCESS
	JSR PC,SPRDEC	;DECREMTENT THE REF COUNT AND DELETE IF 0
REMPR1:	RTS PC
REMPR7:	MOV ITEM1,A	;THE SPHERE TO DO THE DEED ON
	JSR PC,FALTFX	;FIX THE FAULT
	CLR -(B)	;CLEAR THE FAULT WORDS
	BR REMPR9	;DONE
REMPR3:	MOV SPHPRP(A),A	;GET THE FIRST PROCESS IN LINE
REMPR6:	BUGC NE		;IS THERE ANOTHER ONE?
	JSR PC,ITM1LD	;PUT THIS PROCESS INTO ITEM1
	CMP PSPHCP(A),ITEM0	;DOES IT POINT TO PROCESS WE WANT TO SPLICE OUT?
	BNE REMPR4	;NOPE, KEEP TRYING
	MOV ITM0A,B
	MOV PSPHCP(B),PSPHCP(A)	;SPLICE IT OUT OF THE LIST
	BR REMPR5	;NOW WE CAN PUT IT WHERE WE WANT TO
REMPR4:	MOV PSPHCP(A),A	;GET NEXT ONE
	BR REMPR6	;GO CHECK IT OUT

;DECREMENT STOP COUNT OF PROCESS
;IF IT REACHES ZERO, PUT PROCESS ONTO RUN Q
;ASSUMES PROCESS IS LOADED INTO ITEM 0
PSTPDC:	SAVE A
	MOV ITM0A,A	;WHERE IS IT?
	DEC PSTOPC(A)	;ONE LESS REASON TO BE STOPPED
	BUGC GE		;SHOULD NOT GET NEGATIVE!
	BGT PSTPD1	;DON'T START IT YET
	SAVE B
	MOV PPRTPT(A),A	;POINTER TO THE PROCESS TABLE
	MOV #RUNQ,B	;PUT IT ONTO THE RUN Q
	JSR PC,TQUEUE
	REST B
PSTPD1:	REST A
	RTS PC
;INCREMENT STOP COUNT OF PROCESS WHOSEITEM ISIN A
;IF THE COUNT WAS ZERO AND THE PROCESS WAS IN THE SYSTEM, PCLOSER IT
PSTPIN:	JSR F,ACSAV
	JSR PC,ITM0PL	;GET IT INTO THE MAP
	TST PSTOPC(A)	;IS IT ALREADY NON-ZERO?
	BNE PSTPI1	;YES, JUST INCREMENT
	MOV PPRTPT(A),A	;IT'S PROCESS TABLE ENTRY
	MOV #STOPQ,B	;STOP THE PROCESS
	JSR PC,TQUEUE
	MOV ITM0A,A
	TST PSPC(A)	;IN THE SYSTEM?
	BEQ PSTPI1	;NOPE, PC ISUSER MODE PC
	CLR PSPC(A)	;CLEAR HIS PC
	JSR PC,PRSUNL	;UNLOCK HIS SWITCHES
PSTPI1:	INC PSTOPC(A)	;TELL THE WORLDHE IS STOPPED
	JSR PC,ITM0PO
	JSR F,ACRES
	RTS PC

;UNLOCK ALL THE SWITCHES OF THE GUY IN ITEM0
;IN "BEING PCLOSERED" MODE
;CAN BE EXPECTED TO CLOBBER MOST REGISTERS
PRSUNL:	SAVE BPCLSR	;SAVE THE FLAG
	MOV #1,BPCLSR	;SAY WE ARE PCLOSERING HIM
PSTPI2:	MOV ITM0A,A
	TST PLCKSL(A)	;ANY SWITCHES LOCKED
	BEQ PSTPI3	;NOPE
	JSR PC,LSWPOP	;POP THE TOP SWITCH
	BR PSTPI2
PSTPI3:	REST BPCLSR	;DONE PCLOSERING HIM
	RTS PC

;THIS IS WHERE WE GET AFTER SOMEONE SETS PIRQ AND PIRBRK DISPATCHES
;(NOTE THAT WE DON'T GET TO PIRBRK UNTIL ALL INTERUPTS HIGHER
;THAN CLKL HAVE EXITED. CLKL SHOULD BE THE LOWEST INTERUPT IN
;THE SYSTEM, SO IT ALWAYS INTERRUPTS DIRECTLY FROM
;THE MAIN PROGRAM LEVEL)
;STOP A PROCESS IF IT IS IN USER MODE
;IF IT FINDS THE PROCESS
;WAS IN USER MODE, IT ASSUMES THAT THE SECOND REGISTER SET
;WAS BEING USED, AND CLOBBERS SET 0 ARBITRAILY
;IT SAVES THE PROCESSES REGISTERS, THEN RETURNS TO WHOMEVER STARTED
;THE PROCESS BY DOING AN RTS PC
STOPPR:	TST USRMOD	;ARE WE IN USER MODE?
	BNE PIRRET	;NOPE, THE SYSTEM WILL STOP HIM
	MOV PC,USRMOD	;NO LONGER IN USER MODE
	TST (P)+	;FLUSH THE SAVED A
	JSR F,SPCPSP	;SAVE THE PC, THE PS AND P
	JSR PC,PACSAV	;SAVE THE REST OF THE REGISTERS, INCLUDING THE FPP
	JSR PC,SAVAWB	;SAVE THE A AND W BITS
	JSR PC,TIMEUS	;GO CHARGE HIM FOR TIME USED
	MOV #-1,PRUNNG	;NO PROCESS RUNNING NOW
	CLR CDISP	;NO ONE AROUND
	MOV ITM1A,A	;POINT TO THE PROCESS
	MOV SPRTPT(A),A	;PROCESS TABLE POINTER
	TST PRTPRI(A)	;WAS I A WINNER
	BGE .+4		;YES
	RTS PC
	DEC NWINRS	;ONE LESS WINNER
	BIS #100000,PRTPRI(A)	;CLEAR THE WINNER BIT IN THE SPHERE
	RTS PC		;(GULP!!) RETURN TO CALLER
PIRRET:	REST A
	RTT
;CHARGE USER FOR THE TIME HE HAS USED
;EXPECTS POINTER TO ITEM0 IN A. CLOBBERS B AND C
;AND SPHERE IN ITEM1
TIMEUS:	MOV TUSED,B	;NUMBER OF TICKS HE USED
	ASL B		;CONVERT TO HALF TICKS
	BNE .+4		;DID HE USE ANY TIME?
	INC B		;EVERYONE USES AT LEAST ONE HALF-TICK
	ADD B,PTUSED(A)	;UPDATE HIS TIME USED
	ADC PTUSED+2(A)
	MUL #JTMUAC,B	;MULTIPLY BY THE ADDTIVE FACTOR
	MOV PPRTPT(A),C	;POINTER TO PROCESS BLOCK
	ADD B,PRTJTM(C)	;UPDATE THE PROCESS JTMU
	MOV PRTUPT(C),C	;POINTER TO THE USER BLOCK
	ADD B,PRTJTM(C)	;UPDATE THAT JTMU TOO
	SAVE <D,E>
	MOV ITM1A,C	;POINTER TO THE SPHERE
	ADD #SUPTS,C	;MAKE C POINT TO THE FIRST UPT
	MOV #20,B	;NUMBER OF UPT'S
TIMUS1:	BIT #UPTDEI,2(C)	;IS IT I=D SPACE
	BEQ TIMUS2	;NO
	CMP #10,B	;IS IT A DATA PAGE
	BLE TIMUS3	;YES, IT IS ALREADY COUNTED
TIMUS2:	MOVB 1(C),D	;THE DR
	BIC #177617,D	;CLEAR ALL BUT THE LENGTH OF THE REFERENCED ENTRY
	ADD #20,D	;SINCE 0 IS A 1 BLOCK PAGE
	ADD D,E		;GET THE TOTAL CORE LENGTH
TIMUS3:	ADD #UPTLEN,C	;POINT TO THE NEXT UPT
	SOB B,TIMUS1	;GET ALL THE PAGES
	ASH #-4,D	;GET IT INTO THE LOW BITS
	MUL TUSED,D	;GET THE CORE TIME PRODUCT
	MOV ITM1A,C	;POINTER TO THE SPHERE
	MOV SPRTPT(C),C	;POINTER TO PROCESS TABLE ENTRY FOR THIS SPHERE
	ADD D,PRTJTM(C)	;ADD TO THE JTMU
	BVC .+10	;IT DIDN'T OVERFLOW
	MOV #-1,PRTJTM(C)	;MAKE IT AS LARGE AS WE CAN (THE CORE HOG!!!)
	REST <E,D>
	RTS PC
;ENTER THE RUNNING QUEUE
RUNME:	SAVE <A>
	MOV ITM0A,A	;THE PROCESS
	BIT #PPCLSR,PFLAGS(A)	;SHOULD I BE PCLOSERED
	BEQ RUNME1	;NO
	BIC #PPCLSR,PFLAGS(A)	;CLEAR THE PCLOSER FLAG
	MOV #1,BPCLSR	;PCLOSER ME
	JSR PC,LSWCLR	;CLEAR THE SWITCHES
RUNME1:	REST A
	SAVE #RUNQ	;PUT ME ON THE RUN QUE
	BR FLUSH
;ENTER THE SHORT FLUSHED QUEUE
SFLUSH:	SAVE #SFLSQ
	BR FLUSH
;ENTER THE LONG FLUSH QUEUE
LFLUSH:	SAVE #LFLSQ
	BR FLUSH
;ENTER THE PAGE WAIT QUEUE
PAGEW:	SAVE #PAGWQ
	BR FLUSH
;ENTER THE SWAP BLOCKED QUEUE
SWAPB:	SAVE #SWPBQ
FLUSH:	SAVE A		;GET A FREE REGISTER
	MOV ITM0A,A	;THE RUNNING PROCESS IS ALWAYS ITEM 0
	ADD #PSREGS,A	;A POINTER TO THE SYSTEM REGISTERS FOR THE GUY
	REST (A)+	;GET BACK A
.IRPC X,<BCDEF>
	MOV X,(A)+
.ENDM
	MOV ITM0A,E
	MOV PPRTPT(E),A	;POINTER TO PROCESS TABLE
	MOV (P),B	;QUEUE TO MOV IT TO
	JSR PC,TQUEUE	;DO THE ACTUAL MOVE
	MOV ITM0A,A
	REST <B,E>		;GET THE QUEUE AGAIN
	TST PSPC(A)	;WERE WE ALREADY FLUSHED?
	BNE FLUSH2	;YES
.IRPC X,<012>
	TST ITM'X'D
	BUGC EQ		;HAD ITEMS PUSHED
.ENDM
	CLR CDISP	;OLD GUY NOT RUNNING ANY MORE
	JSR PC,PACSAV	;IN CASE USER'S REGISTERS NOT SAVED YET
	JSR PC,TIMEUS	;CHARGE HIM FOR TIME USED
	JSR PC,SAVAWB	;SAVE REFERENCED PAGES
	JSR PC,PDLSAV	;SAVE THE SYSTEM PDL
	MOV ITM1A,A	;POINT TO THE SPHERE
	MOV SPRTPT(A),A	;POINT TO THE PROCESS TABLE ENTRY
	TST PRTPRI(A)	;AM I A WINNER
	BMI FLUSH2	;NO
	BIS #100000,PRTPRI(A)	;NOW A LUSER
	DEC NWINRS	;ONE LESS WINNER
FLUSH2:	MOV ITM0A,A
	MOV ITEM2,PITM2(A)	;SAVE THE GUYS ITEM 2
	TST BPCLSR	;IS THIS A SPECIAL PCLOSER?
	BEQ .+4		;YES, LEAVE MY PSPC AS IS
	CLR E		;SET HIS PSPC TO ZERO
	MOV E,PSPC(A)
	CLR BPCLSR	;CLEAR THE PCLOSER FLAG
	RTS PC
;START THE PROCESS WHOSE PROCESS TABLE ENTRY IS
;POINTED TO BY A
;WHEN PROCESS FINALLY STOPS, THE ROUTINE WILL RETURN
;CLOBBERS ALL REGISTERS
STPROC:	MOV P,STPSVP	;SAVE P FOR ERROR RECOVERY
	BIS #30000,PS	;MAKE SURE PREVIOUS MODE IS USER
	SPL CLKL	;STOP US FROM GETTING STOPPED
	BIC #CLKPIR,PIRQ	;MAKE SURE NO STOP PENDING
	MOV PRTUPT(A),CURUSR	;THE GUY TO "CHARGE" FOR THIS RUN
	CLR TUSED		;START COUNTING NOW
	MOV PRTPPT(A),A		;GET THE PROCESS ITEM #
	MOV A,PRUNNG		;THIS IS THE RUNING PROCESS
	MOV A,CDISP		;SAY WHICH PROCESS IS RUNNING
	JSR PC,ITM0LD	;IT IS EXPECTED TO BE IN ITEM0
	MOV A,B		;SAVE THE POINTER TO IT
	MOV PITM2(A),A	;GET HIS OLD ITEM 2
	JSR PC,ITM2LD	;RESTORE IT
	MOV B,A
	MOV PSPHRP(A),A	;GET A POINTER TO THE SPHERE
	JSR PC,ITM1LD	;IT IS EPECTED IN ITEM1
	JSR PC,PACRES	;RESTORE REGISTER SET 1
	JSR PC,MAPRES	;RESTORE THE MAP
	SAVE PUP(B)	;GET THE USER'S PDL POINTER
	MTPI P		;RESTORE IT TO HIM
	TST PSPC(B)	;IS HE RUNNING IN THE SYSTEM?
	BNE STPRO1	;YES, GO RESTORE OTHER THINGS
	BIC #PPCLSR,PFLAGS(B)	;THEN HE DOESN'T NEED TO BE PCLOSERED!
	TST PFAULT(B)	;IS THERE A FAULT?
	BEQ .+6		;NO, JUST RETURN TO HIM
	JMP CFAULT	;CAUSE THE MAGIC FAULT TO HAPPEN
	MOV P,PSP(B)	;WHERE THE PDL ENDS
	SAVE <PUPS(B),PUPC(B)>	;HIS PROCESSOR STATUS AND HIS PROGRAM COUNTER
	CLR USRMOD	;THE WORLD IS NOW IN USER MODE
	RTT		;RETURN TO HIM IN USER MODE

STPRO1:	BIT #PPCLSR,PFLAGS(B)	;SHOULD HE BE PCLOSERED?
	BEQ STPRO2	;NO
	BIC #PPCLSR,PFLAGS(B)
	CLR PSPC(B)
	JSR PC,LSWCLR	;CLEAR THE SWITCHES
	RTS PC		;RETURN TO THE SCHEDULER

STPRO2:	JSR F,PDLRES	;RESTORE HIS SYSTEM PDL
	SAVE <#30000,PSPC(B)>	;GET PS AND GET PC
	CLR PSPC(B)	;INDICATE NOT HUNG
	MOV (P),USRMOD	;INDICATE THAT WE ARE NOT IN USER MODE
	MOV B,A		;POINTER TO THE PROCESS
	ADD #PSREGS+14,A	;THE SYSTEM REGISTERS
.IRPC X,FEDCBA
	MOV -(A),X
.ENDM
	RTT		;EXIT TO RIGHT PLACE IN THE SYSTEM
;SAVE THE USER'S PC, PS AND PDL POINTER
;CALL WITH JSR F,SPCPSP
;A GETS CLOBBERED TO ITEM 0 ADDRESS
;F GETS CLOBBERED TO VALUE OF THE USER'S P
;ITEM0 IS EXPECTED TO BE THE PROCESS
SPCPSP:	TST (P)+
	MOV ITM0A,A	;THE ADDRESS OF THE PROCESS IN THE MAP
	REST <PUPC(A),PUPS(A)>	;SAVE HIS PC AND HIS PS
SAVEPP:	MOV ITM0A,A
	MFPD P		;GET HIS P
	MOV (P),PUP(A)	;SAVE HIS PDL POINTER (PUP-P?)
	RTS F		;RETURN WITH P IN F
;SAVE THE PROCESSES REGISTERS, INCLUDING THE FPP IF THAT IS ENABLED
;THE GENERAL REGISTERS ARE IN SET 1
;THE ADDRESS OF THE PROCESS ITEM IS EXPECTED IN A
;THE PROCESS ITEM IS EXPECTED TO BE IN THE MAP
PACSAV:	SAVE A		;TO COMMUNICATE WITH THE OTHER REGISTER SET
	BIT #PACSVF,PFLAGS(A)	;HAVE THE AC'S ALREADY BEEN SAVED?
	BEQ PACSV1	;ZERO=>SAVED
	BIC #PACSVF,PFLAGS(A)
	BIS #4000,PS	;CHANGE TO OTHER SET
	SAVE A		;SAVE A OF SET 1
	MOV 2(P),A	;GET A FROM SET 0
	ADD #PUREGS,A	;POINT TO PALCE TO SAVE REGISTERS
	REST (A)+	;SAVE A OF SET 1
	MOV B,(A)+	;SAVE REST OF SET 1
	MOV C,(A)+
	MOV D,(A)+
	MOV E,(A)+
	MOV F,(A)+
	BIC #4000,PS	;BACK TO SET 0
;NOTE THAT SET 0'S A HAS NOT BEEN CLOBBERED
	BIT #PFPFLG,PFLAGS(A)	;HAS HE ENABLED THE FPP?
	BEQ PACSV1	;NOPE
	STFPS PFPPS(A)		;STORE THE STATUS
	ADD #PFPPRG,A	;POINT TO FPP REGISTERS
	SETD		;SO WE SAVE ALL THE BITS
	STD A,(A)+
	STD B,(A)+
	STD C,(A)+
	STD D,(A)+	;SAVE ALL WE CAN GET TO DIRECTLY
	LDD E,A		;LAST 2 HAVE TO BE MOVED SPECIAL
	STD A,(A)+
	LDD F,A
	STD A,(A)+
PACSV1:	REST A
	RTS PC
;RESTORE THE USER'S REGISTERS
;B IS EXPECTED TO CONTAIN A POINTER TO THE PROCESS ITEM
;NO REGISTERS ARE CLOBBERED (EXCEPT, OF COURSE, THE USER'S)
PACRES:	SAVE B
	BIT #PACSVF,PFLAGS(B)	;WERE THEY EVER SAVED?
	BNE PACRS1	;ONE=>NOT SAVED
	BIS #PACSVF,PFLAGS(B)
	BIS #4000,PS	;GO TO REGISTER SET 1
	MOV (P),A	;GET THE POINTER TO THE ITEM
	ADD #PUREGS+14,A	;CONVERT TO A REGISTER POINTER
.IRPC X,<FEDCBA>
	MOV -(A),X
.ENDM
	BIC #4000,PS	;BACK TO SET 0
	BIT #PFPFLG,PFLAGS(B)
	BEQ PACRS1		;DOESN'T USE FPP
	SETD		;RESTORE ALL BITS
	ADD #PFPPRG+<16.*2>,B	;POINT TO REGISTERS E AND F FIRST
	LDD (B)+,A
	STD A,E
	LDD (B)+,A
	STD A,F
	MOV (P),B
	ADD #PFPPRG,B		;GO BACK FOR REG'S A THROUGH D
.IRPC X,<ABCD>
	LDD (B)+,X
.ENDM
	MOV (P),B
	LDFPS PFPPS(B)
PACRS1:	REST B
	RTS PC
;RESTORE THE USER'S SYSTEM PDL
;CALLED WITH JSR F,PDLRES  
;CLOBBERS A AND C AND F
;AS WELL AS PUSHING THINGS ONTO P
;EXPECTS A POINTER TO THE PROCESS ITEM IN B
PDLRES:	TST (P)+
	MOV PSP(B),A	;THE VALUE THAT THE STACK POINTER SHOULD HAVE
	MOV P,PSP(B)	;FOR PDLSAV, THE VALUE IT SHOULD HAVE AFTER SAVING
	MOV B,C		;COPY POINTER TO ITEM
	ADD #PPDL,C	;MAKE IT A POINTER TO THE PDL
PDLRE2:	CMP P,A		;HAVE WE PUSHED ENOUGH?
	BEQ PDLSA1	;YUP
	MOV (C)+,-(P)	;POP-PUSH
	BR PDLRE2
;SAVE THE SYSTEM PDL INTO THE PROCESS'S
;SYSTEM PDL AREA. SAVES UP TO WHAT IS INDICATED BY PSP
;CALLED WITH JSR PC,PDLSAV
;CLOBBERS A,B,C, AND F
;ALSO POPS STUFF OFF THE STACK
PDLSAV:	REST F		;GET THE RETURN ADDRESS
	MOV ITM0A,A	;GET A POINTER TO THE PROCESS
	MOV PSP(A),B	;WHAT THE PDL POINTER SHOULD BE
	MOV P,PSP(A)	;SAVE THE TOP OF PIDDLE
	MOV B,C
	SUB P,B		;WHAT'S THE DIFFERENCE?
	BEQ PDLSA1	;NONE, FORGET IT
	BUGC GT		;MAKE SURE IT'S POSITIVE
	CMP #PRPDLL,B	;IS IT PUSHED TO DEEP?
	BUGC GT		;NAUTGHY!
	ADD A,B		;MAKE A POINTER TO THE END OF
	ADD #PPDL,B	;THE PROCESS'S PDL
PDLSA2:	MOV (P)+,-(B)	;POP-PUSH
	CMP C,P		;ARE WE DONE YET?
	BNE PDLSA2	;NOPE
PDLSA1:	JMP (F)

;RETURN THE NEXT WOR DFROM THE USER'S PDL
;INCREMENT THE POP COUNT SO IT IS POPED IF THE CALL RETURNS
;THE WORD IS RETURNED IN A
RETNSW:	SAVE B
	MOV ITM0A,A	;ASSUME THE PROCESS IS ITEM 0
RETNS1:	MOV PUP(A),B	;THE PDL POINTER
	ADD PUPDLO(A),B	;THE OFFSET SO FAR
	ADD #2,PUPDLO(A)	;POPPED ONE MORE THING
	MFPD (B)	;GET THE WORD
	MOV  (P),A	;SAVE THE WORD
	MTPD (B)	;MAKE SURE WE CAN WRITE IT BACK
	REST B
	RTS PC
;RETURN THE PREVIOUS WORD FROM THE USER'S STACK (THE ONE YOU GOT ALREADY)
;RETURNED IN A
RETPSW:	SAVE B
	MOV ITM0A,A
	SUB #2,PUPDLO(A)	;BACK UP!
	BR RETNS1	;GO DO THE REST

:GIVE THE WORD IN B TO THE USER
GIVPSW:	SAVE <A,C,B>
	MOV ITM0A,A	;ASSUME PROCESS IS IN ITEM0
	MOV PUP(A),C	;THE PDL POINTER
	SUB #2,PUPDLO(A)	;DEC THE OFFSET
	ADD PUPDLO(A),C	;MAKE IT CORRECTED
	MTPD (C)	;MOVE THE WORD
	REST <C,A>	;RESTORE REGS
	RTS PC
	.SBTTL SPHERE HACKING ROUTINES

;CREATE A SPHERE
;RETURN THE INDEX OF THE ITEM IN A
CRSPHR:	SAVE B
	MOV #SPHLEN,A	;THE LENGTH OF A SPHERE (INITIALLY)
	JSR PC,CRITEM	;MAKE ONE
	BNE CRSPH1	;DID IT SUCEED?
CRSPH0:	REST B
	SEZ		;INDICATE FAILURE
	RTS PC		;NOPE
CRSPH1:	JSR PC,CLITEM	;LOAD IT INTO ITEM0 AND CLEAR IT
	MOV #ITSPHR,(A)	;SET THE TYPE
	MOV CURUSR,SUSRPT(A)	;THE GUY WHO CREATES IT GETS "CHARGED" FOR  IT
	MOV #SICLST+<NCLSEB*CLSELN*2>,SCLSEP(A)	;THE LAST LOCATION USED
	SAVE <C,B>
	MOV A,B
	ADD #SCLSTT,B	;GET AN ADDRESS POINTER TO THE INDEX TABLE
	MOV #<MNCLSE/NCLSEB>/2,C	;NUMBER OF WORDS OF POINTERS
	MOV #-1,(B)+
	SOB C,.-4	;INTIALIZE THEM TO POINT AT NOTHING
	MOVB #1,-(B)	;EXPECT THE LAST ONE POINTS AT THE 2ND BLOCK
	CLRB SCLSTT(A)	;AND THE FIRST TO THE FIRST
	MOV CURSPH,SMSSPT(A)
	MOV (P),B	;GET THE ITEM INDEX BACK
	JSR PC,CRUSR1	;INITIALIZE THE PROCESS TABLE ENTRY
	BEQ CRSPH2
	MOV B,A		;THE PROCESS TABLE ENTRY
	MOV #SPHRQ,B	;THE PLACE TO PUT IT
	JSR PC,TQUEUE	;MOVE IT
	REST A	;THE ITEM #
	REST C
	REST B	;THE ORIGINAL CONTENTS OF B
	CLZ		;SUCECESS
	RTS PC
CRSPH2:	REST <A,C>
	BR	CRSPH0

;SAVE THE A AND W BITS FOR THE CURRENT SPHERE
;THE SPHERE IS EXPECTED TO BE IN ITEM1, AND THE USER
;SEGMENTATION REGISTERS ARE EXPECTED TO REFLECT THIS SPHERE
SAVAWB:	JSR F,ACSAV
	MOV ITM1A,A	;ADDRESS OF ITEM1 IN THE MAP
	ADD #SUPTS+UPTDR,A	;POINT TO THE UPTS DR
	MOV #USRISD,B	;THE ACTUAL SEGMENTATION REGISTERS
	MOV #20,C	;NUMBER OF SEGMENTS
SAVAW1:	MOV (B)+,D	;THE SEGMENTER'S DR
	BIC #177477,D	;JUST THE A+W BITS
	MOV D,E		;COPY THEM
	ASR E		;SHIFT IT DOWN
	BIC #177700,E	;CLEAR ALL BUT THE W BIT (BECOMES THE M BIT)
	BIS E,D		;TOTAL BITS TO SET
	BIS D,(A)	;INTO THE APPROPRIATE UPT
	TST (A)		;IS IT A D=I PAGE?
	BGE SAVAW2	;NOPE
	CMP C,#10	;IS IT AN I PAGE?
	BGT SAVAW2	;YES, JUST IGNORE IT
	BIS D,-10*UPTLEN(A)	;SET THE COORESPONDING I PAGE
SAVAW2:	ADD #UPTLEN,A	;TO THE NEXT UPT ENTRY
	SOB C,SAVAW1
	JSR F,ACRES
	RTS PC
	.SBTTL SPHERE HACKING ROUTINES- C-LIST HANDLERS
;GET ADDRESS OF A C-LIST ENTRY
;A CONTAINS ADDRESS OF SPHERE IN MAP
;B CONTAINS C-LIST NUMBER
;B RETURNS OFFSET INTO SPHERE IF SUCESSFUL (Z CLEAR)
;OTHERWISE Z SET AND B CONTAINS SPHERE BYTE ADDRESS OF INDEX BYTE
GCLSTA:	SAVE <D,C,A>
	CMP B,#200		;IS IT TO LARGE?
	BHIS GCLST1	;YES
	CLR C		;FOR THE DIVIDE
	MOV B,D		;SAVE C-LIST NUMBER
	DIV #NCLSEB,C	;GET THE BLOCK AND OFFSET
	ADD C,A		;CONVERT TO
	ADD #SCLSTT,A	;ADDRESS OF INDEX BYTE
	MOVB (A),B	;GET THE BYTE
	BLT GCLST1	;NEGATIVE IMPLIES NO STUCK BLOCK
	MUL #NCLSEB*CLSELN,B	;RELATIVE ADDRESS OF BLOCK
	MUL #CLSELN,D	;REMANDER
	ADD D,B		;NOW WITHIN BLOCK
	ADD #SICLST,B	;LESS RELATIVE
	REST <A,C,D>
	CLZ		;SUCESS
	RTS PC
GCLST1:	MOV A,B		;SAVE FOR THE CALLER
	REST <A,C,D>
	SEZ		;FAILURE
	RTS PC
;ALWAYS GET THE ADDRESS OF A C-LIST ENTRY
;(CREATE IF NON-EXISTANT)
;B CONTAINSC-LIST NUMBER
;C CONTAINS ITEM NUMBER TO INSERT INTO
;A GETS CLOBBERED
;B RETURNS OFFSET INTO SPHERE IF SUCESSFUL (Z CLEARED)
;OTHERWISE, SET Z
AGCLSA:	SAVE B
	MOV C,A		;COPY SPHERE ITEM NUMBER
	JSR PC,ITM1PL	;LOAD IT INTO THE MAP
	JSR PC,GCLSTA	;SEE IF THE ENTRY IS ALREADY THERE
	BNE AGCLS1	;SUCESS, IT'S ALREADY THERE
	MOV SCLSEP(A),A	;POINTER TO BEGGINING OF UNUSED SPACE
	ADD #NCLSEB*CLSELN,A	;NEW END
	JSR PC,ITM1PO	;IN CASE WE HANG
	SAVE B
	MOV C,B		;COPY SPHERE ITEM NUMBER
	ASH #-6,A	;MAKE WORD SIZE INTO BLOCK SIZE
	JSR PC,EXITEM	;MAKE SURE IT'S BIG ENOUGH
	BEQ AGCLS2	;FAILURE
	MOV C,A		;ITEM WHERE THE NEW THING IS GOING
	JSR PC,ITM1PL	;LOAD IT UP
	MOV #NCLSEB*CLSELN/2,B	;NUMBER OF WORDS WE JUST ADDED
	MOV SCLSEP(A),C	;POINTER TO OLD END+2
	ADD #NCLSEB*CLSELN,SCLSEP(A)	;THE NEW END
	SAVE D
	MOV C,D		;FOR DIVIDE LATER
	ADD A,C		;MAKE IT A REAL ADDRESS FOR CLEAR
	CLR (C)+	;WIPE OUT NEW STUFF
	SOB B,.-2
	CLR C		;FOR DIVIDE
	SUB #SICLST,D	;MAKE IT RELATIVE
	DIV #NCLSEB*CLSELN,C	;GET BLOCK NUMBER
	MOV 2(P),B	;RESTORE BYTE POINTER
	MOVB C,(B)	;NEW BLOCK NUMBER
	MOV ITEM1,C	;THE SPHERE WE ARE HACKING
	JSR PC,ITM1PO	;RESTORE ITEM 1
	REST <D,B,B>
	BR GCLSTA	;TRY AGAIN
AGCLS1:	JSR PC,ITM1PO	;POP THE ITEM WE PUSHED
	TST (P)+
	CLZ
	RTS PC
AGCLS2:	REST <B,B>
	SEZ
	RTS PC
;GET THE ADDRESS OF A C-LIST ENTRY, ASSUMING THE SPHERE IS IN ITEM 1
;RETURN REAL ADDRESS IN A AND CLEAR Z, UNLESS YOU FAIL
AGCLAD:	SAVE <B,C>
	MOV ITEM1,C	;ASSUME THE SPHERE IS IN ITEM 1
	JSR PC,AGCLSA	;GO GET THE ADDRESS
	BEQ AGCLA1	;FAILURE
	MOV ITM1A,A	;GET THE ADDRESS IN THE MAP
	ADD B,A		;MAKE A REAL ADDRESS
	REST <C,B>
	CLZ
	RTS PC
AGCLA1:	REST <B,C>
	SEZ
	RTS PC


;GET A POINTER TO THE NEXT EXISTANT C-LIST ENTRY
;ON ENTRY, A POINTS TO THE ITEM WITH THE SPHERE
;D IS THE FIRST C-LIST NUMBER TO CHECK
;B RETURNS POINTING TO THE C-LIST ENTRY
;D RETURNS POINTING TO THE C-LIST ENTRY
;CLEAR Z IF SUCESSFUL, SET OTHERWISE
GNCLST:	CMP #MNCLSE,D	;AT THE LAST ENTRY?
	BNE GNCLS3	;NOT YET, TRY AGAIN
	RTS PC		;AT END, NOTE THAT Z IS SET
GNCLS3:	MOV D,B		;COPY THE C-LIST NUMBER
	JSR PC,GCLSTA	;TRY TO GET POINTER
	BEQ GNCLS1	;NO SUCH BLOCK
	ADD A,B		;MAKE A REAL POINTER
	TST (B)		;ANYHTING THERE?
	BEQ GNCLS2	;NO, TRY NEXT ONE
	RTS PC		;FOUND ONE, NOTE THAT Z IS CLEAR
GNCLS1:	ADD #NCLSEB-1,D	;NEXT BLOCK
GNCLS2:	INC D		;NEXT ENTRY
	BR GNCLST
;CREATE A C-LIST ENTRY, ITEM OF SPHERE IN C, POSITION OF ENTRY
;TO BE CREATED IN B (-1 GETS THE FIRST AVAILABLE ENTRY), RETRURNS WITH Z CLEARED
;NORMALLY, SETS Z IF SLOT ISN'T AVAILABLE, AND SETS C IF NO SLOTS AVAILABLE
;ON NORMAL RETURN, B CONTAINS C-LIST NO. AND A CONTAINS ADDRESS OF ENTRY RELATIVE TO SPHERE
CRCLST:	BIC #177400,B	;ONLY THE BOTTOM BYTE IS SIGINIFICANT
	CMP #377,B	;IS IT -1
	BNE CRCLS1	;NO, FIGURE OUT WHICH ONE IT IS
	MOV #MNCLSE-1,B	;START LOOKING AT THE TOP
CRCLS2:	SAVE B		;THE CURRENT C-LIST NO.
	JSR PC,AGCLSA	;GET A C-LIST ENTRY
	BEQ CRCLS3	;FAILED, BECAUSE NOT AVAILABLE
	MOV C,A		;THE SPHERES ITEM NO.
	JSR PC,ITM1PL	;LOAD IT UP
	ADD B,A		;MAKE THE POINTER TO THE C-LIST ENTRY ABSOLUTE
	TST (A)		;IS IT FREE
	BEQ CRCLS4	;YES RETURN SUCESSFUL
	REST B
	DEC B		;TRY THE NEXT C-LIST ENTRY
	BEQ CRCLS5	;NO MORE RETURN WITH CARRY SET
	JSR PC,ITM1PO	;POP THE SPHERE
	BR CRCLS2	;TRY THE NEXT ONE
CRCLS1:	SAVE B
	JSR PC,AGCLSA	;GET A C-LIST ENTRY
	BEQ CRCLS3	;FAILED (NOT AVAILABLE)
	MOV C,A		;SPHERES ITEM NO
	JSR PC,ITM1PL	;LOAD UP THE SPHERE
	ADD B,A		;MAKE THE POINTER ABSOLUTE
	TST (A)		;IS TI FREE
	BNE CRCLS6	;NOPE
CRCLS4:	REST B
	SUB ITM1A,A	;MAKE IT RELATIVE AGAIN
	JSR PC,ITM1PO	;POP THE SPHERE
	CLZ!CLC		;CLEAR EVERYTHING
	RTS PC
CRCLS6:	REST B
CRCLS5:	JSR PC,ITM1PO	;POP THE SHPERE
	CLZ
	SEC
	RTS PC
CRCLS3:	REST B
	SEZ 
	RTS PC
;THIS ROUTINE TAKES A POINTER TO THE FIRST CAPABILITY OF A CIRCULAR
;LIST IN A AND THE C-LIST NO. OF THAT CAP IN B, AND RETURNS THE
;ITEM NO. (IN C) AND THE C-LIST NO. (IN D) OF THE C-LIST ENTRY THAT
;POINTS TO IT. THE C-LIST NO. OF THE ORIG. ENTRY IS IN B,AND THE ORIG.
;ITEM NO. IN A. RETURNS WITH Z SET IF NO CIRCULAR LIST
FNBKPT:	TST 4(A)	;IS THERE A CIRCULAR LIST
	BNE FNBPT1	;YES
	MOV ITEM1,C	;FAKE THE CIRCULAR LIST
	MOV B,D		;COPY IT
	RTS PC
FNBPT1:	MOV ITEM1,A	;THE CURRENT ITEM NO.
	SAVE <A,B>	;FOR REFERENCE LATER
FNBPT2:	SAVE <A,B>	;SAVE CURRENT ITEM AND C-LIST
	JSR PC,ITM1PL	;LOAD UP THIS SPHERE
	JSR PC,GCLSTA	;GET ADDRESS OF C-LIST ENTRY
	BUGC NE		;DID WE SUCCEED
	ADD A,B		;MAKE THE POINTER ABSOLUTE
	MOV 4(B),A	;THE NEXT C-LIST NO.
	MOV 10(B),B	;THE NEXT C-LIST ITEM
	BUGC NE		;THE ITEM SHOULDN'T BE 0
	JSR PC,ITM1PO	;GET RID OF THIS ITEM
	REST <D,C>	;GET THE OLD VALUES
	CMP A,2(P)	;IS THE POINTER THE SAME AS THE ORIG.
	BNE FNBPT2	;NOPE FIND THE NEXT ONE
	CMP B,(P)	;IS THE REST OF THE POINTER THE SAME
	BNE FNBPT2	;NOPE TRY AGAIN
	ADD #4,P	;POP OFF THE ORIG. ITEM AND C-LIST NO.
	CLZ
	RTS PC

;STOP SPHERE WITH INDEX IN C
SPRSTP:	SAVE A
	MOV #-1,A	;FOR THE BOGUS PUSH
	JSR PC,ITM0PL	;CREATE A WORK CELL
	MOV C,A		;THE SPHERE NO.
	JSR PC,ITM1PL	;LOAD THE SPHERE
	MOV SPHPRP(A),A	;GET POINTER TO THE FIRST PROCESS
	JSR PC,ITM1PO	;POP THE SPHERE
	BR SPSTP2	;CHECK OUT THE FIRST PROCESS
SPSTP1:	JSR PC,PSTPIN	;STOP THE PROCESS
SPSTP3:	JSR PC,ITM0LD	;LOAD THE PROCESS JUST STOPPED
	MOV PSPHCP(A),A	;GET THE NEXT PROCESS
SPSTP2:	CMP A,PRUNNG	;DONT STOP THE CURRENT PROCESS
	BEQ SPSTP3	;THIS IS IT
	TST A		;ARE THERE ANY PROCESSES
	BNE SPSTP1	;YES
	JSR PC,ITM0PO	;POP THE WORK CELL
	REST A
	RTS PC

;PCLOSER ROUTINE FOR DECREMENTING SPHERE STOP COUNTS
PCSPST:	SAVE E
	MOV LCKWD2(B),E	;THE ONE NOT TO START
	MOV ITEM2,A	;THE SPHERE IS LOADED INTO ITEM2
	BR SPRST5
;DECREMENT THE STOP COUNTS OF EVERYTHING ATTACHED TO THIS SPHERE
;INDEX IN A
SPRSTR:	SAVE E
	CLR E		;STOP ALL THE PROCESSES
SPRST5:	SAVE B
	JSR PC,ITM1PL	;LOAD THE SPHERE
	MOV SPHPRP(A),B	;GET THE POINTER TO THE FIRST PROCESS
	JSR PC,ITM1PO	;POP THE SPHERE
	MOV #-1,A
	JSR PC,ITM0PL	;MAKE A BOGUS PUSH
	BR SPSTR4	;CHECK THE FIRST ONE
SPSTR1:	JSR PC,PSTPDC	;DECREMENT THE PROCESSES STOP COUNT
SPSTR3:	BIC #PSPHSB,PSTOP(A)	;CLEAR THE STOP BIT
	MOV PSPHCP(A),B	;GET THE NEXT PROCESS
SPSTR4:	TST B		;ARE THERE ANY MORE PROCESSES
	BEQ SPSTR2	;NO WE ARE DONE
	MOV B,A		;THE NEXT PROCESS
	JSR PC,ITM0LD
	CMP B,E		;IS THIS THE ONE NOT TO DECREMENT
	BEQ SPSTR3	;YES IGNORE IT
	BR SPSTR1	;GO STOP THIS ONE
SPSTR2:	JSR PC,ITM0PO	;POP THE PROCESS
	REST <B,E>
	RTS PC
;THIS ROUTINE IS THE PC-LOSER ROUTINE FOR RESTARTING PROCESSES IN A SPHERE AND
;ALL INFERIOR SPHERES
PCMSST:	MOV ITEM2,A	;GET THE SPHERE NO.
	JSR PC,ITM1PL	;LOAD UP THE SPHERE
	SAVE E		;KEEP E FROM BEING CLOBBERED
	CLR E		;SAY WE SHOULD START THE PROCESSES
	JSR PC,STPMS	;START THEM
	REST E		;RESTORE E
	JSR PC,ITM1PO	;POP THE SPHERE
	RTS PC		;RETURN

;THIS ROUTINE EXPECTS THAT MS TO BE STOPPED OR STARTED TO BE LOADED IN ITEM1
;IF E IS < 0 THE SPHERE (AND INFERIORS ARE STOPPED, ELSE STARTED)
STPMS:	JSR F,ACSAV	;SAVE THE AC'S
	SAVE <#-1>	;FLAG THE TOP OF THE STACK
STPMS8:	MOV ITEM1,A	;WHATEVER IS IN ITEM1 IS WHAT WE WANT TO STOP
	TST E		;OR START
	BLT STPMS1	;STOPPING
	JSR PC,SPRSTR	;STARTING
	BR STPMS2
STPMS1:	MOV A,C		;REQUIRES SPHERE IN DIFFERENT REGISTER
	JSR PC,SPRSTP	;STOP IT
STPMS2:	CLR D		;D IS THE CURRENT C-LIST ENTRY NUMBER
STPMS3:	MOV ITM1A,A	;POINT TO THE CURRENT SPHERE
STPMS9:	JSR PC,GNMSCP	;GET NEXT MS CAP
	BEQ STPMS4	;NO ONE HOME
	SAVE <D>	;SAVE THE CONTINUATION POINT
	MOV 2(B),A	;GET THE INDEX OF THE SPHERE POINTED TO
	JSR PC,ITM1LD	;LOAD IT UP
	BR STPMS8	;GO STOP/START IT AND LOOK AT ITS C-LIST
STPMS4:	REST D		;TRY TO POP TO SUPERIOR SPHERE
	BLT STPMS6	;GOT THE FLAG
	MOV SMSSPT(A),A	;GET THE SUPERIOR
	JSR PC,ITM1LD	;AND MAKE IT CURRENT
	INC D		;NEXT C-LIST ENTRY
	BR STPMS9	;CONTINUE THROUGH ITS C-LIST
STPMS6:	JSR F,ACRES
	RTS PC		;DONE
;GET NEXT MSCAP
;A POINTS TO THE SPHERE IN THE MAP
;D POINTS TO THE FIRST C-LIST ENTRY TO CHECK
;B GETS THE POINTER TO THE ENTRY
;D GETS THJeNUMBER OF THE ENTRY
;SET Z ON FAILURE
GNMSC2:	INC D		;LOOP TO NEXT ENTRY
GNMSCP:	JSR PC,GNCLST	;GET THE NEXT C-LIST ENTRY
	BEQ GNMSC1	;NONE
	CMPB #.MSCAP,(B)	;IS IT A MSCAP?
	BNE GNMSC2	;NO, TRY NEXT ONE
	CLZ		;Z HAD BEEN SET, BUT WE WON SO CLEAR IT
GNMSC1:	RTS PC		;RETRUN WITH Z SET OR CLEARED

;TAKES POINTER TO UPT IN B PCLOSERS EVERYONE NEAR THAT PAGE
PAGPCL:	CMP #-1,B		;IS IT REALLY NULL?
	BEQ PAGL3
	SAVE <A,B>
	MOV #-1,A		;BOGUS PUSH
	JSR PC,ITM2PL		;LOAD UP NOTHING
PAGPLP:	JSR PC,UPTLD		;LOAD A UPT
	MOV ITEM2,A		;THE SPHERE TO PC-LOSER
	BMI PAGL1		;FUPT
	JSR PC,SPRPCL		;PC-LOSER THAT SPHERE
PAGL2:	MOV UPTCLP(B),B		;GET NEXT UPT
	BEQ PAGDON		;NO MORE
	CMP B,(P)		;IS IT THE SAME AS THE FIRST
	BNE PAGPLP		;NO, PC-LOSER IT
PAGDON:	REST <B,A>
	JSR PC,ITM2PO		;POP THE SPHERE
PAGL3:	RTS PC
PAGL1:	MOV UPTPRP(B),A		;THE PROCESS THIS BELONGS TO
	BLE PAGL2		;NO ONE TRY NEXT UPT
	JSR PC,PRSPCL		;PCLOSER PROCESS
	BR PAGL2		;TRY NEXT UPT

;PCLOSER SPHERE ITEM IN A
SPRPCL:	SAVE A
	MOV #-1,A
	JSR PC,ITM0PL		;FOR A BOGUS PUSH
	MOV (P),A		;GET BACK POINTER TO SPHERE
	JSR PC,ITM1PL		;LOAD IT UP
	MOV SPHPRP(A),A		;POINTER TO THE CURRENT PROCESS
	JSR PC,ITM1PO		;POP SPHERE
	TST A			;ARE THERE ANY PROCESSES
	BEQ SPRPC2
SPRPC1:	JSR PC,PRSPCL		;PCLOSER PROCESS
	JSR PC,ITM0LD		;LOAD THE CURRENT PROCESS
	MOV PSPHCP(A),A		;POINTER TO NEXT PROCESS
	BNE SPRPC1		;THERE IS ANOTHER
SPRPC2:	JSR PC,ITM0PO		;POP THE BOGUS PUSH
	REST A
	RTS PC

;PCLOSER PROCESS ITEM IN A
PRSPCL:	CMP A,PRUNNG		;IS THIS THE CURRENT PROCESS
	BEQ PRSPC2		;YES, DONT PCLOSER YOURSELF
	JSR F,ACSAV
	JSR PC,ITM0PL		;LOAD THE PROCESS
	TST PSTOPC(A)		;IS IT STOPPED ALREADY
	BNE PRSPC1		;YES
	TST PSPC(A)		;IS IT IN SYSTEM
	BEQ PRSPC1		;NO
	BIS #PPCLSR,PFLAGS(A)	;SET BIT TO PCLOSER HIM
	JSR PC,PRSUNL		;UNLOCK HIS SWITCHES
PRSPC1:	JSR PC,ITM0PO		;POP PROCESS
	JSR F,ACRES
PRSPC2:	RTS PC
	.SBTTL SPHERE HACKING ROUTINES => UPT HANDLERS

;MAKES A GENERALIZED ITEM POINTER, B CONTAINS UPT NO, C CONTAINS SPHERE NO.
;THEN DELETES UPT, BY FALLING INTO UPTDEL
SUPTDL:	ASH #10.,B		;SET THE UPT NO. IN THE CORRECT BITS
	BIS C,B			;SET IN THE ITEM NO.
	BIS #GIPBIT!GIPSPR,B	;SAY IT IS A GIP AND IN A SPHERE
UPTDL:	JSR PC,UPTDEL		;DELETE THE UPT
	BEQ SUPTD1		;JUST ROUTINE
	TST FPTREF(B)		;BETTER POINT TO THE FPT
	BNE SUPTD1		;WATCH OUT PFPTS HANGIN AROUND
	SAVE E
	MOV B,E			;POINT TO THE FPT
	JSR PC,FPTDEL
	REST E
SUPTD1:	RTS PC

;DELETE A UPT, B POINTS TO UPT TO DELETE
;CLOBBERS NO OTHER REGISTERS.  B IS NON ZERO IF DELETED LAST FPT UPT
;AND CONTAINS ADDRESS OF FPT, ELSE ZERO
UPTDEL:	CLR -(P)		;SET A FLAG
	JSR F,ACSAV		;SAVE THE ACS
	JSR PC,UPTPLD		;LOAD UP THE UPT
	CMP ITEM2,CURSPH	;IS IT THE CURRENT SPHERE
	BNE .+6			;NO
	JSR PC,SAVAWB		;MAKE SURE WE GET ALL THE RIGHT BITS
	MOV B,D			;COPY POINTER
	MOV (B),F		;THE DR
	BIC #360,F		;CLEAR THE ACESS INFO BITS
	TST F			;IS THERE ANYTHING HERE
	BNE UPTDL1		;YES
	CMP ITEM2,#-1		;IS IT AN FUPT
	LBR EQ,UPTCLR		;YES, LINK IT ONTO THE FREE LIST
	CMP B,#<ITM2AD+SUPTS+<10*UPTLEN>>
				;THAT FOO CHECKS TO SEE IF IT IS A DATA PAGE
	BLO .+10		;IT ISNT
	BIC #UPTDEI,-<10*UPTLEN>(B)	;MAKE SURE WE CLEAR THE D=I BIT
UPTRT:	JSR PC,ITM2PO		;POP THE ITEM PUSHED BY UPTPLD
	JSR F,ACRES		;RESTORE THE AC
	TST (P)+		;IS IT A FPT RETURN
	BNE .+4			;NO
	CLR B
	RTS PC
UPTDL1:	BIT #UPTABT,UPTAR(B)	;IS IT AN ABSOLUTE PAGE
	LBR NE,UPTCLR		;YES, JUST CLEAR IT OUT
	BIT #UPTDEI,(B)		;IS IT D=I
	BEQ UPTDL2		;NO
	MOV B,A			;GET POINTER TO THE CURRENT PAGE
	CMP B,#<ITM2AD+SUPTS+<10*UPTLEN>>	;DATA PAGE?
	BHIS UPTD10		;YES
	MOV 2(P),B		;THE GIP
	JSR PC,UNLNK		;UNLINK THE UPT
	TST C			;ANY MORE LIST?
	BEQ UPTD11		;NO, JUST FAKE IT
	MOV C,B			;LOAD IT UP
	JSR PC,UPTLD		;LOAD THIS UPT
	MOV 2(P),A		;POINTER TO THE CURRENT PAGE
	ADD #10_10.,A		;MAKE IT POINT TO THE DATA ONE
	MOV UPTCLP(B),C		;WHAT TO MAKE THE DATA PAGE POINT TO
	MOV A,UPTCLP(B)		;SET IN CIRCULAR LIST POINTER
	BR UPTD12		;SET UP THE OLD UPT
UPTD11:	MOV 2(P),B		;GET THE POINTER
	JSR PC,UPTLD		;LOAD IT UP
	MOV UPTCLP(B),C		;OLD POINTER TO I PAGE
	ADD #10_10.,C		;MAKE IT POINT TO THE D SPACE PAGE
UPTD12:	MOV 2(P),B
	JSR PC,UPTLD		;LOAD OLD ONE
	MOV C,UPTCLP(B)		;SET IN THE NEW POINTER
	BIC #-1-360,UPTLEN*10(B)	;CLEAR ALL BUT THE AW BITS
	BIS (B)+,<UPTLEN*10>-2(B)	;SET IN THE ADDRESS, AND OTHER FOO
	BIC #UPTDEI,UPTLEN*10(D)	;CLEAR THE D=I BIT
	MOV #<UPTLEN-2>/2,C	;NUMBER TO COPY
	MOV (B)+,<UPTLEN*10>-2(B)	;COPY THEM
	SOB C,.-4		;COPY ALL THEM
	BR UPTCLR		;CLEAR IT OUT
UPTD10:	BIC #-1-360,(B)		;CLEAR ALL BUT THE A,W,M,N BITS
	BIS (B),-UPTLEN*10(B)	;SET IN THE A,W,N,M BITS
	BIC #UPTDEI,-UPTLEN*10(B)	;CLEAR THE DATA=I BIT
	BR UPTCLR		;CLEAR IT OUT
UPTDL2:	MOV UPTAR(B),C		;THE AR
	BIC #UPASMS,C		;CLEAR ALL BUT THE ADDRESS
	ASH #-3,C		;GET IT INTO A WORD OFFSET
	BEQ UPTDL3		;NO CORE
	MOV CST(C),C		;GET THE CST ENTRY FOR THIS PAGE
	BIC #CSTCOM,C		;GET THE CPT OFFSET
	ADD #CPT,C		;MAKE C POINT TO IT DIRECTLY
	BIT #CPTMOV,CPTADR(C)	;IS IT MOVING
	BEQ UPTDL3		;NO
	JSR PC,ITM2PO		;POP THE UPT
UPTDL6:	JSR PC,LFLUSH		;GET RID OF OURSELVES FOR A LONG TIME
	BIT #CPTMOV,CPTADR(C)	;STILL MOVING
	BNE UPTDL6		;YES
	JSR PC,RUNME		;LETS CHECK IT AGAIN
	MOV 2(P),B		;RELOAD THE UPT
	JSR PC,UPTPLD
	BR UPTDL2		;TRY AGAIN
UPTDL3:	MOV UPTFPT(D),C		;IS IT AN FPT POINTER
	BMI UPFPTD		;YES
	MOV UPTCLP(D),A		;IS THIS THE LAST UPT IN THIS LIST
	CMP A,2(P)
	BEQ UPTDL4		;YES
	TST A
	BNE UPTDL5		;NO
	;DROPS INTO THE NEXT PAGE
	;DROPS IN FROM PREVIOUS PAGE
UPTDL4:	MOV C,B			;GET THE SWAP ADDRESS
	JSR PC,DSWPAL		;DEALLOCATE THE SPACE
	MOV 2(P),B		;THE GIP
	JSR PC,CORFRE		;FREE THE CORE IF IT EXISTS
	BR UPTCLR		;CLEAR OUT THE UPT
UPTDL5:	MOV 2(P),B		;THE GIP
	JSR PC,UNLINK		;UNLINK IT
UPTDL9:	MOV UPTAR(D),A		;THE AR
	BIC #UPASMS,A		;THE ADDRESS
	BEQ UPTCLR		;NO CORE
	ASH #-3,A		;GET IT INTO WORD OFFSET
	MOV CST(A),B		;GET CST ENTRY FOR THIS PAGE
	BIC #CSTCOM,B		;GET CPT OFFSET
	MOV C,CPT+CPTUPP(B)	;UPDATE CPT'S UPT POINTER
	BEQ UPTCLR		;NO MORE UPT'S
	MOV C,B			;GET THE OLD LIST
	MOV (D),C		;GET THE DR
	BIC #-1-360,C		;CLEAR ALL BUT THE ACCESS BITS
	JSR PC,UPTPLD		;LOAD IT UP
	BIS C,(B)		;SET IN THE ACCESS BITS FOR OLD UPT
	JSR PC,ITM2PO		;POP THE CRUFT
UPTCLR:	MOV #UPTLEN/2,B		;THE LENGTH OF UPT IN WORDS
	CLR (D)+		;CLEAR OUT ALL THE WORDS
	SOB B,.-2
	CMP #-1,ITEM2		;IS IT A FUPT
	BNE UPTCL1		;NO,RETURN
	SUB #UPTLEN,D		;BACK UP
	MOV FUPTFR,(D)		;LINK IT ONTO FREE LIST
	MOV D,FUPTFR
UPTCL1:	LBR ,UPTRT		;DONE
UPFPTD:	MOV UPTCLP(D),F		;POINTER TO THE NEXT UPT
	BEQ UPTDL7		;THERE ARE NONE
	CMP F,2(P)		;DOES IT POINT TO ITSELF
	BEQ UPTDL7		;YES
	MOV UPTDR(D),A		;THE DR
	MOV A,B			;COPY IT
	BIC #UPMSRE,A		;GET START IF THE REFERNCED AREA
	MOV UPTAR(D),E		;GET THE AR
	MOV E,F			;COPY IT
	BIC #UPMSSW,E		;GET THE GLOBAL START
	CMP E,A			;DOES THIS PAGE START AFTER THE GLOBAL START
	BLE UPTDL7		;NO, SWAP IT OUT FIRST
	BIC #UPMLSW,F		;GET THE GLOBAL LENGTH
	ASH #-12.,F		;GET IT INTO THE LOW BITS
	ADD F,E			;MAKE E THE GLOBAL END
	BIC #UPMLRE,B		;GET THE REFERENCED LENGTH
	ASH #-12.,B		;GET IT INTO THE LOW BITS
	ADD B,A			;GET THE REFERENCED END
	CMP A,B			;IS THE GLOBAL END AFTER THE REFERENCED END
	BLT UPTDL8		;YES, JUST UNLINK IT
UPTDL7:	MOV 2(P),B		;THE GIP
	JSR PC,ITM2PO		;POP THE ITEM
	JSR PC,SWPIN		;SWAP IT IN
	MOV C,A			;THE FPT POINTER
	ASL A			;MAKE IT ABSOLUTE
	BIS #FPTTSR,FPTFLG(A)	;SET THE TEMPORARY WRITE TO SOURCE
	JSR PC,SWPOT		;SWAP IT TO SOURCE
	JSR PC,UPTPLD		;LOAD IT AGAIN
	;DROPS INTO NEXT PAGE
	;DROPS IN FROM PREVIOUS PAGE
UPTDL8:	CMP #-1,ITEM2		;IS IT AN FUPT
	BEQ FPTFL		;YES, DONT DECREMENT THE MFI REFERENCE COUNT
	MOV UPTFPT(D),A		;POINTER TO FPT
	JSR PC,ITM2PO		;POP UPT
	ASL A			;MAKE FPT POINTER ABSOLUTE
	MOV A,E			;COPY POINTER TO FPT
	MOV FPTMFI(A),A		;POINTER TO MFI
	JSR PC,MFIDLP		;DECREMENT REFERENCE COUNT OF MFI, AND DELETE IF ZERO
	BCS UPDL11		;DELETED THE MFI
	MOV 2(P),B		;THE GIP
	JSR PC,UPTPLD		;LOAD IT UP
	MOV B,D			;COPY THE POINTER
FPTFL:	MOV D,12.(P)		;SET FLAG FOR FPT
	MOV 2(P),B		;GIP TO UPT
	JSR PC,UNLINK		;UNLINK IT
	MOV UPTFPT(D),E		;GET POINTER TO FPT
	ASL E			;MAKE IT ABSOLUTE
	MOV C,FPTUPT(E)		;FIX UP FPT
	BEQ FPTFL1		;MORE UPTS
	CLR E			;SAY THAT THERE ARE MORE UPT'S
	CLR 12.(P)
FPTFL1:	MOV E,2(P)		;RETURN POINTER TO FPT
	BR UPTDL9
UPDL11:	MOV FPTSWA(E),B		;THE SWAP ADDRESS
	BEQ .+6			;NO SWAP SPACE ALLOCATED
	JSR PC,DSWPAL		;DEALLOCATE THE SWAP SPACE
	MOV FPTFRE,FPTLNK(E)	;LINK IT ONTO THE FREE LIST
	MOV E,FPTFRE
	MOV 2(P),B		;THE UPT
	JSR PC,UPTPLD		;LOAD IT UP
	MOV B,D			;FOR UPTCLR
	BR UPTCLR		;DONE
;THIS IS A ROUTINE THAT WILL LINK A UPT OUT OF
;THE CIRCULAR LIST OF UPT'S, AND IF THERE IS ONLY ONE
;LEFT IT WILL UNCIRCULARIZE THE LIST.  IF THERE IS NO
;CIRCULAR LIST, IT RETURNS SETTING Z. ELSE CLEARS Z.
;IT TAKES A GENERALIZED ITEM POINTER IN B TO THE UPT.
;IT RETURNS IN C WHAT THE UPT IT UNLINKED USED TO POINT TO
;UNLNK DOESN'T RECACULATE THE SWAP FIELDS
UNLNK:	SAVE #1			;FLAG
	BR .+4
UNLINK:	CLR -(P)		;A FLAG
	MOV B,F			;SAVE THE POINTER
	BIT #GIPBIT,B		;IS IT A GIP
	BUGC NE			;YES
	JSR PC,UPTPLD		;LOAD THE UPT INTO ITEM2
	MOV UPTCLP(B),B		;GET THE NEXT POINTER
	CMP B,F			;IS THERE CIRCULAR LIST
	BEQ UNLNK3		;NO
	MOV B,C			;SAVE THIS FOR LATER
	BNE UNLNK1		;THERE IS A CIRCULAR LIST
UNLNK3:	TST (P)+
	JSR PC,ITM2PO		;POP ITEM2 PUSHED BY UPTPLD
	CLR C			;CLEAR THE FORWARD POINTER
	RTS PC
UNLNK1:	JSR PC,UPTLD		;LOAD THE NEXT UPT
	CMP UPTCLP(B),F		;DOES THIS POINT TO THE FIRST UPT
	BEQ UNLNK2		;YES
	MOV UPTCLP(B),B		;GET THE NEXT POINTER
	BNE UNLNK1		;THERE IS A NEXT POINTER
	BPT
UNLNK2:	MOV C,UPTCLP(B)		;UPDATE THE UPT CIRCULAR POINTER
	TST (P)+		;SHOULD WE UPDATE THE MASTER FIELDS
	BNE .+6			;NO
	JSR PC,SWPCAL		;DO THE DEED
	JSR PC,ITM2PO		;POP THE ITEM STACK PUSHED BY UPTPLD
	RTS PC

;THIS ROUTINE TAKES GIP TO UPT IN C AND UPDATES ITS CIRCULAR LIST
SWPCAL:	MOV C,B			;POINTER TO GIP TO START WITH
	SAVE <A,C,E>		;PLACES TO PUT THE START AND LENGTH
	MOV #7_8.,E		;THE MAXIMUM START
	CLR F			;THE MINIMUM END
SWPCL1:	JSR PC,UPTLD		;LOAD THE UPT
	MOV (B),C		;THIS ENTRIES LENGTH AND START FIELDS
	MOV C,A			;COPY IT
	BIC #UPMSRE,A		;GET THE START
	BIC #UPMLRE,C		;CLEAR THE LENGTH
	ASH #-4,C		;INTO THE CORRECT BITS
	ADD A,C			;GET THE END OF THIS UPT
	CMP A,E			;IS NEW START < OLD START
	BGE .+4			;NO
	MOV A,E			;SET IN THE NEW START
	CMP C,F			;IS THE NEW END > OLD END
	BLE .+4			;NO
	MOV C,F			;SET IN NEW END
	MOV UPTCLP(B),B		;NEXT UPT
	CMP B,2(P)		;SAME AS FIRST
	BNE SWPCL1		;NO
	SUB E,F			;GET THE NEW LENGTH
	ASH #4,F		;INTO THE CORRECT BITS
	SWAB E			;SINCE IT IS IN BOTTOM BYTE IN AR
	BIS F,E			;SET IN THE AR BITS
	MOV #-UPMLSW-1-UPMSSW-1,A	;BITS TO CLEAR
SWPCL2:	JSR PC,UPTLD		;LOAD UP THE UPT
	BIC A,UPTAR(B)		;CLEAR THE CORRECT FIELDS
	BIS E,UPTAR(B)		;SET IN THE NEW BITS
	MOV UPTCLP(B),B		;GET THE NEXT UPT
	CMP B,2(P)		;SAME AS FIRST
	BNE SWPCL2		;NOPE
	REST <E,C,A>
	RTS PC


;PUSH ITEM2 AND THEN FALL INTO LOAD A UPT
;GIP IS IN B
;RETURN CORE ADDRESS IN B

UPTPLD:	SAVE <A>
	MOV #-1,A		;MAKE IT NXM
	JSR PC,ITM2PL
	REST <A>
UPTLD:	TST B
	BUGC NE
	BIT #GIPSPR,B		;THIS BIT SET IN SPHERE UPT
	BNE UPTL.1
	ADD #<100000+FUPTTB>,B	;FUPT CORE ADDRESS
	RTS PC
UPTL.1:	SAVE <A>
	MOV B,A
	BIC #GIPITM,A		;GET THE ITEM NUMBER
	JSR PC,ITM2LD		;LOAD THE SPHERE OVER THIS ITEM
	BIC #GIPUPT,B		;GET THE UPT NUMBER
	SWAB B
	ASH #-2,B		;GET THE UPT NO.
	MUL #UPTLEN,B
	ADD A,B
	ADD #SUPTS,B
	REST <A>
	RTS PC
	.SBTTL CLOCK AND PIRQ ROUTINES
;ENTERED BY AN INTERUPT FROM EITHER THE LINE CLOCK OR THE PROGRAMABLE
;CLOCK. HOPEFULLY, ONLY ONE OF THESE WILL BE ENABLED!
LCBRK:
PCBRK:	JSR F,ACSAV	;SAVE THE ACS
	JSR PC,SWCHEK
	INC TIME	;INCREASE TIME-SINCE-SYSTEM UP
	BNE .+6		;OVERFLOW?
	INC TIME+2	;YUP
.IIF NZ NTKDIS,JSR PC,TKDCLK	;KEEP DISPLAYS GOING
.IIF NZ NTVS,JSR PC,TVTICK	;PROCESS TV CHARS
	BIT #1,TIME	;DO THIS ONLY EVERY OTHER TICK
	BNE .+6
	JSR PC,CLKTTY	;PROCESS CHARACTERS
	INC TUSED	;ONE MORE TICK FOR THIS USER
	DEC STIMER	;MAINTAIN TIMERS
	DEC LTIMER
	DEC TIMTSS
	DEC CORTIM	;DECREMENT COUNTER TO CORE JTMU'S
	DEC JTMUUP	;TIME TO UPDATE THE JTMUS?
	BNE .+6		;NOT YET
	JSR PC,JTMUU	;GO UPDATE THEM
	DEC QUANT	;HAS THE CURRENT USER OVERSTAYED HIS WELCOME?
	BGT CLKRET	;NO, RETURN TO MAIN PROGRAM
	BIS #CLKPIR,PIRQ	;CAUSE THE STOP USER ROUTINE TO RUN
CLKRET:	JSR F,ACRES	;RESTORE THE ACS
	RTT

SWCHEK:	MOV CSWR,SVCSR	;IS SWITCH REGISTER ZERO?
	BNE .+6
	MOV PC,LOOKSW	;YES, SAY WE SHOULD LOOK AT SWITCHES
	TST LOOKSW	;SHOULD WE LOOK AT SWITCHES?
	BEQ SWCHE1	;NOPE
	BIT #100000,CSWR	;BPT SWITCH?
	BEQ .+4
	BPT
	BIT #1,CSWR	;INGNORE SWITCHES SWITCH
	BEQ .+6
	CLR LOOKSW
SWCHE1:	RTS PC
.IFNZ NTKDIS
TKDCLK:	MOV TKDPDL,A	;THE PDL ITEM
	JSR PC,ITM2PL	;LOAD IT UP
	MOV A,F		;SAVE POINTER INTO IT
	ADD #20,F	;MAKE IT POINT TO PDLS
	CLR A		;THE DISPLAY NUMBER
	CLR D		;THE DISPLAY*2
	MOV #8.,C	;THERE ARE 8 DISPLAYS
TKDCL1:	MOV TKDRUN(A),B	;IF RUNNING, WHICH DISPLAY I AM
	BLT TKDCL2	;NOT RUNNING
	MOV B,D
	SWAB B
	MOV B,NGCSR	;CHECK THAT DISPLAY
	BIT #TKRUN,NGCSR	;STILL RUNNING?
	BNE TKDCL2	;YUP
	ASL D
	BIC #17,F
	ADD D,F
	MOV TKDPDP(D),(F)	;RESTORE THE PDL POINTER
	BIS #TKGO,B	;BIS DOESN'T WORK ON NGCSR
	MOV B,NGCSR	;RESTART DISPLAY
TKDCL2:	TST (A)+
	SOB C,TKDCL1	;DO THEM ALL
	JSR PC,ITM2PO
	RTS PC
.ENDC

;THIS IS ENTERED BY THE PROGRAM INTERUPT REQUEST
;CURRENTLY IT IS ONLY USED FOR THE "CLOCK", BUT ITS DISPATCH
;TABLE COULD ACCOMADATE USES FOR OTHER LEVELS
PIRBRK:	SAVE A		;SAVE A REGISTER
	MOV PIRQ,A	;GET THE INTERUPT LEVEL
	BIC #177761,A	;USE AS AN INDEX TO DISPATCH
	BIC PIRBIT(A),PIRQ	;CLEAR THE RIGHT BIT
	ASH #4,A	;GET PRIORITY INTO RIGHT BITS
	MOVB A,PS	;SET PRIORITY OF PROCESSOR TO PRIORITY
			;LEVEL RESPONSABLE FOR THIS INTERUPT
	ASH #-4,A	;GET BACK FOR DISPATCHING
	JMP @PIRDIS(A)
PIRLOS:	BPT	;UNIMPLEMENTED LEVELS COME HERE
	BR .-2

	.SBTTL SCHEDULING ROUTINES
;THE SYSTEM'S MAIN LOOP
;ENTERED AT SCHED, NEVER EXITED
SCHED:	JSR PC,RUNBPS	;FOR NOW, JUST RUN THE BEST USER
	JSR PC,CJTMUD	;CHECK THE CORE JTMU'S
	JSR PC,CHKACT	;SEE IF WE SHOULD ACTIVATE ANYONE
	TST RUNQ	;IS ANYONE RUNNABLE?
	BEQ SCHED1	;NO, GO TRY EVERYONE
	TST STIMER	;IS IT TIME TO CHECK SHORT-FLUSHED GUYS?
	BGT SCHED2	;NOT YET
	MOV #STIMEL,STIMER	;RESET THE TIMER
	MOV #SFLSQ,A
	JSR PC,CHKQ	;GO CHECK THEM ALL
	MOV #PAGWQ,A	;CHECK GUYS WAITING FOR PAGES TOO
	JSR PC,CHKQ
SCHED2:	TST LTIMER	;TIME TO CHECK THE LONG FLUSHED GUYS?
	BGT SCHED3	;NOPE, NOT YET
	MOV #LTIMEL,LTIMER
	MOV #LFLSQ,A
	JSR PC,CHKQ
	JSR PC,SWAPTR	;TRY TO SCHEDULE A SWAP
SCHED3:	BR SCHED	;NOW GO RUN THE BEST ONE
SCHED1:	MOV #SFLSQ,A	;CHECK THE SHORT ONES
	JSR PC,CHKQ
	MOV #PAGWQ,A	;AND THE LONG ONES
	JSR PC,CHKQ
	TST RUNQ	;DID WE CATCH ANY?
	BNE SCHED	;YUP, TRY ONE
	MOV #LFLSQ,A	;OH WELL, TRY THE LONG ONES
	JSR PC,CHKQ
	JSR PC,SWAPTR	;TRY TO SWAP SCHEDULE
	BR SCHED

SWAPTR:	DEC TIMTSS	;TIME TO DO SWAP SCHEDULE
	BLT .+4		;YES
	RTS PC
	MOV #200.,TIMTSS
	JMP SWAPSC	;SCHEDULE THEM ALL

;UPDATE JTMUS ON ALL QUEUES.
JTMUU:	MOV #JTMUUT,JTMUUP	;RESTORE TIME TILL NEXT UPDATE
	MOV #FIRSTQ,A	;BEGGINING OF THE QUEUE POINTERS
	MOV #NQS,B	;NUMBER OF QUEUES THAT EXIST
JTMUU1:	MOV (A),C	;POINTER TO BEGGINING OF QUEUE
	BEQ JTMUU2	;NOBODY THERE!
JTMUU4:	MOV PRTJTM(C),F	;GET THE JTMU
	BEQ JTMUU3	;IT'S ALREADY ZERO, FORGET IT
	CLR E		;FOR THE DIVIDE
	DIV #JTMUDC,E	;FIND OUT HOW MUCH TO DECAY BY
	INC E		;MAKE SURE IT EVENTUALLY GETS TO ZERO
	SUB E,PRTJTM(C)	;DECAY IT
JTMUU3:	MOV (C),C	;GO DOWN THE LINK
	BNE JTMUU4	;MORE ON THIS QUEUE
JTMUU2:	ADD #QLEN,A	;GO TO NEXT QUEUE
	SOB B,JTMUU1	;GO THROUGH ALL QUEUES
	RTS PC

CJTMUD:	TST CORTIM	;IS IT TIME TO CHECK THEM
	BLE .+4		;TIME TO UPDATE THEM
CJTMU1:	RTS PC
	MOV #CQUANT,CORTIM	;RESET THE TIMER
	MOV #SPHRQ,A	;POINTER TO SPHERE QUE
CJTMU2:	MOV (A),A	;POINTER TO THE PROCESS BLOCK OF A SPHERE
	BEQ CJTMU1	;DONE
	MOV PRTJTM(A),D	;GET THE CORE JTMU
	CLR C		;FOR THE DIVIDE
	DIV #CDECAY,C	;GET THE REMAING JTMU
	MOV C,PRTJTM(A)	;RETURN NEW JTMU
	BR CJTMU2
;THIS ROUTINE FIGURES OUT WHO ARE THE WINNERS FOR THIS SWAP SCHEDULE, AND
;FIGURES OUT THE MEMORY MAP (JUST ROUGHLY) FOR IT.
SWAPSC:	JSR PC,SPRSRT	;SORT THE SPHERES FOR THIS SCHEDULE
	MOV #PHASHT,A	;POINTER TO HASH TABLE
	MOV #128.,B	;NUMBER OF WORDS
	CLR (A)+	;CLEAR IT OUT
	SOB B,.-2
	JSR PC,SWHASH	;HASH THE SWAP ADDRESSES, UNTIL A FEW K OF CORE LEFT
	MOV #-1,A
	JSR PC,ITM2PL	;LOAD ITEM 2
	MOV #CPT+2+CPTADR,A	;POINTER TO FIRST ENTRY IN CPT
	MOV #NCPTTE/2,B	;NUMBER OF ENTRIES
	MOV #CPTWIN,C	;THE "PAGE BELONGS TO A WINNER" BIT
SWAPS5:	BIC C,(A)	;CLEAR THE BIT
	ADD #CPTLEN,A	;GET THE NEXT ONE
	SOB B,SWAPS5	;CLEAR THEM ALL
	MOV #PHSPRQ,B	;POINTER TO FAKE SPHERE QUEUE
SWAPS1:	MOV (B),B	;GET THE NEXT ENTRY
	BEQ SWAPSD	;DONE
	TST PRTPRI(B)	;IS HE A WINNER
	BMI SWAPS1	;TRY THE NEXT ONE
	MOV PRTPPT(B),A	;THE ITEM OF THE SPHERE
	JSR PC,ITM2LD	;LOAD IT UP
	ADD #SUPTS,A	;POINT TO THE FIRST UPT
	MOV #20,F	;THE NUMBER OF UPTS
SWAPS2:	MOV UPTAR(A),C	;THE AR
	BIT #UPTICR,C	;IS IT IN CORE
	BEQ SWAPS3	;NO, IF WE WANT A PAGE
	BIC #UPASMS,C	;CLEAR ALL BUT THE CORE ADDRESS
	ASH #-3,C	;GET CST OFFSET
	MOV CST(C),C	;GET CST ENTRY
	BIC #CSTCOM,C	;GET ALL BUT CPT OFFSET
	BIS #CPTWIN,CPT+CPTADR(C)	;SET THE WINNER BIT
SWAPS3:	ADD #UPTLEN,A	;POINT TO THE NEXT UPT
	SOB F,SWAPS2	;GET THE NEXT PAGE
	BR SWAPS1	;GET THE NEXT SPHERE
SWAPSD:	MOV PHSPRQ,A	;COPY THE SPHERE QUE
	MOV #SPHRQ,2(A)	;FIX THE POINTER
	MOV A,SPHRQ	;RESTORE THE SPHERE QUE
	JSR PC,ITM2PO	;POP THE ITEM
	MOV #SWPBQ,A	;POINTER TO SWAP BLOCKED QUEUE
	MOV #RUNQ,B	;MOVE THEM TO THE RUN QUEUE
SWAPS4:	TST (A)		;ANYONE SWAP BLOCKED
	BEQ SWAPDN	;NOPE
	MOV (A),A	;GET HIM
	JSR PC,TQUEUE	;MOVE HIM TO RUN QUEUE
	BR SWAPS4	;TRY THE NEXT ONE
SWAPDN:	RTS PC		;RETURN WITH WINNER LIST SET UP

;THIS ROUTINE HASHES SWAP ADDRESSES UNTIL THERE ARE AT LEAST 2 PAGES LARGER
;THAN OR EQUAL TO 2K.
SWHASH:	CLR NWINRS	;SAY NO WINNERS NOW
	MOV #NUMPGS,A	;POINTER TO THE NUMBER OF PAGES
	MOV #NUMPGL,B	;POINTER TO THE NUMBER OF PAGES LEFT
	MOV #10,C	;NUMBER OF SIZES
	MOV (A)+,(B)+
	SOB C,.-2
	MOV #PGHND,F	;POINTER TO NEXT NODE
	MOV #PHSPRQ,B	;GET POINTER TO SPHERE QUEUE IN EXILE
	MOV #-1,A
	JSR PC,ITM1PL	;MAKE A BOGUS PUSH
SWHSH1:	MOV #20,E	;THE NUMBER OF PAGES IN SPHERE
	MOV (B),A	;GET NEXT SPHERE
	BEQ SWHSH3	;RAN OUT OF WINNERS
	CLR PRTPRI(A)	;SAY HE IS WINNER
	SAVE A
	MOV PRTPPT(A),A	;THE ITEM OF THIS SPHERE
	JSR PC,PROSCK	;CHECK TO MAKE SURE THERE ARE RUNNING PROCESSES, AND LOAD SPHERE
	BNE SWHSH6
	REST B		;GET BACK PROCESS LINK
	MOV #-1,PRTPRI(B)	;SAY NO PRIORITY FOR THIS LUSER
	BR SWHSH1	;TRY NEXT GUY
SWHSH6:	MOV ITM1A,A	;THE ADDRESS OF THE SPHERE
	ADD #SUPTS,A	;GET THE FIRST UPT
SWHSH2:	TST (A)		;ANYONE HOME?
	BEQ SWHSH7	;NO
	BPL SWHSH8	;NOT I=D PAGE
	CMP A,#ITM1AD+SUPTS+<UPTLEN*10>	;DATA PAGE?
	BHIS SWHSH7	;YES, IT IS ALWAYS FOR FREE
SWHSH8:	TST 2(A)	;IS IT ABSOLUTE PAGE
	BMI SWHSH7	;YES
	MOV UPTFPT(A),C	;GET THE UPT
	MOV C,D		;COPY IT
	SWAB D		;GET THE TOP BYTE
	XOR C,D		;GET A HASH OF THE 2 BYTES
	BIC #177401,D	;CLEAR ALL BUT THE BOTTOM BYTE
	JSR PC,ALFPAG	;FIND THE PAGE, OR ADD IT
	BEQ SWHSH4	;OUT OF CORE.
SWHSH7:	ADD #UPTLEN,A	;POINT TO THE NEXT UPT
	SOB E,SWHSH2	;GET NEXT PAGE
	REST B		;POINTER TO NEXT SPHERE
	INC NWINRS	;SAY ANOTHER WINNER
	BR SWHSH1	
SWHSH4:	REST A		;GET POINTER TO THE NEXT SPHERE
SWHSH5:	MOV #-1,PRTPRI(A)	;SAY HE IS A LOSER
	MOV (A),A	;GET NEXT ONE
	BEQ SWHSH3	;NO MORE, DONE
	BR SWHSH5
SWHSH3:	JSR PC,ITM1PO	;POP THE ITEM PUSHED
	RTS PC

;THIS ROUTINE LOOKS IN HASH TABLE, AND ADDS IT IF THERE IS NO PREVIOUS ENTRY
;EXPECTS HASH IN D, SWAP ADDRESS IN C, POINTER TO UPT IN A, F POINTS TO FREE
;NODES
ALFPAG:	SAVE <B,E>
	MOV PHASHT(D),E	;GET FIRST HASH LINK
	BEQ ALFNFN	;NOT THERE
ALFPG1:	CMP 2(E),C	;IS IT THE SAME
	BEQ ALFFN	;FOUND IT
	MOV (E),E	;TRY THE NEXT ONE
	BNE ALFPG1
ALFNFN:	TST F
	BMI ALFPG4	;STOP HERE
	MOV UPTAR(A),E	;GET THE AR
	BIC #UPMLSW,E	;GET THE LENGTH
	SWAB E
	ASH #-3,E	;GET THE LENGTH IN RIGHT BITS
	MOV #20,B	;THE NUMBER OF SIZES * 2
	SUB E,B		;GET THE NUMBER OF SIZES TO CHECK
	ASR B		;GET THE NUMBER INTO B
	ADD #NUMPGL,E	;MAKE THE POINTER ABSOLUTE
ALFPG2:	TST (E)+	;IS THERE A PAGE THERE
	BNE ALFPG3	;YES,
	SOB B,ALFPG2	;TRY LARGER ONES	
			;NO ONLY SMALLER ONES,
ALFFN:	REST <E,B>
	CLZ		;STILL PAGES LEFT
	RTS PC
ALFPG3:	DEC -(E)	;DECREMENT THE COUNT
	MOV PHASHT(D),E	;GET THE FORWARD POINTER
	MOV F,PHASHT(D)	;SET IT IN
	MOV E,(F)+	;CREATE A NEW HASH TABLE ENTRY
	MOV C,(F)+	;SET IN THE SWAP ADDRESS
	MOV #5,C	;SET UP A COUNT
	SAVE D		;IN CASE WE HAVE TO UNHASH IT
	MOV #NUMPGL+6,D	;POINTER TO THE 2K SIZE PAGE
	CLR E		;COUNT
	ADD (D)+,E	;GET NUMBER OF BLOCKS LARGER THAN 2K
	SOB C,.-2	;GET THEM ALL
	REST D
	CMP E,#2	;ARE THERE MORE THAN 2
	BGT ALFFN	;YES,
	MOV (P),D	;GET BACK HAST POINTER
	SUB #4,F	;POINT TO THE PREVIOUS ALLOCATE NODE
	MOV (F),PHASHT(D)	;FIX THE HASH LINK
	NEG F		;SET FLAG
ALFPG4:	REST <E,B>
	SEZ
	RTS PC		;SAY, WE SHOULD STOP HERE


;THIS ROUTINE CHECKS TO SEE IF THERE IS A RUNNING PROCESS IN THE SPHERE POINTED TO BY
;A.  THIS ROUTINE ALSO LOADS THAT SPHERE.
PROSCK:	CLR -(P)	;A FLAG
	SAVE B
	JSR PC,ITM1LD	;LOAD THE SPHERE
	MOV A,B
	MOV #-1,A	;FOR BOGUS PUSH
	JSR PC,ITM0PL	;JUST FOR KICKS
	MOV SPHPRP(B),A	;THE FIRST PROCESS
	BEQ PRSCK1	;DONE HE IS A LOSER
PRSLP:	JSR PC,ITM0LD	;LOAD THIS PROCESS
	BIT #RUNQB!SFLSQB!SWPBQB,PQBIT(A)	;IS HE ON RUNQ OR SHORT FLUSH QUE
	BNE PRSCK2	;YES
	MOV PSPHCP(A),A	;NEXT!
	BNE PRSLP	;CHECK HIM OUT (IT ONLY TAKES ONE)
PRSCK1:	JSR PC,ITM0PO	;POP THE ITEM PUSHED
	REST B
	TST (P)+	;USE FLAGS TO SET CONDITION CODES
	RTS PC
PRSCK2:	INC 2(P)	;SET FLAG
	BR PRSCK1	;JUST RETURN NOW

;THIS ROUTINE SORTS SPHERES BY CORE TIME PRODUCTS (KEPT IN JTMU OF SPHERE'S 
;PROCESS TABLE BLOCK)
SPRSRT:	;THIS ALGORYTHM SHOULD BE REPLACED BY SOME GOOD SORT MEATHOD
	MOV SPHRQ,A	;GET THE SPHERE QUE
	MOV A,PHSPRQ	;STORE AWAY THE OLD SPHERE QUE
	CLR SPHRQ	;IN CASE WE GET CLOCK INTERRUPT, DON'T WANT TO BE BOTHERED
	CLR C		;THE POINTER TO THE LAST THING CHECKED
	JSR PC,LSORT	;SORT THE LIST
	MOV #PHSPRQ,A	;GET THE POINTER TO FIRST ENTRY
	MOV #PHSPRQ,B	;POINTER TO PREVIOUS
	MOV #SPHRQ,PRTBCK(A)	;FAKE BACK POINTER
	BR .+4		;B POINTS WHERE WE WANT IT
SPRSR1:	MOV (B),B	;GET POINTER TO NEXT
	MOV (A),A	;GET POINTER TO NEXT
	BEQ SPRSR2	;END OF LIST
	MOV B,PRTBCK(A)	;FIX BACK POINTER
	BR SPRSR1	;GET THE NEXT ONE
SPRSR2:	RTS PC
;THIS ROUTINE SORTS THE LIST, SO THAT THE SMALLEST JTMU'S ARE FIRST
LSORT:	CLR F		;FLAG FOR SOMETHING MOVED
	MOV PHSPRQ,A	;START OF THE LIST
	MOV #PHSPRQ,E	;POINT TO THE FIRST ENTRY
	MOV PRTJTM(A),D	;THE FIRST JTMU
	MOV (A),B	;THE FIRST SPHERE
	CMP B,C		;ARE WE DONE
	BEQ LSORT4	;YES
	BR LSORT5	;BECAUSE E IS ALREADY CORRECT
LSORT1:	MOV (E),E	;UPDATE E
	MOV (B),B	;UPDATE B
	CMP B,C		;ARE WE DONE WITH THIS PASS
	BEQ LSORT2	;YES
LSORT5:	CMP PRTJTM(B),D	;IS THE NEW JTMU LESS THAN THE OTHER
	BHIS LSORT3	;NO
	MOV (B),@(E)	;MAKE THE HIGHER ONE POINT TO THE REST OF THE LIST
	MOV (E),(B)	;MAKE THE LESSER ONE POINT TO THE HIGHER ONE
	MOV B,(E)	;MAKE THE PREVIOUS ONE POINT TO THE LESSER ONE
	MOV (B),B	;TO CATCH UP, SINCE WE EXCHANGED THEM
	INC F		;SAY WE CHANGED SOMETHING
	BR LSORT1
LSORT2:	TST F		;DID WE CHANGE ANYTHING
	BEQ LSORT4	;NO, WE MUST BE DONE
	MOV @(E),C	;WE DONT HAVE TO CHECK THE REST OF THE LIST NEXT TIME
	BR LSORT	;START A NEW PASS
LSORT3:	MOV PRTJTM(B),D	;NEW HIGHED JTMU
	BR LSORT1	;GET THE NEXT ONE
LSORT4:	RTS PC
;CHECK RUNNABILITY OF A PROCESS
;PROCESS TABLE ENTRY IN A
;MIGHT CLOBBER ALL REGISTERS
CHKPRS:	MOV PRTPPT(A),A	;GET THE ITEM
	JSR PC,ITM0LD
CHKPRL:	SAVE PSPC(A)	;GET THE PLACE TO CONTINUE IT AT
	BUGC NE		;MAKE SURE IT IS NON-ZERO
	MOV A,B
	MOV PSPHRP(A),A	;GET THE SPHERE
	JSR PC,ITM1LD
	MOV B,A		;RESTORE ITEM ADDRESS
	MOV PITM2(A),A	;GET HIS ITEM 2
	JSR PC,ITM2LD	;RESORE IT
	MOV B,A
	ADD #PSREGS+14,A	;POINTER TO REGISTERS
.IRPC X,<FEDCBA>
	MOV -(A),X
.ENDM
	RTS PC

;CHECK RUNNABLITY OF PROCESSES ON QUEUE IN A
;MAY CLOBBER ALL REGISTERS
CHKQ:	SAVE (A)
CHKQ1:	MOV (P),A	;GET THE NEXT IN LINE TO CHECK
	BEQ CHKQ2	;NO MORE
	MOV (A),(P)	;LINK THROUGH FOR NEXT TIME
	JSR PC,CHKPRS	;CHECK IT
	BR CHKQ1
CHKQ2:	REST A
	RTS PC

;PUT PROCESS ON THE WAKE-UP QUICK LIST
;CALL WITH ITEM IN A, PROCESS ID WORD 1 IN B, PROCESS ID WORD 2 IN C
;IF CAN'T PUT IT ON LIST, JUST RETURNS....
PRSWAK:	SAVE <PS,D>
	SPL 7		;DON'T INTERUPT ME
	MOV ACTFRE,D	;GET A FREE BLOCK
	BEQ PRSWA1	;THERE ARE NONE
	MOV (D),ACTFRE	;SPLICE IT OUT
	MOV A,ACTITM(D)	;THE ITEM
	MOV B,ACTPI1(D)	;PROCESS ID WORD 1
	MOV C,ACTPI2(D)	;PROCESS ID WORD 2
	MOV ACTLST,ACTLNK(D)	;LINK TH ENEW NODE
	MOV D,ACTLST	;TO THE FRONT OF THE LIST
PRSWA1:	REST <D,PS>	;RESTORE THE INT LEVEL AND D
	RTS PC

;CHECK THE RUNABILITY OF ALL PROCESSES ON THE ACTLST
CHKACT:	SPL 7		;SO THE LIST DOESN'T CHANGE
	MOV ACTLST,E	;GET THE FIRST GUY
	BEQ CHKAC1	;NOBODY HOME
	MOV (E),ACTLST	;SPLICE HIM OUT
	SPL 0		;OK NOW
	MOV ACTITM(E),A	;THE ITEM
	JSR PC,ITM0LD	;LOAD HIM UP
	CMPB #ITACCD,ITM0DR	;IS THIS STILL A GOOD ITEM?
	BNE CHKAC2	;NOPE, FORGET THIS LOSER
	CMP #ITPROC,(A)	;IS THIS THING I LOADED A PROCESS?
	BNE CHKAC2	;NO, CAN'T BE WHAT I WANT
	CMP ACTPI2(E),PRSID2(A)	;DO THE IDS MATCH?
	BNE CHKAC2	;NOPE
	BIT #RUNQB!STOPQB,PQBIT(A)	;IS HE RUNNING OR STOPPED?
	BNE CHKAC2	;YUP
	SAVE E
	JSR PC,CHKPRL	;GO CHECK HIM OUT
	REST E
CHKAC2:	SPL 7
	MOV ACTFRE,(E)	
	MOV E,ACTFRE	;PUT IT ON THE FREE LIST
	BR CHKACT	;AND TRY AGAIN
CHKAC1:	SPL 0
	RTS PC

;RUN THE BEST PROCESS ON THE RUN QUEUE
;CLOBBERS ALL REGISTERS
RUNBPS:	MOV RUNQ,A	;START OF GUYS TO RUN
	BNE RUNBP1	;SOME THERE FIND HIM
	WAIT		;TWIDDLE YOUR THUMBS
	RTS PC		;I GIVE UP!
RUNBP1:	SAVE <#-1,#77777,#-1,#-1,#77777,#-1>
RUNBP2:	MOV PRTUPT(A),B	;WHO IS THIS GUY'S USER?
	CMP 6(P),B	;SAME GUY WHO IS ALREADY BEST?
	BEQ RUNBP3	;YES, GO SEE IF THIS PROCESS IS BETTER
	MOV PRTPRI(B),E	;GET THE PRIORITY MULITPLE FOR THIS GUY
	BIC #177760,E	;MASK IT TO 4 BITS
	MUL PRTJTM(B),E	;GET THE NET PRIOTIRTY
	CMP E,10(P)	;HIGH PART > THAN OLD HIGH PART?
	BLO RUNBP4	;NO, THIS USER IS BETTER!
	BHI RUNBP6	;YES, THIS USER NOT AS GOOD
	CMP F,12(P)	;HIGH ORDER EQUAL, TRY LOW
	BHIS RUNBP6	;SAME OR WORSE
RUNBP4:	MOV B,6(P)	;THIS IS THE NEW BEST USER
	MOV E,10(P)	;AND HERE IS HIS PRIORITY
	MOV F,12(P)
	MOV PRTPRI(A),E	;NOW COMPUTE PRIORITY FOR THIS PROCESS
	BIC #177760,E
	MUL PRTJTM(A),E
RUNBP5:	MOV A,(P)	;THIS IS NOW THE BEST PROCESS
	MOV E,2(P)	;AND THIS IS IT'S PRIORITY
	MOV F,4(P)
RUNBP6:	MOV (A),A	;NEXT ONE ON THE QUEUE
	BNE RUNBP2	;GO SEE IF HE IS BETTER
	REST A		;THIS ONE IS BEST
	ADD #12,P	;FLUSH THE CRAP OFF THE STACK
	MOV PQUANT,QUANT	;HOW LONG TO RUN HIM FOR
	JMP STPROC	;GO TO IT (WILL RETURN TO CALLER OF RUNBPR)
RUNBP3:	MOV PRTPRI(A),E	;SAME USER, IS THIS PROCESS BETTER?
	BIC #177760,E
	MUL PRTJTM(A),E
	CMP E,2(P)	;IS THE HIGH PART BETTER?
	BLO RUNBP5	;YUP, HE'S NOW BEST
	BHI RUNBP6	;NOPE, OLD GUY IS BEST
	CMP F,4(P)	;SAME HIGH PARTS, WHAT ABOUT LOW?
	BHIS RUNBP6	;OLD GUY BEST
	BR RUNBP5	;NEW GUY BEST
	.SBTTL LOCK SWITCH ROUTINES
;GET A LOCKED SWITCH BLOCK AND STUFF THE TYPE AND ITEM INTO IT
;AND LINK IT INTO THE CURRENT PROCESS'S LOCKED LIST
;CALL WITH TYPE IN A, ITEM IN B
;PUTS ADDRESS OF BLOCK INTO A, CLOBBERS B
LOCKSW:	TST LCKFRE	;ARE THERE ANY FREE LOCKS?
	BNE LOCKS1	;YES, GO GOBBLE
LOCKS3:	BPT		;WE JUST RAN OUT OF LOCK BLOCKS!!!
			;NO GARENTEES IF YOU PROCEED FROM HERE, BUT IT WILL TRY
	JSR PC,SFLUSH	;WAIT A WHILE
	TST LCKFRE	;TRY AGAIN
	BNE LOCKS3	;NONE YET
	JSR PC,RUNME	;HOPEFULLY, WE CAN GET ONE NOW
	BR LOCKSW	;TRY AGAIN
LOCKS1:	SAVE A
	CLR A		;TO DO THE SILLY DIVIDE
	DIV #ITMTEL,A	;TO CONVERT INDEX TO NUMBER
	BIS A,(P)	;SET NUMBER INTO TYPE
	MOV LCKFRE,A	;GET THE FREE LOCK BLOCK
	MOV (A),LCKFRE	;SPLICE IT OUT
	REST LCKTIT(A)	;POP THE THING INTO THE TYPE AND ITEM
	MOV ITM0A,B	;ADDRESS OF THE PROCESS
	MOV PLCKSL(B),(A)	;PUT IT INTO LIST FOR THIS PROCESS
	MOV A,PLCKSL(B)
	MOV #-1,LCKWD1(A)	;LOCK NOT REALLY USED YET
	CLR LCKWD2(A)
	RTS PC

;CLEAR THE LOCKED SWITCH LIST
LSWCLR:	SAVE A
	MOV ITM0A,A
LSWCL2:	TST PLCKSL(A)	;ANY LOCKED
	BEQ LSWCL1	;NOPE, ALL POPED
	JSR PC,LSWPOP	;FLUSH ONE
	BR LSWCL2	;TRY AGAIN
LSWCL1:	REST A
	RTS PC
;LOCK A PARTICULAR SWITCH
;A HAS THE ADDRESS OF THE SWITCH, OR THE OFFSET INTO THE SPHERE
;B HAS THE BIT(S) WHICH ARE TO BE LOCKED
;C HAS THE ITEM NO THAT THE SWITCH IS IN  (OR 0 IF ABSOLUTE)
LCKASW:	TST INITSW	;NO SWITCHES LOCKED IN THE INIT CODE
	BNE LOCKA5
	SAVE <E,D,A,B>
	MOV A,E		;COPY THE OFFSET
	MOV #LONOFF,A	;THE TYPE OF LOCK
	MOV C,B		;THE ITEM NO. OF THE SPHERE
	JSR PC,LOCKSW	;GET A LOCK
	REST B
	MOV A,D		;SAVE POINTER TO THE LOCK
LOCKA2:	MOV C,A		;THE SPHERE NO. THAT THE SWITCH IS IN
	BEQ .+6		;NO ITEM
	JSR PC,ITM1PL	;LOAD IT UP
	ADD E,A	;MAKE A POINT TO THE SWITCH
	BIT B,(A)	;IS THE LOCK UNLOCKED?
	BEQ LOCKA1	;YES
LOCKA3:	TST C		;ANY ITEM PUSHES
	BEQ .+6		;NOPE
	JSR PC,ITM1PO	;POP THE SPHERE
	JSR PC,SFLUSH	;TWIDDLE OUR THUMBS
	MOV C,A		;THE SPHERE NO.
	BEQ .+6		;ABSLOLUTE SWITCH
	JSR PC,ITM1PL	;LOAD IT UP
	ADD E,A	;MAKE A POINT TO THE SWITCH
	BIT B,(A)	;IS IT UNLOCKED YET
	BNE LOCKA3	;NOT YET
	TST C		;IS THE SWITCH IN AN ITEM
	BEQ .+6		;NOPE
	JSR PC,ITM1PO	;POP THE SPHERE
	JSR PC,RUNME	;I THINK I HAVE GOT IT
	BR LOCKA2	;MAKE SURE
LOCKA1:	BIS B,(A)	;LOCK THE SWITCH
	TST C		;ANY ITEM PUSHED
	BEQ .+6		;NOPE
	JSR PC,ITM1PO	;POP THE SPHERE
	REST A		;GET THE POINTER TO THE LOCK
	MOV A,LCKWD1(D)	;SAY THIS LOCK IS USED
	MOV B,LCKWD2(D)	;THE BITS LOCKED
	REST <D,E>	;GET ORIGINAL CONTENTS OF D
LOCKA5:	RTS PC
;POP THE TOP LOCK OFF THE LOCKED SWITCH LIST
LSWPOP:	TST INITSW	;ARE WE IN INIT CODE?
	BNE LSWPO2	;NO SWITCHES EVER LOCKED
	SAVE <A,B,C>
	MOV ITM0A,A	;ASSUME ITEM0 IS THE PROCESS WHICH IS UNLOCKING
	MOV PLCKSL(A),B	;SPLICE LOCK OUT OF IT'S LIST
	BUGC NE		;ONLY SHOULD GET CALLED IF ANYTHING IS LOCKED
	MOV (B),PLCKSL(A)
	MOV LCKFRE,(B)	;PUT IT ONTO THE FREE LIST
	MOV B,LCKFRE
	CMP #-1,LCKWD1(B)	;IS IT FOR REAL?
	BEQ LSWPOR+4	;NOPE, WE HAVE "UNLOCKED" IT
	SAVE B		;FOR THE ROUTINES WE CALL
	MOV LCKTIT(B),B	;GET THE TYPE
	MOV #-1,A	;MAKE ITEM NXM (FOR THE SAKE OF THE PUSH)
	JSR PC,ITM2PL
	SAVE B		;SAVE TYPE AND ITEM
	CLR A		;IN CASE THERE IS NO ITEM
	BIC #176000,B	;GET THE ITEM
	BEQ LSWPO1	;NOPE, NO ITEM
	MUL #ITMTEL,B	;CONVERT TO INDEX
	MOV B,A
	JSR PC,ITM2LD	;SAVE IT AWAY
LSWPO1:	REST <C,B>		;GET BACK FOR TYPE
	ASH #-9.,C
	BIC #177601,C	;MAKE IT INTO A 6 BIT INDEX
	JMP @LCKDIS(C)	;DISPATCH ON TYPE

LSPONF:	ADD LCKWD1(B),A	;POINT INTO ITEM IF THERE IS ONE
	BIC LCKWD2(B),(A)	;UNLOCK ON-OFF TYPE LOCK
LSWPOR:	JSR PC,ITM2PO	;POP THE ITEM STACK
	REST <C,B,A>
LSWPO2:	RTS PC
LSPERR:	BPT		;GASP! BAD LOCK TYPE
	BR .-2
LSPPCL:	TST BPCLSR	;IS HE BEING PCLSRED?
	BEQ LSWPOR	;IF NO, GO AWAY
LSPRTN:	JSR PC,@LCKWD1(B)	;BEING PCLSRED, RUN ROUTINE
	BR LSWPOR	;ALL DONE WITH THIS SWITCH
LSPDEC:	ADD LCKWD1(B),A	;GET ABSOULUTE ADDRESS
	DEC (A)		;FIXUP THE FLAG
	BNE LSWPOR	;IF NOT ZERO, ALL DONE
	TST LCKWD2(B)	;IS THERE A ROUTINE TO RUN ON ZERO FLAG?
	BEQ LSWPOR	;NO, FINISHED THEN
	JSR PC,@LCKWD2(B)	;CALL THE ROUTINE
	BR LSWPOR
;THE DELETE ON PCLOSERING ROUTINE, FOR THINGS THAT NEED ITEMS FLUSHED
PCLDLI:	MOV ITEM2,A
	JMP DLITEM	;THE LOADED ITEM IS GETTING FLUSHED

	.SBTTL MEMORY MANAGMENT ROUTINES
;MAP RESTORE ROUTINE
;CLOBBERS NO REGISTERS
;EXPECTS THE SPHERE TO RESTORE IN ITEM1
;DOES NOT RESTORE IF CURSPH IS SAME AS ITEM1
MAPRES:	CMP CURSPH,ITEM1	;IS IT ALREADY LOADED?
	BEQ MAPRE6		;YES
	MOV ITEM1,CURSPH
MAPRE1:	JSR F,ACSAV	;THIS IS THE ENTRY POINT FOR RESTORING THE MAP EVERY TIME
	MOV ITM1A,A	;POINTER TO THE ITEM
	ADD #SUPTS,A	;GET POINTER TO UPTS FOR SPHERE
	MOV #USRISD,B	;POINT TO USER MAP
	MOV #20,C	;NUMBER OF SEGMENTS TO LOAD
MAPRE2:	CLR (B)		;CLEAR OUT THE OLD REGISTER
	TST (A)		;DOES THE PAGE EXIST?
	BEQ MAPRE3	;NO PAGE HERE
	BLT MAPRE4	;SAME AS COORESPONDING I PAGE
MAPRE7:	TST UPTAR(A)	;IS IT AN ABSOLUTE PAGE?
	BLT MAPRE8	;YUP, GO LOAD IT
	BIT #UPTICR,UPTAR(A)	;IS IT IN CORE
	BEQ MAPRE3	;NO
	MOV UPTAR(A),D	;GET THE CORE ADDRESS
	BIC #UPASMS,D	;CLEAR ALL BUT THE ADDRESS
	ASH #-3,D	;GET IT INTO THE CORRECT BITS
	BIC #1,D	;MAKE SURE IT IS A WORD INDEX
	MOV CST(D),D	;GET THE CST ENTRY
	BIC #CSTCOM,D	;GET THE CPT OFFSET
	BIT #CPTMOV,CPT+CPTADR(D)	;IS THE PAGE MOVING
	BNE MAPRE3	;YES, DON'T LOAD IT
	MOV (A),F	;THE DR
	BIC #UPMSRE,F	;GET THE START OF THE REFERENCED ENTRY
	SWAB F		;INTO THE LOW BYTE
	MOV UPTAR(A),E	;GET THE AR
	BIC #UPMSSW,E	;CLEAR ALL BUT THE START
	SUB E,F		;GET THE OFFSET
	MOV UPTAR(A),E	;GET THE AR
	ASH #4,F	;PUT IT INTO THE RIGHT BITS
	ADD F,E		;FIX AR
	BIC #UPASMS,E	;CLEAR ALL BUT THE SEGMENTER BITS
	MOV E,USRISA-USRISD(B)		;SET IT IN
	BR MAPRE9	;HANDLE THE DR
MAPRE8:	MOV UPTAR(A),USRISA-USRISD(B)	;PUT IN THE AR
	BIC #UPASMS,USRISA-USRISD(B)	;CLEAR EXTRA BITS
MAPRE9:	MOV (A),(B)	;COPY THE DR
	BIC #UPTSMS,(B)	;CLEAR ALL THE SPURIOUS DATA
	BIS #7400,(B)	;MAKE IT FOR A FULL PAGE
MAPRE3:	TST (B)+	;INCREMENT POINTER TO SEG REGISTERS
	ADD #UPTLEN,A	;AND POINTER TO UPTS
	SOB C,MAPRE2	;GO BACK IF NOT FINISHED
	JSR F,ACRES
MAPRE6:	RTS PC

MAPRE4:	CMP #10,C	;IS IT REAL A DATA PAGE?
	BLT MAPRE7	;NO, IT IS THE I SPACE FOR I=D PAGE
	MOV USRISD-USRDSD(B),(B)	;DR FROM THE I SPACE
	MOV USRISA-USRDSD(B),USRISA-USRISD(B)	;THE AR FROM THE I SPACE PAGE
	BR MAPRE3	;GET THE NEXT PAGE
;INTIAL MAP-SETTING ROUTINE
;CLOBBERS MOST AC'S, INTENDED TO BE RUN ONLY AT ITIALIZE TIME
;OR AFTER A POWER FAIL RESTART
MAPSET:	MOV #I0AR,A	;FIRST WE'LL SET UP A STRAIGHT MAP
	CLR B		;I AND D SPACE THE SAME AND MAPPED DIRECTLY
	MOV #8.,C	;FROM VIRTUAL CORE TO PHYSICAL
MAPST1:	MOV #77406,VAR0DR-I0AR(A)	;DATA SPACE 4K SEGEMNET
	MOV #77406,I0DR-I0AR(A)		;INSTRUCTION SPACE 4K SEGMENT
	MOV B,VAR0AR-I0AR(A)		;VIRTUAL MAPPED DIRECTLY TO PHYSICAL
	MOV B,(A)+			;FOR BOTH INST AND DATA SPACE
	ADD #200,B	;4K WORTH
	SOB C,MAPST1	;DO FORR 8 SEGMENTS
	;NOW WE'LL HACK THE SPEECAIL THINGS
	MOV #7600,IOAR	;MAP USUAL I/O SPACE TO REAL I/O SPACE
;THE FOLLOWING THING IS THE DR FOR THE RUG PAGES (UGH!)
FOO==<<200-<<RUGIDR-I0DR+2>*100>+<<RUGST_-6>&1777>>_8.>+16
	MOV #FOO,RUGIDR	;SPECIAL RUG SEGMENT
	MOV #FOO,RUGDDR	;MAP 156000-157776 VIRTUAL TO SAME PHYSICAL
	MOV #VAR2DR,A	;NOW FLUSH UNUSED VARIABLE PAGE AND 3 ITEM PAGES
	CLR (A)+
	CLR (A)+
	CLR (A)+
	CLR (A)
	MOV #I7DR,A
	CLR (A)		;FLUSH HIGH INSTRUCTION PAGE
	TST -(A)	;DON'T CLOBBER RUG PAGE
	MOV #120000,B	;FIRST LOCATION IN A PAGE BEFORE RUG PAGE
MAPST2:	CMP #LSTILC,B	;LAST INSTRUCTION LOCATION
	BHI MAPST3	;IF THERE IS SOMETHING THERE, WE'RE DONE
	CLR -(A)	;NO ONE THERE, FLUSH IT
	SUB #20000,B	;NEXT PAGE DOWN
	BR MAPST2
MAPST3:	MOV #7,SSR3	;ENABLE I AND D FOR ALL MAPS
	MOV #1,SSR0	;THERE WE GO!!
	RTS PC
;THE MEMORY TABLE INITIALIZER
;CLOBBERS ALL REGISTERS
MEMTST:	CLR ITM0AR	;FIRST FIND HOW MUCH MEMORY
	MOV #6,ITM0DR	;LENGTH 1 PAGE
	SAVE BEBRV	;SAVE THE BUSS ERROR VECTOR
	MOV #MEMTS1,BEBRV	;TRAP BACK TO THE ROUTINE
	MOV #MNCBLK,A		;THE MOST WE WILL PAY ATTENTION TO
	MOV #CST,B
MEMTS2:	TST ITM0AD	;CAUSE BUSS ERROR IF NXM
	ADD #20,ITM0AR	;INCREMENT BY 512 WORDS
	MOV #CSTBEB!CSTSYB,(B)+	;SAY IT EXISTS AND SYSTEM USING IT
	SOB A,MEMTS2	;TRY AGAIN UNLESS WE HAVE ENOUGH
	BR MEMTS3
MEMTS1:	SPL 0
	CMP (P)+,(P)+	;FLUSH THE TRAP
	MOV #CSTSYB,(B)+	;SAY THE SYSTEM IS USING NON-EX CORE
	SOB A,.-4
MEMTS3:	REST BEBRV
	MOV ITM0AR,B
	SUB #<<RUGIAR-I0AR>+2>*100,B	;CONVERT TO AMOUNT ABOVE RUG
	BUGC GE		;IS THERE ENOGUH FOR RUG
	ASH #-4,B	;CONVERT TO 512 WORD BLOCKS
	MOV #<<RUGIAR-I0AR>+2>*4,A	;FIRST BLOCK AFTER RUG
.IIF NZ NTKDIS,JSR PC,DISALC
	MOV B,NUMBLKS
	MOV #2,E	;THE PLACE TO START
	JSR PC,MEMALC	;NOW GO SEE WHAT WE CAN GET FROM THIS
	MOV #FSTFRB,A	;FROM FIRST FREE BLOCK
	MOV #<<<RUGST-LSTILC>_-10.>-1>&77,B	;NUMBER FREE BEFORE RUG
	ADD B,NUMBLKS
;FALL INTO MEMALC TO USE UP SPACE BETWEEN END OF CODE AND RUG
MEMALC:	MOV A,C		;THE BEGGINING OF THE AREA
	ASL C		;CONVERT TO A WORD INDEX
	ADD #CST,C	;WE WILL USE IT TO SET THE CST
	MOV E,-(P)	;THE FIRST CPT ENTRY TO USE
	TST -(P)	;AND A FREE WORD
MEMAL1:	MOV #10,D	;INDEX TO SIZE-INDEXED TABLES
MEMAL7:	ASL D		;CONVERT BACK TO INDEX
MEMAL2:	MOV MEMIAT-2(D),(P)	;NUMBER OF THINGS THIS SIZE TO TRY TO ALLOCATE
	BEQ MEMAL4	;OOOPS, NONE THIS SIZE PLEASE!
MEMAL5:	ASR D		;CONVERT INDEX TO COUNT
	TST B		;IS THERE ANY LEFT?
	BEQ MEMAL3	;NOPE! GOODBYE.
	CMP D,B		;DO WE HAVE ENOGUH FOR THIS SIZE BLOCK?
	BGT MEMAL6	;NOPE, TRY A SMALLER ONE
	BIS #CSTFBB!CSTFRB,(C)	;THE BEGINNING OF A FREE PAGE
	MOV D,E		;THE SIZE OF THE PAGE
MEMAL8:	BIC #CSTSYB,(C)	;SAY THAT IT IS NO LONGER USED BY SYSTEM
	ADD 2(P),(C)+	;THE CPT INDEX
	SOB E,MEMAL8	;IN ALL THE CST WORDS FOR THIS PAGE
;FALL THROUGH TO NEXT PAGE
;FALL IN FROM PREVIOUS PAGE
	MOV 2(P),E		;GET THE CPT INDEX
	ADD #CPTLEN,2(P)	;MOV TO NEXT CPT BLOCK
	CMP #CPTEND-CPT,E	;MAKE SURE WE DON'T GO OFF THE END
	BUGC GT			;BRANCH IF NOT OFF THE END
	ASL D			;BACK TO AN INDEX AGIAN
	MOV FMMALT-2(D),CPT(E)	;LINK INTO FREE LIST FOR THIS SIZE
	MOV E,FMMALT-2(D)
	MOV #-1,CPT+CPTUPP(E)	;THE UPT POINTER=NULL
	MOV A,CPT+CPTADR(E)	;THE CORE ADDRESS
	ASR D		;BACK TO COUNT
	ADD D,A		;INCREMENT ADDRESS
	SUB D,B		;DECREMENT SPACE LEFT
	ASL D		;BACK AGAIN
	INC NUMPGS-2(D)	;SAY ANOTHER PAGE THIS SIZE
	DEC (P)		;DONE ALL OF THIS SIZE?
	BNE MEMAL5	;NOT YET
MEMAL4:	ASR D	;BACK TO COUNT
MEMAL6:	SOB D,MEMAL7
	BR MEMAL1	;DO IT ALL AGAIN
MEMAL3:	TST (P)+
	REST E		;GET BACK THE STARTING CPT OFFSET
	RTS PC

.IFNZ NTKDIS
;DISPLAY ALLOCATION ROUTINE
;ENTER WITH PLACE TO START ALLOCATING IN A
;NUMBER OF BLOCKS FREE IN B
;RETURN WITH A POINTING PAST WHAT WE HAVE ALLOCATED
;AND B HAVING WHAT WE HAVE ALLOCATED REMOVED
DISALC:	CMP #100,A	;THE DISPLAYS MUST START
	BGT .+4		;BELOW 32K
	BPT		;SO WE CAN SET THE RELOCATION PROPERLY
	MOV A,C		;SAVE START
	ASH #10.,C	;CONVERT TO WORD ADDRESS
	MOV C,TKRELS	;AND SAVE AS THE RELOCATION
	MOV C,NGREL	;ALSO SET RELOCATION
	MOV #1,C	;LENGTH ONE BLOCK
	JSR PC,ITMFAK	;FAKE UP AN ITEM
	MOV D,TKDPDL	;THE PDL AND START VECTOR ITEM
	MOV ITMTAB(D),TKDPDA	;SAVE THE START IN A CONVEINET PLACE
	CLR E		;THE ONE WE ARE ALLOCATING
	MOV #NTKDIS,F
DISAL1:	MOV TKDLEN(E),C	;LENGTH FOR THIS ONE
	JSR PC,ITMFAK	;FAKE UP AN ITEM
	MOV D,TKDITM(E)	;SAVE THE ITEM FOR THIS DISPLAY BUFFER
	TST (E)+
	SOB F,DISAL1
	SAVE <A>
	MOV TKDPDL,A	;THE PDLS AND START WORDS
	JSR PC,ITM2LD
	MOV #8.,C
DISAL2:	MOV #DSTOP,(A)+	;STOP ALL DISPLAYS
	SOB C,DISAL2
	REST <A>
	RTS PC

;FAKE UP AN ITEM
ITMFAK:	SAVE <C>
	MOV ITMFRE,D	;THE ITEM LIST
	MOV (D),ITMFRE	;TAKE THIS ITEM
	ASH #4,C	;MAKE LENGHT INTO 32. WORD BLOCKS
	DEC C		;CAUSE OF WAY SEGMENTS WORK
	MOVB C,ITLNGT(D)	;SET LENGHT
	MOVB #ITACCD,ITACCS(D)	;AND ACCESS
	MOV A,C		;COPY START
	ASH #4,C	;MAKE IT INTO 32. WORD BLOCKS
	MOV C,(D)	;SET THE ADDRESS INTO THE ITEM
	SUB #ITMTAB,D	;MAKE IT INTO AN ITEM NUMBER
	REST <C>	;RESTORE LENGHT IN 512. WORD BLOCKS
	ADD C,A		;NEXT PLACE TO ALLOCATE
	SUB C,B		;STUFF WE'VE USED
	BGT .+4		;MAKE SURE WE DON'T RUN OUT
	BPT		;OOOOPS!
	RTS PC
.ENDC
	.SBTTL TRAP AND FAULT ROUTINS
ILLBRK:	TSTB PS+1
	BNE ILLBR1
	BPT
	BR .-2
ILLBR1:	MOV #100000+.ILLTF,C
	BR CCFAUL

BEBRK:	TSTB PS+1	;DID IT COME FROM USER MODE?
	BNE BEBRK1	;YES
	BPT
	RTT
BEBRK1:	MOV #100000+.BETF,C	;BEBRK FAULT
	BR CCFAUL

IOTBRK:	TSTB PS+1	;DID IT COME FROM USER MODE
	BNE IOTBR1	;YES
	BPT
	RTT
IOTBR1:	MOV #100000+.IOTTF,C
	BR CCFAUL

FPPBRK:	MOV #100000+.FPPTF,C
	BR CCFAUL

PARBRK:	BPT
	RTT

BPTBRK:	TSTB PS+1	;FROM USER MOD
	BNE BPTBR1	;YES
	SAVE <RUGSTA,RUGVEC>	;SAVE THE STUFF FOR RUG
	RTI		;RETURN TO RUG
BPTBR1:	MOV #100000+.BPTTF,C	;SAY A BPT FAULT
CCFAUL:	MOV PC,USRMOD	;IN THE SYSTEM NOW
	JSR F,SPCPSP
	MOV C,PFAULT(A)	;THE TYPE OF FAULT
;FALLS IN TO THE NEXT PAGE
;FALLS IN FROM PREVIOUS PAGE
CFAULT:	SPL 0		;JUST IN CASE
	JSR F,SAVEPP	;SAVE THE USERS PDL POINTER
	TST (P)+	;CAUSE SAVEPP LEAVES IT THERE, THAT'S WHY!
	TST LOOKSW
	BEQ CFAUL9	;IGNORE SWITCHES
	BIT #40000,CSWR
	BEQ CFAUL9
	BPT
CFAUL9:	MOV ITEM1,C	;THE SPHERE TO STOP
	CMP C,SYSSPR	;THE SYSTEM SPHERE?
	BNE .+4
	BPT		;YES, DIE
	JSR PC,SPRSTP	;STOP THE SPHERE
	MOV ITM1A,A	;THE SUPERIOR SPHERE
	BIS #FAULT1,SFLAG(A)	;SAY THERE IS A FAULT
	MOV SMSSPT(A),A	;GET THE SUPERIOR SPHERE
	JSR PC,ITM2LD	;LOAD IT UP
	SAVE #177	;THE FIRST CAPABILITY NO.
CFAUL2:	MOV (P),B	;GET THE CAPAIBLITY NO.
	JSR PC,GCLSTA
	BEQ CFAUL3	;COULDN'T GET IT
	ADD A,B		;POINT TO IT DIRECTLY
	CMPB (B),#.MSCAP	;IS IT MASTER SPHERE
	BNE CFAUL3	;NO
	CMP 2(B),ITEM1	;FOR THIS SPHERE
	BEQ CFAUL4	;YES
CFAUL3:	DEC (P)		;THE COUNTER
	BGE CFAUL2	;TRY THE NEXT ONE
	BPT		;COULDN'T FIND IT
	TST (P)+
CFAUL5:	MOV ITEM0,A	;PROCESS THAT FAULTED
	JSR PC,PSTPIN	;INCREMENT MY STOP WORD NOW, AND  PCLOSER MYSELF
	SAVE PC		;JUST FOR RANDOMNESS
	SAVE #STOPQ	;STOP YOURSELF
	JMP FLUSH	;LET THE PROCESS CREATED HANDLE IT
CFAUL4:	BIT #.SPFES,(B)	;CAN I CAUSE AN ENTER
	BNE CFAUL5	;NO, FORGET IT
	MOV 6(B),E	;THE ENTER ADDRESS	
	BIT #1,E	;DOES IT EXIST
	BNE CFAUL5	;NO
CFAUL6:	MOV ITEM2,C	;POINTER TO THE SUPERIOR SPHERE
	MOV #-1,B	;PUT IT ANYWHERE
	JSR PC,CRCLST	;CREATE A PACE FOR IT
	BCS CFAUL5	;C-LIST FULL FORGET IT
	ADD ITM2A,A	;POINT TO THE C-LIST ENTRY
	MOV #-1,(A)	;RESERVE IT
	MOV A,F		;SAVE THE POINTER
	MOV B,D		;SAVE THE CAPABILITY NO.
	MOV #LPCLRT,A	;INCASE OF PC-LOSER
	MOV ITEM2,B	;THE ITEM
	JSR PC,LOCKSW	;RELEASE THE SLOT
	MOV F,LCKWD2(A)	;POINT TO THE C-LIST SLOT
CFAUL7:	MOV F,A		;POINTER TO FIRST CAPABILITY
	MOV #.PRWRA!.PRCAP,(A)+	;CREATE A PROCESS CAPABILITY TO THE FAULTING PROCESS
	MOV ITEM0,(A)+	;SET IN THE PROCESS ITEM NO.
	MOV ITM0A,A
	INC PRSREF(A)
	JSR PC,CRPROC	;CREATE PROCESS
	BEQ CFAUL5	;FAILED
	JSR PC,ITM0PL	;LOAD IT UP
	DEC PRSREF(A)	;SINCE THERE WILL BE NO CAP TO IT, AND PUTPRS WILL INCREMENT IT
	BIC #PSUPSB,PSTOP(A)	;CLEAR THE BIT
	MOV E,PUPC(A)	;SET UP THE STARTING ADDRESS
	ADD #PUREGS,A	;POINT TO THE REGISTERS
	MOV D,(A)+	;PUT IN CAPABILITY TO THE FAULTING PROCESS INTO %0
	REST (A)	;PUT IN CAPABILITY OF MS CAPABILITY TO FAULTING SPHERE
	MOV ITEM0,A	;COPY THE ITEM NO. OF THE FAULT HANDLER
	MOV ITEM2,B	;THE SUPERIOR SPHERE
	JSR PC,PUTPRS	;PUT THE PROCESS INTO THE SPHERE
	JSR PC,PSTPDC	;START IT
	JSR PC,ITM0PO	;POP THE ITEM
	JSR PC,LSWCLR	;CLEAR THE SWITCHES
	JMP CFAUL5

;FIX THE FAULT FOR THE SPHERE IN B
FALTFX:	SAVE <A,C>	;SAVE SOME REGS.
	MOV B,A		;THE SPHERE
	JSR PC,ITM1PL	;LOAD IT UP
	BIT #FAULT1!FAULT2!FAULT3,SFLAG(A)	;IS THERE A FAULT
	BUGC NE		;JUST CHECKING
	BIC #FAULT1!FAULT2!FAULT3,SFLAG(A)	;SAY NO MORE FAULT
	MOV ITEM1,A	;GET THE SPHERE NO.
	JSR PC,ITM1PO	;POP  THE SPHERE
	JSR PC,SPRSTR	;START IT UP
	REST <C,A>	;CLEAN UP
	RTS PC

TRPBRK:	MOV #TRPBRV,A	;POINTER TO THE TRAP STUFF
	JSR PC,USRTRP	;CHECK OUT THE TRAP
	MOV ITM0A,A	;POINTER TO THE PROCESS
	TSTB PS+1	;IS IT FROM KERNEL MODE
	BEQ TRPBR1	;YES,
	MOV #100000+.TRPTF,PFAULT(A)	;FAULT TYPE FOR BAD TRAP
	JMP CFAULT	;JUST CAUSE THE FAULT
TRPBR1:	SUB #2,(P)	;POINT TO THE TRAP
	MOV (P),PERRAD(A)	;SAVE SYSTEM ADDRESS WHERE ERROR HAPPENED
	MFPI (P)	;GET THE ACT`ATxTRAP INSTRUCTION
	REST B		;GET BACK THE INSCTRUCTION
	MOV STPSVP,P	;RESTORE STACK TO THE STATE IT WAS IN WHEN SHED CALLED US
	CCC		;CLEAR THE CONDITION CODES
	SAVE PS		;SAVE A COPY OF THE PS TO MUNG
	BIT #TRPZBT,B	;ARE WE SUPPOSED TO SET THE Z BIT?
	BEQ .+6		;NO
	BIS #4,(P)	;SET IT
	BIT #TRPVBT,B	;ARE WE SUPPOSED TO SET THE V BIT?
	BEQ .+6		;NO
	BIS #2,(P)	;SET IT
	BIC #177400!TRPZBT!TRPVBT,B	;CLEAR BITS
	MOV B,PERRW(A)	;THAT'S THE ERROR TYPE
	JMP EMTRTP	;EMT RETURN SPECIAL ENTRY

;THIS ROUTINE EXPECTS A TO BE A POINTER TO THE TRAP VECTOR IN THE USERS CORE
;AND DECIDES IF IT IS A FAULT OR A TRAP THROUGH
USRTRP:	TSTB PS+1	;IS IT FROM KERNEL MODE
	BNE USRTR1	;NO
	RTS PC		;TEMPORARY FOR TRAP TO WORK
USRTR1:	MOV PC,USRMOD	;SAY WE ARE IN THE SYSTEM
	REST E		;THE CALLING ADDRESS	
	MOV A,B		;SAVE THE POINTER TO THE TRAP
	JSR F,SPCPSP	;SAVE HIS STUFF, AND F GETS USER P POINTER
	SUB #2,PUPC(A)	;DECREMENT IT TO THE CALL IF PCLOSERED
;HERE IF NOT TRAP THROUGH JUST RETURN BY JMP (E)
	MFPD -(F)	;GET THAT WORD
	MFPD -(F)	;GET THE PC WORD
	MFPI 2(B)	;ALL THIS TO PREVENT HANG BELOW
	MFPI (B)	;PROBABLY UNNECCESSARY
	ADD #10,P	;POP OFF THE EXTRA STUFF
	SAVE <PUPS(A),PUPC(A)>
	ADD #2,(P)	;MAKE IT LOOK LIKE REAL TRAP
	MTPD (F)+	;GIVE HIM THE PC
	MTPD (F)+	;AND THE PS
	SUB #4,F
	SAVE F		;THE NEW P
	MTPI P		;GIVE IT BACK
	MFPI 2(B)	;GET THE TRAP VECTOR STATUS
	BIC #340,(P)	;CLEAR THE PRIORITY BITS
	BIS #174000,(P)	;USER MODE, FOR SURE
	MFPI (B)	;AND THE ADDRESS	
	CLR USRMOD
	RTT		;RETURN
	.STITL PAGING ROUTINES
;THIS IS THE ROUTINE CALLED FROM SEGMENTATION INTERRUPT
SEGBRK:	MOV SSR2,(P)	;GET THE TRUE PC
	TSTB PS+1	;IS IT FROM KERNEL MODE
	BEQ SGBRK1	;YES
	MOV PC,USRMOD	;SAY WE ARE NOW IN SYSTEM
	CMPB PS+1,#60	;DID IT COME FROM USER MODE
	BUGC EQ		;YES
	JSR F,SPCPSP	;SAVE HIS P,PS, AND PC (CORRECTED)
	JSR PC,PACSAV	;SAVE HIS REGISTERS
	MOV ITM0A,A
	ADD #PUREGS,A	;A POINTS TO SAVED REGISTERS
	JSR PC,PAGIN	;SWAP THE PAGE IN
	MOV ITM0A,B	;POINTER TO THE PROCESS
	JSR PC,PACRES	;RESTORE HIS REGISTERS
	SPL CLKL	;STOP THE CLOCK
	CLR USRMOD	;SAY WE ARE LEAVING SYSTEM
	TST QUANT	;IS HIS TIME UP YET
	BGE .+10	;NO
	BIS #CLKPIR,PIRQ	;STOP HIM AFTER RTT
	SAVE <PUPS(B),PUPC(B)>	;SAVE FOR RTT
	RTT		;RETURN
SGBRK1:	CLR -(P)	;FAKE A P STACK
	JSR F,ACSAV	;SAVE THE AC'S
	MOV P,A		;GET POINTER TO THE REGISTERS
	JSR PC,PAGIN	;SWAP IN THE PAGE
	JSR F,ACRES	;RESTORE THE REGISTERS
	TST (P)		;IS THE OFFSET NEGATIVE
	BUGC GE		;NO, SOMEONE MUST HAVE DONE A MTPD BEFORE MFPD
	SAVE D		;GET A REGISTER
	MOV 2(P),D	;GET THE OFFSET
	REST (P)	;CLOBBER OFFSET
	SAVE E		;GET ANOTHER REGISTER, AND CLOBBER OFFSET
	MOV P,E		;MAKE E POINT TO THE STACK
	ADD #10,E	;MAKE IT POINT TO THE PS,PC,E,D
	ADD P,D		;MAKE D POINT TO WHERE WE WANT THE STACK
	ADD #10,D	;MAKE D POINT TO WHERE THE DATA IS GOING
	MOV -(E),-(D)	;TRANSFER PS,PC,E,D
	MOV -(E),-(D)
	MOV -(E),-(D)
	MOV -(E),-(D)
	MOV D,P		;NEW P POINTER
	REST <E,D>	;GET BACK E AND D
	RTT		;RETURN TO SYSTEM
;THIS ROUTINE TAKES A POINTER TO THE USERS STORED REGISTERS IN A
;UPDATES THEM AND GETS THE PAGE THAT WAS NEEDED
PAGIN:	SAVE <SSR1,SSR0>	;GET THE STATUS REGISTERS
	BIC #170000,SSR0	;START UP THE MEMORY MANAGEMENT AGAIN
	SPL 0		;NO NEED FOR HIGH PRIORITY
	TST (P)		;IS IT NON RESIDENT?
	BMI .+6
	JMP PAGERR
	TSTB 2(P)	;IS THE CURRENT INSTRUCTION FINISHED
	BMI PAGIN1	;YES
	MOVB 2(P),B	;THE REGISTERS MODIFIED BY INSTRUCTION
	BEQ PAGIN1	;NONE
	MOVB B,C	;GET THE LOW BYTE
	ASH #-3,B	;GET THE OFFSET
	BIC #177770,C	;THE REGISTER NO.
	CMP C,#7	;IS IT THE PC
	BEQ PAGIN2	;YES, FORGET IT
	ASL C		;MAKE IT A WORD INDEX
	ADD A,C		;MAKE C POINT TO THAT SAVED REGISTER
	SUB B,(C)	;CORRECT IT
PAGIN2:	MOVB 3(P),B	;NEXT REGISTER
	BEQ PAGIN1	;NONE
	MOVB B,C	;COPY IT
	ASH #-3,B	;GET THE OFFSET
	BIC #177770,C	;GET THE REGISETER
	CMP C,#7	;PC?
	BEQ PAGIN1	;YES
	ASL C		;WORD INDEX
	ADD A,C		;MAKE C POINT TO IT
	SUB B,(C)	;FIX IT
PAGIN1:	MOV (P),B	;THE STATUS REGISTER
	BIC #SEGPMO,B	;GET THE MODE OF THE PAGE
	CMP B,#SEGUSR	;IS IT A USER PAGE
	BNE KERPAG	;NO, IT IS A KERNEL PAGE
	MOV (P),B	;GET THE SSR0 AGAIN
	BIC #SEGPNO,B	;CLEAR ALL BUT THE PAGE NO.
	SWAB B		;GET IT INTO THE RIGHT BITS
	ASL B
	BIS #GIPBIT!GIPSPR,B	;SAY IT IS A GIP AND IN SPHERE
	BIS ITEM1,B	;SET IN THE ITEM NO
	SAVE B		;SAVE THE POINTER
	JSR PC,UPTPLD	;LOAD IT UP
	MOV UPTDR(B),C	;THE DR
	JSR PC,ITM2PO	;POP IT
	REST B		;GET BACK THE ITEM
	MOV ITM0A,A	;POINT TO THE PROCESS
	BIT #7,C	;ANY ACCESS
	BNE .+6
	JMP PAGACV	;ACCESS VIOLATION
	JSR PC,SWPIN	;SWAP IT IN
	JSR PC,SAVAWB	;SAVE THE CURRENT AWB BITS
	JSR PC,MAPRE1	;RESTORE HIS MAP
	ADD #4,P	;POP OFF STATUS REGISTERS
	RTS PC		;ALL DONE
KERPAG:	BPT
	TST B
	BUGC EQ		;BETTER HAVE BEEN KERNEL MODE
	MOV (P),B	;THE PAGE NO.
	BIC #SEGPNO,B	;GET IT
	BIT #20,B	;IS IT DATA PAGE
	BUGC NE		;YES
	BIC #20,B	;GET THE PAGE NO.
	CMP B,#<ITM2AR-KERDSA>	;IS IT ITEM 2
	BUGC EQ		;YES, IT IS OKAY
	MOV ITEM2,B	;THE GIP TO GET
	JSR PC,SWPIN	;GET IT
	MOV ITEM2,A	;TRY LOADING IT NOW
	JSR PC,ITM2LD	;LOAD IT UP AGAIN
	ADD #4,P
	RTS PC

;JUMPED INTO FROM PERVIOUS PAGE
PAGERR:	MOV ITM0A,A	;THE PROCESS
	MOV (P),B	;THE SSR0
	MOV B,C		;COPY IT
	BIC #SEGPMO,B	;CLEAR ALL BUT THE PAGE NUMBER
	CMP B,#SEGUSR	;IS IT USER PAGE
	BUGC EQ		;NO, BARF SYSTEM TRIED TO WRITE READ ONLY PAGE? OR SLE?
	ROL C		;TST SOME BITS
	ROL C		;CHECK THE SLE BIT
	BCS PAGSLE	;ITS SET
	ROL C		;CHECK THE WRITE VIOLATION BIT
	BCS PAGRDO	;READ ONLY PAGE
	ROL C		;CHECK THE TRAP MEM-MANAGEMENT
	BUGC CS		;IF IT ISN'T THIS DONT KNOW WHAT IS GOING ON

	BPT		;THIS MIGHT BE SOME MAR HACK
PAGSLE:	MOV #100000+.SLETF,PFAULT(A)	;SEGMENT LENGTH ERROR
SEGFLT:	ADD #6,P	;POP OFF SSR0,SSR1, AND RETURN ADDRESS
	JMP CFAULT	;HE LOSES
PAGRDO:	MOV #100000+.RDOTF,PFAULT(A)	;READ ONLY FAULT
	BR SEGFLT	;FAULT HIM
PAGACV:	MOV #100000+.NXMTF,PFAULT(A)	;NON EXISTANT MEMORY FAULT
	BR SEGFLT
	.SBTTL EMT HANDLERS
;GET HERE WHEN A USER EXECUTES AN EMT
EMTBRK:	CMPB #60,PS+1	;MAKE SURE IT CAM FROM USER MODE
	BUGC EQ
	MOV PC,USRMOD	;NOW WE AREIN THE SYSTEM!
	JSR F,SPCPSP	;SAVE THE USER'S PC, PS AND PDL POINTER
	CLR PUPDLO(A)	;NOTHING POPED YET
	SUB #2,PUPC(A)	;POINT TO THE CALL ITSELF
	MFPI @PUPC(A)	;GET THE ACTUAL CALL
	REST B		;POP IT OFF THE STACK
	ASL B		;CONVERT IT TO A WORD INDEX
	BIC #177001,B	;8 BITS ARE SIGNIFICANT
	BIC #PFALTB,PFLAGS(A)	;SET THE TEMPORARY FAULT BIT 
	BIT #400,B	;IS THE FAULT ON FAIL BIT SET?
	BEQ .+10	;NO
	BIS #PFALTB,PFLAGS(A)	;SET THE TEMPORARY FAULT BIT 
	BIC #400,B	;CLEAR THE TOP BIT
	CMP #EMTHGH*2,B	;IS IT TOO HIGH?
	BLOS BADEMT	;YUP, TELL HIM HE IS A LOSER
	SAVE PS		;NOTE THAT TRACE TRAPS WILL ACT STRANGELY HERE
	BIC #357,(P)	;PRIORITY 0
	SAVE EMTDIS(B)	;DISPATCH ADDRESS
	RTT
BADEMT:	MOV ITM0A,A	;POINT TO THE PROCESS
	MOV #100000+.EMTTF,PFAULT(A)	;CAPABILITY FAULT
	JMP CFAULT

;RETURN FROM EMT TO USER
ENOOP:
EMTRET:	SAVE PS		;FOR THE CONDITION CODES
EMTRTP:	MOV ITM0A,A	;PROCESS HAD BETTER BE THERE
EMTRE1:
;THIS IS TEMPORARY INSTRUCTION
	JSR PC,LSWCLR
	TST PLCKSL(A)	;DOES HE HAVE ANY SWITCHES LOCKED?
	BUGC EQ		;NOPE
EMTRE2:
.IRPC X,<012>
	TST ITM'X'D
	BUGC EQ		;HAD ITEMS PUSHED
.ENDM
	BIT #4,(P)	;HAS THE CALL FAILED?
	BEQ EMTRE4	;BR IF NOT
	CLR PUPDLO(A)	;NOTHING GETS POPPED
	BIT #PFALTB!PFAILB,PFLAGS(A)	;SHOULD HE BE FAULTED
	BNE BADEMT	;YES, IT IS A BADEMT
EMTRE4:	BIC #PFALTB,PFLAGS(A)	;CERTAINLY NO LONGER A $ EMT
	CLR PSPC(A)	;NOT IN THE SYS ANYMORE
	MOVB PUPS+1(A),1(P)	;GO BACK TO USER MODE PROPERLY
	BIT #20,PUPS(A)	;RESTORE TRAP BIT IF WAS SET
	BEQ .+6
	BIS #20,(P)	;SET THE TRAP BIT
	SAVE PUP(A)	;GET HIS OLD P ONTO MY STACK
	ADD PUPDLO(A),(P)	;ANYTHING POPED FROM IT?
	MTPI P		;RESTORE P FOR HIM
	SAVE PUPC(A)	;PUT THE PC ON THE STACK NOW
	ADD #2,(P)	;START HIM AFTER THE CALL
	MOV A,B		;THE ITEM ADDRESS
	JSR PC,PACRES	;RESTORE HIS AC'S
EMTRE3:	SPL CLKL	;PREVENT A SCHEDULE
	CLR USRMOD	;THIS COULD CAUSE ONE
	TST QUANT	;HAS HE OVERSTAYED HIS WELCOME?
	BGE .+10	;NO
	BIS #CLKPIR,PIRQ	;GET HIM AFTER THE RTI
	RTI		;GO TO USER MODE
;PROCESS HACKING EMTS
;.FORK:
;1 ARGUMENT IS ADDRESS OF PLACE TO START NEW PROCESS
;CLEARS Z IF IT SUCEEDS IN CREATING A NEW PROCESS
EFORK:	MFPD @PUP(A)	;GET THE PLACE TO START IT
	MOV #2,PUPDLO(A)	;INDICATE THAT AN ARG SHOULD BE POPED
	JSR PC,CRPROC	;ATTEMPT TO CREATE A PROCESS
	BEQ EFORK1	;FAIL
	MOV CURSPH,B	;PUT IT INTO THE CURRENT PROCESS
	JSR PC,PUTPRS
	JSR PC,ITM0PL	;LOAD IT TEMPORARILLY
	DEC PRSREF(A)	;IT IS ONE TO LARGE (SHOULD BE ONLY ONE)
	BUGC GT
	REST PUPC(A)	;SET ITS PC
	BIC #PSUPSB,PSTOP(A)	;CLEAR THE STOP BIT
	JSR PC,PSTPDC	;GO START IT
	ADD #PUREGS,A	;MAKE A POINT TO THE OLD REGISTERS
	BIS #4000,PS
	SAVE <F,E,D,C,B,A>
	BIC #4000,PS
	MOV #6,E	;THE NUMBER TO COPY
	REST (A)+
	SOB E,.-2
	JSR PC,ITM0PO	;POP ITEM STACK
ERETCZ:	CCC		;SUCESS
EFORK1:	JMP EMTRET

;.POOFF:
;NO ARGUMENT. MAKE THE PROCESS EXECUTING ITDISAPPEAR WITHOUT A TRACE
;CURRENTLY, THE PROCESS IS ONLY STOPPED
;IF THERE ARE ANY REFERENCES TO ITREMAINING
EPOOFF:	MOV ITEM0,B	;THE PROCESS ITEM
	JSR PC,SPRINC	;INCREMENT THE REFERENCE COUNT (SO IT DOESN'T DISAPPEAR
			;IN REMPRS)
	MOV ITM0A,A	;THE FOLLOWING IS ONLY DONE TO KEEP THINGS CONSISTENT
	JSR PC,PACSAV
	JSR PC,TIMEUS
	JSR PC,SAVAWB
	JSR PC,PDLSAV
	MOV ITM0A,A	;PROCESS POINTER
	JSR PC,REMPRS	;REMOVE IT FROM THE SPHERE IT IS IN
	MOV PRUNNG,A
	JSR PC,PSTPIN	;INCREMENT THE STOP COUNT
	JSR PC,DLPROC	;DECREMENT REFERENCE COUTN AND DELETE IF ZERO
	RTS PC		;HOPEFULLY, RETURN TO SCHEDULER
;.INVOKE:
;1 ARG IS CAPABILITY NUMBER TO INVOKE AND MAYBE FLAGS
;MORE ARGS MAY BE TAKEN IF CAPABILTY WANTS THEM
;BUT THERE MUST ALWAYS BE 3 THINGS ON THE STACK AND 3 THINGS WILL BE POPPED
EINVOK:	SUB #6,P	;CREATE 3 WORDS OF TEMP STORAGE FOR ARG
	JSR PC,RETNSW	;GET THE TOP OF THE STACK
	MOV A,(P)	;LOTS OF PEOPLE WILL WANT IT
	JSR PC,RETNSW	;GET 2ND ARG
	MOV A,2(P)	;SAVE IT
	JSR PC,RETNSW	;GET 3RD ARG
	MOV A,4(P)	;SAVE LAST ARG
	MOV ITM1A,A	;GET ADDRESS OF SPHERE
	MOV (P),B	;THE CAP NUMBER
	BIC #177400,B	;CLEAR WHATEVER IS THERE
	MOV B,E		;TO SAVE IT FOR LATER ROUTINES
	JSR PC,GCLSTA	;SEE IF IT IS THERE
	BEQ EIVOK1	;LOSER
	ADD B,A		;GET A REAL ADDRESS FOR CAP
	MOV (A),B	;THE FIRST WORD OF CAP
	BEQ EIVOK1	;NOTHING THERE
	CMP B,#-1
	BEQ EIVOK1
	ASL B		;TO A WORD ADDR
	BIC #177001,B	;FLUSH EXTRA BITS
	CMP B,#CAPHGH*2
	BUGC LT		;IF THE CAPABLITY IS TOO BIG
	MOVB 1(P),C	;THE FUNCTION
	BITB #200,C	;IS IT A GENERAL REQUEST
	BNE .+6
	JMP @IVKCTB(B)	;GO TO THE RIGHT ROUTINE
	ASL C		;TURN IT INTO A WORD INDEX
	BIC #177400,C	;CLEAR THE TOP BYTE
	CMP C,#GENHGH
	BLT EIVOK2	;TOO HIGH OF A FUNCTION
	ADD #6,P	;CLEAN UP STACK
	JMP BADEMT
EIVOK2:	JMP @GENDIS(C)	;GO TO THE GENERAL FUNCTION ROUTINE
EIVOK1:	ADD #6,P	;POP OFF THE THREE ARGS
ERETSZ:	CCC
	SEZ
	JMP EMTRET

DELCAP:	MOV CURSPH,C	;THE CURRENT SPHERE MUST BE PCLOSERED
;Z	JSR PC,SPRSTP	;STOP IT
;Z	MOV CURSPH,A	;AND AGAIN
;Z	JSR PC,SPRSTR	;AND START IT UP
	ADD #6,P	;POP OFF ALL THE ARGUMENTS
	JSR PC,@DELTAB(B)	;DELETE ROUTINE FOR THIS CAPABILITY
	JMP EMTRET	;RETURN WHATEVER FLAGS SET
CPYCAP:	MOV A,F
	MOV B,C		;FOR ROUTINES LATER
	TST (P)+	;ONLY WANT TWO ARGS
	ADD #CPYTAB,C
	JMP CPYCA1
GIVCAP:	TST (P)+	;FIRST ARG NO LONGER NEEDED
	MOV (A),C	;TYPE AND FLAGS OF CAP TO USE WHEN GIVING AWAY
	CMPB C,#.MSCAP	;IS IT A MASTER SPHERE CAPABILITY
	BEQ GVCAP1	;YES
	CMPB C,#.SPCAP	;IS IT SPHERE CAP.
	BEQ GVCAP1	;YEP
GVCAP2:	ADD #4,P	;POP OFF GARBAGE
	JMP BADEMT
GVCAP1:	BIT #.SPCAD,C	;DOES HE HAVE APPEND ACCESS
	BEQ GVCAP2	;NOPE, HE LOSES
	MOV (P),B	;THE SECOND ARG SPECIFIES WHAT TO GIVE AWAY
	BIC #177400,B	;GET THE GOOD BITS
	MOV B,E		;TO SAVE IT FOR LATER
	MOV A,C		;SAVE POINTER TO SPHERE OR MS CAP
	MOV ITM1A,A	;FIND IT IN THIS SPHERE
	JSR PC,GCLSTA	;FIND THE CAP.
	BEQ GIVLOS	;CAN'T FIND IT
	ADD A,B		;MAKE B POINT TO THE CAPABILITY
	MOV B,D		;FOR LATER DELETION
	MOV (B),F	;GET THE TYPE AND FLAGS
	BEQ GIVLOS	;THERE ISN'T A CAPABILITY THERE
	CMP #-1,F
	BEQ GIVLOS
	ASL F		;CHANGE IT TO A WORD INDEX
	BIC #177001,F	;CLEAR EXTRA BITS
	MOV 2(C),C	;GET THE SPHERE NO. THAT WE ARE GIVING TO
	JSR PC,SPRSTP	;STOP IT
	MOV C,B		;FOR THE LOCK ROUTINES
	MOV #LCKRTN,A	;RUN A ROUTINE IF UNLOCKED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCSPST,LCKWD1(A)	;START PROCESSES IF UNLOCKED
	MOV #-1,B	;BECAUSE LCKASW DOES A BIT
	MOV #SCLSLK,A	;C-LIST LOCK
	JSR PC,LCKASW	;LOCK AN ITEM'S SWITCH
	MOV C,A		;GET BACK THE SPHERE
	JSR PC,ITM2PL	;LOAD IT UP
	MOV PRUNNG,SCLSLK(A)	;PUT MY PROCESS NUMBER THERE
	JSR PC,ITM2PO	;POP IT AGAIN
	MOV 2(P),B	;WHERE TO PUT IT
	JSR PC,CRCLST	;CREATE A C-LIST ENTRY IN HIS C-LIST
	BCS GVCAP2	;C-LIST FULL
	BEQ GIVLOS	;DESTINATION OCCUPIED
	SAVE <C,B,A>
	MOV ITEM1,C	;THIS SPHERE
	JSR PC,SPRSTP	;STOP IT (EXCEPT FOR ME)
	MOV C,B		;THE ITEM FOR THE LOCKSW ROUTINES
	MOV #LCKRTN,A	;RUN A ROUTINE WHEN UNLOCKED
	JSR PC,LOCKSW	;LOCK THE SWITCH
	MOV #PCSPST,LCKWD1(A)	;START THE PROCESSES WHEN UNLOCKED
	MOV ITEM0,LCKWD2(A)	;START ALL THE PROCESSES, EXCEPT ME
	REST <A,B,C>
	JMP @GIVTAB(F)	;DISPATCH ON TYPE
GIVLOS:	ADD #4,P
	JMP ERETSZ

;THIS ROUTINE CALLS THE APPROPRIATE ROUTINE WITH INFO AS FOLLOWS
;A- POINTER TO CAP DEST.,C- SPHERE OF TAKEE, D-OFFSET OF TAKEE CAP.
;B-C LIST NO. OF DESTINATION,E-C LIST NO. OF TAKEE,F-DISPATCH TYPE
TAKCAP:	TST (P)+	;FIRST ARGUMENT NO LONGER NEEDED
	MOV (A),C	;TYPE AND FLAGS OF CAP. TO USE WHEN TAKING AWAY
	CMPB C,#.MSCAP	;MASTER SPHERE CAP.
	BEQ TKCAP1	;YES
	CMPB C,#.SPCAP	;SPHERE CAP.?
	BEQ TKCAP1	;YES
TKCAP2:	ADD #4,P	;POP OFF ARGS
	JMP BADEMT
TKCAP1:	BIT #.SPCLD,C	;CAN WE DELETE FROM THIS C-LIST
	BEQ TKCAP2	;NO!
	MOV (P),B	;WHAT WE ARE SUPPOSED TO TAKE AWAY
	BIC #177400,B	;GET THE GOOD BITS
	MOV B,E		;THE C-LIST NO. OF TAKEE
	MOV 2(A),A	;THE SPHERE NO. OF TAKEE
	MOV A,C		;SAVE IT FOR LATER
	JSR PC,ITM2PL	;LOAD IT UP
	JSR PC,GCLSTA	;DOES THE CAP EXIST
	BEQ TAKLOS	;NOPE
	MOV B,D		;OFFSET OF TAKEE
	ADD A,B		;MAKE B POINT TO IT
	MOV (B),F	;CAPABILITY TYPE AND FLAGS
	BEQ TAKLOS	;DOESN'T EXIST
	CMP #-1,F
	BEQ TAKLOS
	JSR PC,ITM2PO	;DONE FOR NOW WITH THIS
	ASL F		;TURN TYPE INTO WORD INDEX
	BIC #177001,F	;CLEAR EXTRA BITS
	JSR PC,SPRSTP	;STOP THE SPHERE OF TAKEE
	MOV C,B		;FOR THE LOCK ROUTINE
	MOV #LCKRTN,A	;RUN A ROUTINE WHEN UNLOCKED
	JSR PC,LOCKSW	;GET A LOCK
	MOV #PCSPST,LCKWD1(A)	;START THE SPHERE WHEN UNLOCKED
	MOV #-1,B	;BECAUSE LCKASW DOES A BIT
	MOV #SCLSLK,A	;LOCK THE SPHERES C-LIST
	JSR PC,LCKASW	;LOCK AN ITEM'S SWITCH
	MOV C,A		;GET THE SPHERE NO
	JSR PC,ITM2PL	;LOAD IT BACK UP
	MOV PRUNNG,SCLSLK(A)	;PUT MY ITEM NO. THERE
	JSR PC,ITM2PO	;POP IT AGAIN
	MOV 2(P),B	;THE DESTINATION IN TAKER
	SAVE C		;SAVE SPHERE OF TAKEE
	MOV ITEM1,C	;CREATE THE C-LIST ENTRY IN THIS SPHERE
	JSR PC,CRCLST	;CREATE AN ENTRY
	BCS TKCAP4	;C-LIST FULL
	BEQ TKCAP3	;C-LIST DESTINATION OCCUPIED
	ADD ITM1A,A	;MAKE A POINT ABSOLUTELY
	REST C		;SPHERE OF TAKEE
	JMP @TAKTAB(F)
TAKLOS:	JSR PC,ITM2PO
	BR TKCAP2
TKCAP3:	JMP EIVOK1
TKCAP4:	ADD #6,P
	JMP BADEMT

;.SINK
;DISABLES FLOATING POINT FOR THIS PROCEEDURE
;ALWAYS SUCCEEDS
ESINK:	MOV #PRSLNF,A		;SIZE OF A PROCESS WITHOUT FLOATING POINT AC'S
	MOV ITEM0,B		;THE ITEM INDEX OF THE PROCESS
	JSR PC,EXITEM		;SHRINK THE PROCESS IF NECESSARY
	MOV ITM0A,A		;THE ADDRESS OF THE ITEM
	BIC #PFPFLG,PFLAGS(A)	;CLEAR THE FLOATING  POINT FLAG IN PROCESS
	CLZ			;ALWAYS SUCCEEDS
	JMP EMTRET

;.FLOAT
;ENABLES FLOATING POINT FOR THIS PROCEDURE
EFLOAT:	MOV ITM0A,A
	BIT #PFPFLG,PFLAGS(A)
	BNE EFLOT2
	MOV #PRSLFP,A		;SIZE OF PROCESS WITH FLOATING POINT
	MOV ITEM0,B		;THE ITEM INDEX OF THE PROCESS
	JSR PC,EXITEM		;EXPAND THE PROCESS TO INCLUDE SPACE FOR FLOATING POINT AC'S
	BNE EFLOT1		;IT FAILED
	JMP EMTRET
EFLOT1:	MOV B,A
	JSR PC,ITM0LD		;LOAD THE NEW PROCESS
	MOV #40300,PFPPS(A)	;START HIM WITH INT. DISABLED AND IN DOUBLE AND LONG MODE
	BIS #PFPFLG,PFLAGS(A)
EFLOT2:	CLZ 
	JMP EMTRET

;MAKE THE PROCESS EXECUTING THIS CALL, A USER, AND GIVE THE PROCESS TO THAT USER
;TAKES 3 ARGS, IF FIRST IS NON ZERO, PUT THE NAME OF THE USER INTO THE CURUSR
;LENGTH OF NAME IS SECOND ARG
;POINTER TO NAME IS THIRD
ECRUSR:	CMP CURSPH,SYSSPR	;IS THIS THE SYSTEM SPHERE
	BEQ .+6			;NO, FAIL
ECRUS1:	JMP ERETSZ
	JSR PC,RETNSW		;GET THE SWITCH
	TST A
	BNE ECRUS2		;SET IN THE NAME
	JSR PC,CRUSER		;CREATE A USER
	BEQ ECRUS1		;FAILED
	MOV ITM0A,F		;GET ADDRESS OF THE PROCESS
	MOV PUP(F),E		;POINTER TO TOP OF PDL
	SAVE #-1		;PUSH A -1 ONTO USERS STACK
	MTPD (E)		;PUT THE WORD BACK
	MOV PPRTPT(F),F		;THE PROCESS TABLE POINTER
	MOV B,PRTUPT(F)		;SAY THE NEW USER IS THIS USER
	MOV B,CURUSR		;SAY IT TO EVERYONE
ECRUS2:	MOV CURUSR,B		;GET THE PROCESS TABLE ENTRY FOR USER
	MOV PRTPPT(B),A		;ITEM NO. OF THE USER
	JSR PC,ITM2LD		;LOAD IT UP
	JSR PC,RETNSW		;GET THE NAME
	MOV A,F			;SAVE COUNT
	BLE ECRUS1		;FAIL
	CMP F,#10.		;IS IT MORE THAN 10 CHARACTERS
	BLE .+6			;NO
	MOV #10.,F		;ONLY SAVE 10 CHARACTERS
	JSR PC,RETNSW		;GET POINTER TO NAME
	BIT #1,A		;DOES IT LAY ON BYTE BOUNDARY
	BNE ECRUS1		;YES, FAIL
	MOV F,E			;COPY COUNT
	ASR E			;GET WORD COUNT
	ADC E			;GET AN EXTRA WORD IF BYTE COUNT IS ODD
	MOV E,D			;SAVE IT
	MOV P,C			;SAVE POINTER TO P
	MFPD (A)+
	SOB E,.-2		;GET THE ENTIRE NAME
	BIT #1,F		;IS THERE ANOTHER BYTE
	BEQ .+6			;NO
	CLRB 1(P)		;CLEAR THE SPURIOUS BYTE
	MOV ITM2A,B		;POINTER TO USER ITEM
	ADD #USRNAM,B		;POINT TO THE FIRST BYTE OF NAME
	MOV C,E			;POINTER TO THE BYTES ON PDL
	MOV -(E),(B)+		;SET IN THE NAME
	SOB D,.-2		;GET ENTIRE NAME
	MOV C,P			;RESET PDL POINTER
	JMP ERETCZ		;SUCESS
;.TTGIV
;GIVE TTY AWAY, THE FIRST ARGUMENT IS A MASTER SPHERE CAPABILITY
;THE SECOND IS A TELETYPECAPABILITY
ETTGIV:	JSR PC,RETNSW	;GET THE FIRST ARG
	MOV A,B		;THE MASTER SPHERE CAPABILITY
	BIC #177400,B	;CLEAR THE TOP BYTE
	MOV ITM1A,A	;THE ADDRESS OF THE SPHERE IN THE MAP
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ TTGIV1	;COULDN'T GET IT
	ADD B,A		;MAKE A POINT TO THE SPHERE CAP
	MOV (A),C	;THE TYPE AND FLAGS
	BEQ TTGIV1	;DOESN'T EXIST
	CMPB C,#.MSCAP	;IS IT A MASTER SPHERE CAP.
	BNE TTGIV1	;NOPE, CAN'T DO IT
	MOV 2(A),D	;THE SPHERE TO GIVE IT TO
	JSR PC,RETNSW	;GET THE SECOND ARG
	MOV A,B		;THE ARGUMENT
	BIC #177400,B	;CLEAR THE TOP BYTE
	MOV ITM1A,A
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ TTGIV1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE TTY CAP
	MOV (A),C	;TYPE AND FLAGS
	BEQ TTGIV1	;DOESN'T EXIST
	CMPB C,#.TTCAP	;IS IT A TTY CAPABILITY
	BNE TTGIV1	;NOPE
	MOV 2(A),A	;THE MASTER TTY ITEM NO.
	JSR PC,ITM2LD	;LOAD IT UP
	MOV ITM1A,B	;POINTER TO THE CURRENT SPHERE
	MOV CURSPH,C	;THE CURRETN SPHERE
TTGIV2:	CMP C,TTITM(A)	;IS THIS SPHERE THE OWNER OF THE TTY
	BEQ TTGIV4	;YES
TTGIV3:	JSR PC,LFLUSH	;WAIT FOR IT
	CMP C,TTITM(A)	;DO I OWN IT NOW?
	BNE TTGIV3	;NO
	JSR PC,RUNME	;TRY TO GET IT
	BR TTGIV2	;MAKE SURE
TTGIV4:	MOV TTYST1(A),STTFG1(B)	;STORE THE CURRENT TTY STATUS
	MOV TTYST2(A),STTFG2(B)	;STORE THE EXTRA STATUS WORD
	MOV D,SIFTTY(B)	;NEW INFERIOR SPHERE
	MOV D,A		;THE SPHERE WE ARE GIVING IT TO
	JSR PC,ITM1PL	;BOGUS PUSH
	MOV D,A
TTGIV5:	JSR PC,ITM1LD	;LOAD UP THE INFERIOR SPHERE
	MOV SIFTTY(A),A	;GET THE SPHERE IT GAVE THE TTY TO
	BNE TTGIV5	;HE GAVE IT AWAY
	MOV ITM2A,B	;POINTER TO THE TTY ITEM
	MOV ITM1A,A	;POINTER TO THE SPHER
	MOV CURUSR,TTYU(B)	;FIX USER POINTER
	MOV STTFG1(A),TTYST1(B)	;SET UP HIS STATUS
	MOV STTFG2(A),TTYST2(B)	;SET UP HIS OTHER STATUS WORD
	MOV ITEM1,TTITM(B)	;SET IN THE NEW OWNER
	JSR PC,ITM1PO	;GET RID OF HIM
	MOV CURSPH,A
	JSR PC,SPRPCL	;PCLOSER EVERY (EXCEPT ME)
	MOV ITM0A,A	;POINT TO ME
	BIC #PPCLSR,PFLAGS(A)	;CLEAR THE PCLOSER BIT
	JMP ERETCZ	;SUCCESS
TTGIV1:	JMP ERETSZ

;.TTGET
;GET THE TTY, THE ARGUMENT IS A TTY CAPABILITY
;HANGS UNTIL IT CAN GET THE TTY
ETTGET:	JSR PC,RETNSW	;GET THE CAPABILITY NO. OF A TTY CAP.
	MOV A,B		;GET THE TTY NO.
	BIC #177400,B	;CLEAR THE EXTRA BITS
TTGET1:	MOV ITM1A,A
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ TTGIV1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE CAPABILITY
	CMPB (A),#.TTCAP	;IS IT A TTY CAP
	BNE TTGIV1	;NO, HE IS A LOSER
	MOV 2(A),E	;GET THE TTY ITEM NO.
	MOV CURSPH,C	;THE CURRENT SPHERE
TTGET2:	MOV E,A		;THE TTY NUMBER
	JSR PC,ITM1PL	;LOAD THE TTY ITEM
	MOV TTITM(A),D	;THE CURRENT OWNER OF THE TTY
	MOV D,A
	CMP C,A		;DO I ALREADY OWN IT
	BEQ TTGET5	;YES, SUCCEED
TTGET3:	JSR PC,ITM1LD	;LOAD THE ITEM
	MOV SMSSPT(A),A	;THE MASTER OF THIS SPHERE
	CMP A,C		;IS ITS SUPERIOR THE REQUESTOR
	BEQ TTGET4	;SUCESS
	CMP SYSSPR,A	;ARE WE AT THE ROOT OF THE SPHERE STRUCTURE
	BNE TTGET3	;LINK THROUGH TO THE NEXT SPHERE
	JSR PC,ITM1PO	;CLEAN UP THE STACK
	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	BR TTGET2	;TRY AGAIN
TTGET4:	MOV E,A		;THE TTY ITEM
	JSR PC,ITM2LD	;LOAD IT UP
	MOV A,B		;POINTER TO THE TTY ITEM
	MOV D,A		;THE SPHERE THAT CURRENTLY OWNS IT
	JSR PC,ITM1LD	;LOAD THE OWNER OF THE TTY
	MOV TTYST1(B),STTFG1(A)	;STORE THE FLAGS
	MOV TTYST2(B),STTFG2(A)	;STORE THE OTHER FLAGS
	MOV CURUSR,TTYU(B)	;SET THE USER
	MOV CURSPH,A	;THE NEW OWNER OF THE TTY
	MOV A,TTITM(B)	;NOW EVERYONE KNOWS
	JSR PC,ITM1LD	;LOAD THE NEW OWNER
	MOV STTFG1(A),TTYST1(B)	;SET IN THE OLD FLAGS
	MOV STTFG2(A),TTYST2(B)	;SET UP OTHER OLD FLAGS
	MOV D,A		;THE OLD OWNER
	JSR PC,SPRPCL	;AND HE GETS PCLOSERED
TTGET5:	JSR PC,ITM1PO	;THIS WAS PUSHED SOMEWHERE
	MOV ITM1A,A	;POINT TO THE SPHERE
	CLR SIFTTY(A)	;NO INFERIOR NOW
	JMP ERETCZ
;.SLEEP:
;1 ARG IS TOP 2 WORDS ON STACK (LOW ORDER IS TOP WORD)
;NEGATIVE=>NEGATIVE OF SYSTEM TIME TO CONTINUE
;POSITIVE=>NUMBER OF 60THS TO SLEEP
ESLEEP:	MOV PUP(A),B	;GET HIS PDL POINTER
	MFPD (B)	;GET TOP WORD
	MOV (P),C	;SAVE IT IN C
	MTPD (B)+	;MAKE SURE WE CAN WRITE IT
	MFPD (B)	;GET HIGH ORDER WORD
	MOV (P),D	;SAVE IT IN D
	MTPD (B)	;MAKE SURE WE CAN WRITE IT
	MOV #4,PUPDLO(A)	;POP 2 THINGS IF SUCESSFUL
	TST D		;IS IT NEGATIVE?
	BLT ESLEE1	;YES, GO SEE IF IT'S TIME YET
	NEG C		;NEGATE DOUBLE WORD NUMBER
	ADC D
	NEG D
	SUB TIME,C	;NOW COMPUTE NEGATIVE TIME TO WAKE UP
	SBC D
	SUB TIME+2,D
	SAVE D		;NOW CLOBBER USER'S THING TO NEGATTIVE
	MTPD (B)	;CLOBBER HIGH ORDER
	SAVE C
	MTPD -(B)
ESLEE1:	JSR PC,ESLEEC	;CHECK IF TIME IS UP
	BLT ESLEE4	;NOPE SLEEP SOME MORE
	JMP ERETCZ	;TIME IS UP, GO AWAY
ESLEE4:	CMP #-1,B	;IS IT A LONGE TIME TO WAIT?
	BNE ESLEE2	;YES, MORE THAN 2**16 TICKS
	CMP #-LTIMEL*4,A	;WELL, IS IT LONG?
	BGT ESLEE2	;YUP, MORE THAN 4 LONG WAITS
	JSR PC,SFLUSH	;NOT LONG
	BR ESLEE3	;NOW TRY AGAIN
ESLEE2:	JSR PC,LFLUSH	;LONG TIME TO WAIT
ESLEE3:	JSR PC,ESLEEC	;WELL, TIME UP NOW?
	BLT ESLEE4	;NOPE
	JSR PC,RUNME	;ALL DONE
	JMP ERETCZ	;GO RETURN TO USER
ESLEEC:	MOV C,A		;COPY TIME TO WAKE UP
	MOV D,B
	ADD TIME,A
	ADC B
	ADD TIME+2,B
	RTS PC

;RETURN THE SYSTEM STATUS BLOCK TO THE GUY AT THE PLACE HE PASES TO US
ESSTAT:	JSR PC,RETNSW	;GET THE ONE ARGUMENT
	MOV #SSTATS,B	;POINTER TO THE BLOCK WE GIVE HIM
	MOV #NSTATS,C	;AMOUNT OF STUFF TO GIVE HIM
ESSTA1:	MFPD (A)	;YEAH DEC!
	MOV (B)+,(P)	;WHAT I REALLY WANT TO DO
	MTPD (A)+	;IS GIVE IT TO HIM
	SOB C,ESSTA1
	JMP ERETCZ
;.QUNLK
;THE FIRST ARG IS THE CAPABILITY NO. OF THE QUE CAP
EQUNLK:	JSR PC,RETNSW	;GET THE FIRST ARG
	MOV A,B		;GET THE CAP. NO
	BIC #177400,B	;CLEAR THE SILLY BITS
	MOV ITM1A,A	;THE ADDRESS OF THE SPHERE
	JSR PC,GCLSTA	;FIND THE CAPABILITY
	BEQ UNLCK1	;COULDN'T FIND IT
	ADD B,A		;MAKE A POINT TO THE CAPABILITY
	CMPB (A),#.QUCAP	;IS IT A QUE CAPABILITY
	BNE UNLCK1	;NO
	MOV 2(A),A	;THE ITEM NO OF THE QUE
	JSR PC,ITM2LD	;LOAD IT UP
	INC QUENUM(A)	;UNLOCK (FEATURE: IF NEVER LOCKED, INCREASES MAX LOCKS)
	JSR PC,QUECHK	;SHORT FLUSH FIRST GUY ON QUQUE
	JMP ERETCZ
UNLCK1:	JMP ERETSZ

QUECHK:	TST QUENUM(A)	;CAN ANYONE WIN?
	BNE .+4		;YES
QUECH1:	RTS PC		;NO
	TST QUECNT(A)	;IS ANYONE WAITING?
	BEQ QUECH1	;NO
	MOV QUEQUE(A),A	;GET THE FIRST GUY WHO CAN WIN
	JSR PC,ITM0PL	;LOAD HIM
	MOV PPRTPT(A),A	;POINT TO HIS PROCESS TABLE ENTRY
	MOV #SFLSQ,B	;SHORT FLUSH HIM
	JSR PC,TQUEUE
	JMP ITM0PO	;POP HIM OFF
;REMOVE THE GUY IN ITEM0 FROM THE QUE POINTED TO BY A
;IF HE HAS IT LOCKED, START SOMEONE ELSE, OTHERWISE JUST
;REMOVE HIM
PCQUNL:	SAVE A
	MOV QUECNT(A),F	;THE NUMBER OF PEOPLE ON THE QUE
	BEQ QUNLK7
	MOV F,A		;COPY THE COUNT
	MOV F,C		;COPY IT AGAIN
	ASL A		;TURN IT INTO A WORD INDEX
	ADD (P),A	;MAKE IT LESS RELATIVE
	ADD #QUEQUE,A	;MAKE A POINT TO THE START OF THE QUE
	MOV ITEM0,B	;THE PERSON TO LOOK FOR
QUNLK1:	CMP -(A),B	;IS HE HERE
	BEQ QUNLK2	;YES
	SOB C,QUNLK1	;TRY THE NEXT QUE ENTRY
QUNLK7:	REST A
	SEZ		;SAY HE WASN'T HERE
	RTS PC
QUNLK2:	SUB F,C		;THE NUMBER OF PEOPLE AFTER HIM
	NEG C		;MAKE THE COUNT POSITIVE
	SAVE C		;SAVE THE COUNT
	BEQ QUNLK4	;NOBODY AFTER HIM ON THE QUE
QUNLK3:	MOV 2(A),(A)+	;MOVE EVERYONE UP ONE SLOT ON THE QUE
	SOB C,QUNLK3
QUNLK4:	REST <C,A>
	DEC QUECNT(A)	;ONE LESS PERSON ON THE QUE
	JSR PC,QUECHK	
QUNLK6:	CLZ
	RTS PC
;.QULK,;THE FIRST ARG IS THE CAPABILITY NO OF THE QUE TO LOCK
EQULK:	JSR PC,RETNSW	;GET THE CAPABILITY NO
	MOV A,B
	BIC #177400,B	;CLEAR THE EXTRA BITS
	MOV ITM1A,A
	JSR PC,GCLSTA	;GET THE CAPABILITY
	BEQ UNLCK1	;FAILED
	ADD B,A		;MAKE A POINT TO THE CAP
	CMPB (A),#.QUCAP	;IS IT A QUE
	BNE UNLCK1	;NO
	MOV 2(A),A	;THE ITEM NO OF THE QUE
	JSR PC,ITM2LD	;LOAD IT
QULK5:	MOV QUECNT(A),C	;THE NUMBER OF PEOPLE ON THE QUE
	CMP C,QUEENO(A)	;IS THERE ROOM FOR ONE MORE
	BEQ QULK4	;NO, ENLARGE THE QUE
	INC QUECNT(A)	;ONE MORE PERSON ON THE QUE
	ASL C		;CHANGE IT INTO A WORD INDEX
	ADD A,C		;MAKE C POINT TO THE QUE ENTRY (ALMOST)
	MOV PRUNNG,QUEQUE(C)	;PUT HIM ON THE QUE
	MOV ITEM2,B	;THE Q ITEM
	MOV #LPCLRT,A	;RUN IF PCLOSERED
	JSR PC,LOCKSW	;LOCK IT
	MOV #PCQUNL,LCKWD1(A)	;FLUSH HIM FROM Q IF PCLOSERED
QULK9:	MOV ITM2A,A
	TST QUENUM(A)	;CAN I LOCK IT?
	BEQ QULK1	;NO, FULL
	CMP PRUNNG,QUEQUE(A)	;AM I FIRST?
	BNE QULK3	;NO, SOMEONE ELSE BEFORE ME
	DEC QUENUM(A)	;LOCK
	DEC QUECNT(A)	;ONE LESS WAITING
	BEQ QULK2	;NO ONE WAITING NOW
	MOV QUECNT(A),B
	MOV A,C
	ADD #QUEQUE,C
	MOV 2(C),(C)+	;COPY ME OUT OF WAITING LIST
	SOB B,.-4
QULK2:	JSR PC,LSWPOP	;FLUSH THE SWITCH
	JSR PC,QUECHK	;START ANYONE ELSE
	JMP ERETCZ
QULK3:	JSR PC,QUECHK
	MOV ITM2A,A
QULK1:	JSR PC,LFLUSH	;WAIT A LONG TIME
	TST QUENUM(A)	;CAN IT BE LOCKED?
	BEQ QULK1	;NOPE, WAIT
	JSR PC,RUNME	;GIVE IT A TRY
	BR QULK9
	;MAY JUMP TO NEXT PAGE
	;MAY BE JUMPED INTO FROM ABOVE
QULK4:	MOV QUEENO(A),A	;THE NUMBER OF ENTRIES IN THE QUE
	ASH #-6,A	;TURN IT INTO A ITEM SIZE
	INC A		;WE WANT TO MAKE IT ONE SIZE LOARGER
	MOV (P),B	;THE IUTEM NO FOR EXITEM
	JSR PC,EXITEM	;EXPAND THE QUE
	BNE QULK6	;SUCCEEDED
	JMP ERETSZ
QULK6:	ADD #32.,QUEENO(A)	;MADE IT 16. ENTRIES LARGER
	BR QULK5	;GO TRY TO LOCK IT

;.FONT CALL
;FIRST ARG IS FUNCTION,,FONT #
;SECOND ARG IS POINTER INTO USER CORE
;FUNCTION 0=> READ FONT INTO USER
;FUNCTION .PRWRT=> WRITE FONT FROM USER CORE
EFONT:	.IFZ NTVS
	JMP ERETSZ	;THERE HAD BETTER BE TV'S
.IFF
	JSR PC,RETNSW	;GET THE FIRST ARG
	MOV A,B		;SAVE IT
	BIC #177400,A	;GET THE FONT #
	CMP #NFONTS,A
	BGT .+6		;FONT NUMBER OK
	JMP EFNTL1	;BAD FONT NUMBER
	SAVE A		;SAVE THE FONT NUMBER
	JSR PC,RETNSW	;GET SECOND (USER ADDRESS)
	SAVE A
	BIT #.PRWRT*400,B	;WRITE TO USER OR FONT?
	BNE EFONT9	;GO TO WRITE THE FONT
	BIC #177400,B
	ASL B		;MAKE A WORD ADDRESS
	MOV FNTITM(B),A	;GET THE FONT ITEM NUMBER
	JSR PC,ITM2LD
;NOTE THAT IN CASE OF PCLOSERING, WE DO ALL THIS WORK AGAIN,
;BUT AT LEAST NO HARM IS DONE. BESIDES, IF THE FONT IS BEING
;READ INTO ONLY ONE PAGE, IT CAN ONLY LOSE THE FIRST TIME
;OF COURSE, IF THE USER BITES THE BAG, HIS POINTER DOESN'T POINT
;THE FACT OUT TO HIM.
	MOV FNTEND(A),C	;GET THE END POINTER FOR THE FONT
	BLE EFNTL	;CALL FAILS IF FONT NOT THERE
	REST B		;GET BACK THE USER'S ADDRESS
	ASR C		;FOR THE SOB
EFONT8:	MFPD (B)	;LET'S HEAR IT FOR DEC!
	MOV (A)+,(P)	;AND THE WORD JUST KEEP ON COMING!
	MTPD (B)+	;AND GOING
	SOB C,EFONT8	;LOTS OF TIMES
	TST (P)+
	JMP ERETCZ	;WIN


;THIS PART READS IN A FONT FROM USER
EFONT9:	ADD #FNWIDE,A	;SET THE POINTER TO THE WIDTH
	MFPD (A)+	;GET WIDTH
	REST C		;C WILL HOLD IT FOR A WHILE
	CMP #16.,C
	BLT EFNTL	;CAN'T HAVE A WIDTH OVER 16!
	MFPD (A)+	;HOW HIGH?
	REST E		;E WILL KEEP THAT FOR A MINUTE
	CMP #454.,E	;HIGHT OF SCREEN!
	BLT EFNTL	;DON'T BE SILLY
	MFPD (A)+	;END OF FONT (LENGTH IN BYTES)
	REST D		;KEEP IN D
	CMP #20000,D	;IS IT MORE THAN 4K?
	BLT EFNTL	;WELLL.....
	MFPD (A)+	;THE NUMBER OF TV LINES IN A CHAR LINE
	REST F
	CMP F,E		;THIS HAD BETTER BE GREATER OR EQUAL TO HEIGHT
	BLT EFNTL	;OTHERWISE CHARS WON'T FIT IN A LINE
	CMP F,#454.	;IT HAD ALSO BETTER BE LESS THAN OR EQUAL TO SCREEN SIZE
	BGT EFNTL	;STRANGE CHARACTERS..
	MOV D,F		;COPY THE BYTE COUNT OF THE FONT
	ASR F		;FOR THE SOB
	MOV (P),B	;GET BACK USER POINTER
EFONT1:	MFPD (B)+	;THIS LOOP PREVENTS US FROM
	TST (P)+	;GETTING SCREWED
	SOB F,EFONT1	;BY A PAGE NOT BEING IN CORE WHEN WE WANT IT
	MOV (P),B	;NOW WE WILL CHECK THE LEGALITY OF THE POINTERS
	ADD #FNTPNT,B	;POINT TO THE POINTER TABLE
	MOV #128.,F	;FOR THE SOB
EFONT2:	MFPD (B)+	;GET A POINTER
	TST (P)		;ZERO MEANS NO CHARATCER
	BEQ EFONT3	;WHICH IS FINE
	CMP #<FNTPNT+256.>,(P)	;DEFS START AFTER TABLE
	BGT EFNTL0	;UGH
	CMP D,(P)	;AND END AT (D)
	BLT EFNTL0
EFONT3:	TST (P)+	;YOU'RE OK, POINTER
	SOB F,EFONT2	;CHECK ALL 128. OF THEM
	MOV D,A		;LENGTH IN BYTES OF THE TABLE
	ASH #-6,A	;NUMBER OF BLOCKS FOR CRITEM
	JSR PC,CRITEM	;CREATE AN ITEM OF THE SIZE IN A
	BEQ EFNTL	;CAN'T CREATE AN ITEM
	MOV B,A		;CRITEM RETURNS THE INDEX IN B
	JSR PC,ITM2LD	;LOAD UP THE ITEM WE JUST CREATED
	REST C		;THE USER'S ADDRESS
	ASR D		;CONVERT TO WORD COUNT
EFONT4:	MFPD (C)+	;READ THE USER'S DATA
	REST (A)+	;A IS INITIALLY SET BY THE ITM2LD CALL
	SOB D,EFONT4	;KEEP MOVING UNTIL WE GET ALL OF HIS DATA
	MOV #454.,D	;THE NUMBER OF LINES ON A SCREEN
	CLR C		;FOR THE DIVIDE
	MOV ITM2A,A	;ADDRESS OF THE FONT ITEM
	DIV FNTLCL(A),C	;FIND HOW MANY LINES FIT ON A SCREEN
	CMP D,FNHIGH(A)	;THE LAST LINE DOES NOT NEED SEPARATOR SPACE
	BLT EFON10	;NOT ENOUGH ROOM FOR ANOTHER LINE
	INC C		;WE CAN FIT IN ONE MORE LINE
	SUB FNTLCL(A),D	;GET THE AMOUNT TO ADD TO NEXT LINE TO GET TO TOP
EFON10:	MOV C,FNLINE(A)	;THIS MANY LINES FIT ON A SCREEN
	SAVE C
	MOV D,C		;FOR THE MULTIPLY
	MUL #110,C	;COMPUTE THE NUMBER OF BYTES LEFT OVER AT THE BOTTOM OF SCREEN
	MOV D,FNREM(A)	;THIS NUMBER MAY BE NEGATIVE IF WE SQEEZED IN AN EXTRA LINE
	MOV FNTLCL(A),C	;THE NUMBER OF TV LINES IN ONE CHAR LINE
	MUL #110,C	;COMPUTE THE NUMBER OF BYTES IN ONE CHAR LINE
	MOV D,FLFINC(A)	;THIS IS THE LINE FEED INCREMENT	
	REST D		;THE NUMBER OF LINES ON SCREEN
	CLR C		;FOR THE DIVIDE
	DIV #5,C	;5 SEEMS TO GIVE GOOD RESULTS
	MOV C,FNLSC(A)	;THE NUMBER OF LINES TO SCROLL
	MOV #576.,D	;NUMBER OF BITS ON A LINE
	CLR C		;FOR THE DIVIDE
	DIV FNWIDE(A),C	;DIVIDE BY THE NUMBER OF BITS PER CHAR
	MOV C,FNLINL(A)	;GET THE NUMBER OF CHARS PER LINE
	REST C		;THE FONT NUMBER
	ASL C		;CONVERT TO WORD INDEX
	MOV FNTITM(C),A	;GET THE ITEM INDEX OF THE CURRENT FONT WITH THIS NUM
	MOV B,FNTITM(C)	;NOW THE NEW ITEM IT THIS FONT NUMBER
	TST A		;WAS ANYTHING THERE?
	BEQ EFONT5	;NO
	JSR PC,DLITEM	;DELETE THE OLD FONT
EFONT5:	JMP ERETCZ	;WIN
EFNTL0:	ADD #2,P	;POP SOME STUFF
EFNTL:	ADD #4,P	;POP GARBAGE OFF THE STACK
EFNTL1:	JMP ERETSZ	;LOSE
.ENDC

;THIS SYSTEM CALL ALLOWS CONTROL OF THE VIDEO SWITCH. BASICALLY,
;THE FIRST ARGUMENT SETS THE SOURCE IN VARIOUS MODES, AND THE
;SECOND ARGUMENT SETS THE DESTINATION IN SIMILAR MODES.  FOR
;BOTH SOURCE AND DESTINATION ARGUMENTS, THE GENERAL FORM IS
;A NUMBER IN THE LOW BYTE AND A MODE IN THE HIGH BYTE. THE SOURCE
;USUALLY MEANS THE BUFFER ASSOCIATED WITH THE TV IMPLIED BY THE
;THE MODE AND NUMBER EXCEPT ABSOLUTE GOES DIRECTLY TO THE SWITCH.
;THE MODES ARE:
;.VIABS  =>  JUST PUT THE NUMBER INTO THE APPROPRIATE PART OF SWITCH
;.VILOT  =>  THE NUMBER IS THE LOGICAL NUMBER OF A TTY
;             THE SAME NUMBER THAT IS USED IN THE CREATE INVOK.
;.VILOD  =>  THE NUMBER IS THE LOGICAL NUMBER OF A DISPLAY
;.VICAM  =>  THE NUMBER IS THE INDEX OF A CAPABILITY IN THE CALLER'S
;	      SPHERE, WHICH IS THE TTY OR DISPLAY TO SWITCH IN.
;
;IF THE CALL FAILS, IT IS GENERALLY BECAUSE THE NUMBER IN AN
;ARGUMENT IS INAPPROPRIATE FOR THE MODE, SUCH AS A LOGICAL
;TTY NUMBER THAT IS NOT A TV TTY, OR CAPABILITY THAT IS NOT
;THE APPROPRIATE TYPE ETC.
.IFNZ NTVS
EVIDSW:	JSR PC,RETNSW		;GET THE FIRST ARGUMENT, THE SOURCE
	MOV A,C			;THE VALUE IS RETURNED IN A
	JSR PC,RETNSW		;GET THE SECOND ARG, THE DESTINATION
	MOV A,D			;SAVE VALUE IN D
	SWAB A			;GET DESTINATION MODE IN LOW BYTE
	BIC #177600,D		;ISOLATE THE DESTINATION NUMBER
	CMPB A,#.VICAM		;IS IT CAPABILITY MODE
	BNE EVIDS2		;NO
	MOV D,B			;THE DESTINATION NUMBER IS CAPABILITY INDEX
	MOV ITM1A,A		;ADDRESS OF THE SPHERE ITEM
	JSR PC,GCLSTA		;GET THE OFFSET OF THE CAPABILITY INTO SPHERE
	BEQ EVID15		;ERROR, BAD CAPABILITY NUMBER
	ADD A,B			;CONVERT OFFSET TO ABSOLUTE ADDRESS
	CMPB (B),#.TTCAP	;IS DESTINATION A TTY?
	BNE EVIDS1		;NO
	MOV CLSEPI(B),A		;THE TTY ITEM
	JSR PC,ITM2LD		;LOAD IT UP
	MOV TTLTTY(A),D		;THE LOGICAL TTY NUMBER - WORD OFFSET VERSION
	ASR D			;CONVERT WORD OFFSET VERSION TO NUMBER
	BR EVIDS3		;CONTINUE LIKE LOGICAL TTY NUMBER
EVIDS1:	CMPB (B),#.DSCAP	;IS DESTINATION A DISPLAY?
	BNE EVID15		;NO, BAD CAPABILITY TYPE ERROR
	MOV CLSEM0(B),A		;THE LOGICAL DISPLAY NUMBER - WORD OFFSET
	ASR A			;CONVERT WORD OFFSET VERSION TO NUMBER
	BR EVIDS5		;NOW CONTINUE LIKE LOGICAL DISPLAY NUMBER
EVIDS2:	CMPB A,#.VILOT		;IS MODE LOGICAL TTY NUMBER MODE
	BNE EVIDS4		;NO
EVIDS3:	SUB #NFTV/2,D		;CONVERT TO PHYSICAL TV NUMBER
	BLT EVID15		;ERROR, THIS TTY IS NOT A TV TTY
	CMP D,#NTVS		;MAKE SURE ITS A VALIDE TV NUMBER
	BGE EVID15		;NO, BAD TTY NUMBER ERROR
	ASL D			;GET WORD OFFSET
	MOV TVMAP(D),D		;ARRANGE TO GET THE CORRECT MONITOR
	BR EVIDS7		;NOW PROCESS THE SOURCE ARGUMENT
EVIDS4:	CMPB A,#.VILOD		;IS MODE LOGICAL DISPLAY NUMBER MODE
	BNE EVIDS6		;NO
EVIDS5:	SUB #NFTVDS,D		;GET PHYSICAL TV NUMBER
	BLT EVID15		;BAD DISPLAY TYPE, MUST BE A TK DISPLAY
	CMP D,#NTVS		;MAKE SURE THIS NUMBER IS LEGAL
	BGE EVID15		;ERROR, BAD DISPLAY NUMBER
	ASL D			;GET WORD OFFSET
	MOV TVMAP(D),D		;ARRANGE TO GET RIGHT MONITOR
	BR EVIDS7		;NOW PROCESS THE SOURCE ARGUMENT
EVIDS6:	CMPB A,#.VIABS		;ABSOLUTE MODE?
	BNE EVID15		;NO, THERE ARE NO MORE LEGAL MODES SO ERROR
EVIDS7:	MOV C,A			;GET SOURCE MODE
	SWAB A			;GET MODE IN LOW BYTE
	BIC #177600,C		;ISOLATE THE SOURCE NUMBER
	CMPB A,#.VICAM		;CAPABILITY MODE?
	BNE EVIDS9		;NO
	MOV C,B			;THE CAPABILITY NUMBER
	MOV ITM1A,A		;SPHERE ITEM ADDRESS
	JSR PC,GCLSTA		;GET THE OFFSET INTO THE SPHERE OF CAPABILITY
	BEQ EVID15		;BAD CAPABILITY NUMBER ERROR
	ADD A,B			;GET THE ABSOLUTE ADDRESS OF CAPABILITY
	CMPB (B),#.DSCAP	;IS IT A DISPLAY CAPABILITY?
	BNE EVIDS8		;NO
	MOV CLSEM0(B),C		;GET LOGICAL DISPLAY NUMBER
	ASR C			;CONVERT FROM WORD OFFSET VERSION TO NUMBER
	BR EVID10		;CONTINUE AS LOGICAL DISPLAY NUMBER
EVIDS8:	CMPB (B),#.TTCAP	;IS CAPABILITY A TTY CAP?
	BNE EVID15		;BAD CAPABILITY TYPE ERROR
	MOV CLSEPI(B),A		;GET THE TTY ITEM
	BR EVID12		;GET THE BUFFER ASSOCIATED WITH THIS TTY
EVIDS9:	CMPB A,#.VILOD		;IS SOURCE MODE LOGICAL DISPLAY?
	BNE EVID11		;NO
EVID10:	SUB #NFTVDS,C		;MAKE SURE IT'S A TV DISPLAY
	BLT EVID15		;ERROR, MUST BE A TK DISPLAY
	CMP C,#NTVS		;MAKE SURE IT'S A VALID TV NUMBER
	BGE EVID15		;ERROR, IT'S NOT
	MOV TVDSBF(C),C		;GET THE BUFFER ASSIGNED TO THIS DISPLAY
	BLT EVID15		;NO BUFFER ASSIGNED TO THIS DISPLAY
	BR EVID14		;SWITCH IN THE NUMBERS
EVID11:	CMPB A,#.VILOT		;IS SOURCE LOGICAL TTY NUMBER MODE?
	BNE EVID13		;NO
	CMP C,#NTTYS		;IS THIS A VALID TTY NUMBER?
	BGE EVID15		;NO, ERROR
	TST C			;MAKE ABSOLUTELY SURE
	BLT EVID15		;AHA! IT'S NEGATIVE, THEREFOR ERROR
	ASL C			;CONVERT TO WORD OFFSET
	MOV TTYITM(C),A		;GET THE ITEM FOR THIS TTY
	BLE EVID15		;THIS TTY HAS NO ITEM
EVID12:	JSR PC,ITM2LD		;LOAD IT UP
	MOV TVBUF(A),C		;GET THE BUFFER NUMBER FOR THIS TTY
	BLT EVID15		;ERROR, NO BUFFER ATTACHED TO THIS TTY
	BR EVID14		;GO AHEAD AND SWITCH IN THE ARGUMENTS
EVID13:	CMPB A,#.VIABS		;IS IT ABSOLUTE MODE?
	BNE EVID15		;NO MORE MODES, THUS ERROR
EVID14:	SWAB D			;DESTINATION GOES IN HIGH BYTE
	BIS D,C			;SOURCE IN LOW BYTE
	MOV C,VIDSW		;SWITCH IT
	JMP ERETCZ		;THAT'S ALL FOLKS.
EVID15: JMP ERETSZ		;SOMETHING WENT WRONG
.IFF
EVIDSW:	JMP ERETSZ		;CAN'T SWITCH 'EM IF YOU DON'T HAVE 'EM
.ENDC

	.SBTTL INVOKE CAPABILITY ROUTINES
CAPRXX:	BPT	;THE ZERO CAPABILITY
CAPRCC:	TST (P)+	;ONLY WANT TWO ARGS
	ASL C		;THE CAPABILITY TYPE TO CREATE
	CMP C,#CAPHGH	;IS HE ASKING FOR A NON-EXISTANT TYPE?
	BGE CAPRC1	;LOSER!
	ADD #CCTAB,C
CPYCA1:	MOV E,D	;CAP NUMBER
	MOV 2(P),B	;CAP DESTINATION
	MOV (P)+,(P)	;SECOND ARG
	SAVE <C>	;ADDRESS OF ROUTINE
	MOV ITEM1,C
	JSR PC,CRCLST
	BEQ CAPRC4	;THE C-LIST ENTRY WAS USED
	BCS CAPRC1	;FULL C-LIST
	ADD ITM1A,A	;MAKE A POINT ABSOLUTELY TO ENTRY
	REST <C,E>	;ROUTINE ADDRESS AND SECOND ARG
	SAVE <B,A>
	MOV #-1,(A)+	;SAVE THIS SPACE
	CLR (A)+
	CLR (A)+
	CLR (A)+
	CLR (A)+
	MOV #LPCLRT,A
	MOV ITEM1,B
	JSR PC,LOCKSW
	MOV (P),LCKWD2(A)
	MOV #CAPRC5,LCKWD1(A)
	MOV C,A		;ROUTINE ADDRESS
	CLR C
	JSR PC,@(A)
;THE ROUTINE WE CALL IS EXPECTED TO RETURN:
;IN A THE CAP TYPE AND FLAGS
;IN B THE PRIMARY ITEM 
;THE SECONDARY ITEM IS NEVER RETURNED
;IN C THE FIRST MISC WORD
;THE SECOND MISC WORD IS NEVER RETURNED
;THE ROUTINE SHOULD SET Z IF IT FAILS, OTHERWISE CLEAR IT
	BEQ CAPRC3	;FAILURE
	REST F
	MOV A,(F)+	;THE TYPE AND FLAGS
	MOV B,(F)+	;THE PRIMARY ITEM
	TST (F)+	;NO SECONDARY ITEM
	MOV C,(F)+	;THE 1ST MISC WORD
	REST <B>
	JSR PC,GIVPSW
	JMP ERETCZ	;SUCESS
CAPRC1:	CMP (P)+,(P)+
CAPRC2:	JMP BADEMT
CAPRC3:	CLR @(P)	;FREE CAP SLOT
CAPRC4:	REST <A,B>
	JMP ERETSZ	;FAIL
CAPRC5:	MOV LCKWD2(B),B
	CLR (B)		;RELEASE CAP SPACE
	RTS PC
	.SBTTL START THE WORLD ROUTINE
GO:	RESET
	MOV #PDL,P	;SET UP THE PDL
	MOV #RUGVEC,A	;POINTER TO VECTOR STORAGE
	MOV #BPTBRV,B	;THE VECOTR
	MOV (B),(A)+	;THE STUFF
	MOV #BPTBRK,(B)+	;SET UP OUR VECTOR
	MOV (B),(A)+	;STORE STATUS
	MOV #340,(B)+	;SET UP INFINITE PRIORITY
	JSR PC,PARIN	;INITIALIZE THE PARITY STUFF
	JSR PC,TYINIT	;INITIALIZE THE TTY'S
	JSR PC,MAPSET	;SET UP THE INTIAL MAP
	JSR PC,INITTB	;LINK UP LISTS
	JSR PC,MEMTST	;SET UP MEMORY TABLES
	JSR PC,CLKIN	;START UP THE CLOCK
;FALL THROUGH TO NEXT PAGE TO START UP THE SYSTEM PROCESS, ETC.
;FALLS IN FROM PREVIOUS PAGE
;START UP THE SYSTEM PROCESS
	JSR PC,CRUSER	;CREATE A USER
	MOV B,CURUSR	;HE IS THE CURRENT USER
	MOV #2,PRTPRI(B)	;INCREASE HIS PRITORITY
	JSR PC,CRSPHR	;CREATE A SPHERE FOR HIM
	MOV A,SYSSPR	;THE SYSTEM SHPERE
	MOV A,C		;SAVE THE SPHERE ITEM#
	JSR PC,CRPROC	;CREATE A PROCESS
	MOV C,B		;PUT THE SPHERE ITEM IN THE RIGHT PLACE
	JSR PC,PUTPRS	;PUT THE PROCESS INTO THE SPHERE
	MOV A,D		;SAVE THE PROCESS ITEM
	JSR PC,ITM0LD	;MAKE PROCESS ITEM 0
	MOV A,C		;SAVE ADDRESS
	MOV B,A		;GET SPHERE ITEM #
	JSR PC,ITM1LD	;MAKE SPHERE ITEM1
	ADD #SUPTS,A	;GET A POINTER TO THE UPTS
	MOV #20,D	;THERE ARE 20 PAGES
	MOV #KERISD,E	;WE WILL COPY THE KERNEL MAP INTO THIS SPHERE
SYSJI1:	MOV (E)+,(A)+	;THE DR
	MOV KERISA-KERISD-2(E),(A)	;THE AR
	BIS #UPTABT,(A)	;AN ABSOLUTE PAGE
	ADD #UPTLEN-2,A
	SOB D,SYSJI1	;DO FOR 20 PAGES
	CLR B		;CAPABILITY ZERO
	JSR PC,AGCLAD	;GO GET THE ADDRESS
	MOV #.CCCAP,(A)	;A CREATE CAPABILITY CAPABILITY
	MOV #1,B	;CAPABILITY ONE
	JSR PC,AGCLAD	;GO GET THE ADDRESS
	MOV #.MSCAP,(A)	;MAKE IT A MASTER SPHERE CAPABILITY TO ITSELF (!!!!)
	BIS #MSPCBT!.SPFES,(A)+	;EVERYTHING AND NO ENTERS
	MOV SYSSPR,(A)	;THSI IS IT
	MOV #30.,E	;THE NUMBER OF SLOTS OF USERS TO TRY TO START
	SAVE C		;SO THAT IT DOESN'T GET CLOBBERED
	JSR PC,CCPRCL	;CREATE A CORE LINK
	REST C
	MOV B,TTYCL	;SET UP POINTER TO THE CORE LINK FOR TTY ROUTINES
	MOV #2,B	;THE CAPABILITY 2
	JSR PC,AGCLAD	;GET THE ADDRESS
	MOV #.CLCAP!.CLCONS,(A)+	;SET IN THE FLAGS
	MOV TTYCL,B	;GET THE POINTER TO IT
	MOV B,(A)+	;SET IT IN
	MOV B,A		;GET IT
	JSR PC,ITM2LD	;LOAD IT
	MOV ITEM0,CLCONP(A)	;SET IN CONSUMER POINTER
	MOV #SYSJOB,PUPC(C)	;SET THE THINGS PROGRAM COUNTER
	MOV #SYSJPD,PUP(C)	;AND ITS PDL POINTER
	BIC #PSUPSB,PSTOP(C)	;CLEAR THE STOP BIT
	JSR PC,PSTPDC	;GO DECREMENT THE STOP COUNT AND PUT ON RUN Q
	CLR INITSW	;EXITING INIT CODE
	JMP SCHED	;GO GO GO!
;INITIALIZE THE CLOCK THAT EXISTS TO TICK AT 60. HZ
CLKIN:	SAVE BEBRV	;FIND OUT WHICH CLOCK WE HAVE
	MOV #CLKIN1,BEBRV	;GO TO GOPC FOR PROGRAMMABLE CLOCK
	MOV #100,LCCS	;TRY TO START THE LINE CLOCK
	BR CLKIN2		;WON'T GET HERE IF UNSUCESSFUL
CLKIN1:	SPL 0		;IN CASE SET BY THE BREAK
	CMP (P)+,(P)+	;FLUSH SAVED THINGS
	CLR PCCB	;WE HAD BETTER HAVE A PROGRAMMABLE CLOCK!
	MOV #115,PCCS	;LINE FEQUENCY, REPEAT INT, ETC.
CLKIN2:	REST BEBRV	;WE HAVE SET UP THE CLOCK
	RTS PC

;INIT THE TABLES AND HARDWARE REGISTERS ASSOCIATED WITH PARITY
PARIN:	SAVE BEBRV	;TO TRAP NON-EX PARITY REGISTERS
	MOV #PARIN1,BEBRV
	MOV #PARREG,A	;POINT TO THE BEGINING OF THE TABLE
	MOV #PARCSR,B	;POINT TO THE BEGGINING OF THE HARWARE REGISTERS
	MOV B,C
	MOV #20,D	;THERE MAY BE AS MANY AS 16. OF THEM
PARRCK:	MOV #1,(B)+	;ENABLE THE PARITY CHECKING
	MOV C,(A)+	;SKIPPED IF REG NOT THERE
PARIN2:	ADD #2,C	;UPDATE THE POINTER TO THE REGISTER THAT IS STORED AWAY
	SOB D,PARRCK
	REST BEBRV
	RTS PC
PARIN1:	CMP (P)+,(P)+	;CLEAR CRAP OFF STACK
	SPL 0
	BR PARIN2
;INITIALIZE VARIOUS TABLES
INITTB:	MOV #INITLS,A	;THINGS TO LINK INTO FREE LISTS
INTLST:	MOV (A)+,B	;GET THE TABLE ADDRESS
	BEQ INTLS1	;DONE WITH THESE THINGS
	MOV (A)+,C	;GET THE ADDRESS OF THE FREE POINTER
	MOV (A)+,D	;GET THE NUMBER OF THINGS
	MOV (A)+,E	;GET THE LENGTH OF THEM
	MOV B,(C)	;SET UP THE FREE POINTER
	MOV B,C		;COPY POINTER INTO TABLE
INTLS2:	ADD E,C		;POINTER TO NEXT ONE
	MOV C,(B)	;GET PUT INTO THIS ONE
	ADD E,B		;GO TO NEXT ONE
	SOB D,INTLS2	;HOWEVER MANY TIMES
	BR INTLST
INTLS1:	MOV #INITM1,A	;STUFF TO MAKE -1
INTM11:	MOV #-1,(A)+
	CMP #EINTM1,A
	BNE INTM11
	MOV #ITMBIT,A	;THE BIT TABLE POINTERS
	MOV #ITMBTP,B
	MOV #NITMBL,C
INTBT1:	MOV A,(B)+	;POINTER TO A BIT TABLE
	ADD #22,A	;FURTHER ON
	SOB C,INTBT1	;FOR SO MANY BIT TABLES
	RTS PC

SYSJOB:	SAVE <#10,#MFITST,#.FACAP*400>
	$INVOK			;MAKE A ROOT MFI
	REST <A>		;ROOT CAP IN A
	SAVE <#-1,#0,A>
	BIS #.CPYCP,(P)		;COPY THE ROOT CAP
	$INVOK
	REST <B>		;BITS CAP WIL BE IN B
	SAVE <#0,#MFIBIT,B>
	BIS #.FAMU,(P)
	$INVOK
	SAVE <#0,#0,B>
	BIS #.FAMB,(P)		;SET UP BIT TABLE
	$INVOK
	SAVE <#-1,#0,A>
	BIS #.CPYCP,(P)		;COPY THE ROOT CAP
	$INVOK
	REST C
	SAVE <#MFIWSB,#MFIDSC,C>
	BIS #.FAMU,(P)		;GET THE DESCRIPTOR FILE
	$INVOK
	SAVE <C,C>		;FOR THE WRDI
	$WRDI			
	TST (P)+		;DONT WANT CREATION DATE
	$WRDI			;GET THE START
	SAVE C
	$WRDI			;AND LENGTH
	SAVE <#12>		;DISK NUMBER
	$ALLOC
	SAVE <#-1,#0,A>
	BIS #.CPYCP,(P)
	$INVOK
	REST C
	SAVE <#MFIWSB,#MFISYS,C>
	BIS #.FAMU,(P)		;MUTATE THE ROOT
	$INVOK
	SAVE <#<7*400>,#0,#13777,#.CRWRT+1>	;SET UP FRESH PAGE IN PAGE 7-17
	$MAP
	MOV #ABSLD,A
	MOV #<<ABSEND-ABSLOD>/2>,B	;NUMBER OF WORDS
	MOV #160000,D			;TOP PAGE
	MOV (A)+,(D)+
	SOB B,.-2
	MOV C,SYSFCP			;POINTER TO SYSTEM FILE CAPABILITY
	SAVE <#<7*400>,#0,#10000+377,#.CRWRT+1>	;SET UP FRESH PAGE IN PAGE 0-10
	$MAP
	SAVE <#<7*400>,#0,#10400+377,#.CRWRT+1>	;SET UP FRESH PAGE IN PAGE 1-11
	$MAP
	JMP 160000			;START IT UP

LSTILC=.	;PUT THIS AT THE LAST INSTRUCTION LOCATION
FSTFRB==<<<.!1777>+1>_-10.>&77	;FIRST FREE BLOCK
.MACRO PAD A,B
.PRINT /A B
/
.ENDM
.IF2
PAD ^/SYSTEM END =/,\.
.IRP Y,<0,1,2,3>
.IRP X,<0.,1.,2.,3.,4.,5.,6.,7.,8.,9.>
.IIF Z <<<FSTFRB+1>/2>-Y''X>,PAD Y''X,<K>
.ENDM
.ENDM
.ENDC
	.END GO
