 	.TITLE PDP11 LOGO
	.ABS
	%COMPAT==0
	VERNF==%FNAM2
	.STITL CONFIGURATION PARAMETERS
.INSRT SITS;SITSS SYMS
.INSRT SITS;SITMAC >
.IF1
TS==1		;1=> SITTING UNDER SITS  0=> ELSE
DSK==1		;0=> NO DISK FOR PDL SWAPPING

		.MACR SETFLG FLG
		.PRINT /FLG=/
		.TTYMAC FLAG
		FLG==FLAG
		.ENDM
		.ENDM

.IIF NDF BEEF,BEEF==0

.IIF NDF DMPCAS,DMPCAS==0
.IIF NDF HALFLG,HALFLG==0
.IFNZ HALFLG
	SETFLG HAL1
.ENDC

NPLOT==1
NDISP==1
GTI==1
.IIF NDF GTI,GTI==0		;2500 DISPLAY
	DDF==1
	FPPF==1
DPM1==1 ;SEE DAN MIRANKER

.IIF NDF GUY,GUY==0
.IIF NDF AI,AI==1

.IIF NDF ENG,ENG==1
.IIF NDF FR,FR==0
TVS==1

;Assembly switch for color TVs.
COLOR == 1

	LPF==1

.IF NDF LSI
LSI==0	;LSI=1 => LSI VERSION, =0 => 1145 VERSION
LSIHAK==0
.ENDC
.IF Z  LSI
.IIF NDF TURFLG,TURFLG==1
.IIF NDF PTBOX,PTBOX==1
.ENDC
.IF NZ LSI
.IIF NDF TURFLG,TURFLG==0
.IIF NDF PTBOX,PTBOX==0
.ENDC
.IIF NDF BOTUR,BOTUR==0
.IFNZ LSI
	TS==0
	DSK==0
	TVS==0
	COLOR==0
	LPF==0
	NPLOT==0
	NDISP==0
	DDF==0
.ENDC
.ENDC
	.STITL SYSTEM PARAMETERS

A=%0
B=%1
C=%2
D=%3
E=%4
F=%5
U=%5
P=%6
SP=%6
PC=%7

FA==%0
FB==%1
FC==%2
FD==%3
FE==%4
FF==%5

EOFCHR==3

ERROR==TRAP

HICORE==160000	;FOR LSI LOGO

.BUG.==ERROR+BUG

;DATA SPACE PAGE MAP

;PAGE 0
;	SYSTEM TRAP VECTOR(S)
;	MISC VARIABLES
;	BEGINING OF ARRAY SPACE

PURPG==1
PURAD==PURPG*20000
PURE==PURAD
;PAGE 1
;	PURE CONSTANTS
;		MISC
;		SOBLST
;		ERRORS+ERROR TABLES

ARYPG==2
.IIF Z LSI,	ARYAD==ARYPG*20000
;PAGE 2
;	MORE ARRAYS

ARYHPG==3
;PAGE 3
;	STILL MORE ARRAYS
;	(END OF ARRAYS, CURRENTLY)

DISPG==4
DISAD==DISPG*20000
;PAGE 4
;	OLD STYLE DISPLAY
;	BEGINNING OF TV DISPLAY
;	MAYBE (UGH!) MORE ARRAYS

HAKPG==5
HAKAD==HAKPG*20000
;PAGE 5
;	MISC HACKS
;		DIRECTORY FOR PRINTING OUT

NODPG==6
.IIF Z LSI,	NODESP==NODPG*20000
.IIF NZ LSI,	NODESP==STORAG
;PAGE 6
;	START OF NODE SPACE

NODPG1==7
;PAGE 7
;	END OF NODE SPACE
	.STITL MACROS
	.MACRO BRAKET
	TST BRAKE
	BEQ .+4
	ERROR+BRK
	.ENDM

	.MACR PUSH AA
	MOV AA,-(P)
	JSR PC,PPUSHT
	.ENDM

	.MACR POP AA
	MOV (P)+,AA
	JSR PC,PPOPT
	.ENDM

	.MACR PUSHS AA
	JSR PC,SPUSHT
	MOV AA,@S
	.ENDM

	.MACR POPS AA
	MOV @S,AA
	JSR PC,SPOPT
	.ENDM

	.MACR SPUSH AA
	MOV AA,-(P)
	.ENDM

	.MACR SPOP AA
	MOV (P)+,AA
	.ENDM

	.MACR SPUSHS AA
	SUB #2,S
	MOV AA,@S
	.ENDM

	.MACR SPOPS AA
	MOV @S,AA
	ADD #2,S
	.ENDM

.MACR	TEXT AA
	.ASCII ÁA‰;DON'T TRY TO INCLUDE RUBOUTS IN TEXT
	.BYTE 0		;('CAUSE DELIMITERS ARE RUBOUTS)
	.EVEN
.ENDM

.MACR	.PRTXT AA
	JSR A,ERTAS
	AA
.ENDM

.MACR	PRTXT AA
	.PRTXT ^ÔEXT ^&AA&‰;RUBOUTS AROUND .PRTXT ARG
.ENDM

.MACR	CPRTXT	AA
	.PRTXT ^®BYTE	15
	TEXT ^&AA&‰;RUBOUTS!
.ENDM

.MACR	BPRTXT X
	.PRTXT ^®BYTE	7,7,15
	TEXT	^&X&‰;RUBOUTS!
.ENDM

.MACR	PRTXTC	AA
	.PRTXT ^®ASCII	&AA&
	.BYTE	15,0
	.EVEN‰	;RUBOUTS!
.ENDM

.MACR PAD A,B
	.PRINT &A B
&
.ENDM

.MACR PRCR
	JSR PC,.CRLF
.ENDM

.MACR SPACE
	JSR PC,.SPACE
.ENDM

LGNSYM==0
.MACRO LANGC EN,F
.IFNZ <ENG&FR>
	BIT #PFRFLG,LANG
	CONS BNE ,LS,\LGNSYM
.ENDC
.IF NZ ENG
EN
.ENDC
.IF NZ <FR&ENG>
CONS BR ,LS,\LGNSYM+1
CONS LS,\LGNSYM,::
.ENDC
.IF NZ FR
F
.ENDC
.IF NZ <FR&ENG>
CONS LS,\LGNSYM+1,::
LGNSYM==LGNSYM+2
.ENDC
.ENDM

.MACR REPT1 A,B
	.REPT A
	B
	.ENDR
.ENDM

.MACR REPT2 A,B,C
	.REPT A
	B
	C
	.ENDR
.ENDM

.MACR SDPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
.ENDC
.ENDM

.MACR SDPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
.ENDC
.ENDM

.MACR VERR
.IFLE .-.VERR-127.
	BVS	.VERR
.ENDC
.IFG .-.VERR-127.
	BVC	.+4
	.VERR==.
	ERROR+RTB
.ENDC
.ENDM

.MACR DPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPCLR HIGH,LOW
	CLR	HIGH
	CLR	LOW
.ENDM

.MACR DPINC HIGH,LOW
	DPADD ,#1,HIGH,LOW
.ENDM

.MACR DPDEC HIGH,LOW
	DPSUB ,#1,HIGH,LOW
.ENDM

.MACR DPNEG HIGH,LOW
	NEG LOW
	ADC HIGH
	NEG HIGH
.ENDM

.MACR NOP NUM
	.IFG NUM
	BR .+<NUM*2>
	NOP <NUM-1>
	.ENDC
.ENDM

.MACR EXCH LOC1,LOC2
	MOV	LOC1,EXCH1
	MOV	LOC2,LOC1
	MOV	EXCH1,LOC2
.ENDM
	.MACR NODE A,B
$.==$$+1
	A
	B
$$==$$+1
.ENDM


.MACR	CONS	A,B,C
	A'B'C
.ENDM

.MACR CONC6 A,B,C,D,E,F
	A'B'C'D'E'F
.ENDM


SYPDLL==240
DSECLN==400
.IFZ LSI
PPDLL==2000
SPDLL==2000
.IFF
PPDLL==1000
SPDLL==1000
.ENDC
PDSLOP==300.	;MUST BE EVEN AFTER DIVISION BY 3
PDSWOP==2000
MAXARG==32.
DBUFL==1000


FRTRCF==1
SWTRCF==2
SPTRCF==4
GCTRCF==10

	;NODE TYPES
SFUN==000000
INFIX==10000
UFUN==20000
UVAR==30000
IDLE==40000
BUKTEL==60000	;NODE IN BUCKET OF OBLIST (INVALID TOKEN TYPE)
;THE FOLLOWING TYPES ARE NEEDED IN THIS ORDER BY THE CONVERT ROUTINES
SSTR==70000	;NOT VALID TOKEN TYPE
SNP==100000
ATOM==110000
SNUM==120000	;NOT A VALID TOKEN TYPE
LNUM==130000
INUM==LNUM	;INTEGER NUMBER
LSTR==140000
FNUM==150000
LIST==170000
SENT==LIST
;END OF ORDER

	;BINDING TYPES
FBIND==20000
VBIND==30000
;DON'T USE 40000, IT IS "IDLE" (UGH)
ABIND==50000
SVBIND==130000	;SWAPPED OUT  VARIABLE BINDING
.IIF NZ BEEF,	DBIND==60000	;DELETED PROCEDURE BINDING

	;SOE FLAGS SEE OLE MACRO STUFF
VNAF==2000

	;READ FLAGS SEE DTBL:
DOTF==400	;IN LEFT HALF
	;EVAL FLAGS - PUSHED BY PEVAL
PTLPF==1	;PREVIOUS TOKEN WAS LEFT PAREN
RTF==2	;REPEAT TOKEN
CRF==4	;CURRENT TOKEN IS CR
EDITF==10	;EDIT FLAG
DORF==20	;SET IF THIS FRAME IS A DO OR A READ
;	TOF==20	;TO FLAG
;	IFF==40	;IF FLAG
TSTFLG==100	;TEST FLAG FOR TEST, IFTRUE AND IFFALSE
SPDF==200	;SKIP PROC DEF. FLAG
TPTF==400	;THIS PROCEDURE TRACED FLAG	;MUST BE IN LEFT HALF
EDTIF==1000	;EDIT TITLE FLAG
BRKF==2000	;BREAK MODE FLAG
ERRF==4000	;ERROR FLAG
EDTIF2==10000	;BECOMES EDTIF ON LEAVING EVAL
TPSF==20000	;THIS PROCEDURE STEPPED FLAG	;MUST BE IN LEFT HALF
TPBF==40000	;THIS PROCEDURE BURIED FLAG	; "   "  "   "    "
EVIFS==PTLPF+RTF+CRF	;FLAGS CLEARED BY EVLINE

	;EVAL FLAGS2 - NOT PUSHED
CPTBF==1	;CHANGE % TO BLANK
TRACEF==2
PQF==4		;PRINT QUOTE FLAG - FOR PRSTR
DPQF==10	;DONT " " "
MMF==20	;MULTIPLE MAKE FLAG
SSF==40	;SPECIAL STATUS FLAG
PADERF==100	;PRINT ADDRESS OF ERROR
MGCF==200	;MANY G. C.'S FLAG
PNNLF==400	;PRINT NO. NODES LEFT
DSAMFL==1000	;DISK ALMOST FULL
PPNAIF==2000	;P PDL NOT ALL THE WAY IN
SPNAIF==4000	;S PDL NOT ALL THE WAY IN
HERRF==10000	;HARD ERROR
CHEKUF==20000	;TURNS ON VARIOUS USER CHECKING THINGS

	;TEMP FLAGS IN TFLAGS
TF6==1
RBRKF==2	;BREAK FLAG - FOR ROUTINE THAT CALLS RDSTR
TF7==4
TF1==100	
TF2==200
TF3==400
TF4==10000
TF5==20000


NBN==40	;# BUFFER NODES - IF FREE NODES < THIS, == NO STG LEFT


	.IFNZ NDISP
;DISPLAY COMMANDS
ADDX==150000
ADDY==144000
ADDXY==ADDX!ADDY
DPUSHJ==100000
DPOP==140200
DPOPJ==140100
DSTOP==140400
DRSTXY==143000	;RESET X AND Y TO 0
DINC==40000

TURSIZ==6	;THE SIZE OF THE TURTLE

TKRUN==4000
TKGO==10000
TKSTOP==20000
.ENDC

.IFNZ GTI
GTNOP==0	;NOP
GTHOME==4000	;HOME
GTPEND==4400	;PENDOWN
GTPENU==4407	;PENUP
GTSTUR==5001	;SHOWTURTLE
GTHTUR==5000	;HIDETURTLE
GTSNAP==5400	;SNAP (ADDRESS IN NEXT WORD)
GTBLNK==6000	;BLINK
GTWRAP==6400	;WRAP
GTRSET==7000	;RESET???
GTFD==10000	;FORWARD+11 BITS OF DISTANCE
GTRT==14000	;RIGHT+11 BITS OF ANGLE
GTSHED==20000	;SET HEADING+11 BITS OF HEADING
GTMOVE==24000	;MOVE+11 BITS OF SPEED
GTSPIN==30000	;SPIN+11 BITS OF SPEED
GTDISP==34000	;DISPLAY, ADDRESS IN NEXT WORD
GTSTXY==40000	;SET X+11 BITS, Y IN NEXT WORD
GTDLXY==44000	;DELTA X+11 BITS, Y IN NEXT WORD
GTCS==50000	;CLEAR SCREEN
GTRUB==50000	;RUBOUT+11 BITS OF WORDS TO RUB OUT (SHOULD BE NEGATIVE)

.MACRO GTJUMP ADDR
.IFNZ GTI
	TST GTIDF
	BEQ .+6
	JMP ADDR
.ENDC
.ENDM
.ENDC

;FLAGS USED FOR DFLAGS
PENUF==1	;PEN UP
HIDETF==4	;TURTLE NOT SHOWN
TURTF==10
TEMF==20
DISPF==40	;DISPLAY IN USE
WRAPF==100	;WRAP AROUND MODE
PLOTF==200	;PLOTTER IN USE
TVF==400	;THIS IS A TV DISPLAY
CLIPF==1000	;CLIP MODE

;Flags for color in DFLAGS word of display flags.

COLORF == 2000	;On if color display in use.
ERASEF == 4000	;Eraser doesn't seem to be implemented. [:ERASERSTATE] in Lisp.
XORF == 10000	;:XORSTATE
COLORW == 20000 ;Color write mode is on.




.IFNZ TS
.=34
	ERRBRK
	.=40
.IFF
.=0
	.REPT 60
	.+2
	BPT
	.ENDR
.=34
	ERRBRK
.=10
	FLEMT
.=30
	LSIEMT
.=244
	FLFIS
.=60
	LSTINT
	340
	LSTONT
	340
.=14
	.+2
	ERROR+BUG
.=0
	BPT
.=300
	JMP START	;MAGIC START/RESTART PLACE (300
	JMP START1	;HERE IS WE WANT TO CLEAR THE WORLD (304)
	ERROR+BRK	;TO CAUSE AN ERROR, SET PC TO 310
.ENDC
LVERNF:	VERNF
PAT:
PATCH:	.=.+400	;PATCH AREA
PATEND=.

.STITL LSI UTILITY FILES (VARIABLES)

.IFNZ LSI

.INSRT 11LOGO;LSITVR >

.INSRT 11LOGO;LSFLVR >

;XOR TABLES FOR THE SYSTEM
XORFLG:	0	;NON-ZERO => XOR S SHOULD BE CORRECT
SYSXOR:	0	;XOR OF WHOLE SYSTEM
SYSTAB:	.BLKW 16.	;XOR OF ADDRESS+2 FOR EACH BIT
WRNGBT:	0	;SAVED WRONG BITS
WRNGAD:	0	;SAVED WRONG ADDRESS
WRNGCN:	0	;COUNT OF CORRECTED ERRORS
IGNERR:	0	;TOO MANY ERRORS, IGNORE ALL
INCNT:	0	;SAVED COUNT FOR INCREMENTAL CHECK
INADDR:	0	;SAVED ADDRESS
INXOR:	0	;SAVED XOR
.ENDC
	.STITL USER VARIABLES
.IFZ DSK
	IIS=LOGEND
	IIP=IS-<2*SPDLL>
INITTB:	0			;TOP OF CORE
	S
	0
	SPOPL
	0
	IS
	PDSLOP/3
	SPOPLM
	SPDLL+<PDSLOP/3>	;TO SET LIMIT ON PDL
	SPUSHL
	<2*SPDLL>-<SPDLL+<2*<PDSLOP/3>>>	;GET TO THE TOP OF THE P PDL
	IP
	0
	PPOPL
	PDSLOP/3
	POPLM
	PPDLL+<PDSLOP/3>
	PPUSHL
	<2*PPDLL>-<PPDLL+<2*<PDSLOP/3>>>
	PPDTOP
INITTE::
.ENDC
SPMSWP:	0	;THE PLACE WE ARE MARKING IN GHT ESWAPPED OUT PDL
PDLEMR:	0	;PDL EMERGENCY FLAG
IS:	IIS
S:	IIS
SPOPL:	IIS
SPUSHL:	IIS-<SPDLL+<2*PDSLOP/3>>
SPDLCP:	0
SPEMR:	0	;S PDL EMERGENCY FLAG
SPLIMT:	20000	;LIMIT ON S PDL
SCRBLK:	0
IP:	IIP
PPOPL:	IIP
PPUSHL:	IIP-<PPDLL+<2*PDSLOP/3>>
PPDLCP:	0
PPEMR:	0	;P PDL EMERGENCY FLAG
PPLIMT:	40000	;LIMIT ON P PDL
PPDTOP:	IIP-<2*PPDLL>	;DSK=0 PDL BUFFER TOP (BOTTOM)
.IFNZ DSK
NDISKS==4
MXNAME==10.	;MAX LENGTH OF NAME IN WORDS
DNAME:	.BLKW 5	;BITS, LENGTH, DATE, TIME
DNAM:	.BLKW MXNAME	;ACTUAL NAME
DNAMEP:	.REPT NDISKS	;NDISKS IS MAX NUBMER OF DISKS WHEN PUT IN .EVAL
	DNAMES+<.RPCNT*MXNAME*2>
	.ENDR
	0
DNAMES:	.BLKW MXNAME*NDISKS
DISKS:	0	;NUMBER OF DISKS
DSKNCH:	0	;NUMBER OF CHARS LEFT IN DISK BUFFER
.IFTF
REDFLG:	0
WRTFLG:	0
NAME:	.BLKW 10.
FILFLG:	0	;-1=> FILE OPEN FOR WRITE, 1=> FILE OPEN FOR READ, 2 => DIRECTORY
		; OPEN FOR READ, 0  => NOTHING OPEN FOR READ OR WRITE
.IFT
DIRFLG:	0	;NONZERO <=> NOTHING LEFT TO .FILER FROM OPEN DIRECTORY
	.BLKW 100.
DPDL:		;PDL FOR DIRECTORY-READ COROUTINE PROCESS
DRBUFF:	0	;QUE CAPABILITIES FOR DIRECTORY-READ COROUTINE COORDINATION
DRSTUF:	0
DIRCAP:	TMPCP	;PTR TO TMPCP OR CURCAP FOR .POI
USERS:	ASCIZ ^/USERS/
	.EVEN
CURROT:	10	;CURRENT ROOT
DEFROT:	10	;DEFAULT ROOT
CURCAP:	0	;CURRENT FILE CAP
DEFCAP:	4	;DEFAULT DIRECTORY CAP
DISCAP:	0
FREEBL:	0
DSKNUM:	0
DATE:	0
TIME:	0
CAPSP:	CAPSTK
CAPSTK:	.BLKW 20.
FILBLK:	.BLKW 20	;PALCE TO PUT FILE BLOCK FOR .FARI
TMPCP:	0
;DISPATCH TABLE FOR POTREE (INDEXED OFF OF DISK ENTRY TYPES)
PODIRC:	0					;CURRENT DIRECTORY BEING POTREE'D

BUFFER:	.BLKW 20.
DBUFCC:	0		;NUMBER OF CHARS IN BUFFER
FEOF:	.BLKW 2		;REMAINING CHARS IN FILE (ON READ)
DBUFP:	0
DBUF:	.BLKB DBUFL
FINFO:	.BLKW 2	;WORDS FOR FILE INFO FROM .FADI INVOK
SSTATS::	;THE SITS STATUS AREA
SVERN:	0	;SITS VERSION
STIME:	.BLKW 2	;TIME SINCE SYS START IN 60THS
SCSR:	0	;CONSLOE SWITCHS
LOOKSW:	0
RANDS:	.BLKW 20	;POTENTIALLY THERE ARE MORE
.ENDC
.IIF NZ ENG&FR,LANG:	FRFLG!PFRFLG
PRMTCH:	'?	;PROMPT CHAR
GTIDF:
.IIF Z LSI,	0	;2500 DISPLAY IS ON THE LINE
.IIF NZ LSI,	1	;LSI VERSION ASSUMES 2500.
GTIBUF:	.BYTE 33,0,0,0
TYICP:	2
TYOCP:	3
RNSEED:	27.	;FOR RANDOM
MUCWRD:	100	;CONTROL CHAR FOR CURRENT MUSIC BOX MODE
GCHR:	0	;SOURCE OF CHARS
PCHR:	0	;PLACE WHERE OUTPUT CHARS GO (TYO, BLST, ...)
OTTYST:	0
TTYST:	0
DFLAGS:	.WORD 0
ZEROS:	;BEGINNING OF STUFF THAT GETS ZEROED
;**************
;WARNING!!! ON RESTART, EVERYTHING ON THIS PAGE IS SET TO ZERO !!!!
;**************
PCRBLK:	0
ERRPT:	0
ERRPNT:	0
PRBAO:	0	; = 0,374,770, ... N*PDSWOP
SPRBAO:	0	;WHERE N = # P OR S PDL BLOCKS SWAPPED OUT
PRB:	0	;LIKE PRBAO, BUT NOTHING ACTUALLY SWAPPED OUT
SPRB:	0	; PRB AND SPRB ARE USED WHEN DSK=0, IE NO DISK
NNGC:	0	;NUMBER OF NODES GARBAGE COLLECTED
NNIFSL:	0	;NO. NODES IN FREE STORAGE LIST
FREE:	0	;START OF FREE NODES
GCP1:	0
GCP2:	0
GCPREV:	0
.IFNZ BEEF
PROCAR==4	;TYPE OF ARRAY FOR PROCEDURES

PARRYS:	0	;POINTER TO START OF PROCEDURE ARRAY WE ARE EDITING
PARRYF:	0	;NUMBER OF FREE BYTES IN THE PROCEDURE BEFORE WE NEED TO EXPAND

;THE LENGTH OF USED PROCEDURE IS STORED IN THE FIRST DIMENSION OF THE ARRAY
PRSIZE==40.	;NUMBER OF BYTES TO ALLOW FOR INITIAL PROCEDURE ALLOCATION
PROINC==40.	;NUMBER OF BYTES TO ADD EVERY TIME WE ADD MORE CORE TO THE PROC
.ENDC
;**************
;WARNING!!! ON RESTART, EVERYTHING ON THIS PAGE IS SET TO ZERO !!!!
;**************

	ERCLR1==.	;ON ERROR, START ZEROING HERE
OLFUN:	0	;USED FOR REDEFINING SYS. FUN
HTNODE:	0	;USED FOR REDEFINING SYS. FUN
TOPS:	0	;GC MARK FROM HERE IF NON 0
TOPS1:	0	;   "
TOPS2:	0	; "	(SIGH)
JPLN:	0	;PROCEDURE LINE # BEFORE LAST "GO"
	;THE FOLLOWING ARE PUSHED BY PEVAL
.IFZ BEEF
CPSN:	0
CPLN:	0	;CURRENT PROCEDURE LINE NO.
CLP:	0	;CURRENT LINE POINTER - GOOD IF CPSN'S AGREE
CLGN:	0	;CURRENT LINE GENERATION NO.
CTN:	0	;CURRENT TOKEN NO.
CTP:	0	;CURRENT TOKEN POINTER
.IFF
CPBND:	0	;POINTER TO THE CURRENT PROCEDURE'S BINDING NODE
NEXLIN:	0	;NEXT LINE IN THIS PROCEDURE (0 IF NO MORE EXIST, ODD IF WE HAVE TO
		;SEARCH FOR THE LINE)
CTP:	0	;POINTER TO THE NEXT TOKEN
CLCNT:	0	;NUMBER OF TOKENS LEFT ON THIS LINE
CPLN:	0	;CURRENT LINE NUMBER
.ENDC
CPP:	0	;POINTER TO THE CURRENT PROCEDURE NAME
IFLEV:	0	;IF LEVEL
NOPAR:	0	;NUMBER OF PARENS SEEN BY STNE
CPDLP:	0	;CURRENT PDL PTR AFTER LAST PEVAL PUSH
CSPDLP:	0	;CURRENT S PDL PTR AFTER LAST PEVAL PUSH
	;END OF PEVAL PUSHES EXCEPT
	;CO, CO+2, FLAGS + ERPROC ARE ALSO PUSHED
FUNLEV:	0	;FUNCTION LEVEL
	;THE FOLLOWING ARE PUSHED (SOMETIMES) BY EVAL
.IFZ BEEF
CO:	0	;CURRENT OPERATOR
	0
NOR:	0	;NO. OF OPERANDS STILL NEEDED BEFORE CO CAN BE EXECUTED
	;END OF EVAL PUSHES
COF:	0	;CURRENT OPERATOR FLAGS
LO:	0	;LAST OPERATOR
	0
CT:	0	;CURRENT TOKEN
	0	; "
.ENDC
.IFNZ BEEF
CO:	0	;CURRENT OPERATOR
NOR:	0	;NO. OF OPERANDS STILL NEEDED BEFORE CO CAN EXECUTE
COF:	0	;FLAGS FOR THE CURRENT OPERATOR
LO:	0	;LAST OPERATOR
CT:	0	;CURRENT TOKEN
.ENDC
RDFLAG:	0	;FOR READ
LISTBD:	0	;LIST BUILD DEPTH
PSTOPR:	0	;RETURN ADDR FOR PSTOP
.IIF Z BEEF,ERFRET:	0	;RETURN ADDR WHEN AN ERROR SET FRAME IS ENCOUNTERED
DOFRET:	0
TEMP:	0
TMPBLK:	.BLKW 7
TFLAGS:	0	;TEMP FLAGS (ALL TFN'S SHOULD EVENTALLY POINT HERE)
NCHR:	0	;FOR BLST
ABASE:	0	;(ABASE)+10. IS WHAT ARITHMETIC BASE WE ARE IN
		;(FOR CONVERT TO & FROM STRING ROUTINES)
	ERCLR2==.	; ON ERROR STOP CLEARING HERE
SECOND:	0
MINUTE:	0
HOUR:	0
DAY:	0
MONTH:	0
YEAR:	0
;**************
;WARNING!!! ON RESTART, EVERYTHING ON THIS PAGE IS SET TO ZERO !!!!
;**************

FLAGS:	0	;FLAG WORD
ERPROC:	0	;UOE PTR TO PROC TO CALL IF THERE IS AN ERROR
ILINEL:	0	;INPUT LINE PTR GC MARK FROM HERE)
NPROCL:	0	;NAME OF PROC BEING EXECUTED WHEN ERROR OCCURED
NLINEL:	0	;# OF PROC LINE BEING EXECUTED " " "
NTOKEL:	0	;# OF TOKEN BEING EXECUTED " " "
ERRORN:	-1	;ERROR NUMBER
BRAKEL:	0	;VALUE OF BRAKE(U)
BRAKE:	0
TOPRNM:	0	;PTR TO UOE OF PROC. BEING "TO"'ED
.IIF Z BEEF,FNLLP:	0	;FIRST NODE OF LIST OF LINE POINTERS (FOR "TO")
FLAGS2:	0	;EVAL FLAGS - NOT PUSHED BY PEVAL
GNCN:	0	;"GET NEXT CHAR" NODE AND USED BY GNOLE
	0
NBKTS:	0	;FOR RDSTR
LASTER:	0	;ADDRESS OF LAST ERROR
LASTPR:	0	;LAST PROC DEFINED
PTBF:	0
PTBTAB:	.BLKW 4
CHI:	0
ALEVN:	0	;NON-ZERO MEANS ALLOW N LEVEL BREAK STUFF
ENDWLD:	0
SEXP:	0	;USED FOR SIGN OF EXPONENT IN CONVERT
FNPDL:	0	;AUXILIARY STACK IN CONVERT
	0
	0
	0
	0
	0
	0
	0

;**************
;WARNING!!! ON RESTART, EVERYTHING ON THIS PAGE IS SET TO ZERO !!!!
;**************
	MUSBEG==.	
		;KEEP VARIABLES IN THIS ORDER
MVOC:	.WORD	0,0,0,0	;POINTERS TO VOICE LISTS--ONE FOR EACH VOICE
VLAST:	.WORD	0,0,0,0	;POINTERS TO LAST NODE IN LIST
VOICLN:	.WORD	0,0,0,0	;NUMBER OF NOTES IN EACH VOICE
VOICEN:	0	;INDEX FOR CURRENT ACTIVE VOICE
NVOIC:	0	;NUMBER OF ACTIVE VOICES
	MUSEND==.
PLTCHR:	0	;CHAR COMING BACK FROM PLOTTER

;TURTLE VARIABLES
TURDN:	0	;USER'S TURTLE DEVICE NUMBER
TURF:	0	;FUDGE FACTOR FOR TURTLE LEFT AMD RIGHT

DIVOWN:	.WORD 0
DPENP:	.WORD 0
PLPENP:	.WORD 0
;PLOTTER VARIABLES
;THESE MUST BE IN ORDER
PORBEG==.
PCURX:	.WORD 0,0	;CURRENT PLOTTER X POS
PCURY:	.WORD 0,0	;PLOTTER CURRENT Y
PCURA:	.WORD 0,0		;CURRENT ANGLE PLOTTER
PCOSA:	.WORD 0,0
PSINA:	.WORD 0,0
RPCURX:	.WORD 0,0,0,0
POREND==.

;VARIABLES AND CONSTANTS FOR DISPLAY SYSTEM

;THESE MUST BE IN THIS ORDER
DORBEG==.
DCURX:	.WORD 0,0
DCURY:	.WORD 0,0
DCURA:	.WORD 0,0
DCOSA:	.WORD 0,0
DSINA:	.WORD 0,0
RDCURX:	.WORD 0,0,0,0
OLDX:	.WORD 0,0
OLDY:	.WORD 0,0
 
NADXY:	0	;NUMBER OF EXTRA ADDXY'S WE CAN TRY TO COLLAPSE
ODIREC:	0	;IF NOT EQUAL TO DIREC BREAK INCREMENTS TO NEW OWRD

DOREND==.	;MARKS END OF THESE VARIABLES
;END OF ORDER

STB:	0	;STATIC AREA BOTTOM
STT:	0	;STATIC AREA TOP.POINTS TO TOP OF STATIC DISPLAY AREA
DYB:	0	;DYNAMIC BOTTOM.  POINTS TO BOT OF DY AREA
DYR:	0	;ROVING POINTER USED BY DISPLAY STORAGE ALLOCATIN ROUTINES
DYT:	0	;POINTER TO DYNAMIC AREA TOP
TUB:	0	;POINTER TO TURTLE AREA BOTTOM
SNLIST:	0	;POINTER TO SNAP LIST
SNABOT:	0	;BOTTOM OF CURRENT SNAP
DFBCNT:	0	;KEEPS TRACK OF # OF FREE BITS IN DISPLAY LIST
PUSHJT:	0	;DISPLAY PUSHJ TO TURTLE
DRELOC:	0	;RELOCATION.  ADD THIS TO VIRTUAL ADDRESS TO GET DISPLAY ADDRESS
DIREC:	0
EZEROS::	;END OF ZEROING

.IIF NZ HALFLG, .INSRT 11LOGO;HALVAR >

.IFNZ TVS
;VARIABLES FOR TV TURTLE ROUTINES
DRAWMD:	.TVDSI	;PEN MODE, CAN BE XOR IOR OR NULL
WINDATA:
	-1.	;Data to be written in TVRWIN register. 0 for B&W eraser mode, else -1.
TVX:	423.
TVY:	152.	;POSITION OF THE TV DRAWER
TVTOP:	2.	;TOP LINE OF THE DISPLAY AREA
TVBOT:	302.	;BOTTOM LINE OF THE DISPLAY AREA
TVLEFT:	273.	;BIT POSITION OF LEFT SIDE OF DISPLAY AREA
TVRIGH:	573.	;BIT POSITION OF RIGHT SIDE OF DISPLAY AREA
TVSIZX:	301.	;SIZE OF DISPLAY AREA IN X DIRECTION
TVSIZY:	301.	;SIZE OF DISPLAY AREA IN Y DIRECTION
TVCENX:	423.	;BIT POSITION OF CENTER OF DISPLAY AREA
TVCENY:	152.	;LINE OF THE CENTER OF DISPLAY AREA
TVMIN:	301.	;MINIMUM DIMENSION OF DISPLAY AREA
TVSIZE:	0	;NUMBER OF LINES IN DISPLAY AREA (DOWN TO ECHO AREA)
TVHIGH:	0	;HEIGHT OF A CHAR LINE IN TV LINES
TVWIDE:	0	;WIDTH OF A CHAR IN BITS

;THE NEXT SET OF VARIABLES REFER TO THE TURTLE PICTURE. IE, THE SCREEN
;AS MEASURED IN TURTLE COORDINATES.
TRMIN:	400.	;MINIMUM DIMENSION OF DISPLAY AREA
TRCENX:	0	;CENTER OF TURTLE SCREEN IN X
TRCENY:	0	;CENTER OF TURTLE SCREEN IN Y

;FLOATING POINT VARIABLES
TRPRTV:	.WORD 0,0	;NUMBER OF TURTLE INCREMENTS PER TV INCREMENT
TRFRAD:	.WORD 0,0	;SIZE OF THE TURTLE FRONT RADIUS
TRSRAD:	.WORD 0,0	;SIZE OF THE TURTLE SIDE RADIUS
TRSIZX:	.WORD 0,0	;SIZE OF TURTLE SCREEN IN X
TRSIZY:	.WORD 0,0	;SIZE OF TURTLE SCREEN IN Y
TRRIGH:	.WORD 0,0	;TURTLE VALUE OF RIGHT BORDER
TRLEFT:	.WORD 0,0	;TURTLE VALUE OF LEFT BORDER
TRTOP:	.WORD 0,0	;TURTLE VALUE OF BOTTOM BORDER
TRBOT:	.WORD 0,0	;TURTLE VALUE OF BOTTOM BORDER
TRSCLX:	.WORD 0,0	;X TURTLE SCALE FACTOR
TRSCLY:	.WORD 0,0	;Y TURTLE SCALE FACTOR


;Definitions of registers relevant to color stuff.

DISOFF == 164100 - DISAD 	;Offset of display addresses.

COLORD == 164102 - DISOFF	;Color data
VIDSW == 164104 - DISOFF	;Video switch
COLORA == 164106 - DISOFF	;Color address

CLRRED  ==  300			;IOR these with color map address into COLORA to set 
CLRGREEN  ==  500		;red, green, blue intensities. 
CLRBLUE  ==  600	

TVINCR == 164140 - DISOFF	;The increment register for the TV's
TVINC == 77			;The mask for the increment
TVRSET == 100000		;The reset bit
TVCLRW == 400			;The color write bit
TVOFLO == 1000			;Mask to handle overflow in increment register

TVSEL == 164142 - DISOFF	;The console select register
TVRCNS == 77			;The console number mask
TVRWMD == 300			;The regular write mode mask
TVNSH == 0			;No shift write mode
TVIOR == 100			;The inclusive or mode
TVXOR == 200			;The XOR mode
TVSET == 300			;The set mode [word moved directly to destination]
TVDCNS == TVRCNS * 400		;The disk console number (same, but in top byte)
TVDWMD == TVRWMD * 400		;The disk write mode mask

TVRADR == 164144 - DISOFF	;The regular address register

TVWDCN == 164146 - DISOFF	;The word count for the block write
TVWDCM == 777			;Mask for word count
TVDADR == 164150 - DISOFF	;The disk transfer address register

TVSHR == 164152 - DISOFF	;The shift register
TVSHCN == 17			;The shift count
TVMAP == 17400			;The start of the 16k page (in 4k blocks)
TVAMAP == 20000			;The activate tvmap bit

TVMSK == 164154 - DISOFF	;The mask register

TVDWIN == 164156 - DISOFF	;The window for disk transfers

TVRWIN == 164160 - DISOFF	;The window for regular transfers

TVCNSO == 164162 - DISOFF	;The console register for the memory
TVCLR == 160000			;The color number


;Magic constants

VSWMC1 == 30_10 + 0 	;Video switch magic constant 1
VSWMC2 == 31_10 + 1	;Video switch magic constant 2
VSWMC3 == 32_10 + 2 	;Video switch magic constant 3
VSWMC4 == 33_10 + 3	;Video switch magic constant 4
CRMC1 == 1_15		;Console register magic constant 1
CRMC2 == 2_15		;Console register magic constant 2
CRMC3 == 3_15		;Console register magic constant 3
CRMC4 == 4_15		;Console register magic constant 4
ROTMC == 35400		;Rotate register magic constant
WORLIN == 36.		;Number of 16 bit words on a TV line [576 bits]
BYTLIN == 72.		;Number of 8 bit bytes on a TV line.
TVXSMN == 20.		;TV X size minimum [args to TVSIZE].
TVXSMX == 570.		;TV X size maximum.
TVYSMN == 20.		;TV Y size minimum.
TVYSMX == 415.		;TV Y size maximum.
PIXMAX == 4.		;Maximum number of bits per pixel.
PALMAX == 1_PIXMAX	;Maximum palette size.


;End of color TV register definitions.


;Variables for color TVs.

PENNUM: 0.		;Pen number in palette [:PENNUMBER in Lisp]
ERANUM: PALMAX-1	;Index of eraser in palette [:ERASERNUMBER]
NCBITS:	PIXMAX		;Number of bits per point in color.
PALSIZ: PALMAX		;Size of the palette.
NCSIGB:	1_<PIXMAX-1>	;High order color bit, used by RTVPN. 

DSCAP:	.BLKW PIXMAX	;Table of capabilities to screen buffers.
DSNUM:	.BLKW PIXMAX	;Table of buffer numbers associated with buffers in DSCAP.

;The Palette is a set of locations holding atomic symbols of colors.
;This must be marked by the garbage collector.
;The palette is initially filled with NIL [list type code, zero pointer].

PALETTE: 
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
	LIST
PALEND:

;For debugging purposes a set of locations which can be used
;to look at the corresponding TV registers, since you can't look
;at them directly as DDT will show you the registers for its process,
;not Logo's.

FAKCLD:	0			;Fake COLORD
FAKCLA:	0			;Fake COLORA
FAKINC:	0			;Fake TVINCR
FAKSEL:	0			;Fake TVSEL
FAKADR:	0			;Fake TVRADR
FAKWDC:	0			;Fake TVWDCN
FAKSHR:	0			;Fake TVSHR
FAKMSK:	0			;Fake TVMSK
FAKWIN:	0			;Fake TVRWIN
FAKCNS:	0			;Fake TCNSO


;TEMPORARY LOCATION USED BY FACSAV
FACTMP:	.WORD 0,0
.ENDC
.IFNZ TS
TTYHGH==66	;NUMBER OF TTYS
TTYCPS:	;CAPS OF THE TTYS, 0 IF NOT OPEN
	.BLKB TTYHGH
.EVEN
.ENDC

	.=.+40	;FOR THE BREAK PROCESS
BRKPDL::
	.=.+20	;FOR RESTARTING
RSTPDL::
;RESTART PDL MUST BE BEFORE REGULAR PDL
.IFNZ DSK
	.=.+PPDLL+PDSLOP
	IIP=.
.=.+4
SSWPAD==IIS-PDSWOP
	.=.+SPDLL+PDSLOP
	IIS=.
.=.+4
PSWPAD==IIP-PDSWOP
.ENDC
POPLM:	IIP-<PDSLOP/3>
SPOPLM:	IIS-<PDSLOP/3>
HCC==67.	;HASH CODE CONSTANT - A PRIME
UHCT:	.=UHCT+<2*HCC>
	-1
GCBITS:	.BLKW 400
.IFNZ BEEF
INLEN==100.		;NUMBER OF TOKENS PERMITTED IN THE INPUT STREAM
CURPNT:	CURLIN		;FAKE BINDING NODE FOR THE CURRENT LINE
CURLIN:	.BLKW INLEN+3	;LENGTH + LINE NUMBER, GENERATION NUMBER, AND ONE FOR SAFETY
.ENDC

RAN:	0	;IF NON-ZERO, THIS LOGO HAS BEEN STARTED BEFORE
MAINPR:	0	;CAP TO MAIN PROCESS, FOR BREAK
DEBSW:	1-LSI	;DEBUG SWITCH, NON-ZERO IF BEING DEBUGGED
NOADDR:	1	;ZERO MEANS PRINT ADDRESS OF ERRORS
ASIZE:	0	;SIZE OF ARRAY SPACE (SHOULD BE ZERO)


	.IFNZ NDISP
;DISPLAY SYSTEM VARIABLES
DPDLL==60	;LENGTH OF EACH DISPLAY PDL (IN BYTES)
TLEN==20	;LENGTH OF EACH TURTLE LIST (IN BYTES)
TLIST==DISAD
DLIST==TLIST+TLEN
	.ENDC
TUT:	0	;TURTLE TOP.  POINTS TO TOP OF TURTLE DISPLAY LIST
SNPTEM:	0	;USED BY GARBAGE COLLECTOR


	CONSO==20
	PLOTT==40
	PMBOX==100
	INITF==1000	;MUSIC BOX INITIALIZED
	TURT==200
	TBMASK==177417

TEM0:	0
TEM1:	0
ANSWER:	.WORD	0,0	;USED BY DOUBLE PRECISION ROUTINES
SHFCNT:	0		;USED BY DOUBLE PRECISION ROUTINES
EXCH1:	0

INITED:	0	;IF NON-ZERO INIT CODE HAS BEEN RUN
ZERO:	0
AFREE:	0	;POINTER TO ARAY SPACE FREE LIST
AROVER:	0	;BOW-WOW
ASPACE:	0	;AMOUNT OF ARAY SPACE STILL FREE
.IFNZ LSI
NODTOP:		;IN LSI STORAGE ALLOC, TOP OF NODESP IS BOTTOM OF ARSPACE
ARYAD:	NODESP+2000
ARTOP:	NODESP+2000
.IFF
ARTOP:	ARYAD
.ENDC
;KEEP THE NEXT 3 IN ORDER!!!!
ARRHPG:	ARYPG-1	;HIGHEST PAGE GOBBLED SO FAR
ARRHPL:	7		;LENGTH OF HIGHEST PAGE
ARRHP:	ARYHPG	;HIGEST PAGE TO EVER GOBBLE

.IIF Z LSI,	NODTOP:	NODESP+2000
;KEEP NEXT 3 IN ORDER!!!
NODEHP:	NODPG	;HIGEST NODE PAGE SO FAR
	0	;LENGTH THEREOF
	NODPG+1	;HIGHEST PAGE TO GRAB
SYSHTL==16.		;IF YOU CHANGE THIS YOU ALSO HAVE TO CHANGE THE MASKS IN THE CODE
;END OF VARIABLES
.IIF GT .-PURAD,.ERROR OOOOPS! TOO MUCH IMPURE STUFF
LSUPBL==._-10.
.IIF Z LSI,.=PURAD
;START OF PURE CONSTANTS
PURES::	;START OF PURE FOR LSI SYS CHECKER
TBCCHR:	.WORD 117,112,105,40	;CONTROL CHARACTERS FOR TBOX
TURN:	144/2
	146/2
MBDN:	150/2
PLTDVN:	152/2
;MUSIC BOX VARIABLES (ONE SET FOR EACH MUSIC BOX)
INODESP:	0	;NODE 0
N==NODESP
	0
	$$==1
.IFNZ ENG
TRUE=LSTR+$$
	NODE SSTR+$.,"TR
	NODE SSTR,"UE
FALSE=LSTR+$$
	NODE SSTR+$.,"FA
	NODE SSTR+$.,"LS
	NODE SSTR,'E
.ENDC
.IFNZ FR
	VRAI=LSTR+$$
	NODE SSTR+$.,"VR
	NODE SSTR,"AI
	FAUX=LSTR+$$
	NODE SSTR+$.,"FA
	NODE SSTR,"UX
.ENDC
.IFNZ ENG
$TOTO=LSTR+$$
	NODE SSTR,"TO
.ENDC
.IFNZ FR
$POURX=LSTR+$$
	NODE SSTR+$.,"PO
	NODE SSTR,"UR
.ENDC

	LUNN=$$-1
	NNN=$$	;NEXT NODE NO.
SOFN=NNN	;START OF FREE NODES
ASOFN=.

.IFNZ TVS
VSWMC:	VSWMC1		;Video switch magic constants.
	VSWMC2
	VSWMC3
	VSWMC4

CRMC:	CRMC1		;Console register magic constants.
	CRMC2
	CRMC3
	CRMC4

DRAWTB:	DRAWH		;HORIZONTAL LINE
	DRAWV		;VERTICAL LINE

POIMSK:	
.REPT 16.
	-<1_<15.-.RPCNT>+1>
.ENDR

STARMSK:			;Table of masks for rightmost part of word.
	0			;For stuffing into TVMSK register, the Nth
	100000			;entry in the table allows writing all bits except
	140000			;the leftmost (1- N) bits.
	160000
	170000
	174000
	176000
	177000
	177400
	177600
	177700
	177740
	177760
	177770
	177774
	177776

STOPMSK:				;Table of masks to write leftmost N bits.
	77777
	37777
	17777
	7777
	3777
	1777
	777
	377
	177
	77
	37
	17
	7
	3
	1
	0
.ENDC

BREAKS:	RLWAIT	;WAITING FOR USER TO TYPE LINE
	TYWAIT	;WAITING FOR .BYTI FOR .TYI
.IFZ LSI
	SLWAIT	;WAITING FOR .SLEEP TO FINISH
	DTWAIT	;WAITING FOR .BYTI
.ENDC
	0
;THEM'S THE BREAKS!

.IFZ LSI
PODIRT:	PODIRP					;PARENT
	PODIRD					;DIRECTORY
	PODIRF					;FILE
	PODIRF					;LAST FILE
	PODIRS					;SELF
	PODIRL					;LINK
	PODIRL					;NOT IMPLEMENTED
	PODIRL					;NOT IMPLEMENTED
.ENDC

MAILNM:	.ASCIZ /MAIL/	;MAIL DIR. NAME
.EVEN

;DATE-TIME TABLE
	;BIT FORMAT OF DATE & TIME WORDS IS:
	;     YR  MO  DA        HR  MIN  SEC/2
;	DATE: 7   4   5   TIME: 5   6     5

DTTAB:	-5			;MONTH SHIFT
	177760			;BIC #
	0			;MULT. FACTOR 
	'/			;DELIMITER CHAR

	0			;DAY SHIFT  
	177740			;BIC #
	0			;MULT. FACTOR
	'/			;DELIMITER CHAR
	
	-9.			;YEAR SHIFT
	177600			;BIC #
	0			;MULT. FACTOR
	' 			;DELIMITER CHAR 

	-11.			;HOUR SHIFT
	177740			;BIC #
	0			;MULT. FACTOR
	':			;DELIMITER CHAR

	-5			;MINUTE SHIFT
	177700			;BIC #
	0			;MULT. FACTOR
	':			;DELIMITER CHAR

	0			;SECONDS/2 SHIFT
	177740			;BIC #
	1			;MULT. FACTOR
	'			;DELIMITER CHAR 


.IFNZ HALFLG
	H.1.1:	40214	;CONSTANT 1.1 FOR ORBIT HACK
		146315
.ENDC

;FLOATING POINT CONSTANTS
FLTTOL:	.WORD 35603,11156	;FLOATING POINT TOLERANCE 0.001
SIN120:	.WORD 40135,131730	;SIN 120 OR 0.86602544
COS120:	.WORD 140000,0		;COS 120 OR -0.5
SIN240:	.WORD 140135,131731	;SIN 240 OR -0.86602544
COS240:	.WORD 140000,0		;COS 240 OR -0.5
FPC0.1:	.WORD 37314,146314	;FLOATING CONSTANT 0.1

;THESE CONSTANTS USED BY ARCTAN ROUTINE ("ATAN")
PI:	40511		;PI = 3.141592653589793
	7732
	121041
	64303
PITWO:	40311		;PI/2 = 1.570796326794896
	7732
	121041			
	64303
ACOPI:	41545		;180/PI
	27340
	151436
	7675
TMNI:	30611		;10**-9	
	70137
	40466
	132246
ATANTB:			;ATAN TABLE					
B3:	40271		;1.448631538			
	66302
	15725
	1745
A3:	137607		;-.2647686202
	107700
	124610
	33414
B2:	40524		;3.316335425
	37326
	170074
	36637
A2:	140743		;-7.106760045
	65224
	5271
	66163
B1:	40730		;6.762139240
	61561
	152331
	105643
A1:	40555		;3.709256262
	62164
	60161
	76074
B0:	37462		;.1746554388
	154340
	13333
	126636



	.MACRO BEGER X,EN,F
X'.E::
FOO==.
	.ASCII /X/
	.=FOO+4
	BARF==0
	.IRPC Q,X
	BARF==<<''Q-'A+1>&17>+<BARF*20>
	.ENDM
	BARF
	.IFNZ ENG
	EN
	.ENDC
	.IIF NZ ENG&FR,.BYTE 0
	.IFNZ FR
	F
	.ENDC
	.BYTE 0
	.EVEN
	.ENDM

	.MACRO EROT A
	.BYTE A'.N
	.ENDM


	.MACRO ETEXT AA
	.ASCII \AA\
	.ENDM
ERRSRT:

MAXELN==0

BEGER BADD,<
ETEXT ^/BAD DIRECTORY./>,<
ETEXT ^/MAUVAIS UTILISATEUR/>

BEGER BADE,<
ETEXT ^/BAD ENTRY./>,<
ETEXT ^/MAUVAISE ENTREE/>

BEGER BAT,<
ETEXT ^/BAD ARRAY TYPE./>,<
ETEXT ^/MAUVAIS TYPE DE VECTEUR/>

BEGER BDD,<
ETEXT ^/BAD DISK./>,<
ETEXT ^/MAUVAIS DISQUE/>

BEGER BRK,<
EROT BRK>,<
EROT BRK>

BEGER BUG,<
EROT BUG>,<
EROT BUG>

BEGER CDE,<
ETEXT ^/CAN'T DELETE ENTRY./>,<
ETEXT ^/JE NE PEUX DETRUIRE CETTE ENTREE/>

BEGER CDF,<
ETEXT ^/CAN'T ERASE THAT FILE./>,<
ETEXT ^/NE PEUX DETRUIRE CE FICHIER/>

BEGER COP,<
ETEXT ^/CHAR /
EROT TYO
ETEXT ^/ OUT OF PLACE./>,<
ETEXT ^/CAR /
EROT TYO
ETEXT ^/ HORS POSITION/>

BEGER CRE,<
ETEXT ^/CAN'T READ THAT ENTRY./>,<
ETEXT ^/NE PEUX RAMENER CETTE ENTREE/>

BEGER CTIT,<
ETEXT ^/YOU ARE ALREADY DEFINING /
EROT CTIT>,<
ETEXT ^/VOUS ETES ENTRAIN DE DEFINIR /
EROT CTIT>

BEGER DFU,<
ETEXT ^/DISC FULL./>,<
ETEXT ^/LE DISQUE EST REMPLI/>

BEGER DIU,<
ETEXT ^/DEVICE IN USE./>,<
ETEXT ^/L'APPAREIL N'EST PAS DISPONIBLE/>

BEGER DNA,<
EROT PRS1
ETEXT ^/ IS NOT A DEVICE NAME./>,<
EROT PRS1
ETEXT ^/ N'EST PAS UN APPAREIL./>

BEGER DNR,<
ETEXT ^/DEVICE NOT READY./>,<
ETEXT ^/L'APPAREIL N'EST PAS PRET/>

BEGER DOR,<
ETEXT ^/DURATION OUT OF RANGE/>,<
ETEXT ^/DUREE TROP LONGUE/>

BEGER DRF,<
ETEXT ^/DIRECTORY FULL./>,<
ETEXT ^/PLUS DE PLACE/>

BEGER EAES,<
ETEXT ^/ENTRY ALREADY EXISTS./>,<
ETEXT ^/ENTREE DEJA EXISTANTE/>

BEGER ELW,<
EROT PRCT
ETEXT ^/ - EDIT LINE WHAT?/>,<
ETEXT ^/ EDITE QUELLE LIGNE??/>

BEGER ENDR,<
ETEXT ^/ENTRY NOT A DIRECTORY./>,<
ETEXT ^/CETTE ENTREE N'EST PAS CELLE D'UN UTILISATEUR/>

BEGER ERP,<
ETEXT ^/UNEXPECTED RIGHT PARENTHESIS./>,<
ETEXT ^/PARENTHESE DROITE SUPERFLUE/>

BEGER ERW,<
ETEXT ^/CAN'T ERASE "/
EROT PRCT>,<
EROT PRCT
ETEXT ^/ - EFFACE QUOI?/>

BEGER FAE,<
ETEXT ^/FILE ALREADY EXISTS./>,<
ETEXT ^/FICHIER DEJA EXISTANT/>

BEGER FAO,<
ETEXT ^/FILE ALREADY OPEN./>,<
ETEXT ^/FICHIER DEJA OUVERT/>

BEGER FBUG,<
ETEXT ^/FATAL SYSTEM BUG./
EROT GDBY>,<
ETEXT ^/BUG FATAL AU SYSTEME/
EROT GDBY>

BEGER FNF,<
ETEXT ^/FILE NOT FOUND./>,<
ETEXT ^/N'AI PAS TROUVE CE FICHIER/>

BEGER SIT,<
ETEXT ^/NOT IN SITS YET/>,<
ETEXT ^/N'EST EN SITS/>

BEGER HARD,<
ETEXT ^/HARDWARE ERROR/>,<
ETEXT ^/ERREUR DE MACHINERIE/>

BEGER HNM,<
ETEXT ^/YOU HAVEN'T TOLD ME HOW   TO /
EROT HNM>,<
EROT HNM
ETEXT ^/ N'EXISTE PAS./>

BEGER HNM1,<
ETEXT ^/YOU HAVEN'T TOLD ME HOW   TO /
EROT PRCT>,<
EROT PRCT
ETEXT ^/ N'EXISTE PAS./>

BEGER HNV,<
EROT PNAB
ETEXT ^/ HAS NO VALUE./>,<
EROT PNAB
ETEXT ^/ N'A PAS RECU DE VALEUR/>

BEGER IDN,<
ETEXT ^/IMPROPER DISPLAY NUMBER (UGH!)/>,<
ETEXT ^/CET ECRAN N'EXISTE PAS/>

BEGER IFN,<
EROT PRCO
ETEXT ^/ IS INVALID FILE NAME./>,<
EROT PRCO
ETEXT ^/ NE PEUT SERVIR COMME NOM DE FICHIER/>

BEGER INF1,<
EROT PRCO
ETEXT ^/ IS IN THE WRONG PLACE./>,<
EROT PRCO
ETEXT ^/ EST A LA MAUVAISE PLACE/>

BEGER INVN,<
ETEXT ^/INVALID NODE./>,<
ETEXT ^/NODE INVALIDE/>

BEGER ITN,<
ETEXT ^/A NONEXISTANT TURTLE?/>,<
ETEXT ^/NUMERO DE TORTUE INEXISTANT/>

BEGER IUN,<
ETEXT ^/INVALID USER./>,<
ETEXT ^/ON NE PEUT UTILISER CE NOM/>

BEGER IVV,<
ETEXT ^/INVALID VOICE NUMBER/>,<
ETEXT ^/NUMERO DE PISTE INEXISTANT/>

BEGER LCE,<
ETEXT ^/LINE ... CHANGED BY EDIT./>,<
ETEXT ^/LIGNE ... A ETE CHANGEE PAR EDITE/>

BEGER LDE,<
ETEXT ^/LINE /
EROT LDE1
ETEXT ^/ DOESN'T EXIST./>,<
ETEXT ^/LIGNE /
EROT LDE1
ETEXT ^/ INEXISTANTE/>

BEGER LNTB,<
ETEXT ^/LINE NUMBER TOO BIG./>,<
ETEXT ^/NUMERO DE LIGNE TROP GRAND/>

BEGER LNTS,<
ETEXT ^/LINE NUMBER TOO SMALL./>,<
ETEXT ^/NUMERO DE LIGNE TROP PETIT/>

BEGER NAS,<
ETEXT ^/NOT ENOUGH ARRAY SPACE./>,<
ETEXT ^/PAS ASSEZ D'ESPACE POUR LA MATRICE/>

BEGER NDU,<
ETEXT ^/YOU DON'T HAVE A DISPLAY CONSOLE/>,<
ETEXT ^/CE TERMINAL NE PEUT AVOIR UN ECRAN/>

BEGER NDV,<
ETEXT ^/NO DISPLAY AVAILABLE./>,<
ETEXT ^/PLUS D'ECRANS DISPONIBLES/>

BEGER NEC,<
EROT PRCT
ETEXT ^/ CAN'T BE EDITED./>,<
EROT PRCT
ETEXT ^/ N'EST PAS UN COMMANDEMENT D'EDITION/>

BEGER NED,<
ETEXT ^/DIRECTORY NOT FOUND./>,<
ETEXT ^/N'AI PAS TROUVE CET UTILISATEUR/>

BEGER NFO,<
ETEXT ^/NO FILE OPEN!/>,<
ETEXT ^/FICHIER N'EST PAS OUVERT!/>

BEGER NIP,<
ETEXT ^/NOTHING INSIDE PARENTHESES./>,<
ETEXT ^/LES PARENTHESES SONT VIDES/>

BEGER NOG,<
ETEXT ^/NOTE OUT OF RANGE/>,<
ETEXT ^/NOTE HORS LIMITE/>

BEGER NOU,<
EROT PRLO
ETEXT ^/ DIDN'T OUTPUT!/>,<
EROT PRLO
ETEXT ^/ N'A PAS PRODUIT D'OUTPUT/>

BEGER NSL,<
ETEXT ^/NO STORAGE LEFT./>,<
ETEXT ^/PLUS D'ESPACE DISPONIBLE/>

BEGER NTB,<
ETEXT ^/THORTON BOX SLOTS NOT AVAILABLE/>,<
ETEXT ^/IL N'Y A PAS DE TBOX/>

BEGER NTF,<
EROT PRS1
ETEXT ^/ NOT "TRUE OR "FALSE ./>,<
ETEXT ^/NI "VRAI NI "FAUX/>

BEGER NTVS,<
ETEXT ^/TVS CANNOT DO THIS FUNCTION/>,<
ETEXT ^/NOT ON TVS YOU DUMMY!/>

BEGER OTVS,<
ETEXT ^/ONLY ON TVS/>,<
ETEXT ^/ONLY ON TVS/>

BEGER OGT,<
ETEXT ^/ONLY ON 2500'S/>,<
ETEXT ^/ONLY ON 2500'S/>

BEGER OIP,<
ETEXT ^/ONLY WHEN DEFINING OR EDITING A PROCEDURE./>,<
ETEXT ^/POSSIBLE SEULEMENT A L'INTERIEUR D'UNE PROCEDURE/>

BEGER OOB,<
ETEXT ^/OUT OF BOUNDS/>,<
ETEXT ^/HORS LIMITE/>

BEGER OOP,<
EROT PRCO
ETEXT ^/ OUT OF PLACE./>,<
EROT PRCO
ETEXT ^/ HORS POSITION/>

BEGER OOT,<
ETEXT ^/OUT OF TOKENS./>,<
ETEXT ^/JE SUIS VIDEE/>

BEGER PAE,<
ETEXT ^/YOU HAVE ALREADY TOLD ME HOW   TO /
EROT PAE
EROT PRAB>,<
ETEXT ^/PROCEDURE /
EROT PAE
EROT PRAB
ETEXT ^/ DEJA EXISTANTE/>

BEGER PBE,<
EROT CTIT
ETEXT ^/ IS BEING EDITED./>,<
EROT CTIT
ETEXT ^/ EST SOUS EDITION/>

BEGER PNH,<
ETEXT ^/PROCEDURE /
EROT PRCT
ETEXT ^/ NOT HERE./>,<
ETEXT ^/LA PROCEDURE /
EROT PRCT
ETEXT ^/ N'EST PAS ICI/>

BEGER PNH1,<
EROT PNH1
ETEXT ^/PROCEDURE /
EROT PRAB
ETEXT ^/ NOT HERE./>,<
ETEXT ^/LA PROCEDURE/
EROT PRAB
ETEXT ^/ N'EST PAS ICI/>

BEGER ROB,<
ETEXT ^/INDEX REFERENCE OUT OF BOUNDS./>,<
ETEXT ^/INDEX DE REFERENCE HORS LIMITE/>

BEGER RTB,<
ETEXT ^/ARITHMETIC RESULT TOO BIG./>,<
ETEXT ^/NOMBRE TROP GRAND/>

BEGER SHW,<
ETEXT ^/CAN'T PRINTOUT "/
EROT PRCT>,<
EROT PRCT
ETEXT ^/ IMPRIME QUOI?/>

BEGER STDP,<
ETEXT ^/TOO MANY SNAPS./>,<
ETEXT ^/TROP DE PHOTOS/>

BEGER TDE,<
ETEXT ^/TTY /
EROT TDE
ETEXT ^/ DOESN'T EXIST./>,<
ETEXT ^/TERMINAL /
EROT TDE
ETEXT ^/ NON EXISTANT/>

BEGER TGDZ,<
ETEXT ^/INPUT TO RIGHT OR LEFT TOO LARGE/>,<
ETEXT ^/INPUT TROP GRAND/>

BEGER TIP,<
ETEXT ^/TOO MUCH INSIDE PARENTHESES./>,<
ETEXT ^/TROP DE PARENTHTHESES INTERIEURES/>

BEGER TMAC,<
ETEXT ^/"/
EROT PRCO
ETEXT ^/" CAN'T TAKE MORE THAN 32 ARGS./>,<
EROT PRCO
ETEXT ^/ NE PEUT RECEVOIR PLUS DE 32 INPUTS/>

BEGER TMAP,<
ETEXT ^/TOO MANY ARGS!!!/
EROT TMAP>,<
ETEXT ^/TROP D'INPUTS!!!/
EROT TMAP>

BEGER TML,<
ETEXT ^/TOO MANY LINES/>,<
ETEXT ^/TROP DE LIGNES/>

BEGER TNR,<
ETEXT ^/HELP! TURTLE NOT RESPONDING./>,<
ETEXT ^/AU SECOURS! LA TORTUE NE REPOND PAS/>

BEGER UBL,<
EROT PRCT
ETEXT ^/ IS USED BY LOGO./>,<
EROT PRCT
ETEXT ^/ EST UTILISE PAR LOGO/>

BEGER UDA,<
ETEXT ^/YOU HAVE NOT DEFINED ARRAY "/
EROT PRCT>,<
ETEXT ^/MATRICE NON DEFINIE/>

BEGER UEL,<
ETEXT ^/UNEXPECTED END OF LINE./>,<
ETEXT ^/ENONCE INCOMPLET/>

BEGER UELX,<
EROT PRCO
ETEXT ^/ NEEDS MORE INPUTS./>,<
EROT PRCO
ETEXT ^/ A BESOIN DE PLUS D'INPUT(S)/>

BEGER VTD,<
EROT PRCO
ETEXT ^/ NEEDS A TURTLE OR A DISPLAY/>,<
EROT PRCO
ETEXT ^/ AVEZ-VOUS DEMANDE UNE TORTUE OU UN ECRAN/>

BEGER VTU,<
EROT PRCO
ETEXT ^/ NEEDS A TURTLE/>,<
EROT PRCO
ETEXT ^/ AVEZ-VOUS DEMANDE UNE TORTUE/>

BEGER WDIM,<
ETEXT ^/BAD DIMENSION(S)./>,<
ETEXT ^/MAUVAISES DIMENSIONS/>

BEGER WDW,<
ETEXT ^/YOU DON'T SAY WHAT TO DO WITH /
EROT PRS1>,<
ETEXT ^/QUE DOIS-JE FAIRE AVEC /
EROT PRS1>

BEGER WIT,<
EROT PRCT
ETEXT ^/ CAN'T BE AN INPUT./>,<
EROT PRCT
ETEXT ^/ NE PEUT SERVIR D'INPUT/>

BEGER WNA,<
ETEXT ^/WRONG NUMBER OF ARGUMENTS TO /
EROT PRCO>,<
ETEXT ^/NOMBRE INCORRECT D'INPUTS POUR /
EROT PRCO>

BEGER WTA,<
EROT PRCO
ETEXT ^/ DOESN'T LIKE /
EROT PRS1
ETEXT ^/ AS INPUT./>,<
EROT PRCO
ETEXT ^/ N'AIME PAS RECEVOIR /
EROT PRS1
ETEXT ^/ COMME INPUT./>

BEGER WTAA,<
EROT PRCO
ETEXT ^/ DOESN'T LIKE /
EROT WTAA
EROT PRS1
ETEXT ^/ AS INPUT./>,<
EROT PRCO
ETEXT ^/ N'AIME PAS RECEVOIR /
EROT WTAA
EROT PRS1
ETEXT ^/ COMME INPUT./>

BEGER WTAB,<
EROT PRCO
ETEXT ^/ DOESN'T LIKE /
EROT WTAB
EROT PRS1
ETEXT ^/ AS INPUT./>,<
EROT PRCO
ETEXT ^/ N'AIME PAS RECEVOIR /
EROT WTAB
EROT PRS1
ETEXT ^/ COMME INPUT./>

BEGER WTIB,<
EROT PRCO
ETEXT ^/ DOESN'T LIKE /
EROT WTIB
ETEXT ^/ AS INPUT./>,<
EROT PRCO
ETEXT ^/ N'AIME PAS RECEVOIR /
EROT WTIB
ETEXT ^/ COMME INPUT./>

	.STITL ERROR MACROS

	.MACRO ERMM AA
	AA'.E
	AA==ERMNO
	ERMNO==ERMNO+1
	.ENDM

	.MACRO JROT A
.IIF NDF A'.R,A'.R==A
	.ENDM

	.MACRO ERRM A,C
	.IIF B C,JROT A
	.IIF NB C,A'.R==C
	A'.R
	A'.N==ERRNO
	ERRNO==ERRNO+1
	.ENDM

ERRNO==200
ERMNO==0
	.STITL ERROR TABLES


ROTTAB:	ERRM PNAB,PNODAB
	ERRM PRLO
	ERRM TYO
	ERRM PRCO
	ERRM PRS1
	ERRM PRCT
	ERRM GDBY,FBUGB
	ERRM CTIT
	ERRM HNM
	ERRM LDE1
	ERRM PAE
	ERRM PRAB,PROAB
	ERRM PNH1
	ERRM TMAP
	ERRM TDE
	ERRM BUG
	ERRM BRK
	ERRM WTA
	ERRM WTAA
	ERRM WTAB
	ERRM WTIB
ERTAB:	ERMM BADD	;BAD DIRECTORY
	ERMM BADE	;BAD ENTRY
	ERMM BAT	;BAD ARRAY TYPE
	ERMM BDD	;BAD DISK
	ERMM BRK	;BREAK!!
	ERMM BUG	;SYSTEM BUG!!
	ERMM CDE	;CAN'T DELETE ENTRY
	ERMM CDF	;CAN NOT DELETE THAT FILE
	ERMM COP	;CHAR (D) OUT OF PALCE
	ERMM CRE	;CAN'T READ THAT ENTRY
	ERMM CTIT	;CANT "TO" IN "TO"
	ERMM DFU	;DISC FULL
	ERMM DIU	;DEVIVE IN USE
	ERMM DNA	;INVALID DEVICE NAME
	ERMM DNR	;DEVICE NOT READY
	ERMM DOR	;DURATION OUT OF RANGE
	ERMM DRF	;DIRECTORY FULL
	ERMM EAES	;ENTRY ALREADY EXISTS
	ERMM ELW	;EDIT LINE WHAT?
	ERMM ENDR	;ENTRY NOT DIRECTORY
	ERMM ERP	;EXTRA RIGHT PAREN
	ERMM ERW	;ERASE WHAT??
	ERMM FAE	;FILE ALREADY EXISTS
	ERMM FAO	;FILE ALREADY OPEN
	ERMM FBUG	;FATAL SYSTEM BUG
	ERMM FNF	;FILE NOT FOUND
	ERMM SIT	;NOT IN SITS
	ERMM HARD	;HARDWARE ERROR
	ERMM HNM	;.(B). HAS NO MEANING
	ERMM HNM1	;..CT.. HAS NO MEANING
	ERMM HNV	;.(CT). HAS NO VALUE
	ERMM IDN	;INVALID DISPLAY NUMBER (UGH!)
	ERMM IFN	;A,,B IS INVALID FILE NAME
	ERMM INF1	;INFIX IN THE WRONG PLACE
	ERMM INVN	;INVALID NODE
	ERMM ITN	;INVALID TURTLE NUMBER
	ERMM IUN	;INVALID USER NAME
	ERMM IVV	;INVALID VOICE NUMBER
	ERMM LCE	;LINE ... CHANGED BY EDIT
	ERMM LDE	;LINE ..(B).. DOESN'T EXIST
	ERMM LNTB	;LINE # TOO BIG
	ERMM LNTS	;LINE # TOO SMALL
	ERMM NAS	;NO ARRAY STORAGE
	ERMM NDU	;NOT A DISPLAY USER
	ERMM NDV	;NO DISPLAY AVAILABLE
	ERMM NEC	;NOT AN EDITING COMMAND
	ERMM NED	;NON EXISTENT DIRECTORY
	ERMM NIP	;NOTHING INSIDE PARENS
	ERMM NOG	;NOTE OUT OF RANGE
	ERMM NOU	;NO OUTPUT
	ERMM NSL	;NO STORAGE LEFT
	ERMM NTB	;NO THORTON BOX SLOTS AVAILABLE
	ERMM NTF	;(S) NOT "TRUE" OR "FALSE"
	ERMM NTVS	;TVS CANNOT DO SNAPS AND ASSOCIATED FUNCTIONS
	ERMM OTVS	;ONLY ON TVS
	ERMM OGT	;ONLY ON 2500'S
	ERMM OIP	;ONLY IN PROCEDURE
	ERMM OOB	;OUT OF BOUNDS
	ERMM OOP	;(CO) OUT OF PLACE
	ERMM OOT	;OUT OF TOKENS
	ERMM PAE	;PROCEDURE (TEMP) ALREADY EXIXTS
	ERMM PBE	;PROCEDURE IS BEING EDITED
	ERMM PNH	;PROCEDURE .(CT). NOT HERE
	ERMM PNH1	;PROCEDURE .(CPP). NOT HERE
	ERMM ROB	;INDEX REFERENCE OUT OF BOUNDS
	ERMM RTB	;RESULT TOO BIG
	ERMM SHW	;SHOW WHAT??
	ERMM STDP	;SNAP TOO DEEP
	ERMM TDE	;TTY ..(E).. DOESN'T  EXIST
	ERMM TGDZ	;TURTLE GETTING DIZZY
	ERMM TIP	;TOO MUCH INSIDE PARENS
	ERMM TMAC	;TOO MANY ARGS (CURRENT PROC)
	ERMM TMAP	;TOO MANY ARGS (PROC BEING TO'ED)
	ERMM TML	;TOO MANY LINES
	ERMM TNR	;TURTLE NOT RESPONDING
	ERMM UBL	;USED BY LOGO
	ERMM UDA	;UNDEFINED ARRAY
	ERMM UEL	;UNEXPECTED END OF LINE
	ERMM UELX	;...(CO) NEEDS ARGS
	ERMM VTD	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE OR A DISPLAY
	ERMM VTU	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE
	ERMM WDIM	;BAD DIMENSIONS
	ERMM WDW	;YOU DON'T SAY WHAT TO DO WITH...
	ERMM WIT	;(CT) IS WRONG INPUT TO "TO"
	ERMM WNA	;WRONG NUMBER OF ARGUMENTS TO ..(CO)
	ERMM WTA	;..(CO)..DOESN'T LIKE..(CT)..AS INPUT
	ERMM WTAA	;..(CO)..DOESN'T LIKE..(A)...AS INPUT
	ERMM WTAB	;..(CO)..DOESN'T LIKE..(B)...AS INPUT
	ERMM WTIB	;..(CO)..DOESN'T LIKE..NUMBER IN B...AS INPUT
.STITL SYSTEM OBLIST

VARIABLE==4	;FOR VARIABLE NUMBER OF ARGUMENTS
YINFIX==20	;"YES INFIX" FLAG FOR OLE

;SOE FIELDS		1.==RIGHT BYTE (EVEN ADDR) 2.==LEFT BYTE
	;		1.1==RIGHT BIT  2.8==LEFT BIT
ABRFLG==1
FRFLG==2
ENGFLG==4
PFRFLG==10
	;1.4-1.8 UNUSED
	;2.1-2.2 "STANDARD" NO. OF INPUT ARGS
	;2.3 VNAF 1==CAN TAKE "ANY" NO. OF ARGS
	;2.5 INFIX 1==THIS IS AN INFIX PROCEDURE
	;2.6-2.8 PRECEDENCE

	.MACR NGPTWO A
	NGP2=NGP2*2
	FOO==A
	.IFLE NGP2-FOO
	NGPTWO A
	.ENDC
	.ENDM

;****************************************************
;MACRO TO DEFINE SYSTEM OBLIST ELEMENTS
;THE PARAMETERS ARE:
;1)	THE PRINT NAME
;2)	PRINT NAME OF ABBREVIATION
;3)	THE NAME OF THE POINTER TO THE OBLIST ELEMENT.
;4)	THE ADDRESS OF THE PROGRAM
;5)	THE PRECEDENCE.  A NUMBER FROM 0-7
;6)	THE NUMBER OF ARGUMENTS, AND THE SYMBOL "VARIABLE"
;		IF IT CAN ALSO TAKE A VARIABLE NUMBER OF ARGUMENTS
;7)	THE SYMBOL "YINFIX" IF THIS IS AN INFIX OPERATOR
	;8)	IF 0, DONT ASSEMBLE THIS PRIMITIVE



;VERSION FOR OBLIST ELEMENTS THAT ARE BOTH FRENCH AND ENGLISH
.MACR OLB PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG!FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG!FRFLG
.ENDC
.ENDC
.ENDM
;VERSION FOR ENGLISH ONLY
.MACR OLE PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ ENG
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG
.ENDC
.ENDC
.ENDC
.ENDM
;VERSION FOR FRENCH ONLY
.MACR OLF PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ FR
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,FRFLG
.ENDC
.ENDC
.ENDC
.ENDM
.MACR CDM A
A==<.-SOBLSU>/2
.ENDM

.MACR ABRV PN,OB,FLGS
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
OBLSTL==OBLSTL+4+OBL
.ENDC
.IF2
OBADD2-SOBLST
OBADD1=.
.=OBADD2
ABRFLG!FLGS
OB
TEXT ^\PN\
OBADD2=.
.=OBADD1
.ENDC
.ENDM
.MACR OLT PN,ABR,FPN,FAB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ ENG
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG
.ENDC
.ENDC
.IFNZ FR
.IF1
NUMOBS==NUMOBS+1
TEXT ^@FPN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@FPN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB FAB
ABRV FAB,OLEAD-SOBLST,FRFLG
.ENDC
.ENDC
.ENDC
.ENDM
;THE SYSTEM OBLIST
	;ADD ITEMS (EXCEPT FOR SPECIAL CHAR ITEMS) ALPHABETICALLY.

	.IF1
	NUMOBS==0
	.=.+4	;RESERVE SPACE FOR THE TWO WORDS ON PASS TWO
	.ENDC
	.IF2
SOBLSU=SOBLST+<NUMNSCOBS*2>-2
SOOMX=.
	2+SOBLSU	;2 > THAN HIGHEST ADDR USED IN SYS OBLIST
	NGP2==1
	NGPTWO SOBLSU-SOBLST+2
SOBP2=.
	NGP2	;( SMALLEST POWER OF 2 >= NUMOBS )*2
OBADD1=.
OBADD2=.+<2*NUMOBS>
OBSTRT=OBADD2	;WHERE THE SYSTEM OBLIST ELEMENTS START
	.ENDC

		;PRIORITIES
	PARPRI==1	; (  )
	BAKPRI==2	; _ __ IF TEST NOT BOTH EITHER
	RELPRI==3	; < = >
	PREPRI==4	;PRIORITY FOR MOST PREFIX PRIMITIVES
	PMPRI==5	; + -
	MDPRI==6	; * / \
	HIPRI==7	; : ! # -- ++
SOBLST:	OLB 0
	OLB .ASCII,,ASCI,ASCI,,1
	OLB .CASESW,,CASESW,CASESW,,1
	OLB .CGCF,,CGCF,CGCF
	OLB .CLOSE,,CLOSE,CLOSE,,1,,LSI-1
	OLB .CLOSEF,,,.CLOSF,,,,LSI-1
	OLB .COLOR,,,.COLOR,,1,,COLOR
	OLB .COLORINIT,,,.CLRINIT,,1,,COLOR
	OLB .CPNF,,CPNF,CPNF
	OLB .CTF,,CTF,CLRSTF
	OLB .CTYI,,CTYI,CTYI
	OLB .CTYO,,CTYO,CTYO,,1
	OLB .CURSET,,,,,2,,TVS
	OLB .ECHOSW,,ECHOSW,ECHOSW,,1
	OLB .FILEO,,,,,,,LSI-1
	OLB .FILEP,,,,,1,,LSI-1
	OLB .FILER,,,,,,,LSI-1
	OLB .GCOLL
	OLB .GTIOUT,,,,,1,,GTI
	OLB .NODES,,NODES,NODES
	OLB .OPENA,,,,,1,,LSI-1
	OLB .OPENR,,,,,1,,LSI-1
	OLB .OPENW,,,,,1,,LSI-1
	OLB .READPALETTE,,,.REAPAL,,1,,COLOR
	OLB .RUG,,RUG,RUNRUG
	OLB .SETFONT,,,,,2,,TVS
	OLB .SETTV,,SETTV,SETTV,,2,,LSI-1
	OLB .SGCF,,SGCF,SGCF
	OLB .SPNF,,SPNF,SPNF
	OLB .STATUS,,,STATUS
	OLB .STF,,,SETSTF
	OLB .SYSCHK,,,SYSCHK,,,,LSI
	OLB .TTYP,,,,,1,,LSI-1
	OLB .TVHERE,,,,,1,,TVS
	OLB .TVOMODE,,,,,2,,TVS
	OLB .TVP,,,,,,,TVS
	OLB .TVGRAB,,,TVGRAB,,1,,TVS
	OLB .TYI,,TYI,DEVTYI,,1,,LSI-1
	OLB .TYO,,TYO,DEVTYO,,2,,LSI-1
	OLB .VERSION,,VERSION,VERSN
	OLB .WRITEBLUE,,,.WRIBLUE,,2,,COLOR
	OLB .WRITEGREEN,,,.WRIGREEN,,2,,COLOR
	OLB .WRITEPALETTE,,,.WRIPAL,,2,,COLOR
	OLB .WRITERED,,,.WRIRED,,2,,COLOR
	OLE ALL,,,NOTPRO
	OLT ALSO,,AUSSI,,,,,,DDF
	OLB ANGLAIS,,,,,,,<ENG&FR>
	OLF ARBRE,,,NOTPRO
	OLB ARCTAN,ATAN,,ATAN,,1,,FPPF
	OLE ARRAY,,,NOTPRO
	OLE ARRAYS,,ARAYS,NOTPRO
	OLT ASIZE,,DIMMAT,,ASIZEX,,1
;	OLB ATOD,,,,,1,,AI&<LSI-1>
	OLT BACK,BK,RECULE,RE,,,1,,GTI!NPLOT!NDISP!TURFLG
	OLT BELL,,DING
	OLB BIGFONT,,,,,,,TVS
;	OLB BITOUT,,,,,1,,AI&<LSI-1>
	OLT BLINK,,CLIGNE,,,,,,GTI
	OLT BOTH,,LESDEUX,,,BAKPRI,2
;	OLB BOXIN,,,,,1,,AI&<LSI-1>
	OLT BTOUCH,,TOUCHEAR,,,,,,TURFLG
	OLE BURY
	OLT BUTFIRST,BF,SAUFPREMIER,SP,,,1
	OLT BUTLAST,BL,SAUFDERNIER,SD,,,1
	OLF CACHE,,,HIDETU,,,,GTI
	OLB CHAR,,,,,1
	OLT CLEARSCREEN,CS,VIDEECRAN,VE,,,,,NDISP!GTI
	OLB CLIP,,,,,,,TVS
	OLT CLOCK,,SECONDES,,,,,,LSI-1
	OLB CNTRL,,,,,,,DDF
	OLT CONTENTS,,CONTENU
	OLB CONTINUE,CO
	OLB COS,,,COSF,,1,,FPPF
	OLT COUNT,,COMPTE,,,,1
	OLB CRINDEX,,,.CRIND,,1,,LSI-1
	OLB CTYOWAIT,,,,,1,,LSI-1
	OLB CURSET,,,,,1,,TVS
	OLB DATE,,,UDATEG,,,,LSI-1
	OLB DEBUG,,,DEBUG
	OLT DEFINEARRAY,DEFAR,DEFMATRICE,DEFMAT,DEFAR,,3+VARIABLE
	OLT DELETE,ERF,DETRUIS,,.DELET,,1,,LSI-1
	OLT DELETEINDEX,ERI,DETRUISINDEX,,.DELI,,1,,LSI-1
	OLB DELTAXY,DELXY,,,,2,,GTI
	OLB DIFFERENCE,,,DIFF,,2
	OLE DISPLAY,,,,,1,,NDISP!GTI
	OLB DUMP,,,,,,,LSIHAK
	OLB ED,,,EDIT
	OLT EDIT,,EDITE
	OLB EDL,,,EDLINE
	OLB EDT,,,EDTITL
	OLT EITHER,,UNDE,,,BAKPRI,2
	OLE ELSE
	OLT EMPTYP,,VIDE,,EMPTYP,,1
	OLT END,,FIN
	OLF ENFOUIS,,,BURY
	OLB ENDFILE,,,,,,,LSI
	OLB ENGLISH,,,,,,,<ENG&FR>
	OLT EQUAL,IS,EGAL,,EQUAL,,2
	OLT ERASE,ER,EFFACE,EF
	OLB ERASERDOWN,ERD,,ERASED,,0,,COLOR
	OLB ERASERUP,ERU,,ERASEU,,0,,COLOR
;	OLB ERDOWN,ERD
	OLB ERBRK,,ERRBREAK,ERRBREAK
	OLB ERCLR,,ERRCLEAR,ERRCLEAR
	OLT ERL,,EFL
	OLB ERLIN,,ERRLINE,ERRLINE
	OLB ERLOC,,ERRLOCATION,ERRLOCATION
	OLB ERNAM,,,ERRNAM
	OLB ERNUM,,ERRNUMBER,ERRNUMBER
	OLB ERPRO,,ERRPROCEDURE,ERRPROCEDURE
	OLB ERRET,,RETURN,RETURN,,1
	OLB ERSET,,ERRSET,ERRSET
	OLB ERTOK,,ERRTOKEN,ERRTOKENî
;	OLB ERWINDOW,EW,,,,1+VARIABLE,,TVS
	OLF EXECUTE,,,DO,,1
;	OLE EYETURTLE,,,EYE,,1,,LSI-1
	OLF FICHIER,,,NOTPRO
	OLE FILE,,,NOTPRO
	OLT FIRST,F,PREMIER,PREM,,,1
	OLF FIXEDIR,,,SETHEA,,1,,GTI!NPLOT!NDISP
	OLT FORWARD,FD,AVANCE,AV,,,1,,GTI!NPLOT!NDISP!TURFLG
	OLT FPRINT,,ECRISC,,,,1+VARIABLE
	OLT FPUT,,INCLUSD,,,,2+VARIABLE
	OLB FRANCAIS,,,,,,,<ENG&FR>
	OLB FRANGLAIS,,,,,,,<ENG&FR>
	OLB FRENCH,,,,,,,<ENG&FR>
	OLT FTOUCH,,TOUCHEAV,,,,,,TURFLG
	OLT GET,,SORT,,,,2+VARIABLE
	OLT GO,,VA,,,,1
	OLT GOODBYE,,SALUT
	OLT GREATER,,PLUSGRAND,,GREATR,,2
	OLT GTIDIS,,GTIECRAN,,,,,,GTI
	OLB HALHACK,,,,,3,,HALFLG
	OLT HEADING,,CAP,,,,,,<NDISP!NPLOT>
	OLT HERE,,ICI,,,,,,<NDISP!NPLOT>
	OLT HIDETURTLE,HT,CACHETORTUE,CTT,,,,,NDISP!GTI
	OLB HIDEWINDOW,HW,,,,1+VARIABLE,,TVS
;	OLT HISSPEED,,SAVITESSE,,,,2,,DHON
	OLT HOME,H,ORIGINE,ORI,,,,,<NDISP!NPLOT!GTI>
	OLE IF,,,,BAKPRI,1
	OLT IFFALSE,IFF,SIFAUX,SIF
	OLT IFTRUE,IFT,SIVRAI,SIV
	OLB ILINE
	OLB INDEX,,,NOTPRO
	OLB INTEGER,INT,,,,1,,FPPF
	OLT LAMPOFF,,ETEINT,,,,,,TURFLG
	OLT LAMPON,,ALLUME,,,,,,TURFLG
	OLT LAST,L,DERNIER,DER,,,1
	OLT LEFT,LT,GAUCHE,GA,,,1,,GTI!NPLOT!NDISP!TURFLG
	OLT LESS,,PLUSPETIT,,LESSP,,2
	OLT LEVEL,,NIVEAU,,FLEV
;	OLT LIGHT,,LUMIERE,,,,,,LSI-1
	OLF LIGNE,,,NOTPRO
	OLE LINE,,,NOTPRO
	OLT LINEPRINT,LP,IMPRIMANTE,IMP,LPRINT,,1+VARIAB,,<LPF&AI>
	OLT LINEPRINT,LPT,IMPRIMANTE,IMP,LPRINT,,1+VARIAB,,<LPF&GUY>
	OLT LIST,,LISTE,,LIST.P,,2+VARIABLE
	OLT LISTP,,LISTEP,,LISTP,,1
	OLB LOAD,,,,,1-DMPCAS,,LSIHAK
	OLB LOAD2500,,,,,2,,LSI-1
	OLB LOCAL,,,,,1
	OLT LPUT,,INCLUSF,,,,2+VARIABLE
	OLT LTOUCH,,TOUCHEG,,,,,,TURFLG
	OLT MAIL,,MALLE,,,,1,,LSI-1
	OLT MAKE,,RELIE,,,,2
	OLB MAKEWINDOW,MW,,,,3,,TVS
	OLF MATRICE,,,NOTPRO
	OLF MATRICES,,MATRS,NOTPRO
	OLB MCLEAR,,,,,,,LSI-1
	OLT MLEN,,LONGM,,,,,,LSI-1
	OLF MONTRE,,,DISPLAY,,1,,NDISP!GTI
	OLT MOVETURTLE,MOVET,BOUGE,,MOVE,,1,,GTI
	OLB MUCTRL,,,,,1,,LSI-1
	OLB MUTYO,MUT,,,,2+VARIABLE,,LSI-1
	OLB MUWAIT,,,,,1,,LSI-1
	OLT MYSPEED,,MAVITESSE,,,,1
	OLE NAME,,,NOTPRO
	OLE NAMES,,,NOTPRO
	OLT NEWSNAP,,NOUVPHOTO,,,,,,NDISP
	OLB NOCLIP,,,,,,,TVS
	OLT NODISPLAY,ND,LIBECRAN,,KILLDISPLAY,,,,NDISP
	OLB NOGTI,,,,,,,GTI
	OLF NOM,,,NOTPRO
	OLF NOMS,,,NOTPRO
	OLT NOMUSIC,,LIBMUSIQUE,,,,,,LSI-1
	OLT NOPLOTTER,,LIBTRACEUR,,KILLPL,,,,NPLOT
	OLT NOT,,NON,,,BAKPRI,1
	OLE NOTBOX,,,,,,,PTBOX
	OLB NOTE,,,SING,,2+VARIABLE,,LSI-1
	OLT NOTURTLE,,LIBTORTUE,,KILLTURTLE,,,,TURFLG
	OLT NOWRAP,,DEBORDEPAS,,,,,,NDISP
	OLT NUMBERP,,NOMBREP,,NUMBP,,1
	OLT NVOICES,,NPISTES,,,,1,,LSI-1
	OLB OUTPUT,OP,,,,1
	OLF PASAPAS,,,STEP
	OLB PAUSE
	OLT PENDOWN,PD,DESCENDPLUME,DP
	OLT PENP,,PLUMEP,,,,,,TVS!NDISP
	OLT PENUP,PU,LEVEPLUME,LP,,,,,GTI!NPLOT!NDISP!TURFLG
	OLE PLOTTER,,,STRTPL,,,,NPLOT
	OLT PM,,JM,,,,,,LSI-1
	OLT POF,,IMF,,.POF,,1,,LSI-1
	OLT POI,,IMI,,.POI,,,,LSI-1
	OLB POINT,,,,,2+VARIABLE,,TVS
	OLF POINTE,,,SHOWTU,,,,GTI!TVS!NDISP
;POINT commands should have zero arguments as default, but this currently
;doesn't work for some reason...
	OLB POINTCOLOR,,,POINTCOLOR,,2+VARIABLE,,TVS
	OLB POINTSTATE,PS,,,,2+VARIABLE,,TVS
	OLT POL,,IML
	OLT POT,,IMT
	OLT POTS,,IMTS
	OLT PRINT,PR,ECRIS,EC,,,1+VARIABLE
	OLT PRINTOUT,PO,IMPRIME,IM,SHOW
	OLB PRINTSCREEN,PRS,,,,,,TVS
	OLB PROCEDURES,,,NOTPRO
	OLT PRODUCT,,PRODUIT,,PROD,,2+VARIABLE
	OLB QUOTIENT,,,DIVDE,,2
	OLT RANDOM,,HASARD
	OLT READ,,RAMENE,,.READ,,1,,LSI-1
	OLT READPTR,PTR,DECODE,,,,1+VARIABLE,,LSI-1
;	OLT RELAY,RELAIE,,,,,2,,AI&<LSI-1>
	OLT REMAINDER,MOD,RESTE,,MOD,,2
	OLT REQUEST,RQ,REPONSE,,RQUEST
	OLT RIGHT,RT,DROITE,DR,,,1
	OLT RTOUCH,,TOUCHED,,,,,,TURFLG
	OLT RUBDIS,,ENLEVE,,,,1,,GTI
	OLE RUN,,DO,DO,,1
	OLB SEETURTLE,,,SEETURTLE,,0,,TVS
	OLT SENTENCE,SE,PHRASE,PH,,,2+VARIABLE
	OLT SETHEADING,,METSLECAP,,,,1,,<NDISP!GTI!NPLOT>
	OLT SETINDEX,SETI,FIXEINDEX,FIXEI,.DIRSE,,1,,LSI-1
	OLT SETTURTLE,SETT,PLACETORTUE,,,,1,,<NDISP!NPLOT>
	OLT SETX,,FIXEX,,,,1,,<NDISP!NPLOT>
	OLT SETXY,,FIXEXY,,,,2,,<NDISP!GTI!NPLOT>
	OLT SETY,,FIXEY,,,,1,,<NDISP!NPLOT>
	OLT SHOWTURTLE,ST,TORTUEPOINTEE,TIP,,,,,NDISP!GTI
	OLB SHOWWINDOW,SW,,,,1+VARIABLE,,TVS
	OLF SI,,,IF,BAKPRI,1
	OLB SIN,,,SINEF,,1,,FPPF
	OLF SINON,,,ELSE
	OLB SMALLFONT,,,,,,,TVS
	OLT SNAP,,PHOTO,,,,,,NDISP!GTI
	OLB SPIN,,,,,1,,GTI
	OLT SQRT,,RCAR,,,,1,,FPPF
	OLT STARTDISPLAY,SD,ECRAN,,,,1,,NDISP
	OLE STEP,,.STEP
	OLB STOP
	OLB STORE,,,,,3+VARIABLE
	OLT SUM,,SOMME,,,,2+VARIABLE
;	OLB SWITCH,,,,,2,,AI&<LSI-1>
	OLE TBOX,,,,,,,PTBOX
	OLT TEST,,TESTE,,,BAKPRI,1
	OLT TEXT,,TEXTE,,TEXTT,,1
	OLT THEN,,ALORS
	OLT THING,,CHOSE,,DOTS,,1
	OLT THINGP,,CHOSEP,,,,1
	OLT TIME,,HEURE,,UTIMEG,,,,LSI-1
	OLE TITLE,,,NOTPRO
	OLE TITLES,,TITLS,NOTPRO
	OLF TITRE,,,NOTPRO
	OLF TITRES,,TITRS,NOTPRO
	OLT TO,,POUR
	OLT TOOT,,BEEP,,,,1,,TURFLG
	OLT TOPLEVEL,,NIVEAUSUP,,TOPLEVEL
	OLF TORTUE,,,STARTT,,1,,TURFLG
	OLF TOUT,,,NOTPRO
	OLB TRACE
	OLF TRACEUR,,TRAC,STRTPL,,,,NPLOT
	OLE TREE,,,NOTPRO
	OLB TRIANGLETURTLE,,,,,,,TVS
	OLB TTYP
	OLE TURTLE,,STTUR,STARTT,,1,,TURFLG
	OLB TURTLESIZE,,,TRSIZE,,1,,TVS
	OLB TVHERE,,,,,,,TVS
	OLB TVSIZE,,,RESIZE,,1+VARIABLE,,TVS
	OLB TVOMODE,,,,,1,,TVS
	OLB TYOWAIT,,,,,2,,LSI-1
	OLT TYPE,,TAPE,,,,1+VARIABLE
	OLT TYPEIN,,PREPONSE
	OLB UNTIL,,,,BAKPRI,1
	OLT USE,,REFERE,,.USE,,1,,LSI-1
	OLT VLEN,,LONGP,,,,,,LSI-1
	OLT VOICE,,PISTE,,,,1,,LSI-1
	OLT WAIT,,ATTENDS,,UWAIT,,1,,LSI-1
	OLT WHERE,,OU
	OLT WIPE,,DEGAGE,,,,1,,NDISP
	OLT WIPECLEAN,WC,BALAYE,,,,,,NDISP
	OLT WORD,,MOT,,,,2+VARIABLE
	OLT WORDP,,MOTP,,WORDP,,1
	OLT WRAP,,DEBORDE,DEB,,,,,NDISP
	OLT WRITE,,ENVOIE,,.WRITE,,1,,LSI-1
	OLT WRITEPTP,PTP,PERFORE,,,,1+VARIABLE,,LSI-1
	OLB XCOR,,,,,,,<NDISP!NPLOT>
	OLB XORDOWN,XD,,,,,,TVS&<LSI-1>
	OLB XORUP,XU,,,,,,TVS
	OLB XORWINDOW,XW,,,,1+VARIABLE,,TVS
	OLB YCOR,,,,,,,<NDISP!NPLOT>
	.IF1
NUMNSC==NUMOBS	;NUMBER OF NON-SPECIAL CHARACTER OBLIST ELEMENTS

	.ENDC
	OLB ^\!(\,,LLPAR,LLPAR,PARPRI,1
	CDM EXCL$
	OLB ^\!\,,COMT,COMT,HIPRI
	CDM HASH$
	OLB ^\#\,,PROC,PROC,HIPRI,1
	CDM LP$
	OLB ^\(\,,LPAR,LPAR,PARPRI,1
	CDM RP$
	OLB ^\)\,,RPAR,RPAR,PARPRI
	CDM PRD$
	OLB ^\*\,,STAR,PROD,MDPRI,2+VARIABLE,YINFIX
	CDM PLU$
	OLB ^\+\,,PLUS,SUM,PMPRI,2+VARIABLE,YINFIX
	OLB ^\++\,,UPLUS,UPLUS,HIPRI,1
	CDM MIN$
	OLB ^\-\,,MINUS,DIFF,PMPRI,2,YINFIX
	OLB ^\--\,,UMINS,UMINS,HIPRI,1
	CDM DIV$
	OLB ^\/\,,SLSH,DIVDE,MDPRI,2,YINFIX
	CDM DOTS$
	OLB ^\:\,,DOTS,DOTS,HIPRI,1
	CDM LSS$
	OLB ^\<\,,LESS,LESS,RELPRI,2,YINFIX
	CDM EQL$
	OLB ^\=\,,EQUAL,EQUAL,RELPRI,2,YINFIX
	CDM GTR$
	OLB ^\>\,,GRTR,GREATR,RELPRI,2,YINFIX
	CDM BKSL$
	OLB ^/\/,,BKSL,MOD,MDPRI,2,YINFIX
	CDM BKAR$
	OLB ^/_/,,BKAR,MAKE,BAKPRI,2,YINFIX
	OLB ^/__/,,TBKAR,MMAKE,BAKPRI,2,YINFIX

	.IF1
.=.+<NUMOBS*6>
	.ENDC
	.IF2
.=OBADD2
	.ENDC


.VERR==-128.
.VRTS==-128.
GCMKL:	TOPS
	TOPS1
	TOPS2
	GCP1
	GCP2
	GCPREV
	MVOC
	MVOC+2
	MVOC+4
	MVOC+6
	ILINEL	;PTR TO TYPED INPUT LINE
	ERPROC	;PTR TO ERRSET PROC
	.IIF NZ NDISP, SNLIST
	0


SECRET:	TEXT ^/SECRET/


	.STITL GARBAGE COLLECTOR MARK-NODE TABLES

BMT:	.BYTE 1,2,4,10,20,40,100,200
LMT:	MARKV2	;SYSTEM FUNCTION
	MARKV2	;INFIX (SYSTEM FUNCTION)
	MKATOM	;USER FUNCTION
	MKATOM	;VARIABLE BINDING
	GCDIE	;IDLE NODE
	GCDIE	;UNUSED
	GCDIE	;BUCKET ELEMENT
	MARKV2	;SHORT STRING
	.IFNZ NDISP
	MKSNAP	;SNAP
	.ENDC
	.IFZ NDISP
	GCDIE
	.ENDC
	MKATOM	;ATOM
	MARKV2	;SHORT NUMBER
	MKINUM	;INTEGER NUMBEB
	MKLIST	;LONG STRING
.IFZ FPPF
	GCDIE	;TBA
.IFF
	MKINUM
.ENDC
	GCDIE	;UNUSED (WAS "SENTENCE" ONCE)
	MKLIST	;LIST

	.STITL OTHER TABLES

;THE DISPATCH TABLE FOR CONVERT

CNVTBL:
	.BYTE CNVNOP	;SNAP TO SNAP
REPT1 7,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE 0	;ATOM TO SNUM
	.BYTE 0	;ATOM TO INUM
	.BYTE CA2LS	;ATOM TO LSTR
REPT1 3,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;SNUM TO SNUM
	.BYTE CSN2IN	;SNUM TO INUM
	.BYTE CSN2LS	;SNUM TO LSTR
.IIF NZ FPPF,	.BYTE CSN2FN	;SNUM TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CIN2SN	;INUM TO SNUM
	.BYTE CNVNOP	;INUM TO INUM
	.BYTE CIN2LS	;INUM TO LSTR
.IIF NZ FPPF,	.BYTE CIN2FN	;INUM TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CLS2SN	;LSTR TO SNUM
	.BYTE CLS2IN	;LSTR TO INUM
	.BYTE CNVNOP	;LSTR TO LSTR
.IIF NZ FPPF,	.BYTE CLS2FN	;LSTR TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

.IFNZ FPPF

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME (RNUM TO ANYTHING)
	.BYTE CFN2SN	;FNUM TO SNUM
	.BYTE CFN2IN	;FNUM TO INUM
	.BYTE CFN2LS	;FNUM TO LSTR
	.BYTE CNVNOP	;FNUM TO FNUM
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME


.IFF

REPT1 8.,^\.BYTE 0\


.ENDC

REPT1 6,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;SENT TO SENT
REPT1 1,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 7,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;LIST TO LIST

.IIF NZ .-CNVTBL-100,.PRINT /CONVERT TAB SCREWED UP!/
	.EVEN

		;MUSIC BOX CHARACTERS

	MBTRAP==43	;TRAP CHARACTER
	MBFCH==100	;SHUT-UP CHARACTER
	MBREST==40	;REST CHARACTER FOR MUSIC BOX
	MBPERC==42	;HIGHEST CODED PERCUSSION EFFECT

MBVCH:	.BYTE	123,42,61,60	;CTL CHARACTERS FOR NUMBER OF VOICES
MBSCH:	.BYTE	103,102,101,100	;LIKE MBVCH, EXCEPT SPECIFIES SILENCE


STURF:	.BYTE 101.,36.,68.,19.	;TURTLE FUDGE FACTORS FOR LEFT AND RIGHT
;	MULTIPLY BY EVEN BYTE AND DIVIDE BY ODD BYTE
.IFZ FPPF

;BEAUTIFUL SINE TABLE IN WHOOPIE FORMAT


SIN:

	0	;0 DEGREES
	2167	;2 DEGREES
	4355	;4 DEGREES
	6541	;6 DEGREES
	10720	;8 DEGREES
	13072	;10 DEGREES
	15234	;12 DEGREES
	17367	;14 DEGREES
	21510	;16 DEGREES
	23615	;18 DEGREES
	25707	;20 DEGREES
	27763	;22 DEGREES
	32017	;24 DEGREES
	34034	;26 DEGREES
	36027	;28 DEGREES
	40000	;30 DEGREES
	41724	;32 DEGREES
	43623	;34 DEGREES
	45474	;36 DEGREES
	47315	;38 DEGREES
	51106	;40 DEGREES
	52646	;42 DEGREES
	54352	;44 DEGREES
	56023	;46 DEGREES
	57437	;48 DEGREES
	61015	;50 DEGREES
	62335	;52 DEGREES
	63615	;54 DEGREES
	65035	;56 DEGREES
	66214	;58 DEGREES
	67331	;60 DEGREES
	70404	;62 DEGREES
	71413	;64 DEGREES
	72357	;66 DEGREES
	73255	;68 DEGREES
	74107	;70 DEGREES
	74674	;72 DEGREES
	75412	;74 DEGREES
	76062	;76 DEGREES
	76463	;78 DEGREES
	77016	;80 DEGREES
	77301	;82 DEGREES
	77514	;84 DEGREES
	77660	;86 DEGREES
	77754	;88 DEGREES
	77777	;90 DEGREES
.ENDC

;PRINTOUT DISPATCH TABLE
.MACRO DT A,B
$'A
B
.ENDM
PODISP:
.IIF Z LSI,	DT INDEX,.POI
	DT PROCED,SHALPR
.IFNZ ENG
	DT ALL,SHOWAL
.IIF Z LSI,	DT FILE,.POFILE
	DT TITLE,POT
	DT LINE,POL
	DT ARRAY,PO1AR
	DT ARAYS,POARR
	DT NAMES,SHALNA
.IIF Z LSI,	DT TREE,.POTREE
.ENDC
.IFNZ FR
	DT TOUT,SHOWAL
.IIF Z LSI,	DT FICHIER,.POFILE
	DT TITRE,POT
	DT TITRS,POTS
	DT LIGNE,POL
	DT MATRICE,PO1AR
	DT MATRS,POARR
	DT NOMS,SHALNA
.IIF Z LSI,	DT ARBRE,.POTREE
.ENDC
	0

;ERASE DISPATCH TABLE
ERSDISP:	DT TRACE,ETRACE
.IIF Z LSI,	DT INDEX,ERINDX
	DT PROCE,ERALPR
.IFNZ ENG
	DT ALL,ERALL
	DT .STEP,ESTEP
	DT BURY,EBURY
.IIF Z LSI,	DT FILE,ERFI
	DT LINE,ERLINE
	DT NAMES,ERALNA
	DT NAME,ERNAME
	DT ARRAY,ERARAY
	DT ARAYS,ERARAS
.ENDC
.IFNZ FR
	DT TOUT,ERALL
	DT PASAPAS,ESTEP
	DT ENFOUI,EBURY
.IIF Z LSI,	DT FICHIER,ERFI
	DT LIGNE,ERLINE
	DT NOMS,ERALNA
	DT NOM,ERNAME
	DT MATRICE,ERARAY
	DT MATRS,ERARAS
.ENDC
	0
;DISPLAY DIRECTION CODES

DREC:	.BYTE 10
	.BYTE 0
	.BYTE 20
	.BYTE 30
	.BYTE 60
	.BYTE 70
	.BYTE 50
	.BYTE 40
	.EVEN
	.STITL SYSTEM DISPATCH TABLE (BYTE ONE)

;FLAG DEFINITIONS
FSF==200	;SPECIAL INPUT
FOF==100	;SPECIAL OUTPUT
FQF==20		;QUOTING
SEPF==4		;SEPARATOR
WSF==2		;WORD SEPARATOR
NNUMF==40	;NOT A NUMBER
OPERF==10	;OPERATOR

DTBL:
.BYTE	NNUMF,FOF!NNUMF		;^@	;^A ECHOES AS CR
.BYTE	FSF!NNUMF,FSF!NNUMF	;^B IS CONVERTED TO %
				;^C COPYS NEXT CHARACTER
.BYTE	FSF!NNUMF,NNUMF		;^D DELETES NEXT CHARACTER	;^E
.BYTE	NNUMF,FSF!FOF!NNUMF	;^F	;^G BREAK
.BYTE	FOF!NNUMF,FOF!SEPF!WSF!NNUMF	;^H BACKSPACE	;^I TABULATE
.BYTE	FOF!SEPF!WSF!NNUMF,FOF!SEPF!WSF!NNUMF	;^J LINE FEED
				;^K TABULATE VERTICALLY
.BYTE	FOF!SEPF!WSF!NNUMF,FSF!FOF!SEPF!WSF!NNUMF	;^L FORM FEED
				;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	FSF!NNUMF,NNUMF		;^N GET NEXT WORD	;^O
.BYTE	NNUMF,FSF!NNUMF		;^P	;^Q SUPER-QUOTE
.BYTE	FSF!NNUMF,FSF!NNUMF	;^R COPY REST OF LINE
				;^S SKIP NEXT WORD
.BYTE	NNUMF,NNUMF		;^T	;^U
.BYTE	NNUMF,FSF!NNUMF		;^V	;^W ERASE LAST WORD
.BYTE	FSF!NNUMF,FSF!NNUMF	;^X CLARIFY INPUT
				;^Y EDIT PREVIOUS LINE
.BYTE	FSF!NNUMF,NNUMF		;^Z DESTROY INPUT BUFFER
				;^[ MAYBE ALTMODE
.BYTE	NNUMF,NNUMF		;^\	;^]
.BYTE	NNUMF,NNUMF		;^^	;^_ ANY BETTER IDEAS FOR THEM?
.BYTE	SEPF!WSF!NNUMF,NNUMF!SEPF!OPERF	;SP	;! COMMENT?
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;"	;# ACTION OF
.BYTE	NNUMF,NNUMF		;$	;%
.BYTE	NNUMF,NNUMF!OPERF	;&	;' (MAYBE LE)
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;( ARITHMETIC GROUPING
				;) DITTO
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;* MULTIPLY	;+ ADD
.BYTE	NNUMF,SEPF!NNUMF!OPERF	;,	;- SUBTRACT
.IIF NZ FPPF, .BYTE	0,SEPF!NNUMF!OPERF
.IIF Z FPPF, .BYTE	NNUMF,SEPF!NNUMF!OPERF	;.	;/ DIVIDE
.BYTE	0,0	;0	;1
.BYTE	0,0	;2	;3
.BYTE	0,0	;4	;5
.BYTE	0,0	;6	;7
.BYTE	0,0	;8.	;9.
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF	;: THING OF	;; PROPERTY OF
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;<	;=
.BYTE	SEPF!NNUMF!OPERF,NNUMF	;>	;?
.BYTE	NNUMF,NNUMF		;@	;A
.BYTE	NNUMF,NNUMF		;B	;C
.IIF NZ FPPF,	.BYTE	NNUMF,0
.IIF Z FPPF, .BYTE	NNUMF,NNUMF		;D	;E
.BYTE	NNUMF,NNUMF		;F	;G
.BYTE	NNUMF,NNUMF		;H	;I
.BYTE	NNUMF,NNUMF		;J	;K
.BYTE	NNUMF,NNUMF		;L	;M
.IIF NZ FPPF,	.BYTE	0,NNUMF
.IIF Z FPPF,	.BYTE	NNUMF,NNUMF		;N	;O
.BYTE	NNUMF,NNUMF		;P	;Q
.BYTE	NNUMF,NNUMF		;R	;S
.BYTE	NNUMF,NNUMF		;T	;U
.BYTE	NNUMF,NNUMF		;V	;W
.BYTE	NNUMF,NNUMF		;X	;Y
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF	;Z	;[
.BYTE	SEPF!NNUMF!OPERF,FSF!FQF!SEPF!WSF!NNUMF	;\ MODULO	;]
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;^	EXPONENTIATE, MAYBE
				;_ MAKE
.BYTE	NNUMF,NNUMF		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	NNUMF,NNUMF		;b LOWER CASE	;c LOWER CASE
.BYTE	NNUMF,NNUMF		;d LOWER CASE	;e LOWER CASE
.BYTE	NNUMF,NNUMF		;f LOWER CASE	;g LOWER CASE
.BYTE	NNUMF,NNUMF		;h LOWER CASE	;i LOWER CASE
.BYTE	NNUMF,NNUMF		;j LOWER CASE	;k LOWER CASE
.BYTE	NNUMF,NNUMF		;l LOWER CASE	;m LOWER CASE
.BYTE	NNUMF,NNUMF		;n LOWER CASE	;o LOWER CASE
.BYTE	NNUMF,NNUMF		;p LOWER CASE	;q LOWER CASE
.BYTE	NNUMF,NNUMF		;r LOWER CASE	;s LOWER CASE
.BYTE	NNUMF,NNUMF		;t LOWER CASE	;u LOWER CASE
.BYTE	NNUMF,NNUMF		;v LOWER CASE	;w LOWER CASE
.BYTE	NNUMF,NNUMF		;x LOWER CASE	;y LOWER CASE
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF		;Z LOWER CASE	;LEFT BRACE
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF		;VERTICAL BAR	;RIGHT BRACE
.BYTE	NNUMF,FSF!NNUMF		;TILDE	;RUBOUT
	.STITLE SYSTEM DISPATCH TABLE (BYTE TWO)
;NUMBERS POINT TO OTHER TABLES
;$ POINTS TO SYSTEM OBLIST

DTBL2:
.BYTE	0,0		;^@ 			;^A
.BYTE	36,0		;^B BECOMES %, PRINTS AS SPACE IN STRINGS
			;^C COPY NEXT CHARACTER
.BYTE 2,0		;^D DELETES NEXT CHAR	;^E
.BYTE	0,4		;^F 			;^G BREAK
.BYTE	2,10		;^H BACKSPACE		;^I TABULATE
.BYTE	12,14		;^J LINE FEED		;^K TABULATE VERTICALLY
.BYTE	16,6		;^L FORM FEED
			;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	10,0		;^N GET NEXT WORD		;^O
.BYTE	0,12		;^P 			;^Q SUPER-QUOTE
.BYTE	14,16		;^R 			;^S SKIP NEXT WORD
.BYTE	0,0		;^T	;^U
.BYTE	0,20		;^V	;^W ERASE LAST WORD
.BYTE	22,24		;^X CLARIFY INPUT	;^Y
.BYTE	26,0		;^Z DESTROY INPUT BUFFER
			;^[ MAYBE ALTMODE
.BYTE	0,0		;^\	;^]
.BYTE	0,0		;^^	;^_ WELL, ANY BETTER IDEAS FOR THEM?
.BYTE	0,EXCL$		;SP	;! COMMENT?
.BYTE	0,HASH$		;"	;# ACTION OF
.BYTE	0,0		;$	;%
.BYTE	0,0		;&	;' (MAYBE LE)
.BYTE	LP$,RP$		;( ARITHMETIC GROUPING	;) DITTO
.BYTE	PRD$,PLU$	;* MULTIPLY	;+ ADD
.BYTE	0,MIN$		;,	;- SUBTRACT
.BYTE	0,DIV$		;.	;/ DIVIDE
.BYTE	0,0		;0	;1
.BYTE	0,0		;2	;3
.BYTE	0,0		;4	;5
.BYTE	0,0		;6	;7
.BYTE	0,0		;8.	;9.
.BYTE	DOTS$,0		;: THING OF	;; PROPERTY OF
.BYTE	LSS$,EQL$	;<	;=
.BYTE	GTR$,0		;>	;?
.BYTE	0,0		;@	;A
.BYTE	0,0		;B	;C
.BYTE	0,0		;D	;E
.BYTE	0,0		;F	;G
.BYTE	0,0		;H	;I
.BYTE	0,0		;J	;K
.BYTE	0,0		;L	;M
.BYTE	0,0		;N	;O
.BYTE	0,0		;P	;Q
.BYTE	0,0		;R	;S
.BYTE	0,0		;T	;U
.BYTE	0,0		;V	;W
.BYTE	0,0		;X	;Y
.BYTE	0,32		;Z	;[
.BYTE	BKSL$,34	;\ MODULO	;]
.BYTE	0,BKAR$		;^ (MAYBE EXPONENTIATE)		;_ MAKE
.BYTE	0,0		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	0,0		;b LOWER CASE	;c LOWER CASE
.BYTE	0,0		;d LOWER CASE	;e LOWER CASE
.BYTE	0,0		;f LOWER CASE	;g LOWER CASE
.BYTE	0,0		;h LOWER CASE	;i LOWER CASE
.BYTE	0,0		;j LOWER CASE	;k LOWER CASE
.BYTE	0,0		;l LOWER CASE	;m LOWER CASE
.BYTE	0,0		;n LOWER CASE	;o LOWER CASE
.BYTE	0,0		;p LOWER CASE	;q LOWER CASE
.BYTE	0,0		;r LOWER CASE	;s LOWER CASE
.BYTE	0,0		;t LOWER CASE	;u LOWER CASE
.BYTE	0,0		;v LOWER CASE	;w LOWER CASE
.BYTE	0,0		;x LOWER CASE	;y LOWER CASE
.BYTE	0,32		;z LOWER CASE	;{ OPEN BRACE
.BYTE	0,34		;| VERTICAL BAR, MAYBE OR, MAYBE XOR
			;} CLOSE BRACE
.BYTE	0,30		;~ TILDE, LOGICAL NOT	;RBO	RUBOUT

LPURBL==<.-PURAD>_-10.
.IIF GT .-PURAD-20000,.ERROR OOOPS!! TOO MUCH PURE STUFF!
.STITL LSI UTILITY FILES

.IFNZ LSI

.INSRT 11LOGO;LSITTY >

.INSRT 11LOGO;LSFLEM >

.ENDC
	.STITL USER VARIABLES
.STITL SYSTEM PRIMITIVES
.IFZ LSI
.IFNZ ENG&FR
ENGLIS:
ANGLAI:	MOV #ENGFLG,LANG
ENG1:	SEZ
	RTS PC
FRENCH:
FRANCAIS:	MOV #PFRFLG!FRFLG,LANG
	BR ENG1
FRANGLAIS:	BIS #ENGFLG!FRFLG,LANG
	BR ENG1
.ENDC

CLOCK:	SAVE <#SSTATS>	;THE SYSTEM STATUS BLOCK
	$SSTATUS	;FILL IT UP
	MOV STIME,B
	MOV STIME+2,A
	JSR PC,GRBAD	;MAKE NODE UP WITHT THE NUMBER IN IT
	BIS #INUM,C	;POINT TOT HE NUMBER
	JMP ORTC	;RETURN IT

UTIMEG:	MOV #HOUR+2,D
	BR UTIME1
UDATEG:	MOV #YEAR+2,D
UTIME1:	MOV #SECOND,E
	MOV #6,F
1$:	CLR (E)+
	SOB F,1$
	SAVE #SECONDS
	MOV #3,F
	.TIME
UTIME2:	MOV -(D),B
	JSR PC,PSHNUM
	SOB F,UTIME2
	MOV #3,D
	JMP SENT.

SETTV:	MOV #SECOND,A
	MOV #6,B
1$:	CLR (A)+
	SOB B,1$
	JSR PC,G1IARG
	SPUSH C
	BLT SETTV1
	JSR PC,G1IARG
	TST C
	BLT SETTV1
	CMP #6,C
	BLE SETTV1
	ASL C
	BIS #100000,(P)
	MOV (P)+,SECOND(C)
	SAVE <#SECOND>
	.TIME
SETRT:	SEZ
	RTS	PC
SETTV1:		ERROR+WTA

UWAIT:	JSR PC,G1IARG
	SAVE <B,C>
SLWAIT:	$SLEEP
	SEZ
	RTS PC
.ENDC
;THIS IS THE STUFF FOR ARRAY HACKING
AMAKE:	MOV 4(SP),D	;NO. OF ARGS
	ASL D
	ADD S,D
	MOV -(D),A	;ADDR OF ARRAY NAME
AMAKE5:	MOV A,B
	BIC #7777,A
	CMP #ATOM,A	;IS A TYPE ATOM?
	BNE AMAKE3	;NO
AMAKE4:	MOV #ABIND,A
	JSR PC,.BINDL
	BEQ AMAKE6
	CLR TOPS
	RTS PC
AMAKE3:	CMP #LSTR,A	;IS A TYPE LSTR?
	BNE AMAKE2	;YES
AMAKE1:	BIT #7777,B	;NULL POIMTER?
	BEQ AMAKE2	;YES
	MOV B,TOPS
	JSR PC,.OBSCH	;GET ATOM
	BNE AMAKE4
AMAKE6:	ERROR+UDA
AMAKE2:	ERROR+WTAB



ARRAD:	MOV B,E
	SPUSH E	;TOP OF ARRAY HEADER
	CMPB 4(E),F	;IS DIM=NO. OF INDICES?
	BEQ ARRAD1	;YES
	ERROR+WNA	;WRONG NO OF ARGS
ARRAD1:	CLR A	;TEMP ACCUMULATOR
	ADD #12,E	;LENGTH OF DIMENSION IN E
ARRAD2:	JSR PC,G1NARG	;GET INDEX OFF S-PDL
	CMP B,(E)	;INDEX IN BOUNDS?
	BGE ARRAD4	;NO
	TST B	;NEGATIVE INDEX?
	BGE .+4	;INDEX OK
ARRAD4:	ERROR+ROB
	ADD B,A
	DEC F
	BEQ ARRAD3	;MORE INPUT
	MUL -(E),A
	MOV B,A
	BR ARRAD2
ARRAD3:	SPOP E	;ADDR OF ARRAY HEADER
	TSTB 5(E)	;IS TYPE PTR?
	BEQ 1$
	ASL A
1$:	ASL A		;TOTAL OFFSET (A*4)
	ADD #HEADER,A	;ADDR OF FIRST VALUE
	ADD E,A		;ADDR OF VALUE TO BE STORED
	RTS PC

STORE:	JSR PC,AMAKE
	SPOP	A	;RETURRN ADDR
	SPOP F		;NO. OF ARGUMENTS
	SPUSH	A
	SUB #2,F
	POPS D		;VALUE TO BE STORED
	JSR PC,ARRAD	;FIND STORAGE LOCATION
	MOV A,F
	MOV 4(E),A
	MOV D,B
	BIC #7777,A
	BEQ STORE1
	JSR PC,CONVERT
	BNE 1$
	ERROR+WTAB
1$:	JSR PC,.LOADB
	MOV A,(F)+
STORE1:	MOV B,(F)	;VALUE IS NOW STORED
	ADD #2,S
	SEZ
	RTS PC


GET:	JSR PC,AMAKE
	SPOP	A	;RETURN ADDR
	SPOP F	;NO. OF ARGUMENTS
	SPUSH	A
	DEC F		;NO. OF INDICES
	JSR PC,ARRAD	;COMPUTE STORAGE LOCATION
	MOV A,F		;STORAGE LOCATION ADDR IN F
	MOV (F),C
	TSTB 5(E)	;TEST TYPE
	BEQ GET1	;TYPE 0 (PTR)
	MOV (F)+,A
	MOV (F),B
	JSR PC,GRBAD	;STORES VALUE IN NODE SPACE
	MOV 4(E),D
	BIC #7777,D
	BIS D,C		;SET TYPE ON PTR TO VALUE
GET1:	MOV C,@S	;PTR ON TOP OF S-PDL
	CLZ
	RTS PC

LIMIT==3
HEADER==20.
BKPTR==4
SIZE==2
;FORMAT OF ARRAY HEADER IS:
;	WORD 0	BACK POINTER TO ATOM BOUND TO THIS ARRAY
;	WORD 1	LENGTH OF STORAGE USED
;	WORD 2	TYPE (INUM, FNUM OR 0 FOR POINTER) + NUMBER OF DIMENSIONS
;	WORD 3	DIMENSION 3
;	WORD 4	DIMENSION 2
;	WORD 5	DIMENSION 1
;	WORDS 6,7,10 AND 11 ARE USED ONLY FOR WINDOWS
;A FREE ARRAY BLOCKS:
;	WORD 0	POINTER TO NEXT FREE BLOCK
;	WORD 1	LENGHT OF BLOCK
;	WORD 2	BACK POINTER TO PREVIOUS FREE BLOCK


	;INPUT--B HAS SIZE OF BLOCK TO BE ALLOCATED IN BYTES
	;OUTPUT--A HAS PTR.TO BLOCK IF ALLOCATION SUCESSFUL
	;        SECOND WORD OF BLOCK CONTAINS SIZE OF BLOCK IN BYTES
	;        AND SKIP RETURN


..ALLOC:	CMP	B,ASPACE	;SIZE OF ARRAY .LE. FREE SPACE?
	BGT ARREXP		;NO, TRY TO EXPAND
	PUSH	C
	MOV	AROVER,A	;GET FRE BLOCK PTR.
SRCBLK:	CMP	B,SIZE(A)	;IS BLOCK NOW POINTED AT BIG ENOUGH?
	BLE	OKALOC		;YES
	CMP	(A),AROVER	;CHAIN GONE THRU' ONCE?
	BEQ	CMPRES		;YES
	MOV	(A),A		;NEXT FREE BLOCK
	BNE	SRCBLK		;LAST BLOCK IN CHAIN?
	MOV	AFREE,A		;YES,START FROM THE BEGINNING
	CMP A,AROVER
	BNE SRCBLK

CMPRES:	JSR	PC,.PRESS	;GO COMPRESS THE ARRAY SPACE
	MOV	AROVER,A	;A POINTS TO FREE SPACE
OKALOC:	MOV SIZE(A),C
	SUB B,C
	CMP #HEADER+4,C
	BGE HOLE
	MOV	A,C		;TO ADDR.OF FREE BLOCK
	ADD	B,C		;ADD SIZE OF ALLOCATED BLOCK TO GET NEW FREE BLOCK ADDR.
	SUB	B,SIZE(A)	;GET SIZE OF NEW FREE BLOCK
	MOV	SIZE(A),SIZE(C)	;AND STORE IN SIZE FIELD OF NEW FREE BLOCK
	MOV B,SIZE(A)
	MOV	BKPTR(A),BKPTR(C)	;PTR. MANAGEMENT
	BEQ	NEWBK1		;IF THIS BLOCK FIRST OF CHAIN,SKIP
	MOV	C,@BKPTR(A)	;CHANGE FORWARD PTR. OF LAST BLOCK
NEWBK1:	MOV	(A),(C)		;FORWARD PTR. FOR NEW BLOCK
	BEQ	NEWBK3		;IF THIS BLOCK IS LAST IN CHAIN,SKIP
NEWBK2:	ADD	#BKPTR,(A)	;TO ACCESS BKPTR FIELD OF NEXT BLOCK
	MOV	C,@(A)		;AND CHANGE IT
NEWBK3:	MOV	C,AROVER	;UPDATE FREE BLOCK ROVING POINTER
	CMP	AFREE,A		;REQUIRED TO UPDATE AFREE?
	BNE	ALDONE		;NO
	MOV	C,AFREE		;YES
ALDONE:	SUB	SIZE(A),ASPACE	;UPDATE FREE SPACE AVAILABLE
	POP	C
	CLZ
	RTS PC

HOLE:	MOV	BKPTR(A),C	;TO LINK UP WITH BLOCK BEFORE THE ONE ALLOCATED
	BNE	NEWBK1		
	MOV (A),C		;MAKE THIS THE FIRST BLOCK
	CLR BKPTR(C)		;AND DONT HAVE IT HAVE A BACKPOINTER
	BR NEWBK3

.IFZ LSI

ARREXP:	MOV ASPACE,A	;AMOUNT OF FREE SPACE WE KNOW ABOUT
	ADD #<ARYHPG-ARYPG+1>_13.+ARYAD,A	;TOTAL POSSIBLE ARRAY SPACE
	SUB ARTOP,A	;AMOUNT ALREADY GOBBLED
	CMP B,A		;NOW THEN, IS THIS POTENTIALLY ENOUGH??
	BLE ARREX4
	BR ARREX1
ARREX3:	ADD #6,P
ARREX1:	SEZ		;TOO GREEDY
	RTS PC
ARREX4:	MOV B,A		;AMOUNT WE WANT
	SUB ASPACE,A	;AMOUNT WE HAVE
	ASH #-10.,A	;AMOUNT WE NEED IN 512 WORD BLOCKS
	SAVE <C,B,A>
ARREX2:	MOV #ARRHPG,A
	JSR PC,EXSPAC	;TRY TO EXPAND ARRAYS
	BEQ ARREX3	;NO LUCK
	MOV ARTOP,B	;OLD TOP OF ARRAYS
	ADD #2000,ARTOP	;NEW!
	MOV #2000,SIZE(B)	;SIZE OF "ARRAY" WE ARE "FREEING"
	JSR PC,.RELES	;FREE THE NEW SPACE
	DEC (P)		;IS THAT ENOUGH?
	BGE ARREX2	;NOT YET
	REST <A,B,C>
	BR ..ALLOC	;TRY IT AGAIN (THIS TIME SURE TO WIN!)

.IFF

ARREXP:	MOV ARTOP,A	;TOP OF ARRAY SPACE
	SAVE B
	DEC B		;XFORM B TO LEAST NUMBER OF
	BIC #1777,B	; 2000-BYTE BLOCKS >OR= B
	ADD #2000,B
	ADD B,A		;EXTEND ARRAY TOP
	CMP A,PPDTOP	;BUMP INTO PDL SPACE?
	BHI ARREXF
	MOV ARTOP,B	;SAVE OLD ARTOP
	MOV A,ARTOP	; AND MAKE NEW ONE
	SUB B,A		;DIFFERENCE IS SIZE OF NEW SPACE
	MOV A,SIZE(B)	;WHICH IS SIZE OF "ARRAY" WE ARE "FREEING"
	JSR PC,.RELES	;FREE THE NEW SPACE
	REST B
	BR ..ALLOC	;SUCCEED, RETURN TO ..ALLOC
ARREXF:	REST B
	SEZ		;SIGNAL LOSS, FLUNK OUT OF ..ALLOC
	RTS PC
.ENDC
	;RELEASE A BLOCK IN THE ARRAY SPACE
	;INPUT--B HAS PHYSICAL PTR TO BLOCK TO BE RELEASED
	;OUTPUT--B UNCHANGED. RELEASED BLOCK INSERTED INTO CHAIN OF FREE BLOCKS


.RELES:	ADD	SIZE(B),ASPACE	;UPDATE ASPACE
	TST	AFREE		;IS ARRAY SPACE EMPTY?
	BEQ	ONEBLK		;YES
	PUSH	A
	SPUSH	C
	SPUSH	D
	MOV	AROVER,C
	CMP	B,C		;ADDR OF RELEASED BLOCK > (AROVER)
	BHI CHAIN		;START TRYING TO INSERT AT AROVER
	MOV	AFREE,C		;OTHERWISE START AT AFREE
	CMP B,C
	BHI CHAIN
	MOV C,A			;SAVE POINTER TO THE OLD FIRST FREE BLOCK
	JSR PC,ONEBLK		;MAKE THE THE BLOCK WE ARE FREEING, FIRST
	MOV B,C			;GET POINTER TO THE END OF THIS BLOCK
	ADD SIZE(B),C
	CMP A,C			;IS IT THE SAME AS THE OLD AFREE?
	BNE .RELE1		;NO
	ADD SIZE(C),SIZE(B)	;HERE COMPRESS THE TWO BLOCK
	MOV (C),C		;GET POINTER TO NEXT BLOCK
	MOV C,(B)		;FIX THIS BLOCK TO POINT TO IT
	BR REDON1		;UPDATE THE BACK POINTER OF IT IF NEEDED
.RELE1:	MOV A,(B)
	MOV B,BKPTR(A)
	BR REDONE

CHAIN:	MOV	C,A		;A_CURRENT FREE BLOCK
	MOV	(A),C		;C_NEXT FREE BLOCK
	BEQ	LSTBLK		;CURRENT BLOCK IS LAST IN CHAIN
	CMP	C,B		;ADDR OF NEXT FREE > ADDR OF RELEASED?
	BLO	CHAIN		;NO,TRY NEXT ONE
	MOV	SIZE(B),D	;YES,START INSERTING THE RELEASED BLOCK
	ADD	B,D		;SIZE IN BYTESADDED TO (B) GIVES END OF RELEASED BLOCK
	CMP	C,D		;WHICH MIGHT BE ADJACENT TO NEXT FREE BLK
	BNE	LSTBLK		;NO
	ADD	SIZE(C),SIZE(B)	;YES,COLLAPSE THE TWO
	MOV	(C),C		;UPDATE FWDPTR
	CMP C,AROVER		;IS AROVER POINTING TO THIS BLOCK?
	BNE LSTBLK		;NO
	MOV B,AROVER		;WELL, NOW B IS THE AROVER

LSTBLK:	MOV	SIZE(A),D	;THIS FREE BLOCK 
	ADD	A,D		;MIGHT BE ADJACENT TO THE
	CMP	D,B		;RELEASED BLOCK
	BEQ	CONBLK		;YES
	MOV	C,(B)		;NO,JUST UPDATE PTR
	MOV	A,BKPTR(B)	;SIZE FIELD NEED NOT BE CHANGED
	MOV	B,(A)	
REDON1:	TST	C		;IF THIS FREE BLOCK IS LAST IN CHAIN
	BEQ	REDONE		;THEN NOTHING
	MOV	B,BKPTR(C)	;ELSE UPDATE BKPTR OF NEXT BLK
REDONE:	POP	D
	SPOP	C
	SPOP	A
	RTS	PC

ONEBLK:	MOV	B,AFREE		;RELEASED BLOCK IS THE ONLY FREE ONE
	MOV	B,AROVER
	CLR	(B)
	CLR	BKPTR(B)
	RTS	PC


CONBLK:	ADD	SIZE(B),SIZE(A)	;COLLAPSE
	MOV	C,(A)		;AND UPDATE PTR
	CMP B,AROVER		;DID AROVER POINT TO THE BLOCK WE COMPRESSED?
	BNE REDONE		;NO
	MOV A,AROVER		;WELL, MAKE AROVER POINT TO THE START FO THE BLOCK
	BR REDONE

.IFZ 1
	;THIS ROUTINE COMPRESS THE ARRAY SPACE BY STACKING FREE BLOCKS TOGETHER
	;AFREE POINTS TO FIRST FREE BLOCK IN THE CHAIN
	;FIRST WORD OF USED BLOCK MUST CONTAIN PTR. TO WORD POINTING TO THAT BLOCK FOR RELOCATING

.PRESS:	TST	AFREE		;ARE THERE ANY FREE BLOCKS?
	BNE	1$		;YES
	RTS	PC		;NO,DONE
1$:	PUSH	A
	SPUSH	B
	SPUSH	C
	SPUSH	D

	MOV	AFREE,A		;A_FIRST FREE BLOCK ADDR
MOVNXT:	MOV	A,B		;B_CURRENT FREE BLOCK ADDR
	MOV	(B),A		;A_NEXT FREE BLOCK ADDR
	BEQ	PSDONE		;IF NEXT FREE BLOCK ADDR = 0,DONE
	MOV	SIZE(B),C	;FREE BLOCK SIZE IN BYTES
	ADD	B,C		;PLUS FREE BLOCK ADDR=STARTING ADDR OF USED BLOCK

COLAPS:	MOV	SIZE(C),D	;GET USED BLOCK SIZE
	ASR	D		;GET SIZE IN WORDS
	MOV	B,@(C)		;CHANGE PTRRR TO ARRAY		
	MOV	(C)+,(B)+	;BLOCK TRANSFER
	SOB	D,.-2		;COUNTER
	CMP	C,A		;THIS BLOC OF USED BLOCKS MOVED?
	BNE	COLAPS		;NO, CONTINUE FOR NEXT USED BLOCK
	TST	(A)		;WAS THIS THE LAST FREE BLOCK?
	BNE	MOVNXT		;NO, GET THE NEXT ONE
				;HERE B POINTS PAST THE LAST USED BLOCK
				;SO ALL SPACE AFTER IT IS MADE INTO ONE FREE BLOCK
PSDONE:
	.IFNZ LSI
	MOV ASPACE,A	;A_AMOUNT OF FREE ARRAY SPACE
PSDON1:	SUB #2000,A	;MINUS ONE BLOCK
	BLT PSDON2	;IF THAT WAS TOO MUCH, GO ON
	MOV A,ASPACE	;ELSE REDUCE FREE ARRAY SAPCE
	SUB #2000,ARTOP
	BR PSDON1

PSDON2:	
.ENDC
	MOV ASPACE,SIZE(B)	;LAST FREE BLOCK HAS ALL FREE SPACE
	MOV B,AFREE	;ONLY ONE FREE BLOCK
	MOV B,AROVER
	CLR (B)
	CLR BKPTR(B)
	SPOP D
	SPOP C
	SPOP B
	SPOP A
	RTS PC
.ENDC
	;THIS ROUTINE COMPRESS THE ARRAY SPACE BY STACKING FREE BLOCKS TOGETHER
	;AFREE POINTS TO FIRST FREE BLOCK IN THE CHAIN
	;FIRST WORD OF USED BLOCK MUST CONTAIN PTR. TO WORD POINTING TO THAT BLOCK FOR RELOCATING
.PRESS:	TST AFREE		;ANY FREE SPACE?
	BNE 1$			;YES
	RTS PC			;OH WELL....
1$:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D			;SAVE AC'S
	MOV AFREE,B		;B POINTS TO WHERE TO START COPYING TO
	MOV B,D			;AND D POINTS TO THE NEXT FREE BLOCK
MOVNXT:	MOV D,C			;GET POINTER TO START OF NEXT FREE BLOCK
	ADD SIZE(D),C		;MAKE C POINT TO THE USED BLOCK AFTER IT
	MOV (D),D		;AND UPDATE D TO POINT TO NEXT FREE BLOCK ON LIST
	BNE COLAPS		;THERE IS ANOTHER BLOCK, DONT WORRY ABOUT TOP OF ARRAY SPACE
	CMP C,ARTOP		;IS THIS FREE BLOCK THE LAST BLOCK IN ARRAY SPACE?
	BEQ PSDONE		;YES, WE ARE DONE
	MOV ARTOP,D		;PRETEND THAT THE END OF THE USED BLOCK IS THE END OF
				;ARRAY SPACE
COLAPS:	MOV SIZE(C),A		;GET THE LENGTH OF THE USED ARRAY
	ASR A			;TURN INTO NUMBER OF WORDS
	MOV B,@(C)		;UPDATE THE BINDING POINTER TO POINT TO THE NEW LOCATION
1$:	MOV (C)+,(B)+		;COPY THE ARRAY
	SOB A,1$
	CMP C,D			;HAVE WE COPIED THESE CONTIGUOUS USED ARRAYS
	BNE COLAPS		;NO, COPY THE NEXT USED ARRAY
	CMP D,ARTOP		;HAVE WE COPIED UP TO THE TOP OF ARRAY SPACE
	BNE MOVNXT		;NO, THEREFORE DO THE NEXT USED BLOCK
PSDONE:
.IFNZ LSI
	MOV ASPACE,A		;GET THE AMOUNT OF FREE ARRAY SPACE
PSDON1:	SUB #2000,A		;MINUS ONE BLOCK
	BLT PSDON2		;IF THAT WAS TOO MUCH TO TAKE AWAY, JUST RETURN
	MOV A,ASPACE		;CLAIM LESS FREE SPACE
	SUB #2000,ARTOP		;AND FREE IT FOR SOMEONE ELSE
	BR PSDON1		;FOR AS LONG AS WE CAN
PSDON2:
.ENDC
	MOV B,AROVER		;FROM NOW ON, ALLOCATE FROM HERE
	MOV B,AFREE		;B NOW POINTS TO THE FIRST AND ONLY FREE BLOCK
	MOV ASPACE,SIZE(B)	;ITS SIZE IS THE AMOUNT OF FREE STORAGE LEFT
	CLR (B)			;NO MORE BLOCKS OF FREE STORAGE
	CLR BKPTR(B)		;AND NO PREVIOUS ONE
	SPOP D
	SPOP C
	SPOP B
	SPOP A
	RTS PC

	;DEFINE AN ARRAY

DEFAR:	POP	A		;RETURN ADDR
	SPOP	F		;NO. OF ARGS PASSED
	SPUSH	A
	CMP	F,#LIMIT+2	;WHICH SHOULD BE < ALLOWABLE LIMIT
	BLE	OKARAY		;OKAY,THIS IS.
AERROR:	ERROR+WDIM
OKARAY:	SUB	#2,F		;DIMENSION OF ARRAY IN F
	MOV	F,A
	MOV	#1,D		;SET UP FOR MULTIPLICATION
	JSR	PC,G1NARG	;GET TYPE
	MOV	B,E		;SAVE IT
	BEQ	ALNUM		;0 FOR LNUM
	.IFNZ FPPF
	CMP	#1,B
	BEQ	AFNUM		;1 FOR FNUM
	.ENDC
	CMP #2,B
	BEQ NXTIDX	;2 FOR PTR
	ERROR+BAT
ALNUM:	BIS	#LNUM,F
	BR	NXTIDX
	.IFNZ FPPF
AFNUM:	BIS	#FNUM,F
;	BR	NXTIDX
	.ENDC
NXTIDX:	JSR PC,G1NARG	;GET MAGNITUDE OF LAST DIMENSION
	PUSH	B		;SAVE THIS DIMENSION
	MUL	B,D		;D IS ODD
	BLE	AERROR		;DIMENSION < 0
	BCS	AERROR		;DIMENSION TOO BIG
	SOB	A,NXTIDX
	SPUSH	F		;SAVE DIMENSION OF ARRAY
	BIT	#160000,D	;SIZE SHOULD NOT BE TOO BIG
	BNE	AERROR
	CMP	#2,E		;IS THIS PTR ARRAY
	BEQ	WALLOC
	ASL	D		;THIS IS DOUBLE PRECISION ARRAY
WALLOC:	ASL	D		;TO CONVERT TO BYTES
	ADD	#HEADER,D
	SPUSH	D		;SAVE SIZE OF ARRAY BLOCK
	MOV	@S,B		;GET NAME OF ARRAY
	MOV	B,A		
	BIC	#7777,A		;SEE WHETHER IT HAS BEEN INTERNED?
	CMP	#ATOM,A		;BY TESTING ITS TYPE
	BEQ	FABIND		;YES
	CMP	#LSTR,A		;NO,IS NAME ALL RIGHT
	BEQ	1$		;YES
	ERROR+WTAB
1$:	MOV	B,TOPS
	JSR	PC,UINTRN	;INTERN NAME OF ARRAY
	MOV	B,@S		;SAVE UOE PTR
FABIND:	CLR	TOPS		;NOT TO CHANGE BINDING
	MOV	#ABIND,A	;SEE IF AN ARRAY IS
	JSR	PC,.BIND	;BINDED TO THIS NAME
	BEQ	GETSPA		;NO
	MOV	C,@S		,SAVE PTR TO BINDING NODE
	MOV	B,C
	MOV 2(C),B
	ADD	ASPACE,B	;ADDED TO AVAILABLE FREE SPACE
.IFZ LSI
	ADD #<ARYHPG-ARYPG+1>_13.+ARYAD,B	;TOTAL POSSIBLE ARRAY SPACE
	SUB ARTOP,B		;AMOUNT OF CORE GOTTEN SO FAR
.ENDC
	CMP	B,(P)		;IS SUM ENOUGH FOR NEW BINDING?
	BGE	ERAOLD		;YES
FULL:	ERROR+NAS		;NOT ENOUGH SPACE
ERAOLD:	MOV	C,B
	JSR	PC,.RELES	;RELEASE OLD BINDING
;FALLS THROUGH
;FALLS IN
GETSPA:	SPOP B	;GET SIZE OF ARRAY
	MOV B,D		;SAVE IT
	JSR	PC,..ALLOC	;ASSIGN SPACE
	BEQ	FULL		;NOT ENOUGH
	SPOPS	B		;UOE PTR
	MOV	A,TOPS		;ARRAY PTR
BINDA:	MOV	#ABIND,A
	JSR	PC,.BIND	;BIND NEW ARRAY
	BIC	#170000,C	;PTR TO BINDING NODE
	ASL	C
	ASL	C
	ADD	#NODESP+2,C	;THIS IS PHYSICAL ADDR OF BINDING NODE
	MOV	TOPS,A		;PTR TO ARRAY
	MOV	C,(A)+		;BACK PTR FIRST ENTRY IN HEADER
	MOV (A)+,D	;SIZE OF ARAY SECOND
	SPOP	F
	MOV	F,(A)+		;DIMENSION OF ARRAY THIRD
	ADD	#LIMIT*2,A	;TO ADVANCE (A)
	BIC	#177400,F	;GET DIMENSION PART
	MOV	F,E
	ASL	E		;TO GET IT INTO BYTES
	SUB	E,A		;FOR OFFSET INTO HEADER
POPDIM:	SPOP	(A)+
	SOB	F,POPDIM
	MOV TOPS,A
	ADD #HEADER,A
	SUB #HEADER,D
	ASR D
	CLR (A)+	;ZERO ARRAY VALUES
	SOB D,.-2
	SEZ
	RTS	PC
ERARAY:	JSR	PC,GTUOEB	;GET NEXT TOKEN
	BNE	ERARA1
ERARA2:	CLR	TOPS
	MOV	#ABIND,A
	MOV	B,F
	JSR	PC,.BIND
	BEQ ERARAR
	JSR	PC,.RELES	;RELEASE ARRAY BLOCK
	MOV	F,B
	JSR PC,.UNBND
ERARAR:	SEZ
	RTS PC

ERARA1:	CMP	#UFUN,A
	BGT	1$
	ERROR+ERW
1$:	JSR	PC,CVSFLS
	MOV	#ATOM,A
	JSR	PC,.OBSCH
	BNE	ERARA2
ERARA3:	RTS PC


ERARAS:	JSR	PC,GNOLEI
ERARS1:	JSR	PC,GNOLE
	BEQ ERARAR
	MOV	B,F
	CLR	TOPS
	MOV	#ABIND,A
	JSR	PC,.BIND
	BEQ	ERARS1		;THIS NAME HAS NO ARRAY BINDING
	JSR	PC,.RELES	;RELEASE THIS ARRAYY
	MOV	F,B
	JSR	PC,.UNBND
	BR	ERARS1


;RETURNS SIZE OF ARRAY DIMENSIONS
ASIZEX:	POPS A		;GET THE ARRAY NAME
	JSR PC,AMAKE5	;FINDS THE START OF THE ARRAY
ASIZE2:	PUSH E
	MOV B,E
	MOVB 4(E),D	;TYPE/DIM WORD
	MOV D,F
	SPUSH D		;SAVE IT
	ASL D		;SETS UP OFFSET FOR DIMENSION WORD
	SUB D,E
	ADD #14,E	;ADDR. OF FIRST DIM.
ASIZE1:	MOV (E)+,B
	JSR PC,.CSNIN	;CONVERT TO INUM AND PUT IN NODE 
	SPUSHS C	;SAVE PTR ON S-PDL
	SOB F,ASIZE1	;CHECK FO MORE DIMS.
	SPOP D		;NO OF DIMS. IN D
	JSR PC,SENT.	;LINK DIMS. IN LIST
	POP E
	CLZ
	RTS PC


.IFNZ FPPF

;FLOATING POINT MACROS

.MACR FPUSH FF
	STF FF,-(P)
	JSR PC,PPUSHT
.ENDM

.MACR FPOP FF
	LDD (P)+,FF
	JSR PC,PPOPT
.ENDM

.ENDC


.IFZ FPPF

;SINGLE PRECISION ARITHMETIC ROUTINES

UPLUS:	CLZ	;UNARY PLUS - NOTHING TO DO
	RTS PC
UMINS:	JSR PC,G1IARG	;UNARY MINUS
	DPNEG	B,C
DONBC:	JMP	R1I.BC

SUM:
	EXCH (P),2(P)
	CLR	E
	CLR	F
	MOV	(SP)+,D	;NUMBER OF ARGS
	BLE	DIFF.2	;DONE
SUM.1:	JSR	PC,G1IARG	;GET 1 INTEGER
	DPADD	B,C,E,F
	DEC	D	;COUNTER
	BGT	SUM.1
	BR	DIFF.2	;DONE

DIFF:
	JSR	PC,G2IARG	;GET 2 INTEGERS
	DPSUB	B,C,E,F
DIFF.2:	CMP	E,#100000	;IS ANSWER = 100...00 ?
	BNE	DONEMP
	TST	F	;IF SO , THEN ERROR
	BNE	DONEMP
	ERROR+RTB	;SINCE THAT IS SMALLEST NEG NUMBER
DONEMP:	JMP	R1I.EF

PROD:
	EXCH (P),2(P)
	CLR	E
	MOV	#1,F
	MOV	(SP)+,D	;NUMBER OF ARGS
PROD.1:	DEC	D
	BLT	DONEMP	;DONE
	JSR	PC,G1IARG	;GET ONE ARG IN B
	JSR	PC,.DPMUL
	BNE PROD.1
	ERROR+RTB	;RESULT TOO BIG

MOD:
	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONBC
	ERROR+RTB

DIVDE:
DIV.1:	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONEMP
	ERROR+RTB


.ENDC


.IFNZ FPPF


;FLOATING POINT ARITHMETIC ROUTINES

ERRET:	ERROR+RTB
UPLUS:	CLZ
	RTS PC
UMINS:	MOV #INUM,F
	JSR PC,G1ARG
	LDD FA,FB
	NEGF FB
	BR .FSTOR	;STORE FB
DIFF:	JSR PC,G2ARG	;LOAD FA AND FB
	SUBF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
SUM:	EXCH (P),2(P)
	MOV #INUM,F
	CLRF FB
	SPOP D		;SET UP COUNTER
	BLE .FSTOR
SUM.1:	JSR PC,G1ARG	;GET A NUMBER
	ADDF FA,FB	
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT SUM.1	;ADD MORE NUMBERS
	BR .FSTOR	;DONE AT LAST
PROD:	EXCH (P),2(P)
	MOV #INUM,F
	LDCFD #40200,FB	;LOAD CONSTANT "1"
	SPOP D
	BLE .FSTOR	;DONE ALREADY
PROD.1:	JSR PC,G1ARG
	MULF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT PROD.1	;LOOK AT COUNTER

;FALLS THROUGH
;FALLS IN
;THIS TAKES A NUMBER OUT OF FB AND
;CONVERTS IT ACCORDING TO TYPE IN REG F (INUM,FNUM)
;AND RETURNS

.FSTOR:	CMP #FNUM,F	;FNUM OR INUM?
	BEQ .FST.2
	STCFI FB,-(P)	;PUT INUM ON STACK
	BCS ERRET	;OVERFLOW?
.FST.1:	SPOP A
	SPOP B
	JSR PC,GRBAD	;STORE ANSWER
	BIS F,C		;SET TYPE
	JMP ORTC
.FST.2:	STCDF FB,-(P)	;PUT FNUM ON STACK
	JMP .FST.1
DIVDE:	JSR PC,G2ARG	;GET ARGS
	TSTF FA		;TEST ZERO DIVIDE
	CFCC
	BEQ ERRET	;IT WAS!!??
	DIVF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
MOD:	JSR PC,G2ARG	;GET ARGUMENTS IN FA AND FB
	SPUSH #.FSTOR
.MOD:	TSTF FA		;IS FA 0?
	CFCC
	BEQ ERRET	;IT IS??
	LDD FB,FC	;FC <- FB
	DIVF FA,FC	;FC <- (FB/FA)
	CFCC
	BVS MOD2	;THE ANSWER IS 0
	MODD #40200,FC	;SEPERATE INTEGER AND FRACTION PARTS
	MULF FA,FD	;FD <- FA * (INT (FB/FA))
	SUBF FD,FB	;FB <- MOD (FB,FA)
MOD1:	CFCC
	BGE MOD3	;IS IT POSITIVE?
	ADDF FA,FB	;NO, ADD FA
	BR MOD1
MOD2:	CLRF FB
MOD3:	RTS PC


SQRT:	MOV @S,GCPREV	;SAVE THIS WORD
	JSR PC,G1NUM
	BNE SQRT2
SQRT1:	MOV GCPREV,B	;GET POINTER TO NUMBER OR ARGUMENT
	ERROR+WTAB
SQRT2:	TSTF FA
	CFCC
	BMI SQRT1
	BEQ SQRTRT
	CLR GCPREV	;NO NEED FOR THIS ANYMORE.
	LDF FA,FB
	STEXP FA,A
	LDEXP #0,FA
	ASR A
	ADC A
	ADDF #40000,FA
	BCS 1$
	ADDF #40000,FA
1$:	CLRF FC
	LDEXP A,FC
	MULF FC,FA
	MOV #4,A
SQRTLP:	LDF FB,FC	;FC <= X
	DIVF FA,FC	;FC <= X/Y
	ADDF FC,FA	;FA <= Y + X/Y
	MULF #40000,FA	;FA <= 1/2 * (Y + X/Y)
	SOB A,SQRTLP
SQRTRT:	MOV #FNUM,F
	STCDF FA,-(P)
	JMP .FST.1
.ENDC





SENTENCE:
	SPOP EXCH1
	MOV (SP),D
	MOV EXCH1,(SP)	;# OF ARGS . DON'T CHANGE FROM D WITHOUT CHANGING SNAP!!!!
SENT.:	CLR	C
	TST	D
SENT.1:	BLE	SENT.R	;RETURN
	MOV	@S,B	;ARGUMENT.  LEAVE ON S-PDL FOR GARBGE COLLECTOR
	MOV	B,A
	BIC	#7777,A	;LEAVE ONLY DATA TYPE
	CMP	#LIST,A
	BEQ	SENT.S	;ARG IS LIST
	CMP	#ATOM,A
	BNE	SENT.2	;ARG IS LSTR OR INUM

;ARG IS AN ATOM
SENT.A:	JSR	PC,.LOAD	;CONVERT ATOM TO LSTR
	MOV	#LSTR,A

SENT.2:	BIS	C,A	;C POINTS TO PREVIOUS STUFF OF SENTENCE
	JSR	PC,GRBAD

SENT.3:	MOV	C,GCPREV	;POINTER TO PREVIOUS STUFF OF SENTENCE
	BIS	#LIST,GCPREV	;GARBAGE COLLECTOR NEEDS RIGHT DATA TYPE
SENT.4:	JSR	PC,SPOPT	;POP S
	DEC	D	;COUNTER
	BR	SENT.1

SENT.S:	BIT	#7777,B	;ARGUMENT IS A LIST
	BEQ	SENT.4	;EMPTY
	TST	C	;0 IF FIRST TIME CALLED
	BEQ	SENS.1	;NO NEED TO COPY
;SECOND OR LATER TIME THROUGH
SENS.2:	JSR	PC,COPYL	;COPY LIST. RETURN POINTER IN B
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;C STILL POINTS TO LAST NODE COPIED
SENS.1:	BIC	#170000,B	;LEAVE POINTER ONLY
	MOV	B,C
	BR	SENT.3

;RETURN.  POINTER TO SENTENCE IN C
SENT.R:	BIS	#LIST,C
	CLR	GCPREV
	PUSHS	C
	CLZ
	RTS	PC



LIST.P:
	EXCH (P),2(P)
	MOV	(SP),D	;COUNT
	MOV	#ORTC,(SP)	;RETURN ADDRESS
LIST1:	CLR	C
LIST.1:	DEC	D	;COUNT
	BLT	LIST.9	;DONE
	MOV	@S,B
	MOV	B,A
	BIC	#7777,A	;LEAVE DATA TYPE ONLY
LIST.2:	BIS	C,A	;POINTER TO REST OF LIST
	JSR	PC,GRBAD
	MOV	C,GCPREV	;PROTECT FROM GARBAGE COLLECTOR
	BIS	#LIST,GCPREV	;GAR. COLL. NEEDS RIGHT DATA TYPE
	JSR	PC,SPOPT
	BR	LIST.1	;GET NEXT ARG

LIST.9:	CLR	GCPREV
	BIS	#LIST,C
	RTS	PC

FPUT:
	CLR	F
	BR	.+6
LPUT:
	MOV	#<LPUT1-FPUT1>,F
	EXCH (P),2(P)
	MOV	(SP),D	;NUMBER OF ARGS
	MOV	#ORTC,(SP)	;RETURN ADDRESS
	DEC	D
	BGT	1$
	ERROR+UEL	;NEED AT LEAST 2 ARGS
1$:	JSR	PC,GLWARG
	BEQ	2$	;LIST
	ERROR+WTA	;FIRST ARG MUST BE LIST
2$:	ADD	F,PC	;CHOOSE BETWEEN LPUT AND FPUT

FPUT1:	MOV	B,A	;POINTS TO ARG
	BIC	#170000,A	;CLEAR DATA TYPE
	JSR	PC,SPOPT
	MOV	@S,B	;FIRST ELEMENT TO BE PUT
	MOV	B,C
	BIC	#7777,C	;THIS DATA TYPE WILL BE SET INTO A
	DEC	D
	BR	LIST.2

LPUT1:	JSR	PC,COPYL	;COPY LIST. RETURN PTR IN B
	MOV	B,GCP1
	JSR	PC,SPOPT	;POP 1ST ARG
	JSR	PC,LIST1	;LIST REST OF ARGS
	TST F
	BEQ LPUT2
	BIC	#170000,C	;POINTER TO THAT LIST
	MOV	C,D	;SAVE IT
	MOV	F,C	;POINTER TO LAST NODE OF COPIED LIST
	JSR	PC,.LDP1
	BIS	D,A	;JOIN COPIED LIST TO LIST OF ARGS
	JSR	PC,.STP1
	MOV	GCP1,C
LPUT2:	CLR	GCP1
	RTS	PC


WORD:	CLR GCPREV	;USED AS A FLAG LATER
	EXCH (P),2(P)
	CLR	C
	MOV	(SP)+,D	;NUMBER OF ARGS
WORD.1:	BLE	WORDR
	MOV	@S,B	;GET ARG,  BUT LEAVE ON STACK

.IFZ FPPF
	CMP	B,#LNUM	;IS ARG NUMBER?
	BLO	WORD.2
	CMP	B,#<LNUM+10000>
	BLO	WORD.N	;NUMBER
.IFF
	MOV B,A		;DOES B POINT TO INUM OR FNUM
	BIC #170000,A
	CMP #INUM,A
	BEQ WORD.N
	CMP #FNUM,A
	BEQ WORD.N
.ENDC

WORD.2:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BNE 1$
	ERROR+WTAB
1$:	BIT	#7777,B	;IS ARG THE EMPTY WORD
	BEQ	WORD.4	;YES

	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3

;SECOND OR LATER ARG
WORD.5:	JSR	PC,CPYSTR	;COPY STRING
WORD.6:	JSR	PC,.LDP1	;LAST NODE OF COPIED STRING
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;BIS POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;STORE BACK

WORD.3:	BIC	#170000,B
	BIS	#LSTR,B	;GAR. COLL. NEEDS RIGHT DATA TYPE
	MOV	B,GCPREV	;POINTER TO PREVIOUS STUFF
WORD.4:	JSR	PC,SPOPT	;POP S
	DEC	D
	BR	WORD.1

;ARGUMENT IS NUMBER. CONVERT TO STRING
WORD.N:
.IFZ FPPF
	JSR PC,.CINLS
.IFF


.CLNLS:	MOV B,A
	BIC #170000,A
	CMP #INUM,A
	BEQ .CLNL1
	JMP .CINLS
.CLNL1:	JMP .CFNLS
.ENDC
	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3	;IS FIRST ARG
	BR	WORD.6	;SECOND OR LATER, BUT DON'T RECOPY!!

;RETURN
WORDR:	MOV	GCPREV,C
	BIS	#LSTR,C
	CLR	GCPREV
	JMP	ORTC



FIRST:
	JSR	PC,GLWANE
	BEQ	F.SENT	;ARG IS SENTENCE

;ARG IS WORD
	JSR	PC,INSTR	;RETURN ONE CHAR IN D
	BNE	.+4	;FOUND A CHAR
F.WTA:	ERROR+WTA	;NO CHARS IN STRING
	TST	(SP)+	;POP OFF CO-ROUTINE LINK
	MOV	D,B
F.STOR:	CLR	F
	JSR	PC,ACTSTO	;STORE THE CHAR.
	POPS C
	BIC #170000,C
	BIS	#LSTR,C	;POINTER TO THE NODE OF THE CHAR
	JMP	ORTNC

F.SENT:	MOV	B,C
	JSR	PC,.LDP2
	JMP	ORTNA


BUTFIRST:
	JSR	PC,GLWANE
	BEQ	BF.SEN

;ARG IS WORD
BF.W:	JSR	PC,INSTR	;RETURN ONE CHAR
	BEQ	F.WTA	;NO CHARS IN STRING
	TST	(SP)+
;A CONTAINS FIRST 2 CHARS OF THE STRING
;BUT IT MAY ONLY HAVE ONE.
	BIT	#177,A	;IS TOP CHAR OF A 0?
	BEQ BF.W1
	BIT #77400,A
	BEQ	BF.W1	;YES. ONLY ONE CHAR IN A
	CLRB	A	;KILL THE FIRST CHAR
	MOV	A,B
	MOV	C,A	;POINTER TO REST
	JSR	PC,GRBAD
BF.W1:	BIC	#170000,C
	BIS	#LSTR,C
	JMP	ORTNC

;ARG IS SENTENCE
BF.SEN:	MOV	B,C
	JSR	PC,.LDP1	;POINTER TO REST OF SENTENCE
	BIC	#170000,A	;LEAVE ONLY POINTER
	BIS	#SENT,A
	JMP	ORTNA


LAST:
	JSR	PC,GLWANE
	BEQ	L.SENT	;ARG IS SENTENCE

;ARG IS WORD
	MOV	B,C
	SPUSH	#INSTR1	;ADDRESS OF CO-ROUTINE
	CLR	D
L.W1:	MOV	D,B	;SAVE LAST CHAR
	JSR	PC,@(SP)+	;RETURNS CHAR IN D
	BNE	L.W1	;FOUND ONE
	TST	B	;STRING DONE
	BNE	F.STOR	;STORE THE CHAR AND RETURN
	ERROR+WTA	;NO CHARS FOUND

L.SEN1:	MOV	A,B
;ARG IS SENTENCE
L.SENT:	JSR	PC,.LOAD
	BIT	#7777,A	;LAST NODE OF SENTENCE YET?
	BNE	L.SEN1

L.SRET:	JMP	ORTNB


BUTLAST:
	JSR	PC,GLWANE
	BEQ	BL.SEN	;ARG IS A SENTENCE

;ARG IS A WORD
	JSR	PC,CPYSTR	;COPY STRING.
	JSR	PC,.LDP2	;LAST NODE OF NEW STRING
	SWAB	A
	BNE	BL.W2	;THE LAST CHARACTER IS REALLY THERE
	CLR	A	;(WE KNOW THE FIST CHAR IS REALLY THERE)
	CMP	B,C	;IS THERE ONLY ONE NODE
	BNE	BL.W1	;MORE TAN ONE NODE
	CLR	B	;ANSWER IS EMPTY WORD
	BR	BL.W3

BL.W2:	CLRB	A	;CLEAR LAST CHAR
BL.W1:	JSR	PC,.STP2	;STORE NODE BACK
BL.W3:	BIS	#LSTR,B	;POINTER TO THE WORD
BL.ORT:	JMP	ORTNB

;ARG IS A SENTENCE
BL.SEN:	JSR	PC,COPYL	;COPY LIST
	MOV	E,C	;POINTS TO NEXT TO LAST NODE
	BEQ	BL.SR	;ANSWER IS EMPTY
	JSR	PC,.LDP1
	BIC	#7777,A
	JSR	PC,.STP1
	MOV	B,C
BL.SR:	BIS	#LIST,C
	JMP	ORTNC


;INPUT IS NUMBER. OUTPUT IS THE CHARACTER CORRESPONDING TO THAT NUMBER

CHAR:	JSR	PC,G1IARG	;B,,C _ NUMBER
	MOV	C,B
	BIC	#177600,B
	MOV	#SSTR,A
	JSR	PC,GRBAD
	BIS	#LSTR,C
	JMP	ORTC

;INPUT IS WORD, OUTPUT IS # OF FIRST CHAR
ASCI:	MOV #NAME,E
	JSR PC,NNFNGT
	MOVB NAME,B
	JMP R1NARG

COUNT:
	JSR	PC,GLWARG
	BEQ	CT.SEN

;ARG IS WORD
	MOV	B,C
	CLR	B
	MOV	#INSTR1,-(SP)	;ADDRESS OF A CO-ROUTINE
CT.W1:	INC	B	;INCREMENT COUNTER
	JSR	PC,@(SP)+	;RETURNS CHAR IN B
	BNE	CT.W1
	DEC	B	;WHEN RETURNS HERE, NO MORE CHARS
CT.ORT:	POPS C
	JMP R1NARG	;C IS A THROW-AWAY

;ARG WAS A SENTENCE
CT.SEN:	MOV	B,C
	JSR	PC,CLE	;RETURNS NUMBER OF LIST ELEMENTS IN B
	BR	CT.ORT


;COPY LIST.
;	CALL WITH B POINTING TO LIST
;	RETURNS B POIOTING TO NEW LIST, C POINTING TO LAST NODE
COPYL:	CLR	E	;WILL POINT TO 2ND NODE FROM LAST
	CLR	F
	BIT #7777,B
	BEQ COPYR1
COPYL1:	BIT	#7777,B
	BEQ	COPYLR	;DONE
	JSR	PC,.LOAD
	MOV	F,E	;LISTB PLACES  LAST NODE PTR INTO F
	JSR	PC,LISTB
	MOV	A,B
	BR	COPYL1

COPYLR:	MOV F,C	;LISTB KEEPS PTR TO LAST NODE OF LIST IN F
	POPS	B	;LISTB KEEPS POINTER TO NEW LIST ON S.
COPYR1:	RTS	PC


;COPY STRING
;CALL WITH B POINTING TO STRING TO BE COPIED,
;ASSUMES THAT INPUT STRING HAS BEEN GARBAGE COLLECT PROTECTED ALREAEDY
;B POINTS TO FIRST NODE OF NEW STRING,  C POINTS TO LAST

CPYSTR:	MOV	#INSTR,A
MAKSTR:	MOV	D,-(SP)
	MOV	E,-(SP)
	MOV	F,-(SP)

	MOV	A,-(SP)	;ADDRESS OF INPUT STRING ROUTINE
	CLR	F

OUTSTR:	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE1	;INPUT STRING DONE

OSTR1:	MOV	D,B	;SAVE CHARACTER
	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE2	;INPUT STRING DONE

OSTR2:	SPUSH	A	;SAVE REGISTERS USED BY INPUT STRING
	SWAB	D
	BIS	D,B	;BIS SECOND CHARACTER
	JSR	PC,ACTSTO	;ACTUAL STORE
	SPOP	A
	BR	OUTSTR

;INPUT STRING HAS ENDED
OSTRE2:	JSR	PC,ACTSTO	;STORE CHAR IN B
OSTRE1:	POPS	B	;POINTER TO FIRST NODE OF STRING
	MOV	F,C	;POINTER TO LAST NODE
	BIC	#170000,B
	BIC	#170000,C
.RDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
	SEZ
OSTRR:	RTS	PC


;ACTUALLY STORE OUTPUT NODE
ACTSTO:	MOV	#SSTR,A
	JMP	LISTB


;INPUT STRING
;A CO-ROUTINE THAT HANDS BACK A CHARACTER IN BOTTOM BYTE OF D
;DOES RTS PC WHEN INPUT STRING FINISHED

INSTR:	MOV	B,C
INSTR1:	BIT	#7777,C
	BEQ	OSTRR	;RTS PC
	JSR	PC,.LDP2I
	MOVB	A,D
	BIC	#177600,D	;CLEAR TOP BYTE
	BEQ	INSTR2	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE

INSTR2:	CLRB A
	SWAB	A
	MOV	A,D
	BIC #177600,D
	BEQ	INSTR1	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE
	BR	INSTR1


;LIKE INSTR, EXCEPT GETS CHAR FROM TEXT STRING (NOT NODE SPACE)
;NOTE -- ENTER AT INTXT
INTXT0:	JSR	PC,@(P)+
INTXT:	MOVB	(C)+,D
	BNE	INTXT0	;BR IF NOT END OF TEXT
	RTS	PC

MAKE:	BIC #MMF,FLAGS2
	BR .+10
MMAKE:	BIS #MMF,FLAGS2
	POPS TOPS	;PUT VALUE INTO TOPS
	MOV @S,B
	MOV B,A
	BIC #7777,A
	CMP #ATOM,A	;IS TYPE ATOM?
	BNE MAKE2
MAKE4:	MOV #VBIND,A	;YES< SET VARIABLE BINDING?
	JSR PC,.BIND
	BIT #MMF,FLAGS2	;IS IT MULTIPLE MAKE?
	BEQ MAKE1
	MOV TOPS,@S
	CLR TOPS
	CLR TOPS1
	CLZ
	RTS PC
MAKE1:	POPS A
	CLR TOPS
	CLR TOPS1
	RTS PC
MAKE2:	CMP #LSTR,A
	BEQ MAKE3
MAKE5:	ERROR+WTAB	;WRONG TYPE OF ARG
MAKE3:	BIT #7777,B
	BEQ MAKE5
	MOV TOPS,@S
	MOV B,TOPS	;FOR .INTRN
	JSR PC,UINTRN	;.INTRN FOR STRINGS THAT MAY INCLUDE NULL CHARS
	MOV @S,TOPS
	BIS #ATOM,B
	MOV B,TOPS1
	BR MAKE4

DOTS:	JSR PC,GETVAL	;GET VALUE IF IT HAS ONE
	BNE 1$
	ERROR+HNV	;HAS NO VALUE
1$:	PUSHS B
	CLR TOPS
	CLZ
	RTS PC

THINGP:	JSR PC,GETVAL	;DOES IT HAVE A VALUE?
	BEQ THNGPF	;NO
	JMP RTTRUE
THNGPF:	JMP RTFALS

GETVAL:	JSR PC,GUOEB	;GET UOE PTR FROM S INTO B
	BEQ GETVA1
	MOV #VBIND,A
	JSR PC,.BINDL
	BEQ GETVA1
	TST B
GETVA1:	RTS PC		;HAS NO VALUE (UNBOUND LOCAL)

GUOEB:	POPS B	;GET UOE OR LSTR IN B FROM S
	MOV B,A	;    SKIP IF UOE
	BIC #7777,A
	CMP #ATOM,A
	BEQ GUOE1
	CMP #LSTR,A
	BEQ GUOE2
	ERROR+WTAB	;.(B). ISWRONG TYPE OF ARG
GUOE2:	MOV B,TOPS
	JMP UOBSCH	;.OBSCH FOR STRINGS THAT HAVE NULL CHARS
GUOE1:	CLZ
	RTS PC
		;PRINT TOP (C) THINGS ON S
FPRINT:	INC NBKTS	;PRINTS OUTER [,]'S
PRINT:	EXCH (P),2(P)
	JSR	PC,REVS	;DOESNT "
	POP	C
	JSR	PC,TYPE1
	JSR	PC,.CRLF
	SEZ
	RTS PC

TYPE:	EXCH (P),2(P)
	JSR	PC,REVS
	POP	C
	JSR	PC,TYPE1	;PRINT WITHOUT CRLF AT END
	SEZ
	RTS PC

TYPE1:	BIS #DPQF+CPTBF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
			;BUT DO  PRINT % AS BLANK
	JSR PC,PRS1
	POPS A
	DEC C
	BGT	TYPE1
	BIC #DPQF+CPTBF,FLAGS2
	RTS	PC

.IFNZ LSIHAK
LOAD:
.IFZ DMPCAS
	MOV #1,D	;TO LOGO. THE SITS RTN WILL THEN INPUT THE CONTENTS
	JSR PC,SETTIM
	JSR PC,TYO	;OF THE FILE TO LOGO
	JSR PC,RESTTY
	MOV #1,D	;ONE THING TO PRINT
	JSR PC,TYPE1
	JSR PC,.CRLF
.IFF
	PRTXT <START TAPE>
.ENDC
	JSR PC,LSTIG	;SET TTY INPUT TO IMAGE WITH BIG BUFFER
	CLR LSILSC	;CLEAR LOST CAHRS COUNT
	MOV PC,REDFLG
	SEZ
	RTS PC

ENDFIL:	JSR PC,LSTRES	;RESTORE REAL BUFFERS
	CLR REDFLG
	TST LSILSC
	BEQ 1$
	PRTXT <LOST SOME CHARS!>
1$:	.IIF NZ DMPCAS,PRTXT <STOP TAPE>
	SEZ
	RTS PC

DUMP:	PRTXT <!START TAPE RECORDING THEN TYPE SPACE!>
	JSR PC,ONETYI
	MOV PC,WRTFLG
	JSR PC,SETTIM	;SET TTY TO IMAGE MODE
	JSR PC,SHOWAL
	PRTXT <
ENDFILE
!STOP TAPE THEN TYPE SPACE!
>
	JSR PC,ONETYI
	JSR PC,RESTTY
	CLR WRTFLG
	SEZ
	RTS PC
.ENDC

;PREDICATES

EQUAL:	MOV	S,F
	MOV	(F)+,B	;ARG1.  LEAVE ON STACK FOR GC PROTECTION
	MOV	(F),C	;ARG2
	JSR	PC,EQUAL1
	BEQ	EQ.F	;RETURNS HERE IF FALSE
	ADD #4,S
	JMP RTTRUE
EQ.F:	ADD #4,S
	JMP RTFALS


;COMPARE THE DATA ITEM POINTED TO BY B WITH
;THE DATA ITEM POINTED TO BY C.
;SKIP IF THEY ARE EQUAL
EQUAL1:	MOV #7777,E	;AN OFT-USED CONSTANT
	MOV B,A
	MOV C,D
	BIC E,A
	BIC E,D
	CMP A,D
	BNE WEQUAL
	CMP #LIST,A
	BNE WEQUAL
EQ.LST:	BIC #170000,B
	BIC #170000,C
	CMP B,C
	BEQ EQTRUE
	TST B
	BEQ EQFALS
	TST C
	BEQ EQFALS
	JSR PC,.LOAD
	PUSH A
	JSR PC,.LDP2I
	SPUSH C
	MOV A,C
	JSR PC,EQUAL1
	BEQ EQ.FF
	POP B
	SPOP C
	BR EQ.LST

EQ.FF:	CMP	(SP)+,(SP)+	;POP OFF THE POINTERS TO THE BF'S
	JSR PC,PPOPT
	SEZ
	RTS PC

;COMPARE TWO WORDS

.IFZ FPPF

WEQUAL:	MOV	#INUM,A
	JSR	PC,CONVERT	;TRY CONVERTING ARG TO INUM
	BEQ	EQ.STR	;NOT NUMERIC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG
	BEQ	EQFALS	;NOT NUMERIC
	JSR	PC,.LOAD	;A,,B HAVE NUMBER
	MOV	A,D
	MOV	B,F
	JSR	PC,.LOADC
	CMP	A,D	;COMPARE 2 INTEGERS
	BNE	EQFALS
	CMP	B,F
	BNE	EQFALS
	BR	EQTRUE
.IFF

WEQUAL:	JSR PC,G1NUMS	;IS IT A NUMBER?
	BEQ EQ.STR
	LDD FA,FB	;IT WAS SO SAVE IT
	MOV C,B		;IS THE SECOND A NUM?
	JSR PC,G1NUMS
	BEQ EQFALS
	CMPF FA,FB	;COMPARE THEM
	CFCC
	BNE EQFALS
	BR EQTRUE

.ENDC


;ARG NOT NUMERIC.  TRY STRING COMPARE
EQ.STR:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BEQ EQFALS	;EQUAL NOT DEFINED FOR SNAPS, ETC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG, TOO
	BEQ	EQFALS	;NOT SAME TYPE AS FIRST ARG
	CMP	B,C
	BEQ	EQTRUE

;COMPARE TWO STRINGS.  POINTERS IN B AND C.
	SPUSH	#INSTR1
	MOV	C,GCP2
CMPSTR:	MOV	B,GCP1
	MOV	B,F
CMPST1:	BIT	E,F	;IS ARG 1 ENDED
	BEQ	CMPSTE	;YES
	SPUSH	A	;SAVE A
	MOV	F,B	;POINTER TO REST OF ARG1
	JSR	PC,.LOAD
	MOV	A,F	;POINTER TO REST OF ARG1
	SPOP	A	;RESTORE A
	BICB #200,B	;IS CHAR REAL OR NULL?
	BEQ	CMPST2	;NULL
	JSR	PC,@(SP)+	;PUTS 1 CHAR OF ARG 2 INTO B
	BEQ	CSFAL1	;ARG 2 ENDED
	CMPB	D,B	;COMPARE CHARS!!
	BNE	CSFALS
CMPST2:	SWAB	B
	BIC #177600,B
	BEQ	CMPST1	;NULL CHAR
	JSR	PC,@(SP)+	;1 CHAR OF ARG 2 IN B
	BEQ	CSFAL1
	CMPB	D,B	;COMPARE CHARS!!
	BEQ	CMPST1
CSFALS:	TST	(SP)+	;POP CO-ROUTINE LINKAGE
CSFAL1:	CLR	GCP1
	CLR	GCP2
EQFALS:	SEZ
	RTS PC

;ARG 1 HAS ENDED
CMPSTE:	JSR	PC,@(SP)+
	BNE	CSFALS	;BUT ARG 2 HASN'T ENDED
	CLR	GCP1
	CLR	GCP2
EQTRUE:	CLZ
	RTS PC	;BOTH ENDED AT THE SAME TIME!!!!



;CALL WITH B = POINTER TO STRING IN NODE SPACE
;	C = POINTER TO STRING IN DATA SPACE
EQ.TXT:	SPUSH	#INTXT	;ADDRESS OF CO-ROUTINE
	MOV	#7777,E	;AN OFT USED CONSTANT
	BR	CMPSTR



;MORE PREDICATES

GREATR:	JSR PC,CMP2IA
	BGT RTTRUE
RTFALS:
LANGC	<PUSHS #FALSE>,<
	PUSHS #FAUX>
RTNCMP:	CLZ
	RTS PC

LESSP:
LESS:	JSR PC,CMP2IA
	BGE RTFALS
RTTRUE:
LANGC	<PUSHS #TRUE>,<
	PUSHS #VRAI>
	BR RTNCMP

GREQ:	JSR PC,CMP2IA
	BGE RTTRUE
	BR RTFALS

LSEQ:	JSR PC,CMP2IA
	BLE RTTRUE
	BR RTFALS

NUMBP:	POPS B
 	MOV #INUM,A
	JSR	PC,CONVERT
.IFZ FPPF
	BEQ	RTFALS	;COULDN'T CONVERT IT
	BR RTTRUE
.IFF
	BNE RTTRUE
	MOV #FNUM,A
	JSR PC,CONVERT
	BEQ RTFALS
	BR RTTRUE
.ENDC

EMPTYP:	POPS B
	BIT	#7777,B
	BEQ	RTTRUE
	BR	RTFALS

LISTP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTTRUE
	BR	RTFALS

WORDP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTFALS
	BR	RTTRUE

.IFZ FPPF

;COMPARE TWO INTEGER ARGUMENTS
CMP2IA:	JSR	PC,G2IARG
;COMPARE 2 INTEGERS IN B,,C & E,,F
.ENDC
CMP2I:	CMP	E,B
	BNE	CMP2IR	;CONDITION CODES SET CORRECTLY
	CMP	F,C
	BEQ	CMP2IR
	BHI	CMP2IH
;E,,F < B,,C
	CMP	#0,(PC)
	RTS	PC
CMP2IH:	TST	(PC)
CMP2IR:	RTS	PC

.IFNZ FPPF

;GET AND COMPARE TWO (FNUM OR INUM) ARGS

CMP2IA:	SPUSH A
	JSR PC,G2ARG
	SPOP A
	CMPF FB,FA
	CFCC
	RTS PC

INTEGER:
	MOV @S,B
	MOV #INUM,A
	JSR PC,CONVERT
	BNE 1$
	ERROR+WTA
1$:	MOV B,@S
	CLZ
	RTS PC


.ENDC


NOT:	JSR	PC,TSTST	;TEST S SKIP IF TRUE
	BEQ	RTTRUE
	BR	RTFALS

BOTH:	JSR	PC,TSTST
	BNE EITH1
	JSR PC,SPOPT
BOTH1:	BR RTFALS
EITH1:	JSR	PC,TSTST
	BEQ	BOTH1
	BR	RTTRUE	;BOTH ARE "TRUE !!

EITHER:	JSR	PC,TSTST
	BEQ	EITH1	;IS 2ND ONE "TRUE?
	JSR	PC,SPOPT	;POP 2ND ARG
	BR	RTTRUE
TEST:	JSR PC,TSTST	;IS TOP OF S "TRUE"?
	BEQ TES1	;NO, CLEAR FLAG
	BIS #TSTFLG,FLAGS	;YES, SET FLAG
	BR IFR
TES1:	BIC #TSTFLG,FLAGS
	BR IFR
IFTRUE:	BIT #TSTFLG,FLAGS	;FLAG SET?
	BNE IFR	;YES, CONTINUE
IFT1:	CLR CT	;NO, MAKE GNT THINK LINE HAS ENDED
.IIF Z BEEF,	CLR CT+2
	RTS PC
IFFALS:	BIT #TSTFLG,FLAGS	;FLAG CLEARED?
	BEQ IFR	;YES, CONTINUE
	BR IFT1	;NO STOP
UNTIL:	JSR PC,TSTST
	BNE IFR
.IIF NZ BEEF,	MOV CPLN,TMPBLK	;STORE THE CURRENT LINE NUMBER
	JMP GOUNTL
IF:	INC IFLEV
	JSR PC,TSTST	;TEST S, SKIP IF "TRUE"
	BNE IFR
	CLR NOPAR
	JSR PC,STNE
	BEQ IFR
	BIC #RTF,FLAGS
	DEC IFLEV
IFR:	SEZ
	RTS PC
THEN:	TST IFLEV
	BGT IFR
	ERROR+OOP	;THEN OUT OF PLACE
ELSE:	DEC IFLEV
	BGE .+4
ELSE1:	ERROR+OOP	;ELSE OUT OF PLACE
	CLR NOPAR
	JSR PC,STNE
	BEQ IFR
	TST IFLEV
	BLE ELSE1
	BR IFR
STNE:	;SCAN TOO NEXT ELSE, CR OR UNMATCHED );
	;  SET RTF.  SKIP IIF "ELSE"
	JSR PC,GNT
	CMP #$RPAR,B
	BNE STNE4
	DEC NOPAR
	BGE STNE
	BIS #RTF,FLAGS
	SEZ
	RTS PC
STNE4:	CMP #$LPAR,B
	BNE STNE5
	INC NOPAR
	BR STNE
STNE5:	TST NOPAR
	BGT STNE
	.IFNZ ENG
	CMP #$ELSE,B
	BEQ STNE6
	.ENDC
	.IFNZ FR
	CMP #$SINON,B
	BEQ STNE6
	.ENDC
STNE1:	BIT #CRF,FLAGS
	BEQ STNE2
STNE3:	BIS #RTF,FLAGS	;IF "CR" SET RTF AND RETURN
	BIC #CRF,FLAGS
	SEZ
	RTS PC
STNE6:	BIS #RTF,FLAGS	;IF "ELSE", SET RTF AND SKIP RETURN
	RTS PC
STNE2:
	.IFNZ ENG
.IIF Z BEEF,	CMP #$IF,CT+2	;IF "IF", LOOK FOR NEXT ELSE!
.IIF NZ BEEF,	CMP #$IF,CT	;IS "IF", LOOK FOR THE NEXT ELSE!
	BEQ STNE7
	.ENDC
	.IFNZ FR
.IIF Z BEEF,	CMP #$SI,CT+2
.IIF NZ BEEF,	CMP #$SI,CT
	BEQ STNE7
	.ENDC
	BR STNE
STNE7:	JSR PC,STNE
	BEQ STNE3
	BIC #RTF,FLAGS
	BR STNE
TSTST:
	.IFNZ ENG
	MOV	@S,B		;TEST S, SKIP IF TRUE
	CMP	B,#FALSE
	BEQ	TSTF9	;IT'S "FALSE
.ENDC
.IFNZ FR
	CMP B,#FAUX
	BEQ TSTF9
.ENDC
.IFNZ ENG
	MOV	#TRUE,C	;ERROR IF NEITHER "TRUE" OR "FALSE"
	JSR	PC,EQUAL1
	BNE TESTIT
.ENDC
.IFNZ FR
	MOV @S,B
	MOV #VRAI,C
	JSR PC,EQUAL1
	BNE TESTIT
.ENDC
.IFNZ ENG
	MOV	@S,B
	MOV	#FALSE,C
	JSR	PC,EQUAL1
	BNE TSTF9
.ENDC
.IFNZ FR
	MOV @S,B
	MOV #FAUX,C
	JSR PC,EQUAL1
	BNE TSTF9
.ENDC
	ERROR+NTF	;NOT "FALSE, EITHER
TSTF9:	JSR	PC,SPOPT
	SEZ
	RTS	PC	;"FALSE!!
TESTIT:	JSR	PC,SPOPT
	CLZ
	RTS PC	;"TRUE!!
REVS:	CMP #1,2(P)	;REVERSES THE TOP ((P)+2) THINGS ON S
	BLT 1$	;IF <2 QUIT
	RTS PC
1$:	CMP #MAXARG,2(P)
	BGE 2$
	.BUG.	;BARF, WHO ASKED REVS TO SWITCH > 32 THINGS?
2$:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV 10.(P),C	;GET # TO BE SWITCHED
REVS5:	MOV S,A	;COMPUTE ADDR OF WORD JUST BEYOND BLOCK
	MOV C,B
	ASL B
	ADD A,B
	CMP IS,B	;SHOULD WE FORCE A SWAPIN?
	BLO REVS4	;YES
	ASR C
	BEQ REVS1
REVS2:	MOV (A),D
	MOV -(B),(A)+
	MOV D,(B)
	DEC C
	BGT REVS2
REVS1:	JMP RETD
REVS4:	JSR PC,SPSWPI	;SWAP S PDL BACK IN
	BR REVS5
.STITL DOUBLE PRECISION INTEGER ARITHMETIC
.IFZ FPPF

;INTEGER MULTIPLICATION

;CALL WITH ONE DOUBLE PRECISION ARGUMENT IN B,,C
;AND THE OTHER IN E,,F
;RETURNS PRODUCT IN E,,F.
;ALL OTHER ACCUMULATORS (INCLUDING B,C ARE UNCHANGED)

.DPMUL:	SPUSH	A	;SAVE A
	CLR	A
DVML:	PUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F
	PUSH B		;STUFF ABS(B,,C)
	SPUSH C
	SPUSH E		;AND ABS(E,,F)
	SPUSH F
	CLR	-(SP)	;A FLAG FOR NEG. ARGS
	TST	B	;MAKE SURE ARGS ARE POSITIVE
	BGE	DVML1
	DPNEG	B,C
	DPNEG 10(P),6(P) ;ALSO ON STACK (FOR DIV)
	COM	(SP)
DVML1:	TST	E
	BGE	DVML2
	DPNEG	E,F
	DPNEG 4(P),2(P)
	COM	(SP)
DVML2:	ADD	A,PC	;CHOOSE BETWEEN MUL AND DIV

;DOUBLE PRECISION MULTIPLY (CONT.)

MUL1:	TST	B	;OVERFLOW UNLESS A1*A2=0
	BEQ	MUL2
	TST	E
	BNE	MDV2	;OVERFLOW!
	EXCH	B,E	;WANT ARG1 TO HAVE ZERO HIGH ORDER PART
	EXCH	C,F
MUL2:	CLR	-(SP)	;SET B1 AND B2
	ASL	C
	BCC	1$
	MOV	#100000,(SP)	;B2
1$:	ASL	F
	BCC	2$
	ADD	#200,(SP)	;B1 (ALSO CLEARS CARRY)
2$:	ROR	C	;C2
	ROR	F	;C1
;IF B2*A1>0, THEN OVERFLOW
	TST	(SP)
	BGE	MUL3	;B2=0
	TST	E	;A1
	BNE	MDV1	;OVERFLOW

;DOUBLE PRECISION MULTIPLY (CONT.)

;GET A1*C2*(2**16.)
MUL3:
	MOV C,A		;C2*A1
	MUL E,A
	BCS MDV1	;CARRY INTO A IS OVERFLOW
	MOV B,ANSWER+2	;SINCE A1*C2 IS HIGH ORDER OF ANSWER
;GET C1*C2 AND ADD INTO ANSWER
	MOV C,A		;C1*C2
	MUL F,A
	MOV B,ANSWER	;LOW ORDER PARTIAL PRODUCT
	ADD A,ANSWER+2	;ADDED TO A1*C2
	BVS	MDV1	;OVERFLOW
;GET C2*B1*(2**15.) AND ADD INTO ANSWER
	TSTB	(SP)
	BEQ	MUL35	;B1=0
	CLR A
	MOV C,B		;GET C2
	ASHC #15.,A	;SHIFT C2 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
	ADC	ANSWER+2
	BVS	MDV1
	ADD A,ANSWER+2
	BVS	MDV1
;NOW GET B2*C1*(2**15.) AND ADD INTO ANSWER
MUL35:	TST	(SP)
	BGE	MUL4
	CLR A
	MOV F,B		;GET C1
	ASHC #15.,A	;SHIFT C1 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
	ADC	ANSWER+2
	BVS	MDV1
	ADD A,ANSWER+2
	BVS	MDV1
;NOW GET B1*B2*(2**30.)
MUL4:	CMP	(SP)+,#100200	;ARE BOTH B1 AND B2 SET
	BNE	MUL5	;NO (PRODUCT IS ZERO, OBVIOUSLY)
	ADD	#40000,ANSWER+2	;1*2**30. + ANSWER
	BVS	MDV2	;OVERFLOW
;PUT ANSWER IN THE RIGHT PLACE
MUL5:	MOV	ANSWER+2,E	;HIGH ORDER PARTS
	MOV	ANSWER,F	;LOW ORDER PARTS
	TST	(SP)+	;NEGATIVE?
	BEQ	MUL6
	DPNEG	E,F
MUL6:	ADD #14,SP	;THROW AWAY E,,F, ABS(B,,C) AND ABS(E,,F)
	JMP	SRETD	;BUT RESTORE THE REST

;OVERFLOW EXITS
MDV1:	TST (SP)+	;POP 2 WORDS + ABS'S
MDV2:	ADD #12,SP	;POP 1 WORD + ABS'S
	JMP	RETF	;RESTORE ALL AC'S AND RTS


;DOUBLE PRECISION DIVIDE
;	DIVIDE E,F BY B,C
;RETURN QUOTIENT IN E,F  AND REMAINDER IN B,C
.DPDIV:	SPUSH	A
	MOV	#<DIV1-MUL1>,A	;ADD TO THE PC IN A WHILE
	JMP	DVML	;INITIALIZATION.

DIV1:	TST	B	;IS DEN = 0, 1, OR DOUBLE PRECISION ?
	BNE	DIV2	;DOUBLE PRECISION
	TST	C
	BLT	DIV2	;DOUBLE PRECISION (SINCE TOP BIT WAS SET)
;DEN IS SINGLE PRECISION
	BEQ	MDV2	;DEN=0. OVERFLOW!
	CMP	C,#1	;IS IT 1?
	BNE	SPDEN1	;NO
	CLR	B
	CLR	C
	BR	DIV10
SPDEN1:	JSR	PC,.SPDEN	;DO THE DIVISION
	BR	DIV10

;DEN IS DOUBLE PRECISION
DIV2:	JSR	PC,CMP2I	;IS NUM < DEN
	BGE	DIV5	;NO
;NUM<DEN. QUOTIENT=0. REM=NUM
DIV4:	MOV	E,B
	MOV	F,C
	CLR	E
	CLR	F
	BR	DIV10

;NUM>=DEN.
DIV5:	PUSH B		;SAVE DENOMINATOR
	SPUSH C
	MOV B,A		;MOVE B,,C TO A,,B AND NORMALIZE
	MOV C,B
	CLR SHFCNT
DIV5A:	INC SHFCNT	;COUNT A LEFT SHIFT
	ASHC #1,A
	BVC DIV5A	;UNTIL SIGN BIT CHANGES (OVERFLOW)

	ASHC #-1,A	;UNDO LAST SHIFT
	BIC #100000,A	;AND CLEAR SIGN BIT WHICH WAS SET
	DEC SHFCNT	;UNCOUNT THE LAST SHIFT
	MOV A,C		;DIVIDE BY HIGH-ORDER OF NORMED DIVISOR
	JSR PC,.SPDEN	;E,,F _ (E,,F)/(DIVISOR*2^[N-16.])
	MOV E,A		;MOV (QUOTIENT*2^[16.-N]) TO A,,B
	MOV F,B
	ADD #-16.,SHFCNT	;TIMES 2^[N-16.] IS TRIAL QUOTIENT
	ASHC SHFCNT,A
;GET TRIAL NUM_(TRIAL QUOTIENT-1)*DEN. COMPARE WITH TRUE NUM
	POP F		;E,,F _ SAVED DENOMINATOR
	SPOP E
	MOV B,C		;B,,C _ A,,B (TRIAL QUOTIENT)
	MOV A,B
	SUB	#1,C	;TRY FIRST WITH Q_Q-1
	SBC	B
	BVS	MDV2	;OVERFLOW
	JSR	PC,.DPMUL
	BEQ	MDV2	;MULTIPLY GOT AN ERROR (HMM!)
;COMPARE NUM TO TEM
	MOV	B,ANSWER+2	;SAVE TRIAL QUO
	MOV	C,ANSWER
;FALLS THROUGH
;FALLS IN
;GET TEM-NUM
	MOV	SP,D
	TST	(D)+
	SUB	(D)+,F
	SBC	E
	BVS	MDV2
	SUB	(D)+,E
	BVS	MDV2
;TURN INTO NUM-TEM
	DPNEG	E,F
	MOV	E,B
	MOV	F,C
	MOV	(D)+,F	;E,,F_DEN
	MOV	(D)+,E
DIV6:	TST	B	;NUM-TEM
	BEQ	DIV7
	BGT	DIV75
;ANSWER TOO BIG. TRY ANSWER _ ANSWER - 2
	SUB	#2,ANSWER
	SBC	ANSWER+2
	BVS	MDV2
;THIS MAKE TEM _ TEM + 2*DEN
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	BR	DIV6
DIV7:	TST	C
	BEQ	DIV9	;TRIAL QUOTIENT = QUOTIENT !!
;TEM < NUM. EITHER QUOT=QUOT OR QUOT+1
DIV75:	JSR	PC,CMP2I	;IS REM < DEN
	BGT	DIV9	;YES
DIV8:	ADD	#1,ANSWER	;QUOT _ QUOT + 1
	ADC	ANSWER+2
	BVS	MDV2
	SUB	F,C	;REM _ REM - DEN
	SBC	B
	BVS	MDV2
	SUB	E,B
	BVS	MDV2
DIV9:	MOV	ANSWER+2,E
	MOV	ANSWER,F
DIV10:	TST	(SP)+	;NEG. IF ANSWER SHOULD BE NEG.
	BGE	DIV11
	DPNEG	B,C
	DPNEG	E,F
DIV11:	ADD #14,SP	;POP ABS(E,,F), ABS(B,,C) AND E,,F
	POP	D	;RESTORE D
	CMP	(SP)+,(SP)+	;THROW AWAY B & C
	SPOP	A	;RESTORE A
	CLZ
	RTS PC



;SINGLE PRECISION DENOMINATOR. DOUBLE PRECISION NUMERATOR.
;C=DEN. E,F=NUM. RETURNS C_REM, E,F_QUOTIENT
.SPDEN:	SPUSH	A
	SPUSH	B
	ASL	E	;DOUBLE E,,F
	ASL	F
	ADC	E
	MOV E,B		;2E/C
	CLR A
	DIV C,A
	MOV A,E		;2*HIGH-QUOTIENT -> E
	MOV B,A		;(2REM + 2F)/2 /C
	MOV F,B
	ASHC #-1,A
	DIV C,A
	MOV A,F		;LOW-QUOTIENT -> F
	MOV B,C		; REMAINDER -> C
	ASR	E	;HALVE E TO GET PROPER HIGH-QUOTIENT
	BCC	1$
	BIS #100000,F	;& LOW BIT FROM DOUBLE-E CLOBBERS F'S SIGN BIT
1$:	SPOP	B
	SPOP	A
	RTS	PC
.ENDC


.IFNZ FPPF


;FLOATING DIVIDE AND MULTIPLY FROM REGS B,,C AND E,,F

.DPMUL:	PUSH A
	CLR A	;SET SWITCH
.DPMU1:	FPUSH FA
	FPUSH FB
	SPUSH C
	SPUSH B
	LDCIF (P)+,FA
	SPUSH F
	SPUSH E
	LDCIF (P)+,FB	;LOAD FLOATING REGS
	ADD A,PC	;WHICH ENTRY?
.DPMU5:	MULF FA,FB
	BR .DPMU2
.DPMU6:	LDD FB,FC	;SAVE FB
	DIVF FA,FB
.DPMU2:	STCFI FB,-(P)	;STACK QUOTIENT OR PRODUCT
	BCS .DPERR	;TOO BIG!?
	SPOP E
	SPOP F		;LOAD E,,F
	TST A
	BNE .DPMU4	;BRANCH ON DIVIDE
.DPMU3:	FPOP FB
	FPOP FA
	SPOP A
	CLZ
	RTS PC

.DPMU4:	STCFI FB,-(P)
	LDCIF (P)+,FB	;TRUNCATE QUOTIENT
	MULF FA,FB
	SUBF FB,FC	;GET REMAINDER
	STCFI FC,-(P)
	SPOP B
	SPOP C		;LOAD B,,C WITH REMAINDER
	BR .DPMU3


.DPDIV:	TST C				;DIVIDE ENTRY
	BNE .DPDI1
	TST B				;DON'T DIVIDE BY ZERO
	BEQ .DPERQ
.DPDI1:	PUSH A
	MOV #<.DPMU6-.DPMU5>,A		;SET DIVIDE SWITCH
	BR .DPMU1			;GO DO IT

.DPERR:	CMP (P)+,(P)+			;CLEAR STACK
	FPOP FB
	FPOP FA
	SPOP A
	SEZ
.DPERQ:	RTS PC




.ENDC





	.STITL CONVERSION ROUTINES


;CONVERT
;CALL WITH DESIRED DATA TYPE IN A
;CALL WITH POINTER TO DATA IN B
;IF CONVERSION SUCCEEDS, RETURN POINTER TO CONVERTED DATA IN B AND
;LEAVE A UNCHANGED.
;
;IF CONVERSION FAILS, LEAVE B UNCHANGED,BUT RETURN ITS DATA TYPE IN A

CONVERT:
	MOV	A,-(SP)	;SAVE A,B,C HERE
	MOV	B,-(SP)
	MOV	C,-(SP)

	BIC	#107777,A	;LEAVE DATA TYPE ONLY
	MOV	B,C
	BIC	#107777,C
	ASR	A	;SHIFT DESTINATION DATA TYPE 3 PLACES
	ASR	A
	ASR	A
	BIS	C,A	;SET SOURCE DATA TYPE IN THE 3 VACATED BITS
	ASR	A	;AND PLACE THE ENTIRE MESS IN BOTTOM 6 BITS
	SWAB	A
;(A IS NOW A 6 BIT DISPATCH ADDRESS)
	MOVB	CNVTBL(A),A	;PICK UP ENTRY FROM TABLE
	BIC	#177400,A	;CLEAR TOP BYTE
	ASL	A		;IT IS A BYTE ADDRESS
	JSR	PC,CNVTOP(A)	;RELATIVE TO CONVERT TOP
	BEQ	CONV.F	;THE CONVERSION FAILED
	MOV	(SP)+,C
	TST	(SP)+	;DON'T RESTORE B
	MOV	(SP)+,A
	RTS PC

CONV.F:	MOV	(SP)+,C
	MOV	(SP)+,B
	MOV	B,A
	BIC	#7777,A	;DATA TYPE OF ARG LEFT IN A
	TST	(SP)+	;DON'T RESTORE A
			;FALLS THROUGH

;CONVERT ROUTINE JUMPS TO THE PROGRAMS HERE

CNVTOP==.	;TOP OF CONVERT ROUTINES

;THE ARGUMENT CAN'T BE CONVERTED TO DESIRED DATA TYPE
.CERR:	SEZ
	RTS	PC


CA2LS==<.-CNVTOP>/2
;CONVERT ATOM TO LSTR
.CATLS:	JSR	PC,.LOAD

CNVNOP==<.-CNVTOP>/2
;THE ARGUMENT ALREADY HAS THE DESIRED TYPE
.CNOP:	CLZ
	RTS PC


CSN2IN==<.-CNVTOP>/2
;CONVERT SNUM TO INUM.  ASSUME NUMBER IN B, RATHER THAN POINTER
.CSNIN:	CLR	A
	TST	B	;IS NUM NEGATIVE?
	BGE	1$
	COM	A	;SET TOP PART TO ALL 1'S
1$:	JSR	PC,GRBAD
	BIS	#INUM,C	;C POINTS TO NEW NODE
	MOV	C,B
	RTS PC

;MORE CONVERSION ROUTINES

CIN2SN==<.-CNVTOP>/2
;CONVERT INUM TO SNUM.  RETURN NUMBER IN B
.CINSN:	JSR	PC,.LOAD
	TST B
	SXT C		;SEE IF B'S SIGN EXTENDED FILLS A.
	CMP A,C
	BNE .CERR
	CLZ
	RTS PC


CSN2LS==<.-CNVTOP>/2
;CONVERT SNUM TO LSTR
.CSNLS:	JSR	PC,.CSNIN	;CONVERT TO INUM FIRST

CIN2LS==<.-CNVTOP>/2
;CONVERT INUM TO LSTR
.CINLS:	SPUSH	D
	SPUSH	E
	SPUSH	F
	JSR	PC,.LOAD	;A,B HAS NUMBER
	JSR	PC,.CINST	;CONVERT TO STRING ON P-PDL
.CINL0:	CLR	F
	MOV	#SSTR,A
.CINL1:	SPOP	B
	BEQ	.CINL2		;0 MARKS END OF DIGITS
	JSR	PC,LISTB	;PUT NEXT 2 CHARS ONTO LIST
	BR	.CINL1
.CINL2:	POPS	B	;POINTER TO FIRST NODE OF ANSWER
	BIC	#170000,B	;CLEAR DATA TYPE
	BIS	#LSTR,B	;REPLACE BY LSTR
	MOV F,C	;GET PTR TO LAST NODE IN STRING

.SRDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
	CLZ
	RTS PC


;GET NEXT CHARACTER IN B
;SKIP UNLESS NO MORE CHARS
.CNXTD:	TST	E	;IS THERE MORE NUMBER LEFT
	BNE	.CNXD1	;YES
	TST	F
	BEQ .CNXD2
.CNXD1:	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPDIV	;C_REM, E,,F_QUO
	BEQ .CNXD2
	ADD	#60,C	;TURN TO ASCII
.CNXD2:	RTS PC


;CONVERT INUM TO STRING ON P-PDL
.CINST:	MOV	(SP),TEM1	;RETURN ADDRESS
	CLR	(SP)
	MOV	#10,D
	MOV	A,E
	BGE	.CINI1	;NUMBER IS POSITIVE
	DPNEG	E,B	;NUMBER IS NEG
	CLR	D	;FLAG
.CINI1:	MOV	 B,F

.CINI2:	JSR	PC,.CNXTD	;GET NEXT DIGIT IN C
	BEQ	.CINI5	;NO MORE CHARS
	SWAB	C
	PUSH	C
	JSR	PC,.CNXTD
	BEQ	.CINI6
	BISB	C,(SP)	;SET NEW CHAR INTO PREVIOUS ONE
	BR	.CINI2

.CINI5:	ADD	D,PC	;NEGATIVE?
	SPUSH	#<55*256.>	;PUSH A MINUS SIGN IN HIGH BYTE
.CINIR:	JMP	@TEM1	;RETURN
	BR	.CINI7

.CINI6:	ADD	D,PC	;NEGATIVE?
	BIS	#55,(SP)	;PUT A MINUS SIGN IN LOW BYTE
	JMP	@TEM1
.CINI7:	TST	(SP)	;WERE ANY CHARACTERS GENERATED?
	BNE	.CINIR	;YES, SO RETURN
	SPUSH	#<60*256.>	;NO, SO PUSH A "0 IN HIGH BYTE
	BR	.CINIR

;MORE CONVERSION ROUTINES


CLS2SN==<.-CNVTOP>/2
;CONVERT LSTR TO SNUM
.CLSSN:	JSR	PC,.CLSIN	;CONVERT TO INUM FIRST
	BEQ .CLNR
	JSR	PC,.CINSN	;THEN CONVERT TO SNUM
.CLNR:	RTS	PC	;FAILED

CLS2IN==<.-CNVTOP>/2
;CONVERT LSTR TO INUM
.CLSIN:	BIT	#7777,B	;IS B EMPTY
	BEQ	.CLNR	;CAN'T CONVERT EMPTY
	PUSH	D
	SPUSH	E
	SPUSH	F
	MOV	B,GCP1	;POINT TO INPUT. (GETS CLEARED AT .RDEF & .SRDEF)
	MOV	B,C
	CLR	E
	CLR	F

.CLSS0:	CLR	-(SP)	;A FLAG
	JSR	PC,INSTR1	;GET FIRST CHAR IN D
	BEQ	.CLSS8	;NO CHARS (HMM)
	CMPB	D,#53	;PLUS
	BEQ	.CLSSA
	CMPB	D,#55	;MINUS
	BNE	.CLSS3	;NOT + OR -
	COM	2(SP)	;-1
.CLSSA:	JSR PC,@(SP)+
	BEQ .CLSS8
	BR .+4
.CLSS1:	JSR	PC,@(SP)+	;GET NEXT CHAR INTO D
	BEQ	.CLSS9	;ALL CHARS GOTTEN
.CLSS3:	SPUSH	C	;SAVE C
	SUB	#60,D	;CONVERT FROM ASCII
	BLT	.CLSS7	;NOT DIGIT
	CMPB	D,#10.
	BGE	.CLSS7	;NOT DIGIT
	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPMUL
	BEQ	.CLSS7	;TOO BIG
	ADD	D,F	;ADD NEXT DIGIT IN
	ADC	E
	BVS	.CLSS7	;OVERFLOW
	SPOP	C
	BR	.CLSS1

;EITHER A NON-DIGIT CHARACTER WAS FOUND, OR ELSE 
;THERE WAS OVERFLOW
.CLSS7:	CMP	(SP)+,(SP)+	;POP OFF C & CO-ROUTINE LINKAGE
.CLSS8:	TST	(SP)+	;POP OFF FLAG
	JMP	.RDEF

;ALL CHARS GOTTEN.  NUMBER IS IN E,,F
.CLSS9:	TST	(SP)+	;BUT SHOULD IT BE NEG?
	BGE	.CLSSR	;NO
	DPNEG	E,F
.CLSSR:	MOV	E,A
	MOV	F,B
	JSR	PC,GRBAD
	BIS	#INUM,C
	MOV	C,B
	JMP	.SRDEF
.IFNZ FPPF

;FLOATING POINT CONVERSION ROUTINES

CSN2FN==<.-CNVTOP>/2
.CSNFN:	SPUSH #.CINFN
	JMP .CSNIN


CIN2FN==<.-CNVTOP>/2
.CINFN:	MOV #INUM,A
	JSR PC,.FLOAD
	STCFD FA,-(P)
RFSTR:	SPOP A
	SPOP B
	JSR PC,GRBAD
	BIS #FNUM,C
	MOV C,B
	CLZ
	RTS PC


CFN2IN==<.-CNVTOP>/2
.CFNIN:	MOV #FNUM,A
	JSR PC,.FLOAD
	ADDF #40000,FA
	CFCC
	BVS .LERR1
	BGE 1$
	SUBF #40200,FA
1$:	STCFI FA,-(P)
	BCS .LERR
	SPOP A
	SPOP B
	JSR PC,GRBAD
	MOV C,B
	BIS #INUM,B
	CLZ
	RTS PC
.LERR:	CMP (P)+,(P)+
.LERR1:	SEZ
	RTS PC


CFN2SN==<.-CNVTOP>/2
.CFNSN:	JSR PC,.CFNIN
	BEQ .LERR1
	JMP .CINSN


CFN2LS==<.-CNVTOP>/2
.CFNLS:	SPUSH D
	SPUSH E
	SPUSH F
	MOV #FNUM,A
	JSR PC,.FLOAD
	JSR PC,.CFNST
	JMP .CINL0




CLS2FN==<.-CNVTOP>/2
.CLSFN:	CLR FNPDL+2
	CLR SEXP
	CLR FNPDL
	STF FA,FE	;STORE FLOATING REGISTERS
	STF FB,FF
	CLRF FB
	BIT #7777,B	;CAN'T CONVERT EMPTY LSTR
	BEQ .FNLR
	PUSH D
	SPUSH E
	SPUSH F
	MOV B,GCP1
	MOV B,C
	CLR E	
	CLR F
CLSS0:	CLR -(P)	;A FLAG FOR THE SIGN OF NUMBER
	JSR PC,INSTR1	;GET FIRST CHAR
	BEQ .FERR	;NO CHARS
	SETI		;TO PREPARE FOR MOVES FROM REGS TO FLOAT REGS
	CMPB D,#53	;IS CHAR A "+?
	BEQ CLSSA
	CMPB D,#55	;IS CHAR A "-?
	BNE CLSS3
	COM 2(P)	;SET NEGATIVE NUMBER FLAG
CLSSA:	JSR PC,@(P)+	;GET NEXT CHAR
	BEQ .FERR	;NO MORE CHAR????
	BR .+4
CLSS1:	JSR PC,@(P)+	;GET NEXT CHAR
	BEQ CLSS9
CLSS3:	SUB #60,D	;CONVERT FROM ASCII
	BLT CLSS7	;IT WASN'T A DIGIT
	CMPB D,#12
	BGE CLSS7	;IT WASN'T A DIGIT
	CLR B
	LDCFD #41040,FA	;CONSTANT 10
	MULF FA,FB
	CFCC
	BVS CLSS8
	LDCIF D,FD
	INC FNPDL+2	;SET SWITCH
	ADDF FD,FB
	CFCC
	BVS CLSS8	;OVERFLOWED A FLOATING REGISTER??????!!!
	ADD E,F
	BR CLSS1	;GET ANOTHER CHAR
CLSS8:	TST (P)+	;DESTROY CO-ROUTINE LINKAGE
	JMP .FERR
CLSS9:	CLR B		;NO EXPONENT
	JMP OKY
CLSS7:	INC FNPDL
	CMPB D,#25	;IS IT "E?
	BEQ GTEXP
	CMPB D,#36	;IS IT "N?
	BEQ GTNEXP
	CMPB D,#177776	;ITS NOT ".!!??
	BNE CLSS8
	TST E
	BNE CLSS8	;THERE WERE TWO ".
	DEC E
	BR CLSS1
.FNLR:	LDF FE,FA	;RESTORE REGS
	LDF FF,FB
	SEZ
	RTS PC
FERR2:	POPS GCP1
	FPOP FB
	FPOP FA
.FERR:	TST (P)+
	LDF FF,FB
	LDF FE,FA
	SETL
	JMP .RDEF
GTNEXP:	DEC SEXP	;SET NEG EXPONENT FLAG
GTEXP:	SETL
	SPOP D		;SAVE CO-ROUTINE LINKAGE
	FPUSH FA
	FPUSH FB
	JSR PC,KL	;GET EXPONENT
	BEQ FERR2
	POPS GCP1
	FPOP FB
	FPOP FA
	SPUSH A
	CLR A
	JSR PC,.LOAD	;GET EXPONENT IN A,,B
	TST A
	BEQ OKAY
	SPOP A		;THE EXPONENT WAS TOO TOO LARGE!!!
	BR .FERR
OKAY:	SPOP A
OKY:	TST FNPDL+2
	BEQ .FERR
	SETL
	TST (P)+	;THE NUMBER IS NEGATIVE?
	BGE OKY1
	NEGF FB
OKY1:	LDCDF #40200,D	;CONSTANT 1
	TST SEXP	;GET FINAL EXPONENT
	BGE 1$		;IS EXP NEGATIVE
	NEG B
1$:	CLR SEXP
	ADD B,F
	TST F		;GET ABSOLUTE VALUE IN F
	BGE LOOP
	DEC SEXP
	NEG F
LOOP:	DEC F		;GET 10 TO THE EXPONENT IN FD
	BLT DONEX
	MULF FA,FD
	CFCC
	BVS .FERR+2	;TO BIG
	BR LOOP
DONEX:	TST SEXP	;IF EXP IS POSITIVE MULTIPLY BY IT
	BLT DIVE	;IF NEG DIVIDE BY IT
	MULF FD,FB	;AND PUT RESULT IN FB
	CFCC
	BVS .FERR+2
	BR FIN
DIVE:	DIVF FD,FB
FIN:	STCFD FB,-(P)
	SPOP A		;GET RESULT IN A,,B
	SPOP B
	JSR PC,GRBAD	;STORE RESULT IN NODE SPACE
	BIS #FNUM,C	;PUT POINTER TO DATA IN B
	MOV C,B
	TST FNPDL
	BEQ .FERR+2
	LDF FF,FB	;RESTORE FLOATING REGS
	LDF FE,FA
	JMP .SRDEF
KL:	SPUSH D		;SHORT FOR KLUDGE.
	SPUSH E		;PREPARE TO FAKE OUT .CLSSA
	SPUSH F		;IT WILL GET US AN EXPONENT
	CLR -(P)	;FAKE A FLAG
	SPUSH D		;RESTORE CO-ROUTINE LINKAGE
	CLR E
	CLR F
	PUSHS GCP1
	JMP .CLSSA	;GET POINTER TO EXPONENT



;CONVERT FROM FNUM TO SSTR ON P-PDL

.CFNST:	SPOP SEXP	;SAVE PC
	CLR -(P)
	MOV #FNPDL+16,D	;INITIALIZE STACK POINTER
	TSTF FA
	CFCC
	BEQ .CFNZE	;ITS ZERO
	BGE .CFNS0
	MOVB #'-,-(D)	;PUT IN A MINUS SIGN
	NEGF FA		;PROCESS SIGN OF FNUM
.CFNS0:	CLR A
  	LDCFD #40200,FB	;CONSTANT 1
	LDCFD #41040,FD	;CONSTANT 10
	CMPF FA,FB
	CFCC
	BLT .CFNS2
.CFNS1:	DIVF FD,FA	;NORMALIZE FA
	INC A		;DIVIDE UNTIL 0<FA<1
	CMPF FA,FB
	CFCC
	BGE .CFNS1
.CFNS2:	MULF FD,FA	;MULTIPLY UNTIL 1<F=FA<10
	DEC A
	CMPF FA,FB
	CFCC
	BLT .CFNS2
	SPUSH #66152
	SPUSH #2657
	SPUSH #33675
	SPUSH #33006
	ADDF (P)+,FA	;ADD .0000005 FOR ROUNDING
	CMPF FA,FD	;9.99999999999999 WILL OVERFLOW
	CFCC
	BLT 1$
	DIVF FD,FA
	INC A		;MAKE IT 1.000 WHEN IT WAS 10.000
1$:	MOV A,FNPDL	;SAVE EXPONENT
	MOV #7,B	;COUNTER FOR SEVEN DIGITS
	SETI
	INC A
	BLT 2$		;ITS LESS THAN .1
	CMP #7,A
	BLT 2$		;ITS GREATER THAN 10000000.
	INC A
	CLR FNPDL
	BR .CFNS3
2$:	MOV #2,A
.CFNS3:	DEC A		;A COUNTS PLACES TO DECIMAL POINT
	BNE 1$
	MOVB #'.,-(D)	;PUT IN ".
1$:	STCFI FA,C	;GET DIGIT
	LDCIF C,FB
	ADD #'0,C
	MOVB C,-(D)	;STACK CHARACTER
	SUBF FB,FA	;GET FRACTIONAL PART OF NUMBER
	MULF FD,FA
	SOB B,.CFNS3
	DEC A
	BNE 2$
	MOVB #'.,-(D)
2$:	SETL
	CLR A
;FALLS THROUGH
;FALLS IN
.CFNS4:	INC A		;COUNT ZEROS POPPED
	CMPB #'0,(D)+
	BEQ .CFNS4	;POP INSIGNIFICANT ZEROS
	DEC D		;RESET POINTER
	MOV FNPDL,B	;RETRIEVE EXPONENT
	BEQ .CFNS6	;NO EXPONENT
	BGT .CFNS5
	ADD B,A
	BGE .CFNS8	;IT NOW FITS DUE TO POPPED ZEROS
	NEG B
	MOVB #'N,-(D)	;STACK "N
	BR .CFNS5+4
.CFNS5:	MOVB #'E,-(D)	;STACK "E
	CLR A
	MOV D,FNPDL	;SAVE POINTER
	JSR PC,.CINST	;REDUCE EXPONENT TO SSTR
	SPOP A
	SPOP B
	MOV FNPDL,D	;RESTORE POINTER
	MOVB A,-(D)	;STACK EXPONENT DIGIT
	BNE 1$
	INC D		;IT WASN'T A DIGIT SO KILL IT
1$:	SWAB A
	MOVB A,-(D)	;GET OTHER DIGIT
.CFNS6:	MOVB (D)+,-(P)	;GET HIGH BYTE
	BEQ .CFNS7	;A ZERO BYTE MEANS ITS DONE
	SWAB (P)
	MOVB (D)+,(P)	;GET ANOTHER BYTE
	BNE .CFNS6	;ZERO BYTE SIGNALS END
	SUB #2,P
.CFNS7:	ADD #2,P	;FIX UP STACK POINTER
	JMP @SEXP
.CFNZE:	SPUSH #"0.	;PUT "0. ON STACK
	JMP @SEXP
.CFNS8:	ADD D,B		;CREATE POINTER
	INC B
	MOV B,C		;SAVE IT
.CFNS9:	MOVB (D)+,(B)+	;SHIFT STACK
	CMPB #'.,-1(B)
	BNE .CFNS9
	MOVB (D),-1(B)	;GET LAST DIGIT
	MOV FNPDL,A
	COM A		;COMPUTE HOW MANY ZEROS ARE TO BE ADDED
.CFN10:	MOVB #'0,(B)+
	SOB A,.CFN10
	MOVB #'.,(B)
	MOV C,D		;RESTORE POINTER
	BR .CFNS6	;I HOPE YOUR HAPPY THAT THE EXPONENT IS GONE


.ENDC
	.STITL GET ARGUMENT ROUTINES

;GET 2 SNUM'S OFF OF S PDL
;RETURN TOP ONE IN A, BOTTOM ONE IN B
G2NARG:	JSR	PC,G1NARG	;NUMBER IN B
	MOV	B,A

;GET 1 SNUM OFF OF S PDL
;RETURN IT IN B
G1NARG:	POPS B
G1NAR1:	MOV	A,-(SP)	;ENTER HERE WITH ARG IN B
	MOV	#SNUM,A
	JSR	PC,CONVERT
G1WTA:	BEQ G1ARG1
	MOV	(SP)+,A
G1RET:	RTS	PC

;GET ONE LIST OR WORD ARG
;SKIP IF WORD
GLWARG:	MOV	@S,B	;DON'T POP ARG.  LEAVE IT GC PROTECTED
GLWAR1:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BNE GSW2
GSW1:	CMP	A,#SENT
	BNE	G1ARG1	;NOT SENTENCE EITHER
	SEZ
GSW2:	RTS	PC

;GET ONE LIST OR WORD.  ERRROR IF EMPTY
GLWANE:	MOV	@S,B
	BIT	#7777,B
	BEQ	G1ARG1
	BR	GLWAR1

;RETURN ONE NUMERIC ARGUMENT
;CALL WITH SNUM IN B
R1INT:	JSR	PC,GETINT
R1NARG:	JSR	PC,.CSNIN	;CONVERT SNUM TO INUM
	JMP ORTB

PSHINT:	JSR	PC,GETINT
;PUSH A NUMBER ONTO THE S-PDL
PSHNUM:	JSR	PC,.CSNIN
	SPUSHS	B
	RTS	PC
.IFZ FPPF


;GET 2 INTEGERS FROM THE S-PDL
G2IARG:	JSR	PC,G1IARG
	MOV	B,E
	MOV	C,F
	JSR	PC,G1IARG
	EXCH	B,E
	EXCH	C,F
ILOAD1:	RTS	PC
G1ARG1:	ERROR+WTAB
.ENDC

;GET 1 INTEGER FROM THE S-PDL
G1IARG:	POPS	B
	SPUSH	A	;SAVE A
	MOV	#INUM,A
	JSR	PC,CONVERT
	BEQ G1ARG1
	JSR	PC,.LOAD	;INTEGER IN A,,B
	MOV	B,C
	MOV	A,B
	SPOP	A
	RTS	PC

.IFZ FPPF
;RETURN 1 INTEGER FROM B,,C
R1I.BC:	MOV	B,A
	MOV	C,B
	BR	R1I.N

;;RETURN 1 INTEGER FROM E,,F
R1I.EF:	MOV	E,A
	MOV	F,B
R1I.N:	JSR	PC,GRBAD
	BIS	#INUM,C
	JMP	ORTC
.ENDC

.IFNZ FPPF
;ROUTINES TO LOAD FLOATING REGS FROM NODESPACE
G2ARG:	MOV #INUM,F
	JSR PC,G1NUM	;GET 1 INTO FA
	BEQ G1ARG1
	LDD FA,FC
	JSR PC,G1NUM	;GET ANOTHER
	BEQ G1ARG1
	LDD FA,FB
	LDD FC,FA	;SWITCH THEM
	RTS PC		;F WILL CONTAIN TYPE EXPECTED OF
			;ARITHMETIC RESULT

;LOAD ONE ARG INTO FA AND ERROR+WTA
G1ARG:	JSR PC,G1NUM
	BNE ILOAD1
G1ARG1:	ERROR+WTAB

;LOAD ONE ARG INTO FA AND CLZ

G1NUM:	POPS B
G1NUMS:	MOV B,A	;IS IT ALREADY AN FNUM?
	BIC #7777,A
	CMP #FNUM,A
	BEQ G1FAG
	MOV #INUM,A
	JSR PC,CONVERT	;TRY TO GET AN INUM
	BNE .FLOAD
G1FARG:	MOV #FNUM,A
	JSR PC,CONVERT	;TRY TO GET A FNUM
	BEQ ILOAD1
G1FAG:	MOV A,F		;SET F TO SHOW FNUM

.FLOAD:	BIC #170000,B
	ASL B
	ASL B
	ADD #NODESP,B
	CMP #INUM,A
	BEQ .ILOAD	;LOAD AN INUM?
	LDCFD (B),FA	;LOAD FNUM
	CLZ
	RTS PC
.ILOAD: LDCIF (B),FA	;LOAD INUM
	CLZ
ILOAD1:	RTS PC
.ENDC




;GET 1 SNAP
;	RETURN POINTER TO SNAP IN D, DELTA X IN E, DELTA Y IN F
G1SNAP:	MOV	@S,C	;POINTER TO ARG
	BIT	#7777,C	;IS IT EMPTY?
	BEQ	ILOAD1	;YES. RETURN WITHOUT SKIPPING


;LOAD 3 NUMBERS
;	GROVEL DOWN A LIST OF NUMBERS RETURNING 3 NUMBERS IN D,E,F
;	CALL WITH C POINTING TO LIST
;	IF LIST CONTAINS 1)NON-NUMBERS OR 2)MORE THAN 3 ELEMENTS,
;	THEN ERROR+WTA
LD3NUM:	PUSH	A
	SPUSH	B
	SPUSH	C
	MOV	#7777,D	;AN OFT USED CONSTANT
	MOV	#3,F	;COUNTER
LDN.L:	BIT	D,C	;IS THERE MORE LIST?
	BEQ	LDN.ER	;ERROR
	JSR	PC,.LOADC	;LOAD A WITH NEXT ELEMENT
	MOV	A,C
.IFNZ FPPF
	CMP #3,F
	BGT LDN.E
.ENDC
	MOV	#SNUM,A
	JSR	PC,CONVERT
	BEQ LDN.ER
LDN.E:	SPUSH	B	;PUSH THIS ELEMENT
	SOB F,LDN.L
	BIT	D,C	;IS THE LIST FINISHED?
	BNE	LDN.ER	;NO. ERROR
	JMP	SRETF	;SKIP RETURN AND RESTORE ALL AC'S!

LDN.ER:	ERROR+WTA
	.STITL EVAL

EVAL:	JSR PC,GNT	;GET NEXT TOKEN, RETURNED IN A
	JSR PC,STRACE	;CHECK FOR SYSTEM TRACE
	BIC #DPQF+CPTBF,FLAGS2	;DON'T PRINT QUOTE, CHANGE % TO BLANK
	BIC #7777,A
	CMP A,#UFUN	;USER FUNCTION?
	BLOS EVFUN
	CMP A,#UVAR	;USER VARIABLE?
	BEQ EVVAR
	CMP A,#SSTR
	BHI .+4
EVWHAT:	.BUG.
	CMP A,#ATOM
	BEQ EVATM
	CMP A,#SNUM	;INTEGER?
	BEQ EVWHAT
.IIF Z FPPF,	CMP A,#LSTR
.IIF NZ FPPF,	CMP A,#FNUM
	BLOS EVCON
	CMP A,#LIST
	BNE EVWHAT
EVCON:
EVATM:
.IIF Z BEEF,	PUSHS CT+2	;SAVE ON S-PDL FOR OUTPUT
.IIF NZ BEEF,	PUSHS CT	;SAVE ON S-PDL FOR OUTPUT
	BR EVI
EVVAR:	BIC #170000,B
	BIS #ATOM,B
	MOV B,D		;SAVE UOE PTR FOR ERROR
	JSR PC,.BINDL
	BEQ EVVAR2	;NO BINDING FOUND
	TST B		;NIL?
	BNE EVVAR1	;NO, GOOD
	MOV D,B
EVVAR2:	ERROR+HNV	;... HAS NO VALUE
EVVAR1:	PUSHS B		;SAVE IT FOR OUTPUT
EVI:	JSR PC,GNT	;ABOUT TO OUTPUT A VALUE.
			;BEFORE WE DO, CHECK TO SEE IF
			;NEXT TOKEN IS INFIX WHICH SHOULD GOBBLE IT.
	BIC #7777,A	;IS NEXT TOKEN INFIX?
	CMP #INFIX,A
	BEQ CKPRCD	;YES
EVI1:	BIS #RTF,FLAGS	;SET REPEAT TOKEN FLAG
	BIC #CRF,FLAGS	;CLEAR CARRIAGE RETURN TOKEN FLAG
	CLZ
	RTS PC
CKPRCD:
.IIF Z BEEF,	TST CO+2	;COMPARE PRECEDENCE
.IIF NZ BEEF,	TST CO		;COMPARE PRECEDENCE
	BEQ EVI2
.IIF Z BEEF,	MOV CT+2,A
.IFNZ BEEF
	MOV CT,A
	BIC #170000,A	;CLEAR OUT THE TYPE (FOR INFIX TYPES)
.ENDC
	ASL A
	MOV SOBLST(A),A	;SYSTEM OBLIST ELEMENT (NEXT OPER.)
	BIC #7777,A
	MOV COF,B	;CURRENT OPERATOR FLAG
	BIC #7777,B
	CMP A,B		;IS PRECD OF CO >= PRECD NEXT OPER
	BLO EVI1	;YES, > - GIVE OUTPUT TO CO
	BEQ EVI4	;YES, = - CHECK FOR _
		;NO - NEXT TOKEN SHOULD GOBBLE THIS OUTPUT
EVI2:	JSR PC,STRACE
.IFZ BEEF
EVI12:	CMP #$BKAR,CT+2	;CHECK FOR SUCCESSIVE _'S
	BNE EVI3		;   "A _"B _0
	CMP #$BKAR,CO+2
	BEQ EVI13
	CMP #$TBKAR,CO+2
	BNE EVI3
EVI13:	MOV #$TBKAR,CT+2
EVI3:	PUSH CO
	SPUSH CO+2
	SPUSH NOR	;NO. OF OPERANDS STILL NEEDED
	MOV CT,CO
	MOV CT+2,CO+2
	MOV CO+2,A	;GET FLAGS
	ASL A
	MOV SOBLST(A),COF	;SET CURRENT OPERATOR FLAG
	MOV #1,NOR
	JMP EVW		;CALLS EVAL
EVI4:	CMP #$BKAR,CT+2	;PRECD ARE = - IF _ DO RIGHT ONE FIRST
	BEQ EVI2	;IT IS _
	BR EVI1
.ENDC
.IFNZ BEEF
EVI12:	CMP #INFIX+$BKAR,CT	;CHECK FOR SUCCESSIVE _'S
	BNE EVI3		;   "A _"B _0
	CMP #INFIX+$BKAR,CO
	BEQ EVI13
	CMP #INFIX+$TBKAR,CO
	BNE EVI3
EVI13:	MOV #INFIX+$TBKAR,CT
EVI3:	PUSH CO
	SPUSH NOR	;NO. OF OPERANDS STILL NEEDED
	MOV CT,CO
	MOV CO,A	;GET FLAGS
	BIC #170000,A	;CLEAR OUT THE INFIX TYPE
	ASL A
	MOV SOBLST(A),COF	;SET CURRENT OPERATOR FLAG
	MOV #1,NOR
	JMP EVW		;CALLS EVAL
EVI4:	CMP #INFIX+$BKAR,CT	;PRECD ARE = - IF _ DO RIGHT ONE FIRST
	BEQ EVI2	;IT IS _
	BR EVI1
.ENDC

.IFZ BEEF
EVFUN:	BIT #CRF,FLAGS	;CT IS A FUNCTION
	BEQ 1$
	ERROR+UELX	;UNEXPECTED END OF LINE
1$:	CMP #$LPAR,CT+2	;IS NEXT TOKEN A LEFT PAREN?
	BNE EVF1
	TST CO+2	;NEXT OPERATOR?
	BEQ EVF11	;NOTHING THERE
.IFNZ ENG
	CMP #$DO,CO+2	;IS NEXT OPERATOR A RUN COMMAND?
	BEQ EVF11
.ENDC
.IFNZ FR
	CMP #$EXECUT,CO+2
	BEQ EVF11
.ENDC
	CMP #$LLPAR,CO+2
	BNE EVF1
EVF11:	MOV #$LLPAR,CT+2	;INSERT PARENS.FOR PARSE
EVF1:	PUSH CO
	SPUSH CO+2
	SPUSH NOR	;NO. OF ARGS NEEDED FOR CO'S EXECUTION
	CMP #$LLPAR,CO+2	;IF CO IS !(, PUSH IFLEV INSTEAD OF NOR
	BNE EVF13
	MOV IFLEV,(P)
	CLR IFLEV
EVF13:	MOV CT,CO
	MOV CT+2,CO+2
	BIC #EDTIF2,FLAGS
EVF2:	CMP A,#UFUN	;IS POPPED OPER. A  USER FUNCTION?
	BLO MFUN	;NO, MACHINE
	MOV #<PREPRI_13.>,COF	;SET PRECD TO PREPRI
	JSR PC,GNASN	;GET NO. OF ARGS IN B
	BNE 1$		;FOUND FBINDING
	ERROR+HNM	;... HAS NO MEANING
1$:	MOVB B,B	;CLEAR ANY LEFT HALF FLAGS
	MOV B,NOR
	BEQ EVXP	;EVAL IT, WE ARE DONE
	JMP EVL1

EVXP:	JSR PC,STRACS	;NO MORE, SPACE AND CHECK FOR SYSTEM TRACE
	JSR PC,PEVAL	;SET TO EVALUATE THIS USER PROCEDURE
	BEQ XNORT	;PEVAL DOES SEZ  IF THERE IS NO OUTPUT
	JMP XORT		;DOES CLZ IF THERE IS
MFUN:	MOV CO+2,A	;GET FLAGS FOR THIS MACHINE PROCEDURE
;FALLS THROUGH
.ENDC

.IFNZ BEEF
EVFUN:	BIT #CRF,FLAGS	;CT IS A FUNCTION
	BEQ 1$
	ERROR+UELX	;UNEXPECTED END OF LINE
1$:	CMP #$LPAR,CT	;IS NEXT TOKEN A LEFT PAREN?
	BNE EVF1
	TST CO		;NEXT OPERATOR?
	BEQ EVF11	;NOTHING THERE
.IFNZ ENG
	CMP #$DO,CO	;IS NEXT OPERATOR A RUN COMMAND?
	BEQ EVF11
.ENDC
.IFNZ FR
	CMP #$EXECUT,CO
	BEQ EVF11
.ENDC
	CMP #$LLPAR,CO
	BNE EVF1
EVF11:	MOV #$LLPAR,CT	;INSERT PARENS.FOR PARSE
EVF1:	PUSH CO
	SPUSH NOR	;NO. OF ARGS NEEDED FOR CO'S EXECUTION
	CMP #$LLPAR,CO	;IF CO IS !(, PUSH IFLEV INSTEAD OF NOR
	BNE EVF13
	MOV IFLEV,(P)
	CLR IFLEV
EVF13:	MOV CT,CO
	BIC #EDTIF2,FLAGS
EVF2:	CMP A,#UFUN	;IS POPPED OPER. A  USER FUNCTION?
	BLO MFUN	;NO, MACHINE
	MOV #<PREPRI_13.>,COF	;SET PRECD TO PREPRI
	JSR PC,GNASN	;GET NO. OF ARGS IN B
	BNE 1$		;FOUND A FUNCTION BINDING
	ERROR+HNM	;... HAS NO MEANING
1$:	MOVB B,B	;CLEAR ANY LEFT HALF FLAGS
	MOV B,NOR
	BEQ EVXP	;NO ARGUMENTS, THEN JUST EVALUATE IT
	JMP EVL1

EVXP:	JSR PC,STRACS	;NO MORE, SPACE AND CHECK FOR SYSTEM TRACE
	JSR PC,PEVAL	;SET TO EVALUATE THIS USER PROCEDURE
	BEQ XNORT	;PEVAL DOES SEZ  IF THERE IS NO OUTPUT
	JMP XORT		;DOES CLZ IF THERE IS
MFUN:	MOV CO,A	;GET FLAGS FOR THIS MACHINE PROCEDURE
;FALLS THROUGH
.ENDC
;FALLS IN
.IIF NZ BEEF,	BIC #170000,A	;CLEAR THE INFIX TYPE
	ASL A
	MOV SOBLST(A),A
	MOV A,COF
	SWAB A
	BIC #177774,A	;FIND NO. OF ARGS. NECESSARY
	MOV A,NOR
	BNE EVS		;IS  NO. ARGS = 0? (BRANCH IF NO)
	BIT #PTLPF,FLAGS	;PREVIOUS TOKEN LP?
	BEQ EVXM	;NO, AND NO ARGS NEEDED, EXECUTE
	BIT #VNAF,COF	;VARIABLE?
	BNE EVL		;YES, GO MAYBE GOBBLE ARG(S)
EVXM:	JMP MEVAL	;YES.  EXECUTE THIS MACHINE PROCEDURE

XNORT:	BIC #EDTIF,FLAGS
	BIT #EDTIF2,FLAGS
	BEQ NORT0
	BIS #EDTIF,FLAGS
NORT0:	MOV #EVDNO,A	;SET RETURN TO INDICATE NO OUTPUT
NORT1:
.IIF Z BEEF,	MOV CO+2,LO+2	;UPDATE OPERATORS
	MOV CO,LO
	POP NOR
	SPOP B
.IIF Z BEEF,	MOV B,CO+2
.IIF NZ BEEF,	MOV B,CO
.IIF Z BEEF,	SPOP CO
	CMP #$LLPAR,B	;IF POPPED OPER IS !(, IFLEV_NOR, NOR_1	
	BNE NORT3
	MOV NOR,IFLEV
	MOV #1,NOR
NORT3:	CLR COF
	TST B
	BEQ NORT2	;NO MORE OPERATORS
	BIT #160000,CO	;IS IT A UFUN
	BNE NORT2	;YES
.IIF NZ BEEF,	BIC #170000,B	;CLEAR THE INFIX TYPE
	ASL B		;NO, MUST BE A PRIMITIVE. GET OFFSET IN BYTES
	MOV SOBLST(B),COF
NORT2:	JMP (A)		;RETURN DEPENDS ON WHETHER OUTPUT EXISTS
EVDNO:	SEZ
	RTS PC
EVS:	BIT COF,#INFIX	;IS CO INFIX OP
	BEQ EVL		;NO
	JSR PC,CKUI	;CHECK FOR VALID UNARY INFIX +,-
	BNE EVW
	ERROR+INF1	;INFIX IN WRONG PLACE
PROC:	MOV @S,B	;THE WORD
	BIT #7777,B	;IS IT THE EMPTY WORD
	BNE 1$
	ERROR+WTA
1$:	JSR PC,GUOEB	;PEVAL INVOKED VIA "#"
	BEQ PROC1
	MOV B,(P)	;OLD RETURN - POPPED LATER
	JSR PC,.BINDF	;IS A PROC DEFINED
	BEQ PROC3	;NO
	MOV #UFUN,CO	;YES
	MOV (P),B
PROC2:	CLR TOPS
.IIF Z BEEF,	MOV B,CO+2
.IIF NZ BEEF,	MOV B,CO
	SPOP B		;GET P BACK IN PHASE
	JMP EVF2
PROC3:	JSR PC,.LOAD	;GET PNAME FOR UOBSCH
PROC1:	MOV B,TOPS
	MOV #SFUN,A
	JSR PC,UOBSCH	;MAKE SURE CO EXISTS
	BNE 1$
	ERROR+HNM	;HAS NO MEANING
1$:	MOV A,CO
	BR PROC2

EVL:	BIT #PTLPF,FLAGS	;WAS PREVIOUS TOKEN A LEFT PAREN
	BEQ EVL1		;NO
	BIT #VNAF,COF	;DOES CO USE VARIABLE NO. OF ARGS.?
	BEQ EVL1	;NO
	CLR NOR
	BR EVW9
EVL1:	JSR PC,GNT
EVW1:	BIS #RTF,FLAGS	;SET REPEAT TOKEN FLAG
	BIC #CRF,FLAGS
EVW:	JSR PC,EVAL	;EVALUATE THIS ARGUMENT
	BEQ EVW2	;NO OUTPUT FROM EVAL
	DEC NOR
	BEQ EVX		;WHEN NOR = 0, WE'VE ENUF INPUTS
EVW9:	JSR PC,GNT
	TST NOR		;IF NOR < 0 AND NEXT TOKEN IS ")" THEN THE ")" 
	BGT EVW1	;TERMINATES THE ARG SCAN FOR THE CO
.IIF Z BEEF,	CMP #$RPAR,CT+2  ;IS IT?
.IIF NZ BEEF,	CMP #$RPAR,CT
	BNE EVW1	;NO
	BIS #RTF,FLAGS
	BIC #CRF,FLAGS
	NEG NOR
	CMP #MAXARG,NOR
	BGE MEVALN	;EXECUTE MACHINE PROC.
	ERROR+TMAC	;TOO MANY ARGS COMMAND/OPERATION
EVX:	BIT #160000,CO	;IS IT A MACHINE PROCEDURE
	BEQ 1$
	JMP EVXP	;NO
1$:	BIT #VNAF,COF	;MACHINE PROC NOW HAS ITS "STD" NO. OF ARGS.
		;IF IT CAN TAKE A VARIABLE NO., THEN THE "STD" NO. HAS
		;BE PUSHED ON P
	BEQ MEVAL	;IT DOESN'T- GO EVALUATE IT
	MOV COF,A
	SWAB A
	BIC #177774,A
	MOV A,NOR
	BR MEVALN	;SAME AS MEVAL BUT SAVES NO. OF ARGS
EVW2:
.IIF Z BEEF,	CMP #$LLPAR,CO+2	;EVAL SHOULD OUTPUT WHEN NOT AT TOP LEVEL
.IIF NZ BEEF,	CMP #$LLPAR,CO		;EVAL SHOULD OUTPUT WHEN NOT AT TOP LEVEL
	BEQ EVW		;EXCEPT WHEN CO IS LLPAR
	ERROR+NOU	;WHAT, NO OUTPUT??!!

LLPAR:
LPAR:	JSR PC,GNT
.IIF Z BEEF,	CMP #$RPAR,CT+2
.IIF NZ BEEF,	CMP #$RPAR,CT
	BEQ LPAR1
	ERROR+TIP	;TOO MUCH INSIDE PARENS
LPAR1:	CLZ
	RTS PC

RPAR:	BIT #PTLPF,FLAGS
	BEQ 1$
	ERROR+NIP	;NOTHING INSIDE PARENS
1$:	CMP 4(P),#$LLPAR	;IS PENDING COMMAND !(
	BNE RPAR1
RPAR2:	POP A
	MOV (P),IFLEV
.IIF Z BEEF,	ADD #6,P	;POP !( OFF STACK
.IIF NZ BEEF,	CMP (P)+,(P)+	;POP !( OFF THE STACK
	MOV A,(P)		;CRETINOUS NON-LOCAL RETURN
	SEZ
	RTS PC

RPAR1:	ERROR+ERP	;EXTRA RIGHT PAREN
CKUI:	PUSH A
.IIF Z BEEF,	MOV CO+2,A
.IFNZ BEEF
	MOV CO,A
	BIC #170000,A	;CLEAR THE INFIX TYPE
.ENDC
	CMP A,#$PLUS	;+
	BNE CKUI1
	MOV #$UPLUS,A
CKUI0:
.IIF Z BEEF,	MOV A,CO+2
.IIF NZ BEEF,	MOV A,CO
	ASL A
	MOV SOBLST(A),COF
	MOV #1,NOR
	JMP SRETA

CKUI1:	CMP A,#$MINUS	;-
	BNE CKUI2
	MOV #$UMINS,A
	BR CKUI0

CKUI2:	POP A
	RTS PC

MEVALN:	PUSH NOR
MEVAL:	JSR PC,STRACS
.IIF Z BEEF,	MOV CO+2,A	;GET SOE POINTER
.IFNZ BEEF
	MOV CO,A
	BIC #170000,A	;CLEAR OUT THE INFIX TYPE
.ENDC
	CLR NBKTS
	ASL A
	JSR PC,@2+SOBLST(A)	;JMP ADDR IS IN 2ND WORD
	BNE XORT	;PROCEDUE OUTPUTS
	LDFPS #40300
	JMP XNORT	;NO OUTPUT
XORT:	LDFPS #40300
	MOV #EVI,A
	JMP NORT1

ORTNA:	MOV A,@S
	BR SRET
ORTNB:	MOV B,@S
	BR SRET
ORTNC:	MOV C,@S
	BR SRET
ORTND:	MOV D,@S
	BR SRET
ORTNE:	MOV E,@S
	BR SRET
ORTNF:	MOV F,@S
	BR SRET
ORTNP:	MOV	(SP)+,@S
	BR SRET


ORTA:	PUSHS A
	BR SRET
ORTB:	PUSHS B
	BR SRET
ORTC:	PUSHS C
	BR SRET
ORTD:	PUSHS D
	BR SRET
ORTE:	PUSHS E
	BR SRET
ORTF:	PUSHS F
	BR SRET
ORTP==.
ORTSP:	PUSHS	(SP)+

RETF:	POP F
	BR RETE1
RETE:	POP E
	BR RETD1
RETD:	POP D
	BR RETC1
RETC:	POP C
	BR RETB1
RETB:	POP B
	BR RETA1
RETA:	POP A
	SEZ
	RTS PC

RETF1:	SPOP F
RETE1:	SPOP E
RETD1:	SPOP D
RETC1:	SPOP C
RETB1:	SPOP B
RETA1:	SPOP A
RET:	SEZ
	RTS PC

SRETF:	POP F
	BR SRETE1
SRETE:	POP E
	BR SRETD1
SRETD:	POP D
	BR SRETC1
SRETC:	POP C
	BR SRETB1
SRETB:	POP B
	BR SRETA1
SRETA:	POP A	;POP A THEN DO CLZ RETURN
	BR SRET

SRETE1:	SPOP E
SRETD1:	SPOP D
SRETC1:	SPOP C
SRETB1:	SPOP B
SRETA1:	SPOP A	;POP A THEN DO CLZ RETURN
CKTYP:
SRET:	CLZ
	RTS PC
	.STITL PROCEDURE EVALUATOR
PEVAL:	JSR PC,CKSTG	;CHECK STORAGE
.IIF Z BEEF,	MOV CO+2,B	;FIRST CHECK IF PROC IS THERE
.IIF NZ BEEF,	MOV CO,B	;FIRST CHECK IF THE PROC IS THERE
	JSR PC,.BINDF	;GET BINDING
	BNE 1$
	ERROR+HNM	;PROCEDURE HAS NO MEANING
1$:	JSR PC,SAVEVL	;SAVE ALL PROCEDURE INFORMATION
.IFZ BEEF
	;GET ARG LIST - PUT UOE POINTERS AND VALUES FROM THERE ON S
	MOV A,C		;SAVE PTR TO LLP (LIST OF LINEPTRS)
	JSR PC,.LOAD	;GET FLAGS,,#ARGS
.IFF
	MOV B,C		;SAVE POINTER TO THE ARRAY WE WILL EVAL
	MOV CO,B	;GET BACK POINTER TO THE ATOM
	MOV B,CPP	;SET UP POINTER TO PROCEDURE NAME
	JSR PC,GNASN	;GET THE NUMBER OF ARGMENTS AND FLAGS IN B
.ENDC
	MOV B,FLAGS
	MOVB B,B
	SPUSH B		;PUSH # ARGS
	BIC #-<TPTF+TPSF>-1,FLAGS  ;CLEAR ALL BUT TRACE AND STEP FLAGS
	BNE PEV3
	BIT #TRACEF,FLAGS2	;IS TRACE SET?
	BEQ PEV6	;NO
PEV3:
.IIF Z BEEF,	MOV CO+2,B
.IIF NZ BEEF,	MOV CO,B	;SET UP B TO POINT TO THE PROCEDURE
	INC FUNLEV
	JSR PC,TINDNT	;SET SPACING ACCORDING TO FUNCTION LEVEL
	DEC FUNLEV
LANGC	<JSR PC,PPNAME	;PRINT PROCEDURE NAME
	PRTXT ^\'S INPUTS: \>,<
	PRTXT ^/LES INPUTS DE /
	JSR PC,PPNAME
	PRTXT ^/ SONT:/>
	MOV (P),B	;# OF ARGS
PEV6:	SPUSH C		;SAVE FOR BELOW (POINTS TO LASTLINEPTR)
			;SAVE FOR BELOW POINTS TO START OF THE ARRAY
	MOV B,D		;NO. OF ARGS
	BEQ PEV2	;NO ARGS
.IFZ BEEF
	JSR PC,.LOADC
	JSR PC,.LOAD
	SPUSH A		;SAVE PTR TO REST OF TITLE LINE
.IFF
	ADD #HEADER,C	;POINT TO THE START OF THE ARRAY DATA
	ADD (C)+,C	;POINT TO THE TITLE LINE
	SPUSH C		;PUSH POINTER TO THE ARGUMENTS LINE
.ENDC
	CMP SPUSHL,S	;ENOUGH ROOM ON S-PDL?
	BLOS 2$	;OK
	JSR PC,SPSWPO	;SWAP OUT S-PDL
2$:	MOV D,B		;# OF ARGS
	ASL B		;MULTIPLY BY TWO FOR OFFSET
	MOV S,D
	MOV D,E
	SUB B,E
	MOV E,S
	ASR B
;DROPS INTO NEXT PAGE
	;DROPPED IN FROM ABOVE
1$:	MOV (D)+,(E)+	;GET ARGS ON TOP OF STACK
	SOB B,1$
	MOV (P),A	;GET SAVED LLP PTR
.IFNZ BEEF
	MOV A,F		;POINTER TO THE END OF THIS LINE
	ADD (A),F	;POINT TO THE START OF THE NEXT LINE
	ADD #2,F	;BECAUSE THE NUMBER OF VARIABLES IS ON THIS LINE
	ADD #4,A	;MAKE A POINT TO THE FIRST VARIABLE
	MOV A,(P)	;AND PUT IT BACK
.ENDC
PEV1:	TST FLAGS
	BNE PEV4	;TRACE IS SET
	BIT #TRACEF,FLAGS2
	BEQ PEV5	;NO TRACE
PEV4:	MOV -2(E),B	;TOP ARGUMENT
	MOV B,A
	INC NBKTS
	SPUSH D
	JSR PC,PRTAB	;PRINT TOKEN IN A,,B
	DEC NBKTS
	SPOP D
	MOV (P),A	;POINTER TO ARG ON TOP OF SATCK
PEV5:
.IIF Z BEEF,	JSR PC,.LOADA	;GET THE ARG
.IIF NZ BEEF,	MOV (A)+,B	;GET THE NEXT ARGUMENT
	MOV A,(P)	;PTR. TO NEXT NODE
	CMP #$COMT,B	;IS CURRENT NODE A COMMENT?
	BNE PEV10
PEV12:
.IIF Z BEEF,	BIT #7777,A	;END OF ARGUMENT?
.IIF NZ BEEF,	CMP A,F		;ARE WE POINTING TO THE NEXT LINE?
	BEQ PEV11	;YES
.IIF Z BEEF,	JSR PC,.LOADA
.IIF NZ BEEF,	MOV (A)+,B	;GET THE NEXT TOKEN ON THIS LINE
	CMP #$COMT,B
	BNE PEV12
	BR PEV5

PEV10:	JSR PC,SAVVAR	;SAVE THIS VARIABLE BINDING
	MOV (P),A
.IIF Z BEEF,	BIT #7777,A
.IIF NZ BEEF,	CMP A,F		;ARE WE AT THE END OF THE TITLE LINE?
	BEQ PEV11
	TST FLAGS
	BNE PEV10A
	BIT #TRACEF,FLAGS2
	BEQ PEV1
PEV10A:	PRTXT ^/,/
	BR PEV1		;GO DO NEXT ARG

PEV11:	SPOP C		;USED TITLE LINE POINTER
PEV2:
	SPOP C		;PTR TO LLP THAT WAS PUSHED WAY ABOVE
			;POINTER TO THE START OF THE ARRAY
.IFNZ BEEF
	MOV (C),CPBND	;SET UP POINTER TO THE BINDING NODE
	INC 4*2(C)	;INCREMENT THE REFERENCE COUNT FOR THIS PROCEDURE
	MOV C,F		;COPY IT
	ADD #HEADER,F	;POINT TO THE PROCEDURE START
	ADD (F)+,F	;POINT TO THE VARIABLE'S LINE
	ADD (F)+,F	;POINT TO THE FIRST LINE
	SUB C,F		;MAKE IT RELATIVE TO THE START OF THE PROCEDURE ARRAY
	MOV F,NEXLIN	;F POINTS TO THE FIRST EXECUTABLE LINE OF THE PROCEDURE
	CMP F,5*2(C)	;IS IT = TO THE END OF THE PROC?
	BNE 1$		;NO
	CLR NEXLIN	;OH WELL, MAKE IT STOP AT EVAL LEVEL
1$:
.ENDC
	TST FLAGS
	BNE PEV2A	;TRACE SET
	BIT #TRACEF,FLAGS2
	BEQ PEV2B	;NO TRACE
PEV2A:	PRCR
PEV2B:	JSR PC,SAVPPS	;SAVE PDL PTRS
	BIS #1,CPDLP	;INDICATES PROC PUSH AS OPPOSED TO A LOCAL PUSH
.IFZ BEEF
	MOV CO+2,B
	MOV C,CLP
	MOV B,CPP	;GET CPSN IN A
	JSR PC,GNASN
	MOV A,CPSN
	CLR CO+2
.ENDC
	CLR CPLN
	CLR CO
	CLR IFLEV
	INC FUNLEV
	JMP MLOOP
SAVVAR:	;SAVE IN (D) VARIABLE BINDING OF UOE PT'ED TO BY B
		;GIVE IT NEW VALUE WHICH IS AT (E)
		;USES A,C.  TOPS MUST BE 0
		;BOTH D AND E ARE -()ED
	MOV B,-(D)	;SAVE UOE PTR
	MOV #VBIND,A	;THIS WILL CHECK SPDL THINGS--
			;NOP IT IF IT SEEMS TO CAUSE TROUBLE.  RWW
	JSR PC,.BINDL	;NOW GET VARIB. BINDING
	BEQ SAVV2	;NOT THERE
SAVV1:	MOV -(E),A	;GET NEW VALUE PTR
	MOV B,-(D)	;SAVE OLD VALUE PO[NTER
	MOV A,B
	JSR PC,.LDP1
	BIC #100000,A	;MAKE SURE BINDING NODE SAYS "VBIND"
	JSR PC,.STORE	;STORE NEW BINDING AWAY
	RTS PC

SAVV3:	TST -(E)
	CLR -(D)	;THERE IS NO OLD VALUE POINTER
	RTS PC

SAVV2:	TST -2(E)
	BEQ SAVV3	;IF NEW VALUE = 0, DON'T BOTHER TO CREATE CELL
	MOV #VBIND,A
	CLR B
	JSR PC,GRBAD1
	BR SAVV1

SAVPPS:	POP F	;SAVE P AND S PDL PTRS
	SPUSH CSPDLP
	MOV IS,A	;COMPUTE RELATIVE S PDL PTR
	SUB S,A		;CURRENT TOP OF S-PDL
	ADD SPRBAO,A	;# OF PDL BLOCKS SWAPPED OUT
	MOV A,CSPDLP
	SPUSH CPDLP
	MOV IP,A	;COMPUTE RELATIVE P PDL PTR
	SUB P,A
	ADD PRBAO,A
	MOV A,CPDLP
	JMP (F)

TINDNT:	PUSH A	;TRACE INDENT
	MOV FUNLEV,A
TIND2:	DEC A
	BGT TIND1
	JMP RETA
TIND1:	SPACE
	BR TIND2
LOCAL:	JSR PC,GUOEB	;GET UOE PTR FROM S
LOC9:	MOV IS,F	;MOVE STUFF FROM S TO P PDLS
	SUB S,F
	ADD SPRBAO,F
	MOV CSPDLP,D
	BIC #1,D
	SUB D,F
	ASR F
	MOV F,A
	BLE LOC2
LOC1:	POPS D
	PUSH D
	DEC A
	BGT LOC1
LOC2:	MOV S,D	;NOW STORE AWAY PTR & OLD VALUE
	PUSHS #0
	MOV S,E
	PUSHS #0
	JSR PC,SAVVAR
	MOV F,A	;NOW RETURN STUFF FROM P TO S
	BLE LOC4
LOC3:	POP D
	PUSHS D
	DEC A
	BGT LOC3
LOC4:	MOV IP,A	;NOW MOVE STUFF FROM P TO S
	SUB P,A
	ADD PRBAO,A
	MOV CPDLP,D
	BIC #1,D
	SUB D,A
	ASR A
	MOV A,F
	BLE LOC6
LOC5:	POP D
	PUSHS D
	DEC A
	BGT LOC5
LOC6:	PUSH #1	;PUSH GOODIES ON P
	SPUSH CSPDLP
	SPUSH CPDLP
	BIC #1,CPDLP	;INDICATE LOCAL PUSH
	BIC #1,CSPDLP
	ADD #4,CSPDLP
	ADD #6,CPDLP
	MOV F,A
	BLE LOC8
LOC7:	POPS D	;NOW RETURN STUFF TO P
	PUSH D
	DEC A
	BGT LOC7
LOC8:	SEZ
	RTS PC


.STITL PROC EVAL - "OUTPUT" "STOP"
.IFZ BEEF
OUTPUT:	TST FUNLEV
	BGT .+4
OUTPU1:	ERROR+OIP	;ONLY IN PROCEDURE
	MOV #SRET,PSTOPR ;"OUTPUT" (CLZ FOR RETURN)
	POPS TOPS1	;SAVE THE OUTPUT
	BR PSTP10
STOP:
PSTOP:	TST FUNLEV
	BLE OUTPU1
	MOV #RET,PSTOPR	;"STOP" AND "END" (SEZ FOR RETURN)
	CLR TOPS1
	MOV #PSTP15,ERFRET	;RETURN ADDRESS FROM ERROR SET FRAME
PSTP10:	MOV #PSTP18,DOFRET	;SAME FOR DO FRAME
	BIT #DORF,FLAGS		;IS THIS A DO OR READ FRAME?
	BEQ PSTP12	;NO
PSTP14:	JSR PC,RESPPS	;RESTORE PDLS
	POP B		;RETURN ADDRESS
	BIT #TF7,TFLAGS	;IS THIS AN ERROR SET FRAME?
	BEQ PSTP16	;NO
	MOV B,ERPROC
	BR PSTP14
PSTP16:	JSR PC,RESEVL	;RESTORE PROCEDURE VARIABLES
	MOV B,FLAGS
	BR PSTP10
PSTP12:	BIT #TPTF+TPSF,FLAGS	;STEP OR TRACE FLAGS SET?
	BNE PSTP11	;YES
	BIT #TRACEF,FLAGS2
	BEQ PSTP15	;NO TRACE
PSTP11:	JSR PC,TINDNT
	MOV CPP,B
	JSR PC,PPNAME
	MOV TOPS1,B
	BEQ PSTP13
	PRTXT ^\ OUTPUTS \
	INC NBKTS
	JSR PC,PNODAB	;USES A (PRINTS OUT OBJECT ON S AS STRING)
	DEC NBKTS
	PRCR
	BR PSTP15
PSTP13:	LANGC <PRTXTC ^\ STOPS.\>,<
	PRTXTC ^/ STOPPE./>
PSTP15:	JSR PC,RESPPS	;RESTORE PDLS
	BIT #TF7,TFLAGS	;IF IT WAS AN ERROR SET FRAME, GO TO @ERFRET
	BEQ PSTP21	;IT WASN'T
	POP ERPROC
	JMP @ERFRET
PSTP21:
	SPOP D	;# ARGS SAVED
	BEQ PSTOP4	;NO ARGS
PSTOP3:	POPS E		;GET OLD VARIBLE BINDING
	SPOPS B		;GET NEXT UOE PTR
	MOV #VBIND,A
	TST E		;IS OLD BINDING NIL?
	BNE PSTP31	;NO
	JSR PC,.UNBND	;YES, GET RID OF IT
	BR PSTP33
PSTP31:	JSR PC,.BINDL	;GET VARIB BINDING PTR
	BEQ PSTPE3	;NONE THERE
	MOV E,B		;GET OLD VARIB BINDING
	JSR PC,.STORE	;RESTORE OLD BINDING
PSTP33:	DEC D		;ONE LESS ARG
	BGT PSTOP3	;GET NEXT BINDING IF MORE LEFT
PSTOP4:	BIT #TF3,TFLAGS	;WAS IT A LOCAL PUSH OR PROC PUSH
	BEQ PSTP15	;LOCAL
	CMP #SRET,PSTOPR	;WAS IT "OUTPUT"
	BNE PSTP42	;NO
	PUSHS TOPS1	;PUT THE OUTPUT BACK ON S
	CLR TOPS
	CLR TOPS1
;FALLS THROUGH
;FALLS IN
PSTP42:	BIT #DORF,FLAGS	;DO OR READ FRAME?
	BNE PSTP45	;YES
	DEC FUNLEV	;UP ONE LEVEL
PSTP45:
	JSR PC,RESEVL
	MOV B,FLAGS
	BIT #DORF,FLAGS
	BEQ PSTP18
	JMP @DOFRET
PSTP18:	TST FUNLEV	;IF AT TOP LEVEL, ALMOST DONE!
	BLE PSTOP9	;IT IS
PSTP43:	MOV CPP,B
	JSR PC,.BINDF	;MAKE SURE PROC IS IN
	BEQ PSTPE2	;PROCEDURE ... NOT HERE
	MOV CPP,B	;SEE IF PROC'S CPSN AGREE
	JSR PC,GNASN	;GET CPSN
	BEQ PSTPE3	;IMPOSSIBLE!!!
	MOV CLP,C
	BIS #TF3,TFLAGS
	CMP A,CPSN
	BEQ PSTP41	;OK
	BIC #TF3,TFLAGS
	MOV CPLN,B	;DON'T AGREE, GO RELOCATE LINE WE WERE IN
	JSR PC,GTLINE
	BEQ PSTPE4
PSTP41:	MOV C,CLP
	JSR PC,.LOADC	;GET LLP NODE
	JSR PC,.LOAD	;GET LINE #
	MOV A,C
	JSR PC,.LOADC	;GET NEXT NODE-SEE IF SNUM (I.E. GEN NO.)
	BIC #7777,A
	CMP #SNUM,A
	BEQ 1$
	CLR B	;NOT SNUM, SO SET GEN NO. TO 0
1$:	CMP B,CLGN	;ARE GEN #'S =?
	BNE PSTPE4
	BIT #TF3,TFLAGS	;IF PROC WASNT SWAPPED
	BEQ PSTOP8	;THEN CTP IS GOOD
PSTOP9:	CLR D
	MOV CTP,C
	BR PSTOP6
PSTOP8:	MOV CTN,D	;OK, NOW GET NODE NO.
	TST B	;IF B > 0, WE WERE LOOKING GEN NO.
	BEQ PSTOP6
	JSR PC,.LDP1
PSTOP7:	MOV A,C
PSTOP6:	JSR PC,.LOADC
	DEC D
	BGT PSTOP7
	MOV C,CTP
	MOV A,CT
	MOV B,CT+2
	JMP @PSTOPR
PSTPE2:	JSR PC,CHKER
	ERROR+PNH1	;POPPED PROCEDURE NOT HERE
PSTPE3:	JSR PC,CHKER
	.BUG.		;PROCEDURE STRUCTURE SCREWED
PSTPE4:	JSR PC,CHKER
	ERROR+LCE	;LINE CHANGED BY EDIT
.ENDC

.IFNZ BEEF
OUTPUT:	TST FUNLEV		;IN A PROCEDURE
	BGT OUTPU2		;YES
OUTPU1:	ERROR+OIP		;ONLY IN A PROCDURE
OUTPU2:	MOV #SRET,PSTOPR	;SEZ WHEN WE RETURN
	BR PSTOP1		;AND STOP THIS PROCEDURE

STOP:
PSTOP:	TST FUNLEV		;IN A PROCEDURE?
	BLE OUTPU1		;NO, GIVE AN ERROR
	MOV #RET,PSTOPR		;CLZ WHEN WE RETURN
	CLR TOPS1		;JUST RANDOM
PSTOP1:	MOV #POPFRM,DOFRET	;JUST POP THE DO FRAME
	BIT #DORF,FLAGS		;IS IT A DO FRAME?
	BNE POPFRM		;IGNORE THE TRACE
	BIT #TPTF!TPSF,FLAGS	;PROCEDURE TRACED?
	BNE PSTOP3		;YES, PRINT OUT MESSAGE
	BIT #TRACEF,FLAGS2	;ARE ALL PROCEDURES TRACED?
	BEQ POPFRM		;NO, JUST IGNORE
PSTOP3:	JSR PC,TINDNT		;INDENT THE RIGHT AMOUNT
				;HERE PRINT MESSAGE
	MOV CPP,B		;GET POINTER TO PROCEDURE NAME
	JSR PC,PPNAME		;AND PRINT IT
	MOV TOPS1,B		;GET THE OUTPUT
	BEQ PSTOP5		;NO OUTPUT PRINT "STOPS"
	PRTXT ^\ OUTPUTS \	;PRINT "OUTPUTS"
	INC NBKTS		;PRINT BRACKETS AROUND THE OUTPUT
	JSR PC,PNODAB		;AND PRINT THE OUTPUT
	DEC NBKTS		;AND RESET FLAG
	BR PSTOP8		;PRINT CR AND CONTINUE
PSTOP5:	LANGC <PRTXT ^\ STOPS. \>,<
	PRTXT ^\ STOPPE. \>
PSTOP8:	PRCR			;PRINT CR.
;FALLS THROUGH, OR BRANCES INTO NEXT PAGE

;IS BRANCHED INTO, AND FALLEN INTO FROM PREVIOUS PAGE

;HERE IS AN ENTRY POINT FOR RESTORING THE VARIABLES FOR A FRAME
;IF OUTPUTTING, EXPECTS PSTOPR TO BE SRET, AND OUTPUT ON STACK
;POPVAR IGNORES OUPUT, AND JUST POPS THE FRAME
POPFRM:	CMP #SRET,PSTOPR	;OUTPUTTING?
	BNE POPVAR		;NO
	POPS TOPS1		;PUT OUTPUT INTO TOPS1
POPVAR:	JSR PC,RESPPS		;RESTORE THE PDLS
	SPOP D			;GET THE NUMBER OF ARGUMENTS
	BEQ PSTOP6		;NONE, DONT BOTHER REBINDING
PSTOP4:	POPS TOPS		;GET THE OLD VARIABLE BINDING
	SPOPS B			;GETH THE UOE POINTER
	MOV #VBIND,A		;MAKE A VARIABLE BINDING
	TST TOPS		;IS IT GOING TO BE BOUND?
	BEQ PVUNBN		;THEN UNBIND IT
	JSR PC,.BIND		;GET A POINTER TO THE BINDING
PSTOP7:	SOB D,PSTOP4		;DO IT FOR ALL THE VARIABLES
	BR PSTOP6		;DONE WITH THIS FRAME
PVUNBN:	JSR PC,.UNBND		;UNBIND IT
	SOB D,PSTOP4		;AND RETURN TO NEXT VARIABLE
PSTOP6:	BIT #TF3,TFLAGS		;WAS IT A LOCAL PUSH
	BEQ POPVAR		;YES, CONTINUE POPPING UNTIL WE GET TO SOMETHING
				;WITH SOME MEAT ON IT
	BIT #DORF,FLAGS		;IS IT A DO FRAME?
	BNE STOPDO		;STOP A DO FRAME
	BIT #ERRF,FLAGS		;ERROR FRAME?
	BNE 1$			;YES, JUST RETURN
	DEC FUNLEV		;ONE LESS FUNCTION LEVEL
	MOV @CPBND,E		;GET POINTER TO THE ARRAY WE ARE LEAVING IN E
	DEC 4*2(E)		;DECREMENT THE REFERENCE COUNT
	BLT PRCNTB		;ERROR IF LESS THAN 0
	BGT 1$			;STILL REFENCED ON THE STACK
	TST 2*2(E)		;HAS IT BEEN DELETED?
	BPL 1$			;NO
	MOV E,B			;COPY POINTER TO THE ARRAY
	JSR PC,DELPRO		;AND DELETE IT
1$:	JSR PC,RESEVL		;GET BACK EVAL
	MOV B,FLAGS		;AND RESTORE THE FLAGS
	JSR PC,POUTPU		;AND RESTACK OUTPUT IF NEEDED
	JMP @PSTOPR		;SAY WE HAVE STOPPED

STOPDO:	SPOPS A			;GET BACK POINTER TO THE ILINE
	JSR PC,WRTLIN		;AND WRITE IT AWAY
	JSR PC,RESEVL		;RETORE EVAL
	MOV B,FLAGS		;RESTORE THEM
	JSR PC,POUTPU		;OUTPUT IF WE SHOULD
	JMP @DOFRET		;AND NOW WE HAVE CLEANED UP

POUTPU:	CMP #SRET,PSTOPR	;OUTPUTTING?
	BNE POUTP1		;NO
	PUSHS TOPS1		;PUSH OUTPUT ON THE STACK
	CLR TOPS1		;AND FLUSH THE GC-PROTECTION
POUTP1:	RTS PC

PRCNTB:	.BUG.			;REFENCE COUNT WAS NEGATIVE
.ENDC

RESPPS:	SPOP E	;RESTORE P AND S PDLS
	MOV CPDLP,A
	BIC #TF3+TF7,TFLAGS ;SAVE MODE OF PROC/LOCAL PUSH FLAG
	BIT #1,A
	BEQ 1$
	BIS #TF3,TFLAGS	;SET PROCEDURE PUSH FLAG
1$:	BIC #1,A	;ALWAYS EVEN
	JSR PC,PPTA	;POP P TO (A)
	POP CPDLP	 ;RESTORE OLD CPDLP
	MOV CSPDLP,A
	BIT #1,A
	BEQ 2$
	BIS #TF7,TFLAGS	;ERROR SET FLAG
2$:	BIC #1,A
	JSR PC,PSTA	;POP S TO (A)
	SPOP CSPDLP	;RESTORE OLD CSPDLP
	JMP (E)

CHKER:	BIT #HERRF,FLAGS2  ;THIS IS A TERRIBLE THING TO HAPPEN
	BNE CKHER1	;AND IT'S HAPPENED BEFORE!
	BIS #HERRF,FLAGS2  ;OR IF NOT, "DON'T LET IT HAPPEN AGAIN!"
	RTS PC
CKHER1:	CPRTXT ^/HELP!!  RECURSIVE BUG!/
	JSR PC,PPLACE
	CLR CPP
	CLR FUNLEV
	CLR IFLEV
	CLR FLAGS
	JMP ERTL3	;CLEAN UP THE WORLD

.IFZ BEEF
DO:	JSR PC,CKSTG	;MAKE SURE THERE'S ENOUGH STORAGE
	MOV @S,A	;DO...(RUN)
	MOV A,B
	BIC #7777,A
	CMP #LIST,A	;INPUT MUST BE A LIST
	BEQ DO1		;OK
	ERROR+WTAB
DO1:	JSR PC,BLSTI
	PUSH PCHR
	MOV #BLST,PCHR
	CLR NBKTS
	JSR PC,PNODAB	;CONVERT THING ON S TO STRING ON S
	POP PCHR
	JSR PC,BLSTF
	BEQ DO3		;EMPTY STRING
	MOV TOPS,@S
DO2:	JSR PC,READ	;CONVERT STRING ON S TO TOKEN LIST ON S
	BEQ DO4		;NO TOKENS
	JSR PC,SAVEVL
	PUSH #0		;NO. OF ARGS
	JSR PC,SAVPPS	;SAVE PDL POINTERS
	BIS #DORF,FLAGS	;SET FOR DO FRAME
	BIS #1,CPDLP	;RESULTS IN PROC PUSH
	JSR PC,EVLINE	;EVALUATE THE LINE
	BEQ DO5		;NO OUTPUT
	MOV #-1,C
	MOV #RET,PSTOPR	;RETURN ADDRESS (NO OUTPUT)
	BR DO6
DO5:	POPS C		;GET THE "OUTPUT"
	MOV #SRET,PSTOPR	;RETURN ADDRESS (OUTPUT)
DO6:	JSR PC,RESPPS	;RESTORE PDLS
	POP B
	JSR PC,RESEVL	;RESTORE PROC VALUES
	BIC #EVIFS+DORF,FLAGS
	BIC #-EVIFS-1,B	  ;EVIFS=PTLPF+CRF+RTF
	BIS B,FLAGS
	POPS B
	CMP #-1,C	;WAS THERE OUTPUT?
	BEQ DO7		;NO
	PUSHS C		;PUT "OUTPUT" BACK ON S
DO7:	CLR D
	MOV CTP,C
	JMP	PSTOP6
DO3:	POPS A
DO8:	SEZ
DO4:	RTS PC
.ENDC

.IFNZ BEEF
DO:	JSR PC,CKSTG		;MAKE SURE THERE IS ROOM
	MOV @S,A		;THE LIST TO RUN
	MOV A,B			;COPY IT
	BIC #7777,A		;GET TYPE
	CMP #LIST,A		;IS IT A LIST
	BEQ DO1			;YES
	ERROR+WTAB		;NO, THIS IS A LOSER THEN
DO1:	JSR PC,BLSTI		;BUILD A LIST OF THE CHARACTERS OF THIS LIST
	PUSH PCHR		;SAVE THE PRINTING ROUTINE
	MOV #BLST,PCHR		;WHEN YOU PRINT A CHARACTER PUT IT INTO THIS LIST
	CLR NBKTS		;NO BRACKETS NOW
	JSR PC,PNODAB		;PRINT OUT THIS LIST
	SPOP PCHR		;RESTORE THE PRINT ROUTINE
	JSR PC,BLSTF		;NOW, FINISH THIS LIST
	BEQ DO4			;WAS THE EMPTYP LIST
	MOV TOPS,@S		;PUT THE LIST WE BUILT ONTO THE STACK
	JSR PC,SAVEVL		;SAVE THE EVAL STATE
	PUSH #0			;NUMBER OF ARGUMENTS
	JSR PC,SAVPPS		;SAVE THE PDL POINTERS,
	MOV S,A			;POINT TO THE TOP OF THE STACK
	MOV (A),-(A)		;COPY THE TOKEN LIST TO CREATE A CELL FOR THE OLD COMMAND
				;BUFFER
	MOV ILINEL,2(A)		;STACK POINTER TO THE ILINE
	MOV A,S			;FIX STACK POINTER 
				;HERE, WHEN A RESPPS IS DONE, THE TOP OF THE STACK IS
				;THE OLD ILINEL
	BIC #ERRF,FLAGS		;THIS CANNOT BE A BOTTOM ERROR FRAME
	BIS #DORF,FLAGS		;THIS IS A DO FRAME!!!!!!
	BIS #1,CPDLP		;I AM A PROCEDURE, PUSH ME....
	JSR PC,MREAD1		;TURN CHARACTER STRING INTO THE BUFFER
	BEQ 1$			;NO TOKENS
	JSR PC,EVLINE		;EVALUATE THE LINE
	BNE 1$			;DIDN'T OUTPUT
	MOV #SRET,PSTOPR	;OUTPUT!!!!
	MOV #SRET,DOFRET	;OUTPUT!!!!
	BR 2$			;RETURN....
1$:	MOV #RET,PSTOPR		;JUST RETURN, NO OUTPUT
	MOV #RET,DOFRET		;DITTOR
2$:	JMP POPFRM		;POP THE DO FRAME AND RETURN
DO4:	POPS A			;POP OFF CHARACTER STRING
DO3:	SEZ			;NO OUTPUT
	RTS PC
.ENDC

SAVEVL:	POP F	;SAVE THE WORLD
	SPUSH CPP		;PUSH THE WORLD!
.IFZ BEEF
	SPUSH CPSN
	SPUSH CLP
	SPUSH CTN
	SPUSH CLGN
.IFF
	SPUSH CPBND
	SPUSH NEXLIN
	SPUSH CLCNT
.ENDC
	PUSH CPLN
	SPUSH CTP
	SPUSH FLAGS
	SPUSH CO
.IIF Z BEEF,	SPUSH CO+2
.IIF NZ BEEF,	SPUSH CT
	SPUSH IFLEV
	SPUSH ERPROC
	JMP (F)

RESEVL:	POP F
	SPOP ERPROC	;PROC, RESTORE REST OF WORLD
	SPOP IFLEV
.IIF NZ BEEF,	SPOP CT
.IIF Z BEEF,	SPOP CO+2
	SPOP CO
	SPOP B
	SPOP CTP
	POP CPLN
.IFZ BEEF
	SPOP CLGN
	SPOP CTN
	SPOP CLP
	SPOP CPSN
.IFF
	SPOP CLCNT
	SPOP NEXLIN
	SPOP CPBND
.ENDC
	SPOP CPP
	JMP (F)
	.STITL "TO" ETC.
GTLN:	JSR PC,GTUOEB	;GET LINE # FROM NEXT TOKEN INTO B
	BEQ GTLN2	;CANT FIND IT
	MOV #SNUM,A
	JSR PC,CONVER	;MAKE NEXT TOKEN INTO AN SNUM
GTLN2:	RTS PC
.IFZ BEEF
GTLP:	PUSH CPP	;GET LINE PTR OF LINE (B) FOR PROC (TOPRNM)
	MOV TOPRNM,CPP	;LEAVE PTR IN C
	JSR PC,GTLINE
	BEQ GTLP1
	POP CPP
	CLZ
GTLP2:	RTS PC

GTLP1:	POP CPP
	ERROR+LDE
.IFF
GTLP:	PUSH CPBND		;SAVE POINTER TO EXECUTING PROCEDURE
	MOV PARRYS,CPBND	;GET POINTER TO EDITING PROCEDURE
	JSR PC,GTLINE		;GET POINTER TO LINE IN B
	BEQ GTLP2		;LOSES
	POP CPBND		;GET BACK CPBND
	MOV B,F			;RETURN POINTER
	RTS PC
GTLP2:	SPOP CPBND		;ERROR OUT
	ERROR+LDE		;LINE NOT HERE
.ENDC

EDTITL:	TST TOPRNM
	BNE 1$
	ERROR+OIP	;ONLY IN PROCEDURE
1$:	JSR PC,EDITA	;SET UP FOR EDIT BUFFER INSERT
	PUSH PCHR
	MOV #ETYO,PCHR
	MOV TOPRNM,B
	JSR PC,SHTITL	;"PRINT" TITLE LINE INTO EDIT BUFFER
	BNE 2$
	.BUG.
2$:	BIS #EDTIF2,FLAGS
	BR EDLIN1
EDLINE:	TST TOPRNM
	BNE 1$
	ERROR+OIP
1$:	JSR PC,GTLN	;GET LINE # IN B
	BNE 2$
	ERROR+ELW	;EDIT LINE WHAT
2$:	JSR PC,GTLP	;GET PTR TO THAT LINE
	JSR PC,EDITA
	PUSH PCHR
	MOV #ETYO,PCHR
.IFZ BEEF
	JSR PC,.LOADC	;GET PTR TO LINE (IN LLP NODE)
	PUSHS B	;FOR INPUT TO PRLN
.IFTF
	JSR PC,PRLN	;"PRINT" THE LINE TO THE EDIT BUFFER
.IFT
	POPS B
.ENDC
EDLIN1:	POP PCHR
	SEZ
	RTS PC

.IFZ BEEF
EDIT2:	CMP #TYI,GCHR
	BNE EDIT3
	CMP #INFIX,A
	BHIS 1$
	ERROR+WTAB
1$:	ERROR+UBL

EDIT3:	JSR PC,CVSFLS
	MOV TOPS,B
	JSR PC,GRBAD
	MOV C,TEMP
	BIS #LIST,C
	MOV C,TOPS2
	JMP TO86
EDIT1:
	.IFNZ ENG
	CMP #$TITLE,B
	BNE EDIT1A
	JMP EDTITL
EDIT1A:	CMP #$LINE,B
	BNE 1$
	JMP EDLINE
1$:
.ENDC
.IFNZ FR
	CMP #$TITRE,B
	BEQ EDTITL
	CMP #$LIGNE,B
	BEQ EDLINE
.ENDC
		;NOT A VALID EDITING COMMAND
	TST B	;IS THIS A CR?
	BEQ JEDIT
ERRO:	ERROR+NEC
JEDIT:	BIS #EDITF,FLAGS
	MOV LASTPR,B
	BNE TO0
	ERROR+UELX
.ENDC

EDITA:	TST -(P)	;DUMMY ARG
	SAVE <#.TIEDM!.TERST,#.TTBIS_8.+2>
	$INVOK		;RESET EDIT BUFFER AND ENTER EDIT MODE
	RTS PC

ETYO:	TST BRAKE
	BEQ 1$
	RTS PC
1$:	SPUSH D
	SPUSH TYOCP
	BIS #.TTEDM,(P)	;SAY IT SHOULD BE WRITTEN INTO THE EDIT BUFFER
	$BYTO
	RTS PC


.IFZ BEEF
EDIT:	BIC #EDTIF,FLAGS
	JSR PC,GTUOEB	;LOOK AT NEXT TOKEN
	BNE EDIT1	;NOT A UOE
	BIS #EDITF,FLAGS
	BR TO0
TO:	BIC #EDITF,FLAGS
	JSR PC,GTUOEB	;GET UOE PTR FROM NEXT TOKEN
	BEQ TOJ
	JMP EDIT2
TOJ:	BIC #170000,B
	BIS #UFUN,B
	MOV B,TOPS2	;SO THIS "TOTALLY WORTHLESS ATOM WONT BE G.C.
	JSR PC,TITLDF
TO0:	TST TOPRNM
	BEQ TO8
	MOV FNLLP,TMPBLK
	BIT #EDTIF,FLAGS
	BNE TO8
	ERROR+CTIT	;CANT "TO" IN TO
TO8:	MOV B,TEMP
	CLR TOPS
	JSR PC,.BINDF
	BEQ TO6
	BIT #EDTIF,FLAGS
	BEQ TO84
	CMP TOPRNM,TEMP
	BNE TO85
	MOV TOPS1,A
	BIS #LIST,A
	JSR PC,.STP2
	MOV TOPS1,B
	BR TITED1
TO84:	MOV A,FNLLP
	BIT #EDITF,FLAGS	;IS IT "EDIT"?
	BNE TO5	;YES
	CMP #TYI,GCHR	;IS INPUT FROM TTY?
	BNE TO86
TO85:	ERROR+PAE	;YES - PROCEDURE ALREADY EXISTS
TO86:	BIS #SPDF,FLAGS	;NO - SET SKIP PROC DEF. FLAG
	MOV TEMP,TOPRNM
TO81:	BIT #CRF,FLAGS
	BNE TO82
	JSR PC,GNT	;READ TO END OF LINE
	BR TO81
TO82:	CLR TOPS
	CLR TOPS1
	CLR TOPS2
	RTS PC
TO7:	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
	JSR PC,.LOAD
	MOV A,FNLLP
TO5:	MOV TEMP,TOPRNM
	MOV #'>,PRMTCH
	BR TO82
TO6:	BIT #EDTIF,FLAGS	;EDITING TITLE?
	BNE TITED
	BIT #EDITF,FLAGS	;IS IT "EDIT"
	BEQ TO7	;NO
	ERROR+PNH	;YES, PROCEDUTE NOT HERE
TITED:	;EDIT THAT TITLE...
	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
TITED1:	JSR PC,.LOAD
	MOV A,FNLLP
;MAKE NEW PROC POINT TO OLD LINES
	MOV A,C
	MOV TMPBLK,B
	JSR PC,.LOAD
	JSR PC,.STP1
	CMP TEMP,TOPRNM
	BEQ TITED2
	MOV TOPRNM,B
	MOV #FBIND,A
	JSR PC,.UNBND
	MOV TEMP,TOPRNM
TITED2:	BR TO82
.ENDC

.IFNZ BEEF
;HERE WE LOOK FOR THE TOKEN $LINE OR $TITLE, IF NOT THAT WE ERROR OUT,
EDITSY:
.IFNZ ENG
	CMP #$TITLE,B		;IS IT EDIT TITLE?
	BEQ EDTITL		;YES
	CMP #$LINE,B		;IS IT EDIT LINE?
	BEQ EDLINE		;YES
.ENDC
.IFNZ FR
	CMP #$TITRE,B		;AS ABOVE BUT IN FRENCH
	BEQ EDTITL
	CMP #$LIGNE,B
	BEQ EDLINE
.ENDC
	ERROR+NEC		;CAN'T BE EDITED

EDIT:	BIC #EDTIF,FLAGS	;SO THAT WE ARE NO LONGER EDITING TITLES
	JSR PC,GTUOEB		;GET POINTER TO THE USER OBLIST ELEMENT
	BNE EDITSY		;WASN'T A UOE
	BIS #EDITF,FLAGS	;SAY WE ARE IN EDIT PROCEDURE MODE
	TST TOPRNM		;EDITING ANYTHING CURRENTLY?
	BEQ EDIT2		;NO
EDIT1:	ERROR+CTIT		;CANT TO IN TO
EDIT2:	MOV B,TEMP		;STORE THE POINTER TO THE ATOM
	CLR TOPS		;MAKE SURE WE DONT CREATE A NEW BINDING
	JSR PC,.BINDF		;SEE IF IT HAS A PROCEDURE BINDING
	BNE EDIT4		;IT DOES
EDIT3:	ERROR+PNH		;PROCEDURE NOT HERE
EDIT4:				;HERE FETCH ALL THE INFO THAT IS SET UP BY STARTING
				;EDITING
	MOV (B),PARRYS		;SET UP FOR THE EDIT,
				;POINTER TO BINDING NODE FOR THIS ARRAY
	MOV SIZE(B),PARRYF	;POINT TO THE END OF THE ARRAY
	SUB 5*2(B),PARRYF	;SUBTRACT POINTER TO THE END OF USED STORAGE AND DONE
EDIT5:	MOV TEMP,TOPRNM		;STORE THE PROCEDURE NAME AWAY
	MOV #'>,PRMTCH		;CHANGE PROMPTING CHARACTER TO >
	CLR TOPS		;CLEAR ALL TEMPORARYS
	CLR TOPS1
	CLR TOPS2
	RTS PC


TO:	BIC #EDITF,FLAGS	;CLEAR EDIT FLAG (SHOULDN'T BE NEEDED)
	JSR PC,GTUOEB		;GET THE UOE POINTER
	BEQ 1$			;FINE
	CMP #INFIX,A		;IS IT A SYSTEM FUNCTION
	BHIS 2$			;YES
	ERROR+WTAB		;CANT EDIT LISTS AND SUCH
2$:	ERROR+UBL		;USED BY LOGO
1$:	BIC #170000,B		;GET ONLY THE POINTER PART
	BIS #UFUN,B		;MAKE SURE IT IS A UFUN
	MOV B,TOPS2		;STORE IT AWAY
	MOV B,TEMP		;FOR ERROR MESSAGE
	CLR TOPS		;SO THAT WE DONT CAUSE A BINDING YET.
	JSR PC,.BINDF		;GET THE PROCEDURE BINDING FOR PROC IN B
	BEQ TO2			;DOESN'T EXIST
	BIT #EDTIF,FLAGS	;ARE WE EDITING THE TITLE?
	BNE TITLED		;YES
TO1:	ERROR+PAE		;PROC (TEMP) ALREADY EXISTS
TO2:	TST TOPRNM		;ARE WE IN EDIT MODE CURRENTLY?
	BNE TITLED		;YES, WELL BETTER BE EDITING THE TITLE
	JSR PC,TITLDF		;SET UP PROCEDURE ARRAY... RETURN POINTER IN B
	MOV #FBIND,A		;SET UP THE FUNCTION BINDING TO POINT TO THE NEWLY
				;CREATED ARRAY, C WAS SET UP BY .BINDF, AND IS USED
				;BY GRBAD1
TOBND:	MOV TEMP,3*2(B)		;PUT THE POINTER TO THE PNAME OF THIS ATOM INTO
				;THE FIRST DIMENSION
	JSR PC,GRBAD1		;NEW FUNCTION BINDING FOR THIS ATOM
	ASL C
	ASL C			;MAKE POINTER TO THE NODE
	ADD #NODESP+2,C		;MAKE POINTER TO THE BINDING NODE
	MOV C,(B)		;MAKE THE ARRAY POINT TO THE BINDING NODE
	MOV C,PARRYS		;SET UP POINTER TO THE START OF THE ARRAY
	BR EDIT5		;SET UP PROMPT AND CLEAN IT UP
	
;CALLED WITH C POINTING TO THE END OF THE BINDING LIST FOR THE NEW NAME
;OLD NAME IS IN TOPRNM
;TEMP POINTS TO THE NEW NAME
TITLED:	BIT #EDTIF,FLAGS	;EDITING THE TITLE?
	BEQ EDIT1		;NO, CANT TO IN TO
	SPUSH C			;SAVE POINTER TO THE BINDING NODE
	JSR PC,CHKTIT		;CHECK THE TITLE, D <= THE NUMBER OF ARGS
				;ARGUMENTS PUSHED ON THE S PDL
	MOV @PARRYS,E		;THE START OF THE OLD ARRAY
	ADD #HEADER,E		;POINT TO THE START OF THE PROCEDURE STRUCTURE
	MOV D,2(E)		;PUT IN NEW NUMBER OF ARGUMENTS
	SPUSH D			;SAVE ARGUMENTS
	ASL D			;NUMBER OF BYTES NEEDED FOR THE ARUMENTS
	ADD #2,D		;BECAUSE WE NEED A WORD SAYING HOW MANY ARGS,
	ADD (E)+,E		;POINT TO THE PROCEDURE TITLE LINE
	SPUSH D			;SAVE THE LENGTH OF THE NEW LINE
	SUB (E),D		;THE LENGTH DIFFERENCE IN BYTES
	JSR PC,MAKSPA		;BYTE DIFFERENCE IN D, POINTER TO PLACE IN E
				;WILL EITHER CONTRACT OR EXPAND ARRAY AS NEEDED
	SPOP (E)+		;POP THE LINE LENGTH
	MOV (P),(E)+		;AND THE NUMBER OF ARGUMENTS
	SPOP D			;GET THE NUMBER OF ARGUMENTS
	BEQ 1$			;NONE, FORGET IT
	MOV D,A			;COPY IT
	ASL A			;INTO BYTES
	ADD S,A			;MAKE IT A RELATIVE POINTER TO THE S PDL
	SPUSH A			;WHERE THE PDL POINTER WILL BE WHEN WE ARE DONE
2$:	MOV -(A),(E)+		;PUT IN THE ARGUMENTS
	SOB D,2$		;TAKE ALL THE ARGUMENTS OFF THE S PDL
	SPOP S			;NOW RESTORE THE S-PDL
1$:	CMP TEMP,TOPRNM		;ARE THE NAMES THE SAME?
	BNE NEWTIT		;NO, WE MUST UNBIND THE OLD NAME, AND CREATE NEW BINDING
	SPOP C			;JUST FLUSH THE NEW BINDING NODE POINTER
	BR EDIT5		;AND CLEAN UP
NEWTIT:	MOV #FBIND,A		;REMOVE THE FUNCTION BINDING
	MOV TOPRNM,B		;UNBIND THE OLD ONE
	SPUSH @PARRYS		;PUSH THE PROCEDURE ADDRESS
	JSR PC,.UNBND		;DO THE DEED
	SPOP B			;GET IT INTO B
	SPOP C			;GET BACK POINTER TO WHERE THE NEW PROC BINDING GOES
	BR TOBND		;BIND IT LIKE YOU WERE DOING A TO
.ENDC

GTUOEB: JSR PC,GNT	;GET UOE PTR FROM NEXT TOKEN IN B
	BIT #CRF,FLAGS
	BEQ 1$
	ERROR+UEL	;UNEXPECTED END OF LINE
1$:	BIC #7777,A	;SKIP UNLESS NEXT TOKEN NOT UOE.  USES A
	CMP #UFUN,A
	BEQ GTU1
	CMP #ATOM,A
	BEQ GTU1
	CMP #LSTR,A
	BNE GTU2
	MOV B,TOPS
	JSR PC,.INTRN
GTU1:	CLR TOPS
GTU2:	RTS PC


.IFZ BEEF

GO:	MOV CPLN,JPLN	;SAVE CURRENT LINE # AS LINE JUMPED-FROM
	JSR PC,G1NARG
	MOV B,CPLN
GOUNTL:	CLR CT+2
	CLR CLP
	CLR CT
	BIC #RTF,FLAGS
	SEZ
	RTS PC

RETURN:	JSR PC,G1NARG
	MOV B,TMPBLK
	MOV #RETU1,PSTOPR
	MOV #RETU3,ERFRET	;CATCH ERROR SET FRAME
	MOV #PSTP15,DOFRET
RETU1:	TST FUNLEV
	BEQ PROCE1
	JMP PSTP15
RETU3:	MOV #RETU2,PSTOPR
	CLR CTN			;SET UP TO RESTART AT BEGINNING OF LINE
	MOV #-1,CPSN
	BR PROCE2
RETU2:	MOV TMPBLK,CPLN
	CLR CTN	;SET UP TO RESTART AT BEGINNING OF LINE
	CLR CTP
	CLR CLP
	JMP MLOOP

CONTINUE:
;	JSR	PC,BRKMON	;RESTART MUSIC BOX IF APPROPRIATE
	MOV #MLOOP,PSTOPR
	MOV #PSTP15,DOFRET
PROCE2:	TST FUNLEV
	BEQ PROCE1
	BIT #DORF,FLAGS
	BEQ PROCE3
PROCE4:	JSR PC,RESPPS
	POP B
	JSR PC,RESEVL
	BR PROCE2
PROCE3:	MOV CPDLP,A
	BIC #1,A
	JSR PC,PPTA
	MOV CSPDLP,A
	JSR PC,PSTA
	BIC #BRKF,FLAGS
	JMP PSTP43	;TRY RESTARTING
PROCE1:	JMP ERTL3
.ENDC

.IFNZ BEEF
CONTINUE:
	MOV #POPVAR,DOFRET	;POP OFF DO FRAMES
	MOV #CNTIN1,PSTOPR	;AND CHECK FOR ERROR FRAMES
CNTIN1:	TST FUNLEV		;IN A PROCEDURE?
	BEQ CNTIN3		;NOT ANY MORE
	BIT #ERRF!BRKF,FLAGS   	;IS THIS THE BOTTOM LEVEL ERROR PROCEDURE?
	BNE CNTIN2		;YES
	JMP POPVAR		;POP A FRAME...
CNTIN2:	MOV #CNTIN4,PSTOPR	;POP OFF THE ERROR FRAME
	JMP POPVAR		;POP IT
CNTIN4:	MOV #CNTIN5,DOFRET	;POP OFF ALL THE DO FRAMES
CNTIN5:	BIT #DORF,FLAGS		;DO FRAME?
	BEQ CNTIN6		;NOPE
	JMP POPVAR		;POP IT OFF
CNTIN6:	JMP MLOOP		;RESTART A MLOOP (I.E. THE NEXT LINE
				;IF WE WANT TO ALLOW PROCEDES TO WIN TOTALLY, WE SHOULD
				;MAKE SURE ALL ERROR+BRK GET CONTINUED CORRECTLY, AND
				;HERE WE SHOULD CALL PSTOP. THAT IS ALL ERROR+BRKS MUST
				;BE FOLLOWED BY A BRANCH TO A GOOD PLACE TO CONTINUE FROM
				;JUST STOP THE ERROR FRAME, AND RETURN
CNTIN3:	JMP TOPLEVEL		;JUST RETURN TO TOPLEVEL


RETURN:	JSR PC,G1NARG		;GET THE LINE TO RETURN TO
	MOV B,TMPBLK		;SAVE IT FOR A BIT
	MOV #RETUR1,PSTOPR	;AND CHECK FOR ERROR FRAMES
	MOV #POPVAR,DOFRET	;POP OFF DO FRAMES
RETUR1:	TST FUNLEV		;IN A PROCEDURE?
	BEQ CNTIN3		;NOPE
	BIT #ERRF!BRKF,FLAGS	;IS THIS THE BOTTOM LEVEL ERROR PROCEDURES
	BNE RETUR2		;YES, DO A JUMP TYPE THING
RETUR3:	JMP POPVAR		;POP A FRAME
RETUR2:	MOV #RETUR4,PSTOPR	;AND POP THE ERROR PUSH, AND GET BACK TO PROCEDURE
	BR RETUR3
RETUR4:	JSR PC,GOUNTL		;EXECUTE A GO
	
GO:	MOV CPLN,JPLN		;SAVE THE JUMPED FROM LINE
	JSR PC,G1NARG		;GET THE LINE TO JUMP TO
	MOV B,TMPBLK		;SAY IT
GOUNTL:	MOV #GOUNTL,DOFRET		;COME HERE AGAIN IF IT IS A DO
	BIT #DORF,FLAGS		;IS IT A DO FRAME?
	BNE RETUR3		;POP A DO FRAME
GO2:	CLR CLCNT		;MAKE IT LOOK LIKE WE HAVE RUN OUT OF TOKENS
	BIS #1,NEXLIN		;AND THE NEXT LINE IS INACCURATE
	BIC #RTF,FLAGS		;DONT REPEAT TOKENS
	MOV TMPBLK,CPLN		;PUT IN THE NEW LINE NUMBER
	JMP MLOOP		;JUST GO TO THE NEXT LINE
.ENDC
.IFZ BEEF
TITLDF:		;INPUT-CURRENT TOKEN LIST VIA GNT
		;OUTPUT-TOPS1  - POINTS TO FIRST NODE OF LLP
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV CT,TEMP
	CLR D
TO3:	JSR PC,GNT
	BIT #CRF,FLAGS
	BNE TO4		;DONE
	BIC #7777,A
	INC D
	CMP #UVAR,A
	BEQ TO3
	ERROR+WIT
TO4:	CMP #MAXARG,D
	BGE TO9
	ERROR+TMAP
	CLR D
	CLR TEMP
TO9:	MOV #LIST,A
	MOV A,B
	JSR PC,GRBAD	;ZEROTH NODE IN LLP - PTS TO SWAP INFO
	MOV C,TOPS1	;SAVE - PTR TO LLP
	MOV #SNUM,A
	MOV D,B
	JSR PC,GRBAD2	; - # ARGS NODE
	CLR B
	JSR PC,GRBAD1	; - CPSN NODE (START CPSN AT 0)
	MOV TOPS1,C
	MOV #LIST,A
	MOV A,B
	JSR PC,GRBAD1	;FIRST NODE OF LLP - POINTS TO ARG LIST
	MOV TEMP,A
	BIC #170000,A
	BIS #SNUM,A
	MOV D,B	;# ARGS SAVED ABOVE
	JSR PC,GRBAD2	;FIRST NODE OF LINE 0 (ARG LINE)
	JMP RETD
.ENDC

.IFNZ BEEF
TITLDF:	PUSH C
	JSR PC,CHKTIT	;PUSH ARGUMENTS ON THE S-PDL, AND RETURN NUMBER IN D
	MOV D,B		;NUMBER OF ARGUMENTS
	ADD #5,B	;NUMBER OF OVERHEAD WORDS USED
	ASL B		;NUMBER OF BYTES
	ADD #HEADER+PRSIZE,B	;NUMBER OF BYTES IN ARRAY OVERHEAD, AND THE SIZE INIT
	JSR PC,..ALLOC	;ALLOCATE AN ARRAY OF THAT SIZE
	BNE 1$		;OKAY
	ERROR+NSL	;NO STORAGE LEFT
1$:	MOV A,C		;COPY IT
	MOV A,PARRYS	;STORE THE START OF THE ARRAY (CLOBBERED LATER TO POINT TO THE
			;BINDING NODE FOR THIS PROCDURE
	MOV B,PARRYF	;NUMBER OF BYTES TO BE USED+HEADER LENGTH
	CMP (C)+,(C)+	;SKIP BACK POINTER TO ATOM, AND LENGTH
	MOV #PROCAR,(C)+	;PROCEDURE ARRAY
	CLR (C)+	;ONE DIMENSIONAL
	CLR (C)+
	CLR (C)+	;THIS WILL BE THE TOTAL LENGTH OF THE PROCEDURE EVENTUALLY
	ADD #10,C	;SKIP INFO FOR WINDOWS
	MOV #4,(C)+	;ONE WORD FOR LENGTH, # OF ARGS, AND CPSN
	MOV D,(C)+	;THE NUMBER OF ARGUMENTS
	CLR (C)+	;THE SWAP NUMBER
	MOV D,B		;NUMBER OF ARGS
	INC B		;ONE FOR THE NUMBER
	ASL B		;GET LENGTH IN BYTES
	MOV B,(C)+
	MOV D,(C)+	;NUMBER OF ARGS
	TST D		;ANY ARGUMENTS?
	BEQ TITDON	;NO, WE ARE FINISHED
	MOV D,B		;NUMBER OF ARGUMENTS WE PUSHED ON S
	ASL B		;INTO A BYTE NUMBER
	ADD S,B		;GET NEW S POINTER
	SPUSH B		;SAVE IT FOR LATER
ARGLOP:	MOV -(B),(C)+	;PUT IN POINTER TO THE ARUMENT
	SOB D,ARGLOP	;FOR ALL OF THEM
	SPOP S		;AND NOW RESTORE S TO WHAT IT WAS
TITDON:	MOV PARRYS,B	;GET POINTER TO START OF THE ARRAY
	SUB B,C		;GET NUMBER OF BYTES USED
	MOV C,5*2(B)	;PUT IN POINTER TO THE FIRST FREE LOCATION INTO 1 DIMENSION
	SUB C,PARRYF	;AND SET UP NUMBER OF BYTES LEFT
	SPOP C
	RTS PC		;DONE

CHKTIT:	CLR D		;COUNTER FOR NUMBER OF TOKENS
	CMP SPUSHL,S	;ENOUGH ROOM ON THE S PDL?
	BLOS CHKTI0	;YES
	JSR PC,SPSWPO	;SWAP OUT SOME OF S
CHKTI0:	JSR PC,GNT
	BIT #CRF,FLAGS
	BNE CHKTI1	;DONE
	BIC #7777,A
	INC D
	CMP #UVAR,A
	BNE CHKTER
	CMP D,#MAXARG	;TO MANY ARGS?
	BGE CHKTI0	;YES, DONT PUSH ANY MORE
	PUSHS B		;PUSH ON THE TOKEN
	BR CHKTI0	;AND GO FOR THE NEXT
CHKTER:	ERROR+WIT	;WRONG TYPE OF INPUT TO "TO"
CHKTI1:	CMP #MAXARG,D
	BGE CHKTI2
	ERROR+TMAP	;TOO MANY ARGS (PROCEDURE)
	ADD #<MAXARG-1>*2,S	;FIX THE S PDL
	CLR D	;THIS ERROR RETURNS HERE!!
	CLR C
CHKTI2:	RTS PC
.ENDC
END:	MOV TOPRNM,B
	BNE 1$
	ERROR+OIP	;ONLY IN PROCEDURE DEFINITION
1$:	MOV B,LASTPR	;SAVE FOR "PO"
	TST REDFLG
	BEQ END4
	BIT #SPDF,FLAGS
	BEQ END3
END4:	TST FUNLEV	;DON'T PRINT "FOO DEFINED" IF NOT AT TOP LEVEL
	BEQ END5
	BIT #BRKF,FLAGS
	BEQ END3
END5:	JSR PC,PPNAME
	BIT #SPDF,FLAGS
	BNE END1
.IFZ ENG&FR
.IIF NZ ENG,	PRTXTC ^\ DEFINED\
.IIF NZ FR,	PRTXTC ^/ EST DEFINI/
.IFF
	BIT #FRFLG,LANG
	BEQ END6
	PRTXTC ^/ EST DEFINI/
	BR END7
END6:	PRTXTC ^/ DEFINED/
END7:
.ENDC
END3:	CLR TOPRNM
	BIC #SPDF,FLAGS
	MOV #'?,PRMTCH
END2:	SEZ
	RTS PC
END1:
.IFZ ENG&FR
.IIF NZ ENG,	PRTXTC ^/ SKIPPED/
.IIF NZ FR,	PRTXTC ^/ A ETE PASSE/
.IFF
	BIT #FRFLG,LANG
	BEQ END8
	PRTXTC ^/ A ETE PASSE/
	BR END9
END8:	PRTXTC ^/ SKIPPED/
END9:
.ENDC
	BR END3
	.STITL UTILITY - COUNT LIST ELEMENTS
CLE:		;COUNT LIST ELEMENTS
		  ;IN - LIST PTR IN C
		 ;OUT - # OF ELEMENTS IN B
	PUSH A
	SPUSH C
	CLR B
	MOV C,A
CLE1:	BIT #7777,A
	BEQ CLE2
	MOV A,C
	JSR PC,.LDP1
	INC B
	BR CLE1
CLE2:	POP C
	SPOP A
	RTS PC
	.STITL UTILITY - ADD A LINE
.IFZ BEEF
ADLN:
		;ON S IS A "NEW LINE" INSERT IN PROPER PLACE
		;IN LLP POINTED TO BY FNLLP.
		;IF "NEW LINE" # IS NEG, DELETE THE LINE
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	MOV @S,C
	JSR PC,.LOADC
	MOV B,F	;SAVE LINE #
	BLT ADLN6	;IF < 0, THIS IS A DELETE
	BIC #TF4,TFLAGS
ADLN7:	MOV FNLLP	,C
	JSR PC,.LOADC	;SKIP OVER ARG LINE
	MOV C,D
	MOV A,C
	;LOOK DOWN LLP FOR LINE #(@P)
ADLN1:	MOV D,E	;SAVE PTR TO PREDECESSOR IN E
	MOV C,D	;SAVE PTR TO CURRENT IN D
	MOV #LIST,A
	BIT #7777,C
	BEQ ADLN2	;AT END, ADD NEW NODE
	JSR PC,.LOADC
	MOV A,C	;SAVE PTR TO SUCCESSOR IN C
	JSR PC,.LOAD
	CMP B,F
	BLT ADLN1	;NOT THERE YET
	BEQ ADLN3	;FOUND LINE
	MOV D,A	;OTHERWISE, INSERT NEW LINE
ADLN2:	BIT #TF4,TFLAGS	;PASSED IT - IF DELETE
	BNE ADLN5	;ALL DONE
	MOV @S,B	;ADD NEW NODE TO END
	MOV E,C
	JSR PC,GRBAD1
ADLN5:	JMP RETF
ADLN3:	BIT #TF4,TFLAGS	;FOUND LINE NO.  DELETE?
	BEQ ADLN31	;NO
	MOV C,A	;YES
	MOV E,C
	JSR PC,.STP1
	BR ADLN5
		;NOT DELETE, REPLACE THEN CHECK GEN. NO.
ADLN31:	MOV A,E	;SAVE A, POINT TO FIRST TOKEN IN OLD LINE
	MOV @S,A
	MOV D,C	;D POINTS TO RELEVENT LLP NODE
	JSR PC,.STP2	;STORE LINK TO NEW LINE
	TST FUNLEV	;IF AT FUNLEV 0, DON'T BOTHER WITH GEN #
	BEQ ADLN5
	MOV E,C	;E POINTS TO OLD LINE
	JSR PC,.LOADC	;GET NEXT NODE IN OLD LINE(1ST TOKEN OR GEN )
	BIC #7777,A
	CMP #SNUM,A
	BEQ ADLN4
	CLR B
ADLN4:	INC B	;ALREADY HAS GEN NO.
	MOV @S,C
	JSR PC,.LDP1
	BIC #170000,A
	BIS #SNUM,A
	JSR PC,GRBAD1
	BR ADLN5
ADLN6:	NEG F
	BIS #TF4,TFLAGS
	BR ADLN7
	.STITL UTILITY - GET A LINE, GET ARGS
GTLINE:		;GET LLP POINTER OF LINE WHOSE NO. IS IN B
			;FOR PROCEDURE PONTED TO BY "CPP"
			;OUTPUT - LLP PTR WILL BE IN C AND WILL SKIP
	BIS #TF1,TFLAGS
	BR .+10
GNLINE:		;SAME EXCEPT LOOKING FOR LINE WHOSE # IS > # IN B
		;NEVER USED
	BIC #TF1,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	MOV B,D
	MOV CPP,B
	JSR PC,.BINDF	;LOOK FOR PROC BINDING
	BNE 1$
	.BUG.	;WHAT NO PROC BINDING??!!
1$:	JSR PC,.LOADA
	MOV A,E
GNL1:	BIT #7777,E
	BEQ GNL4	;NONE LEFT
	MOV E,C
	JSR PC,.LOADC	;GET NEXT NODE IN LLP
	MOV A,E
	JSR PC,.LOADB	;GET FIRST NODE OF THAT LINE
	CMP B,D
	BLT GNL1	;NOT THERE YET
	BEQ GNL2	;FOUND IT
	BIT #TF1,TFLAGS	;WENT PAST, WERE WE LOOKING FOR IT?
	BEQ GNL3	;NO, OK
GNL4:	JMP RETE	;YES "NO SUCH LINE NO."
GNL2:	BIT #TF1,TFLAGS	;FOUND IT, LOOKING FOR IT?
	BEQ GNL1	;NO, GET NEXT
GNL3:	MOV C,4(P)	;OUTPUT (C) INTO C
	JMP SRETE
GNASN:		;GET NO. OF ARGS AND CPSN OF USER PROC
		;IN: PROC PTR IN B
		;OUTPUT: CPSN IN A # IN B
		;DONT SKIP IF NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	BNE 1$
	JMP RETC
1$:	JSR PC,.LOADB
	MOV B,2(P)	;# IN OLD B
	JSR PC,.LOADA
	MOV B,4(P)	;CPSN IN OLD A
	JMP SRETC
.ENDC

.IFNZ BEEF
;TAKES POINTER TO ATOM IN B, AND OUTPUTS NUMBER OF ARGUMENTS IN B
;SET Z IF PROCEDURE IS NOT FOUND
GNASN:	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS	;GET THE BINDING INTO B
	BNE 1$		;FOUND IT
	JMP RETC
1$:	ADD #HEADER,B	;POINT TO THE START OF THE PROCEDURE
	MOV 2(B),2(P)	;PUT THE # OF ARGS INTO B ON THE STACK
	JMP SRETC

GTLINE:			;LINE NUMBER IN B, OUTPUT POINTER TO LINE IN B
			;PROCEDURE POINTED TO BY CPADR
			;SET Z IF NOT FOUND
	SPUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV @CPBND,C	;GET POINTER TO THE START OF THE ARRAY
	MOV 5*2(C),D	;POINTER TO THE END OF THE ARRAY
	ADD C,D		;MAKE IT AN ABSOLUTE POINTER
	ADD #HEADER,C	;POINT TO THE START OF THE DATA
	ADD (C)+,C	;POINT PAST THE HEADER LINE
GTLIN1:	ADD (C)+,C	;GET TO THE NEXT LINE
	CMP C,D		;ARE WE AT THE END OF THE PROC?
	BEQ GTLINF	;YES, WE HAVE FAILED TO FIND IT
	BHI GTLINB	;OOPS WE SHOULDN'T OVERSHOOT
	CMP B,2(C)	;ARE THE LINE NUMBERS THE SAME?
	BGT GTLIN1	;THE ONE WE ARE LOOKING FOR IS FURTHER ON
	BLT GTLINF	;WE PASSED WHERE IT SHOULD BE, FAIL
	MOV C,4(P)	;CLOBBER B ON THE STACK
	JMP SRETD	;AND RETURN
GTLINF:	JMP RETD
GTLINB:	.BUG.
;CALLED WITH THE LINE NUMBER IN B
;IF NEGATIVE DELETE THAT LINE
;IF NOT INSERT LINE POINTED TO BY CTP, CLCNT IS EXPECTED TO BE CORRECT
ADLN:	JSR F,CACSAV	;CAREFULLY SAVE THE AC'S
	CLR A		;A FLAG
	MOV B,F		;THE LINE NUMBER
	BPL FINLIN	;FIND THE LINE AND INSERT IT
	NEG F		;GET THE REAL LINE NUMBER
	INC A		;FLAG FOR JUST DELETING LIEN
FINLIN:	MOV @PARRYS,E	;POINTER TO THE START OF THE ARRAY
	MOV 5*2(E),B	;THE POINTER TO THE FIRST FREE LOCATION
	ADD E,B		;MAKE IT ABSOLUTE
	ADD #HEADER,E	;POINT TO THE BEGINNING OF THE PROCEDURE
	ADD (E)+,E	;POINT TO THE TITLE LINE
LINLOP:	ADD (E)+,E	;POINT TO THE NEXT LINE
	CMP E,B		;ARE WE AT THE END?
	BEQ ADDEND	;YES
	BHI ADDBUG	;CANT BE...
	CMP F,2(E)	;ARE THE LINE NUMBERS THE SAME?
	BGT LINLOP	;NO, IT MUST BE FURTHER ON
	BEQ LINEQ	;INSERT THE LINE (E)
ADDEND:	TST A		;DELETING THE LINE?
	BNE LINDN2	;CANT FIND THE LINE TO DELETE IT
	JSR PC,LINLEN	;GET THE LENGTH OF THE LINE IN BYTES INTO D+4 FOR 
			;LENGTH AND LINE NUMBER
	JSR PC,MAKSPA	;AND MAKE SPACE FOR IT
	SUB #2,D	;SUBTRACT FOR THE LENGTH WORD
	MOV D,(E)+	;SET IN THE LINE LENGTH
	MOV F,(E)+	;THE LINE NUMBER
LINDON:	JSR PC,INSLIN	;AND THE LIST
LINDN2:	JSR F,CACRES
	RTS PC
ADDBUG:	.BUG.

;HERE WE DELETE THE LINE (E), AND INSERT LINE POINTED TO BY A
LINEQ:	TST A		;ANY LIST TO INSERT?
	BNE NOLIST	;NO JUST DELETE THE LINE
	JSR PC,LINLEN	;GET THE LENGTH OF THE LINE IN D
	SUB #2,D	;BECAUSE WE DONT COUNT THE LENGTH WORD NOW
	SPUSH D		;SAVE IT FOR LATER
	SUB (E),D	;GET THE DIFFERENCE BETWEEN THE TWO LINES
	JSR PC,MAKSPA	;MAKE SPACE FOR THE LINE
	SPOP (E)+	;SET IN THE LENGTH
	MOV F,(E)+	;AND LINE NUMBER
	BR LINDON	;DONE WITH THE LINE
NOLIST:	MOV (E),D	;GET THE NUMBER OF DELTA BYTES
	ADD #2,D	;BECAUSE WE ARE DELETING THE LENGTH ALSO
	NEG D		;IT IS GETTING SMALLER
	JSR PC,MAKSPA	;FIX THIS LINE
	BR LINDN2	;JUST RETURN
.ENDC

.IFNZ BEEF
;RETURN NUMBER OF BYTES NEEDED FOR THE LINE IN D
LINLEN:	MOV CLCNT,D	;GET NUMBER OF TOKENS LEFT
	ASL D		;FROM WORDS TO BYTES
	ADD #4,D	;FOR THE LINE NUMBER, AND LENGTH
	RTS PC
;PUT LINE POINTED TO BY CTP INTO ARRAY POINTED TO AT E
INSLIN:	TST CLCNT	;ARE THERE ANY MORE TOKENS LEFT?
	BEQ INSDON	;NO
	MOV @CPBND,B	;GET POINTER TO THE START OF THE LINE'S PROCEDURE
	ADD CTP,B	;POINT TO THE LINE TO INSERT
	MOV CLCNT,C	;NUMBER OF TOKENS TO INSERT
1$:	MOV (B)+,(E)+	;COPY THE TOKENS
	SOB C,1$
INSDON:	RTS PC


;MAKE SPACE FOR D BYTES AT (E). IF D IS NEGATIVE COLLAPSE SPACE.
;IF D IS POSITIVE, EXPAND THE ARRAY IF NEEDED, COPY THE ARRAY, LEAVING D
;BYTES AT THE ORIGINAL E
;PARRYS AND PARRYF ARE UPDATED IF NEEDED, AND 1 DIMENSION OF ARRAY ALSO
MAKSPA:	TST D
	BEQ SPADON	;NOTHING NEED BE DONE
	BPL SPAEXP	;NEED TO EXPAND MAYBE
	JSR F,CACSAV	;SAVE THE AC'S
	SUB D,PARRYF	;MAKE THE FREE SPACE A LITTLE LARGER
	MOV @PARRYS,A	;POINT TO THE START OF THE ARRAY
	MOV 5*2(A),B	;GET POINTER TO THE FIRST UNUSED LOCATION
	ADD A,B		;MAKE IT AN ABSOLUTE POINTER
	ADD D,5*2(A)	;DECREASE THE POINTER BY THE AMOUNT SHIFTED DOWN
	MOV E,F		;COPY POINTER TO WHERE WE ARE MUNGING
	SUB D,F		;MAKE IT POINT AHEAD D BYTES
	SUB F,B		;GET NUMBER OF BYTES TO TRANSFER
	BLE SPADN1	;NUMBER OF BYTES DELETING IS MORE THAN FROM (E) TO END OF PROC.
	ASR B		;GET NUMBER OF WORDS
MAKSP1:	MOV (F)+,(E)+	;TRANSFER THEM
	SOB B,MAKSP1	;FOR ALL THE BYTES
SPADN1:	JSR F,CACRES	;GET BACK THE AC'S
SPADON:	RTS PC		;AND RETURN
SPAEXP:	JSR F,CACSAV	;SAVE THE AC'S
	CMP D,PARRYF	;IS THERE ENOUGH FREE SPACE TO WIN ON THIS PROCEDURE?
	BLE NUFSPA	;YES
;HERE WE HAVE TO TRY TO EXPAND THE ARRAY
	MOV @PARRYS,A	;POINT TO THE BEGINNING OF THE CURRENT ARRAY
	MOV SIZE(A),B	;GET THE CURRENT SIZE
	SUB A,E		;MAKE POINTER TO WHERE TO INSERT RELATIVE TO OLD ARRAY START
	ADD D,B		;GET NEW NUMBER OF BYTES NEEDED
	ADD #PROINC,B	;AND ADD A LITTLE EXTRA FOR EFFICIENCY
	JSR PC,..ALLOC	;GET A NEW ARRAY OF THAT SIZE, POINTER IN A
	BEQ NOSPA	;NO SPACE
	MOV @PARRYS,C	;GET ADDRESS OF OLD ARRAY
	ADD C,E		;MAKE IT POINT TO THE POSSIBLE NEW PLACE
;HERE THE OLD ARRAY IS CONSISTENT AGAIN, NEW ARRAY POINTED TO BY A, OLD BY C
;PARRYS IS NOT CONSISTANT YET
	ADD #PROINC,PARRYF	;ADD SOME SPACE TO THE FREE COUNT
	MOV C,B		;COPY POINTER TO OLD ARRAY
	MOV A,F		;COPY POINTER TO THE NEW ARRAY
	ADD #2*2,F	;POINT TO THE START OF THE INFO IN THE NEW ARRAY
	ADD #2*2,B	;POINT TO THE START OF THE INFO IN THE OLD ARRAY
	SUB B,E		;GET THE BYTE COUNT FROM BOTTOM TO INSERTED AREA
	BEQ TOPPRT	;NO BYTES BELOW AREA, MOVE REST OF AREA UP
	ASR E		;INTO A WORD COUNT
1$:	MOV (B)+,(F)+	;COPY UP THE BOTTOM OF THE ARRAY
	SOB E,1$	;ALL THE WORDS IN THE BOTTOM
TOPPRT:	MOV F,10(P)	;CLOBBER THE STORED E ON THE STACK
	ADD D,F		;SKIP D BYTES
	MOV 5*2(C),E	;GET THE POINTER TO THE END OF THE ARRAY
	ADD C,E		;MAKE IT UNRELATIVE AGAIN
	SUB B,E		;SUBTRACT WHERE WE HAVE GOTTEN
	BEQ SPADN2	;DONE IF NO BYTES ABOVE THIS POINT
	ASR E		;INTO A WORD COUNT
2$:	MOV (B)+,(F)+	;MOVE IT UP IN THE NEW ARRAY
	SOB E,2$	;FOR ALL THE WORDS IN THIS ARRAY
SPADN2:	MOV A,@PARRYS	;UPDATE THE POINTER TO THE ARRAY
	MOV (C),(A)	;SET UP BACK POINTER TO BINDING NODE
	SUB A,F		;MAKE POINTER TO END RELATIVE AGAIN
	MOV F,5*2(A)	;SET IN POINTER TO THE END OF THE PROC
	MOV C,B		;COPY POINTER TO THE OLD ARRAY 
	JSR PC,.RELES	;AND RELEASE IT
	BR SPADN1	;AND FINISH UP
NOSPA:	ERROR+NAS	;NOT ENOUGH ARRAY SPACE (MAYBE CHANGED TO NO STORAGE LEFT)

NUFSPA:	SUB D,PARRYF	;DECREASE THE AMOUNT OF FREE SPACE
	BMI MAKBUG	;BUG IF IT GOES NEGATIVE
	MOV @PARRYS,A	;POINT TO THE START OF THE ARRAY
	MOV 5*2(A),B	;GET THE POINTER TO THE END OF THE ARRAY
	ADD A,B		;MAKE IT NON RELATIVE
	ADD D,5*2(A)	;MAKE THE POINTER A LITTLE HIGHER
	MOV B,A		;COPY IT
	SUB E,A		;GET THE NUMBER OF BYTES TO COPY
	BEQ SPADN1	;NOTHING TO COPY
	ASR A		;GET THE NUMBER OF WORDS TO COPY
	MOV B,C		;POINTER TO THE TOP OF THE ARRAY
	ADD D,C		;POINT TO THE RIGHT SPOT ABOVE THE ARRAY
MAKSP2:	MOV -(B),-(C)	;COPY IT UP
	SOB A,MAKSP2
	BR SPADN1	;ALL DONE
MAKBUG:	.BUG.
.ENDC
	.STITL UTILITY - LOAD AND STORE
.LOADA:	MOV A,B		;(A) -> A,,B
	BR .LOAD
.LOADC:	MOV C,B	;NODE ADDR IN C
		;NODE RETURNED IN A,B
.LOADB:
.LOAD:	BIC #170000,B	;NODE ADDR IN B
	ASL B	;NODE RETURNED IN A,B
	ASL B
	ADD #NODESP,B
	MOV (B)+,A
	MOV (B),B
	RTS PC
.STORE:	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ASL C	;NODE IN A,B IS STORED AT C
	ASL C
	ADD #NODESP,C
	MOV A,(C)+
	MOV B,(C)
	SPOP C
	RTS PC

.STP2:		;SAME AS .STP1 EXCEPT STORE IN 2ND WORD OF NODE
	SEC	;THEN RESULT OF ROL'S WILL BE TWO GREATER THAN  .STP1
	BR .+4
.STP1:	CLC	;STORE (A) IN FIRST WORD OF NODE AT C
	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ROL C
	ROL C
	ADD #NODESP,C
	MOV A,(C)
	SPOP C
	RTS PC

.LDP2:	SEC		;NODE ADDR IN C (TYPE FIELD =0)
	BR .+4		;LOAD 2ND WORD OF NODE INTO A
.LDP1:	CLC		;SAME AS .LDP2 EXCEPT 1ST WORD
	MOV C,A
	BIC #170000,A
	ROL A
	ROL A
	ADD #NODESP,A
	MOV (A),A
	RTS PC

.LDP2I:	MOV C,A	;SAME AS .LDP2 EXCEPT C WILL
	BIC #170000,A	;CONTAIN ADDR OF NEXT NODE
	ASL A
	ASL A
	ADD #NODESP,A
	MOV (A)+,C
	MOV (A),A
	RTS PC
	.STITL UTILITY - BINDING
	;INPUT:	A=TYPE	B=UOE POINTER
	;		TOPS=0 OR TYPE+VALUE POINTER
	;OUTPUT:	A - UCHANGED
	;		B - EITHER UNCHANGED OR VALUE POINTER
	;		C - POINTS TO BINDING NODE, EITHER 
	;		    RELEVANT ONE OR LAST IN BINDING LIST
	;		IF TOPS = 0, SKIPS IF BINDING FOUND
	;		IF TOPS NOT = 0, TOPS WILL BE INSERTED
	;		   AS THE NEW VALUE POINTER (A NEW BINDING
	;		   NODE WILL BE ADDED IF NECESSARY) NEVER SKIPS.
.BINDL:	TST TOPS
	BEQ .BIND
	PUSHS TOPS
	CLR TOPS
	JSR PC,.BIND
	BEQ .BNDL2
	POPS TOPS
	CLZ
	RTS PC
.BNDL2L:	POPS TOPS
	SEZ
	RTS PC

.BIND:	PUSH D
	SPUSH B
	SPUSH A
	MOV B,A
BINDF1:	MOV A,C
	JSR PC,.LOADC
	MOV A,D
	BIC #7777,D
	CMP (P),D
	BEQ BINDF4	;FOUND IT
	BIT #7777,A
	BNE BINDF1
	TST TOPS	;DIDNT FIND IT
	BEQ BINDF2	;SHOULD ONE BE CREATED?
	SPOP A
	MOV TOPS,B
	JSR PC,GRBAD1
BINDF5:	POP D	;OLD B
BINDF3:	SPOP D
	SEZ
	RTS PC

BINDF2:	POP A	;NO, DONT CREATE NODE
	SPOP B
	BR BINDF3

BINDF4:	TST TOPS	;FOUND, CHANGE VALUE POINTER?
	BEQ BINDF6
	MOV TOPS,A	;YES + DONT SKIP
	JSR PC,.STP2
	POP A
	BR BINDF5

BINDF6:	POP A	;NO, LEAVE VALUE POINTER, BUT SKIP
	SPOP D	;OLD B
	SPOP D
	CLZ
	RTS PC
.UNBND:	PUSH A	;ERASE TYPE (A) FROM UOE (B)
	SPUSH B	;SKIP UNLESS NOT FOUND
	SPUSH C
	SPUSH D
	MOV B,C
.UNB1:	MOV C,D
	MOV B,C
	BIT #7777,C
	BNE 1$
	JMP RETD
1$:	JSR PC,.LOADC
	MOV A,B
	BIC #7777,A
	CMP 6(P),A
	BNE .UNB1
	MOV D,C
	JSR PC,.LDP1
	BIC #7777,A
	BIC #170000,B
	BIS B,A
	JSR PC,.STP1
	JMP SRETD

.IFZ BEEF
.BINDF:	MOV #FBIND,A	;GET FUNCTION BINDING, SWAP IN IF NECESSARY
		;PTR TO UOE IN B
		;OUTPUT AS IN .BIND: EXCEPT A,,B = NODE PTD TO BY C
	JSR PC,.BINDL	;LOOK FOR FUNCTION BINDING
	BEQ BIF1
	JSR PC,.LOADB
	BIT #7777,A	;IS PROC SWAPPED IN?
	BNE BIF1	;YEP
	ERROR+BUG
	CLZ
	RTS PC
.IFF
.BINDF:
.IFTF
.BNDFS:	MOV #FBIND,A	;SAME AS .BINDF EXCEPT DONT SWAPIN
	JSR PC,.BINDL
.IFT
	BEQ BIF1
	JSR PC,.LOADB
	CLZ
.IFTF
BIF1:	RTS PC
.ENDC
	.STITL .INTRN!!
.OBSCH:		;SAME AS .INTRN EXCEPT WONT INSERT IF ENTRY ISNT FOUND
		;(ALSO SEE UOBSCH ON NEXT PAGE)
	BIC #TF5,TFLAGS
	BR .+10
.INTRN:		;(ALSO SEE UINTRN ON NEXT PAGE)
		;INPUT:  TYPE IN A, LSTR IN "TOPS"
		;OUTPUT:  IF TYPE IS UFUN OR SFUN,
		; SEARCH SYSTEM OBLIST FIRST.
		;  IF FOUND THERE, RETURN THAT PTR IN B,
		; MAKING TYPE OF A TO "SFUN".
		;  IF NOT FOUND THERE, AND IF A=UFUN, OR IF TYPE
		;  IS > "UFUN", DO THE LOOKUP IN THE USER OBLIST.
		;  RETURN WITH THE UOE PTR IN B.
		; DONT SKIP IF A NEW ONE HAD TO BE ADDED,
		;  OR IF IN SEARCHING FOR AN SFUN
		;  ONE WAS NOT FOUND.
;*******  NOTE  ********
;A NEW UOE IS "TOTALLY USELESS" AND SO MUST BE PROTECTED FROM G.C.
	BIS #TF5,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
	CMP #UFUN,A	;IS TYPE SFUN OR UFUN
	BLO INT2	;NO
	JSR PC,SSOL	;YES, SEARCH SYSTEM OBLIST
	BEQ INT1	;NOT THERE
	MOV #SFUN,4(P)	;SET TYPE TO "SFUN"
	BR INT5

INT1:	CMP #SFUN,A	;IS A = TYPE SFUN
	BEQ INT0	;YES, DONE, DONT SKIP
INT2:	JSR PC,HSSL	;NO, HASH TO AND SEARCH SUBLIST
	BEQ INT3

INT5:	MOV B,2(P)
	JMP SRETC	;FOUND ATOM

INT3:	BIT #TF5,TFLAGS	;NOT THERE, SHOULD IT BE ADDED
	BEQ INT0	;NO, RETURN AND DONT SKIP
	SPUSH B		;SAVE WORD POINTER TO LAST NODE OF BUCKET
	MOV #LIST,A
	MOV #ATOM,B
	JSR PC,GRBAD	;CONS UP NEW LAST NODE
			;  (STRANGE TYPE LEST GARBAGE COLLECT)
	BIS #LIST,C
	PUSHS C		;SAVE POINTER TO IT, ALSO FOR G.C.
	MOV #ATOM,A
	MOV TOPS,B
	JSR PC,GRBAD2	;CONS UP ATOM NODE; NEW BUCKET NODE PTS TO IT
	MOV C,4(P)	;SO WILL B ON RETURN
	POPS C
	BIC #LIST,C	;GET BACK POINTER TO NEW BUCKET NODE

	MOV #BUKTEL,A
	JSR PC,.STP1	;MAKE IT AN END-OF-BUCKET NODE
	BIS C,A		;OLE & PTR TO IT
	SPOP C		;TO OLD END-OF-BUCKET WORD
	MOV A,(C)

INT0:	JMP RETC


;"UNPURE" .INTRN AND .OBSCH
;BY "UNPURE" IT IS MEANT THAT THE INPUT STRING MAY INCLUDE
;NULL CHARACTERS
;SPECIFICATIONS ARE OTHERWISE IDENTICAL TO .INTRN AND .OBSCH

;ROUTINE TO PURIFY STRING
UINOB:	PUSH A
	PUSH B
	PUSH C
	MOV	TOPS,B
	JSR PC,CPYSTR	;OUTPUT POINTER IN B TO STRING WITH NO NULLS
	BIS #LSTR,B
	MOV	B,TOPS
	POP C
	POP B
	POP A
	RTS PC

UINTRN:	SPUSH #.INTRN
	BR UINOB

UOBSCH:	SPUSH #.OBSCH
	BR UINOB
	.STITL SEARCH SYSTEM OBLIST
SSOL:		;SEARCH SYSTEM OBLIST
		;INPUT:  C POINTS TO STRING
		;OUTPUT:  SKIP = FOUND AND SOE PTR IN B
		;  NO SKIP = NOT FOUND AND NO CHANGE
		;NULL MUST BE USED AS FILLER CHAR BUT NOT BE IMBEDDED
	PUSH A
	SPUSH B
	SPUSH C		; -> STRING (DESIRED PNAME)
	SPUSH D		; -> CURRENT PNAME
	SPUSH E		; 2^N
	SPUSH F		; -> SYSTEM OBLIST ELEMENT
	MOV SOBP2,E	;GET 2^N
	MOV #SOBLST,F	;GET START OF OBLIST
SSOL1:	ASR E		;HALVE 2^N
	BIT #177776,E	;NOT FOUND IF 2^N = 1
	BEQ SSOL5
	ADD E,F		;ADD 2^N TO OBLIST PTR
	CMP F,SOOMX	;OVERSHOT END OF LIST THEN UNDO ADD
	BHIS SSOL2
	MOV (F),D
	ADD #4+SOBLST,D	;FIND START OF THIS PNAME
	MOV C,A		;AND DESIRED PNAME
SSOL4:	JSR PC,.LOADA	;GET TWO CHARS OF DESIRED
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED:  ADD 2^(N-1)
	BLO SSOL2	;PNAME > DESIRED:  UNADD 2^N AND ADD 2^(N-1)
	SWAB B
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED
	BLO SSOL2	;PNAME > DESIRED
	BIT #7777,A	;MORE PNAME TO COMPARE?
	BNE SSOL4	;YES
	TSTB B		;MATCHING NULLS FOUND?
	BEQ SSOL3	;FOUND
	TSTB (D)	;AT END OF STRING, IS IT END OF SYS PNAME
	BNE SSOL2	;NO:  TRY ANOTHER (COUNT AS OVERSHOOT)
SSOL3:	MOV (F),F	;POINTER TO OBLIST ELEMENT
	.IFNZ ENG&FR
	BIT LANG,SOBLST(F)
	BEQ SSOL5
	.ENDC
	BIT #ABRFLG,SOBLST(F)	;IS IT AN ABBRVIATION?
	BEQ 1$
	MOV 2+SOBLST(F),F	;YES, "EXPAND" IT
1$:	ASR F
	MOV F,10(P)	;YES, SAVE F AS OUTPUT
	JMP SRETF

SSOL5:	JMP RETF

SSOL2:	SUB E,F		;UNADD 2^N
	BR SSOL1
	.STITL HASH AND SEARCH USER SUB-OBLIST
HSSL:		;HASH, THEN SEARCH SUB-LIST
		;INPUT:  C POINTS TO LSTR
		;OUTPUT:  IF NOT FOUND, B IS A WORD POINTER
		;	 TO LAST BUCKET ELEMENT.
		;  IF FOUND, B POINTS TO ATOM CELL, AND RETURN SKIPS.
	PUSH A
	SPUSH B		;PTR TO THIS PNAME
	SPUSH C		;PTR TO DESIRED PNAME
	SPUSH D		;NEXT OLE
	SPUSH E		;THIS OLE
	MOV C,A		;PTR TO STRING
	CLR D		;SUM OF WORDS FOR HASHING
HSSLA:	JSR PC,.LOADA	;GET A TWO-LETTER FRAGMENT
	ADD B,D		;ADD IN
	BIT #7777,A	;MORE FRAGMENTS?
	BNE HSSLA	;YES
	MOV D,B		;CREATE SUM OF ALL CHARS
	SWAB B
	ADD D,B		;IN LOWER BYTE (UPPER WON'T HURT)
	CLR A
	DIV #HCC,A
	ASL B
	ADD #UHCT,B
	MOV B,E		;RETURN ADDR OF LAST ELEMENT OF BUCKET IF NOT FOUND
	MOV (B),A	;A POINTS TO FIRST OLE NOW
HSSL1:	BIT #7777,A	;END OF BUCKET?
	BNE HSSLB
	MOV E,6(P)	;YES: NOT-FOUND RETURN:
	JMP RETE	;OUTPUT END-OF-BUCKET POINTER IN B

HSSLB:	MOV A,E		;SAVE PTR TO THIS OLE
	JSR PC,.LOADA	;GET THIS OLE
	MOV A,D		;SAVE PTR TO NEXT ONE
	JSR PC,.LOADB	;GET FIRST NODE OF ATOM STRUCTURE
	JSR PC,CSEQ	;CSEQ COMPARES STRINGS AT (B) AND (C)
	BEQ HSSL2	;NOT EQUAL:  TRY NEXT OLE
	MOV E,A		;EQUAL:
	JSR PC,.LOADA	;OUTPUT ATOM POINTER
	MOV B,6(P)
	JMP SRETE	;SKIP RETURN

HSSL2:	MOV D,A		;NOT FOUND, CHECK NEXT BUCKET ELEMENT
	BIC #LIST,E	;MAKE E A WORD PTR TO FIRST WORD OF PREV. NODE
	ASL E		;IN CASE IT'S THE LAST ONE.
	ASL E
	ADD #NODESP,E
	BR HSSL1
CSEQ:	PUSH A		;COMPARE TWO STRINGS - POINTERS IN B & C
	PUSH B		;SKIP IF EQUAL
	PUSH C		;"NULL" (8-BIT ON) CHARACTERS
	PUSH D		;  DON'T MATCH CORRESPONDING 8-BIT OFF CHARS
	MOV B,D		;SAVE STR 1 PTR
CSEQ1:	BIT #7777,D	;CHECK IF EITHER STRING DONE
	BEQ CSEQ3	;FIRST IS:  IS SECOND?
	BIT #7777,C
	BEQ CSEQ2	;SECOND BUT NOT FIRST:  NOT EQUAL
	MOV D,A
	JSR PC,.LOADA	;GET NEXT NODE OF STR 1: (A) TO A,,B
	MOV A,D	;SAVE POINTER IN D
	JSR PC,.LDP2I	;GET NEXT NODE OF STR 2: (C) TO C,,A
	CMP A,B
	BEQ CSEQ1	;WELL, THESE WORDS MATCH
CSEQ2:	JMP RETD	;STRINGS NOT EQUAL

CSEQ3:	BIT #7777,C	;SEE IF BOTH STRINGS ARE DONE
	BNE CSEQ2	;NOPE, NOT EQUAL
	JMP SRETD	;STRINGS EQUAL
	.STITL UTILITY - GRAB NODE ROUTINES
GRBAD2:	SEC	;GRAB A FREE NODE, FILL IT WITH A,,B
			;IF C NOT =0, PUT PTR TO NEW NODE IN WORD 2 OF NODE(C)
			;C ALSO GETS POINTER TO NEW NODE REGARDLESS
	BR .+6
GRBAD:	CLR	C	;SAME AS ABOVE EXCEPT NEW POINTER ALWAYS IN C
GRBAD1:	CLC	;SAME AS ABOVE EXCEPT NEW PTR IN WORD 1
	SPUSH A
	BIC #170000,C
	BEQ GRB2	;C IS ZERO, FORGET STORING NEW NODE PTR
	ROL C
	ROL C
	ADD #NODESP,C	;ELSE MAKE NODE ADDRESS TO STORE AT
GRB2:	BIT #MGCF,FLAGS2
	BNE GRB4
	MOV FREE,A
	BNE GRB1
GRB4:	JSR PC,.GCOLL
	MOV FREE,A
	BNE GRB1
	CLR ERPROC	;DISABLE ERRSET IF 0 NODES
	ERROR+NSL	;NO STORAGE LEFT
GRB1:	DEC NNIFSL
	BGE 1$		;NEG NODES LEFT??
	.BUG.
1$:	TST C
	BEQ GRB3
	BIC #170000,A
	BIC #7777,(C)
	ADD A,(C)
GRB3:	MOV A,C
	JSR PC,.LDP1
	SPUSH A		;CHECK THAT NODE WAS IDLE
	BIC #7777,A
	CMP #IDLE,A
	BEQ 1$
	.BUG.		;GRABBED AN UNIDLE NODE!!!!!
1$:	SPOP A
	BIC #170000,A
	MOV A,FREE
	SPOP A
	JSR PC,.STORE
	RTS PC
	;.STITL UTILITY  -  FREE NODE ROUTINES
.FREE:	SPUSH A	;RETURN NODE IN C TO FREE STORAGE
	SPUSH B
	MOV FREE,A
	BIS #IDLE,A
	CLR B		;MAKE SURE POINTER 2 IS ZERO
	JSR PC,.STORE
	BIC #170000,C
	MOV C,FREE
	INC NNIFSL
	SPOP B
	SPOP A
.FREE1:	RTS PC
FRELST:	BIT #7777,TOPS	;RETURN LIST (TOP-LEVEL ONLY) IN TOPS
			;TO FREE STORAGE
	BEQ .FREE1
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
FRL1:	JSR PC,.LOADC
	JSR PC,.FREE
	BIT #7777,A
	BEQ FRL2
	MOV A,C
	BR FRL1
FRL2:	CLR TOPS
	JMP RETC
	.STITL READ A STRING

RDSTR7:	BIS #RBRKF,TFLAGS
	SEZ
RDSTR8:	RTS PC
RDSTR1:	PRCR	;OUTPUT - PTR ON S, SKIP UNLESS EMPTY OR BREAK
RDSTR:	CLR NBKTS
	TST	BRAKE
	BNE RDSTR7
	CMP #TYI,GCHR	;WILL CHARS BE COMING FROM TTY?
	BNE RLINE1	;NO
	TST REDFLG
	BNE RLINE1	;READING FROM A FILE
	TST BRAKE
	BEQ 1$
	ERROR+BRK
1$:	MOV PRMTCH,D
	BEQ	RLINE
	BIT #BRKF,FLAGS
	BEQ RLINE2
	MOV FUNLEV,A
	BEQ RLINE2
LANGC	<MOV #'L,D>,<
	MOV #'N,D>
	JSR PC,TYO
	JSR PC,PRDN
	MOV PRMTCH,D
RLINE2:	JSR PC,TYO
RLINE:
RLINE1:	JSR PC,BLSTI
RDSTR2:	JSR PC,@GCHR
	CMP #TYI,GCHR
	BEQ RDST2A
	CMP #2,D	;NOT FROM TTY: CHANGE ^B TO %
	BNE RDST2A	;(PRINTS AS SPACE STILL)
RDST2A:	TST	BRAKE
	BNE	RDSTR7
	CMP #EOFCHR,D
	BNE RDSTR9
	MOV #TYI,GCHR	;NON-TTY INPUT DONE
	MOV #'],D	;FILL IN MISSING ]'S
	TST NBKTS
RDSR10:	BLE RDSTR4
	JSR PC,BLST
	DEC NBKTS
	BR RDSR10
RDSTR9:	CMP #'G-100,D	;BREAK TYPED?
	BEQ RDSTR7	;YES
	CMP #'Z-100,D
	BEQ RDSTR7
	TST NBKTS	;IN A LIST?
	BGT RDSTR3	;YES
	CMP #15,D	;CR?
	BEQ RDSTR4
RDSTR3:	CMP #'[,D
	BNE RDSTR6
	INC NBKTS
RDSTR6:	CMP #'],D
	BNE RDSTR5
	DEC NBKTS
RDSTR5:	JSR PC,BLST
	BR RDSTR2
RDSTR4:	BIC #RBRKF,TFLAGS
	JSR PC,BLSTF
	BEQ RDSTR8
	PUSHS TOPS
	CLR TOPS
RDSTSR:	CLZ
	RTS PC

	.STITL REQUEST, FILE READ & WRITE
RQUEST:
RQU1:	PUSH PRMTCH
	JSR PC,INPUTL
	BEQ RQU5
	MOV E,C	;E POINTS TO LAST NODE OF STRING
	JSR PC,.LOADC	;NEED TO ADD A "]", IS THERE ROOM?
	BIT #177400,B
	BNE RQU2	;YES
	BIS #']*400,B	;NO - PUT A "]" THERE
	JSR PC,.STORE
RQU3:	MOV @S,GNCN
	BIC #170000,GNCN
	CLR F		;THIS IS PUSHED BY RDLST
	JSR PC,RDLST
	POPS TOPS
RQU4:	MOV TOPS,@S
	CLR TOPS
RQUR:	POP PRMTCH
	CLZ
	RTS PC
RQU2:	MOV #'],B
	JSR PC,GRBAD1
	BR RQU3
RQU5:	MOV #LIST,@S
	BR RQUR
INPUTL:	MOV #'<,PRMTCH
	CMP -(P),-(P)
	SPUSH TYICP
	BIS #.TTCNO*400,(P)
	$INVOK
	TST (P)+
	BEQ 1$
	CLR PRMTCH
1$:	JSR PC,RDSTR
	BNE IPUL2
IPUL1:	BIT #RBRKF,TFLAGS
	BEQ IPUL3
	POP PRMTCH	;THE RETURN
	SPOP PRMTCH	;NOW THE OLD PRMTCH
	ERROR+BRK
IPUL3:	PUSHS #LSTR
	SEZ
IPUL2:	RTS PC
TYPEIN:	JSR PC,RQU1	;INPUT A WORD FROM TTY
	BIT #7777,@S
	BNE TYPIN2
	MOV #LSTR,@S
	RTS PC
TYPIN2:	JMP FIRST
	.STITLE  READ -

READ:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	CLR RDFLAG
	MOV @S,GNCN
	BIC #170000,GNCN
	CLR F
READA:	JSR PC,RDWRD
	BEQ READB
	BIS #SEPF,RDFLAG
	JSR PC,CKDOTF
READC:	JSR PC,LISTB
	BIT #SEPF,RDFLAG
	BEQ READA
READB:	BIC #SEPF,RDFLAG	;CHECK SPECIAL CHAR IN D
	JSR PC,CKDOTF	;FIRST CHECK FOR PENDING ":"
	CMP #15,D
	BEQ READR	;C-R
	CMP #'",D
	BEQ READS	;STRING
	CMP #'[,D
	BEQ READL	;LIST
	CMP #'],D
	BNE 1$
	ERROR+COP	;CHAR (]) OUT OF PLACE
1$:	CMP #':,D
	BEQ READD	;DOTS
	BITB #OPERF,DTBL(D)	;IS CHAR AN OPERATOR
	BEQ READA	;NO
	MOVB DTBL2(D),A
	ASL A
	MOV SOBLSU(A),B
		;SET TYPE TO SFUN OR INFIX
	MOV SOBLST(B),A	;THIS CROCK WORKS BECAUSE #SFUN=0
	BIC #-INFIX-1,A	; AND #INFIX=10000
	ASR B
.IIF NZ BEEF,	BIS A,B		;SET IN THE TYPE (IF INFIX)
	BR READC

READR:	POPS A
	CLR	TOPS
	TST	F
	BNE	READR1
	JMP RETF
READR1:	MOV A,@S
	JMP SRETF

READS:	JSR PC,GNC
	JSR PC,RDST
	BIS #SEPF,RDFLAG
	BR READC
READL:	JSR PC,RDLST
	POPS TOPS
	BIC #SEPF,RDFLAG
	BR READC
READD:	BIS #DOTF,RDFLAG
	BR READA
	.STITLE READ - READ WORD
	;READ CHARS UP THRU NEXT SEPARATOR CHAR.  IF JUST A SEP, RETURN
	;WITH IT IN D.  OTHERWISE NUMBERIFY OR INTERN CHAR STRING,
	;SKIP RETURN WITH TOKEN IN A,,B
RDWRD:	CLRB RDFLAG
	JSR PC,BLSTI
RDWA:	JSR PC,GNC
	JSR PC,GETCHF	;GET FLAGS IN A
	BIT #SEPF,A	;IS THIS CHAR A SEPARATOR?
	BNE RDWB	;YES
	BISB A,RDFLAG
	JSR PC,BLST
	BEQ RDWA
RDWB:	JSR PC,BLSTF	;FINISH OFF STRING
	BEQ RDWR+2
	BIT #NNUMF,RDFLAG
	BNE RDWC	;NOT A POSSIBLE NUMBER
	MOV TOPS,B
	MOV #LNUM,A
	JSR PC,CONVER	;TRY MAKING A #
.IFNZ FPPF
	BNE RDWR1
	MOV #FNUM,A
	JSR PC,CONVER	;IT MIGHT BE AN FNUM
.ENDC
	BNE RDWR1
RDWC:	MOV #UFUN,A	;TRY TO INTERN STRING IN TOPS AS A SYSTEM OR USER FUNCTION
	BIT #DOTF,RDFLAG	; UNLESS DOTF ON, THEN AS USER VARIABLE
	BEQ RDWD
	MOV #UVAR,A
	BIC #DOTF,RDFLAG
RDWD:	JSR PC,.INTRN	;RDST COMES HERE ALSO
	BEQ RDWE
	JSR PC,FRELST
RDWE:	BIC #170000,B
	BIS A,B
	CMP #UFUN,A	;IF WE GOT A UOE
	BHI RDWR+2	;THEN--
RDWR1:	MOV B,TOPS	;PROTECT THIS NEWLY HATCHED UOE FROM G.C.
RDWR:	CLZ
	RTS PC

GETCHF:		;GET FLAGS FOR CHAR IN D INTO A
	MOV #NNUMF,A
	TSTB D	;CHECK FOR 200 BIT
	BLT 1$
	MOVB DTBL(D),A
1$:	RTS PC
	.STITLE READ - READ STRING
	;READ CHAR UP TO NEXT SPACE OR ] IF INSIDE
	;A LIST.  DONT ALLOW ] OR [.
	; SKIPS UNLESS EMPTY STRING
RDST:	CLRB RDFLAG
	JSR PC,BLSTI
	BR RDSB
RDSA:	JSR PC,GNC
RDSB:	JSR PC,GETCHF
	BIT #SEPF,A
	BEQ RDSE
	CMP #' ,D
	BEQ RDSX
	CMP #'],D
	BEQ RDSC
	CMP #'[,D
	BEQ RDSX
	CMP #15,D
	BEQ RDSX
RDSE:	BISB A,RDFLAG
	JSR PC,BLST
	BR RDSA
RDSC:	TST LISTBD	;ARE WE IN LIST
	BNE RDSX	;YES
RDSD:	ERROR+COP	;CHAR (D) OUT OF PLACE
RDSX:	MOV #LSTR,A
	MOV #LSTR, B
	JSR PC,BLSTF
	BEQ RDWR+2
	MOV #LSTR,A
	MOV TOPS,B
	BIT #NNUMF,RDFLAG
	BEQ RDWR	;IT IS A POSSIBLE NUMBER
	BIT #SEPF,RDFLAG
	BNE RDWR+2	;IT HAS A SEP CHAR IN IT
	MOV #ATOM,A
	BR RDWD	; INTERN IT

	;READ THRU MATCHING ] MAKING A LIST AS U GO
RDLST:	CLRB RDFLAG
	JSR PC,SLISTB
RDLA:	JSR PC,GNC
	CMP #' ,D
	BEQ RDLA	;SKIP OVER SPACES
	CMP #'[,D
	BEQ RDLB	;READ A LIST
	CMP #'],D
	BEQ RDLY	;DONE
	JSR PC,RDST	;READ A STRING
RDLX:	JSR PC,LISTB	;ADD THIS NODE TO LIST
	CMP #'[,D
	BEQ RDLB
	CMP #'],D	;AT END?
	BNE RDLA	;NO, GET NEXT ELEMENT
RDLY:	JSR PC,FLISTB
	RTS PC
RDLB:	JSR PC,RDLST
	POPS TOPS
	CLR D
	BR RDLX
	.STITLE READ - MISC
CKDOTF:	BIT #DOTF,RDFLAG
	BEQ LISTBR
	BIC #DOTF,RDFLAG
	PUSH A
	SPUSH B
	MOV #SFUN,A
	MOV #$DOTS,B
	JSR PC,LISTB
	JMP RETB
LISTB:	PUSH C
	MOV F,C	;BUILD A LIST, ADD NODE IN A,,B TO
	JSR PC,GRBAD1	;LIST WHOSE LAST NODE PTR IS IN F
	TST F	;CAREFUL - THE FIRST TIME IT IS CALLED, THE
		;POINTER TO THE FIRST NODE IS PUSHED ONTO S
	BNE LISTB1
	PUSHS	C
	BIS #LIST,@S
LISTB1:	MOV C,F
	POP C
LISTBR:	RTS PC
SLISTB:		;START LISTB
	PUSHS F	;SAVE CURRENT LAST NODE PTR
	CLR F
	INC LISTBD
	RTS PC
FLISTB:	TST F
	BNE FLSB1
	PUSHS #LIST
FLSB1:	POPS B	;THIS IS THE OUTPUT
	MOV @S,F	;RESTORE OLD LAST NODE PTR
	MOV B,@S	;THE RESULT
	MOV #LIST,A
	DEC LISTBD
	RTS PC
BLSTI:	CLR NCHR
	CLR E
	CLR TOPS
BLSTI1:	BIS #100000,E
	RTS PC
BLST:		;BUILD STRING - CHAR IN D, USES E
	PUSH A
	SPUSH B
	SPUSH C
	CMPB #200,D	;CHECK IF NULL CHARACTER
	BEQ BLSTRT
	BIT #177,D	;CHECK IF NULL
	BEQ BLSTRT
	INC NCHR	;WE HAVE A CHAR
	ADD #40000,E
	BGE BLST2	;IS IT  THE SECOND
	MOVB D,TEMP	;NO, 1ST
BLSTRT:	JMP RETC
BLST2:	MOVB D,TEMP+1	;IT IS THE SECOND CHAR
	MOV TEMP,B
	;STORE THE CHARACTERS
BLST3:	JSR PC,BSAN
	BIS #100000,E
	BR BLSTRT
BLSTF:	;FINISH BUILDING STRING, PUT PTR IN TOPS.
		; DONT SKIP IF EMPTY STRING (TOPS=0)
	TST NCHR
	BEQ BSANR	;EMPTY STRING
	ADD #40000,E
	BLT BSANR
	PUSH A
	SPUSH B
	SPUSH C
	MOVB TEMP,B	;YES
	JSR PC,BSAN
BLSTF1:	JMP SRETC
BSAN:	MOV E,C
	MOV #SSTR,A
	JSR PC,GRBAD1
	TST E
	BNE BSAN1
	MOV C,TOPS	;SAVE NEW STRING PTR ON S
	BIS #LSTR,TOPS
BSAN1:	MOV C,E
BSANR:	RTS PC
	.STITL GNC - GET NEXT CHAR
GNC:	PUSH A		;GET NEXT CHAR INTO D
	SPUSH B		;INITIALIZE BY MOVING LSTR PTR INTO GNCN
GNC4:	MOVB GNCN+2,D	;    AND CLEARING TYPE FIELD (#170000)
	MOV GNCN,B	;PUTS CR (=#15) IN D IF NO MORE CHAR
	BLT GNC1	;JUST GOT 2ND CHAR
	BNE GNC3
	MOV #15,D
	JMP RETB	;NONE LEFT
GNC3:	JSR PC,.LOAD	;GET NEXT NODE
	BIS #100000,A	;SET "STILL ANOTHER CHAR" BIT
	MOV A,GNCN
	MOVB B,D	;FOR OUTPUT
	SWAB B
	MOVB B,GNCN+2
GNC2:	TST D
	BEQ GNC4	;IGNORE NULL CHARS
	JMP RETB
GNC1:	BIC #170000,GNCN	;CLEAR "STILL ..." BIT
	BR GNC2
	.STITL PRINT ROUTINES

PRLO:	PUSH A	;PRINT LAST OPERATOR
	SPUSH B
	MOV LO,A
	BEQ EMPTY
.IIF Z BEEF,	MOV LO+2,B
.IIF NZ BEEF,	MOV A,B
	BR PRCO1
PRCO:	PUSH A,	;PRINT CURRENT OPERATOR
	SPUSH B
	MOV CO,A
.IIF Z BEEF,	MOV CO+2,B
.IIF NZ BEEF,	MOV A,B
	BEQ EMPTY
PRCO1:	SPUSH D
	JSR PC,PROAB
	SPOP D
	JMP RETB
PROAB:	CMP A,#UFUN	;PRINT OPERATOR IN A,B
	BLO PRCO2
	JMP PPNAME	;PRINT PNAME
PRCO2:	MOV B,A	;SYSTEM FUNCTION
	BNE PRCO3
	PRTXT ^\ CR.\
	RTS PC
PRCO3:
.IIF NZ BEEF,	BIC #170000,A	;CLEAR OUT THE INFIX TYPE
	ASL A
	ADD #4+SOBLST,A
	BR	PRAS	;PRINT ASCIZ PNAME
NOTPRO:	ERROR+OOP	;SOMETHING OUT OF PLACE
EMPTY:	PRTXT ^\ EMPTY \
	JMP RETB

ERTAS:	SPUSH D
.IFZ TS
ERTAS1:
.IFZ LSI
	MFPI (A)
.IFF
	MOV (A),-(P)
.ENDC
	MOVB (P),D
	BEQ ERTAS2
	JSR PC,@PCHR
	MOVB 1(P),D
	BEQ ERTAS2
	JSR PC,@PCHR
	ADD #2,A
	TST (P)+
	BR ERTAS1
ERTAS2:	ADD #2,A
	TST (P)+
.IFF
	SPUSH B
	SPUSH C
MAPRD3:	MOV A,C		;ADDRESS IN I SPACE
	ASH #-13.,C	;PAGE IN I SPACE
	BIC #177770,C	;WHAT WE WANT IS A LSH (OR A BOTTLE OF BOOZE)
	SPUSH #7*400+0
	SPUSH C
	SPUSH #<10+HAKPG>*400+1
	SPUSH #.CRRD+1
	.MAP
	BNE 1$
	BPT
1$:	MOV A,B
	BIC #160000,B
	ADD #HAKAD,B
MAPRD1:	MOVB (B)+,D
	BEQ MAPRD2
	JSR PC,@PCHR
	INC A
	CMP B,#HAKAD+20000
	BEQ MAPRD3
	BR MAPRD1
MAPRD2:	INC A
	BIT #1,A
	BEQ 1$
	INC A
1$:	SPOP C
	SPOP B
.ENDC
	SPOP D
	RTS A


PRAS:	SPUSH	D	;PRINT ASCIZ STRING POINTED TO BY A
	BR	.+6
PRAS1:	JSR	PC,@PCHR
	MOVB	(A)+,D
	BNE	PRAS1
	SPOP	D
	RTS	PC
PRON:	BIC #TF2,TFLAGS	;PRINT OCTAL NO., NO. IN A
	BR PRON1	;CALL-	JSR PC,PRON
PRONL:	BIS #TF2,TFLAGS
PRON1:	PUSH A		;PRON DOESN'T PRINT LEADING ZEROS, PRONL DOES
	SPUSH D
	CLR D
	SEC
	ROL A	;TO TELL WHEN WE ARE DONE
	BR PRON2
PRON3:	CLR D
	ASL A
	BEQ PRON5
	ROL D
	ASL A
	ROL D
	ASL A
PRON2:	ROL D
	BNE PRON4
	BIT #TF2,TFLAGS
	BEQ PRON3
PRON4:	BIS #TF2,TFLAGS
	BIS #60,D
	JSR PC,@PCHR
	BR PRON3
PRON5:	BIS #60,D
	BIT #TF2,TFLAGS
	BNE 1$		;IF NOTHING HAS BEEN TYPED, TYPE A ZERO
	JSR PC,@PCHR
1$:	SPOP D
	SPOP A
	RTS PC

PRDN:	PUSH B		;PRINT DECIMAL NO. IN A
	SPUSH C
	SPUSH D
	CLR C
	MOV A,B
	BGT PRDN1	;POSITIVE
	BEQ PRDN0	;ZERO
	NEG B		;NEGATIVE:
	MOV #'-,D	;"-" (ABS VAL)
	JSR PC,@PCHR
PRDN1:	INC C		;COUNT A STORED DIGIT
	CLR A
	DIV #10.,A	;DIVIDE BY 10
	PUSH B		;SAVE REMAINDER = NEW DIGIT
	MOV A,B		;QUOTIENT:  = 0?
	BNE PRDN1	;NO:  GET SOME MORE LOW-ORDER DIGITS
PRDN2:	POP D		;GET SAVED HIGH-ORDER DIGIT
	ADD #'0,D	;ENCODE IT
	JSR PC,@PCHR	;PRINT IT
	DEC C
	BGT PRDN2	;UNTIL NO. DIGITS LEFT = 0
PRDNX:	POP D
	SPOP C
	SPOP B
	RTS PC
PRDN0:	MOV #'0,D	;TYPE "0"
	JSR PC,@PCHR
	BR PRDNX

EMPTY1:	JMP EMPTY

;ZPRDN PRINTS DECIMAL INTEGER IN A, WITH LEADING 0 IF < 10
ZPRDN:	JSR F,ACSAV	;SAVE ALL REGISTERS
	MOV A,B		;PUT NUMBER IN B
	CLR A	
	DIV #10.,A	;QUOTIENT IN A; REMAINDER IN B
	ADD #'0,A	;CONVERT TO CHAR
	MOV A,D		;PUT QUOTIENT IN D
	JSR PC,@PCHR	;PRINT IT
	ADD #'0,B	;CONVERT TO CHAR
	MOV B,D		;PUT REMAINDER IN D
	JSR PC,@PCHR	;PRINT IT
	JSR F,ACRES	;RESTORE ALL REGS
	RTS PC

PRS1:	PUSH A		;PRINT TOP ELEMENT OF SS
	SPUSH B
	MOV IS,A	;COMPUTE RELATIVE S PD PTR
	SUB S,A
	ADD SPRBAO,A
	CMP A,CSPDLP
	BLOS EMPTY1
	MOV @S,B
	SPUSH D
	JSR PC,PNODAB
	SPOP D
	JMP RETB
PNODAB:	MOV B,A
	BIC #7777,A
	CMP #SSTR,A
	BEQ PRS11
	CMP #SNP,A
	BLOS PRS11
	ERROR+INVN	;INVALID NODE
PRS11:	JSR PC,PRDATA
	RTS PC
PRCT:	PUSH A	;PRINT CURRENT TOKEN
	SPUSH B
	SPUSH D
	MOV CT,A
.IIF Z BEEF,	MOV CT+2,B
.IIF NZ BEEF,	MOV A,B
	JSR PC,PRTAB
	SPOP D
	JMP RETB
PRTAB:	BIC #7777,A	;PRINT TOKEN IN A,B
	CMP A,#UVAR
	BHIS 1$
	JMP PROAB
1$:	CMP A,#UVAR
	BEQ PRUV
	BR PRDATA
PRATM:	BIS #PQF,FLAGS2	;PRINT ATOM IN A,B
	BR PRUV1
PRUV:	MOVB #':,D	;PRINT USER VARIABLE IN A,B
	JSR PC,@PCHR
PPNAME:	BIC #PQF,FLAGS2	;PRINT PNAME - UOE PTR IN B
PRUV1:	JSR PC,.LOAD
	JMP PRLSTR	;PRINT PNAME
PRDATA:	CMP #INUM,A	;PRINT DATA IN A,B. 7777 FIELD OF A IS 0000
	BEQ PRINUM	;NUMBER
.IFNZ FPPF
	CMP #FNUM,A
	BEQ PRFNUM
.ENDC
	CMP #SNUM,A
	BEQ PRSNUM
	BIS #PQF,FLAGS2	;SET PRINT QUOTE FLAG
PRPNM1:	CMP #ATOM,A
	BEQ PRUV1
	CMP #LSTR,A
	BEQ PRLSTR	;LONG STRING
	CMP #SSTR,A
	BEQ PRSSTR	;SHORT STRING
	BIC #PQF,FLAGS2
	CMP #LIST,A
	BEQ PRLST
	TST WRTFLG
	BEQ	PRSNP	;YES
	PRTXT	^/" /	;OUTPUT EMPTY
	BR	PRSRET
PRSNP:	PRTXT ^\%SNAP%\	;CANT PRINT A SNAP
	BR PRSRET
PRLSTR:	JSR PC,.LOAD	;PRINT LONG STRING
PRSSTR:	JSR PC,PRQQ	;PRINT SHORT STRING
PRSTR2:	MOVB B,D
	JSR PC,PRSPT
PRSTR3:	SWAB B
	MOVB B,D
	JSR PC,PRSPT
PRSTR4:	MOV A,B
	BIC #170000,B
	BEQ PRSRET
	JSR PC,.LOAD
	BR PRSTR2
PRSRET:	RTS PC
PRQQ:	BIT #PQF,FLAGS2	;PRINT ' " ' IF PQF=1
	BEQ PRSRET
	BIT #DPQF,FLAGS2
	BNE PRSRET
	MOVB #'",D
	JMP @PCHR
.IFNZ FPPF
PRFNUM:	PUSH C
	JSR PC,.FLOAD
	MOV #FNUM,C
	BR PRFNM1
.ENDC
PRSNUM:	CLR A	;PRINT SNUM
	TST B
	BGE PRINM1
	COM A
	BR PRINM1
PRINUM:	JSR PC,.LOAD	;PRINT INUM
PRINM1:	PUSH C
.IFNZ FPPF
	 MOV #INUM,C	;SET FLAG FOR INUM ENTRY
.ENDC
PRFNM1:	MOV E,TMPBLK+2
	MOV F,TMPBLK+4
.IFNZ FPPF
	CMP #FNUM,C
	BNE 1$
	JSR PC,.CFNST
	BR .+6
1$:
.ENDC
	JSR PC,.CINST	;CONVERT INUM IN A,,B TO STRING ON P
	MOV TMPBLK+2,E
	MOV TMPBLK+4,F
	MOV P,A
	MOVB (A)+,D
	BNE PRINM3
PRINM2:	MOVB (A)+,D
	BEQ PRINM4
PRINM3:	JSR PC,@PCHR
	BR PRINM2
PRINM4:	INC A	;TO MAKE IT EVEN (??)
	MOV A,P
	POP C
PRSPT2:	RTS PC

PRSPT:	CMPB #200,D
	BEQ PRSPT2
	TSTB D
	BEQ PRSPT2
	BIT #CPTBF,FLAGS2
	BEQ PRSPT1
	CMPB #'%,D
	BNE PRSPT1
	MOV #' ,D
PRSPT1:	JMP @PCHR
PRLST:	PUSH A	;PRINT LIST, PTR IN B
	SPUSH B
	SPUSH C
	TST NBKTS
	BEQ PRL4
	MOV #'[,D
	JSR PC,@PCHR
PRL4:	INC NBKTS
	MOV B,C
PRL1:	SPUSH FLAGS2
	BIT #7777,C	;EMPTY LIST
	BEQ PRL2	;YES, DONE
	BIS #DPQF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
	BR PRL3
PRL6:	SPACE
PRL3:	JSR PC,.LOADC	;GET THIS NODE
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	JSR PC,PRTAB
	BIT #7777,C
	BNE PRL6
PRL2:	DEC NBKTS
	BEQ PRL5
	MOV #'],D
	JSR PC,@PCHR
PRL5:	BIC #DPQF,FLAGS2
	SPOP C	;GET OLD FLAGS2
	BIC #<-DPQF-1>,C	;MASK ALL BUT DPQF
	BIS C,FLAGS2	;AND RESTORE IT
	JMP RETC
PRNODE:	PUSH A	;PRINT NODE POINTED TO BY B
	SPUSH B
	SPUSH D
	JSR PC,.LOAD
	JSR PC,PRON
	SPACE
	MOV B,A
	JSR PC,PRON
	SPOP D
	JMP RETB


	.STITL PRINTOUT (ONCE KNOWN AS SHOW)
SHALPR:		;SHOW ALL PROCEDURES
		;USES A-F
	JSR PC,GNOLEI
	BR SHALP2
SHALP1:	JSR PC,.CRLF
SHALP2:	JSR PC,GNOLE
	BEQ SHOWA1
.IIF Z BEEF,	JSR PC,BURYQ
.IIF NZ BEEF,	JSR PC,BURYQX
	BEQ SHALP2
	JSR PC,PSHOW
	BNE 1$
	.BUG.
1$:	CMP PCHR,#TYO
	BNE SHALP2
	BR SHALP1

POTS:
SHALTI:	;SHOW ALL TITLES
	JSR PC,GNOLEI
SHATI1:	JSR PC,GNOLE
	BEQ SHOWA1
.IIF Z BEEF,	JSR PC,BURYQ
.IIF NZ BEEF,	JSR PC,BURYQX
	BEQ SHATI1
	JSR PC,SHTITL
	BR SHATI1

SHOWAL:	JSR PC,SHALPR	;SHOW ALL PROCEDURES
	JSR PC,SHALNA	;SHOW ALL NAMES
	TST WRTFLG	;DON'T SHOW ARRAYS ON WRITE
	BNE SHOWA1
	JSR PC,POARR	;SHOW ALL ARRAYS
SHOWA1:	SEZ
	RTS PC

SHOW:	BIT #7777,CT	;ANY TOKENS LEFT
	BNE SHOW00	;YEP
	MOV TOPRNM,B
	BNE SHOW0
	MOV LASTPR,B
	BNE SHOW0
	ERROR+SHW

SHOW00:	JSR PC,GTUOEB
	BNE SHOW1	;THE TOKEN ISNT A USER PROC
SHOW0:	JSR PC,PSHOW
	BNE SHOWA1
	ERROR+PNH	;PROCEDURE NOT HERE
SHOW1:	CMP #SFUN,A
	BNE SHOWE1
	TST B	;IS IT CR?
	BNE SHOW12	;NO
	MOV TOPRNM,B
	BNE SHOW0
SHOWE1:	ERROR+SHW

SHOW12:	MOV #PODISP,A
SHOW13:	CMP (A)+,B
	BNE SHOW23
	JMP @(A)
SHOW23:	TST (A)+
	TST (A)
	BNE SHOW13
	ERROR+SHW

.IFNZ DDF
CNTRL:	CLR C
	INC C
	BR ALSO2
ALSO:	CLR C
ALSO2:	BIT #7777,CT
	BNE .+4
ALSOWH:	ERROR+WTAB
	JSR PC,GNT
	BIC #7777,A
	CMP #SFUN,A
	BNE ALSOWH
	TST B
	BEQ ALSOWH
.IFNZ ENG
	CMP #$STTUR,B
	BEQ TUR
.IFNZ NDISP
	CMP #$DISPLAY,B
	BEQ DIS
.ENDC
.IFNZ NPLOT
	CMP #$PLOTTER,B
	BEQ PLOT
.ENDC
.ENDC
.IFNZ FR
	CMP #$TORTUE,B
	BEQ TUR
.IFNZ NDISP
	CMP #$ECRAN,B
	BEQ DIS
.ENDC
.IFNZ NPLOT
	CMP #$TRACEUR,B
	BEQ PLOT
.ENDC
.ENDC
	BR ALSOWH
.IFNZ NDISP
DIS:	TST C
	BEQ 1$
	JMP CTRDIS
1$:	JSR PC,EVAL
	BEQ TUR2
	JMP ASTRDI
.ENDC
TUR:	TST C
	BEQ TUR1
	JSR PC,EVAL
	BEQ TUR2
	JMP CTRTUR
TUR1:	JSR PC,EVAL
	BNE .+4
TUR2:	ERROR+WTAB
	JMP ASSTUR
.IFNZ NPLOT
PLOT:	TST C
	BEQ 1$
	JMP CTRPLT
1$:	JMP ASSTPL
.ENDC
.ENDC

POT:	MOV TOPRNM,B	;SHOW THIS TITLE
	BEQ POL1
	JSR PC,SHTITL
	BNE POL2
	.BUG.

POL:	TST TOPRNM
	BNE .+4
POL1:	ERROR+OIP
	JSR PC,GTLN	;GEN LINE NO. FROM NEXT TOKEN INTO B
	BNE 1$
	ERROR+SHW	;SHOW WHAT??
1$:	JSR PC,GTLP	;GET POINTER TO LINE IN F (WITH BEEF), B WITHOUT
.IFZ BEEF
	JSR PC,.LOADC
	PUSHS B	;FOR PRLN
.IFTF
	JSR PC,PRLN	;PRINT LINE
	PRCR
.IFT
	POPS C
.ENDC
POL2:	SEZ
POL3:	RTS PC

.IFZ LSI
.POFILE:	JSR PC,EVAL
	BNE 1$
	ERROR+UELX
1$:	JMP .POF
.ENDC

.IFZ BEEF
;SHOW (B).  SKIP UNLESS (B) NOT A USER PROC
PSHOW:	JSR PC,SHTITL	;SHOW TITLE LINE, CLZ IF PROC THERE
	BEQ POL3
	BIT #7777,A
	BEQ PSHOW4
	MOV A,C
	PUSHS #0
PSHOW3:	JSR PC,.LOADC
	MOV A,C
	MOV B,@S
	JSR PC,PRLN
	PRCR
	BIT #7777,C
	BNE PSHOW3
	POPS A
PSHOW4:	TST WRTFLG
	BNE 1$		;OUTPUTTING TO FILE, OR PTR, SO PRINT END ALWAYS
	TST TOPRNM
	BNE PSHOW5
1$:	LANGC <PRTXTC ^\END\>,<
	PRTXTC ^/FIN/>
PSHOW5:	CLZ
	RTS PC
.ENDC

.IFNZ BEEF
;PRINT PROC POINTED TO BY B
PSHOW:	JSR PC,SHTITL	;CLZ IF IF PROC EXISTS; RETURNS WITH B POINTING TO ARRAY
			;F POINTS TO THE FIRST LINE
	BEQ PSHOW1	;JUST RETURN
	PUSH 5*2(B)	;PUSH POINTER TO THE END OF PROC
	ADD B,(P)	;MAKE POINTER UNRELATIVE
PSHLIN:	CMP F,(P)	;AT THE END
	BEQ PSHDON	;DONE
	BHI PSHBUG	;ERROR
	JSR PC,PRLN	;PRINT LINE POINTED TO BY F, AND RETURN POINTER TO NEXT LINE IN F
	PRCR		;CARRIAGE RETURN
	BR PSHLIN
PSHDON:	TST (P)+	;POP OFF POINTER TO THE END OF THE FILE
	TST WRTFLG	;WRITING A FILE, OR PAPER TAPE
	BNE 1$		;YES, SO ALWAYS PRINT THE END
	TST TOPRNM	;EDITING A PROCEDURE?
	BNE PSHOW2	;YES, DONT PRINT END
1$:	LANGC <PRTXTC ^\END\>,<
	PRTXTC ^\FIN\>
PSHOW2:	CLZ
PSHOW1:	RTS PC
PSHBUG:	.BUG.
.ENDC

PON:
SHALNA:		;SHOW ALL NAMES
		;USES A-F
	JSR PC,GNOLEI
SHALN1:	JSR PC,GNOLE	;GET NEXT UOE
	BEQ POL2+2
	MOV B,F
	MOV #VBIND,A
	JSR PC,.BINDL
	BEQ SHALN1	;NO THING FOR THIS UOE
	MOV B,C	;SAVE VALUE PTR
	MOV F,B	;GET UOE PTR
	TST WRTFLG
	BEQ SHALN2	;NO
	TST C		;IS VALUE = "UNBOUND"? (0?)
	BEQ SHALN1	;SKIP THIS ATOM
	SPUSH B
LANGC	<PRTXT ^/MAKE "/>,<
	PRTXT ^/RELIE "/>
	SPOP B
	JSR PC,PPNAME	;PRINT THE NAME
	PRTXT ^\ (\
	BR SHALN3
SHALN2:	JSR PC,PRUV	;PRINT THE NAME
LANGC	<PRTXT ^/ IS/>,<
	PRTXT ^/ EST/>
	TST C		;UNBOUND?
	BEQ SHALN5	;YES; JUST SAY SO
SHALN3:	SPACE
	SPUSHS C
	INC NBKTS
	JSR PC,PRS1
	ADD #2,S
	TST WRTFLG
	BEQ SHALN4
	PRTXT ^\ )\
SHALN4:	PRCR
	BR SHALN1

SHALN5:	PRTXT ^/ UNBOUND./
	BR SHALN4

POARR:	JSR PC,GNOLEI
POARR1:	JSR PC,GNOLE	;GET NEXT UOE
.IFZ <ENG&FR>
	BEQ POARR6
	.IFF
	BNE 1$
	JMP POARR6
1$:
.ENDC
	MOV B,F		;PTR TO UOE
	MOV #ABIND,A
	JSR PC,.BINDL	;GET ARRAY BINDING
	BEQ POARR1	;NO BINDING FOUND
	JSR PC,POARR5	;PRINT ARRAY NAME,SIZE,TYPE
	BR POARR1	;LOOK FOR MORE ARRAYS
POARR5:	MOV B,C		;SAVE VALUE PTR
	MOV F,B		;GET UOE PTR
	JSR PC,PPNAME	;PRINT THE NAME
LANGC	<PRTXT ^/ SIZE / >,<
	PRTXT ^/ DIMMENSION />
	MOV C,B	;SAVE VALUE PTR
	PUSH B
	JSR PC,ASIZE2	;PUTS DIMS. OF ARAY IN LIST
	MOV C,B		;PPTR TO LIST
	JSR PC,PRLST	;PRINT IT
	SPACE
	PRTXT ^/ TYPE/
	POP B		;VALUE PTR
	MOV 4(B),B	;TYPE/DIM WORD IN ARRAY HEADER
	BIC #7777,B	;GET THE TYPE
	BEQ POARR2	;TYPE POINTER
	CMP #FNUM,B
	BEQ POARR3	;TYPE FNUM
LANGC	<PRTXT ^/ INTEGER/>,<
	PRTXT ^/ NOMBRE ENTIER/>
	BR POARR4
POARR2:	LANGC	<PRTXT ^/ POINTER/>,<
	PRTXT ^/ POINTEUR/>
	BR POARR4
POARR3:	LANGC	<PRTXT ^/ FLOATING POINT/>,<
	PRTXT ^/ NOMBRE DECIMAL/>
POARR4:	PRCR		;CARRIAGE RETURN
	SEZ
POARR6:	RTS PC
PO1AR:	JSR PC,GTUOEB
	BEQ 1$
	MOV B,F
1$:	MOV #ABIND,A
	JSR PC,.BINDL
.IFZ <ENG&FR>
	BNE POARR5
	ERROR+UDA
	.IFF
	BEQ 2$
	ERROR+UDA
2$:	JMP POARR5
.ENDC

CONTEN:	;MAKE A LIST OF ALL ATOMS THAT HAVE A PROCEDURE
	JSR PC,SLISTB
	JSR PC,GNOLEI
CONTN1:	JSR PC,GNOLE
	BEQ CONTN2	;DONE
.IIF Z BEEF,	JSR PC,BURYQ
.IIF NZ BEEF,	JSR PC,BURYQX	;CHECK TO SEE IF IT IS BURRIED
	BEQ CONTN1
	MOV B,D
	JSR PC,.BINDF	;A PROCEDURE
	BEQ CONTN1	;NOPE
	MOV D,C
	JSR PC,.LOADC	;GET PNAME
	MOV #LSTR,A
	JSR PC,LISTB
	BR CONTN1
CONTN2:	JSR PC,FLISTB
	CLZ
	RTS PC

.IFZ BEEF
SHTITL:		;INPUT - UOE PTR IN B
		;OUTPUT - "SHOWS" TITLE LINE
		;	-A POINTS TO LLP NODE FOR 1ST LINE
		;	- SKIPS UNLESS NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BINDF
	BNE 1$
	JMP RETC
1$:	MOV A,4(P)
LANGC	<PRTXT ^\TO \>,<
	PRTXT ^/POUR />
	MOV 2(P),B
	JSR PC,PPNAME
	MOV 4(P),C
	JSR PC,.LOADC
	MOV A,4(P)	;SAVE PTR TO NEXT NODE
	JSR PC,.LOAD	;#ARGS IN B
	BIT #7777,A	;ANY TOKENS LEFT?
	BEQ SHTI1
	MOV A,C
SHTI2:	SPACE
	JSR PC,.LOADC	;NEXT ARG
	MOV A,C
	JSR PC,PRTAB	;PRINT TOKEN
	BIT #7777,C
	BNE SHTI2
SHTI1:	PRCR
	JMP SRETC
PRLN:	PUSH A	;PRINT PROC LINE ON S
	SPUSH B
	SPUSH C
	SPUSH D
	INC NBKTS	;PRINT OUTER LIST BRACKETS
	BIC #DPQF,FLAGS2	;DO PRINT QUOTE BEFORE STRINGS
	MOV @S,C
	JSR PC,.LOADC	;PRINT LINE #
	MOV A,C
	JSR PC,PRTAB
	BIT #7777,C
	BEQ PRLN3	;DONE
	JSR PC,.LOADC	;CHECK FOR TYPE = SNUM
	MOV A,C	;THIS MEANS 2ND TOKEN IS A CLGN & SHOULDNT PRINT
	BIC #7777,A
	CMP #SNUM,A
	BNE PRLN4
	BR PRLN2
PRLN1:	JSR PC,.LOADC
	MOV A,C
PRLN4:	SPACE
	JSR PC,PRTAB
PRLN2:	BIT #7777,C	;DONE?
	BNE PRLN1	;NO
PRLN3:	DEC NBKTS
	JMP RETD
.ENDC

.IFNZ BEEF
;INPUT - UOE POINTER IN B
;OUTPUT - PRINTS TITLE LINE, OUTPUTS POINTER TO THE FIRST LINE OF PROC IN F, POINTER
;	TO THE PROCEDURE IN B. SEZ IF NO PROCEDURE.
SHTITL:	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BINDF		;GET POINTER TO THE FUNCTION IN B
	BNE 1$			;GOT THE BINDING
	JMP RETC		;JUST RETURN
1$:	MOV B,F			;COPY POINTER INTO F
LANGC	<PRTXT ^\TO \>,<
	PRTXT ^\POUR\>
	MOV 2(P),B		;POINT TO THE ATOM AGAIN
	JSR PC,PPNAME		;PRINT THE NAME OF THE ATOM
	MOV F,2(P)		;GET BACK POINTER TO THE ARRAY INTO B
	ADD #HEADER,F		;POINT TO THE INFO LINE
	ADD (F)+,F		;POINT TO THE VARIABLES LINE
	SPUSH (F)+		;PUSH NUMBER OF BYTES IN THIS LINE
	ADD F,(P)		;MAKE IT POINT TO THE NEXT LINE
	TST (F)+		;SKIP THE NUMBER OF VARIABLES
VARLOP:	CMP F,(P)		;DONE?
	BEQ VARDON		;YES
	SPACE
	MOV (F)+,B		;GET THE POINTER TO THE VARIABLE
	MOV B,A			;COPY IT
	BIC #7777,A		;CLEAR THE POINTER PART
	JSR PC,PRTAB		;PRINT THE TOKEN IN A,,B
	BR VARLOP		;NEXT!!
VARDON:	PRCR			;PRINT CR
	SPOP F			;POP POINTER TO THE NEXT LINE
	JMP SRETC		;RETURN
	
;INPUT - F POINTS TO THE LINE TO PRINT, OUTPUT F POINTING TO THE NEXT LINE
PRLN:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH (F)+		;PUSH NUMBER OF BYTES IN THIS LINE
	ADD F,(P)		;MAKE IT A POINTER TO THE NEXT LINE
	INC NBKTS		;PRINT THE OUTER LIST BRACKETS
	BIC #DPQF,FLAGS2	;ALLOW PRINTING OF QUOTES
	MOV (F)+,B		;THE LINE NUMBER
	MOV #SNUM,A		;PUT THE TYPE INTO A
	JSR PC,PRTAB		;PRINT THE TOKEN IN A,,B
PRLN1:	CMP F,(P)		;DONE?
	BEQ PRLN2		;YES
	SPACE			;TYPE A SPACE
	MOV (F)+,B		;GET THE NEXT TOKEN
	MOV B,A			;COPY IT FOR THE TYPE
	BIC #7777,A		;DELETE THE POINTER PART
	JSR PC,PRTAB		;PRINT THE TOKEN IN B
	BR PRLN1		;NEXT TOKEN
PRLN2:	DEC NBKTS		;FIX IT FOR THE NEXT CALL
	SPOP F			;WELL RESTORE F
	JMP RETD		;AND RETURN
.ENDC
	.STITL TEXT
TEXTT:	;LISTIFY TEXT OF PROC ON (S)
		;OUTPUT ON S
	JSR F,CACSAV
	JSR PC,LISTIT	;LISTIFY THE TITLE
	CLR F	;FOR LISTB
	SPOPS TOPS	;PRESERVE TITLE FROM GC!!!!!
	JSR PC,LISTB	;THE TITLE LINE
	SUB #2,S	;WORK CELL
	BR TEXT2
TEXT1:	JSR PC,.LOADC	;GET NEXT LLP NODE
	MOV A,C	;SAVE PTR TO NEXT ONE
	MOV B,@S	;NPUT TO LISTLN
	JSR PC,LISTLN	;LISTIFY THIS LINE
	JSR PC,LISTB	;ADD TO LIST
TEXT2:	BIT #7777,C
	BNE TEXT1	;NOT DONE YET
	ADD #2,S	;POP WORK CELL
	BR LIL2
LISTIT:	;LISTIFY TITLE LINE OF PROC ON (S)
		;SKIP IF THERE
		;OUTPUT ON S AND IN A,,B.  C POINTS TO LLP NODE FOR 1ST LINE
	JSR F,CACSAV
	JSR PC,GUOEB	;GET UOE PTR FROM S
	BEQ LIT4	;NONE THERE
	MOV B,D	;SAVE UOE PTR
	CLR TOPS
	JSR PC,.BINDF	;GET PROC BINDING
	BEQ LIT4	;NONE THERE
			;RETURNS WITH FIRST NODE OF LLP IN A,,B
	JSR PC,.LOADA	;GET 2ND NODE
	MOV A,4(P)	;SAVE PTR TO 3RD NODE IN SAVED C
	JSR PC,.LOADB	;GET #ARGS NODE
LIT1:	PUSHS A
	JSR PC,LTOK	;LISTIFY THE DUMMY ARGS
	BEQ LIT4	;LOST???
	MOV #LSTR,A	;NOW ADD "TO FOO"
LANGC	<MOV #$TOTO,B>,<
	MOV #$POURX,B>
	JSR PC,GRBAD	;"TO"
	MOV D,B
	JSR PC,.LOADB	;GET PNAME PTR
	MOV @S,A
	MOV A,TOPS
	BIC #170000,A
	BIS #LSTR,A
	BIS #LIST,C
	MOV C,2(P)
	MOV #LIST,(P)
	MOV C,@S
	JSR PC,GRBAD1	;"FOO"
	BR LIL2
LIT4:	ERROR+HNM
LISTLN:	;LISTIFY PROC LINE ON S
		;OUTPUT ON S AND IN A,,B
		;SKIPS UNLESS BAD TOKEN
	JSR F,CACSAV
	MOV @S,C	;GET LLP  IN C
	JSR PC,.LOADC	;GET LINE # NODE
	MOV B,F		;SAVE IT
	MOV A,@S	;SAVE PTR TO REST OF LINE
	MOV A,B
	JSR PC,.LOAD	;GET NEXT TOKEN AND CHECK IF IT IS ALSO SNUM
	BIC #7777,B
	CMP #SNUM,B
	BNE 1$
	MOV A,@S	;IT IS - SKIP OVER IT
1$:	JSR PC,LTOK	;LISTIFY THE REST OF THE TOKENS
	BEQ LIL1		;LOST
	MOV F,B	;NOW ADD LINE # ON FRONT.  GET IT FROM F
	JSR PC,.CSNLS	;CONVERT SNUM TO LSTR
	MOV B,TOPS	;PTR TO LSTR IS IN B - PROTECT FROM G..C.
	MOV @S,A	;PTR TO TOKEN-LISTIFIED
	BIC #170000,A
	BIS #LSTR,A
	JSR PC,GRBAD
	CLR TOPS
	BIS #LIST,C
	MOV C,@S	;OUTPUT ON S
	MOV C,2(P)	;AND IN SAVED A AND B
	MOV #LIST,(P)
LIL2:	JSR F,CACRES
	CLZ
	RTS PC

LIL1:	.BUG.
LTOK:	;LISTIFY TOKEN LIST ON S
		;OUTPUT ON S AND IN A,,B
		;SKIP UNLESS A "BAD" TOKEN IS FOUND
	JSR F,CACSAV
	POPS C	;GET PTR TO TOKEN LIST
	CLR F
	JSR PC,SLISTB
LTOK1:	BIT #7777,C	;ANY TOKENS LEFT
	BEQ LTOKF
	JSR PC,.LOADC	;GET NEXT TOKEN
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	CMP #SNUM,A
	BEQ LTOK1	;IGNORE SNUM'S
	CMP #UFUN,A
	BHI LTOKSF	;MUST BE SFUN OR INFIX
	BEQ LTOKUF	;A USER PROC
	MOV #':,D
	CMP #UVAR,A
	BEQ LTOKCT	;A USER VARIABLE
	MOV #'",D
	CMP #ATOM,A
	BEQ LTOKCT	;A STRING
	BHI LTOKBD
	CMP #LSTR,A
	BNE LTOKAD	;AN INUM OR LIST - OK AS IS
	JSR PC,CONCTL	;AN LSTR, ADD A "
	BR LTOKAD
LTOKBD:	JSR PC,FLISTB	;BAD TOKEN
	POPS A
	BR LIL2
LTOKUF:	JSR PC,.LOAD	;USER PROC
LTOK3:	MOV #LSTR,A
LTOKAD:	JSR PC,LISTB
	BR LTOK1
LTOKSF:	JSR PC,CVSFLS	;CONVERT SYSTEM FUNCTION TO LSTR
	MOV TOPS,B
	BR LTOK3
LTOKCT:	JSR PC,CONCT
	BR LTOK3
LTOKF:	JSR PC,FLISTB
	MOV A,(P)	;SAVED A
	MOV B,2(P)	;SAVED B
LIL3:	BR LIL2
CONCT:	;APPEND CHAR IN D TO BEGINING OF PNAME OF ATOM IN B
		;OUTPUT #LSTR,,PTR IN A,,B
	JSR PC,.LOAD	;GET PNAME PTR
CONCTL:	PUSH C
	MOV B,A
	BIC #170000,A
	BIS #SSTR,A
	MOV D,B
	JSR PC,GRBAD
	MOV C,B
	MOV #LSTR,A
	BIS A,B
	POP C
	MOV B,TOPS
	RTS PC
CVSFLS:	;CONVERT SFUN NAME TO LSTR
		;INPUT - A,,B SFUN OR INFIX TOKEN IN TOPS
		;OUTPUT -  LSTR PTR IN TOPS
	JSR F,CACSAV
	SPUSH PCHR
	JSR PC,BLSTI
	MOV #BLST,PCHR
	JSR PC,PROAB
	JSR PC,BLSTF
	BNE 1$
	.BUG.	;CANT HAVE NO CHARS!!
1$:	POP PCHR
	BR LIL3
	.STITL ILINE & ERSET STUFF
ILINE:	;OUTPUT LAST LINE TYPED IN
	PUSHS ILINEL
	JSR PC,LTOK
	BNE ERRPR2
	.BUG.	;A BAD TOKEN??
ERRPRO:	;OUTPUT NAME OF PROC EXTENT AT LAST ERROR
	MOV NPROCL,B
	BEQ ERRPR1
	JSR PC,.LOAD
	PUSHS B
	CLZ
	RTS PC

ERRPR1:	PUSHS #LSTR
ERRPR2:	RTS PC
ERRLIN:	;OUTPUT LINE # EXTENT AT LAST ERROR
	MOV NLINEL,B
	BR NTOKE1
ERRTOK:	;OUTPUT TOKEN # EXTENT AT LAST ERROR
	MOV NTOKEL,B
NTOKE1:	JMP R1NARG
ERRLOC:	;OUTPUT ADDR OF LAST ERROR
	MOV LASTER,B
	BR NTOKE1
ERRNUM:	;OUTPUT NO. OF LAST ERROR
	MOV ERRPNT,B
	CMP (B)+,(B)+
	MOV (B),B
	BR NTOKE1
ERRNAM:	MOV #4,C	;MAX CHARS
	MOV ERRPNT,B
	JSR PC,BLSTI	;START AN LSTR
ERRNA2:	MOVB (B)+,D	;GET CHAR
	BEQ ERRNA1
	JSR PC,BLST
	SOB C,ERRNA2	;CONTINUE UNLESS DONE
ERRNA1:	JSR PC,BLSTF
	BEQ ERRPR1
	PUSHS TOPS
	CLZ
	RTS PC

ERRBREAK:	;OUTPUT BRAKE(U)
	MOV BRAKEL,B
	BR NTOKE1
ERRSET:	JSR PC,GTUOEB
	BEQ 1$
	ERROR+HNM
1$:	MOV B,ERPROC
	SEZ
	RTS PC
ERRCLE:	CLR ERPROC
ERRC3:	RTS PC
ERNAME:	;ERASE NAME
	JSR PC,GTUOEB
	BEQ ERN2
ERN1:	CMP #UFUN,A	;AN SFUN OR INFIX?
	BGT 1$
	ERROR+ERW
1$:	JSR PC,CVSFLS
	MOV #ATOM,A
	JSR PC,.OBSCH
	BEQ ERRC3
ERN2:	MOV #VBIND,A
	JSR PC,.UNBND
	SEZ
	RTS PC
	.STITLE ERASE
.IFZ BEEF
ERASE:	JSR PC,GTUOEB	;ERASE ...
	BNE ERASE1	;NOT A PROCEDURE
	JSR PC,ERPR
	BEQ ERASER
	SEZ
	RTS PC
ERASER:	ERROR+PNH	;PROCEDURE NOT HERE

ERASE1:	MOV #ERSDISP,A
ERASE2:	CMP (A)+,B
	BNE ERASE4
	JMP @(A)
ERASE4:	TST (A)+
	TST (A)
	BNE ERASE2
ERASE3:	ERROR+ERW	;ERASE WHAT
ERALL:	JSR	PC,ERALPR
	JSR	PC,ERALNA
	JSR PC,ERARAS
	JMP ERTL3
ERL:
ERLINE:	TST TOPRNM
	BNE 1$
	ERROR+OIP
1$:	JSR PC,GTLN	;GET LINE # IN B
	BEQ ERASE3
	NEG B		;SO ADLN WILL ERASE IT
	MOV #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	PUSHS C
	JSR PC,ADLN
	ADD #2,S	;POP S
ERL1:	SEZ
	RTS PC
ERPR:		;ERASE PROCEDURE (B)
	BIC #170000,B
	BIS #UFUN,B
	CMP B,TOPRNM
	BNE 1$
	ERROR+PBE	;PROCEDURE IS BEEN EDITED (UGH!!!)
1$:	MOV #FBIND,A
	JMP .UNBND
ERALPR:		;ERASES ALL PROCEDURES
	TST TOPRNM
	BEQ ERALP2
	MOV TOPRNM,B
	BR ERPR
ERALP2:	JSR PC,GNOLEI
	MOV #FBIND,A
ERALP1:	JSR PC,GNOLE	;GET NEXT UOE
	BEQ ERL1+2
	JSR PC,BURYQ
	BEQ ERALP1
	JSR PC,.UNBND
	BR ERALP1
ERALNA:		;ERASE ALL NAMES
	JSR PC,GNOLEI
ERALN1:	JSR PC,GNOLE
	BEQ ERL1+2
	MOV #VBIND,A
	JSR PC,.UNBND
	BR ERALN1	;EVENTUALLY HAVE TO CHECK FOR SVBIND
.IFZ LSI
ERFI:	JSR PC,EVAL
	BEQ ERINX1
	JMP .DELETE
ERINDX:	JSR PC,EVAL
	BNE .+4
ERINX1:	ERROR+UELX
	JMP .DELI
.ENDC
	.STITL TRACE
EBURY:	BIC #TF6,TFLAGS
BURY1:	MOV #TPBF,D
	BR TRA3

ESTEP:	BIC #TF6,TFLAGS
STEP1:	MOV #TPSF,D
	BR TRA3
ERTR:
ETRACE:	BIC #TF6,TFLAGS
TRA1:	MOV #TPTF,D
TRA3:	JSR PC,GTUOEB
	BNE TRA6
	JSR PC,CSSTF
	BNE TRA11
TRA5:	ERROR+PNH	;PROC NOT HERE
TRA6:	CMP #SFUN,A
	BNE TRA5
	.IFNZ ENG
	CMP #$ALL,B
	BEQ TRA10
	.ENDC
	.IFNZ FR
	CMP #$TOUT,B
	BEQ TRA10
	.ENDC
	ERROR+ERW
TRA10:	JSR PC,GNOLEI
TRA7:	JSR PC,GNOLE
	BEQ TRA9
	CMP #TPBF,D	;UNBURY BURIED PROCS
	BEQ TRA8
	JSR PC,BURYQ	;BUT DON'T TRACE UNTRACE STEP OR UNSTEP THEM.
	BEQ TRA7
TRA8:	JSR PC,CSSTF
	BR TRA7

CSSTF:	JSR PC,.BNDFS
	BEQ TRA9
	MOV B,C	;B POINTS TO LIST OF GOODIES. FIRST IS FLAGS,,#ARGS
	JSR PC,.LDP2
	BIC D,A
	BIT #TF6,TFLAGS
	BEQ TRA2
	BIS D,A
TRA2:	JSR PC,.STP2
	CLZ
TRA9:	RTS PC
TRA11:	SEZ
	RTS PC

BURYQ:	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	BEQ BURYQ1
	JSR PC,.LOADB
	BIT #TPBF,B
	BEQ .+6
BURYQ1:	JMP RETC
	JMP SRETC

TRACE:	BIS #TF6,TFLAGS
	BR TRA1
STEP:	BIS #TF6,TFLAGS
	BR STEP1
BURY:	BIS #TF6,TFLAGS
	BR BURY1
.ENDC

.IFNZ BEEF
ERASE:	JSR PC,GTUOEB		;GET THE PROCEDURE TO ERASE
	BNE ERASE1		;NOT A UOE, MUST BE A SYSTEM WORD
	JSR PC,ERPR		;ERASE THAT PROCEDURE
	BEQ ERASER
	SEZ
	RTS PC
ERASER:	ERROR+PNH		;CAN'T FIND THE STUPID THING
ERASE1:	MOV #ERSDIS,A		;POINT TO THE ERASE DISPATCH TABLE
ERASE2:	CMP (A)+,B		;IS IT THIS WORD?
	BNE 1$			;NO, SKIP THE ADDRESS
	JMP @(A)		;GO DO THAT
1$:	TST (A)+		;PASS THE ADDRESS
	TST (A)			;AT THE END OF THE TABLE?
	BNE ERASE2		;NO
ERASE3:	ERROR+ERW		;ERASE WHAT?

ERALL:	JSR PC,ERALPR		;ERASE ALL THE PROCEDURES
	JSR PC,ERALNA		;ERASE ALL THE NAMES
	JSR PC,ERARAS		;ERASE ALL THE ARRAYS
	JMP ERTL3		;CLEAR OUT THE PDLS

;ERASE LINE
ERL:
ERLINE:	TST TOPRNM		;EDITING A PROCEDURE?
	BNE 1$			;YES
	ERROR+OIP
1$:	JSR PC,GTLN		;GET LINE NUMBER IN B
	BEQ ERASE3		;LOSE LOSE
	NEG B			;TO DELETE THIS LINE
	JSR PC,ADLN		;DO THE DEED
ERLI1:	SEZ
	RTS PC

;ERASE PROCEDURE POINTED TO BY THE ATOM IN B
ERPR:	BIC #170000,B		;CLEAR OUT THE TYPE
	BIS #UFUN,B		;MAKE IT INTO A UFUN
	CMP B,TOPRNM		;IS IT THE PROCEDURE BEING EDITED?
	BNE ERPR2		;NO, ALLOW IT TO HAPPEN
ERPR1:	ERROR+PBE		;PROCEDURE BEING EDITED
ERPR2:	JSR PC,.BINDL		;GET THE BINDING
	BEQ ERLI1		;CAN'T FIND IT, FORGET IT
DELPRO:	TST 4*2(B)		;IS IT REFERENCED ON THE STACK?
	BEQ DELIT			;NO, JUST DELETE IT
	MOV #-PROCAR,2*2(B)	;CHANGE TYPE TO DELETED
	MOV (B),C		;POINTER TO THE 2ND WORD OF BINDING NODE
	BIC #170000,-(C)	;CLEAR OUT THE TYPE OF THE FIRST WORD
	BIS #DBIND,(C)		;SET IN DELETED PROCEDURE BINDING
	RTS PC			;AND RETURN
DELIT:	SPUSH B			;SAVE B
	TST 2*2(B)		;WAS IT DELETED PREVIOUSLY?
	BMI DELHRD		;DELETE IT THE HARD WAY
	MOV 3*2(B),B		;GET POINTER TO THE  BINDING NODES
	MOV #FBIND,A		;DELETE THE FUNCTION BINDING
	JSR PC,.UNBND		;DELETE THE BINDING
DELARR:	SPOP B			;GET BACK POINTER TO THE ARRAY
	JSR PC,.RELES		;RELEASE IT
	CLZ
	RTS PC

DELHRD:	MOV 3*2(B),B		;GET POINTER TO THE  BINDING NODES
	MOV B,C			;THIS IS THE POINTER TO THE PREVIOUS NODE
	MOV B,A			;AND SET UP POINTER TO THE START ALSO
DELOP:	MOV C,D			;GET POINTER TO THE PREVIOUS
 	MOV A,C			;THE NEXT NODE TO LOAD
	JSR PC,.LOADC		;LOAD IT UP
	CMP B,(P)		;IS IT POINTER TO THE SAME ADDRESS?
	BNE DELOP		;NO, TRY TRY AGAIN
	MOV A,B			;WHAT THE NODE POINTS TO 
	BIC #7777,A		;IS IT A DBINDED NODE?
	CMP A,#DBIND		;WELL?
	BEQ 1$			;YES, ALL IS WELL
	MOV B,A			;RESTORE A
	BR DELOP		;AND TRY AGAIN
1$:	MOV D,C			;POINTER TO THE NODE BEFORE THIS
	JSR PC,.LDP1		;GET WHAT IT POINTS TO
	BIC #7777,A		;GET THE TYPE TO PUT ON THE NEW POINTER
	BIC #170000,B		;CLEAR OUT THE POINTER
	BIS B,A			;SET IN THE POINTER INTO THE TYPE
	JSR PC,.STP1		;AND CLOBBER THAT NODE TO POINT TO THE NEXT
	BR DELARR		;NOW DELETE THE ARRAY

;ERASE ALL PROCEDURES
ERALPR:	TST TOPRNM		;ANY BEING EDITED?
	BEQ ERALP1		;NO, CONTINUE
	MOV TOPRNM,B		;GET UOE EDITED INTO B
	BR ERPR1		;TO REPORT THE ERROR
ERALP1:	JSR PC,GNOLEI		;INITIALIZE THE GET NEXT OBLIST ROUTINE
ERALP2:	MOV #FBIND,A		;THE BINDING TO LOOK FOR
	JSR PC,GNOLE		;GET THE NEXT OBLIST ELEMENT
	BEQ ERLI1		;RETURN WHEN WE CANT GET ANY MORE
	JSR PC,BURYQ		;IS IT BURIED?
				;ALSO GETS INDEX TO ARRAY IN B
	BEQ ERALP2		;YES, OR ISN'T A PROCEDURE
	JSR PC,DELPRO		;DELETE THE PROCEDURE, IF AT LEVEL 0, OR FIX
				;IT TO BE DELETED  LATER
	BR ERALP2		;FOR ALL THE PROCEDURES

;ERASE ALL NAMES
ERALNA:	JSR PC,GNOLEI		;INIT GET NEXT OBLIST ELEMENT
ERALN1:	JSR PC,GNOLE		;GET THE NEXT OBLIST ELEMENT
	BEQ ERALN2		;DONE
	MOV #VBIND,A		;DELETE VARIABLE BINDINGS
	JSR PC,.UNBND
	BR ERALN1		;DELETE THEM ALL
ERALN2:	RTS PC

.IFZ LSI
ERFI:	JSR PC,EVAL		;GET THE FILE NAME OR PATH LIST
	BEQ ERINX1		;DIDN'T TELL ME WHAT TO DO
	JMP .DELETE		;FLUSH HIS FILE
ERINDX:	JSR PC,EVAL		;GET THE FILE NAME OR PATH LIST
	BNE ERINX2		;GOT IT
ERINX1:	ERROR+UELX		;UNEXPECTED END OF LINE
ERINX2:	JMP .DELI		;GET ME A BALOGNA ON RYE
.ENDC

BURY:	BIS #TF6,TFLAGS		;SET THE FLAG SAYING WE ARE ENABLING THIS FEATURE
	BR BURY1		;GO DO IT
EBURY:	BIC #TF6,TFLAGS		;CLEAR A FLAG FOR LATER
BURY1:	MOV #TPBF,D		;THE FLAG TO CHANGE
	BR TRACE2		;DO IT

STEP:	BIS #TF6,TFLAGS		;SAY WE ARE TURNING ON STEP
	BR STEP1
ESTEP:	BIC #TF6,TFLAGS		;SAY WE ARE ERASEING THIS FLAG
STEP1:	MOV #TPSF,D		;THE FLAG FOR STEPPING
	BR TRACE2

TRACE:	BIS #TF6,TFLAGS		;SAY WE ARE TRACING
	BR TRACE1
ETRACE:	BIC #TF6,TFLAGS		;CLEAR THE TRACE
TRACE1:	MOV #TPTF,D		;THE TRACE FLAG
TRACE2:	JSR PC,GTUOEB		;GET THE OBLIST ELEMENT INTO B
	BNE TRCSYS		;WASN'T USERS PROC, GET A SYSTEM WORD
	JSR PC,CSSTF		;SET THE CORRECT FLAG FOR PROC IN B
	BNE TRCDON		;DONE WITH THIS
TRAERR:	ERROR+PNH		;NO PROCEDURE TO DO THIS WITH
TRCSYS:	CMP #SFUN,A		;IS IT A SYSTEM FUNCTION
	BNE TRAERR		;NOPE
.IFNZ ENG
	CMP #$ALL,B		;IS IT TRACE ALL?
	BEQ TRCALL		;YES
.ENDC
.IFNZ FR
	CMP #$TOUT,B		;IS IT TRACE TOUT?
	BEQ TRCALL		;YES
.ENDC
	ERROR+ERW		;TRACE WHAT?????
TRCALL:	JSR PC,GNOLEI		;INIT GET NEXT USER OBLIST ELEMENT
TRCAL1:	JSR PC,GNOLE		;GET THE NEXT ELEMENT
	BEQ TRCDON		;FINISHED
	CMP #TPBF,D		;IS IT AN ERASE BURY?
	BEQ TRCAL3		;YES, DO IT REGARDLESS, ELSE IF PROC'S ARE BURRIED, DONT
				;TOUCH THEM
	JSR PC,BURYQ		;IS IT BURIED?
	BEQ TRCAL1		;YES, DONT TOUCH THEM
TRCAL2:	JSR PC,CSSTF1		;SET OR CLEAR THE APPROPRIATE FLAG
	BR TRCAL1		;NEXT!!
TRCAL3:	JSR PC,CSSTF		;CLEAR THE BURY FLAG
	BR TRCAL1
TRCDON:	SEZ
	RTS PC

;THIS ENTRY SETS OR CLEARS A FLAG IN D, ACCORDING TO TF6, PROC POINTED TO BY UOE IN B
;CSSTF1 DOES THE SAME, EXCEPT WITH POINTER TO PROC IN B
CSSTF:	JSR PC,.BINDF		;GET THE FUNCTION BINDING IN B
	BEQ TRCDON		;FAILED MISERABLY
CSSTF1:	MOV B,A			;GET POINER TO ARRAY INTO A
	ADD #HEADER+2,A		;POINT TO THE FLAGS FOR THIS PROC
	BIC D,(A)		;CLEAR THE FLAG
	BIT #TF6,TFLAGS		;BUT DID WE WANT TO SET IT?
	BEQ 1$			;NO, FINE
	BIS D,(A)		;WELL SET IT AFTER ALL
1$:	CLZ
	RTS PC

;THIS RETURNS WITH Z SET IF THE PROCEDURE IS BURRIED, B GETS CLOBBERED TO POINT TO THE
;ARRAY'S ADDRESS
BURYQ:	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BINDF		;GET THE BINDING IF IT EXISTS
	BEQ BURYQ1		;NO PROCEDURE
	MOV B,2(P)		;RETURN THIS POINTER
BURYQ3:	BIT #TPBF,HEADER+2(B)	;IS THE BURY BIT ON?
	BEQ BURYQ2		;NO, RETURN WITH Z CLEARED
BURYQ1:	JMP RETC
BURYQ2:	JMP SRETC

BURYQX:	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BINDF		;GET THE BINDING
	BEQ BURYQ1		;NO PROCEDURE
	BR BURYQ3		;OTHERWISE DO A PROBLEM
.ENDC

STRACS:	BIT #TRACEF,FLAGS2
	BEQ STRA2
	SPACE
	BR STRA1
STRACE:	BIT #TRACEF,FLAGS2	;SYSTEM TRACE
	BEQ STRA2
STRA1:	INC NBKTS
	PUSH A
	PRTXT ^/CT=/
	BIC #DPQF,FLAGS2
	JSR PC,PRCT
	PRTXT ^/ CO=/
	JSR PC,PRCO
	PRTXT ^/ S=/
	BIC #DPQF,FLAGS2
	JSR PC,PRS1
	PRCR
	CLR NBKTS
	POP A
STRA2:	RTS PC

SETSTF:	BIS #TRACEF,FLAGS2	;SET SYSTEM TRACE FLAG
	SEZ
	RTS PC

CLRSTF:	BIC #TRACEF,FLAGS2
	SEZ
	RTS PC

FLEV:	MOV FUNLEV,B	;RETURN USER PROC CALL DEPTH
FLEV1:	JMP R1NARG
NODES:	;OUTPUT NO. OF NODES IN FREE STG LIST
	MOV NNIFSL,B
	BR FLEV1
.STITL	UTILITY ROUTINES

GOODBYE:
LANGC	<CPRTXT ^/AND A PLEASANT DAY TO YOU!/>,<
	CPRTXT ^/BONNE JOURNEE/>
.IFZ LSI
	IOT
.IFF
	JMP START1
.IFT
	CPRTXT ^/YOU BACK AGAIN???/
	BR CR2
.ENDC
VERSN:	MOV LVERNF,B
	BR	RANDO1
RANDOM:
	MOV RNSEED,B	;GET OLD SEED
	MUL #71275,B	;MUL SEED BY GOOD NUMBER!!
	ADD #13713,B	;ADD ANOTHER GOOD NUMBER!! TO LOW ORDER PART
	MOV B,RNSEED	;THIS IS THE NEW SEED
	MOV B,A
	MUL #10.,A	;MULTIPLY IT BY 10
	MOV A,B		;HIGH-ORDER PART IS THE DESIRED DIGIT
	ADD #5,B
RANDO1:	JMP R1NARG
BELL:	MOV #7,B
	JMP CTYO1	
CR:	MOV #1,D
CR1:	JSR PC,TYO
CR2:	SEZ
	RTS PC
DEBUG:	TST ALEVN
	BEQ DEBUG1
	PRTXTC ^\OFF\
	CLR ALEVN
	JMP TOPLEVEL
DEBUG1:	PRTXTC ^\ON\
	MOV #1,ALEVN
DEBUG2:	BR CR2
SGCF:	JSR PC,CKSST
	BIS #MGCF,FLAGS2
	SEZ
	RTS PC
CGCF:	JSR PC,CKSST
	BIC #MGCF,FLAGS2
	SEZ
	RTS PC
STATUS:	BIT #SSF,FLAGS2
	BNE	STATU2	;IF ON TURN OFF
	JSR PC,TINECH
	JSR PC,RDSTR	;READ A STRING
	BEQ	STATU2	;EMPTY OR BREAK
	MOV @S,B	;SEE IF EQUAL TO "SECRET
	MOV #SECRET,C
	JSR PC,EQ.TXT
	BEQ STATU1	;NOPE
	BIS #SSF,FLAGS2	;YES
	POPS A	;POINTER TO STRING READ IN
	PRTXTC	^\ON\
	BR	STATU3
STATU1:	POPS	A
STATU2:	PRTXTC	^\OFF\
	BIC	#SSF,FLAGS2
STATU3:	JMP	SETTTY

CKSST:	TST DEBSW
	BNE CKSST1
	BIT #SSF,FLAGS2
	BEQ .+4
CKSST1:	RTS PC
	ERROR+HNM1

SPNF:	BIS #PNNLF,FLAGS2
	BR CR2
CPNF:	BIC #PNNLF,FLAGS2	;CLEAR IT
	BR CR2

COMT:	.BUG.		;GNT SHOULD SWALLOW ALL COMMENTS;
	.STITL ERRORS AND HANDLER
.IFZ BEEF
EMTBK:	MOV #SRET,(P)	;FAKE IT OUT
	RTT
ERRBRK:ERRBK:	LDFPS #40300
	PUSH A
ERBK2:	TST REDFLG
	BEQ ERBK3	;FINISH UP PENDING PROC DEF
	CLR FILFLG
	TST TOPRNM
	BEQ ERBK3
	JSR PC,END
ERBK3:	CLR GCPREV	;HMMMMM, IS THIS A GOOD PLACE?
.IIF Z LSI,	JSR PC,DELTMP
	TST TOPRNM	;DEFINING PROCEDURE
	BEQ 1$		;NO
	MOV #'>,PRMTCH	;PROMPT WITH THE RIGHT THING
	BR 2$
1$:	MOV #'?,PRMTCH	;PROMPT WITH ?
2$:	JSR PC,RESTTY
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	MOV 2(P),A
	MOV A,LASTER
.IFNZ TS
	SUB #2,A
	SPUSH B
	SPUSH C
	MOV A,C		;ADDRESS IN I SPACE
	ASH #-13.,C	;PAGE IN I SPACE
	BIC #177770,C	;WHAT WE WANT IS A LSH (OR A BOTTLE OF BOOZE)
	SPUSH #7*400+0
	SPUSH C
	SPUSH #<10+HAKPG>*400+1
	SPUSH #.CRRD+1
	$MAP
	MOV A,B
	BIC #160000,B
	ADD #HAKAD,B
	MOV (B),A
	SPOP C
	SPOP B
.IFF
	SUB #2,A
	MOV (A),A
.ENDC
	BIC #177400,A
	MOV A,ERRORN
	ASL A
	MOV ERTAB(A),ERRPNT
	MOV ERRORN,A
ERBK4:	CLR NTOKEL
	CLR NLINEL
	MOV CPP,NPROCL
	BEQ ERBK5
	MOV CPLN,NLINEL
	MOV CTN,NTOKEL
ERBK5:	CMP A,#BUG	;DONT ALLOW ERRSET FOR .BUG. OR FBUG
	BEQ ERSET3
	CMP A,#FBUG
	BEQ ERSET3
	TST ERPROC	;ERROR SET ON?
	BEQ ERSET2
	JSR F,CACSAV
	PUSH CO
	SPUSH CO+2
	SPUSH NOR
	SPUSH BRAKE
	CLR BRAKE
	MOV (P),BRAKEL
;FALLS THROUGH
;FALLS IN
	SPUSH ERPROC
	MOV ERPROC,CO+2
	CLR ERPROC
	JSR PC,SAVPPS	;YES - SAVE THE PDLS
	BIS #1,CSPDLP	;INDICATE ERRORSET PUSH
	BIS #1,CPDLP
	MOV #UFUN,CO
	CLR NOR
	BIC #DORF,FLAGS	;NOTE THAT THIS IS NOT A RUN FRAME
	JSR PC,PEVAL
	BEQ ERSET1	;DIDNT OUTPUT
	JSR PC,PRS1	;DID OUTPUT, PRINT IT
	JSR PC,RESPPS
	POP ERPROC
	JMP ERTLN	;THEN ERROR RETURN
ERSET1:		;DIDNT OUTPUT, DO WHAT U WERE GOING TO
	JSR PC,RESPPS
	POP ERPROC
	SPOP BRAKE
	SPOP NOR
	SPOP CO+2
	SPOP CO
	JSR F,CACRES
ERSET2:	TST NOADDR
	BNE NEWER4
ERSET3:	MOV 2(P),A
	JSR PC,PRONL	;PRINT ADDR WHERE ERROR OCCURED
	SPACE
NEWER4:	MOV ERRPNT,ERRPT
	ADD #6,ERRPT
	.IFNZ ENG&FR
	BIT #FRFLG,LANG
	BEQ NEWER1
	INC ERRPT
	TSTB @ERRPT
	BNE .-10
	INC ERRPT
	.ENDC
NEWER1:	MOVB @ERRPT,D
	BEQ ERTLN
	BGT NEWER2
	BIC #177600,D
	ASL D
	MOV ROTTAB(D),A
	INC NBKTS
	JSR PC,(A)
NEWER3:	INC ERRPT
	BR NEWER1
NEWER2:	JSR PC,TYO
	BR NEWER3
ERRRT:	POP A
	RTT

PPLACE:	MOV FUNLEV,A
	BEQ PPLAC1
.IIF NZ AI,BR PPLAC1		;WE DON'T WANT IT GUY CAN HAVE IT...
LANGC	<CPRTXT ^\AT LEVEL \>,<
	CPRTXT ^/AU NIVEAU />
	JSR PC,PRDN
LANGC	<PRTXT ^\  LINE \>,<
	PRTXT ^/ LIGNE />
	MOV CPLN,A
	JSR PC,PRDN
LANGC	<PRTXT ^\  IN \>,<
	PRTXT ^/ DE />
	MOV CPP,B
	JSR PC,PPNAME
PPLAC1:	JMP .CRLF

ERTLN:			;ERR RETURN TO LEVEL N
	TST ALEVN
	BEQ ERTL0
ERPO1:	JSR PC,RRPOP
	BIS #ERRF+BRKF,FLAGS
	CLR BRAKE
ERTLN1:	JSR PC,PPLACE
	JMP MLOOP
ERTL0:			;ERR RETURN TO LEVEL 0
	CLR	BRAKE
ERTL01:	JSR PC,RRPOP
	JSR PC,PPLACE

TOPLEVEL:
ERTL2:	TST FUNLEV	;POP UP TO LEVEL 0
	BLE ERTL3
	MOV #ERTL2,PSTOPR
ERTL4:	MOV #PSTP15,A
	MOV A,ERFRET	;SET UP ERROR FRAME RETURN
	MOV A,DOFRET
	JMP (A)
ERTL3:	CLR A	;CLEAR OUT PDLS
	JSR PC,PPTA
	CLR A
	JSR PC,PSTA
	CLR CSPDLP
	CLR CPDLP
	MOV #ERCLR1,A
	MOV #<ERCLR2-ERCLR1>/2,B
	CLR (A)+
	SOB B,.-2
	BIC #EDTIF+ERRF+BRKF,FLAGS
	JMP MLOOP
.ERPOP:	PRTXT ^\ERPOP TO\
	TST FUNLEV
	BLE ERTL3
	MOV #ERPO1,PSTOPR
	BR ERTL4

	;POP RUN AND READ FRAMES
RRPOP:	SPOP C	;SAVE RETURN ADDR
ERTLN2:		BIT #DORF,FLAGS
	BEQ ERTLN4
ERTLN3:	JSR PC,RESPPS
	SPOP B
	BIT #TF7,TFLAGS
	BEQ ERTN32
	MOV B,ERPROC
	BR ERTLN3
ERTN32:	JSR PC,RESEVL
	MOV B,FLAGS
	BR ERTLN2
ERTLN4:	JMP (C)

	.STITL ERROR ROUTINES
		; ****  THESE ARE NOW ALPHABETIZED   *****

.IIF NDF MAXELN,MAXELN==0

FBUGB:	BPT		;BREAK HERE ON FATAL BUG
	JMP TOPLEVEL	;TRY TO RECOVER

BRK.R:	MOV BRAKE,A
	CLR BRAKE
;	JSR PC,BRAKR
	TST A
	BLT PAUSE
BRK.2:
.IIF Z LSI,	JSR	PC,BRKMOF	;TURN OFF MUSIC BOX IF HE HAS IT
LANGC	<PRTXT ^\STOPPED!!\>,<
	PRTXT ^/ARRET/>
	JMP ERTL01

PAUSE:	BIS #BRKF,FLAGS
	SPUSH	MUCWRD	;SO THAT CONTINUE WILL WORK (GROAN)
.IIF Z LSI,	JSR	PC,BRKMOF	;TURN OFF MUSIC BOX IF HE HAS IT
	SPOP	MUCWRD
	PRTXT ^\PAUSE \
	JMP ERTLN1

BUG.R:
BUG.1:	PRTXT ^/HELP!!!  SYSTEM BUG VER=/
	MOV #VERNF,A
	JSR PC,PRDN
	JSR PC,.SPACE
	SPOP A
	TST	DEBSW
	BEQ	.+4
BUGBPT:	BPT	;BRK IF IN DEBUG MODE
	MOV 6(P),A
	JSR PC,PRONL
	JMP ERTLN

CTIT.R:	MOV TOPRNM,B
	JMP PPNAME

HNM.R:	MOV B,A
	BIC #7777,A	;GET THE TYPE
	BIS #DPQF,FLAGS2	;DONT PRINT "
	CMP A,#UFUN	;USER FUNCTION?
	BLOS 1$		;SYSTEM FUNCTION, OR USER FUNCTION
	JMP PRPNM1	;OTHER
1$:	JMP PROAB	;PRINT THE SYSTEM OR USER FUNCTION

LDE1.R:	MOV JPLN,CPLN	;MAKE JUMPED-FROM LINE = POINT OF ERROR
WTIB.R:	MOV B,A
	JMP PRDN	;LINE # SHOULD BE IN A

TDE.R:	MOV	E,A
	JMP	PRDN

PAE.R:	MOV #UFUN,A
	MOV TEMP,B
	RTS PC

PNH1.R:	MOV CPP,B
	MOV #UFUN,A
	RTS PC

TMAP.R:	TST (P)+
	JMP ERRRT

WTA.R:	RTS PC

WTAA.R:	PUSHS A
	RTS PC

WTAB.R:	PUSHS B
	RTS PC
.ENDC

.IFNZ BEEF
EMTBRK:	MOV #SRET,(P)		;PRETEND TO FAKE SOMETHING OUT
	RTT
ERRBRK:
ERRBK:	JSR F,CACSAV		;SAVE THE AC'S
	TST REDFLG		;READING?
	BEQ ERRBK1		;NO
	CLR FILFLG		;NO LONGER INPUTTING FROM FILE
	TST TOPRNM		;STILL DEFINING A PROCEDURE?
	BEQ ERRBK1		;NOPE
	JSR PC,END		;WELL, FINISH IT UP
ERRBK1:
.IIF Z LSI,	JSR PC,DELTMP	;DELETE THE CAPABILITY TO THE FILE
	TST TOPRNM		;DEFINING PROC?
	BEQ 1$			;NO
	MOV #'>,PRMTCH		;PROMPT WITH ">"
	BR 2$
1$:	MOV #'?,PRMTCH		;PROMPT WITH A "?"
2$:	JSR PC,RESTTY		;RESTORE THE TTY STATUS
	MOV #TYI,GCHR		;GET CHARACTERS FROM THE TTY NOW
	MOV #TYO,PCHR		;AND PRINT TO THE TTY
	MOV 6*2(P),A		;GET THE TRAP ADDRESS
	MOV A,LASTER		;AND SAVE IT
	SUB #2,A		;POINT TO THE TRAPPING CALL

.IFNZ TS			;THIS IS NECCESSARY BECAUSE MFPI DOESN'T WORK IN USER MODE
	SPUSH B
	SPUSH C
	MOV A,C			;ADDRESS IN I SPACE OF TRAP
	ASH #-13.,C		;GET THE PAGE NUMBER OF TRAP
	BIC #177770,C		;WHAT WE WANTED IS A LSH (OR A BOTTLE OF BOOZE)
	SPUSH #7*400		;ASK FOR THE WHOLE PAGE
	SPUSH C			;THE PAGE NUMBER
	SPUSH #<10+HAKPG>*400+1	;MAP IT INTO OUR HACK PAGE
	SPUSH #.CRRD+1		;READ ONLY ACCESS
	$MAP			;MAP IT IN
	MOV A,B			;THE ADDRESS IN I SPACE
	BIC #160000,B		;GET THE OFFSET INTO THE PAGE
	ADD #HAKAD,B		;RELOCATE IT INTO THE HACK PAGE
	MOV (B),A		;GET THE TRAP INSTRUCTION
	SPOP C
	SPOP B
.IFF
	MOV (A),A		;NOW WASN'T THAT MUCH SIMPLER?
.ENDC
	BIC #177400,A		;GET THE TRAP CODE
	MOV A,ERRORN		;SAVE THE ERROR NUMBER
	ASL A			;TURN IT INTO AN INDEX
	MOV ERTAB(A),ERRPNT	;GET THE POINTER TO THE ERROR MESSAGE
	CLR NLINEL		;NO ERROR LINE YET
	CLR NPROCL		;CLEAR THE PROCEDURE ALSO
	TST FUNLEV		;IN A PROCEDURE?
	BEQ 3$			;NOPE
	MOV CPP,NPROCL		;THE ERROR PROCEDURE
	MOV CPLN,NLINEL		;SAVE THE LINE ERROR CAME FROM
3$:	TST ERPROC		;ERROR SET?
	BEQ ERRNOT		;NOPE
	CMP A,#BUG*2		;IS IT BUG?
	BEQ ERRNOT		;YES, DONT ALLOW ERRSET
	CMP A,#FBUG*2		;SAME WITH FBUG?
	BEQ ERRNOT
	JSR PC,SAVEVL		;SAVE THE STATE OF THE WORLD
	PUSH #0			;MAKE IT LOOK LIKE A PROCEDURE CALL
	JSR PC,SAVPPS		;AND SAVE THE PDLS
	BIS #1,CPDLP		;SAY PROCEDURE PUSH
	BIS #1,CSPDLP		;SAY AND ERRORSET PUSH (NOT NEEDED I THINK)
	BIC #DORF,FLAGS		;NOT A DO OR READ FRAME
	BIS #ERRF,FLAGS		;SAY WE HAVE AN ERROR!!!!
	MOV ERPROC,CO		;MAKE IT THE CURRENT PROCEDURE
	CLR ERPROC		;DONT ALLOW THIS TO BE ERRSET YET
	JSR PC,PEVAL		;EVALUTATE THE PROCEDURE
	BEQ ERRNT1		;NO OUTPUT, JUST DO WHAT WE WERE GOING TO
	JSR PC,PRS1		;PRINT THE OUTPUT
	JSR PC,RESPPS		;RESTORE PDLS
	TST (P)+		;POP NUMBER OF ARGS
	JSR PC,RESEVL		;AND RESTORE EVAL
	MOV B,FLAGS		;PUT BACK THE FLAGS
	BR DEBUGL		;POP OFF EVERYTHING, AND RETURN
ERRNT1:	JSR PC,RESPPS		;RESTORE THE PDLS
	TST (P)+		;POP OFF NUMBER OF ARGS
	JSR PC,RESEVL		;AND GET BACK EVAL...
	MOV B,FLAGS		;RESTORE THE FLAGS
ERRNOT:	TST NOADDR		;ANY PRINT OCTAL ADDRESS?
	BNE ERNOT1		;NO
ERPOCT:	MOV LASTER,A		;GET THE ERROR ADDRESS
	JSR PC,PRONL		;AND PRINT IT
	SPACE			;WITH A SPACE
ERNOT1:	JSR F,CACRES		;RESTORE THE AC'S
	MOV ERRPNT,ERRPT	;GET THE ERROR MESSAGE POINTER
	ADD #6,ERRPT		;POINT TO THE START OF THE ERROR MESSAGE
.IFNZ ENG&FR
	BIT #FRFLG,LANG		;IN FRENCH?
	BEQ ERPRLP		;NO
	INC ERRPT		;LOOK BACKWARDS FOR THE FIRST ZERO BYTE
1$:	TSTB @ERRPT
	BNE 1$
	INC ERRPT		;WE HAVE BACKED UP OVER THE FRENCH ERROR, NOW PRINT IT
.ENDC
ERPRLP:	MOVB @ERRPT,D		;GET THE NEXT BYTE OF ERROR MESSAGE
	INC ERRPT		;POINT TO THE NEXT BYTE
	TST D
	BEQ DEBUGL		;DONE PRINTING, DO THE RIGHT THING NOW
	BLT ERPRL1		;IS A CONTROL BYTE FOR A ROUTINE TO RUN
	JSR PC,TYO		;OUTPUT THE CHARACTER
	BR ERPRLP		;AND LOOP BACK
ERPRL1:	BIC #177600,D		;IT IS THE WORD OFFSET INTO A TABLE, CLEAR THE SIGN EXTEND
	ASL D			;INTO A WORD OFFSET
	MOV ROTTAB(D),A		;THE ROUTINE TABLE
	INC NBKTS		;PRINT BRACKETS
	JSR PC,(A)		;CALL THE ROUTINE
	BR ERPRLP		;AND ADVANCE THE POINTER

PPLACE:	MOV FUNLEV,A		;GET THE LEVEL DEEP
	BEQ PPLAC1		;DONT PRINT IT AT TOP LEVEL
LANGC	<CPRTXT ^\AT LEVEL \>,<
	CPRTXT ^\AU NIVEAU \>
	JSR PC,PRDN		;PRINT THE LEVEL
LANGC	<PRTXT ^\ LINE \>,<
	PRTXT ^\ LIGNE \>
	MOV CPLN,A		;GET THE CURRENT LINE NUMBER
	JSR PC,PRDN		;AND PRINT IT
LANGC	<PRTXT ^\ IN \>,<
	PRTXT ^\ DE \>
	MOV CPP,B		;THE CURRENT PROCEDURE NAME
	JSR PC,PPNAME		;AND PRINT IT
PPLAC1:	JMP .CRLF		;AND PRINT CR-LF

DEBUGL:	JSR PC,PPLACE		;PRINT THE PLACE
	CLR BRAKE		;NO BREAK
	TST ALEVN		;SHOULD WE REALLY ENTER A BREAK LOOP?
	BEQ TOPLEVEL		;NOPE, POP AWAY JOE!!
DBUGL1:	TST FUNLEV		;TOP LEVEL?
	BEQ TOPLEVEL		;YES, JUST FORGET IT
	JSR PC,SAVEVL		;SAVE EVAL (AGAIN)
	PUSH #0			;OH WELL, PUSH NUMBER OF ARGS
	JSR PC,SAVPPS		;SAVE THE PDLS AGAIN
	BIS #1,CPDLP		;SAY THIS IS A PROCEDURE PUSH
	BIC #DORF,FLAGS		;NOT DO OR READ FRAME
	BIS #ERRF!BRKF,FLAGS	;SAY ERROR, AND BREAK LOOP
	JMP MLOOP		;OH WELL, GIVE HIM THE TTY!!!

TOPLEVEL:
	TST FUNLEV		;IN A PROCEDURE?
	BEQ 1$			;NO, JUST CLEAN UP OTHER RANDOM FRAMES
	MOV #TOPLEVEL,PSTOPR	;KEEP GOING TO TOPLEVEL
	JMP PSTOP1		;AND STOP THIS PROCEDURE
1$:	BIT #DORF,FLAGS		;IN A DO OR READ FRAME?
	BEQ ERTL3		;NO, MUST BE AT TOP LEVEL NOW
	MOV #1$,DOFRET		;THE PLACE TO RETURN TO
	JMP POPVAR		;AND POP THIS FRAME
ERTL3:	CLR A			;CLEAR OUT THE PDLS
	JSR PC,PPTA		;POP THE P TO THE BASE OF THE STACK
	CLR A
	JSR PC,PSTA		;POP THE S PDL TO THE BASE OF THE STACK
	CLR CSPDLP		;NO PDL OFFSETS
	CLR CPDLP
	MOV #ERCLR1,A		;THE START OF THE AREA TO CLEAR
	MOV #<ERCLR2-ERCLR1>/2,B	;THE LENGTH IN WORDS OF THE AREA TO CLEAR
3$:	CLR (A)+		;CLEAR IT OUT
	SOB B,3$
	BIC #EDITF+ERRF+BRKF,FLAGS	;CLEAR ALL SORTS OF RANDOM FLAGS
	JMP MLOOP		;AND GO TO TOP LEVEL

FBUGB:	BPT			;BREAK ON A FATAL BUG
	JMP TOPLEVEL		;TRY TO RECOVER

BRK.R:	MOV BRAKE,A		;THE BREAK FLAG
	CLR BRAKE		;CLEAR IT
	SPUSH MUCWRD		;SAVE THE MUSIC STATUS WORD
.IIF Z LSI,	JSR PC,BRKMOF	;TURN OFF THE MUSIC BOX IF HE HAS IT
	SPOP MUCWRD		;AND RESTORE IT
	TST A			;IS IT CONTROL-Z?
	BLT PAUS.R		;YES
LANGC	<PRTXT ^\STOPPED!!\>,<
	PRTXT ^\ARRET\>
	JMP DEBUGL		;GO EITHER RETURN TO TOPLEVEL, OR ENTER BREAK LOOP

PAUSE:
PAUS.R:	PRTXT ^\PAUSE\
	JSR PC,PPLACE		;PRINT THE PLACE
	JMP DBUGL1		;AND ENTER BREAK LOOP

BUG.R:	PRTXT ^\HELP!!! LOGO BUG VERSION #\
	MOV #VERNF,A		;GET THE VERSION NUMBER
	JSR PC,PRDN		;PRINT IT
	SPACE			;PRINT A SPACE
	TST DEBSW		;BEING DEBUGGED?
	BEQ .+4			;NO
BUGBPT:	BPT
	MOV LASTER,A		;GET THE ADDRESS
	JSR PC,PRONL		;PRINT IT
	JMP DEBUGL		;AND ENTER DEBUG LOOP

CTIT.R:	MOV TOPRNM,B		;GET THE PROCEDURE NAME
	JMP PPNAME		;AND PRINT IT

HNM.R:	MOV B,A			;THE THING THAT HAS NO MEANING
	BIC #7777,A		;GET THE TYPE
	BIS #DPQF,FLAGS2	;DONT PRINT " FOR AN ATOM
	CMP A,#UFUN		;USER FUNCTION OR SYSTEM FUNCTION
	BLOS 1$			;YES
	JMP PRPNM1		;PRINT THE OTHER
1$:	JMP PROAB		;PRINT THE NAME OF THE FUCTION

LDE1.R:	MOV JPLN,CPLN		;MAKE THE JUMPED FROM LINE THE LINE OF THE ERROR
WTIB.R:	MOV B,A			;LINE NUMBER SHOULD BE IN A
	JMP PRDN		;AND PRINT IT

TDE.R:	MOV E,A			;TERMINAL NUMBER
	JMP PRDN		;PRINT THE NUMBER

PAE.R:	MOV #UFUN,A		;THE TYPE
	MOV TEMP,B		;THE NAME OF THE PROCEDURE
	RTS PC			;AND RETURN

PNH1.R:	MOV CPP,B		;THE POINTER TO THE PROCEDURE NAME
	MOV #UFUN,A		;THE TYPE TO PRINT
	RTS PC

TMAP.R:	TST (P)+		;POP OFF THE RETURN ADDRESS
	BPT			;HERE POP OFF THE EVAL FRAME, AND RETURN

WTA.R:	RTS PC

WTAA.R:	PUSHS A			;PUSH THE OUTPUT
	RTS PC

WTAB.R:	PUSHS B			;PUSH IT ALSO
	RTS PC
.ENDC

	.STITL TURTLE,DISPLAY, RANDOM DEVICES, AND OTHER CRAP


;CONVERT ADDRESS TO DISPLAY PUSHJ
;ARGUMENT IS AC
.MACR MAKEPJ F
	ASR F
	ADD DRELOC,F
	BIS #DPUSHJ,F
.ENDM

;CONVERT DISPLAY CONTROLLER ADDRESSES TO REAL WORLD ADDRESSES
;	ARG IS AC
.MACR MAKEAD F
	SUB DRELOC,F
	ASL F
.ENDM
.IFZ LSI	;LSICOND, EXTENDS TILL MUSIC PRIMITIVES

MUWAIT:
TBTW:	ERROR+SIT
	.STITL RANDOM DEVICE CONTROL

.IFNZ AI

ATOD:	ERROR+SIT
.IFZ 105
	JSR PC,G1NARG
	TST B		;IS B NEGATIVE
	BLT ATODLS	;YES, SO NO GOOD
	CMP #7,B	;IS B TOO BIG A CHANNEL NO.?
	BLT ATODLS	;YES ITS BIGGER THEN 7
	ASH #10.,B
	MOV B,ATODB
	TST ATODB
	BPL .-4
	MOV ATODB,B
	BIC #176000,B
	SUB #1000,B
	JMP R1NARG
ATODLS:	ERROR+WTA	;HERE FOR BAD ARG TO ATOD
.ENDC


BITOUT:	ERROR+SIT
.IFZ 105
	JSR PC,G1NARG
	MOV B,DIGO
BITOU1:	SEZ
	RTS PC
.ENDC
RELAY:	ERROR+SIT
.IFZ 105
	JSR PC,G1NARG
	MOV B,F
	JSR PC,G1NARG
	MOV #1,C
	ASH B,C
	TST F
	BEQ RELAY1
	BIS C,DIGO
	BR BITOU1
RELAY1:	BIC C,DIGO
	BR BITOUT

.ENDC
DEVICE==160106	;THE ADDRESS OF THE BUFFER REGISTER
DEVADD==160104	;THE SELECTOR REGISTER

BOXIN:	JSR PC,G1NARG
	JSR PC,RDBOX	;READ THE BOX
	JMP R1NARG

SWITCH:	JSR PC,G2NARG
	CMP A,#15
	BGT SWTWTA
	TST A
	BLT SWTWTA
	JSR PC,RDBOX	;BOX NUMBER IN B, RETURNS THE BOX IN B
	MOV #1,C	;GET THE BIT
	ASH A,C		;SHIFT THE BIT THE NUMBER OF THE SWITCH
	BIT C,B		;IS THE BIT SET
	BNE 1$		;YES
	JMP RTFALS	;RETURN FALS
1$:	JMP RTTRUE	;RETURN TRUE

RDBOX:	ERROR+SIT
SWTWTA:	ERROR+SIT
.IFZ 105
	TST B		;IS IT NEGATIVE
	BGE .+4
SWTWTA:	ERROR+WTA	;BAD ARG
	CMP B,#3	;TO LARGE BOX NO.
	BGT SWTWTA
	ASH #10.,B	;THE NUMBER IS SHIFTED 10 PLACES
	MOV B,DEVADD	;TELL IT WHICH BOX TO READ
	CLR DEVICE	;TELL IT TO GO
	TST DEVICE	;DATA IN YET
	BPL .-4		;NOT YET
	MOV DEVICE,B	;GET THE DATA INTO B
	COM B		;THE BITS ARE COMPLEMENTED
	RTS PC
.ENDC
.ENDC
;ROUTINE FOR THE EYETURTLE.  WE WANT TO FILL A LOGO ARRAY WITH WHAT APPEARS
;A-TO-D CHANNEL, SAMPLING THAT A-TO-D 720 TIMES IN ONE ROTATION OF THE TURTLES'S
;EYE. THE TURTLE SENDS US A PULSE WHENEVER IT SHOULD BE SAMPLED
EYE:	ERROR+SIT
.IFZ 105
	SPUSH #1	;TELL AMAKE THERE IS ONLY ONE ARG
	SPUSH PS	;SAVE PSW AND PRIORITY
	MOV @S,A	;S POINTS TO ARRAY NAME
	JSR PC,AMAKE	;FIND TOP OF THE ARRAY
	ADD #2,S	;POP STACK
	CMPB 5(B),#260	;TEST TYPE BYTE
	BEQ 1$		;BRANCH IF IT'S AN INTEGER ARRAY
	ERROR+BAT	;BAD ARRAY TYPE
1$:	CMP 10.(B),#720.;IS THE FIRST DIMENSION 720. LONG?
	BGE 2$		;AT LEAST THAT BIG
	ERROR+BAT	;TOO SMALL,TOO BAD
	CRDPOS==5	;USE INTERFACE LINE FIVE
;THE A-TO-D DEVICE BUFFER REFERRED TO ABOVE IS ALSO THE SWITCHBOX ADDRESS
;REGISTER. I DON'T KNOW WHY.
2$:	ADD #12.,B	;B NOW POINTS TO FIRST ENTRY OF ARRAY
	MOV #CRDPOS,D
	ASH #10.,D	;THIS MAKES THE LINE-SELECTION ACCEPTABLE TO ADDRESS BUFFER
	MOV D,ATODB	;AND WE HAVE NOW SELECTED INTERFACE LINE FIVE.
	MOV #720.,C	;WE WANT 720. POINTS
	SPL 7		;LOCK OUT ALL INTERRUPTS
GNDATA:	CLR DEVICE	;TAP THE EYETURTLE ON THE SHOLDER,GET READY FOR A PULSE
	TST DEVICE	;DID WE GET A TIMING PULSE BACK YET?
	BPL .-4		;WAIT FOR THAT PULSE
	TST ATODB	;IS CONVERSION COMPLETE?
	BPL .-4		;NO, WAIT
	TST (B)+	;ARRAYS ARE DOUBLEWORD LONG, SO INCR PNTR
	MOV ATODB,(B)+	;YES PUT IN THE ARRAY AND INCREMENT POINTER
	SOB C,GNDATA	;IF NOT YET 720 POINTS GO GET ANOTHER
	SPOP PS		;RESTORE THE OLD PRIORITY
	SPOP A		;CLEAN THE P-PDL UP
	SEZ		;TELL EVAL THAT NOTHING IS BEING RETURNED
	RTS PC
.ENDC
.IIF NZ HALFLG, .INSRT 11LOGO;HALHACK >


.STITL DISPLAY AND TURTLE

;A  BRIEF DESCRIPTION OF WHAT IS LEFT TO BE DONE TO THIS PROGRAM.


;4)	DECIDING WHAT SNAP AND WIPE REALLY ARE GOING TO DO.
;AT THIS TIME, SNAP OUTPUTS THE ENTIRE SCREEN
;AND WIPE ERASES ONLY TOP LEVEL OCCURRENCES OF THE SNAP



.ENDC
.IFNZ NPLOT!NDISP!TURFLG
;DISPLAY AND TURTLE COMMANDS
	.IFZ <NDISP!NPLOT>
	DLT==0
	DRT==1
	DFD==2
	DBK==3
	DPD==4
	DPU==5
	.ENDC
.IFNZ DDF
	CURY==4		;USED FOR INDEXING OFF CURX FOR
	CURA==10	;PLOTTER AND DISPLAY
	COSA==14
	SINA==20
	RCURX==24
.ENDC
BACK:	GTJUMP GTBACK
	MOV	#"@C,D	;D _ CHAR. TO SEND TO TURTLE
	MOV	#DBK,E	;IN ORDER TO CAUSE 1 STEP OF MOTION
	BR	TURD	;THE TOP BYTE CONTAINS THE CHAR.
LEFT:	GTJUMP GTLEFT
	MOV	#"BA,D	;IF THE NUMBER OF STEPS IS NEGATIVE
	MOV	#DLT,E
	BR	TURD
RIGHT:	GTJUMP GTRIGH
	MOV	#"AB,D	;E CONTAINS THE ADDRESS OF THE PARALLEL
	MOV	#DRT,E	;DISPLAY ROUTINE
	BR	TURD
FORWARD:	GTJUMP GTFORW
	MOV	#"C@,D
	MOV	#DFD,E
;THE MOVE COMMANDS ARE PROCESSED HERE

TURD:
.IFZ FPPF
	JSR	PC,G1NARG	;B_SINGLE PRECISION NUMBER
.IFF
	JSR PC,G1NUM	;FA_FLOATING NUMBER
	BNE 1$
	ERROR+WTAB
1$:
.ENDC
	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;DISPLAY, OR REAL TURTLE?
	BEQ	TURD.1
	JMP	(E)		;DISPLAY
	.ENDC
TURD.1:	BIT	#TURTF,DFLAGS
	BNE	TURD.A	;TURTLE
	.IFNZ	NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	TURD.E
	JMP	(E) ;HANDLE PLOTTER COMMAND LIKE DISPLAY
	.ENDC
TURD.E:	ERROR+VTD   ;ONLY VALID FOR TURTLE,DSPLY,OR PLTR
TURD.A:
.IFNZ FPPF
	SETI		;IF IT'S A TURTLE CHANGE FLOATING
	STCFI FA,B	;TO AN INTEGER
	SETL
.ENDC
	TST	B
	BGE	TURD.2
	NEG	B	;MAKE NUMBER POSITIVE
	SWAB	D	;AND SWITCH CHARS
;NOW DO THE MOVING
TURD.2:	CMP	E,#DLT	;FOR LEFT OR RIGHT USE FUDGE FACTOR
	BEQ	TURD.0
	CMP	E,#DRT
	BEQ	TURD.0
	BR	TURD.3
TURD.0:	ASL B
	MOV B,A
	MOVB TURF,E	;MULTIPLY BY FIRST BYTE
	MUL E,A
	MOVB TURF+1,E	;DIVIDE BY SECOND
	DIV E,A
TUTE:	BVS TUTER	;OVERFLOW--LOSE.
	MOV A,B
	ASR B
	ADC B		;DIVIDE BY TWO, ROUNDING.
TURD.3:	MOV TURDN,E	;TURTLE DEVICE NUMBER (FOR TYO ROUTINES)
	SUB	#6.,B
	BLT	TURD.5	;NEVER EVEN MAKE IT TO FULL ACCELERATE MODE
	MOV	#10,C
	CLR A		;AGAIN, DIVIDE BY 4 (8)
	DIV #4,A
	MOV	B,F
		;REM.=NUMBER OF STEPS NEEDED BESIDES ACCELERATION
;		AND DECELERATION WHICH CAN'T BE TAKEN IN 8'S
	INC	F	;F_TOTAL NUMBER OF 1 STEPS
	JSR	PC,TUROUT
	ADD	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	MOV A,F	;F _ NUMBER OF 8 STEPS
	INC F
	ADD C,D	;D_CHAR FOR 8 STEPS
	JSR	PC,TUROUT
	SUB	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	SUB	C,D	;D_CHAR FOR 1 STEP
	JSR	PC,TURTYO
.IIF NZ PTBOX,	JSR PC,	TBREST
	SEZ
TURD.4:	RTS PC

;FOR FEWER THAN 14 STEPS, JUST SEND OUT 1 STEPS
;(IN THE WORS CASE, THIS STUPID ALGORITHM REQUIRES TWICE AS
;MANY CHARS AS THE OPTIMAL ALGORITHM)
TURD.5:	ADD	#6.,B	;RESTORE WHAT WAS SUBTRACTED
	MOV	B,F
	INC F
	JSR	PC,TUROUT
	BR	TURB.2
TUTER:	ERROR+TGDZ	;TURTLE GETTING DIZZY
.ENDC

.IFNZ TURFLG
;MORE TURTLE COMMANDS

LAMPON:	MOV	#'!,D
	BR	TURB
LAMPOFF:	MOV	#'",D

TURB:	JSR	PC,TURTST
TURB.1:	MOV	TURDN,E
	JSR	PC,TURTYO
TURB.2:	.IIF NZ PTBOX,	JSR PC,TBREST
	SEZ
	RTS PC
.ENDC
.IFNZ TURFLG!NDISP!TVS
PENDOWN:	GTJUMP GTPD
	MOV	#'0,D
	MOV	#DPD,E
	BR	TURC
PENUP:	GTJUMP GTPU
	MOV	#'8,D
	MOV	#DPU,E

TURC:
	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;TURTLE, OR DISPLAY?
	BEQ	TURC.1
	JMP	(E)
	.ENDC
TURC.1:
.IFNZ TURFLG
	BIT	#TURTF,DFLAGS
	BNE	TURB.1
.ENDC
	.IFNZ NPLOT
	BIT #PLOTF,DFLAGS	;USING PLOTTER
	BEQ	TURC.2
	JMP (E)
	.ENDC
	
TURC.2:	ERROR+VTD  ;ONLY VALID FOR TURTLE,DISPLAY,OR PLOTTER
.ENDC
.IFNZ TURFLG
TURTS1:	MOV	TURDN,E
TURTST:	BIT	#TURTF,DFLAGS
	BEQ	1$
	RTS	PC
1$:	ERROR+VTU
.ENDC

.IFNZ TURFLG
TOOT:	JSR	PC,G1NARG
	JSR	PC,TURTS1
	MOV	#"( ,D	;TOOT CHAR IN BOTTOM, NULL IN TOP
	MOV B,A
TOOT.1:	DEC	A	;HOW MANY TIMES TO TOOT
	BLT	TURB.2
	JSR	PC,TURTYO	;SHIP OUT TOOT CHAR
	MOV	#3,F	;THEN FOLLOW IT WITH 3 NULLS
	SWAB	D
	JSR	PC,TUROUT
	SWAB	D	;RETURN TOOT CHAR TO BOTTOM
	BR	TOOT.1

;TURTLE OUTPUT
;CALL WITH CHAR IN D, NUMBER OF TIMES IN F
TURO9:	JSR	PC,TURTYO
TUROUT:	TST BRAKE
	BNE TURDOR
	SOB	F,TURO9
TURDOR:	RTS	PC

.IFZ BOTUR
TURTYO:	SPUSH C
	MOV #TURT,C
	BIS TURDN,C
	JSR PC,TBTYO
	SPOP C
	RTS PC
.IFF
BOTTKS==177760
BOTTKB==BOTTKS+2
BOTTPS==BOTTKB+2
BOTTPB==BOTTPS+2
TURTYO:	JSR F,ACSAV
	MOV TURDN,C	;TURTLE DEVICE NUMBER
	MOV #21,A
	JSR PC,BOTTYO	;RESET TBOX
	CLR B
1$:	MOV #40,A
	CMP C,B	
	BNE 2$
	MOV D,A
	INC B		;TO OUTPUT ONLY 4 CHARS TOTAL IF TURTLE IS DEV 0, 1 OR 2
2$:	JSR PC,BOTTYO
	INC B
	CMP #4,B	;DONE?
	BGT 1$	
	JSR F,ACRES
	RTS PC

BOTTYO:	TSTB BOTTPS
	BPL BOTTYO
	MOVB A,BOTTPB
	RTS PC

TBTW:	JSR PC,TURTYO
2$:	TSTB BOTTKS
	BLT 1$
	BRAKET		;TEST FOR BREAK TYPED
	BR 2$
1$:	MOVB BOTTKB,D
	RTS PC
.ENDC


TOUCH:	PUSH	A
	JSR	PC,TURTS1
	MOV	#'#,D
	TST PTBF
	BNE TOUCH2
	JSR	PC,TBTW
TOUCH3:	POP	A
	BIT	A,D
	BEQ	TOUCH1
	JMP	RTFALS
TOUCH1:	JMP	RTTRUE
TOUCH2:	JSR PC,TURTYO	;SEND THE CHARACTER FOR READING SENSORS
	JSR PC,CTYI	;GET A CHARACTER	
	JSR PC,SETTTY
	BR TOUCH3	

FTOUCH:	MOV #20,A
	BR	TOUCH
BTOUCH:	MOV	#4,A
	BR	TOUCH
LTOUCH:	MOV	#10,A
	BR	TOUCH
RTOUCH:	MOV	#40,A
	BR	TOUCH
LFTOUC:	MOV #30,A
	BR TOUCH
RFTOUC:	MOV #60,A
	BR TOUCH
LBTOUC:	MOV #14,A
	BR TOUCH
RBTOUC:	MOV #44,A
	BR TOUCH
.IFZ 1
;LIGHT--RETURN INTENSITY SEEN BY TURTLE EYE
LIGHT:
	.IFNZ NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	LIGHT1
	MOV	PLTCHR,B
	BIC	#177774,B	;ONLY 2 SIGNIFICANT BITS
	JMP	R1NARG
	.ENDC
LIGHT1:	JSR	PC,TURTS1	;CHECK TO SEE IF HE HAS A TURTLE
	MOV	#'#,D
	TST PTBF
	BNE LIGHT2
	JSR	PC,TBTW
LIGHT3:	MOV	D,B
	BIC	#177700,B	;ONLY 6 SIGNIFICANT BITS
	JMP	R1NARG
LIGHT2:	JSR PC,TURTYO
	JSR PC,CTYI
	JSR PC,SETTTY
	BR LIGHT3
.ENDC
.ENDC

.IF NZ BOTUR&TURFLG&LSI
STARTT:	JSR PC,G1NARG
	TST B
	BGE 2$
1$:	ERROR+WTA
2$:	CMP #3,B
	BLT 1$
	CLR GTIDF	;NO MORE GTI DISPLAY
	MOV B,TURDN
	MOV STURF,TURF
	BIC #DISPF!PLOTF,DFLAGS
	BIS #TURTF,DFLAGS
	SEZ
	RTS PC

KILLTU:	BIC #TURTF,DFLAGS
	SEZ
	RTS PC










.ENDC
;START TURTLE
.IFZ LSI
.IFNZ DDF
ASSTUR:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4

STARTTURTLE:
	CLR A		;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STARTTURTLE:
.ENDC
	JSR	PC,G1NARG	;WHICH TURTLE
	TST	B
	BGE	.+4
STRTT1:	ERROR+ITN	;INVALID TURTLE NUMBER
	DEC	B
;	CMP	B,#NTUR-1
	BGT STRTT1
STRTT2:	TST PTBF
	BEQ STRTT3
	MOV #TURT,A	;TYPE OF TURTLE
	ADD B,A		;WHICH TURTLE
	JSR PC,TBCHK	;CHECK TO SEE IF HE HAS IT
	BNE 1$
	ERROR+VTU
1$:	MOV B,TURDN	;TURTLE NUMBERR
	MOV STURF,TURF	;USE TURTLE 1'S FUDGE FACTORS
	TST A
	BLT STRTT4
	PUSH B
	JSR PC,KILLT1	;KILL ANOTHER TURTLE
.IIF NZ NPLOT,	JSR PC,KILLPL	;KILL ANOTHER PLOTTER
	POP B
	BR STRTT4
STRTT3:	ASL	B	;TURN INTO WORD INDEX
.IFZ DDF
	.IFNZ NDISP
	PUSH	B
	JSR	PC,KILLD1
	POP	B
	.ENDC
	JSR	PC,KILLT1	;KILL TURTLE IF HE ALREADY HAS ONE
.IIF NZ NPLOT,	JSR PC,KILLPL	;KILL ANOTHER PLOTTER
.IFF
	PUSH B
	TST A		;KILL OTHER DEVICS?
	BLT ASTRT1	;NO
.IIF NZ NDISP, JSR PC,KILLD1
.IIF NZ NPLOT, JSR PC,KILLPL
	JSR PC,KILLT1
ASTRT1:	SPOP B
.ENDC
	MOV	TURN(B),E
	JSR	PC,OPEN1	;TRY TO OPEN IT
	MOV	E,TURDN	;USER VARIABLE
	MOV	STURF(B),TURF	;TURTLE FUDGE FACTOR
STRTT4:	BIC	#<DISPF+PLOTF>,DFLAGS
	BIS	#TURTF,DFLAGS	;SET FLAG FOR CONTROL OF TURTLE
.IIF NZ DDF, BIS #TURTF,DIVOWN	;SET FLAG FOR OWNING TURTLE
	SEZ
	RTS PC

KILLTURTLE:
KILLT1:
.IIF Z DDF,	BIT	#TURTF,DFLAGS
.IIF NZ DDF,	BIT	#TURTF,DIVOWN
	BEQ	KILLT9	;DOESN'T HAVE A TURTLE
	TST PTBF
	BNE KILLT3
	MOV	TURDN,E
	JSR	PC,CLOSE1
KILLT3:	BIC	#TURTF,DFLAGS
.IIF NZ DDF, BIC #TURTF,DIVOWN
KILLT9:	SEZ
	RTS	PC

NODEV:
	.IFNZ NDISP
	JSR	PC,KILLD1
	.ENDC
	JSR	PC,NOMUSIC
	.IFNZ	NPLOT
.IIF NZ NPLOT,	JSR PC,KILLPL	;KILL ANOTHER PLOTTER
	.ENDC
;	JSR	PC,SLAM	;RELEASE ALL DEVICES FOR THIS USER
	TST PTBF
	BNE KILLT3
	RTS	PC

	.IFNZ   NPLOT
;STARTPLOTTER
.IFNZ DDF
ASSTPL:	CLR C		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM C
	BR .+4
STRTPL:	CLR C		;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STRTPL:
.ENDC
	TST PTBF	;THORTON BOX PRIVATE?
	BEQ STRTP2	;NO, JUST IGNORE
	MOV #PLOTT,A	;PLOTTER
	JSR PC,TBCHK	;CHECK IT OUT
	BNE STRTP3	;HE'S GOT IT
	ERROR+DIU	;DONT HAVE ONE, SEND TO THE FACTORY
STRTP2:	MOV PLTDVN,E
	JSR	PC,OPEN1
.IFNZ DDF
STRTP3:	TST C		;SHOULD WE KILL OTHER DEVICES?
	BLT STRTP1	;NOPE
.ENDC
	JSR	PC,KILLT1   ;KILL TURTLE IF HE HAS ONE
	BIT	#DISPF,DFLAGS
	BEQ	STRTP1
.IIF NZ NDISP,	JSR	PC,KILLD2   ;KILL DISPLAY IF HE HAS ONE
STRTP1:	MOV     #PORBEG,F   ;SETT [0 0 0]
	BIS     #PLOTF,DFLAGS     ;SET PLOTTER FLAG
.IFNZ DDF
	BIC #<DISPF+TURTF>,DFLAGS
	BIS #PLOTF,DIVOWN	;SET FLAG FOR OWNING PLOTTER
.ENDC
ZVAR:	CLR (F)+	;CLEAR USER'S PLOTTER VARIABLES
	CMP #POREND,F
	BNE ZVAR
.IIF NZ DDF,	BIS #PENUF,PLPENP	;SET PENUP FLAG IN PLOTTER 
	BIS     #PENUF,DFLAGS     ;START WITH PEN UP
	JSR	PC,ANGCRP	;INIT SINE AND COSINE
	CLR	B
	CLR	C
	JSR     PC,MTO.02     ;MOVE PLOTTER THERE
ZVAR1:	SEZ
	RTS	PC
;KILLPLOTTER
KILLPL:
	TST PTBF		;PRIVATE TBOX?
	BNE 1$			;CLEAR FLAGS
	MOV PLTDVN,E
	JSR	PC,CLOSE1
1$:
.IIF NZ DDF, BIC #PLOTF,DIVOWN
	BIC	#PLOTF,DFLAGS  ;ELIM. PLOTTER FLAG
	BR ZVAR1
	.ENDC
;HERE IS WHERE THE DISPLAY PRIMITIVES START.
.IFNZ NDISP

;STARTDISPLAY
;	INITIALIZE EVERYTHING
;	ALLOCATE DISPLAY BUFFERS
.IFNZ DDF
ASTRDI:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4
STARTDISPLAY:	CLR A	;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STARTDISPLAY:
.ENDC


;USE THIS PRIMITIVE TO SPECIFY A LARGE DISPLAY
	JSR	PC,G1NARG	;B _ #.  SHOULD BE 0 OR 1


STRTD0:	SPUSH	B	;THE KILLERS CLOBBER B
.IFNZ DDF
	TST A		;KILL OTHER DEVICES?
	BLT ASTRD1	;NO
.ENDC
	JSR	PC,KILLT1	;GET RID OF TURTLE IF NECSSARY
.IIF NZ NPLOT,	JSR PC,KILLPL	;KILL ANOTHER PLOTTER
.IFNZ DDF
ASTRD1:	BIT #DISPF,DIVOWN	;DOES HE ALREADY OWN ONE?
	BEQ ASD1	;YES
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLING DISPLAY
ASD1:
.ENDC

	BIT	#DISPF,DFLAGS	;DOES HE HAVE A DISPLAY?
	BEQ	STRTD1	;USER DOESN'T HAVE A DISPLAY YET
	JSR	PC,KILLD2	;KILL HIS PREVIOUS DISPLAY FIRST
;FALLS THROUGH
;FALLS IN
STRTD1:
;IS THIS USER A DISPLAY USER?
;I.E. IS THERE AN ACTUAL DISPLAY CONSOLE
;	ASSOCIATED WITH HIM?
;NOW WE MUST ALLOCATE HIM A DISPLAY BUFFER
;FIRST DETERMINE WHAT SIZE BUFFER HE IS LOOKING FOR.
	SPOP	B
.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV DISPLAY?
	BEQ 1$			;NO, START UP TK DISPLAY
	JMP TVSTRT		;YES, START UP TVS
1$:
.ENDC
	SAVE <#-1,TYICP>
	MOVB B,1(P)
	BIS #100000,(P)		;SAY GET THE DISPLAY FOR THIS TTY
	SAVE #.DSCAP*400+0	;ZERO IS MY CREATE CAPABILITY
	.INVOK
	BNE 2$
	ERROR+NDV
2$:	REST <DISCAP,B,A>
	SUB #<DISAD/2>&77777,A
	MOV A,DRELOC
	CLR -(P)	;START AND LENGTH DON'T MATER
	CLR -(P)	;NEIRTHER DOES PAGE IN SOURCE
	SAVE DISCAP	;SOURCE
	MOVB #10+DISPG,1(P)	;PAGE IN ME
	SAVE <#.CRWRT+1>	;MY SPHERE CAP AND GIVE ME WRITE ACCESS
	$MAP
	MOV	#DORBEG,F	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,D	;LAST WORD
SDLOOP:	CLR	(F)+	;ZERO WORD
	CMP	F,D
	BLE	SDLOOP
.IFNZ DDF
	BIC #<PLOTF+TURTF+PENUF>,DFLAGS	;CLEAR VARIOUS FLAGS
	CLR DPENP		;START WITH THE PENDOWN
	BIS #DISPF,DIVOWN	;SET FLAG FOR OWNING DISPLAY
.ENDC
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY
;SET UP TURTLE VARIABLES
	MOV	#TLIST,D
	MOV	D,TUB
	MAKEPJ	D
	MOV	D,PUSHJT
;SET FIRST 2 WORDS OF DLIST
;AND SET THE BUFFER VARIABLES
	MOV	#DLIST,D
	MOV	#<DRSTXY!DPOP>,(D)+
	MOV	PUSHJT,(D)
	MOV	D,STB	;STATIC AREA BOTTOM
	MOV	D,STT	;STATIC AREA TOP
	ASL	B	;B _ LENGTH OF DISPLAY IN BYTES.
			;USE THIS TO CALCULATE WHERE DYNAMIC AREA ENDS
	ADD	#DISAD,B
	CLR	-(B)	;SET UP DUMMY FREE AREA
	MOV	B,DYT	;DYNAMIC AREA TOP
	CLR	-(B)
	MOV	B,DYB	;DYNAMIC AREA BOTTOM
	MOV	B,DYR	;DYNAMIC AREA ROVING POINTER
;DRAW THE TURTLE
	PUSH	C
	JSR	PC,ANGCRP	;CALCULATE ANGLE CRAP
	JSR	PC,DR.TUR	;DRAW TURTLE
	SPOP	C
;NOW MAKE A PUSHJ TO THE DISPLAY LIST
;AND STUFF IT INTO THE HARDWARE FIRST LOCATION FOR THIS DISPLAY
	TST -(P)
	SAVE #<DLIST/2>&77777
	ADD DRELOC,(P)
	SAVE DISCAP
	$INVOK		;START UP THE DISPLAY
;AND LAST BUT NOT LEAST
	JMP NEWSN2	;SET UP FOR SNAPS TO START HERE

;KILLDISPLAY
;	USER WANTS TO GIVE UP HIS DISPLAY
KILLDISPLAY:
KILLD1:
.IIF NZ GTI,CLR GTIDF	;IT'S NOT A GTI DISPLAY THEN
.IIF Z DDF,	BIT	#DISPF,DFLAGS
.IIF NZ DDF,	BIT #DISPF,DIVOWN
	BEQ	KILLDR	;USER DOESN'T HAVE DISPLAY
KILLD2:	CLR	A	;GET USER NUMBER
	CLR	SNLIST	;CLEAR  SNAPS
.IIF NZ DDF, BIC #DISPF,DIVOWN	;CLEAR DISPLAY FLAG
	BIC	#DISPF,DFLAGS
	JSR	PC,.GCOLL

.IFNZ TVS
.IIF NZ COLOR,JSR PC,FLSBUF	;GET RID OF COLOR BUFFERS, IF ANY
	BIT #TVF,DFLAGS	;ARE WE USING TV?
	BEQ KILLD3	;NO
KILLD9:	CLR B
	JSR PC,CRECHO	;CREATE AN ECHO AREA OF SIZE 0 IE NO ECHO AREA
	BR KILLDR	;DON'T FLUSH CAP
KILLD3:
.ENDC

	MOV DISCAP,A
	JSR PC,DELCAP
	CLR DISCAP
KILLDR:	SEZ
	RTS	PC
.IFTF
DCHKPL:
	.IFNZ    NPLOT
	BIT     #PLOTF,DFLAGS      ;USING PLOTTER?
	BEQ	DCHK
	RTS	PC
	.ENDC
DCHK:
.IFF
	ERROR+VTU
.IFT
	BIT	#DISPF,DFLAGS
	BNE	DCHK1
	PUSH	B
	CLR	B	;SPECIFY A SMALL DISPLAY BUFFER
.IFNZ DDF
	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
.ENDC
	JSR	PC,STRTD0	;STARISPLAY
	SPOP	B
	RTS	PC
DCHK1:
	.IFNZ TVS
	BIT	#TVF,DFLAGS	;IS THIS A TV
	BNE	KILLDR		;YES JUST RETURN
	.ENDC
	CMP	NADXY,#20
	BLT	KILLDR	;DON'T BOTHER TRYING TO COMPRESS ADDXY'S
	JSR	PC,DSGC8	;TRY TO COLLAPSE
	BR	KILLDR

.ENDC
TBOX:	JSR PC,NODEV
	CLR E
	MOV #PTBTAB,B
	MOV #4,A
TBOX3:	DEC A
	BLT TBOX4
TBOX7:	SPUSH A
	SPUSH E
	PRTXT ^\PORT \
	JSR PC,PRDN
	PRTXT ^\: ?\
	JSR PC,QUEST
	SPOP E
	SPOP A
	CMP D,#'P	;IS IT A PLOTTER
	BEQ TPLOT
	CMP D,#'N	;IS IT NULL
	BEQ TNUL
	CMP D,#'C	;IS IT HIS CONSOLE
	BEQ TCON
	CMP D,#'T	;IS IT A TURTLE
	BEQ TTUR
	CMP D,#'M	;IS IT A MUSIC BOX
	BEQ TMUS
	CMP D,#7
	BEQ TBOX6
	SPUSH A
	PRTXT ^\ ? \
	SPOP A
	BR TBOX7
TMUS:	MOV #PMBOX,(B)+
	BR TBOX3
TNUL:	CLR (B)+
	BR TBOX3
TCON:	MOV #CONSO,(B)+
	BR TBOX3
TTUR:	MOV E,(B)
	BIS #TURT,(B)+
	INC E
	BR TBOX3
TPLOT:	MOV #PLOTT,(B)+
	BR TBOX3
TBOX4:	TST -(P)
	SPUSH #.TIRST
	SPUSH TYOCP
	BIS #.TTBIS*400,(P)
	$INVOK
	SUB #4,P
	SAVE TYOCP
	BIS #.TTRD*400,(P)
	$INVOK
	SPOP OTTYST
	MOV #CONSO,C
	MOV #-1,PTBF
	JSR PC,TBINIT
	BEQ TBOX5
	SEZ
	RTS PC
TBOX5:	JSR PC,NOTBOX
	ERROR+TDE
TBOX6:	JSR PC,NOTBOX
	ERROR+BRK

NOTBOX:	JSR PC,NODEV
	CLR PTBF
	SEZ
	RTS PC

.IFNZ DDF

.IFNZ NDISP

CTRDIS:	BIT #DISPF,DIVOWN	;DOES HE OWN A DISPLAY?
	BEQ CTRERR		;NO
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+PLOTF>,DFLAGS
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY
	BIS DPENP,DFLAGS	;SET DISPLAY PEN POSITION
	SEZ
	RTS PC
.ENDC

CTRTUR:	BIT #TURTF,DIVOWN	;DOES HE OWN A TURTLE?
	BNE .+4			;NO,ERROR
CTRERR:	ERROR+VTD
	BIC #<PLOTF+DISPF>,DFLAGS
	BIS #TURTF,DFLAGS	;SET FLAG FOR CONTROLLING TURTLE
	JSR PC,G1NARG		;WHICH TURTLE DOES HE WANT TO CONTROL?
	TST B			;TEST TURTLE NO.
	BGE .+4			;IT'S OKAY SO FAR
CTRER2:	ERROR+ITN		;INVALID TURTLE NUMBER
	DEC B			;TO START TO TURN INTO AN INDEX
;	CMP B,#NTUR-1
	BGT CTRER2		;IT WAS TO LARGE
	ASL B			;TURN IT INTO A WORD INDEX
	BNE CTRERR		;NOPE
	MOV STURF(B),TURF
CTRRET:	SEZ
	RTS PC

.IFNZ NPLOT

CTRPLT:	BIT #PLOTF,DIVOWN	;DOES HE OWN THE PLOTTER?
	BEQ CTRERR		;NOPE
	BIT #PLOTF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+DISPF>,DFLAGS
	BIS PLPENP,DFLAGS	;SET PLOTTER PEN POSITION
	BIS #PLOTF,DFLAGS	;SET FLAG FOR CONTROLLING PLOTTER
	SEZ
	RTS PC

.ENDC
.ENDC

.IFNZ <NDISP!NPLOT>


.IFZ FPPF

DBK:	NEG	B
;DISPLAY FORWARD AND BACK
DFD:	MOV	B,C
	CLR	B
	TST	C
	BGE	DFD1	;IF ARG IS NEG,
	COM	B	;SET B = -1
	CLR	A	;CLEAR FLAG
DFD1:	MOV	#CURX,D
	JSR	PC,MULSIN	;PUTS DX IN E,,F
	SDPADD	(D)+,(D)+,E,F	;NEW X
	PUSH	F	;FRACTION PART
	SPUSH	E	;INTEGER PART
	JSR	PC,MULCOS	;DY IS IN E,,F
	SDPADD	(D),(D)+,E,F	;NEW Y
	SPUSH	F
	SPUSH	E
	BR	SETMOV

.IFF

DBK:	NEGF FA
DFD:	
.IFZ DDF
	LDCFD COSA,FB
	MULF FA,FB
	LDCFD CURY,FC
.IFF
	JSR PC,GTCURX		;IS HE CONTROLLING PLOTTER OR DISPLAY?
	LDCFD COSA(F),FB	;COSINE OF ANGLE -> FB
	MULF FA,FB		;DY -> FB
	LDCFD CURY(F),FC	;CURY -> FC
.IFTF
	ADDF FC,FB	;GET NEW Y IN FB
	STCDF FB,-(P)	;PUT NEW Y ON STACK
.IFT
	LDCFD SINA,FB
	MULF FA,FB	;DX IN FB
	LDCFD CURX,FC	;CURRENT X IN FC
.IFF
	LDCFD SINA(F),FB	;SINE OF ANGLE -> FB
	MULF FA,FB		;DX -> FB
	LDCFD (F),FC		;CURX -> FC
.ENDC
	ADDF FC,FB	;GET NEW X IN FB
	STCDF FB,-(P)	;PUT NEW X ON STACK
	BR SETMOV

.ENDC
.IFNZ DDF
	;PUTS THE ADDRESS OF THE CURX OF DISPLAY IN F
	;IF HE OWN A DISPLAY, ELSE PUTS CURX OF PLOTTER IN F
.IFNZ NDISP
GTCURX:	BIT #DISPF,DFLAGS	;DOES HE OWN A DISPLAY?
	BNE DISP		;YES
	MOV #PCURX,F		;PUT ADDRESS OF PCURX IN F
	BR DISP1
DISP:	MOV #DCURX,F		;PUT ADDRESS OF DCURX IN F
DISP1:	RTS PC
.IFF
GTCURX:	MOV #PCURX,F
	RTS PC
.ENDC
.ENDC


.IFZ FPPF


SETX:	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;;NEW X IN B
	CLR	-(SP)	;FRACTION PART OF NEW X
	PUSH	B	;INTEGER PART
	SPUSH	CURY	;NEW Y UNCHANGED
	SPUSH	CURY+2
	BR	SETMOV

SETY:	JSR	PC,DCHKPL
	JSR	PC,G1NARG
	PUSH	CURX	;NEW X UNCHANGED
	SPUSH	CURX+2
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	B	;INTEGER PART OF NEW Y
	BR	SETMOV

SETXY:	GTJUMP GTSXY
	JSR	PC,DCHKPL
	JSR	PC,G2NARG
	CLR	-(SP)	;FRATION PART OF NEW X
	PUSH	B	;INTEGER PART
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	A	;INTEGER PART
SETMOV:	JSR	PC,MOVETO
	RTS PC

SETTURTLE:
	JSR	PC,DCHKPL
	MOV	@S,C
	JSR	PC,LD3NUM	;LOAD D,E,F
SETT1:	PUSH	F	;SAVE NEW ANGLE
	JSR	PC,SPOPT	;POP OFF ARG
	CLR	-(SP)	;FRACTION PART OF NEW X
	SPUSH	D	;INTEGER
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	E
	CLR	A	;A FLAG
	JSR	PC,MOVETO	;MOVE TO NEWX,NEWY
	SPOP	B	;NEW HEADING
	JMP	DRT.HD	;SET HEADING

.IFF
SETX:	JSR PC,DCHKPL
.IFZ DDF
	SPUSH CURY+2
	SPUSH CURY
.IFF
	JSR PC,GTCURX
	SPUSH CURY+2(F)	;PUT CURY ON STACK
	SPUSH CURY(F)
.IFTF
	JSR PC,GARG	;PUT NEWX ON STACK
	BR SETMOV
SETY:	JSR PC,DCHKPL
	JSR PC,GARG	;PUT NEW Y ON STACK
.IFT
	SPUSH CURX+2
	SPUSH CURX
.IFF
	JSR PC,GTCURX
	SPUSH 2(F)	;PUT CURX ON STACK
	SPUSH (F)
.ENDC
	BR SETMOV
SETXY:	GTJUMP GTSXY
	JSR PC,DCHKPL
	JSR PC,GARG	;PUT Y ON
	JSR PC,GARG	;PUT X ON
SETMOV:	JSR PC,MOVETO
	RTS PC

SETTURTLE:
	MOV @S,C
	JSR PC,.GFLST	;FA <- NEWX
	LDD A,B		;FB <- NEWX
	JSR PC,.GFLST	;FA <- NEWY
	BIT #7777,C	;ANY MORE LIST?
	BEQ SETT1	;NO?!
	JSR PC,.LOADC	;GET POINTER TO ANGLE
	BIT #7777,A	;ANY MORE LIST? (SHOULDN'T BE)
	BNE SETT1	;THERE IS??
	MOV #SNUM,A	;TAKE POINTER AND TRY TO
	JSR PC,CONVER	;CONVERT IT TO A SNUM
	BNE .+4
SETT1:	ERROR+WTA
	SPUSH B		;STORE ANGLE
	STCDF FA,-(P)	;STORE NEWY
	STCDF FB,-(P)	;STORE NEWX
SETT2:	JSR PC,DCHKPL
	CLR A		;SET A FLAG
	JSR PC,MOVETO	;MOVE IT
	SPOP B		;POP ANGLE
	JMP DRT.HD

.GFLST:	BIT #7777,C	;GETS FLOATING NUMBER OUT OF LIST
	BEQ SETT1	;EMPTY LIST
	JSR PC,.LOADC	;GET NODE IN A AND B
	MOV A,C		;GET POINTER TO REST OF LIST IN C
	JSR PC,G1NUMS	;GET FNUM POINTED TO BY B INTO FA
	BEQ SETT1
	RTS PC

GARG:	SPOP FNPDL+4	;SO THAT THE JMP WILL WORK BELOW
	SPUSH A		;STORES REGISTERS AND GETS NUMBER IN FA
	SPUSH B
	SPUSH F
	JSR PC,G1NUM	;FA <- FNUM POINTER TO BY B
	BEQ SETT1
	SPOP F		;RESTORE REGISTERS
	SPOP B
	SPOP A
	STCDF FA,-(P)	;PUT FA ON STACK
	JMP @FNPDL+4	;DOES A RTS PC

.ENDC

;CALL WITH NEWX AND NEWY ON THE STACK




MOVETO:	JSR PC,PPOPT	;INSURE ENOPUGH STACK IS IN CORE
	.IFNZ	NPLOT
.IFNZ NDISP
	BIT	#PLOTF,DFLAGS ;USING PLOTTER?
	BEQ	MTO.09   ;IF NOT,SKIP ALL THIS
.ENDC


.IFZ FPPF

	MOV	2(P),C	;INT OF Y
	MOV	4(P),A	;FRACTION Y
	MOV	6(P),B	;INT OF X
	MOV	10(P),D	;FRACTION X
	ASL	A
	ADC	C	;ROUND Y
	ASL	D
	ADC	B	;ROUND X
	CMP	B,#128.   ;CHECK IF EXCEEDS PLOTTER BOUNDS
	BGE	MTO.03
	CMP	B,#-128.
	BLT	MTO.03
	CMP     C,#128.    ;NOW CHECK Y BOUNDS
	BGE	MTO.03
	CMP	C,#-128.
	BLT	MTO.03
	JSR	PC,MTO.02
	JMP	MTO.R
;SEND OUT PLOTTER CHARACTERS

.IFF

	LDCFD 2(P),FA	;LOAD NEWX
	LDCFD 6(P),FB	;LOAD NEWY
	STF FA,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	STF FB,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	SETI
	STCFI FA,B	;PUT NEWX INTO B
	STCFI FB,C	;PUT NEWY INTO C
	SETL
	ASR B		;ROUND NEWX
	ADC B
	ASR C		;ROUND NEWY
	ADC C
	JSR PC,MTO.02	;MOVE IT
	JMP MTO.R	;STORE AWAY NEWX AND NEWY
.IFZ DDF

CHKPL:	CMPF #42000,FC
	CFCC
	BLT MTO.03
	CMPF #142000,FC
	CFCC
	BGT MTO.03
	RTS PC
.ENDC

.ENDC

MTO.02:	MOV	#35,D   ;PRIMING CHARACTER
	MOV	PLTDVN,E
	SPUSH C
	MOV #PLOTT,C
	JSR	PC,TBTYO   ;SEND TO TTY
	JSR	PC,MTO.04	;SEND NEW X TO PLOTTER
	JSR	PC,PLT67
	JSR	PC,TBTYO
	SPOP B
	JSR	PC,MTO.04   ;SEND NEW Y TO PLOTTER
	JSR	PC,PLT67
	JSR PC,TBTYO
.IIF NZ PTBOX,	JSR PC,TBREST
	RTS	PC
MTO.03:	ERROR+OOB
MTO.04:	MOV	B,D   ;SEND LOW ORDER 6 BITS
	BIC	#177700,D
	JSR	PC,PLT67
	JSR	PC,TBTYO
	MOV	B,D	;SEND REMAINING 2 BITS
	ASL	D
	ASL	D
	SWAB	D
	BIC	#177774,D
	BIT	#PENUF,DFLAGS   ;SEND PENUP INFO
	BEQ	MTO.05
	BIS	#40,D   ;SET PENUP BIT
MTO.05:	RTS	PC

PLT67:	BIT	#40,D	;SET BIT 6 TO COMP OF BIT 7
	BNE	PLT671
	BIS	#100,D
PLT671:	RTS	PC


.ENDC
.IFNZ NDISP

.IFZ FPPF

MTO.09:	MOV SP,F
	TST	(F)+	;POINT TO ARGS
	MOV	(F)+,B	;INTEGER PART OF NEW Y
	MOV	(F)+,C	;FRACTION PART OF NEW Y
	JSR	PC,CHKBND	;CHECK TO SEE IF IN BOUNDS
	MOV	B,E	;ROUNDED NEWY
	MOV	(F)+,B	;INTEGER PART OF NEW X
	MOV	(F),C	;FRACTION PART OF NEW X
	JSR	PC,CHKBND
	MOV	B,D	;ROUNDED NEWX
;GET D_DX AND E_DY
	MOV	#CURX,F
	ASL	(F)+	;FRACTION OF CURX
	ADC	(F)	;ROUND CURX
	SUB	(F)+,D	;DX
	ASL	(F)+
	ADC	(F)
	SUB	(F),E	;DY

.IFF

MTO.09:
	.IFNZ TVS
	BIT #TVF,DFLAGS
	BEQ MTO.10
	SETF
	LDF DCURX,FA	;FROM X
	LDF DCURY,FB	;FROM Y
	REST F		;THE RETURN ADDRESS	
	LDF (P)+,FC	;TO X
	LDF (P)+,FD	;TO Y
	SAVE F		;PUT THE RETURN ADDRESS BACK
	JMP VECTOR	;DRAW THE VECTOR
MTO.10:
	.ENDC
	
	MOV P,F		;SO IT CAN DO POPS W/O DISTURBING THE STACK
	TST (F)+	;TO GET AROUND THE PC
	LDCFD (F)+,FA	;GET NEW X
	STF FA,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
	LDCFD (F)+,FB	;GET NEW Y
	STF FB,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
.IIF Z DDF,	MOV #RCURX,F
.IFNZ DDF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	ADD #RCURX,F	;TO TELL WHERE TO PUT ROUNDED FA AND FB
.ENDC 
	JSR PC,ROUND	;ROUND FA AND FB
	SETF
	SUBF (F)+,FA	;FA <- NEWX - CURX
	SUBF (F)+,FB	;FB <- NEWY - CURY
	SETD
	JSR PC,MOD1K	;PERFORM A MODULAR 32K. (ANY BETTER IDEAS?)
	SETI
	STCFI FA,D	;PUT DX IN D
	STCFI FB,E	;PUT DY IN E
	SETL

.ENDC

	BNE	MTO.1	;CHECK FOR DX=DY=0
	TST	D
	BEQ	MTO.R	;JUST RETURN

MTO.1:	BIT	#PENUF,DFLAGS	;IS PEN UP?
	BNE	MTO.PU	;YES
;FALLS THROUGH
;FALLS IN
;THE PEN IS DOWN
	SPUSH	DIREC
	JSR	PC,XYDIR	;CALCULATE DIREC
	JSR	PC,DR.LIN	;AND DRAW LINE!!
	SPOP	DIREC

;RETURN.  SET CURX & CURY TO NEWX & NEWY


.ENDC

.IFZ FPPF

MTO.R:	POP	A	;RETURN ADDRESS
	MOV	#CURY+2,B
	SPOP	(B)	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP	-(B)
	SPOP	-(B)
	SPOP	-(B)
	JMP	(A)

.IFF

MTO.R:	POP A
.IFZ DDF
	MOV #CURX,B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE SET OF VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
.ENDC
	SPOP (B)+	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP (B)+
	SPOP (B)+
	SPOP (B)+
	JSR PC,ROUNDER	;ROUND AND PUT IN RCURX AND RCURY
	SEZ
	JMP (A)		;DOES AN RTS!!?

ROUNDER:	;PUTS ROUNDED CURX AND CURY INTO RCURX AND RCURY
.IFZ DDF
	MOV #CURX,B
	MOV #RCURX,F
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
	ADD #RCURX,F	;MAKE F POINT TO RCURX
.ENDC
	LDCFD (B)+,FA	;FA <-CURX
	LDCFD (B)+,FB	;FB <- CURY
	JSR PC,ROUND	;ROUND FA AND FB
	STCDF FA,(F)+	;RCURX <- ROUNDED CURX
	STCDF FB,(F)+	;RCURY <- ROUNDED CURY
	RTS PC

	;ROUNDS FA AND FB
ROUND:	ADDF #40000,FA	;FA <- FA + 1/2
	STCFI FA,-(P)	;INTEGERIZE FA
	BCS EROOB	;TOO BIG
	LDCIF (P)+,FA	;FA <- INTEGER (FA)
	CFCC		;IS FA > 0?
	BGE 1$		;YES
	SUBF #40200,FA	;FA <- FA - 1 (TO ROUND AWAY FROM 0)
1$:	ADDF #40000,FB	;REPEAT SAME PROCESS FOR FB
	STCFI FB,-(P)
	BCS EROOB
	LDCIF (P)+,FB
	CFCC
	BGE 2$
	SUBF #40200,FB
2$:	RTS PC
EROOB:	ERROR+OOB

MOD1K:	LDD FB,FC
	MODF #34600,FC	;DIVIDES BY 2^16 (FC <- ONLY FRACTIONAL PART)
	CFCC
	BEQ MODK1	;IT WAS ZERO OR UNDERFLOWED
	MULF #43600,FC	;FRACTION * 2^16
	LDD FC,FB	;PUT IT BACK NOW
MODK1:	LDD FA,FC	;NOW DO IT TO FA
	MODF #34600,FC
	CFCC
	BEQ MODK2
	MULF #43600,FC
	LDD FC,FA
MODK2:	RTS PC

.ENDC

.ENDC
.IFNZ NDISP


;THE PEN IS UP
;PUT ADDX AND ADDY COMMANDS INTO DISPLAY LIST
MTO.PU:	SPUSH	#MTO.R	;SO RTS PC'S BELOW WILL WORK (GROAN !!!)
	MOV	STT,A	;POINTER TO TOP OF STATIC DISPLAY ALLOCATION
	CMP	-(A),#ADDY
	BLO	MTO.AD	;PREVIOUS STUFF NOT ADDS ANYWAY
	CMP	-(A),#ADDY	;IS THE NEXT TO LAST DCODE AN ADD,TOO ?
	BLO	MTO.AD	;NO
	CMP	A,SNABOT	;DON'T COMPRESS ACROSS SNAP BOTTOM
	BLO	MTO.AD	;NO
;THERE ARE TWO ADD COMMANDS IN A ROW
	JSR	PC,MTO.AS	;TAKE CARE OF FIRST ADD
	JSR	PC,MTO.AS	;AND SECOND ADD
	BR	MTO.R1


;MTO.AS ADDS THE DELTA X OF AN ADD COMMAND TO THE NEW DX OR DY
MTO.AS:	CMP	(A),#ADDX	;ADDX IS THE BIGGER OF THE ADDS
	BHIS	1$
	ADD	(A)+,E	;DY
	RTS	PC
1$:	ADD	(A)+,D
	RTS	PC



;HAVE TO EXPAND STATIC AREA AND PUT IN ADD COMMANDS
MTO.AD:	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

MTO.RM:	MOV	A,STT	;A WAS SET IN STXPND
	MOV	PUSHJT,(A)	;DISPLAY JUMP TO TURTLE
MTO.R1:	BIC	#176000,D	;IN CASE EITHER DX OR DY WERE NEGATIVE
	BIC	#176000,E	;CLEAR THE TOP 6 BITS
	BIS	#ADDY,E	;TURN E INTO ADDY COMMAND
	MOV	E,-(A)	;STORE IN DLIST
	BIS	#ADDX,D	;TURN D INTO ADDX COMMAND
	MOV	D,-(A)	;STORE IN DLIST
	CLR DFBCNT
	RTS	PC

.ENDC
.IFNZ <NDISP!NPLOT>

.IFZ FPPF

DLT:	NEG	B

;DISPLAY RIGHT AND LEFT

DRT:	ADD	CURA,B

.IFF

DLT:	NEGF FA
DRT:	SETI
	STCFI FA,B
	SETL
	BCC 1$		;NUMBER TOO LARGE??, NOPE
	ERROR+TGDZ	;TURTLE GETTING DIZZY
1$:
.IFZ DDF
	ADD CURA,B
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE VARIABLES
	ADD CURA(F),B	;B <- NEWA + CURA
.ENDC

.ENDC
DRT.HD:	JSR	PC,MOD360	;SET B=B MOD 360

.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV?
	BEQ 1$			;NO
	JMP TVHEAD		;TV VERSION OF HEADING UPDATE
1$:
.ENDC

.IIF Z DDF,	MOV	B,CURA
.IFNZ DDF
	JSR PC,GTCURX
	MOV B,CURA(F)	;MOVE NEWLY COMPUTED ANGLE TO CURA
.ENDC

;DRAW THE TURTLE IF IT'S BEING SHOWN
TURDO:	JSR	PC,ANGCRP	;DO ALL THE ANGLE CRAP.
	.IFNZ	   NPLOT
	BIT     #PLOTF,DFLAGS   ;USING PLOTTER?
	BNE	DRTRET	;YES, SO RETURN
	.ENDC
.IFZ NDISP
	ERROR+VTU
.IFF
	BIT	#HIDETF,DFLAGS	;IS THE TURTLE BEING HIDDEN ?
	BNE	DRTRET	;YES. SO RETURN
;THE TURTLE IS BEING SHOWN. SO DRAW THE TURTLE
	JSR	PC,DR.TUR
.ENDC

DRTRET:	SEZ
	RTS	PC

;SETHEAD
;	LIKE RIGHT, EXCEPT SET CURA TO ARGUMENT
SETHEAD:	GTJUMP GTSETH
	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;NUMERIC ARGUMENT IN B
	BR	DRT.HD	;JUMP INTO RIGHT

;WRAPAROUND
.IFNZ NDISP

WRAP:	
.IFNZ TVS
	BIT #TVF, DFLAGS
	BEQ WRNTVE
	JSR PC, ETVTUR
WRNTVE:
.ENDC
	BIS #WRAPF, DFLAGS
	BIC #CLIPF, DFLAGS
.IFNZ TVS
	BIT #TVF, DFLAGS
	BEQ WRNTVD
	JMP DTVTUR
WRNTVD:
.ENDC
	SEZ
	RTS PC

;CLIPMODE
.IFNZ TVS

CLIP:	JSR PC,TVTEST		;TVS ONLY
	BIT #TVF, DFLAGS
	BEQ CLNTVE
	JSR PC, ETVTUR
CLNTVE:
	BIC #WRAPF,DFLAGS
	BIS #CLIPF,DFLAGS
	BIT #TVF, DFLAGS
	BEQ CLNTVD
	JMP DTVTUR
CLNTVD:
	SEZ 
	RTS PC

NOCLIP:	JSR PC, TVTEST
.ENDC

NOWRAP:					
.IFNZ TVS
	BIT #TVF, DFLAGS
	BEQ BHNTVE
	JSR PC, ETVTUR			;Erase turtle over this.
BHNTVE:
.ENDC
	BIC #<WRAPF!CLIPF>, DFLAGS
	SETF				;In WRAP or CLIP modes, coordinates may be 
	SETI				;outside screen. Restore to within bounds.
	LDF DCURX, FB			;Subtract left edge to move origin to left.
	SUBF TRLEFT, FB			;Smash down coordinate modulo screen size.
	LDCIF #1., FA			;Reciprocate so MODF does division by TRSIZX.
	DIVF TRSIZX, FA
	MODF FA, FB			;FB=1 is odd, fractional part of product in FB.
	MULF TRSIZX, FB
	CFCC
	BGE BHXPOS
	ADDF TRSIZX, FB
BHXPOS:	ADDF TRLEFT, FB			;Move origin back.
	STF FB, DCURX			;Save as new XCOR.
	LDF DCURY, FB			;Similarly for YCOR.
	SUBF TRBOT, FB
	LDCIF #1., FA
	DIVF TRSIZY, FA
	MODF FA, FB
	MULF TRSIZY, FB
	CFCC
	BGE BHYPOS
	ADDF TRSIZY, FB
BHYPOS:	ADDF TRBOT, FB
	STF FB, DCURY 
.IFNZ TVS
	BIT #TVF, DFLAGS
	BEQ BHNTVD
	JMP DTVTUR
BHNTVD:	
.ENDC
	SEZ
	RTS PC


.IFZ FPPF



;HERE
;	OUTPUT A SENTENCE OF CURX,CURY,CURA
HERE:	JSR	PC,DCHKPL
	MOV	#CURX,D
	JSR	PC,PSHINT	;PUSH INTEGER OF CURX ONTO S-PDL
	JSR	PC,PSHINT	;PUSH INTEGER OF CURY
	MOV	(D),B	;CURRENT ANGLE
HERE.1:	JSR	PC,PSHNUM	;PUSH CURRENT ANGLE
HERE.2:	MOV	#3,D	;PUSH 3 ONTO P-PDL
	JMP	SENT.


;XCOR
;	OUTPUT THE X COORDINATE
XCOR:	JSR	PC,DCHKPL
	MOV	#CURX,D
	BR	YCOR1
;YCOR
;	OUTPUT THE Y COORDINATE
YCOR:	JSR	PC,DCHKPL
	MOV	#CURY,D
YCOR1:	JMP	R1INT	;RETURN INTEGER


;HEADING
;	RETURN THE CURRENT ANGLE
HEADING:	JSR	PC,DCHKPL
	MOV	CURA,B
	JMP	R1NARG
	;HOME -- SAME AS SETT [0 0 0]
HOME:	GTJUMP GTHME
	JSR PC,DCHKPL
	JSR PC,SPUSHT
	CLR D
	CLR E
	CLR F
	JMP SETT1

.IFF

HERE:	JSR PC,DCHKPL	;DOES HE OWN DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURX,D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
.ENDC
	JSR PC,WHOPIE	;PUT (F) INTO A NODE, POINTER IN B
	PUSHS B		;STORE POINTER TO FNUMS ON STACK
	JSR PC,WHOPIE	;DO IT AGAIN
	PUSHS B
.IIF Z DDF,	MOV (D),B	;STORE ANGLE (SNUM) ON STACK
.IIF NZ DDF,	MOV (F),B	;PUT ANGLE (SNUM) IN B
	JSR PC,PSHNUM	;PUT SNUM IN B ON S-PDL
	MOV #3,D	;PUSH A FLAG ON	
	JMP SENT.	;CHANGE THE THREE THINGS INTO A SENTENCE

XCOR:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IIF Z DDF,	MOV #CURX,D	;PUT POINTER TO CURRENT X IN D
.IIF NZ DDF,	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	BR YCOR1	;GET NUMBER AND RETURN

YCOR:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURY,D	;PUT POINTER TO CURRENT Y IN D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURY,F	;MAKE F POINT TO CURY
.ENDC
YCOR1:	JSR PC,WHOPIE	;PUT NUMBER INTO A NODE,POINTER RETURNED IN B
	JMP ORTB	;PUT POINTER IN B ON S-PDL

HEADING:
	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV CURA,B	;PUT POINTER TO ANGLE IN B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURA,F	;MAKE F POINT TO CURA
	MOV (F),B	;MOVE CURA TO B
.ENDC
	JMP R1NARG	;RETURN B

HOME:	GTJUMP GTHME
	CLR -(P)	;SETTURTLE [0 0 0]
	CLR -(P)
	CLR -(P)
	CLR -(P)
	CLR -(P)
	JMP SETT2	;SET THE TURTLE!

	;TAKES FNUM POINTED TO BY F, AND PUTS IT IN A NODE
	;RETURNS POINTER TO IT IN B
WHOPIE:	SPUSH C
.IFZ DDF
	MOV (D)+,A
	MOV (D)+,B
.IFF
	MOV (F)+,A	;PUT FNUM IN A AND B
	MOV (F)+,B
.ENDC
	JSR PC,GRBAD	;PUT FNUM IN NODE SPACE
	BIS #FNUM,C	;SET APPROPRIATE TYPE
	MOV C,B		;PUT POINTER IN B
	SPOP C
	RTS PC

.ENDC

;PENP
;RETURNS TRUE IF THE PEN IS DOWN
;RETURNS FALSE IF IT IS UP
PENP:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
	BIT #PENUF,DFLAGS	;IS THE PEN UP?
	BNE PENP1	;YES
	JMP RTTRUE	;NO, RETURN TRUE
PENP1:	JMP RTFALS	;YES, RETURN FALSE
.IFNZ NDISP


;	HIDETURTLE
HIDETURTLE:
	BIT #HIDETF, DFLAGS
	BNE STRETURN
	GTJUMP GTHIDE
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY??

.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV?
	BEQ 1$		;NO
	JMP TVHIDE	;YES, DO THINGS FOR TV
1$:
.ENDC

	BIS	#HIDETF,DFLAGS	;SET THE HIDETURTLE FLAG
	MOV	#DPOP!DSTOP,@TUB
	BR STRETURN


;	SHOWTURTLE
SHOWTURTLE:
	BIT #HIDETF, DFLAGS
	BEQ STRETURN
	GTJUMP GTSHOW
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ NTVST	;NO
	JMP TVSHOW	;YES, SHOW THE TV TURTLE
.ENDC
;HAVE TO DRAW THE TURTLE
NTVST:	BIC	#HIDETF,DFLAGS	;CLEAR THE FLAG FIRST
	JSR	PC,DR.TUR
STRETURN:
	SEZ
	RTS PC

.ENDC


;	DISPLAY PENUP
DPU:	BIS #PENUF,DFLAGS	;SET PEN UP FLAG
.IFNZ TVS
	BIC #<XORF!ERASEF>, DFLAGS
	MOV #-1., WINDATA
.ENDC
.IFNZ DDF
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING A DISPLAY?
	BEQ DPU1	;NO
	BIS #PENUF,DPENP	;SET PEN UP FLAG IN DISPLAY VARIABLES
	BR DPR			;RETURN
DPU1:	BIS #PENUF,PLPENP	;SET PEN UP FLAG IN PLOTTER VARIABLES
.ENDC
DPU3:	BIT #DISPF,DFLAGS	;DISPLAY?
	BNE DPU2		;YES, FORGET IT
.IFZ DDF
	SPUSH CURY+2
	SPUSH CURY
	SPUSH CURX+2
	SPUSH CURX
.IFF
	SPUSH PCURY+2
	SPUSH PCURY
	SPUSH PCURX+2
	SPUSH PCURX
.ENDC
	JSR PC,MOVETO	;HAVE TO SEND MOVE COMMAND TO PLOTTER TO TOGGLE PEN
DPU2:	
	SEZ
	RTS PC


;Display PENDOWN

DPD:	BIC #<PENUF!XORF!ERASEF>, DFLAGS	;Clear display pen up flag.
.IFNZ TVS
	BIT #TVF,DFLAGS		;KILL
	BEQ DPDHEN		;HENRY
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ DPDBW
DPDCOL:	JSR PC, SELPEN		;(SELECT-COLOR :PENNUMBER)
	SEZ
	RTS PC
.ENDC
DPDBW:	JSR PC, IORMODE		;Draw lines in IOR mode.
.ENDC
DPDHEN:
.IFNZ DDF
	BIT #DISPF,DFLAGS
	BEQ DPD1
	BIC #PENUF,DPENP
	BR DPR
DPD1:	BIC #PENUF,PLPENP
DPR:
.ENDC
	BR DPU2
.ENDC


;Display ERASERDOWN
.IFNZ TVS
ERASED:	JSR PC, TVTEST		;Check to see if on a TV.
	BIS #<ERASEF!PENUF>, DFLAGS
	BIC #XORF, DFLAGS	;Assign flags; Eraser on, pen, xor off.
.IFNZ COLOR
ERDCOL:	BIT #COLORF, DFLAGS
	BEQ ERDBW
	JSR PC, SELERA		;If in color, select eraer color.
	BR ERARET
.ENDC				;In B&W, eraser mode check is made by line drawer.
ERDBW:	JSR PC, SETMODE		;Eraser needs SET drawmode.
ERARET:	SEZ
	RTS PC

XORUP:				
ERASEU:	
	JSR PC, TVTEST
	BIS #PENUF, DFLAGS
	BIC #<ERASEF!XORF>, DFLAGS
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ ERUBW
	JSR PC, SELPEN
	BR ERARET
.ENDC
ERUBW:	JSR PC,IORMODE
	BR ERARET


;XORDOWN ROUTINE
XORDOWN: 
	JSR PC,TVTEST			;IS THIS A TV?
	BIS #<PENUF!XORF>, DFLAGS	;Pen is now up, xor is down.
	BIC #ERASEF, DFLAGS		;Eraser is up.
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BNE XDRET
.ENDC
	JSR PC, XORMODE		;SET DRAW MODE TO XOR
XDRET:	SEZ
	RTS PC

.ENDC


.IFNZ NDISP
;CLEARSCREEN--WIPE SCREEN AND RESTORE TURTLE TO [0 0 0]
CLEARSCREEN:	GTJUMP GTCLEA
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY
.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV?
	BEQ 1$			;NO
	JMP TVCS		;YES, DO THINGS FOR TV
1$:
.ENDC
	JSR	PC,WC.1	;WIPE IT CLEAN
	SPUSH DFLAGS
	MOV	#DORBEG,C	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,B	;INCLUDING CURX, CURY AND OTHERS
CSLOOP:	CLR	(C)+
	CMP	C,B
	BLT	CSLOOP

	SPOP DFLAGS
	CLR DFBCNT
	JSR	PC,TURDO	;DO ANGLE CRAP AND DRAW TURTLE IF SHOWN
	MOV	STB,STT
	MOV	PUSHJT,@STB
	JSR	PC,NEWSN2	;RECALCULATE STARTING POINT FOR SNAPS
	SEZ
	RTS PC

.IFZ FPPF
;SNAP

SNAP:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

;FIRST SET UP THE 3 NODE SNAP STRUCTURE ITSELF
	JSR	PC,PSHNUM	;FIRST NUMBER IS DUMMY FOR NOW
.IIF NZ DDF,	MOV	#DCURX,D
.IIF Z DDF,	MOV	#CURX,D
	JSR	PC,GETINT	;INTEGER OF CURX IN B
	SUB	OLDX,B	;TO GET DELTA X
	JSR	PC,PSHNUM	;PUSH ON S-PDL
	JSR	PC,GETINT	;INTEGER OF CURY
	SUB	OLDY,B	;TO GET DELTA-Y
	JSR	PC,PSHNUM
	MOV	#3,D	;NUMBER OF ARGS TO SENTENCE
	JSR	PC,SENT.

.IFF
	;CALCULATES DX AND DY, AND PUTS POINTERS TO THEM ON S-PDL
OLD:	JSR PC,(PC)	;DO THIS TWICE
	SETF
	LDF (D)+,FA	;SECOND TIME IT POINTS TO CURY
	SUBF (F)+,FA	;SECOND TIME POINTS TO OLDY
	STF FA,-(P)	;PUT DX OR DY ON STACK
	SPOP A		;PUT FNUM IN A,,B
	SPOP B
	SETD
	JSR PC,GRBAD	;PUT A,,B IN NODE
	BIS #FNUM,C	;SET TYPE
	SPUSHS C	;PUT POINTER ON S-PDL
	RTS PC


SNAP:	GTJUMP GTSNP
	JSR PC,DCHK	;DOES HE OWN ADISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ 2$		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
2$:
.ENDC
1$:	JSR PC,PSHNUM	;PUSH SNAP POINTER
.IIF NZ DDF,	MOV	#DCURX,D	;D POINTS TO CURX
.IIF Z DDF,	MOV	#CURX,D		;DITTO
	MOV #OLDX,F	;E POINTS TO WHERE SNAP IS TAKEN FROM
	JSR PC,OLD	;CALCULATE DX AND DY OF SNAP
	MOV #3,D	;SET FLAG FOR SENTENCE
	JSR PC,SENT.	;MAKE THE THREE THINGS INTO A SENTENCE


.ENDC
;FALLS THROUGH
;FALLS IN
;NOW GRAB A NODE FOR THE SNLIST HACKING
	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BNE	SNAP.2
	MOV	#SNUM,A	;FIRST SNAP
	CLR	B	;CREATE SNAP LIST. FIRST NODE IS A DUMMY
	JSR	PC,GRBAD
	BIS	#LIST,C
	MOV	C,SNLIST
SNAP.2:	JSR	PC,.LDP1	;POINTER TO REST OF SNAP LIST
	JSR	PC,GRBAD	;STORE A NODE
	BIS	#LIST,C
	MOV	C,GCP1	;GARBAGE COLLECT PROTECT

;NOW TRANSFER THE DISPLAY CODE (YEAH)
	MOV	SNABOT,D	;BOTTOM OF STUFF TO BE SNAPPED
	JSR	PC,DYXFR	;TRANSFER THE DCODE. SKIP IF SUCCEEDS
	BEQ	SNAP.4	;COULDN'T FIND ENOUGH FREE MEMORY
SNAP.0:	TST	D	;IF 0
	BEQ	SNAP.3	;NO CODE MOVED

;CHECK THAT THIS SNAP WON'T CAUSE DISPLAY PDL OVERFLOW
	TST	-(D)	;POINTER TO SNAP
	CMP	-(D),#<<<DPDLL_-1>&77777>-1>	;DEPTH COUNTER
	BLE	SNAP.1
	CLR	GCP1
	ERROR+STDP	;SNAP TOO DEEP

;NOW GO BACK AND PUT THE SNAP ADDRESS IN RIGHT PLACES
SNAP.1:	TST	(D)+	;POINT D TO REF COUNTER
	INC	(D)+	;INC COUNTER THAT SAYS HOW MANY TIMES DISPLAYED
	MOV	GCP1,C	;NOW HACK SNLIST
	MOV	D,A
	JSR	PC,.STP2	;STORE ADDRESS IN 2ND WORD OF NODE
	MOV	C,A	;POINTER TO NODE
	BIC	#170000,A
	BIS	#SNUM,A
	MOV	SNLIST,C
	JSR	PC,.STP1	;STORE NEW NODE POINTER INTO FIRST NODE OF SNLIST

	CLR	GCP1


	MOV	@S,C	;NOW HACK THE SNAP STRUCTURE
	BIC	#170000,C
	BIS	#SNP,C
	MOV	C,@S	;PUT IN RIGHT DATA TYPE
;PUT ADDRESS OF SNAP INTO FIRST OF STRUCTURE
	JSR	PC,.LDP2	;A_POINTER TO FIRST OF STRUCTURE
	MOV	A,C
	CLR	A
	MOV	D,B
	BGE	SNAP.6	;SIGN EXTEND ADDRESS
	COM	A
SNAP.6:	JSR	PC,.STORE	;STORE ADDRESS OF SNAP AS FIRST OF STRUCTURE

;NOW COLLAPSE STATIC AREA AND DISPLAY THE SNAP
	MOV	#SNABOT,A	;MAKE SURE THERE IS ROOM FOR DISPLAY HERE
	JSR	PC,STXPND
	MOV	A,STT
	MAKEPJ	D
	MOV	PUSHJT,(A)
	MOV	D,-(A)
	CLR	-(A)
	CLR DFBCNT
	CLZ
	RTS PC


;SINCE NO DISPLAY CODE WAS MOVED, RETURN EMPTY SNAP
SNAP.3:	MOV	#SNP,@S
	CLR	GCP1
	CLZ
	RTS PC

SNAP.4:	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	SNABOT,D
	JSR	PC,DYXFR	;TRY TO TRANSFER D.CODE AGAIN
	BNE	SNAP.0	;SUCCESS!
SNAP.5:	CLR	GCP1
	ERROR+TML
.IFZ FPPF

;NEWSNAP
;SET UP FOR NEXT SNAP TO START HERE
NEWSNAP:	JSR	PC,DCHK
NEWSN1:
.IIF NZ DDF,	MOV	#DCURX,D	;ENTER HERE AS SUBROUTINE
.IIF Z DDF,	MOV	#CURX,D	;ENTER HERE AS SUBROUTINE
	JSR	PC,GETINT	;GET INTEGER OF CURX IN B
	MOV	B,OLDX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,OLDY

.IFF

NEWSNAP:	JSR PC,DCHK	;DOES HE OWN A DISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ 1$		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
1$:
.ENDC
NEWSN1:	;ENTER HERE AS SUBROUTINE
.IIF NZ DDF,	MOV	#DCURX,D	;GET POINTER TO CURX
.IIF Z DDF,	MOV	#CURX,D		;GET POINTER TO CURX
	MOV #OLDX,B		;GET POINTER TO OLDX
	MOV (D)+,(B)+	;PUT CURX AND CURY INTO OLDX AND OLDY
	MOV (D)+,(B)+
	MOV (D)+,(B)+
	MOV (D)+,(B)+

.ENDC

NEWSN2:	MOV	STT,SNABOT	;RESET SNAP BOTTOM TO TOP OF DISPLAY
	CLR DFBCNT
	SEZ
	RTS	PC	;EITHER RETURN FROM SUBROUTINE , OR JMP NORT

;DISPLAY A SINGLE SNAP

DISPLAY:	GTJUMP GTDIS
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ 2$		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
2$:
.ENDC
1$:	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP,CURX,CURY
	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY
.IFZ FPPF
	MOV	E,B
	ADD	CURX+2,B
	CLR	C	;FRACTION PART IS 0 (SEE SNAP)
	JSR	PC,CHKBND	;IS NEW X COR IN BOUNDS?
	MOV	F,B
	ADD	CURY+2,B
	JSR	PC,CHKBND	;IS NEW Y COR IN BOUNDS?
.IFF
	MOV F,B		;PUT POINTER TO DY IN B
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	STF FA,FB	;FB <- DY
	MOV E,B		;PUT POINTER TO DX IN B
	JSR PC,G1NUMS	;FA <- DX
	BNE .+4
DIPSEY:	.BUG.		;NO WAY IT SHOULD FAIL EITHER
.IIF NZ DDF,	MOV #DCURX,B	;PUT POINTER TO CURX IN B
.IIF Z DDF,	MOV #CURX,B
	SETF
	ADDF (B)+,FA	;GET NEW XCOR
	ADDF (B)+,FB	;GET NEW YCOR
	SETD
	STF FA,FD	;CHECK TO SEE IF XCOR IS IN BOUNDS
	JSR PC,CHKBND
	STF FB,FD	;CHECK TO SEE IF YCOR IS IN BOUNDS
	JSR PC,CHKBND
.IFTF
;NOW SEE IF THERE'S ENOUGH ROOM IN THE DISPLAY AREA
	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND
;FINALLY, WE CAN PLACE THE PUSHJ TO THE SNAP INTO THE DISPLAY LIST
DISRM:	INC	-2(D)	;INCREMENT THE REF COUNTER OF THE SNAP
	MOV	A,STT	;SET STATIC TOP TO HERE IN DLIST
	MOV	PUSHJT,(A)	;PUT PUSHJ TO TURTLE AT TOP OF DLIST
	MAKEPJ D
	MOV	D,-(A)	;PUT IN THE PUSHJ
	CLR	-(A)	;PRECEDE BY A NOP

;NOW, SET CURX AND CURY
.IFT

	ADD	E,CURX+2	;E HAD DX OF THE SNAP
	ADD	F,CURY+2	;F HAS DY OF THE SNAP
.IFF

.IIF NZ DDF,	MOV #DCURX,B	;B <- POINTER TO CURX
.IIF Z DDF,	MOV #CURX,B
	STCDF FA,(B)+	;PUT NEW XCOR INTO CURX
	STCDF FB,(B)+	;PUT NEW YCOR INTO CURY
	JSR PC,ROUNDER	;ROUND CURX,CURY AND PUT INTO RCURX,RCURY

.ENDC

	CLR DFBCNT
D.RET:	JSR	PC,SPOPT	;POP S
	SEZ
	RTS PC

;WIPE A SNAP

WIPE:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ 1$		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
1$:
.ENDC

	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP, X,  Y
	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY

.IFNZ FPPF

	MOV F,B		;B <- POINTER TO DY OF SNAP
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	LDD FA,FB	;FB <- DY
	MOV E,B		;B <- POINTER TO DX
	JSR PC,G1NUMS	;FA <- DX
	BEQ DIPSEY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	JSR PC,ROUND	;ROUND FA AND FB
	SETI
	STCFI FA,E	;E <- DX OF THE SNAP
	STCFI FB,F	;F <- DY OF SNAP
	SETL
.ENDC
	BIC	#176000,E	;CLEAR TOP 6 BITS
	BIS	#ADDX,E	;AND TURN INTO ADDX COMMAND
	BIC	#176000,F	;CLEAR TOP 6 BITS
	BIS	#ADDY,F	;TURN INTO ADDY

	MOV	D,B
	TST	-(D)	;POINT D TO SNAP'S REF COUNTER
	MAKEPJ B	;MAKE B INTO DPUSHJ TO SNAP
	MOV	STT,A	;POINTER TO TOP OF DISPLAY LIST
	MOV	STB,C	;POINTER TO BOTTOM OF DLIST

WIPE.L:	CMP	A,C	;ARE WE AT THE BOTTOM YET?
	BLO	D.RET	;YES, SO WE ARE DONE
	CMP	B,-(A)	;IS THE NEXT WORD A PUSHJ?
	BNE	WIPE.L	;NO.  LOOP BACK AND TRY ANOTHER
;YES!  IT IS A PUSHJ
;PUT ADDX AND ADDY COMMANDS INTO DLIST
	INC	NADXY	;NADXY IS ACOUNTER TO TELL WHEN TO COMPRESS
	MOV	F,(A)	;INSERT ADDY MADE FROM DY OF SNAP
	MOV	E,-(A)	;INSERT ADDX MADE FROM DX OF SNAP

	DEC	(D)	;DECREMENT REF COUNTER
	BR	WIPE.L	;AND THEN LOOP BACK TO SEE IF THERE'S ANOTHER
;			PUSHJ TO THIS SNAP


;WIPE THE ENTIRE DISPLAY

WIPECLEAN:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

.IFNZ TVS
	BIT #TVF,DFLAGS
	BEQ 1$		;NO
	JMP TVWC	;TO THE TV FUNCTIONS
1$:
.ENDC

WC.1:	MOV	STB,A	;POINTER TO BOTTOM OF DISPLAY LIST
	MOV	STT,B	;POINTER TO TOP OF DLIST
	MOV	#100000,E	;SMALLEST DPUSHJ
	MOV	#140000,F	;SMALLEST COMMAND BIGGER THAN PUSHJ

WC.LP:	CMP	B,A	;ARE WE AT BOTTOM YET?
	BLOS	WC.DUN	;YES, WE ARE DONE
	CMP	-(B),E	;IS NEXT WORD DOWN A PUSHJ?
	BLO	WC.LP	;NO, IT'S TOO SMALL
	CMP	(B),F
	BHIS	WC.LP	;NO, IT'S TOO BIG
;THIS WORD IS A PUSHJ
	MOV	(B),D	;MOVE	THE PUSHJ COMMAND INTO D
	MAKEAD D	;TURN INTO PDP-11 ADDRESS
	DEC	-(D)	;DECREMENT SNAP'S REF COUNTER
	BR	WC.LP	;LOOP BACK TO LOOK FOR MORE PUSHJ'S

;NOW PLACE ADDX AND ADDY COMMANDS IN THE DISPLAY LIST
;SO THAT THE TURTLE WILL STAY AT THE SAME PLACE IT WAS BEFORE THE WIPE

.IFZ FPPF

WC.DUN:	MOV	#CURX,D
	JSR	PC,GETINT	;GET INTEGER OF  CURX IN B
	SPUSH	B	;SAVE DX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,E	;PUT DY IN E
	SPOP	D	;PUT DX IN B
.IFF
WC.DUN:
.IIF NZ DDF,	MOV #RDCURX,F	;F <- POINTER TO RCURX
.IIF Z DDF,	MOV #RCURX,F
	LDCFD (F)+,FA	;FA <- RCURX
	LDCFD (F)+,FB	;FB <- RCURY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	SETI
	STCFI FA,D	;F <- RCURX
	STCFI FB,E	;E <- RCURY
	SETL
.ENDC
	MOV	STB,STT
	JSR	PC,MTO.AD	;PUTS THE ADD COMMANDS INTO THE DLIST
	JSR	PC,NEWSN1	;SO THAT SNAPS WILL START HERE

	RTS	PC
.ENDC
.STITL DISPLAY UTILITY ROUTINES

.IFZ FPPF


;CHKBND
;	CHECK BOUNDS.  ERROR IF B IS OFF SCREEN
;	ALSO ROUNDS B,,C
CHKBND:	BIT	#WRAPF,DFLAGS
	BNE	CBRND	;GO AND ROUND
	CMP	B,#200.
	BGE	CBIBIG	;INTEGER PART MAY BE TOO BIG
	CMP	B,#-200.
	BLT	ERROOB	;DUE TO THE FACT THAT FRACTION IS ALWAYS
			;POSITIVE, IF B=-200 THAT GUARANTEES IT IS IN
			;BOUNDS. (I HOPE)
CBRND:	ASL	C
	ADC	B
	RTS	PC
;HERE, THE INTEGER PART IS >= 200.
;SO IF THE FRACTION PART IS NON-ZERO, THAT WILL MEAN THAT THE ENTIRE
;NUMBER IS GREATER THAN 200
CBIBIG:	BGT	ERROOB	;INTEGER>200
	TST	C
	BEQ	CBRND
ERROOB:	ERROR+OOB

.IFF

CHKBND:	BIT #PLOTF,DFLAGS	;IS HE USING PLOTTER?
	BNE CHK1	;YES, IGNORE WRAP FLAG
	BIT #WRAPF,DFLAGS	;IS HE WRAPPING
	BNE CBRND	;YES, DON'T CHECK BOUNDS
CHK1:	CMPF #42110,FD	;IS 200 < FD?
	CFCC
	BLT ERROOB	;YES, ERROR
	CMPF #142110,FD	;IS -200 > FD?
	CFCC
	BGT ERROOB	;YES,ERROR
CBRND:	RTS PC
ERROOB:	ERROR+OOB	;OUT OF BOUNDS

.ENDC

.IFNZ NDISP

;STATIC AREA EXPAND.
;	IS THERE ROOM IN STATIC AREA FOR 2 DISPLAY WORDS?
;	RETURN POINTER TO NEW STATIC TOP IN A
STXPND:	PUSH	A
	MOV	(A),A	;ROUTINE IS CALLED WITH ADDRESS OF VARIABLE
	CMP	(A)+,(A)+	;A _ A+4
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN8	;THERE'S ROOM!
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	@(SP)+,A	;AND TRY AGAIN
	CMP	(A)+,(A)+
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN9
	ERROR+TML	;TOO MANY LINES
STXPN8:	TST	(SP)+	;POP OFF A
STXPN9:	RTS	PC

.ENDC


;MOD360
;	OUTPUT B MOD 360 IN B.
;	ALWAYS OUTPUTS A POSITIVE NUMBER
MOD360:	TST B
	SXT A
	DIV #360.,A	;DIVIDE B BY 360
	TST B		;REM >= 0?
	BGE	M360R
	ADD	#360.,B	;IF REMAINDER WAS NEGATIVE, ADD 360 TO IT
M360R:	RTS	PC


.IFZ FPPF

;MULCOS
;	RETURN A*COSINE OF CURA IN B,,C
MULCOS:	MOV	COSA,F
	BR	MULCS2
;MULSIN
;	RETURN A*SINE OF CURA IN B,,C
MULSIN:	MOV	SINA,F
MULCS2:	CLR	E
	ASL	F	;TURN INTO BOTTOM HALF OF DP NUMBER
	SBC	E	;MAKE E NEG. IF F WAS
	JSR	PC,.DPMUL
	NOP	1
	RTS	PC
.ENDC

;ANGCRP
;	CALCULATE ANGLE CRAP.
;	CALCULATE DIREC, SINA, COSA
ANGCRP:
.IFZ FPPF
	CLR E
.IFZ DDF
	MOV CURA,F	;DIVIDE CURA BY 90.
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	MOV CURA(F),F	;F <- CURX
.ENDC
	DIV #90.,E
	MOV F,C		;THE REMAINDER
	MOV E,F		;THE QUOTIENT
	MOV #90.,E	;THE RIGHT ANGLE
	SUB	C,E	;NOW E = 90.- REMAINDER
	MOV	C,A	;A_REMAINDER
	JSR	PC,SINGET	;D_SIN (A)
	MOV	D,B
	MOV	E,A
	JSR	PC,SINGET
	ASL	F	;F = 0,1,2,3
	ADD	F,PC	;JUMP THROUGH THIS DISPATCH TABLE
	BR	ACR.D
	BR	ACRII	;QUADRANT II
	BR	ACRIII	;QUADRANT III
;FOURTH QUADRANT
	MOV	B,A	;SIN (A)
	MOV	D,B	;SIN (90-A)
	NEG	B	;SINA=-SIN(90-A) IN 4TH QUADRANT
	MOV	A,D	;AND COSA=SIN(A) IN 4TH QUADRANT
	BR	ACR.D

;THE THIRD QUADRANT
ACRIII:	NEG	B	;SINA = -SIN (A) IN 3RD QUADRANT
	NEG	D	;COSA = - SIN (90-A) IN 3RD QUADRANT
	BR	ACR.D

;SECOND QUADRANT
ACRII:	MOV	B,A	;SIN (A)
	MOV	D,B	;SINA = SIN (90-A) IN 2ND QUADRANT
	MOV	A,D
	NEG	D	;COSA = -SIN (A) IN 2ND QUADRANT

;IN THE FIRST QUADRANT
;SINA = SIN (A) AND
;COSA = SIN (90-A)
ACR.D:	MOV	B,SINA
	MOV	D,COSA

;FALLS THROUGH
;FALLS IN

;CLACULATE DIREC FROM STUFF LEFT IN F AND C BY ANGCRP
ANGDIR:	CMP	#45.,C
	ADC	F	;CARRY SET IF C<45
	ASL	F
	ASL	F
	ASL	F
	MOV	F,DIREC
	RTS	PC

;GET SIN (A) INTO D.
;THE SINE TABLE HAS ONLY EVEN ANGLES.  INTERPOLATE ODD ANGLES.
SINGET:	BIT	#1,A	;ODD OR EVEN
	BEQ	AEVEN
	ADD	#<SIN+1>,A	;POINT TO ANGLE AFTER IT
	MOV	(A),D	;SIN (A+1)
	ADD	-(A),D	;PLUS SIN (A-1)
	ROR	D	;DIVIDED BY 2
	RTS	PC
AEVEN:	MOV	SIN(A),D
	RTS	PC

.IFF
	SETI
.IFZ DDF
	LDCIF CURA,FA	;ANGCRP FOR FLOATING DISP
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	LDCIF CURA(F),FA	;FA <- CURA
.ENDC
	SETL
	STF FA,FE	;SAVE ANGLE
	JSR PC,SINDEG	;FA <- SIN (FA)
.IIF Z DDF,	STCDF FA,SINA
.IIF NZ DDF,	STCDF FA,SINA(F)	;SINA <- SINE OF ANGLE
	LDD FE,FA	;GET ANGLE
	JSR PC,COSDEG	;FA <- COS (FA)
.IIF Z DDF,	STCDF FA,COSA
.IIF NZ DDF,	STCDF FA,COSA(F)	;COSA <- COSINE OF ANGLE
	ASL C		;CALCULATE DIRECTION
	ASL C
	MOV C,DIREC
 	RTS PC






;XYDIR
;	CALL WITH D=DX, E=DY
;	CALCULATE DIREC BASED ON DX AND DY
XYDIR:	CLR	A	;BUILD INDEX IN A
	TST	D	;IS DX POSITIVE
	BGE	XYDIR1
	NEG	D	;ABSOLUTE VALUE OF DX
	TST	(A)+	;PUT 2 INTO A
XYDIR1:	TST	E	;IS DY POSITIVE
	BGE	XYDIR2
	NEG	E	;ABSOLUTE VALUE OF DY
	INC	A	;INCREMENT INDEX
XYDIR2:	CMP	D,E	;WILL GENERATE CARRY IF D<E
	ROL	A	;PUT CARRY INTO BOTTOM BIT OF INDEX.  AND MULTIPLY REST BY 2
	MOVB	DREC(A),DIREC	;NOW MOVE THE RIGHT THING INTO DIREC
	RTS	PC




.IFNZ NDISP

;DYXFR
;	TRANSFER FROM STATIC AREA TO DYNAMIC AREA
;	THE CODE BEING TRANSFERRED STARTS AT D AND GOES UP TO STT
;	ON RETURN, D POINTS TO THE TRANSFERRED DCODE
;	IF NO CODE WAS TRANSFERRED, THEN D = 0.
;	SKIPS IF THERE'S ROOM FOR TRANSFER
DYXFR:	MOV	STT,E
	SUB	D,E	;LENGTH OF DCODE TO BE MOVED
	BEQ	DYRET	;NOTHING TO BE MOVED
;ALLOCATE STORAGE
;LENGTH OF BLOCK TO BE ALLOCATED IS IN E
DYAL:	ADD	#6,E	;INCREASE LENGTH TO ALLOW FOR REF CNTR, DEPTH CNTR, AND POPJ
	MOV	DYR,B	;INITIALIZE POINTER
	MOV	#1,C	;INITIALIZE FLAG
DYAL1:	MOV	2(B),A	;POINTER TO NEXT FREE BLOCK
	BNE	DYAL2
	DEC	C	;NO NEXT FREE BLOCK--TEST AND SET FLAG
	BNE	DYAL7	;NO MORE ROOM--GO TO EXPAND DY AREA
	MOV	DYB,B	;START AGAIN AT BOTTOM OF LIST
	BR	DYAL1
DYAL2:	MOV	(A),F	;FREE BLOCK FOUND--CHECK LENGTH
	SUB	E,F
	BPL	DYAL4
DYAL3:	MOV	A,B	;BLOCK TOO SHORT--MOVE TO NEXT BLOCK
	BR	DYAL1
DYAL4:	BNE	DYAL5	;BLOCK LONG ENOUGH--IF FILLED EXACTLY
	MOV	2(A),2(B)	;REMOVE BLOCK FROM LIST BY CHANGING POINTERS
DYAL5:	CMP	F,#2	;DONT LEAVE A BLOCK OF LENGTH 2 BYTES
	BEQ	DYAL3
	MOV	F,(A)	;NEW LENGTH OF FREE BLOCK
	MOV	2(B),C	;RESET ROVING POINTER
	BNE	DYAL6	;DONT SET IT TO O
	MOV	DYB,C
DYAL6:	MOV	C,DYR	
	ADD	F,A	;START STORING AT THIS ADDRESS
	BR	DYAL9
DYAL7:	MOV	DYB,A	;ADD NEW BLOCK TO BOTTOM OF LIST
	MOV	2(A),F	;POINTER TO 2ND FREE BLOCK
	SUB	E,A
	CMP	A,STT
	BHI	DYAL8	;THERE IS ENOUGH ROOM IN THE DY AREA
	SEZ
	RTS	PC	;NOT ENOUGH ROOM
DYAL8:	MOV	A,DYB	;NEW BOTTOM OF DY
	MOV	A,DYR	;FIX ROVING POINTER
	MOV	DYB,C	;SET UP NEW LIST BOTTOM
	CLR	(A)+
	MOV	F,(A)+
DYAL9:	SUB	#6,E	;RESTORE LENGTH


;NOW A CONTAINS ADDRESS OF FREE BLOCK
;E CONTAINS NUMBER OF BYTES TO BE TRANSFERRED
;NOW FINALLY YOU GET TO DO THE TRANSFER
;WHILE YOU DO IT, INCREMENT THE REF COUNTER OF ANY PUSHJ'S
DYXFR1:	MOV	#100000,C	;THE CODE FOR DISPLAY PUSHJ
	MOV	#140000,B	;NEXT HIGHER DISPLAY COMMAND
	SPUSH	A	;SAVE POINTER TO DEPTH COUNTER
	CLR	(A)+	;DEPTH_0
	CLR	(A)+	;SET REFERENCE COUNTER TO ZERO
	ASR	E	;E/2 = NUMBER OF WORDS TO BE TRANSFERRED
;PICK UP A WORD.  SEE IF ITS A PUSHJ. AND TRANSFER IT
DYXFR2:	DEC	E	;NUMBER OF WORDS TO BE XFRED
	BLT	DYXFR3
	MOV	(D)+,F	;WORD OF DCODE IN F
	MOV	F,(A)+	;PUT THIS WORD IN ITS NEW PLACE
	CMP	F,C
	BLO	DYXFR2	;NOT A PUSHJ
	CMP	F,B
	BHIS	DYXFR2	;NOT A PUSHJ
;IT IS A PUSHJ
	MAKEAD	F
	INC	-(F)	;INCREMENT THE REF COUNTER
	CMP	-(F),@(SP)	;DEPTH _ MAX (DEPTH OF SUB SNAPS)
	BLE	DYXFR2
	MOV	(F),@(SP)	;DEPTH OF SUB SNAP BIGGEST YET
	BR	DYXFR2	;LOOP BACK

;ALL TRANSFERRING DONE.  END THE BLOCK WITH A POPJ
DYXFR3:	MOV	#DPOPJ,(A)
	SPOP	D	;POINTER TO DEPTH COUNTER
	INC	(D)+
	TST	(D)+	;POINTER TO FIRST D.WORD OF SNAP
	CLZ
	RTS PC	;AND RETURN

;THERE WAS NOTHING TO BE MOVED
DYRET:	CLR	D	;TO SIGNAL THIS FACT
	CLZ
	RTS PC

;DYFREE
;	CALLED DURING GARBAGE COLLECTIONS
;	CALL WITH D POINTING TO REF COUNTER (WORD BEFORE SNAP)
;	FREES THE BLOCK!!
DYFREE:	PUSH	A	;SAVE REGISTERS
	SPUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F

	MOV	#100000,A
	MOV	#140000,B
	MOV	#DPOPJ,C
	JSR	PC,DYF1	;DOES THE FREEING
	JMP	RETF	;RESTORE AC'S AND RETURN TO OUT OF DYFREE

;REAL WORK OF FREEING STARTS HERE.
DYF1:	MOV	D,-(SP)	;SAVE PTR TO 2ND WORD OF BLOCK
	TST	(D)+	;POINT D TO FIRST WORD

;PICK UP EACH WORD OF BLOCK.  IF IT IS A PUSHJ, FREE THAT BLOCK
;CONTINUE UNTIL A POPJ IS REACHED
DYF11:	MOV	(D)+,F	;NEXT WORD
	CMP	F,A
	BLO	DYF11	;NOT PUSHJ OR POPJ
	CMP	F,B
	BHIS	DYF2	;NOT PUSHJ, BUT MAY BE POPJ

;	ITS A PUSHJ
	MAKEAD	F
	DEC	-(F)	;REF COUNTER
	BR DYF11	;LOOK AT NEXT WORD

;IS THE WORD A POPJ
DYF2:	CMP	F,C	;C CONTAINS A POPJ
	BNE	DYF11	;NOT A POPJ.  LOOK AT NEXT WORD
	SPOP	C	;POINTER TO 2ND WORD OF BLOCK
	TST	-(C)	;NOW IT POINTS TO BOTTOM WORD
	SUB	C,D	;LENGTH OF BLOCK
	MOV	D,F


;NOW LINK BLOCK BACK TO FREE CORE
;C/ADDRESS OF BLOCK TO BE LIBERATED
;F CONTAINS LENGTH OF BLOCK

DYLIB:	MOV	DYB,B	;INITIALIZE POINTER TO BOTTOM OF LIST
DYLIB1:	MOV	2(B),A	;NEXT FREE BLOCK
	BEQ	DYLIB3	;AT END OF LIST
	CMP	A,C
	BHI	DYLIB2	;PASSED BLOCK TO BE FREED
	MOV	A,B	;TRY NEXT FREE BLOCK
	BR	DYLIB1
DYLIB2:	MOV	F,D	;CHECK UPPER BOUND
	ADD	C,D	;DO WE COLLAPSE NEW BLOCK WITH NEXT ONE?
	CMP	D,A
	BNE	DYLIB3	;NO
	ADD	(A),F	;YES--NEW LENGTH
	MOV	2(A),2(C)	;NEW POINTER
	CMP	A,DYR	;DID WE JUST SCREW ROVING POINTER?
	BNE	DYLIB4
	MOV	DYB,DYR	;YES--RESET IT
	BR DYLIB4
DYLIB3:	MOV	A,2(C)	;POINTER TO NEXT FREE BLOCK--NO COLLAPSE ON TOP
DYLIB4:	MOV	(B),D	;CHECK LOWER BOUND
	ADD	B,D
	CMP	D,C	;DO WE COLLAPSE WITH BLOCK ON BOTTOM?
	BNE	DYLIB5	;NO
	ADD	F,(B)	;NEW LENGTH OF PREVIOUS BLOCK
	MOV	2(C),2(B)	;NEW POINTER
	BR	DYLIB6
DYLIB5:	MOV	C,2(B)	;POINTER IN PREVIOUS BLOCK--NO COLLAPSE
	MOV	F,(C)	;LENGTH OF BLOCK JUST FREED
DYLIB6:	MOV	C,A	;DID WE JUST FREE BOTTOM BLOCK IN DY?
	SUB	#4,A
	CMP	A,DYB	;NOTE THAT IF CURRENT BLOCK = DYB+4
			;THEN PREVIOUS BLOCK (ADDR IN B) MUST BE DYB
	BNE	DYLIB7	;NO
	ADD	(C),B	;YES--COLLAPSE DY AREA
	CLR	(B)
	MOV	2(C),2(B)	;NEW BOTTOM BLOCK
	MOV	B,DYB
	MOV	B,DYR	;FIX POINTERS
DYLIB7:	RTS	PC


;DSGCF
;	CALLED BY LOGO GARBAGE COLLECTOR WHEN ITS ALL DONE
;	SEE IF EACH SNAP ON THE SNAP LIST WAS MARKED.
;	AND DYFREE THE SNAP IF NOT MARKED AND IT'S REFERENCE COUNTER IS 0

DSGCF:	CLR	F
	BR	DSGC1

DSGC4:	TST	F	;0 IF FIRST TIME THROUGH
	BEQ	DSGC5

;
;CODE FROM DSGC8 - DSGC9 GETS CALLED BY DCHK TO COMPRESS DISPLAY AREA
;
DSGC8:	MOV	STB,A	;COMPRESS ADDX'S AND ADDY'S IN STATIC AREA
	MOV	SNABOT,B	;FIRST DO PART BELOW SNAP BOTTOM
	JSR	PC,ADDSHK
	MOV	C,SNABOT	;C IS NEXT LOCATION TO STORE INTO
	MOV	STT,B	;NOW DO PART ABOVE SNAP BOTTOM
	JSR	PC,ADHK0	;DON'T RECLOBBER C.
	MOV	(A),(C)	;STORE PUSHJ TURTLE, TOO
	MOV	C,STT
	CLR	NADXY

DSGC9:	RTS	PC
DSGC5:	MOV	#<DSGC6-DSGCF1>,F	;NOW CLEAR MARKED BITS
DSGC1:	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BEQ	DSGC8	;OBVIOUSLY DOESN'T HAVE SNAPS

	JSR	PC,.LOADC	;FIRST NODE OF LIST IS DUMMY
DSGC2:	MOV	C,E	;SAVE POINTER TO NODE
DSGC3:	BIT	#7777,A	;LEAVE ADDRESS ONLY
	BEQ	DSGC4	;END OF LIST
	MOV	A,C	;POINTER TO NEXT NODE
	JSR	PC,.LOADC
	ADD	F,PC	;CHOOSE BETWEEN FREEING AND CLEARING

;TRY TO FREE THE SNAP
DSGCF1:	TST	-(B)	;WAS SNAP MARKED?  (B POINTS TO REF COUNT)
	BNE	DSGC2	;EITHER DISPLAYED OR MARKED

;NOT MARKED, AND NOT DISPLAYED ANYWHERE!!
;FREE THIS SNAP
	JSR	PC,.FREE	;CLEAN UP SNLIST
	MOV	E,C	;POINTER TO PREVIOUS NODE OF SNLIST
	JSR	PC,.STP1	;STORE A AS TOP WORD OF PREVIOUS NODE
	MOV	B,D	;POINTER TO SNAP DCODE
	JSR	PC,DYFREE
	BR	DSGC3

DSGC6:	BIC	#100000,-(B)	;CLEAR MARKED BIT
	BR	DSGC3

;ADDS HACK
;	COMPRESS ADDX'S AND ADDY'S STARTING AT LOCATION IN A
;	AND GOING TO LOCATION IN B. (DOESN'T STORE WORD AT LOC IN B)
ADDSHK:	MOV	A,C	;C IS NEXT LOC TO STORE INTO.
ADHK0:	CLR	-(SP)	;FLAG. (NOT IN MIDDLE OF ADD'S)
ADHK1:	CMP	A,B	;ARE WE DONE?
	BHIS	ADFIN	;YES
	MOV	(A)+,D	;NEXT WORD
	CMP	D,#ADDY
	BLO	ADNOT	;NOT AN ADD
	TST	(SP)	;IN MIDDLE OF ADD'S ALREADY ?
	BNE	ADPHS1	;YES
	CLR	E	;NO. THIS IS FIRST ADD
	CLR	F
	INC	(SP)	;SET FLAG
ADPHS1:	CMP	D,#ADDX	;THE BIGGER ADD COMMAND
	BHIS	ADPHSX
;IT IS AN ADDY
	ADD	D,F	;ADD THE DELTA-Y INTO F
	BR	ADHK1	;LOOP BACK
ADPHSX:	ADD	D,E	;ADD THE DELTA-X INTO E
	BR	ADHK1

ADNOT:	TST	(SP)
	BEQ	ADHK2	;NOT END OF ADD'S
	JSR	PC,ADPHSF	;JUST ENDED ADDS.
	CLR	(SP)
ADHK2:	MOV	D,(C)+	;STORE THIS WORD
	BR	ADHK1

ADFIN:	TST	(SP)+	;ALL WORDS PICKED UP
	BEQ	ADHK3
	JSR	PC,ADPHSF	;BUT FIRST FINISH ADDS
ADHK3:	RTS	PC

;ADD PHASE FINISHED.  STORE ADDX E, ADDY F.
ADPHSF:	BIC	#176000,E
	BIC	#176000,F
	BEQ	ADPF1	;DELTA-Y = 0
	BIS	#ADDY,F
	MOV	F,(C)+	;STORE ADDY
ADPF1:	TST	E
	BEQ	ADPF9	;DELTA-X = 0
	BIS	#ADDX,E
	MOV	E,(C)+	;STORE ADDX
ADPF9:	RTS	PC


;MKDC
;	CALLED BY LOGO GARBAGE COLLECTOR DURING MARKING PHASE
;	CALLED WITH B POINTING TO SNAP NODE
MKDC:	TST	SNLIST	;CALLED TO KILL THE DISPLAY?
	BEQ	MKDC.K	;YES
	BIT	#7777,B
	BEQ DSGC9	;EMPTY SNAP
;MARK THE SNAP
	PUSH	A
	SPUSH	B
	JSR	PC,.LOAD	;POINT B TO NODE CONTAINING SNAP ADDR
	TST B
	BEQ MKDC1
	JSR	PC,.LOAD	;B_SNAP ADDRESS
	BIS	#100000,-(B)	;MARK REF COUNTER
MKDC1:	SPOP	B	;RESTORE A AND B
	SPOP	A
	RTS	PC

;CALLED BY KILLDISPLAY
;TURN SNAP INTO EMPTY SNAP
MKDC.K:	SPUSH	A
	SPUSH	B
	SPUSH	C
	MOV	B,C	;POINTER TO DCODE NODE
	CLR	A
	JSR	PC,.STP2
	JMP	RETC



;HERE START THE LINE AND TURTLE DRAWING PROGRAMS

;DR.LIN
;	DRAW A LINE. D=DX, E=DY, OR VICE VERSA.
;	THE DIRECTION CODE FOR THE LINE IS IN DIREC
DR.LIN:	CMP DIREC,ODIREC
	BEQ 1$
	CLR DFBCNT
1$:	JSR	PC,DR.STUP	;SET A=CON, B=AC.
	SPUSH	D
	ADD	STT,D	;D = HOW MANY MORE WORDS IN DLIST
	CMP	D,DYB	;COMPARE TO DY BOTTOM
	BLO	DR.L1	;THERE'S ROOM
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	SPOP	D	;TRY TO FIT LINE AGAIN
	ADD	STT,D
	CMP	D,DYB
	BLO	DR.L2	;THERE'S ROOM!
	ERROR+TML	;TOO MANY LINES

;OKAY, THERE WAS ROOM FOR THE LINE
DR.L1:	TST	(SP)+	;WE HAD PUSHED D UP ABOVE
DR.L2:	MOV	D,STT	;SET STT TO NEW STATIC TOP
	MOV	PUSHJT,(D)	;PUT PUSHJ TURTLE AT TOP
	JSR	PC,DR.ASC	;ASSEMBLE THE DISPLAY CODE
	MOV DIREC,ODIREC
	RTS	PC	;RETURN


;DRAW THE TURTLE
DR.TUR:	PUSH DIREC
	SPUSH DFBCNT
	MOV	#TURSIZ,C	;TURTLE SIZE
.IFZ FPPF
	CLR	B
	JSR	PC,MULCOS	;E,,F _ SIZE * COSA
	ROL	F
	ADC	E	;ROUND
	MOV	E,D
	JSR	PC,MULSIN	;E,,F _ SIZE * SINA
	ROL	F
	ADC	E	;ROUNFD
.IFF
	SETI
	LDCIF C,FA
	SETL
.IIF NZ DDF,	LDCFD DSINA,FB
.IIF Z DDF,	LDCFD SINA,FB
	MULF FA,FB
	ADDF #40000,FB	;ROUND
.IIF NZ DDF,	LDCFD DCOSA,FC
.IIF Z DDF,	LDCFD COSA,FC
	MULF FA,FC
	ADDF #40000,FC
	SETI
	STCFI FB,E
	STCFI FC,D
	SETL
.ENDC

	SPUSH	D
	SPUSH	D
	SUB	E,2(SP)	;NOW SIZE * (COSA - SINA) IS ON STACK
	ADD	E,(SP)	;NOW SIZE * (COSA + SINA) IS ON STACK

	MOV	TUB,TUT	;TUT WILL BE POINTER TO TOP OF TURTLE DLIST SO FAR

;SIDE 1
	ADD	#20,DIREC	;SIDE 1 IS 2*45 DEGREES LEFT OF CURRENT DIRECTION
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 2
	SUB	#30,DIREC	;SIDE 2 IS 3*45 DEGREES RIGHT OF SIDE 1
	MOV	(SP)+,D	;DX IS SIZE * (COSA + SINA)
	MOV	(SP)+,E	;DY IS SIZE * (COSA - SINA)
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 3 HAS THE SAME INCREMENTS AS SIDE 2.
;JUST THE DIRECTION IS DIFFERENT
	MOV	DIREC,B
	SUB	#20,B	;SIDE 3 IS 2*45 DEGREES RIGHT
	BIC	#177707,B	;LEAVE ONLY THE 3 BITS
	SWAB	B	;PUT THE DIREC BITS IN TOP BYTE
	MOV	TUT,C	;POINTS TO WORD ABOVE LAST ONE OF TURTLE DLIST
	MOV	C,A
	SUB	D,C	;SINCE D POINTS TO BOTTOM WORD OF SIDE 2
			;C-D IS NUMBER OF BYTES IN SIDE 2'S DLIST
	ASR	C	;C/2 = NUMBER OF WORDS
DR.TS3:	MOV	(D)+,E	;NEXT WORD OF SIDE 2'S DLIST
	BIC	#34000,E	;CLEAR THE DIRECTION BITS THEREIN
	BIS	B,E	;AND SET THEM FROM THE NEW DIREC IN B
	MOV	E,(A)+	;STORE IN DLIST
	DEC	C	;NUMBER OF WORDS IN SIDE 2'S DLIST
	BGT	DR.TS3	;THERE ARE MORE WORDS

;SIDE 4 IS IDENTICAL TO SIDE 1
;FURTHERMORE, SIDE 1 IS MADE UP OF ONLY ONE WORD
	MOV	@TUB,(A)+	;PUT THE FIRST WORD OF TURTLE INTO TOP WORD
	MOV	#DSTOP!DPOP,(A)

;RESTORE DIREC, THEN RETURN
	SPOP DFBCNT
	POP DIREC
	RTS	PC


;DRAW TURTLE SIDE
;	DRAW ONE SIDE OF THE TURTLE
;	DIREC CONTAINS THE DIRECTION
;	TUT POINTS TO TOP OF TURTLE DISPLAY LIST SO FAR
;	C,D = + OR - DX OR DY
DR.TSD:	BIC	#177707,DIREC	;BITS MAY HAVE BEEN SET BY THE SUBTRACTING
	CLR DFBCNT
	JSR	PC,DR.STUP
	ADD	TUT,D	;D = NEW TOP OF TURTLE
	MOV	D,TUT
	JMP	DR.ASC	;ACTUALLY CREAT THE DISPLAY LIST


;SET UP CON AND AC
;	CALL WITH D,E = + OR - DX OR DY
;	PASSES ON A=FRACTION: MIN (DX/DY,DY/DX)
;		B=ACCUMULATED FRACTION PART SIDEWAYS OF MAIN DIRECT.
;		STARTS AT 1/2
DR.STUP:	TST	D
	BGE	DR.TE	;TEST E
	NEG	D	;MAKE D POSITIVE
;MAKE SURE E IS POSITIVE
DR.TE:	TST	E
	BGE	DR.BIG	;NEXT WE'LL SEE WHICH IS BIGGER
	NEG	E	;MAKE D POSITIVE

;WHICH IS BIGGER
DR.BIG:	CLR B		;CLEAR LOW WORD OF WHICHEVER NUMBER
	CMP	D,E
	BGT	DR.DBG	;D IS BIGGER
	BEQ	DR.EQ	;THEY ARE THE SAME SIZE

;OTHERWISE, E IS BIGGER
	ASL	E	;SO EAE WON'T OVERFLOW WITH A 16 BIT QUOTIENT
	MOV D,A		;DIVIDE D,,0 BY E
	DIV E,A
	MOV	E,F	;WHICHEVER IS BIGGER IS THE NUMBER OF INCS
	BR	DR.SC4

;THEY ARE THE SAME SIZE
DR.EQ:	MOV	#-1,A	;SET CON = .777...
	MOV	E,F	;NUMBER OF INCS
	BR	DR.SC5

;D IS BIGGER
DR.DBG:	ASL D
	MOV E,A		;DIVIDE E,,0 BY D
	DIV D,A
	MOV	D,F	;NUMBER OF INCS

;NOW PICK UP THE QUOTIENT
DR.SC4:	ASL	A	;MAKE QUOTIENT 16 BITS
	ASR	F	;SINCE WE DOUBLED IT ABOVE

;NOW SET AC = .1000 = 1/2 IN THIS REPRESENTATION
DR.SC5:	MOV	#100000,B
;FALLS IN!

;CALCULATE THE NEW END POINT OF THE DLIST
;	RETURNS A AND B AS ABOVE
;	C = BIT-POSITION OF LAST BIT OF NEW CODE
;	  (GENERATED BACKWARDS--STORE FROM HERE BACK)
;	D = NUMBER OF MORE WORDS IN DLIST
;	  (WILL BECOME ADDR OF LAST NEW WORD + 2)
;	E = TOP BYTE OF INCR INSTRUCTION, SWAPPED
;	F = # NEW INCREMENTS
DR.NEP:	CLR C		;CLEAR BIT-POSITION
	MOV F,E		;GET # OF INCREMENTS
	SUB DFBCNT,E	;LESS # LEFT OVER
	MOV E,D
	ASH #-3,D	;DIVIDE BY 8
	ASL D
	BIC #177770,E	;REMAINDER IS # BITS IN LAST WORD
	BEQ DR.NE2	;IF 0 THEN = 8 IN PREVIOUS WORD

	MOV #8.,DFBCNT	;ELSE FREE BITS = 8 - # USED
	SUB E,DFBCNT
	ADD #2,D	;ADD ONE-WORD FUDGE FACTOR IN THIS CASE
	SPUSH E
	SEC
DR.NE1:	RORB C		;SHIFT FIRST-BIT IN OR RIGHT ONE BIT
	DEC E		;SHIFT IT RIGHT (REMAINDER) PLACES
	BNE DR.NE1
	SPOP E
	BR DR.NE3

;REMAINDER WAS 0:  LAST WORD GETS FILLED UP
DR.NE2:	INC C		;LAST BIT IS LAST IN WORD
	CLR DFBCNT	;NO FREE BITS

DR.NE3:	ADD #DINC_-8,E	;PUT IN "INCREMENT" CODE
	ADD	DIREC,E	;ADD IN THE DIRECTION
	RTS	PC


;ACTUALLY ASSEMBLE THE NEW DISPLAY LIST
;	CALL WITH A=SIDEWAYS/FORWARD, B=1/2 (ACCUM SIDEWAYS),
;	C=FIRST BIT POS., D=POINTER  TO FIRST WORD TO STORE OF DLIST
;	E=TOP HALF OF THE INC MODE INSTRUCTION, F=NUMBER OF INCS
DR.ASC:	SWAB	E	;STUFF IN E WAS IN WRONG HALF
DR.AS0:	ADD	A,B	;CON+AC
	BCC	DR.AS1
	ADD	C,E	;CARRY, SO PUT A 1 INTO DCODE
DR.AS1:	DEC	F	;NUMBER OF INCS
	BLE	DR.ALW	;THIS WAS THE LAST WORD
	CLC
	ROLB	C	;SHIFT BYCNT
	BCC	DR.AS0	;CONTINUE WITH THIS WORD

;THIS WORD DONE
	JSR	PC,DR.SH
	MOV	E,-(D)	;STORE IN DLIST
	BIC	#3777,E	;0 THE COUNT AND BOTTOM BYTE
	MOV	#1,C	;RESET BYCNT
	BR	DR.AS0

;ALL THAT'S LEFT TO DO IS STORE THE BOTTOM WORD OF NEW DLIST
DR.ALW:	MOV -(D),B	;GET WORD TO HOOK
	CLR A		;SET UP BIT TO HOOK FROM
	SEC		;  "
DR.LW1:	ROL A		;  "  OR NEXT BIT TO HOOK FROM
	CLC
	ROLB C		;NEXT BIT TO HOOK INTO
	BCS DR.LW2	;DONE HOOKING
	BIT A,B		;GET BIT
	BEQ DR.LWX
	ADD C,E		;STORE IT
DR.LWX:	CLC		;SET UP FOR ROL A
	BR DR.LW1

DR.LW2:	JSR	PC,DR.SH	;SHOVE TO RIGHT END OF WORD
	MOV	E,(D)	;STORE LAST WORD
	RTS	PC

;SHIFT CODE RIGHT 8 MINUS COUNT TIMES

DR.SH:	PUSH	E
	SWAB E		;GET COUNT OF USED BITS
DR.SH1:	BIC #177770,E	;ISOLATE COUNT
	BEQ	DR.SH2	;DONE
	INC E		;COUNT UP; DONE AT 8 (OR 0)
	CLC
	RORB	(SP)	;MAKE ANOTHER FREE BIT AT LEFT
	BR	DR.SH1
DR.SH2:	POP	E
	RTS	PC

.ENDC
.ENDC


.IFNZ TVS
.SBTTL TV TURTLE ROUTINES
;;;;;;;;;;;;;;;;;;;;
;TV TURTLE ROUTINTES
;;;;;;;;;;;;;;;;;;;;

;THESE ROUTINES ARE USED TO PROCESS DISPLAY GRAPHICS FOR TVS.
;THE ROUTINES ARE IN MANY CASES BASED ON, AND TRY TO FOLLOW THE
;WORK OF HENRY LIEBERMAN WITH HIS TVRTLE ROUTINES FOR LLOGO.

FAKTVR:				;Move real TV register to Fake locations
				;for debugging. Symbols FAKADR, FAKWIN, FAKINC, ...
	MOV COLORA, FAKCLA
	MOV COLORD, FAKCLD
	MOV TVINCR, FAKINCR
	MOV TVSEL, FAKSEL
	MOV TVRADR, FAKADR
	MOV TVWDCN, FAKWDC
	MOV TVSHR, FAKSHR
	MOV TVMSK, FAKMSK
	MOV TVRWIN, FAKWIN
	MOV TVCNSO, FAKCNS
FAKEND:	RTS PC



TVSTRT:	JSR PC,TVINIT		;CREATE DISPLAY
TVSTR1:	MOV TVBOT,B		;EVERYTHING BELOW DISPLAY AREA CAN BE ECHO AREA
	JSR PC,CRECHO		;CREATE THE ECHO AREA IN SCREEN
	JSR PC,TVCS		;CLEAR SCREEN, RESET TURTLE
	LDFPS #40300		;RESET THE FLOATING POINT PROCESSOR
	SEZ
	RTS PC


;CREATE A DISPLAY CAPABILITY AND INITIALIZE VARIABLES
TVINIT:	JSR PC, IORMODE
CTVINIT:
	BIC #<PLOTF!HIDETF!TURTF!PENUF!XORF!ERASEF!WRAPF!CLIPF>,DFLAGS	
	CLR DPENP		;START WITH PENDOWN
	BIS #DISPF!TVF,DFLAGS	;WE ARE CONTROLING DISPLAY AND IT IS A TV DISPLAY
	BIS #DISPF,DIVOWN	;WE OWN A DISPLAY
	MOV #DORBEG,A
TVINI1:	CLR (A)+		;CLEAR OUT THIS AREA
	CMP A,#DOREND
	BLO TVINI1
	MOV #2.,TVTOP		;TOP OF DISPLAY AREA IS TV LINE 2
	MOV #302.,TVBOT		;BOTTOM OF DISPLAY AREA IS TV LINE 302
	MOV #273.,TVLEFT	;LEFT SIDE OF DISPLAY AREA IS LINE 138
	MOV #573.,TVRIGHT	;RIGHT SIDE OF DISPLAY AREA IS LINE 438
	MOV #301.,TVSIZY	;Y SIZE IS 300.
	MOV #301.,TVSIZX	;X SIZE IS 300.
	MOV #152.,TVCENY	;Y CENTER IS 152.
	MOV #423.,TVCENX	;X CENTER IS 288.
	MOV #301.,TVMIN		;SIZE OF TV PICTURE
	MOV #400.,TRMIN		;TURTLE PICTURE SIZE
	CLR TRCENX		;TURTLE PICTURE CENTER X
	CLR TRCENY		;TURTLE PICTURE CENTER Y
	MOV TVCENX,TVX
	MOV TVCENY,TVY		;THE DRAWER SHOULD GO INTO THE CENTER OF BOX
;	SAVE <TVX,TVY,DISCAP>
;	BIS #.TVDSS*400,(P)	;SET THE DRAWER TO THE RIGHT PLACE
;	$INVOK
	SETF
	SETI			;THE FOLLOWING STUFF IS IN SHORT INTEGER AND FLOAT MODE
	LDCIF #1.,FA
	STF FA,TRSCLX		;STORE 1 AS THE TURTLE SCALE
	STF FA,TRSCLY		;LIKEWISE
REINIT:	SETF
	SETI
	LDCIF TRMIN,FA		;TURTLE SIZE X(Y)=TURTLE SCASLE FACTOR X(Y)
	LDF TRSCLX,FB
	MULF FA,FB		;MULTIPLIED BY THE TURTLE MINIMUM DIMENSION
	STF FB,TRSIZX
	LDF TRSCLY,FC
	MULF FA,FC
	STF FC,TRSIZY
	LDCIF #-2,FD		;TURTLE LEFT BOUNDRY=TURTLE SIZE X/-2
	DIVF FD,FB
	STF FB,TRLEFT
	NEGF FB			;TURTLE RIGHT BOUNDRY= -TURTLE LEFT BOUNDRY
	STF FB,TRRIGH
	DIVF FD,FC		;TURTLE BOTTOM BOUNDRY=TURTLE SIZE Y/-2
	STF FC,TRBOT
	NEGF FC			;TURTLE TOP BOUNDRY= -TURTLE BOTTOM BOUNDRY
	STF FC,TRTOP
	LDCIF TVMIN,FB
	SUBF FLTTOL,FB
	SUBF FLTTOL,FB
	DIVF FB,FA
	STF FA,TRPRTV		;TURTLE PER TV = TRMIN / (TVMIN - FLOAT TOLERANCE * 2)
	LDCIF #15.,FB
	MULF FA,FB
	STF FB,TRFRAD
	LDCIF #10.,FB
	MULF FA,FB
	STF FB,TRSRAD
	RTS PC


;Color TV initializations. Follows Lisp TVRTLE and BEE;CLRTST programs.

.IFNZ COLOR

FLSBUF:				;Delete capabilities to display buffers in DSCAP table.
	MOV #PIXMAX, C		;Size of capability table for loop index.
	MOV #DSCAP, B		;Index into capability table.
FLBLUP:	MOV (B), A	
	CLR (B)+
	JSR PC, DELCP
	SOB C, FLBLUP
	RTS PC

COLORINIT:			;Color initialization.
	JSR PC, FLSBUF		;FLUSH ALL BUFFERS
	JSR PC, G1NARG		;Argument is number of buffers [bits per point].
	TST B
	BLT 1$
	CMP #4,B
	BGE 2$
1$:	ERROR+WTA
2$:
	CLR A
GRABUF:				;Magic SITS system call to grab a buffer.
	SAVE <#-1, #40377, #.DSCAP*400+0>
	.INVOK
	BNE GOTBUF
	ADD #6,P	;FLUSH ARGS TO FAILED CALL
	BR GOTBU1	;TERMINATE PREMATURELY
GOTBUF:
	REST <DSCAP (A), , DSNUM (A)>
	TST (A)+		;Stuff capabilities and associated buffer numbers
	SOB B, GRABUF		;in tables.

GOTBU1:	MOV A,B
	ASR B			;NUMBER OF BUFFERS WE REALLY GOT
	MOV DSCAP, A		;Pass along capability to one of the color buffers.
	JSR PC, TVRMAP		;Do the system call mapping in TV registers.
	MOV B, NCBITS		;Stow this in NCBITS.
	MOV #1, A
	ASH B, A		;(SETQ PALETTE-SIZE (LSH 1 NCBITS))
	MOV A, PALSIZ
	CLR PENNUM
	MOV A, ERANUM		;(SETQ :ERASERNUMBER (1-  PALETTE-SIZE))
	DEC ERANUM
	ASR A
	MOV A, NCSIGB		;High order color bit.
	RTS PC
				
CRESET:	JSR PC,INITCR		;Initialize video switch and console register.
	BIS #TVOFLO,TVINCR	;Mask to handle overlow correctly in TVINCR.
	JSR PC, SETMODE		;Choose SET drawmode [others don't make sense in color].
	MOV #-1., WINDATA	;Always write bits on [SETMODE clears WINDATA].
	BR CLRWRT		;Turn on color write mode.


INITCR:	CLR C			;Initialize console register and video switch.
	MOV NCBITS, B		;Do the following loop NCBITS times, for each buffer.
ICRLUP:	MOV DSNUM (C), D	;Retrieve buffer number from DSNUM table.
	MOV D, TVSEL		;Select that buffer.
	MOV CRMC (C), TVCNSO	;Move magic constant from table to console register.
	MOV C, E
	ASH #<-1.+8.>, E	;Construct word with buffer number in low order byte
	ADD E, D		;and word index in buffer table in high order byte,
	ADD VSWMC, D		;and magic constant added for video switch.
	MOV D, VIDSW
	TST (C)+
	SOB B, ICRLUP

	MOV #6,A	;THERE ARE SIX BITS IN THE COLOR MAP
	SUB NCBITS,A	;NUMBER OF BUFFERS WE SEEM TO HAVE
	ASH #7,C	;FOR NON-EX BUFFERS
	ADD #30_8,C	;MUST SWITCH TO NOTHINGNESS
	ADD #17,C	;I THINK THIS IS IT??
INITC2:	MOV C,VIDSW	;NOTHING FOR YOU
	ADD #1_8,C	;NEXT
	SOB A,INITC2	;THERE BETTER BE AT LEAST ONE COLOR BIT TO SWITCH TO NON-EX!!
	RTS PC


;FULSCREEN:			;For color, the default TV size should be whole screen.
;	MOV #450., TVBOT	;Change TV, TURTLESIZE default to whole screen.
;	MOV #2., TVLEFT
;	MOV #574., TVRIGHT
;	MOV #574., TVSIZX
;	MOV #449., TVSIZY
;	MOV #289., TVCENX
;	MOV #226., TVCENY
;	MOV TVCENX, TVX
;	MOV TVCENY, TVY
;	MOV #449., TVMIN
;	MOV #1000., TRMIN
;	SETF
;	SETI 
;	LDCIF #1000., FA
;	LDCIF #448., FB
;	DIVF FB, FA
;	STF FA, TRSCLX
;	JMP REINIT		;Redo TURTLESIZE to keep variables consistent.


.CLRINIT:			;.COLORINIT user primitive
	JSR PC, COLORINIT	;Additional initialization for color.
	SAVE B			;SAVE NUMBER OF BUFFERS WE GOT
	JSR PC, CTVINIT		;Do standard initializations for all TV's.
	JSR PC,CRESET		;DO EXTRA STUFF FOR COLOR
	BIS #COLORF, DFLAGS	;Set flag indicating use of color display.
CINIWON:
	LDFPS #40300		;Reset floating point processor [whatever that means].
	REST B
	JMP R1NARG

;WBLOCK: 			;[WRITE-TV-BLOCK] uses block mode of
;	TST C			;hardware to write lots of words at once.
;	BEQ WBLEND		;Arguments: ADDRESS, CONTENTS, ITERATIONS, STEP.
;	BIC #TVINC, TVINCR	;(WRITE-CONTROL-FIELD TVINCR-ADDRESS STEP TVINC-MASK)
;	BIS D, TVINCR
;	MOV A, TVRADR		;(WRITE-TV-WORD ADDRESS CONTENTS)
;	MOV B, TVRWIN
;	DEC C
;	TST C			;(COND ((ZEROP (DECREMENT ITERATIONS)) ...)
;	BEQ WBLINC
;	NEG C
;	MOV C, TVWDCN		;(WRITE-TV-WORD-COUNT (- ITERATIONS))
;WBWAIT:
;	BIT #TVWDCM, TVWDCN	;(DO NIL ((ZEROP (READ-TV-WORD-COUNT))))
;	BNE WBWAIT
;WBLINC:
;	BIC #TVINC, TVINCR	;(WRITE-CONTROL-FIELD TVINCR-ADDRESS 0. TVINC-MASK)
;WBLEND: RTS PC


CLRWRT: BIS #COLORW, DFLAGS	;Sets color write mode [COLOR-WRITE].
	BIS #TVCLRW, TVINCR	;Set color write bit in increment register.
	BR RESELC		;Reselect color.

NOCLRW:	BIC #COLORW, DFLAGS	;Turns off color write mode [NO-COLOR-WRITE].
	BIC #TVCLRW, TVINCR	;Falls thru to RESELECT-COLOR.
		
RESELC: BIT #ERASEF, DFLAGS	;Reselects the proper color in the palette
	BNE SELERA		;according to pen or eraser state [RESELECT-COLOR].
				;Falls through to SELECT-PEN.

SELPEN:	MOV PENNUM, A		;Select the pen color.
	BR SELCOL

SELERA:	MOV ERANUM, A		;Select the eraser color.
				;Falls thru to SELECT-COLOR.
SELCOL:				;Selects a current color from the palette or, 
SELBUF:				;Selects one of the TV buffers [same code].
				;[SELECT-COLOR, SELECT-TV-BUFFER]
	BIC #TVRCNS, TVSEL	
	BIS A, TVSEL		;Write the color or buffer number into the
	SEZ
	RTS PC			;console number field in the console select
				;register.

.COLOR: 			;User primitive to select a color in color map.
	JSR PC, G1NARG		;Returns fixpoint number in B.
	MOV B, A
	MOV A, PENNUM
	JMP SELCOL


;[WRITE-COLOR-MAP] Writes a new color into the color map. 
;Arguments: COLOR-MAP-SLOT, RED, GREEN, BLUE intensities.
;
;WCMAP:	SAVE A			;Save slot number.
;	MOV B, COLORD
;	BIS #CLRRED, A		;IOR slot number with red.
;	MOV A, COLORA		;Color written when address register written.
;	MOV C, COLORD
;	MOV (P), A		;Restore slot from stack, without popping.
;	BIS #CLRGREEN, A	;Or with green, 
;	MOV A, COLORA
;	MOV D, COLORD
;	REST A			;Pop off slot number.
;	BIS #CLRBLUE, A		;And similarly for blue.
;	MOV A, COLORA
;	RTS PC
;
;
;.WRIMAP:			;.WRITEMAP user primitive to write into color map.
;	JSR PC, G1NARG		;Takes 4 args: slot number, RED, GREEN, BLUE
;	SAVE B
;	JSR PC, G1NARG
;	SAVE B
;	JSR PC, G1NARG
;	SAVE B
;	JSR PC, G1NARG		;Remove 4 args from stack, put then in A, B, C, D
;	MOV B, D
;	REST <C, B, A>
;	JSR PC, WCMAP		;The routine that does the work.
;	SEZ
;	RTS PC
;

.WRIRED:
	JSR PC, G2NARG		;Get two integer args, return them in A and B.
	MOV #CLRRED, C		;It's the red we want to write.
	BR WRIMAP

.WRIGREEN:
	JSR PC, G2NARG
	MOV #CLRGREEN, C
	BR WRIMAP
	
.WRIBLUE:
	JSR PC, G2NARG
	MOV #CLRBLUE, C
				;Falls thru to WRIMAP.

WRIMAP:				;Writes a color into color map. Args: slot number
				;in B, beam intensity in A, mask for which beam in C.
	BIS C, B		;IOR slot number with mask for RED, GREEN, or BLUE.
	MOV A, COLORD		;Write into color data before color address.
	MOV B, COLORA
	SEZ
	RTS PC
		

.REAPAL:			;.READPALETTE user function. 
	JSR PC, G1NARG
	ASL B			;Double for number of bytes from start of palette.
	SPUSHS PALETTE (B)	;Indexes supplied arg into the palette.
	CLZ
	RTS PC

.WRIPAL:			;.WRITEPALETTE user function.
	MOV @S, B		;Atom from S stack to B [don't pop to leave GC protect]
	MOV #ATOM, A		;Convert to type ATOM, type check, etc.
	JSR PC, CONVERT		;Atom returns in B.
	SAVE B
	ADD #2, S		;Remove atom from S stack.
	JSR PC, G1NARG		;Index to write into in B
	ASL B			;Multiply by 2 to get byte address.
	REST PALETTE (B)	;Move atom into position in palette indexed by A.
	SEZ
	RTS PC

.ENDC				;End of color conditional assembly section.


XORMODE:
	MOV #TVXOR, A
	BR WINMODE
IORMODE:
	MOV #TVIOR, A
WINMODE:
	MOV #-1., WINDATA	;XOR, IOR draw with bits on.
	BR DRAWMODE		
SETMODE:			;SET mode for eraser draws with bits off.
	MOV #TVSET, A		;In color, however, in SETMODE always but bits on.
	CLR WINDATA		
DRAWMODE:			;Sets mode for writing into screen memory.
	BIC #TVRWMD, TVSEL	;Choose from: TVIOR, TVSET, TVXOR.
	BIS A, TVSEL
	RTS PC






;TVCHK CHECKS IF MY TTY IS A TV. IT CLEARS Z IF IT IS, SETS Z OTHERWISE.
;ALSO SETS THE TV FLAG IN DFLAGS.
TVCHK:	SAVE <,,TYOCP>
	BIS #.TTTYP*400,(P)	;GET FLAGS FROM TTY TABLE
	$INVOK
	BIT #200,(P)+		;BIT 200 IS THE TV FLAG
	BEQ TVCHK1		;IS NOT A TV
	BIS #TVF,DFLAGS		;YES IT IS!
	SAVE <#-1,TYOCP>
	BIS #140000,(P)
	SAVE #0+.DSCAP*400	;0 IS CREATE CAPABILITY
	$INVOK
	REST <DISCAP,,>		;CREATE THE DISPLAY CAP
	MOV DISCAP, A		;Falls thru to TVRMAP.

TVRMAP:				;Map in TV control registers.
	SAVE <#0, #4, A, #.CRWRT!1>
	MOVB #DISPG+10, 3 (P)
	$MAP			;Magic SITS system call to access TV control registers.
	SAVE <,,#.TVSAV*400>
	MOVB A, (P)
	$INVOK			;Magic SITS system call enabling saving of TV registers.
TVCHK1:	RTS PC


;CREATE AN ECHO AREA WITH SIZE BASED ON FONT. EXPECTS THE TV LINE OF THE TOP
;OF THE ECHO AREA IN B

CRECHO:	
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ CREBW
	RTS PC
.ENDC
CREBW:
	SAVE <TVSEL, TVMSK>	;Save TV registers over system calls.
	SAVE <,#.TSCRL,TYOCP>
	BIS #.TTBS2*400,(P)	;GO INTO SCROLL MODE FOR NOW
	$INVOK
	SAVE <,,TYOCP>
	BIS #.TVCL*400,(P)	;SO WE CAN RESET THE SCREEN
	$INVOK			;AND DO A REAL CLEAR
	SAVE <,#.TSCRL,TYOCP>
	TST B			;DOES HE REALLY WANT AN ECHO AREA?
	BNE CRECH1
	BIS #.TTBS2*400,(P)	;NO, SET THE SCROLL MODE BIT
	BR CRECH2
CRECH1:	BIS #.TTBC2*400,(P)	;YES, CLEAR THE SCROLL MODE BIT TO USE WRAP MODE
CRECH2:	$INVOK
	SAVE <,,TYOCP>
	BIS #.TVRFN*400,(P)	;READ THE NUMBER OF TV LINES PER CHAR LINE
	$INVOK			;AND THE WIDTH OF CHAR IN BITS
	REST <TVHIGH,TVWIDE>
	CLR A			;FOR THE DIVIDE
	DIV TVHIGH,A		;DIVIDE BY NUBER OF TV LINES PER CHAR LINE
	TST B			;ANY REMAINDER?
	BEQ 1$			;COUNT IT AS ONE MORE LINE
	INC A
1$:	SAVE <,A,TYOCP>
	BIS #<.TVOFF+.PRWRT>*400,(P)	;SET THE OFFSET TO SET THE ECHO AREA
	$INVOK			;THIS WILL CLEAR SCREEN AND THUS SET CURSOR
	MUL TVHIGH,A
	MOV B,TVSIZE		;THE DISPLAY AREA HAS THIS MANY LINES
	REST <TVMSK, TVSEL>
	RTS PC

TVCS:	SETF
	SETI
	LDCIF TRCENX,FA
	STF FA,DCURX		;RESET DCURX
	LDCIF TRCENY,FA
	STF FA,DCURY		;RESET DCURY
	CLR DCURA		;RESET DCURA
	CLRF FA
	STF FA,DSINA		;RESET DSINA
	LDCIF #1,FA
	STF FA,DCOSA		;RESET DCOSA
	MOV TVCENX,TVX
	MOV TVCENY,TVY		;SO THE DRAWER WILL GO BACK TO CENTER OF SCREEN
;FALL IN TO TVWC


TVWC:				;TV WIPECLEAN.
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ WCBW
CTVWC:	JSR PC, TVWCOL		
	BR WCDPAL
.ENDC
WCBW:	JSR PC, TVWCBW
WCDPAL:	JSR PC, CLEPAL
	JMP DTVTUR
TVWC1:	SEZ
	RTS PC


.IFNZ COLOR
TVWCOL:				;Clear screen in color. [TV-CLEARSCREEN] WIPECLEAN
	JSR PC, SELERA		;(SELECT-COLOR :ERASERNUMBER)
	JSR PC, FILSCR
;	JSR PC, SELPEN
;	JSR PC, OUTLIN
	JMP RESELC

FILSCR:	CLR TVMSK
	CLR TVRADR
	MOVB #1, TVINCR
	MOV #TVRWIN, C
	MOV WINDATA, A
	MOV #WORLIN*453., B
FLSCLUP:
	MOV A, (C)
	SOB B, FLSCLUP
	CLRB TVINCR
	RTS PC

;Block mode unreliable when switching processes.
;CTVWC:	CLR A			;(WRITE-TV-BLOCK 0. -1. 16344. 1)
;	MOV #-1., B
;	MOV #16344., C
;	MOV #1, D
;	JSR PC, WBLOCK
;	JMP RESELC		;(RESELECT-COLOR)

.ENDC

TVWCBW:	SAVE <TVSEL, WINDATA>
	JSR PC, SETMODE		;To clear the screen in black and white,
	JSR PC, FILDIS
	JSR PC, IORMODE
	JSR PC, OUTLIN
	REST <WINDATA, TVSEL>
	RTS PC

FILDIS:				;Fill display area bounded by TVTOP, BOT, LEFT, RIGHT.
	MOV TVLEFT, A
	MOV TVRIGHT, B
	MOV TVTOP, C
	MOV TVBOT, D		;Falls through to FILWIN.


FILWIN:				;Fills area bounded by A, B, C, D
	MOVB #WORLIN, TVINCR	;Words written a line at a time.
	SUB C, D
	INC D			;Number of lines to be written in D.
	MOV A, E
	BIC #-<15.+1>, E
	ASL E
	MOV STARMSK (E), TVMSK	;Calculate starting mask.
	MOV B, E
	BIC #-<15.+1.>, E
	ASL E
	SAVE STOPMSK (E)	;Save stopping mask.
	ASH #-4., A
	ASH #-4., B		;Left and right in words.
	MOV C, F		
	MUL #BYTLIN, F
	MOV A, E
	ASL E
	ADD E, F		;Byte address in F.
	MOV WINDATA, E
	CMP A, B		;Starting and stopping words equal? 
	BNE FILMTOW
	BIC (P)+, TVMSK		;And starting and stopping masks.
	BR FILSTRIP
FILMTOW:			;Fill more than one word.
	SUB A, B
	DEC B			;Iteration counter for full word loop.
	BEQ FILAST		;If zero, don't bother.
	JSR PC, FILSTRIP	;Do the first partial word loop.
	CLR TVMSK		;Prepare to write a full word.	
FILWLUP:
	JSR PC, FILSTRIP
	SOB B, FILWLUP
FILAST:	REST TVMSK		;Falls through to do last partial word strip.
FILSTRIP:			;Fills a vertical strip of the area.
	MOV F, TVRADR		;#WORLIN in TVINCR, Address in F, Number of lines in D
	MOV D, A		;WINDATA in E, mask in TVMSK, clobbers A.
FILUP:	MOV E, TVRWIN
	SOB A, FILUP
	TST (F)+		;F now points to first word in next column.
	RTS PC


CLEPAL:				;[CLEAR-PALETTE]
	MOV #PALETTE, A
	MOV ERANUM, B
	MOV ERANUM, C
	SUB PENNUM, C		;(SETQ C (- :ERASERNUMBER :PENNUMBER))
PALUP:	CMP B, C		;If we're currently working on pencolor slot, skip it.
	BEQ NILPAL
	MOV #LIST, (A)		;Fill slots 0 thru :ERASERNUMBER-1 with NILs
NILPAL:	TST (A)+
	SOB B, PALUP		;except for slot :PENNUMBER.
	RTS PC

OUTLINE:			;Draw box outlineing display area.
	SAVE TVSIZX
	INC (P)
	SAVE TVSIZY
	INC (P)
	SAVE TVLEFT
	DEC (P)
	MOV TVTOP, A		;Remember, silly DRAW routine wants arguments
	DEC A
	MOV (P), B		;Y start, X start, delta Y, delta X.
	CLR C
	MOV 4 (P), D		;(1+ TVSIZX)
	JSR PC, DRAW		;Top line.
	MOV TVBOT, A
	INC A
	MOV (P), B		
	CLR C
	MOV 4 (P), D		;(1+ TVSIZX)
	JSR PC, DRAW		;Bottom line.
	MOV TVTOP, A
	MOV (P), B		;(1+ TVLEFT)
	MOV 2 (P), C		;(1+ TVSIZY)
	CLR D
	JSR PC, DRAW		;Left side.
	MOV TVTOP, A
	MOV TVRIGHT, B
	INC B
	MOV 2 (P), C
	CLR D
	ADD #6, P		;Pop three temporaries off stack.
	JMP DRAW		;Right side.
	
;TVWCBW:				;Black and white version.
;	SAVE <TVLEFT,#0,DISCAP>
;	BIS #.TVDSS*400,(P)	;SET THE TV DRAWER TO TOP LEFT OF DISPLAY
;	$INVOK
;	SAVE <TVSIZX,TVSIZE,DISCAP>
;	BIS #.TVDSC*400,(P)	;CLEAR THE AREA OF DISPLAY
;	$INVOK			;THIS LEAVES DRAWER AT BOTTOM RIGHT
;	SAVE <TVLEFT,TVTOP,DISCAP>
;	BIS #.TVDSS*400,(P)	;SET THE CURSOR TO TOP LEFT
;	$INVOK
;	SAVE <TVSIZX,#0,DISCAP>	;X WIDTH OF SCREEN, NO DELTA Y
;	BIS #.TVDSI*400,(P)	;DRAW THE TOP LINE
;	$INVOK
;	SAVE <#0,TVSIZY,DISCAP>	;NO DELTA X, SCREEN HEIGHT IS DELTA Y
;	BIS #.TVDSI*400,(P)	;DRAW THE RIGHT SIDE
;	$INVOK
;	SAVE TVSIZX		;X WIDTH OF SCREEN
;	NEG (P)			;TO GO BACK
;	SAVE <#0,DISCAP>	;NO DELTA Y
;	BIS #.TVDSI*400,(P)	;DRAW THE BOTTOM LINE
;	$INVOK
;	SAVE <#0,TVSIZY>	;NO DELTA X, THE SCREEN HEIGHT AS DELTA Y
;	NEG (P)			;TO GO UP THE SCREEN
;	SAVE DISCAP
;	BIS #.TVDSI*400,(P)	;DRAW THE LEFT SIDE
;	$INVOK
;
;	SAVE <TVX,TVY,DISCAP>
;	BIS #.TVDSS*400,(P)	;RESET THE DRAWER TO ITS OLD POSITION
;	$INVOK



	;TURTLESIZE ROUTINE
TRSIZE:	JSR PC,TVTEST	;ON TV?
	JSR PC,G1NARG
	MOV B,TRMIN
	JSR PC,REINIT
	SEZ
	RTS PC

	;TVSIZE ROUTINE
RESIZE:	JSR PC,TVTEST
	JSR PC,DCHK
	MOV 2(P),A
	MOV (P)+,(P)
	CMP A,#2.		;CHECK THE NUMBER OF ARGS.
	BEQ SIZ2ARG
	BGT SIZWNA
	CMP A,#1.		;POPOFF NUMBER OF ARGS.
	BEQ SIZ1ARG			;IF ONE ARG.
SIZWNA:	ERROR+WNA		;ERROR-WRONG NUMBER OF ARGS.
SIZ2ARG:
	JSR PC,G2NARG		;GET TWO ARGS. X IN B Y IN
;	JSR PC,CHSIZE		;CHECK SIZE OF Y ARG. (IN A)

	CMP B, #TVXSMN		;Check reasonableness of TVSIZE args.
	BLT XSIZER
	CMP B, #TVXSMX
	BGT XSIZER
	CMP A, #TVYSMN
	BLT YSIZER
	CMP A, #TVYSMX
	BLE OKSIZE
YSIZER:	MOV A,B
XSIZER:	JSR PC,R1NARG
	ERROR + WTA
OKSIZE:	EXCH A, B		;Exch A, B. Rest of code wants this. Change this? 

	MOV B,-(SP)		;STORE B

;	MOV A,B
;	JSR PC,CHSIZE		;CHECK SIZE OF X ARG. NOW COPIED IN B

	MOV (SP)+,B		;RESTORE B
	CMP A,B			;WHICH IS SMALLER AND PUT IT INTO
	BGT SIZMIN		;TVMIN
	MOV A,TVMIN
	BR SIZRST
SIZ1ARG:
	JSR PC,G1NARG		;GET 1 ARG. (X DIMENSION=Y DIMENSION)
	MOV B,A			;COPY DIMENSION
;	JSR PC,CHSIZE		;CHECK SIZE OF ARG.
	CMP A, #TVYSMN
	BLT YSIZER
	CMP A, #TVYSMX
	BGT YSIZER
SIZMIN:	MOV B,TVMIN
SIZRST:	MOV A,TVSIZX		;RESET PARAMETERS
	MOV B,TVSIZY
	MOV B,TVBOT
	ADD TVTOP,TVBOT		;NEW TV BOTTOM OF DISPLAY AREA
	MOV TVRIGH,TVLEFT	;NEW TVLEFT=TVRIGHT-TVSIZE X
	SUB A,TVLEFT
	SETI
	SETF
	LDCIF A,FA
	LDCIF B,FB		;STORE FOR USE LATER A,B
	ASR A			;TV CENTER X=(TVSIZE X/2)+TVLEFT
	ADD TVLEFT,A
	MOV A,TVCENX
	ASR B			;LIKEWISE FOR Y
	ADD TVTOP,B
	MOV B,TVCENY
	LDCIF TVMIN,FC		;TURTLE SCALE FACTOR X!Y=
	DIVF FC,FA		;TV SIZE X!Y/TVMIN
	STF FA,TRSCLX
	DIVF FC,FB
	STF FB,TRSCLY
	JSR PC,REINIT
	MOV TVBOT,B
	JSR PC,CRECHO
	JSR PC,TVCS
	SEZ
	RTS PC



TVSHOW:	BIC #HIDETF, DFLAGS	;The turtle now not hidden.
	JMP DTVTUR
TVSHO1:	SEZ
	RTS PC

TVHIDE:	JSR PC, ETVTUR		;Remove the turtle cursor from the screen.
	BIS #HIDETF, DFLAGS	;Mark the turtle as being hidden.
TVHID1:	SEZ
	RTS PC


SEETURTLE:			;Returns TRUE if in SHOWTURTLE mode, FALSE in HIDETURTLE
	BIT #HIDETF, DFLAGS
	BNE SEERTF		;HIDETF bit in DFLAGS indicates whether turtle is hidden
	JMP RTTRUE
SEERTF:	JMP RTFALSE




.IFNZ TVS
DTVTUR:				;[DRAW-TURTLE]
	BIT #HIDETF, DFLAGS	;If turtle hidden, forget about it.
	BNE DTUREND
DTURST:
	BIT #CLIPF, DFLAGS	;In CLIP mode, if HERE is out of bounds, forget it.
	BEQ DTNCLP
	LDF DCURX, FA
	LDF DCURY, FB
	JSR PC, CLPVIS
	TST A
	BNE DTUREND
DTNCLP:	
.IFNZ COLOR
	BIT #COLORF, DFLAGS	
	BNE DTVCLR
.ENDC

	SAVE <TVSEL, WINDATA>
	JSR PC, XORMODE		;and draw triangle in XOR mode.
	BR DTRIAN

.IFNZ COLOR
DTVCLR:	JSR PC, SELPEN		;In color, (SELECT-COLOR :PENNUMBER)
.ENDC

DTRIAN:	JSR PC, TRIANG

.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ DTURBW		;In color, restore selected color.
	JMP RESELC
.ENDC

DTURBW:	REST <WINDATA, TVSEL>
				;In black and white, restore drawmode and flags.
DTUREN:	SEZ			;Frequently want to return no-value at this point.
	RTS PC


ETVTUR:				;[ERASE-TURTLE]
	BIT #HIDETF, DFLAGS
	BNE ETUREND
ETURST:
	BIT #CLIPF, DFLAGS	;In CLIP mode, if HERE is out of bounds, forget it.
	BEQ ETNCLP
	LDF DCURX, FA
	LDF DCURY, FB
	JSR PC, CLPVIS
	TST A
	BNE ETUREND
ETNCLP:	

.IFNZ COLOR
	BIT #COLORF, DFLAGS	
	BNE ETVCLR
.ENDC

	SAVE <TVSEL, WINDATA>
	JSR PC, XORMODE
	BR ETRIAN

.IFNZ COLOR
ETVCLR:	JSR PC, SELERA
.ENDC

ETRIAN:	JSR PC, TRIANG

.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ ETURBW
	JMP RESELC
.ENDC

ETURBW:	REST <WINDATA, TVSEL>
ETUREN:	RTS PC
.ENDC




TRIANG:	SETF
	SETI			;THE FOLLOWING STUFF IS DONE IN SHORT, FLOAT MODE
	LDF DCURX,FA
	LDF DCURY,FB		;LOAD UP CURRENT X AND Y
	LDF TRFRAD,FC		;TURTLE FRONT RADIUS
	STF FC,FD		;COPY THE RADIUS
	MULF DSINA,FC		;FONT LINE X IS FRONT RADIUS * SIN A
	MULF DCOSA,FD		;FONT LINE Y IS FRONT RADIUS * COS A
	ADDF DCURX,FC
	ADDF DCURY,FD		;MAKE THIS POINT LESS RELATIVE
	JSR PC,WRPVEC		;DRAW AS WRAP VECTOR
	STF FC,-(P)		;SAVE THIS POINT
	STF FD,-(P)
	STF FC,FA		;BECOMES THE FROM X
	STF FD,FB		;BECOMES THE FROM Y
	LDF TRSRAD,FC		;TURTLE SIDE RADIUS
	STF FC,-(P)		;SAVE IT ON STACK
	LDF DSINA,FD
	MULF SIN120,FD
	STF FD,-(P)
	LDF DCOSA,FD
	MULF COS120,FD
	ADDF (P)+,FD		;Y = SIN A * SIN 120 + COS A * COS 120
	MULF (P),FD		;Y = TURTLE SIDE RADIUS * Y
	LDF DCOSA,FC
	MULF SIN120,FC
	STF FC,-(P)
	LDF DSINA,FC
	MULF COS120,FC
	SUBF (P)+,FC		;X = SIN A * COS 120 - COS A * SIN 120
	MULF (P),FC		;X = TURTLE SIDE RADIUS * X
	ADDF DCURX,FC
	ADDF DCURY,FD		;MAKE LESS RELATIVE
	JSR PC,WRPVEC		;DRAW THE RIGHT SIDE OF TURTLE
	STF FC,FA		;BECOMES THE FROM X
	STF FD,FB		;BECOMES THE FROM Y
	LDF DSINA,FD
	MULF SIN240,FD
	STF FD,-(P)
	LDF DCOSA,FD
	MULF COS240,FD
	ADDF (P)+,FD		;Y = COS A * COS 240 + SIN A * SIN 240
	MULF (P),FD		;Y = TURTLE SIDE RADIUS * Y
	LDF DCOSA,FC
	MULF SIN240,FC
	STF FC,-(P)
	LDF DSINA,FC
	MULF COS240,FC
	SUBF (P)+,FC		;X = SIN A * COS 240 - COS A * SIN 240
	MULF (P)+,FC		;X = TURTLE SIDE RADIUS * X
	ADDF DCURX,FC
	ADDF DCURY,FD		;MAKE LESS RELATIVE
	JSR PC,WRPVEC		;DRAW THE BOTTOM OF TURTLE
	STF FC,FA		;BECOMES THE FROM X
	STF FD,FB		;BECOMES THE FROM Y
	LDF (P)+,FD		;Y FROM FRONT LINE
	LDF (P)+,FC		;X FROM FRONT LINE
	JSR PC,WRPVEC		;DRAW THE LEFT SIDE OF THE TURTLE
	RTS PC


;VECTOR DRAW LINES ON THE SCREEN. IT EXPECTS:
;FROM X IN FA
;FROM Y IN FB
;TO X IN FC
;TO Y IN FD

VECTOR:	SETF			;ALL THE FOLLOWING STUFF IS IN FLOAT MODE
	SETI			;AND IN SHORT INTEGER MODE
	STF FC, -(P)		;Save TO point over vector drawing.
	STF FD, -(P)
	BIT #<WRAPF!CLIPF>,DFLAGS	;CHECK THE BOUNDS, IF WRAPPING OR
	BNE 2$			;CLIPPING, NO CHECKING IS NEEDED
	JSR PC,TVBOUN
2$:	BIT #HIDETF,DFLAGS	;ARE WE SHOWING THE TURTLE?
	BNE VECTO1		;NO
	JSR F,FACSAV		;SAVE THE REGISTERS
	JSR PC, ETURST		;THIS CAUSES IT TO GO AWAY
	JSR F,FACRES		;RESTORE THE REGISTERS
VECTO1:	BIT #PENUF, DFLAGS	;Check state of pen, etc., decide whether to draw line.
	BEQ VECTDR		;Pendown, draw the line.
	BIT #<XORF!ERASEF>, DFLAGS
	BEQ VECTO3		;Pen, eraser, xor up, skip drawing the line.
VECTDR:	BIT #WRAPF,DFLAGS	;ARE WE IN WRAP MODE?
	BNE VECTO2		;YES

	BIT #CLIPF,DFLAGS	;CLIP MODE?
	BEQ VECTO5		;NO
	JSR PC, CLPVEC
	BR VECTO3
VECTO5:	JSR PC,BNDVEC		;NO DRAW A BOUNDED VECTOR
	BR VECTO3
VECTO2:	JSR PC,WRPVEC		;YES DRAW VECTORS WITH WRAPAROUND
VECTO3:	LDF (P)+, FD
	LDF (P)+, FC
	STF FC,DCURX
	STF FD,DCURY		;THE NEW CURRENT POSITION
	JMP DTVTUR		;PUT THE TURTLE IN ITS NEW HOME
VECTO4:	SEZ
	RTS PC

TVBOUN:				;CHECKS BOUNDRIES FOR TVRTLE
	CMPF TRLEFT,FC
	CFCC
	BGT 1$
	CMPF TRRIGH,FC
	CFCC
	BLT 1$
	CMPF TRTOP,FD
	CFCC
	BLT 1$
	CMPF TRBOT,FD
	CFCC
	BGT 1$
	RTS PC
1$:	ERROR+OOB

;Old "clipping" code. To be flushed.
OCLIP:	CMPF TRLEFT,FC		;THIS CODE WHEN IN CLIP MODE 
	CFCC			;CHECKS THE BOUNDS OF THE
	BLE 3$			;VECTOR AND IF THE VECTOR RUNS
	LDF TRLEFT,FC		;OUT OF BOUNDS IT IS CLIPPED BY
3$:	CMPF TRRIGH,FC		;PLACING THE TURTLE COORDINATE OF
	CFCC			;THAT EDGE INTO THE APPROPRIATE
	BGE 4$			;PARAMETER
	LDF TRRIGH,FC
4$:	CMPF TRTOP,FD
	CFCC
	BGE 5$
	LDF TRTOP,FD
5$:	CMPF TRBOT,FD
	CFCC
	BLE VECTO5
	LDF TRBOT,FD
	BR VECTO5





;Code for vectors in CLIP mode. Follows clip algorithm in Newman & Sproull.

;Following routine returns a VISIBILITY number in A 0-15 indicating 
;whether point is outside display area in X and/or Y. Coordinates of point in FA 
;and FB.

CLPVIS:					;[CLIP-VISIBILITY]
	CLR A				
	CMPF TRLEFT, FA			;Compare with left edge, outside if X less.
	CFCC				
	BLE CPVSRT			
	INC A
	BR CPVSBT
CPVSRT:	CMPF TRRIGHT, FA		;Compare against right, outside if X greater.
	CFCC
	BGE CPVSBT
	TST (A)+			;Increment A by 2.
CPVSBT:	CMPF TRBOT, FB			;Outside if Y < bottom edge in turtle coords.
	CFCC
	BLE CPVSTP
	ADD #4., A
	RTS PC
CPVSTP:	CMPF TRTOP, FB			;Outside if Y > top edge.
	CFCC
	BGE CPVSEND
	ADD #8., A
CPVSEND:
	RTS PC


;Vector clipping routine. FROM-X in FA, FROM-Y in FB, TO-X in FC, TO-Y in FD.


CLPVEC:					;[CLIP-VECTOR]
	STF FA, -(P)
	STF FB, -(P)			;Save FROM point.
	JSR PC, CLPVIS			;Compute visibility of FROM point.
	SAVE A
	LDF FC, FA
	LDF FD, FB
	JSR PC, CLPVIS			;Compute visibility of TO point.
	MOV A, B
	REST A
	LDF (P)+, FB
	LDF (P)+, FA			;FROM-VISIBILITY in A, TO-VISIBILITY in B.
CLPVS:					;[CLIP-VECTOR-VISIBILITY]
	MOV A, C
	ADD B, C			;If both points are inside display area
	BNE CLPOUT			;hand off to BOUNDED-VECTOR.
	JMP BNDVEC
CLPOUT:	
	BIT A, B			;If both points are outside X or both
	BEQ CLPDRW			;outside Y whole vector is invisible.
	RTS PC
CLPDRW:
	TST A				;Exchange points if necessary so that
	BNE CLPNSW			;TO point is visible.
	STF FA, -(P)
	LDF FC, FA
	LDF (P)+, FC
	STF FB, -(P)
	LDF FD, FB
	LDF (P)+, FD
	EXCH A, B			
CLPNSW:
	BIT #1., A			;Push towards left edge.
	BEQ CLPRT
	STF FB, -(P)
	STF FA, -(P)			
	SUBF FC, FA					  
	SUBF FD, FB
	DIVF FA, FB
	LDF TRLEFT, FA
	SUBF (P)+, FA
	MULF FA, FB
	ADDF (P)+, FB
	LDF TRLEFT, FA
CLPRT:	BIT #2., A				;Push toward right edge.
	BEQ CLPTP
	STF FB, -(P)
	STF FA, -(P)
	SUBF FC, FA
	SUBF FD, FB
	DIVF FA, FB
	LDF TRRIGHT, FA
	SUBF (P)+, FA
	MULF FA, FB
	ADDF (P)+, FB
	LDF TRRIGHT, FA
CLPTP:	BIT #4., A				;Push toward top.
	BEQ CLPBT
	STF FA, -(P)
	STF FB, -(P)
	SUBF FC, FA
	SUBF FD, FB
	DIVF FB, FA
	LDF TRBOT, FB
	SUBF (P)+, FB
	MULF FB, FA
	ADDF (P)+, FA
	LDF TRBOT, FB
CLPBT:	BIT #8., A				;Push toward bottom.
	BEQ CLPNVS
	STF FA, -(P)
	STF FB, -(P)
	SUBF FC, FA
	SUBF FD, FB
	DIVF FB, FA
	LDF TRTOP, FB
	SUBF (P)+, FB
	MULF FB, FA
	ADDF (P)+, FA
	LDF TRTOP, FB
CLPNVS:	JSR PC, CLPVIS				;Recompute visibility for FROM point.
	BR CLPVS



;WRPVEC DRAWS VECTORS WITH WRAP AROUND BY SPLITTING THE LINES IN THE VARIOUS
;SCREENS THAT IT CROSSES, AND CALLING BNDVEC TO ACTUALLY DRAW THE LINES ON
;EACH OF THE VIRTUAL SCREENS.  THE SCREEN SPLITTING IS DONE BY CHOPPING OFF
;PIECES OF THE LINE AND CALLING WRPVEC RECURSIVELY.  THIS PROCEDURE IS
;ESSENTIALLY A HAND COMPILATION OF THE PROCEEDURE WRAP-VECTOR IN HENRY
;LIEBERMAN'S TVRTLE, A PART OF LISP LOGO

WRPVEC:	JSR F,FACSAV		;SAVE ALL THE REGISTERS
	STF FA,FE
	SUBF TRLEFT,FA
	DIVF TRSIZX,FA
	TSTF FA
	CFCC
	BGE 1$
	SUBF #40200,FA		;-0.1 SHOULD TRUNCATE TO -1 NOT 0
1$:	STCFI FA,A		;FROM-SCREEN-X=(FROM-X - TR-PIC-LEFT)/ TR-PICT-SIZE
	LDF FE,FA
	STF FC,FE
	SUBF TRLEFT,FC
	DIVF TRSIZX,FC
	TSTF FC
	CFCC
	BGE 2$
	SUBF #40200,FC
2$:	STCFI FC,C		;TO-SCREEN-X=(TO-X - TR-PICT-LEFT)/ TR-PICT-SIZE
	LDF FE,FC
	CMP A,C			;FROM-SCREEN-X = TO-SCREEN-X ?
	BEQ WRPVE2		;YES
	STF FC,-(P)
	STF FD,-(P)		;GET SOME REGISTERS
	SUBF FA,FC		;CHANGE-X = TO-X - FROM-X
	SUBF FB,FD		;CHANGE-Y = TO-Y - FROM-Y
	TSTF FC
	CFCC
	BGE WRPVE1
	MOV #-1,E
	BR .+6
WRPVE1:	MOV #1,E		;IF CHANGE-X >= 0 THEN SIGN-X = 1 ELSE SIGN-X = -1
	DIVF FC,FD
	STF FD,FE		;TAN-HEADING = CHANGE-Y / CHANGE-X
	LDCIF A,FC		;FROM-SCREEN-X
	MULF TRSIZX,FC
	ADDF TRLEFT,FC		;TO-EDGE-X=TR-PIC-SIZE-X*FROM-SCREEN-X + TR-PICT-LEFT
	TST E
	BLT 1$			;IF SIGN-X >= 0
	ADDF TRSIZX,FC		;	THEN ADD TURTLE-PICT-SIZE-X TO TO-EDGE-X
1$:	LDF FC,FD
	SUBF FA,FD
	MULF FE,FD
	ADDF FB,FD		;TO-EDGE-Y=(TO-EDGE-X - FROM-X)*TAN-HEADING + FROM-Y
	STF FC,FE
	LDCIF E,FC
	ADDF FPC0.1,FC
	STF FC,FF		;BACK-OFF-EDGE = SIGN X + 0.1
	LDF FE,FC
	SUBF FF,FC
	JSR PC,WRPVEC		;(WRAP-VECTOR	FROM-X
				;		FROM-Y
				;		TO-EDGE-X - BACK-OFF-EDGE
				;		TO-EDGE-Y)
	LDF FE,FA
	ADDF FF,FA
	LDF FD,FB
	LDF (P)+,FD
	LDF (P)+,FC
	JSR PC,WRPVEC		;(WRAP-VECTOR	TO-EDGE-X + BACK-OFF-EDGE
				;		TO-EDGE-Y
				;		TO-X
				;		TO-Y)
	JSR F,FACRES
	RTS PC

WRPVE2:	STF FB,FE
	SUBF TRBOT,FB
	DIVF TRSIZY,FB
	TSTF FB
	CFCC
	BGE 1$
	SUBF #40200,FB		;TO MAKE -0.1 TRUNCATE TO -1
1$:	STCFI FB,B		;FROM-SCREEN-Y=(FROM-Y - TR-PICT-BOTTOM) / TR-SIZE-Y
	LDF FE,FB
	STF FD,FE
	SUBF TRBOT,FD
	DIVF TRSIZY,FD
	TSTF FD
	CFCC
	BGE 2$
	SUBF #40200,FD		;TO MAKE -0.1 TRUNCATE TO -1
2$:	STCFI FD,D		;TO-SCREEN-Y=(TO-Y - TR-PICT-BOTTOM) / TR-SIZE-Y
	LDF FE,FD
	CMP B,D			;FROM-SCREEN-Y = TO-SCREEN-Y ?
	
	BEQ WRPVE4		;YES
	STF FC,-(P)
	STF FD,-(P)		;GET SOME REGISTERS
	SUBF FA,FC		;CHANGE-X = TO-X - FROM-X
	SUBF FB,FD		;CHANGE-Y = TO-Y - FROM-Y
	TSTF FD
	CFCC
	BGE WRPVE3		;IF CHANGE-Y < 0
	MOV #-1,E		;	THEN SIGN-Y = -1
	BR .+6
WRPVE3:	MOV #1,E		;	ELSE SIGN-Y = 1
	DIVF FD,FC
	STF FC,FE		;TAN-HEADING = CHANGE-X / CHANGE-Y
	LDCIF B,FD
	MULF TRSIZY,FD
	ADDF TRBOT,FD		;TO-EDGE-Y=FROM-SCREEN-Y * TR-PICT-SIZE-Y + TR-PICT-BOT
	TST E
	BLT .+6			;IF SIGN-Y >= 0
	ADDF TRSIZY,FD		;	THEN TO-EDGE-Y = TO-EDGE-Y + TR-SIZE-Y
	LDF FD,FC
	SUBF FB,FC
	MULF FE,FC
	ADDF FA,FC		;TO-EDGE-X=TAN-HEADING*(TO-EDGE-Y - FROM-Y)+FROM-X
	STF FD,FE
	LDCIF E,FD
	MULF FPC0.1,FD
	STF FD,FF		;BACK-OFF-EDGE = SIGN-Y * 0.1
	LDF FE,FD
	SUBF FF,FD
	JSR PC,WRPVEC		;(WRAP-VECTOR	FROM-X
				;		FROM-Y
				;		TO-EDGE-X
				;		TO-EDGE-Y - BACK-OFF-EDGE)
	LDF FC,FA
	LDF FE,FB
	ADDF FF,FB
	LDF (P)+,FD
	LDF (P)+,FC
	JSR PC,WRPVEC		;(WRAP-VECTOR	TO-EDGE-X
				;		TO-EDGE-Y + BACK-OFF-EDGE
				;		TO-X
				;		TO-Y)
	JSR F,FACRES
	RTS PC

;NOW BOTH FROM X, TO X AND FROM Y, TO Y ARE ALL ON THE SAME SCREEN.
;WE MUST CONVERT THAT SCREEN TO OVERLAY THE CENTER SCREEN BY A
;MODULO TYPE OPERATION.

WRPVE4:	STF FB,-(P)
	SUBF TRLEFT,FA
	DIVF TRSIZX,FA
	MODF #40200,FA		;MUL BY 1, FRACTION IN FA, INTEGER IN FB
	TSTF FA
	CFCC
	BGE 1$
	ADDF #40200,FA		;SO NEGATIVE VALUES WRAP PROPERLY
1$:	MULF TRSIZX,FA
	ADDF TRLEFT,FA		;SHIFT FROM X TO THIS SCREEN
	LDF (P)+,FB
	SUBF TRBOT,FB
	DIVF TRSIZY,FB
	MODF #40200,FB		;MUL BY 1 TO GET FRACTION IN FB
	TSTF FB
	CFCC
	BGE 2$
	ADDF #40200,FB		;SO NEGATIVE VALUES WRAP PROPERLY
2$:	MULF TRSIZY,FB
	ADDF TRBOT,FB		;SHIFT FROM Y TO THIS SCREEN
	STF FD,-(P)
	SUBF TRLEFT,FC
	DIVF TRSIZX,FC
	MODF #40200,FC		;#1 IN FLOATING
	TSTF FC
	CFCC
	BGE 3$
	ADDF #40200,FC		;SO NEGATIVE VALUES WRAP PROPERLY
3$:	MULF TRSIZX,FC
	ADDF TRLEFT,FC		;SHIFT TO X TO THIS SCREEN
	LDF (P)+,FD
	SUBF TRBOT,FD
	DIVF TRSIZY,FD
	MODF #40200,FD		;#1 IN FLOATING
	TSTF FD
	CFCC
	BGE 4$
	ADDF #40200,FD		;SO NEGATIVE VALUES WRAP PROPERLY
4$:	MULF TRSIZY,FD
	ADDF TRBOT,FD		;SHIFT TO Y TO THIS SCREEN
	JSR PC,BNDVEC		;(BOUNDED-VECTOR FROM-X FROM-Y TO-X TO-Y)
	JSR F,FACRES
	RTS PC

;BNDVEC IS THE EQUIVALENT OF HENRY'S BOUNDED-VECTOR. IT IS USED TO DRAW A
;LINE ON THE SCREEN WITHOUT CONSIDERING WRAP AROUND.  THIS PROGRAM ASSUMES
;THAT THE LINE IS WITHIN BOUNDS.

BNDVEC:	JSR F,FACSAV		;SAVE THE REGISTERS
	JSR PC,TVSCAL		;CONVERT FROM TURTLE COORDINATES TO TV COORDS
	JSR PC,ROUND		;ROUND FA AND FB TO NEAREST INTEGER
	STCFI FA, B
	STCFI FB, A
	LDF FC,FA
	LDF FD,FB
	JSR PC,TVSCAL		;CONVERT FROM TURTLE COORDINATES TO TV COORDS
	JSR PC,ROUND		;ROUND TO NEAREST INTEGER
	STCFI FA, D
	STCFI FB, C
;	CMP A,TVX		;SEE IF WE SHOULD MOVE THE DRAWER
;	BNE BNDVE1		;YES
;	CMP B,TVY
;	BEQ BNDVE2
BNDVE1:	
;	SAVE <A,B,DISCAP>
;	BIS #.TVDSS*400,(P)	;SET THE DRAWER TO FROM-X AND FROM-Y
;	$INVOK
BNDVE2:	MOV D, TVX
	MOV C, TVY		;TO-X AND TO-Y BECOME CURRENT TV DRAWER COORDS
	SUB A,C
	SUB B,D			;TO GET DELTA-X AND DELTA-Y
;	SAVE <C,D,DISCAP>
;	BISB DRAWMD,1(P)	;SET THE MODE OF THE LINE
;	$INVOK

	JSR PC, DRAW		;Draw the line.

	JSR F,FACRES		;RESTORE THE REGISTERS
	RTS PC

;LINE DRAWER FOR TV'S
;EXPECTS:
;A - STARTING Y POSITION 0-473
;B - STARTING X POSITION 0-575
;C - DELTA Y
;D - DELTA X

DRAW:	
	TST D			;DO WE HAVE A NEGATIVE DELTA X
	BGE DRAW5		;NO
	ADD C,A
	ADD D,B
	NEG C
	NEG D			;REVERSE THE DIRECTION THE LINE IS DRAWN
DRAW5:	JSR PC, ADRMSK		;GET THE BYTE ADDRESS IN B, X MOD 16 IN A
	SAVE B			;THIS WILL GO INTO TVRADR
	MOV A, E		;BIT MASK IN E.
	TST C			;IS DELTA Y POSITIVE?
	BGE DRAW4		;YES
	MOV #-BYTLINE, A	;THE Y STEP IS ONE LINE UP THE SCREEN
	NEG C			;TO MAKE DELTA Y POSITIVE
	BR .+6
DRAW4:	MOV #BYTLINE, A		;THE Y STEP IS ONE LINE DOWN THE SCREEN
	CLR B			;THIS WILL BE FLAG FOR HORIZONTAL OR VERTICAL
	CMP C,D			;IS DELTA Y GREATER THAN DELTA X
	BGE DRAW1		;YES
	SAVE D			;SINCE D > C, D WILL BE DIVISOR
	MOV C,D			;C WILL BE THE DIVIDEND
	BR DRAW3
DRAW1:	SAVE C			;SINCE C > D, C WILL BE DIVISOR
	TST (B)+		;DRAW A VERTICAL LINE
DRAW3:	CLR C			;FOR THE DIVIDE
	ASHC #14.,C		;SO WE GET A FRACTIONAL RESULT
	DIV (P),C		;GET A QUOTIENT IN C
	MOV #40000,D		;ADD TO THIS NUMBER TO GET A CARRY
	REST F			;THE NUMBER OF STEPS WE WILL MOVE
	INC F			;SO WE SHOW THE INITIAL POINT
	BIC #TVINC, TVINCR	;INCREMENT 0
	MOV (P), TVRADR		;Set up the address [on top of stack].
	REST			;Pop one remaining arg.
	JMP @DRAWTB(B)		;DRAW EITHER A HORIZONTAL OR VERTICAL LINE




DRAWH:
	MOV WINDATA, B
DRHLUP:	
	MOV E, TVMSK		;Complement of point mask in TVMSK.
	MOV B, TVRWIN		;Write bits from B.
	ADD C,D			;ADD INCREMENT UNTIL WE OVERFLOW TO NEGATIVE
	BVC DRAWH1
	BIC #100000,D		;GO BACK TO A POSITIVE NUMBER
	BIS #40000,D		;SO WE WILL OVERFLOW AT THE RIGHT PLACE
	ADD A,TVRADR		;IF WE DID, THEN GO UP OR DOWN ONE LINE
DRAWH1:	SEC			;IN CASE PREVIOUS OP CAUSES CARRY
	ROR E			;SHIFT THE BIT RIGHT ONE POSITION
	BCS DRAWH2		;WE DID NOT OVERFLOW
	ROR E			;MOVE CARRY INTO BIT 15
	ADD #2,TVRADR		;ADVANCE TO NEXT WORD
DRAWH2:	SOB F,DRHLUP		;DRAW A MORE HORIZONTAL LINE
	RTS PC

DRAWV:
	MOV WINDATA, B
DRVLUP:
	MOV E, TVMSK
	MOV B, TVRWIN
	ADD C,D			;ADD INCREMENT UNTIL WE OVERFLOW
	BVC DRAWV1
	BIC #100000,D		;GO BACK TO POSITIVE
	BIS #40000,D		;SO WE WILL OVERFLOW AGAIN AT RIGHT PLACE
	SEC
	ROR E			;MOVE THE BIT RIGHT ONE POSITION
	BCS DRAWV1		;NO OVERFLOW
	ROR E			;MOVE BIT FROM CARRY INTO BIT 15
	ADD #2,TVRADR		;NOW DOING THE NEXT WORD
DRAWV1:	ADD A,TVRADR		;ADD THE Y INCREMENT TO THE TV ADDRESS
	SOB F, DRVLUP		;LOOP UNTIL WE FINISH DRAWING THE LINE
	RTS PC

;GETADR USES THE Y POSITION IN A AND THE X POSITION IN B TO GIVE A BYTE ADDRESS
;IN B AND MASK TO THE APPROPRIATE BIT IN A.

ADRMSK:	JSR PC, GETADR
	ASL A
	MOV POIMSK (A), A
	RTS PC


GETADR:	SAVE C			;NEED A REGISTER
	MOV B,C			;PUT X POSITION IN C
	MUL #BYTLINE, A		;ADDRESS OF THE START OF THE LINE
	MOV C,A			;PUT X BACK, THE HIGH ORDER OF MUL SHOULD BE ZERO
	ASH #-4,C		;GET WORD FROM START OF LINE
	ASL C			;BYTE
	ADD C,B			;GET THE FINAL BYTE ADDRESS
	BIC #177760,A		;GET X MOD 16 IN A
	REST C
	RTS PC
	


;CONVERT FROM TURTLE COORDINATES TO TV COORDINATES
TVSCAL:	SUBF TRLEFT,FA
	DIVF TRPRTV,FA
	STF FA,-(P)
	LDCIF TVLEFT,FA
	ADDF (P)+,FA		;X = (X - TR-PICTURE-LEFT)/TURTLE-PER-TV + TV-PICT-LEFT
	SUBF TRBOT,FB
	DIVF TRPRTV,FB		;THIS GIVES THE NUMBER OF TV STEPS FROM TOP OF DISPLAY
	STF FB,-(P)		;  AND SINCE TV LINES INCREASE DOWN THE SCREEN:
	LDCIF TVBOT,FB		
	SUBF (P)+,FB		;Y = TV-PICT-BOTTOM - (Y - TR-PICT-BOTTOM)/TR-PER-TV
	RTS PC


;TVHEAD IS USED TO SET THE TURTLE TO THE APPROPRIATE HEADING.
;EXPECTS THE NEW HEADING IN B
TVHEAD:	JSR PC, ETVTUR		;Erase the turtle if it's being shown.
TVHEA2:	MOV B,DCURA		;THIS BECOMES THE CURRENT ANGLE
	SETI
	SETD
	LDCIF B,FA
	STF FA,-(P)
	JSR PC,SINDEG		;GET DSIN A
	STCDF FA,DSINA
	LDF (P)+,FA
	JSR PC,COSDEG		;GET DCOS A
	STCDF FA,DCOSA
	JMP DTVTUR		;Show the turtle at its new location.
TVHEA1:	SEZ
	RTS PC


;ROUTINE TO DRAW POINTS
;POINT:	MOV 2(P),A		;PUT # OF ARG IN A
;	MOV (P)+,(P)
;	JSR PC,PHACK		;POINT AND POINTSTATE ARE THE SAME BUT FOR THE
;	BIS C,@D		;LAST FEW STATEMENTS. THIS IS A KLUDGE TO SAVE CORE
;	SAVE <,#-1,DISCAP>	;SET THE POINT
;	BIS #.TVMAP*400,@P	;AND TURN OFF TVMAP
;	$INVOK
;	SEZ
;	RTS PC
;
;POINTSTATE:		;POINT AND POINTSTATE ARE THE SAME BUT FOR THE LAST FEW 
;	MOV 2(P),A
;	MOV (P)+,(P)
;	JSR PC,PHACK		;STATEMENTS. IN THE INTERSEST OF SAVING CORE I'M
;	BIT C,@D		;EMPLOYING THIS KLUDGE ;TEST THE BIT
;	BEQ 1$
;	PUSHS #FALSE		;BIT IS OFF
;	BR 2$
;1$:	PUSHS #TRUE		;BIT IS SET
;2$:	SAVE <,#-1,DISCAP>	;TURN OFF TVMAP
;	BIS #.TVMAP*400,@P
;	$INVOK
;	CLZ
;	RTS PC


;Point hacking routines.

POINT:
	MOV 2 (P), A		;Pop number of args into A, stuff return address back.
	MOV (P)+, (P)	
	JSR PC, PHACK		;Argument handling routine for POINT and POINTSTATE.
	BIT #HIDETF, DFLAGS
	BNE POIHT
	SAVE <C, D>
	JSR PC, ETURST		;Erase the tutle if it's being shown.
	REST <D, C>
POIHT:	MOV D, TVRADR		;Address comes back in D, bit mask in C
	MOV C, TVMSK		;Mask register gets word with relevant bit off.
	MOV WINDATA, TVRWIN	;which gets written into memory data register.
	JMP DTVTUR

POINTSTATE:			
	MOV 2 (P), A
	MOV (P)+, (P)
	JSR PC, PSHACK
	BIT #HIDETF, DFLAGS
	BNE PSHT
	SAVE <C, D>
	JSR PC, ETURST
	REST <D, C>
PSHT:
	BIT #COLORF, DFLAGS	;Color or black-and-white? 
	BNE PSCOLOR	
PSBW:	MOV D, TVRADR		;Test to see if point masked by C is on in word at D.
	BIT C, TVRWIN
	BEQ PSRTFALSE
PSRTTRUE:			;Return true.
	JSR PC, DTVTUR
	JMP RTTRUE
PSRTFALSE: 
	JSR PC, DTVTUR
	JMP RTFALSE		;Return false.
PSCOLOR:			;Color version thereof.
	JSR PC, RTVPN		;Find number corresponding to point.
	CMP A, ERANUM		;Is the point on in the eraser color? 
	BEQ PSRTFALSE
	JSR PC, DTVTUR
	JMP RTTRUE


POINTCOLOR:			;Returns the color of a point.
	MOV 2 (P), A
	MOV (P)+, (P)
	JSR PC, PSHACK
	BIT #HIDETF, DFLAGS
	BNE PCHT
	SAVE <C, D>
	JSR PC, ETURST
	REST <D, C>
PCHT:
	BIT #COLORF, DFLAGS	;As for POINT and POINTSTATE...
	BNE PCLRC 
	MOV PENNUM, A
PCLRBW:	MOV D, TVRADR
	BIT C, TVRWIN		;In black and white, for compatibility, return 
	BNE PCLRN		;either PEN or ERASER color.
	MOV ERANUM, A
	BR PCLRN
PCLRC:	JSR PC, RTVPN		;In color, get the point's color number from the screen.
PCLRN:	ASL A
	SPUSHS PALETTE (A)	;Index into palette to retrieve symbol for color.
	JSR PC, DTVTUR
	CLZ
	RTS PC
		
		
RTVPN:				;[READ-TV-POINT-NUMBER, sort of]
	JSR PC, NOCLRW		;Common routine for point hacking, takes address
	MOV NCBITS, F 		;of a word in D, Mask for a bit in C, reads the point
	CLR B			;and returns number of point's color in A. Color write
	MOV NCSIGB, E		;mode temporarily turned off.
	MOV D, TVRADR		;Word index into address register.
	MOV #DSNUM, D
RTVLUP:	MOV (D)+, A		;Grab number of buffer from DSNUM table.
	JSR PC, SELBUF		;Select buffer number in A [SELBUF doesn't clobber].
	BIT C, TVRWIN		;Read bit in that buffer.
	BNE RTVEND		;Bit is complemented, remember.
	ADD E, B		;Add to the point's total.
RTVEND:	ASR E			;Shift bit one place to the right.
	SOB F, RTVLUP
	JSR PC, CLRWRT		;Needn't save B, CLRWRT doesn't clobber.
 	RTS PC



PHACK:	;THIS IS A KLUDGE THAT DOES THE FIRST PART OF BOTH POINT AND POINTSTATE
	JSR PC,TVDEF		;FA GETS TVX FOR ROUTINE FB GETS TVY AND CHECKS BOUNDS
	STCFI FA, B		;ADRMSK takes X in B, Y in A, returns address of word 
	STCFI FB, A		;in B, mask to point in A.
	JSR PC, ADRMSK
	MOV A, C		;Shuffle registers [perhaps change this?].
	MOV B, D
	RTS PC

PSHACK:				;For POINT reading functions, return complemented mask.
	JSR PC, PHACK
	COM C
	RTS PC


;	STCFI FA,B		;CALL ALSO DOES A SETF SETI
;	STCFI FB,D
;	CLR A			;FOR DIVIDE
;	DIV #16.,A		;WORD IN DISPLAY MEMORY=FIRST WORD OF DISPLAY MEMORY
;	MUL #36.,D		;(#DISAD)+1+36*D(NUMBER OF TVLINES DOWN)+
;	ADD A,D			;ENTIER[TVX/16.]
;	ASL D			;CONVERT TO BYTES
;	ADD #DISAD,D
;	MOV #1,C		;SET THE APPROPRIATE BIT IN C
;1$:	ROL C
;	SOB B,1$
;	ROR C
;
;	SAVE <,#DISPG,DISCAP>	;TURN ON TVMAP
;	BIS #.TVMAP*400,@P
;	$INVOK


TVARGE:	ERROR+WNA
TVDEF:	TST A
	BEQ TVDEF1		;ARGS NOT 
	CMP #2, A
	BNE TVARGE
	JSR PC, G2NARG		;GET ARGS, returns X in B, Y in A.
	SETF
	SETI
	LDCIF A, FB
	LDCIF B, FA
	LDF FA, FC
	LDF FB, FD
	BR TVDEF2
TVDEF1:	SETF
	SETI
	LDF DCURX, FA
	LDF DCURY, FB		;ARGS NOT SPECIFIED, use turtle's position.
TVDEF2:	JSR PC, TVBOUN
	JMP TVSCAL		;CONVERT TO TV COORDINATES



;ROUTINES FOR SAVING AND RESTORING FLOATING POINT REGISTERS
FACSAV:	PUSH E
	SAVE <D,C,B,A>
	STF FA,-(P)
	STF FB,-(P)
	STF FC,-(P)
	STF FD,-(P)
	STF FA,FACTMP		;TEMPORARY LOCATION
	LDF FE,FA
	STF FA,-(P)
	LDF FF,FA
	STF FA,-(P)
	LDF FACTMP,FA		;RESTORE FA
	JMP (F)			;RETURN

FACRES:	TST (P)+
	LDF (P)+,FA
	STF FA,FF
	LDF (P)+,FA
	STF FA,FE
	LDF (P)+,FD
	LDF (P)+,FC
	LDF (P)+,FB
	LDF (P)+,FA
	REST <A,B,C,D>
	POP E
	RTS F






.IFNZ DPM1
MAKEWINDOW:		;FIRST DO ARGUMENT DECODING, DEFAULT PARAMETERS, BOUNDRY CHECK 
	JSR PC,G2ARG	;FA_W SIZE
	SETI		;FB GETS W SIZE Y 
	SETF
	STF FA,FF	;COPY
	STF FB,FE	;SIZE
	LDCIF #2.,FC
	DIVF FC,FA
	DIVF FC,FB
	LDF DCURX,FC	;PRESENTLY W CENTER IS HOME
	LDF DCURY,FD
	STCFI FC,C
	STCFI FD,A
	SUBF FA ,FC	;W RT EDGE=W CENTER X-SIZE/2
	SUBF FB,FD	;LIKEWISE FOR BOTTOM
	JSR PC,TVBOUN	;CHECK BOUNDS
	LDF FC,FA	;STORE THE EDGES
	LDF FD,FB
	ADDF FF,FC	;CALC. OTHER EDGES
	ADDF FE,FD
	JSR PC,TVBOUN	;CHECK BOUNDS
	JSR PC,TVSCAL	;CONVERT [FA,FB] TO TV COORDINATES
	JSR PC,ROUND	;ROUND OFF
	STCFI FA,E
	STCFI FB,D
	LDF FC,FA	;THE SAME FOR OTHER EDGES
	LDF FD,FB
	JSR PC,TVSCAL
	JSR PC,ROUND
	STCFI FA,B
	STCFI FB,F

	SAVE <F,E,A,C> ;PUSH TOP, LEFT,W CENTER Y,WCENTER X

   ;NOW CALCULATE DIMENSIONS OF WINDOW AND LENGTH OF ARRAY NEEDED
;EMULATE THE ARGUMENT SET UP OF DEFAR SO AS TO BE ABLE TO JUMP INTO
;THE MIDDLE AND HAVE IT BIND AND ALLOCATE THE ARRAY

	SUB E,B		;#OF BITS (W LT EDGE-W RT EDGE)
	CLR A		;SET UP DIVIDE
	DIV #16.,A
	MOV B,-(P)	;PUSH LEFTOVER (REMAINDER)
	BEQ 1$
	INC A		;X DIM.=QUOITIENT+1 UNLESS NO LEFTOVER
1$:	SUB F,D		;Y DIM.=W BOTTOM-W TOP
	MOV D,F	
	MUL A,D		
	;LENGTH OF ARRAY NOW IN D
	SAVE <F,A>
	SAVE <#MAKEW1,F,A,#2>	;PUSH RETURN ADDRESS,Y DIM,X DIM,ARRAY TYPE	
	JMP WALLOC	;DO ARRAY BINDING AND ALLOCATION

  ;SET UP THE ARRAY HEADER WITH NECASSARY WINDOW INFORMATION

MAKEW1:	MOV TOPS,F	;F GETS A POINTER TO THE ARRAY
	ADD #4,F	;F NOW POINTS TO WORD ALLOCATED FOR THE # DIM
	MOV #2,(F)+	;FILL HEADER- #OF DIM
	MOV (P)+,(F)+	;XDIM
	MOV (P)+,(F)+	;YDIM
	MOV (P)+,(F)+	;SINCE THERE IS NO Z DIM I CAN STORE THE LEFTOVER IN IT
	REST <A,E>	;POP W CENX,W CENY
	MOV A,(F)+	;PUT W CENX
	MOV E,(F)+	;AND W CENY INTO ARRAY HEADER
	MOV (P),B
	SUB A,B		;DISTANCE FROM W CENTER TO LEFT EDGE
	MOV B,(F)+	;PUT IT INTO HEADER
	SPOP B
	MOV (P),D
	SUB E,D		;DISTANCE FROM W CENTER TO TOP EDGE
	MOV D,(F)+	;PUT IT IN HEADER
	SPOP D		;HEADER NOW FULL,STACK EMPTY,


;SET UP FOR TRANSFER.   THE TRANSFER IS DONE BY TWO NESTED DO LOOPS
;THE INNER LOOP READS AND SHIFTS AND STORES ONE LINE OF THE WINDOW EXCEPT
;FOR THE LAST WORD OF THE LINE WHICH NEEDS A MASK FOR THE LAST #LEFTOVER
;BITS. WHEN THE INNER LOOP IS FINISHED IT IS REINITIALIZED BY ADDING THE
;NUMBER OF WORDS ACROSS THE SCREEN MINUS THE #OF WORDS IN THE X DIM OF THE W
;TO THE POINTER INTO DISPLAY MEMORY AND PUTTING #OF WORDS IN THE X DIM OF THE W
;MINUS 1 INTO THE COUNTING REGISTER FOR THE INNER LOOP. THE OUTER LOOP DOES THIS 
;THE NUMBER OF LINES IN THE WINDOW (Y DIM)

;;Replace mask-creating code with masks from STARMSK, STOPMSK.
	CLR A		;MAKE MASK
	COM A		;OF THE #LEFTOVER
	ASH -10.(F),A	;LOW ORDER BITS
	COM A
	SPUSH A		;PUSH MASK
;	MOV -14.(F),C	;C GETS XDIM
;	SPUSH C		;PUSH INIT. VALUE OF COUNTER FOR INLUP
	SPUSH -14.(F)
	CLR A
	DIV #16.,A
	MUL #36.,D	;CALCULATE THE FIRST WORD OF WINDOW
	ADD A,D
	ASL D		;CONVERT TO BYTES
;	ADD #DISAD,D
	SPUSH D
	SPUSH B
	MOV -12.(F),C	;COUNTER FOR OUTER LOOP GETS YDIM
 ;NOW DO THE TRANSFER AND SHIFT FROM WINDOW TO THE ARRAY

;	JSR PC,TVMON
;	MOVB #1., TVINCR		;Increment address a word at a time.
;	MOV D, TVRADR
	CLRB	TVINCR
OUTLUP:	MOV 4(P),E	;(RE)SET COUNT1

INLUP:	MOV D,TVRADR
	ADD #2.,D
	MOV TVRWIN, B			;Pick up next two words of display memory.
	MOV D,TVRADR
	MOV TVRWIN, A			;Address increments a word at a time. 
;	MOV (D)+,B	;READ NEXT
;	MOV (D),A	;TWO WORD OF DISPLAY MEMORY


	ASHC (P),A	;SHIFT
	COM B		;STORE THE WINDOW IN COMPLEMENTED FORM 
	MOV B,(F)+	;PUT THE WORD INTO THE WINDOW ARRAY
	SOB E,INLUP	;ITERATE
	BIC 6.(P),-2(F)	;MASK THE EXTRANEOUS BITS

	ADD #BYTLINE, 2(P)		;Point to word in next line. 
;	MOV 2(P), TVRADR		;Less 2 because address incremented each read.
	MOV 2(P),D

	SOB C,OUTLUP	;ITERATE
	ADD #8.,P	;CLEAR STACK
	SEZ
	RTS PC


SHWERR:	ERROR+WNA
	;FIRST DECODE ARGS


HIDEWINDOW:
	JSR PC,AMAKE	;B GETS A POINTER TO WINDOW ARRAY
	MOV #TVSET, A			;Display window in eraser mode.
	CLR D
	BR DISWIN

SHOWWINDOW:				;Display window in IOR mode.
	JSR PC,AMAKE
	MOV #TVIOR, A
	BR DRAWIN

XORWINDOW:
	JSR PC,AMAKE
	MOV #TVXOR, A			;XOR mode.

DRAWIN:	MOV #-1.,D
DISWIN:	
	MOV 2(P), C			;Gobble down number of arguments.
	MOV (P)+, (P)
	SAVE <WINDATA, TVSEL>	;Bind drawmode over display of window.
	MOV D, WINDATA
	JSR PC, DRAWMODE

;	JSR PC,AMAKE
;	REST C				;Number of arguments in C.
WINDOW:	
	DEC C
	BEQ 1$		;NO ARGS INADDITION TO NAME PUT IT AT IT'S CENTER
	CMP #2,C
	BNE SHWERR	;MUST BE TWO ARGS IF NONE
	SPUSH B
	JSR PC,G2ARG	;XCEN IN A,Y CEN IN B
	SETI
	SETF
	JSR PC,TVBOUN
	JSR PC,TVSCAL
	STCFI FA,C
	STCFI FB,D
	SPOP B
	BR 2$
1$:	MOV 12.(B),C	;XCEN IN C
	MOV 14.(B),D	;YCEN IN D
2$:	;NOW SET UP STACK AND REGISTERS FOR TRANSFER
;	SPUSH #36.
;	SUB 6(B),(P)
;	ASL (P)		;CONVERT TO BYTES
;	SPUSH 6(B)	;PUSH,RESET DIPLAY MEM POINTER,INITIAL VALUE OF COUNTER (XDIM)
	MOV 16.(B),F	;DIST. FROM ORIGINAL WCENT TO LEFTEDGE
	ADD C,F		;F GETS BIT POSITION OF LEFT EDGE
	CLR E		;FOR DIVIDE
	DIV #16.,E
	NEG F		;SHIFT IS IN OPPOSITE DIRECTION
 	ADD 18.(B),D
	MUL #36.,D	;CALCULATING THE FIRST WORD IN DISPLAY MEMORY
	ADD E,D
	ASL D		;CONVERT TO BYTES
;	ADD #DISAD,D
;	SAVE <8.(B)>
	SAVE <D,6.(B),F>   ;SAVE POINTER TO DISPLAY MEM, X INDEX(XDIM),SHIFT
	MOV 8.(B),A	;A GETS Y INDEX (YDIM)
	ADD #HEADER,B
;	JSR PC,TVMON	;TURN ON TVMAP
;	JMP A

;	SPOP A
;
;	MOVB #1., TVINCR
;	SUB #2., 4(P)			;Because TVINCR adds 2 to TVRADR.
;	MOV D, TVRADR	
	CLRB TVINCR

LOOP1:	MOV 2(P),C	;A:counter y,B:pointer into array C:counter x
;D: pointer into display mem. E:,F: used for shift
;stack @P shift,2(P) counter x needed to restore,4(P) points to next line of disp. mem.
LOOP2:	MOV #-1,E		;SET ALL THE BITS IN E FOR THE SHIFT	MOV (B)+,F
	ASHC (P),E

;	COM F				;Write words in F and E on screen.
	MOV F, TVMSK			;(This loop can be optimized...)
	MOV D,TVRADR
	MOV WINDATA, TVRWIN
	ADD #2.,D
;	COM E
	MOV E, TVMSK
	MOV D,TVRADR
	MOV WINDATA, TVRWIN
;	BIS F,(D)+
;	BIS E,(D)

	SOB C,LOOP2
	ADD #BYTLIN,4(P)
	MOV 4(P),D
;	ADD 4(P), TVRADR
;	ADD 4(P),D
	SOB A,LOOP1

	ADD #6,P	;CLEAR STACK
	REST <TVSEL, WINDATA>
	SEZ 
	RTS PC

;	;TURN OFF TVMAP
;	JMP TVMOFF

;XORWIN:	JSR PC,AMAKE
;	MOV 2(P),C
;	MOV (P)+,(P)
;	JSR A,WINDOW
;	SPOP A
;LOOP3:	MOV 2(P),C
;LOOP4:	CLR E
;	MOV (B)+,F
;	ASHC (P),E
;	XOR F,(D)+
;	XOR E,(D)
;	SOB C,LOOP4
;	ADD 4(P),D
;	SOB A,LOOP3
;	ADD #6,P	;CLEAR STACK
;	JMP TVMOFF
;
;ERWINDOW:	JSR PC,AMAKE
;	MOV 2(P),C
;	MOV (P)+,(P)
;	JSR A,WINDOW
;	SPOP A
;LOOP5:	MOV 2(P),C
;LOOP6:	CLR E
;	MOV (B)+,F
;	ASHC (P),E
;	BIC F,(D)+
;	BIC E,(D)
;	SOB C,LOOP6
;	ADD 4(P),D
;	SOB A,LOOP5
;	ADD #6,P	;CLEAR STACK
;	JMP TVMOFF



;PRINTSCREEN
PRINTS:	JSR PC,TVTEST	;MAKE SURE WE ARE ON A TV
	SAVE <#-1,0,#.LPCAP*400>	;CREAT LINEPRINTER
	.INVOK
	BNE 1$
	ERROR+DIU
1$:	REST TMPCP
	SAVE <,#3,TMPCP>
$INVOK			;PUT INTO PLOT MODE, EXPAND BY 3
	JSR PC,TVMON		;MAP IN BUFFER
	MOV #DISAD,A		;TV BUFFER
	MOV #454.,B		;NUMBER OF TV LINES
PRSLP:	SAVE <#110,TMPCP>
	.WRDO
	BEQ PRSERR
	MOV #DBUF,C
	MOV #110/2,D
1$:	MOV (A)+,F
	SWAB F
	MOV F,(C)+
	SOB D,1$
	SAVE <#DBUF,#-110,TMPCP>
	.BLKO
	BEQ PRSERR
	SOB B,PRSLP
	JSR PC,DELTMP		;Falls thru to TVMOFF.

TVMOFF:	SAVE <,#-1,DISCAP>	;Turns off access to display screen memory.
	BIS #.TVMAP*400,(P)
	$INVOK
	SEZ
	RTS PC

TVMON:	SAVE <,#DISPG,DISCAP>	;GET ACCESS TO DISPLAY MEMORY
	BIS #.TVMAP*400,(P)
	$INVOK
	RTS PC


PRSERR:	ERROR+DNR
.ENDC
.ENDC
.ENDC
.ENDC		;LSICOND, BEGINNING AT "TURTLE,DISPLAY,...AND OTHER CRAP"
.INSRT 11LOGO;GTFUN >
	.STITL  DISPLAY/OTHER UTILITY

;	CALL WITH D POINTING TO CURX OR CURY.
;	RETURN THE INTEGER OF CURX OR CURY IN B
GETINT:	MOV	(D)+,B	;THE FRACTION PART
	ROL	B
	MOV	(D)+,B	;THE INTEGER PART
	ADC	B	;ROUND
	RTS	PC

SINEF:	JSR PC,G1NUM	;FA <- ARGUMENT
	BNE 1$
	ERROR+WTAB	;WRONG TYPE OF ARG
1$:	JSR PC,SINDEG	;FA <- SINE (FA)
	MOV #FNUM,F	;TELL .FST.1 IT'S AN FNUM
	STCDF FA,-(P)	;PUT SINE ON STACK FOR .FST.1
	JMP .FST.1	;PUT IT INTO A NODE
COSF:	JSR PC,G1NUM	;FA <- ARGUMENT
	BEQ SINEF+6
	JSR PC,COSDEG	;FA <- COSINE (FA)
COSF1:	MOV #FNUM,F	;TELL .FST.1 IT'S AN FNUM
	STCDF FA,-(P)	;PUT COSINE ON STACK FOR .FST.1
	JMP .FST.1	;PUT IT INTO A NODE

SINDEG:	MOV #-1,A
	BR TRIG
COSDEG:	MOV #1,A
TRIG:	MOV #1,B
	TSTF FA
	CFCC
	BGE TRIG1
	NEGF FA
	MUL A,B
TRIG1:	DIVF #41464,FA	;DIVIDE BY 45
	MODD #40200,FA	;SEPERATE FRACTION AND INTEGER
	MODD #37400,FB
	MULF #41000,FB	;MOD 8
	SETI
	STCFI FB,C
	SETL
	ASL C
	ADD C,PC
	BR .TRIG0
	BR .TRIG1
	BR .TRIG2
	BR .TRIG3
	BR .TRIG4
	BR .TRIG5
	BR .TRIG6
	MUL A,B
	BR .TRIG7
.TRIG6:	MUL A,B 
	NEG A
	BR .TRIG0
.TRIG4:	NEG B
	BR .TRIG0
.TRIG3:	NEG B
	MUL A,B
	BR .TRIG7
.TRIG2:	NEG A
	MUL A,B
	BR .TRIG0
.TRIG5:	NEG B
.TRIG1:	NEG A
.TRIG7:	SUBF #40200,FA	;WE WANT 45 - ANGLE
	NEGF FA
.TRIG0:	MULF PI,FA
	MULF #37600,FA	;CONVERT FROM DEGREES TO RADIANS
	LDD FA,FD
	MULF FD,FD
	NEGF FD		;-ANGLE SQUARED INTO FD
	LDCFD #40200,FB	;COUNTING CONSTANT "1"
	STF FB,FF
	TST A
	BLT .TRIG9	;WE WANT SIN
	LDD FB,FA
	CLRF FB
.TRIG9:	LDD FA,FC
	TSTF FD
	CFCC
	BEQ TRIG11
TRIG10:	ADDF FF,FB
	DIVF FB,FC
	ADDF FF,FB
	DIVF FB,FC
	MULF FD,FC
	ADDF FC,FA
	CMPF #41100,FB
	CFCC
	BGE TRIG10
TRIG11:	TST B
	BGE 1$
	NEGF FA
1$:	RTS PC

;ARCTAN ROUTINE
;ARG RECEIVED & RETURNED IN FA
;CALL ARG "X"; IT KEEPS CHANGING AS IT PASSES THRU THESE ROUTINES
ATAN:	JSR PC,G1ARG	;ARG IN FA, DOES SEZ IF IT FINDS A NUMBER
	BNE 2$		;DID WE GET A NUMBER?
	ERROR+WTA	;NO
2$:	SETD		;DOUBLE PRECISION

;IF X >= 0, ATAN(X) = 180/PI * ATAN1(X)
;IF X < 0, ATAN(X) = -180/PI * ATAN1(-X)
	LDD ACOPI,FD	;FD = 180/PI
	STD FD,FE	;SAVE IT IN FE
	TSTD FA		;X >= 0?
	CFCC
	BGE 1$		;IF SO, BRANCH
	NEGD FA		;FA = -X
	NEGD FE		;FE = -180/PI
1$:	JSR PC,ATAN1
	MULD FE,FA	;RESULT IN FA
	JMP COSF1	;RETURN ARG

;IF X < 10**-9, ATAN1(X) = X
;IF X > 1, ATAN1(X) = PI/2 - ATAN2(1/X)
;ELSE ATAN1(X) = ATAN2(X)
ATAN1:	CMPD TMNI,FA	;IS 10**-9 > X?
	CFCC
	BGT ATAN1B	;YES, X SMALL SO OUTPUT X
	CMPD #40200,FA	;1 < X?
	CFCC
	BGE ATAN2	;YES, SO OUTPUT ATAN2(X)
	LDD #40200,FB	;LOAD A 1 INTO FB
	DIVD FA,FB	;FB = 1/X
	LDD FB,FA	;TRANSFER TO FA
	JSR PC,ATAN2	;ATAN2(1/X)
	LDD PITWO,FB	;FB = PI/2
	SUBD FA,FB	;FB = PI/2 - ATAN2(1/X)
	LDD FB,FA	;TRANSFER TO FA
ATAN1B:	RTS PC

;ATAN2(X) = (X*(B0+(A1/(Z+B1+(A2/(Z+B2+(A3/(Z+B3))))))))
	;WHERE Z = X**2
	;INTERMEDIATE RESULT CALLED "OP"
ATAN2:	LDD FA,FB	;FA CONTAINS X
	MULD FB,FB	;FB = X**2
	MOV #ATANTB,D	;POINT TO TABLE OF CONSTANTS

	LDD FB,FC	;FC = Z
	ADDD (D)+,FC	;FC = B3 + Z

	LDD (D)+,FD	;FD = A3
	DIVD FC,FD	;FD = A3/OP; FD = NEW OP

	LDD (D)+,FC	;FC = B2
	ADDD FB,FC	;FC = Z + B2
	ADDD FD,FC	;FC = FC + OP; FC = NEW OP

	LDD (D)+,FD	;FD = A2
	DIVD FC,FD	;FD = A2/OP; FD = NEW OP

	ADDD (D)+,FB	;FB = Z +B1
	ADDD FD,FB	;FB = FB + OP; FB = NEW OP

	LDD (D)+,FD	;FD = A1
	DIVD FB,FD	;FD = A1/OP; FD = NEW OP

	ADDD (D)+,FD	;FD = OP + B0
	MULD FD,FA	;FA = OP * X
	RTS PC
	.STITL	MUSIC PRIMITIVES

.IFZ LSI	;RESUME LSICOND UNTIL END OF MUSIC PRIMITIVES
SING:	EXCH (P),2(P)
	JSR	PC,MCHK
	JSR	PC,REVS	;FOR MULTIPLE ARGUMENTS
	MOV	(SP)+,D	;NUMBER OF ARGS
	ASR	D	;IS IT EVEN?
	BCC	SING2
	ERROR+WNA	;WRONG NUMBER OF ARGS
SING2:	MOV	VOICEN,E	;INDEX FOR VOICE (0,2,4 OR 6)
	MOV	VLAST(E),F	;POINTER TO LAST NODE IN VOICE
SING3:	DEC	D
	BGE	SING31
	SEZ
	RTS PC
SING31:	JSR	PC,G2NARG	;DURATION IN B, PITCH IN A
	JSR	PC,SINGNO	;NORMALIZE MIDDLE C TO 0.  ERROR IF NOTE OUT OF RANGE
	TST	B	;DURATION
	BGE	SING7
SING6:	ERROR+DOR	;DURATION OUT OF RANGE
SING7:	CMP	B,#177	;LARGEST LEGAL DURATION (+- 7 BITS)
	BGT	SING6
	ADD	B,VOICLN(E)	;ACCUMULATE TOTAL FOR VOICE
	CMP	B,#1
	BLT	SING3	;IF ZERO THEN GO ON
	BNE	SING8
	NEG	B	;IF 1 THEN SET TO -1 AS FLAG FOR PERFORM
SING8:	SWAB	A
	BIC	#177400,B	;CLEAR TOP HALF
	BIS	A,B	;SET UP 8 BITS PITCH, 8 BITS DURATION IN B
	JSR	PC,ACTSTO	;BUILD ON TO VOICE LIST
	MOV	F,VLAST(E)	;NEW LAST NOTE
	BR	SING3


;NORMALIZE MIDDLE C TO 0
;ERROR IF NOTE OUT OF RANGE.
SINGNO:	ADD	#74,A	;NORMALIZE 0 TO MIDDLE C
	CMP A,#MBTRAP
	BEQ SINGN1
	CMP	A,#MBREST	;SMALLEST VALID PITCH
	BGE	SINGN2
SINGN1:	ERROR+NOG	;NOTE OUT OF RANGE
SINGN2:	CMP	A,#137	;HIGHEST VALID NOTE
	BGT	SINGN1
	RTS	PC
NOMUSIC:
	TST PTBF
	BEQ NOMUS1
	MOV #PMBOX,A
	JSR PC,TBCHK
	BEQ NOMU9
	BIC #INITF,(A)
	BR MUSIN
NOMUS1:	MOV	MBDN,E
	JSR	PC,CLOSE1
	BNE	NOMU9	;BR IF NOT OPEN ANYWAY
	BR	MUSIN	;ELSE CLEAR OUT MUSIC VOICES, ETC.

;TRY TO GET MUSIC BOX AND INITIALIZE
;IF DON'T ALREADY HAVE IT
MCHK:	TST PTBF
	BEQ MCHK1
	MOV #PMBOX,A
	JSR PC,TBCHK
	BNE 1$
	ERROR+DNR
1$:	BIT #INITF,(A)
	BNE NOMU9
	BIS #INITF,(A)
	BR MUSIN
MCHK1:	MOV	MBDN,E
	TSTB TTYCPS(E)		;OPEN ALREADY?
	BNE NOMU9		;YES, FORGET IT
	JSR	PC,OPEN1
MUSIN:	MOV	#100,MUCWRD	;FOR NVOICES 4
	MOV	#MUSBEG,A
MUSIN1:	CLR	(A)+
	CMP	A,#MUSEND
	BLT	MUSIN1
	MOV	#MVOC,A	;CLEAR OUT THE POINTERS IN USER SPACE
	CLR	(A)+
	CLR	(A)+
	CLR	(A)+
	CLR	(A)+
	JSR	PC,MCL	;SET UP DUMMY NODES
	MOV	#6,NVOIC	;NUMBER OF VOICES
NOMU9:	SEZ
	RTS	PC

			;SET UP DUMMY MUSIC LISTS
MCL:	MOV	#6,F
	CLR	B
	MOV	#LSTR,A
MCL2:	MOV	MVOC(F),TOPS	;FREE MUSIC NODES
	JSR	PC,FRELST
	JSR	PC,GRBAD	;GET A NEW NODE
	BIS	A,C
	CLR	B
	JSR	PC,.STORE
	MOV	C,MVOC(F)	;POINTER TO IT
	MOV	C,VLAST(F)
	CLR	VOICLN(F)
	SUB	#2,F
	BGE	MCL2
	RTS	PC

MCLEAR:	JSR	PC,MCHK
	JSR	PC,MCL
	SEZ
	RTS PC
VLEN:	JSR	PC,MCHK	;OUTPUT LENGTH OF CURENT VOICE
	MOV	VOICEN,B
	MOV	VOICLN(B),B
	JMP	R1NARG

MLEN:	JSR	PC,MCHK
	MOV	#4,D
	MOV	#VOICLN,F
	CLR	B
MLEN1:	MOV	(F)+,A	;GET MAXIMUM VOICE LENGTH
	CMP	A,B
	BLE	MLEN2
	MOV	A,B
MLEN2:	DEC	D
	BNE	MLEN1
	JMP	R1NARG

;LIKE TYO, EXCEPT TO MUSIC BOX SPECIFICALLY, ALSO TAKES VARIABLE ARGS, AND CONVERTS
;ARGS TO MUSIC BOX NOTES				
MUTYO:	EXCH (P),2(P)	;EXCHANGE THE STUFF ON THE STACK
	JSR PC,REVS
	JSR PC,MCHK	;CHECK TO MAKER SURE THAT THE MUSIC BOX IS WHERE IT SHOULD BE
	SPOP C		;THE ARGUMENT
	BEQ MUTYO2	;NO CHARACTERS TO SEND BECAUSE NO ARGS
MUTYO1:	JSR PC,G1NARG	;B _ CHARACTER
	MOV B,A		;COPY IT
	JSR PC,SINGNO	;NORMALIZES IT TO MIDDLE C
	MOV A,D		;THE CHAR TO OUTPUT
	JSR PC,TMBTYO	;TYO THE CHARATER
	SOB C,MUTYO1	;FOR ALL THE CHARACTERS
MUTYO2:	.IIF NZ PTBOX,JSR PC,TBREST	;CHANGE BACK TO CONSOLE MODE (NO CHOICE)
	SEZ
	RTS PC

;SENDS CONTROL INFO TO THE MUSIC BOX
MUCTRL:	JSR PC,MCHK	;CHECK TO MAKE SURE MUSIC BOX IS OPEN
	JSR PC,G1NARG	;GET THE ARGUMENT
	MOV B,D		;THE ARG
	BLT MUCERR	;MUST BE A NUMBER BETWEEN 0,,33
	CMP D,#33.
	BLE MUC1	;FINE
MUCERR:	ERROR+WTIB	;BAD ARGMENT TO MUCTRL
;ARG IS DECODED AS FOLLOWS:
;	TOP DIGIT IS SILENCE CONTROL, BOTTOM DIGIT IS LOADING CONTROL (BOTH <4)
MUC1:	CLR C		;FOR THE DIVIDE
	DIV #10.,C	;C_ 10'S D_ UNITS
	ASH #4,C	;SHIFT INTO BITS 6,5
	BIC #177774,D	;LEAVE ONLY THE BOTTOM TO BITS
	BIS C,D		;SET IN THE SILENCE INFO
	BIT #40,D	;BIT 6 CANT EQUAL BIT 7 (ITS A CROCK!!!)
	BNE MUC2	;BIT 6=1
	BIS #100,D	;SO MAKE BIT 7 = 1
MUC2:	MOV D,MUCWRD	;CURRENT CONTROL WORD
	JSR PC,MUCTYO	;OUTPUT THAT BYTE
.IIF NZ PTBOX,	JSR PC,TBREST	;RESET THE MUSIC BOX (GROAN)
	SEZ
	RTS PC
GTVARG:	JSR	PC,G1NARG
	DEC	B	;TRANSFORM VOICE NUMBER (1,2,3,4) TO INDEX (0,2,4,6)
	ASL	B
	TST	B
	BGE	GTV2
GTV1:	ERROR+IVV	;INVALID VOICE NUMBER
GTV2:	CMP	B,#6
	BGT	GTV1
	RTS	PC

VOICE:	JSR	PC,MCHK
	JSR	PC,GTVARG
	MOV	B,VOICEN
	SEZ
	RTS PC

NVOICES:	JSR	PC,MCHK
	JSR	PC,MCL	;REINITIALIZE
	JSR	PC,GTVARG
	MOV	B,NVOIC	;SET NEW VOICE NUMBER
	SEZ
	RTS PC

MBON:	MOV MBDN,E
	MOV	NVOIC,A
	ASR	A	;TURN INTO BYTE INDEX
	MOV	A,B
	CMP	#2,A	;IN NVOICES 3,
	BNE	MBON1
	INC	A	;IT IS NECESSARY TO SILENCE 4 VOICES
MBON1:	MOVB	MBSCH(A),D	;CHAR FOR A VOICES, BUT ALL SILENT
	JSR	PC,MUCTYO
	MOV	#MBREST,D
	INC	A
MBON2:	JSR	PC,TBTYO1	;OUTPUT REST
	SOB	A,MBON2
	MOVB	MBVCH(B),D	;CONTROL CHR  FOR NUMBER OF VOICES
	MOV	D,MUCWRD
	JSR	PC,MUCTYO	;LEAVE BOX READY FOR NOTES
	RTS	PC

;SILENCE MBOX, BUT DON'T CHANGE NUMBER OF VOICES OR ANYTHING
MBOFF:	MOV	MUCWRD,D
	BIC	#177774,D	;LEAVE NUMBER OF VOICES INFO INTACT
	BIS	#100,D
	MOV	D,MUCWRD
	JSR	PC,MUCTYO
.IIF NZ PTBOX,	JSR PC,TBREST
	RTS	PC

;CALLED BY BREAK AND PAUSE TO SHUT THE  DAMN THING UP
BRKMOF:	MOV	MBDN,E
	TSTB TTYCPS(E)	;OWN MUSIC BOX
	BEQ BRKMO9	;NO
	JSR	PC,MBOFF
	RTS	PC

;CALLED BY CONTINUE TO TURN MBOX BACK ON
BRKMON:	MOV	MBDN,E
	TSTB TTYCPS(E)	;OWN MUSIC BOX
	BEQ BRKMO9	;NO
	MOV	MUCWRD,D
	JSR	PC,MUCTYO
BRKMO9:	RTS	PC
			;OUTPUT MUSIC TO THE BOX
PM:	JSR	PC,MCHK
	JSR	PC,MBON
	MOV	NVOIC,A
	MOV	A,F	;USED AS POINTER TO CORRECT VOICE
	ADD	#VOICLN+2,A	;SET UP FLAGS IN VOICLN SLOTS
PM1:	MOV	#-1,-(A)
	CMP	A,#VOICLN
	BGT	PM1
PM2:	JSR	PC,PMCHP	;GRAB DUMMY NODE OF EACH VOICE
	JSR	PC,PMCHP	;NOW SET UP FIRST NODE OF MUSIC
PM21:	SUB 	#2,F
	TST	F
	BGE	PM2
PM3:	TST BRAKE
	BNE PM6
	CLR	F	;LOOP TO OUTPUT NOTES
PM4:	JSR	PC,PMNXT	;F IS INDEX TO VOICE
	ADD #2,F	;POINT TO THE NEXT ONE
	CMP	F,NVOIC	;ONE NOTE FROM EACH VOICE
	BLE	PM4
	CLR	B
	MOV	NVOIC,A	;ADD FLAGS FOR ALL VOICES
	ADD	#VOICLN+2,A
PM5:	ADD	-(A),B
	CMP	A,#VOICLN
	BGT	PM5
	TST	B	;IF ALL FLAGS CLEARED THEN DONE
	BNE	PM3
PM6:	JSR	PC,MBOFF
	JSR	PC,MCL	;REINIT MUSIC VARIABLES
	SEZ
	RTS PC

			;OUTPUT ONE NOTE FROM VOICE(F)
PMNXT:	DEC	TEMP	;NOTE COUNTER
	MOV	#MBREST,D
	TST	VOICLN(F)	;IF FLAG CLEARED OUTPUT REST
	BNE	PMNXT2
	JSR PC,TMBTYO
	RTS	PC
PMNXT2:	CMPB	VLAST(F),#1	;IF DUR=1 PLAY A REST
	BEQ	PMNX2A
	MOVB	VLAST+1(F),D	;PITCH
PMNX2A:	JSR	PC,TMBTYO
	DECB	VLAST(F)	;DECREMENT DURATION
	BGT	PMNXT3
	JSR	PC,PMCHP	;IF DUR<=0 SET UP NEXT NODE
	RTS	PC
PMNXT3:	CMPB	D,#MBPERC	;IS THIS A PERCUSSION SOUND?
	BGT	PMNXT4	;NO
	MOVB	#MBREST,VLAST+1(F)	;YES--CHANGE ALL BUT FIRST TO RESTS
PMNXT4:	RTS	PC

PMCHP:	MOV	MVOC(F),C	;SET UP NEXT NODE SKIP IF SUCCESSFUL
	BIC	#170000,C
	BNE	PMCHP1
	CLR	VOICLN(F)	;CLEAR FLAG TO INDICATE NO NEXT NODE
	RTS	PC
PMCHP1:	JSR	PC,.LOADC
	BIC #170000,A
	BIS #LSTR,A
	MOV	A,MVOC(F)
	MOV	B,VLAST(F)	;PUT PITCH,,DURATION IN VLAST SLOT
	JSR	PC,.FREE	;FREE OLD NODE
	RTS	PC

TMBTYO:	SPUSH C
	MOV #PMBOX,C
	JSR PC,TBTYO
	SPOP C
	RTS PC

MUCTYO:	SPUSH D
	MOV #MBTRAP,D		;TRAP CHARACTER FOR THE MUSIC BOX
	JSR PC,TMBTYO		;OUTPUT IT
	SPOP D			;GET BACK ORIGINAL CHARACTER
	JSR PC,TBTYO1		;OUTPUT IT
	RTS PC

TBTYO:	JSR PC,TBINIT		;INIT THE PRIVATE THORTON BOX IF OWNED
TBTYO1:	SAVE D			;THE CHARACTER TO OUTPUT
	TST PTBF		;THORTON BOX PRIVATE?
	BEQ 1$			;NO, USE THE NUMBER IN E
	MOV TYICP,-(P)		;USE MY CAPABILITY INSTEAD
	BR 2$			;SKIP CRAP WITH GETTING CAPABILITY NUMBER
1$:	CLR -(P)
	MOVB TTYCPS(E),(P)
2$:	$BYTO			;OUTPUT IT
	RTS PC

TBCHK:	TST PTBF
	BNE TBCHK2
	RTS PC
TBCHK2:	SPUSH B
	SPUSH C
	MOV #4,B
	MOV #PTBTAB,C
TBCHK3:	CMPB A,(C)
	BEQ TBCHCZ
	TST (C)+
	SOB B,TBCHK3
TBCHSZ:	SPOP C
	SPOP B
	SEZ
	RTS PC
TBCHCZ:	MOV C,A
	SPOP C
	SPOP B
	CLZ
	RTS PC

CTYOWA:
TYOWAI:
	ERROR+SIT
	.STITL NEW FILING

;USER PRIMITIVE ROUTINES

;DIRSET TAKES A LIST AND SETS THE CURRENT DIRECTORY

DSET:	JSR PC,SETNM	;GET NAME OF DIRECTORY
	BNE DSET1	;INPUT IS A LIST
	JMP COPDEF
DSET1:	JSR PC,COPDEF
DIRSET:	JSR PC,GNWRD	;GET A WORD FROM THE LIST
	BNE 1$		;ANY LEFT?
	RTS PC		;NONE LEFT, DONE
1$:	JSR PC,DIRGET	;GET NEXT ITEM FROM LIST
	BR DIRSET	;AND CONTINUE WITH THE NEXT NAME


DIRGET:	JSR PC,NNFNGT	;GET A FILE NAME
	MOV #NAME,E
1$:	TSTB (E)+	;NO, FIND IT
	BNE 1$
	DEC E
	CMPB #';,-(E)	;IS THIS THE ROOT DIRECTORY?
	BNE DIRGT1
	CMP #NAME+1,E	;JUST ROOT?
	BHI DIRGT2
	BLO DIRGT8	;DISK NAME	
	MOVB -(E),A	;NO, GET WHICH ROOT HE WANTS
	SUB #60,A	;MAKE SURE HE TYPED A NUMBER
	BLT DIRGT8	;MAYBE IT IS A NAME
	CMP DISKS,A	;NUMBER?
	BLE DIRGT8	;MAYBE A NAME
DIRGT9:	ADD #10,A	;GET TO THE ROOT CAPABILITIES
	MOV A,CURROT
DIRGT2:	MOV CURROT,A
	JMP COPCUR
DIRGT8:	MOV #DNAMEP,A	;POINTER TO TABLE OF NAME POINTERS
2$:	MOV (A)+,B	;POINTER TO A NAME
	BNE 1$
	ERROR+BDD	;BAD DISK NAME
1$:	MOV #NAME,C	;POINTER TO HIS NAME
3$:	CMPB (C)+,(B)+
	BEQ 3$
	TSTB -1(B)	;END?
	BNE 2$
	CMPB -1(C),#';
	BNE 2$
	SUB #DNAMEP+2,A	;GET NUMBER*2
	ASR A		;CAP NUMBER
	BR DIRGT9

DIRGT1:	CLR -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAMU,(P)	;MUTATE IT
	.INVOK
	BNE 1$
	ERROR+NED	;DIRECTORY NOT FOUND
1$:	SAVE <#FILBLK,#10,CURCAP>
	BIS #.FARI,(P)	;READ THE CAPABILITY TYPE
	$INVOK
	BIT #.FADIR,FILBLK+2	;CHECK THAT IT IS A DIRECTORY
	BNE 2$
	ERROR+ENDR
2$:	RTS PC
;COPY THE DEFAULT CAPABILITY INTO THE CURRENT CAPABILITY
COPDEF:	MOV DEFCAP,A
	MOV DEFROT,CURROT
COPCUR:	JSR PC,FLSCUR	;GET RID OF ANY CURRENT CAPABILITY
	SAVE <#-1,#0,A>	;TO COPY CAPABILITY
	BIS #.CPYCP,(P)	;TO COPY
	.INVOK
	BNE 1$
	ERROR+BDD
1$:	REST CURCAP
	RTS PC
	
.DIRSET:
	BIT #7777,@S	;CHECK NAME OF DIRECTORY ON S-PDL
	BNE .DIRS1
	SPOPS A		;NOTHING TO DO
	SEZ
	RTS PC
.DIRS1:	JSR PC,DSET	;SET THE DIRECTORY
USEENT:	JSR PC,DIRGET	;SET UP FILES
	MOV CURCAP,DEFCAP
	CLR CURCAP
	MOV CURROT,DEFROT
	SEZ
	RTS PC
.USE:	BIT #7777,@S
	BNE .USE1
	SPOPS A
	SEZ
	RTS PC
.USE1:	TST FILFLG	;FILE ALREADY OPEN?
	BEQ 1$		;NO, PROCEED
	ERROR+FAO	;YES, ERROR
1$:	MOV DEFROT,A
	JSR PC,COPCUR	;MAKE THE DEFAULT ROOT BE THE CURRENT CAP
	TST -(P)
	SAVE <#USERS,CURCAP>
	BIS #.FAMU,(P)	;TO MAKE A CAP TO USERS
	.INVOK
	BNE 2$
	ERROR+BDD
2$:	JSR PC,SETNM
	BEQ 3$
	JSR PC,DIRSET
3$:	BR USEENT


.DELETE:	JSR PC,DSET
	JSR PC,NNFNGT
	TST -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAMU,(P)
	.INVOK
	BNE 1$
	ERROR+FNF
1$:	SAVE <,,CURCAP>
	BIS #.FADL,(P)
	.INVOK
	BNE 2$
	ERROR+CDE
2$:	JSR PC,FLSCUR
	SEZ
	RTS PC



;MAIL PRIMITIVE. SENDS "MAIL" TYPED ON SCREEN TO PERSON SPECIFIED
	;BY INSERTING TEXT INTO HIS OWN MAIL FILE, IF ONE EXISTS
	;OR CREATING A NEW ONE IF ONE DOESN'T
MAIL:	MOV #10,A	;GET CAPABILITY TO ROOT DIRECTORY
	JSR PC,COPCUR
	SAVE <#0,#MAILNM,CURCAP> ;MUTATE TO MAIL DIR. ENTRY IN ROOT DIR.
	BIS #.FAMU,(P)	
	.INVOK
	JSR PC,.OPNA3	;OPEN MAIL FILE
	MOV #.WRTEC,PCHR	;CHARS. IN BUFFER INTO OUTPUT DEVICE
	PRTXTC ^/------/
LANGC	<PRTXT ^/MAIL FROM />,<
	PRTXT ^/EN PROVENANCE DE />
	SAVE <#NAME,#-1> 	
	.CRUSR		;GET SENDER'S NAME IN "NAME"
	MOV #NAME,A	
	JSR PC,PRAS	;PRINT NAME POINTED TO BY A
	JSR PC,.CRLF	;CARRIAGE RETURN, LINEFEED
	JSR PC,UDATEG	;SET THE DATE
	SPUSH #1
	JSR PC,TYPE	;PRINT THE DATE
	JSR PC,.SPACE
	JSR PC,UTIMEG	;SET THE TIME
	SPUSH #1
	JSR PC,PRINT	;PRINT THE TIME
	SPUSH PRMTCH	;SAVE NORMAL PROMPT CHARACTER
	MOV #'_,PRMTCH	;NEW ONE IS "_"
	MOV #TYO,PCHR
MAIL2:	JSR PC,RDSTR	;READ A STRING
	BEQ MAIL3	;NO CHARACTERS TYPED
	MOV @S,B	;POINTER TO STRING
	JSR PC,.LOADB	;FIRST CHARACTER
	CMP #'.,B	;IS IT A PERIOD?
	BEQ MAIL1	;YES (NO MORE INPUT)
	JSR PC,.FILEP
	BR MAIL2
MAIL1:	SPOP PRMTCH	;GET BACK OLD PRMTCH ("?")
	MOV #.WRTEC,PCHR
	SPOPS A
	PRTXTC ^/------/
	MOV #TYO,PCHR
	JMP .WRTCL
MAIL3:	BR MAIL2	;BREAK CODING USED TO BE HERE


READPT:	JSR PC,FILCHK
	REST <A,B>	;GET RET ADDR + NUM ARGS
	SAVE A		;PUT BACK ADDR
	TST B		;ZERO ARGS?
	BEQ READP1	;JUST READ INTO WORKSPACE
	CMP #1,B	;EXACTLY 1?
	BEQ 1$		;YUP
	ERROR+WNA
1$:	JSR PC,.OPENW	;OPEN FILE FOR OUTPUT
	JSR PC,PTRCRT	;TRY TO CREATE A PTR
	MOV F,TMPCP	;SAVE IN THE TEMP CAP
READP3:	SAVE TMPCP
	.BYTI		;READ FROM PT
	BEQ READP2	;DONE
	REST D		;GET THE CHAR WE READ
	JSR PC,.WRTEC	;WRITE TO FILE
	BR READP3

READP2:	REST A		;FLUSH CAP
	JSR PC,DELCAP	;DELETE CAP TO PTR
	CLR TMPCP
	JSR PC,.WRTCL	;CLOSE FILE
	SEZ
	RTS PC	

READP1:	JSR PC,PTRCRT	;GET PAPER TAPE
	JSR PC,FLSCUR
	MOV F,CURCAP
	MOV #.PREAD,GCHR
	BR .READ9

.PREAD:	SAVE CURCAP
	.BYTI
	BNE 1$
	MOV #TYI,GCHR
	JSR PC,FLSCUR
	MOV #EOFCHR,(P)
1$:	REST D
	RTS PC

PTRCRT:	SAVE <#-1,0,#.TRCAP*400>	;CREATE TAPE READER
	.INVOK		;TRY TO GET
	BNE 1$		;READ INTO WORKSPACE
	ERROR+DIU
1$:	REST F
	RTS PC

.IFZ BEEF
.READ:	JSR PC,.READF
.READ1:	MOV #.READCH,GCHR
.READ9:	MOV PC,REDFLG
	JSR PC,SAVEVL
	PUSH #0	;NO. OF ARGS
	JSR PC,SAVPPS
	BIS #DORF,FLAGS
	BIS #1,CPDLP
RMLOOP:	CMP #TYI,GCHR
	BEQ RMLOO1
	JSR PC,RDSTR
	BEQ RMLOO2
	JSR PC,READ
	BEQ RMLOOP	;NO TOKENS
	JSR PC,EVLINE
	BEQ RMWDW
	POPS A
	BR RMLOOP
RMWDW:	ERROR+WDW
RMLOO1:	TST TOPRNM	;DONE, PROC DEF PENDING?
	BEQ 1$
	JSR PC,END
1$:	MOV #RET,PSTOPR
	JSR PC,RESPPS
	POP B
	JSR PC,RESEVL
	MOV B,FLAGS
	MOV CTP,C
	CLR D
	JMP PSTOP6
RMLOO2:	BIT #RBRKF,TFLAGS
	BEQ 1$
	ERROR+BRK
1$:	CMP #TYI,GCHR
	BEQ RMLOO1
	BR RMLOOP
.ENDC

.IFNZ BEEF
.READ:	JSR PC,.READF			;OPEN THE FILE FOR READING
.READ1:	MOV #.READCH,GCHR		;WHERE TO GET THE CHARACTERS
.READ9:	MOV PC,REDFLG			;SAY WE ARE READING
	PUSHS ILINEL			;SAVE THE ILINE FOR LATER
	JSR PC,SAVEVL			;SAVE EVAL
	PUSH #0				;THE NUMBER OF ARGUMENTS
	JSR PC,SAVPPS			;SAVE THE PDL POINTERS
	BIS #DORF,FLAGS			;SAY THIS IS A READ FRAME
	BIS #1,CPDLP			;SAY IT IS A PROCEDURE TYPE PUSH
RMLOOP:	CMP #TYI,GCHR			;ARE WE AT EOF?
	BEQ RMLOO1			;YES, FINISH UP
	JSR PC,RDSTR			;PUSH A STRING ONTO THE STACK
	BEQ RMLOO2			;TRY AGAIN
	JSR PC,MREAD1			;READ IT, AND PUT INTO THE COMMAND BUFFER
	BEQ RMLOO2			;NO TOKENS, CHECK FOR BREAK
	JSR PC,EVLINE			;EVALUATE THE LINE
	BNE RMLOOP			;NO OUTPUT, JUST CONTINUE
	ERROR+WDW			;DONT SAY WHAT TO DO WITH
RMLOO1:	TST TOPRNM			;DONE, DEFINING A PROCEDURE?
	BEQ 1$				;NO, DONT WORRY ABOUT IT
	JSR PC,END			;FINISH ITS DEFINITION
1$:	MOV #RET,DOFRET			;DITTO
	JMP POPVAR			;POP OFF THE READ FRAME
RMLOO2:	BIT #RBRKF,TFLAGS		;BREAK?
	BNE 1$				;YES
	CMP #TYI,GCHR			;STILL INPUTTING FROM FILE?
	BEQ RMLOO1			;NO, FINISH UP
	BR RMLOOP			;GO BACK FOR MORE
1$:	ERROR+BRK
.ENDC

.WRITE:	JSR PC,.WRTEF
	MOV #.WRTEC,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	CLR WRTFLG
	JSR PC,.WRTCL
	MOV #TYO,PCHR
	SEZ
	RTS PC
.READF:
.OPENR:	JSR PC,DSET
	JSR PC,NNFNGT
	JSR PC,FREADR
	BNE 1$
	ERROR+FNF
1$:	SEZ
	RTS PC

FREADR:	CLR -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAMU,(P)
	.INVOK
	BEQ FREAD1
	JSR PC,DIRCHK	;FILE OR DIRECTORY?
	BEQ FREAD2	;FILE
	MOV #2,FILFLG	;DIRECTORY
	MOV PC,DIRFLG	;THIS FLAG IS NONZERO TILL DBUF HAS GOTTEN THE END OF THE DIR
	SAVE #.READD
	$FORK		;START COROUTINE TO FILL DBUF WITH DIRECTORY STUFF
	BR FREAD3
FREAD2:	SAVE <,,CURCAP>
	BIS #.FARE,(P)
	$INVOK		;GET FILE LENGTH
	REST <FEOF+2,FEOF>
	MOV #1,FILFLG
FREAD3:	CLR DBUFCC
	CLZ
	RTS PC
FREAD1:	ADD #6,P
	SEZ
	RTS PC

;READ A CHARACTER
.READC:	TST FILFLG	;IS ANYTHING OPEN FOR READING?
	BLE .REDC1	;NO
	DEC DBUFCC	;ONE LESS CHAR IN BUFF
	BLT .REDC4
	MOVB @DBUFP,D
	INC DBUFP
	RTS PC
.REDC4:	CMP FILFLG,#1	;FILE OR DIRECTORY?
	BEQ .REDC2	;FILE
	TST DIRFLG	;DIRECTORY. ANYTHING LEFT IN IT?
	BEQ .REDC1	;NO, FINISH UP
	JSR PC,DRBLKI	;DO A "BLKI" FROM THE DIRECTORY
	BR .READC
.REDC2:	TST FEOF+2	;PAST EOF?
	BLT .REDC1
	CLR DBUFCC
	SUB #DBUFL,FEOF
	SBC FEOF+2
	BGE .REDC8
	MOV FEOF,DBUFCC
.REDC8:	SAVE <#DBUF,#-DBUFL,CURCAP>	
	.BLKI
	BNE .REDC7
	ADD #6,P
.REDC7:	MOV #DBUF,DBUFP
	ADD #DBUFL,DBUFCC
	BR .READC
.REDC3:	TST (P)+
.REDC1:	JSR PC,.REDCL	;CLOSE FILE FOR READING
	CLR REDFLG	;CLEAR READ FLAG
	MOV #EOFCHR,D	;D POINTS TO LAST CHARACTER OF FILE
	RTS PC

.READD:	MOV #DPDL,P	;THIS GETS FORKED TO AS A COROUTINE, SO IT NEEDS ITS OWN PDL
	SAVE DRBUFF
	$QULK		;WAIT FOR .FILER COROUTINE TO GIVE THE GOAHEAD
	JSR PC,.POI
	CLR DIRFLG	;SIGNAL THAT NOTHING'S LEFT IN THE DIRECTORY
	MOV #DBUF,DBUFP	;REINIT BUFFER POINTER
	SAVE DRSTUF
	$QUNLK		;PROCEED THE .FILER PROCESS
	$POOFF		;AND DISAPPEAR

			;THIS GETS PUT IN PCHR WHEN .POI RUNS AS COROUTINE OF .FILER
DIRHAC:	CMP DBUFP,#DBUF+DBUFL	;END OF BUFFER?
	BLOS 1$
	MOV #DBUF,DBUFP	;REINIT POINTER
	SAVE DRSTUF
	$QUNLK 		;TELL .READC TO GO AHEAD
	SAVE DRBUFF
	$QULK		;AND WAIT TILL BUFFER'S EMPTY & MORE IS WANTED
	RTS PC
1$:	MOVB D,@DBUFP	;MOVE CHARACTER INTO DBUF
	INC DBUFP	;UPDATE POINTER
	INC DBUFCC	;AND COUNTER
	RTS PC

DRBLKI:	CLR DBUFCC	;INIT COUNT
	MOV #DBUF,DBUFP	;AND POINTER
	CLR -(P)
	CLR -(P)
	SAVE CURCAP	;LET'S MAP IN THE DIRECTORY
	MOVB #HAKPG+10,1(P)	;PAGE DESTINATION
	SAVE #.CRRD!1	;SPHERE CAP & PAGE TYPE
	$MAP
	MOV #CURCAP,DIRCAP	;WE WANT .POI TO USE CURCAP, NOT TMPCP
	SAVE <PCHR,PPOPL,PPUSHL>	;THESE NEED TO BE DIFFERENT FOR OUR COROUTINE
	MOV #DIRHAC,PCHR	;PCHR SHOULD READ INTO THE BUFFER, NOT PRINT OUT
	CLR PPUSHL	;COROUTINE HAS ITS OWN STACK & STACK AREA
	MOV #77777,PPOPL
	SAVE DRBUFF
	$QUNLK		;PROCEED THE .POI COROUTINE
	SAVE DRSTUF
	$QULK		;AND HANG TILL IT FILLS THE BUFFER (OR FINISHES)
	REST <PPUSHL,PPOPL,PCHR>	;THESE SHOULD BE NORMAL WHEN CO-RTN NOT RUNNING
	MOV #TMPCP,DIRCAP	;THIS GOES BACK TO NORMAL TOO
	RTS PC

.OPENA:	JSR PC,DSET	;SETS DIRECTORY
.OPNA3:	JSR PC,NNFNGT	;SET FILE NAME
	CLR -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAMU,(P)
	.INVOK		;TRY TO READ THE FILE
	BEQ .OPNA1
	JSR PC,DIRCHK	;DO WE HAVE A FILE OR A DIRECTORY?
	BEQ .OPNA2	;IF FILE, PROCEED
	JSR PC,FLSCUR	;IF DIRECTORY, FLUSH THE CAPABILITY
	ERROR+FNF	;AND COMPLAIN
.OPNA1:	CLRB 1(P)	;FLUSH OLD FUNCTION
	BIS #.FAAD,(P)	;TRY TO MAKE A NEW FILE
	.INVOK
	BNE .OPNA2
	BPT
.OPNA2:	CMP -(P),-(P)	;DUMMY
	SAVE <CURCAP>
	BIS #.FARE,(P)
	$INVOK		;READ THE END OF FILE
	MOV #DBUF,DBUFP
	SAVE <CURCAP>
	BIS #.FASP,(P)	;SET THE POINTER TO THE END OF FILE
	$INVOK
	MOV #-1,FILFLG	;SET OPEN FILE FLAG FOR WRITE
	SEZ
	RTS PC
QUEST:	JSR PC,ONETYI
	SPUSH D		;SAVE IT
	JSR PC,.CRLF	;PRINT CR AND LINEFEED
	SPOP D		;GET CHARACTER
.IFNZ FR
	CMP #'O,D
	BEQ QUEST1
	CMP #'O+40,D
	BEQ QUEST1
.ENDC
.IFNZ ENG
	CMP #'Y,D	;IS IT "Y"?
	BEQ QUEST1
	CMP #'Y+40,D	;IS IT SMALL Y
.ENDC
QUEST1:	RTS PC
.WRTEF:
.OPENW:	JSR PC,DSET	;SET DIRECTORY
	JSR PC,NNFNGT	;SET IT
.WRTF2:	CLR -(P)
	SAVE <#NAME,CURCAP>
	BIS #.FAAD,(P)
	.INVOK		;TRY TO PUT IT INTO THE DIRECTORY
	BEQ .WRTF1
	MOV #DBUF,DBUFP
	MOV #-1,FILFLG
.WRTF6:	SEZ
	RTS PC
.WRTF1:	JSR PC,DIRFUL	;SEE IF THE DIRECTORY FULL
LANGC	<PRTXT ^/FILE ALREADY EXISTS.  DELETE IT?/>,<
	PRTXT ^/FICHIER DEJA EXISTANT. A DETRUIRE?/>
	JSR PC,QUEST	;GET REPLY
	BEQ 1$		;OK, DELETE IT
	ERROR+EAES	;ENTRY ALREADY EXISTS
1$:	MOV CURCAP,A
	MOV A,TMPCP	;SO IT WILL BE DELETEED ON ERROR
	CLR CURCAP
	JSR PC,COPCUR	;COPY OLD CURCAP INTO CURCAP
	CLRB 1(P)	;USE OLD STUFF ON STACK
	BIS #.FAMU,(P)	;BUT MUTATE INSTEAD
	.INVOK		;TRY TO GET TO OLD FILE
	BNE .+4
.WRTF9:	ERROR+CDE	;????
	SAVE <#0,#0,A>	;CABILITY TO FILE
	BIS #.FADL,(P)	;WANT TO DELETE
	.INVOK
	BEQ .WRTF9
	JSR PC,DELTMP	;FLUSH CAP TO FILE
	BR .WRTF2	;TRY AGAIN

DIRFUL:	$GERRW		;READ THE ERROR WORD, SHOULD NEVER FAIL
	TST (P)+	;POP USELESS ERROR ADDRESS
	CMP (P)+,#.EDRF	;DIRECTORY FULL?
	BNE 1$
	ERROR+DRF
1$:	RTS PC

.WRTEC:	TST FILFLG
	BLT 1$
	BPT
1$:	MOVB D,@DBUFP
	INC DBUFP
	CMP #DBUF+DBUFL,DBUFP
	BNE .WRTF6
	MOV #DBUF,DBUFP
	SAVE <#DBUF,#-DBUFL,CURCAP>	
	.BLKO
	BNE .+4	
.WRTDF:	ERROR+DFU
	RTS PC

.WRTCL:	SAVE <#DBUF,DBUFP>
	SUB #DBUF,(P)
	NEG (P)
	SAVE CURCAP
	.BLKO
	BEQ .WRTDF
.WRCL1:	
.REDCL:	JSR PC,FLSCUR
	CLR FILFLG
	SEZ
	RTS PC

FLSCUR:	SAVE A
	MOV CURCAP,A
	JSR PC,DELCAP
	REST A
	CLR CURCAP
	RTS PC

.DELI==.DELETE

.FILEP:	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT 1$		;YES
	ERROR+IFN	;NO, INVALID FILE NAME
1$:	SPUSH PCHR
	MOV #.WRTEC,PCHR
	SPUSH #1
	JSR PC,PRINT	;PRINT THE CHARACTERS
.FILP1:	SPOP PCHR
	SEZ
	RTS PC

.FILER:	TST FILFLG	;IS FILE OPEN FOR READ?
	BGT 1$		;YES
	ERROR+IFN	;NO,INVALID FILE NAME
1$:	SPUSH GCHR
	MOV #.READC,GCHR
	JSR PC,RQUEST
	SPOP GCHR
	CLZ
	RTS PC

.CLOSF:	MOV #TYI,GCHR	;RESET IT FOR TTY INPUT
	CLR REDFLG	;CLEAR READFLAG
	CLR WRTFLG	;CLEAR WRITE FLAG
	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT .WRTCL
	BGT .REDCL
	RTS PC


.FILEO:	TST FILFLG	;IS A FILE OPEN
	BEQ 1$		;NO
	JMP RTTRUE	;RETURN TRUE
1$:	JMP RTFALS	;RETURN FALSE

RINIT:	JSR PC,COPDEF
	MOV #"IN,NAME
	MOV #"IT,NAME+2
	CLR NAME+4
	JSR PC,FREADR	;TRY TO READ THE FILE
	BEQ RINIT1	;LOSE
	JSR PC,.READ1	;GO READ INTO LOGO
RINIT1:	RTS PC
;PAGENO == THE UPT SLOT WE CAN USE
;PGADD  == THE PAGE ADDRESS
;WE ALSO HAVE TO GET THE CAPABILITY
;BUFFER== THE ADDRESS OF A BUFFER
;POTREE AND POI ROUTINES

.POTREE:	MOV PC,B				;FLAG ALLOWS LISTING OF INFERIOR DIR'S.
	BR POI.1
.POI:	CLR B					;SUPRESSES LISTING OF INFERIOR DIR'S.
POI.1:	CMP DIRCAP,#CURCAP	;IF DIRCAP POINTS TO CURCAP, .POI IS BEING USED AS A
	BEQ POI.2	; A COROUTINE FOR .FILER, & WANTS THE OPEN CURCAP DIR TO STAY
	JSR PC,FILCHK	;FILE ALREADY OPNE?
	JSR PC,COPDEF
	MOV CURCAP,TMPCP
	CLR CURCAP
POI.2:	CLR A					;RECURSION DEPTH COUNTER
	CMP -(P),-(P)
	SAVE <@DIRCAP>			;GET DISK DATA
	BIS #.FADI,(P)
	$INVOK
	REST <FREEBL,DSKNUM>
	JSR PC,PODIR				;LIST IT
	MOV FREEBL,A				;NUMBER OF FREE BLOCKS
	JSR PC,PRDN				;PRINT NUMBER OF FREE BLOCKS ON DISK
	PRTXT ^\ FREE BLOCKS ON DISK #\
	MOV DSKNUM,A				;DISK NUMBER
	JSR PC,PRDN				;PRINT DISK NUMBER
	PRCR					;AND CAR-RET
DELTMP:	MOV TMPCP,A
	JSR PC,DELCAP
	CLR TMPCP
	RTS PC					;WE ARE DONE

FILCHK:	TST FILFLG	;IS FILE OPEN?
	BEQ 1$		;NO
	ERROR+FAO
1$:	RTS PC

DIRCHK:	SAVE <#FINFO,#4,CURCAP>
	BIS #.FARI,(P)
	$INVOK		;FIND OUT IF WE'VE OPENED A FILE OR A DIRECTORY
	BIT #.FADIR,FINFO+2	;WELL, WHICH?
	RTS PC
;GIVEN DIRECTORY CAPABILITY, TREE FLAG AND LEVEL

PODIR:	CLR D					;NUMBER OF ENTRY BEING PROCESSED
PODIR0:	CLR -(P)				;MAP IN ALL OF PAGE #0
	CLR -(P)
	SAVE <@DIRCAP>				;CAP TO DIRECTORY
	MOVB #HAKPG+10,1(P)			;DESTINATION OF PAGE
	SAVE <#.CRRD!1>			;SPHERE CAP AND TYPE OF PAGE
	$MAP
PODIR1:	MOV #HAKAD,C
	MOV 6(C),-(P)				;SAVE EOF
	ADD C,(P)				;ABSOLUTE EOF
PODI11:	MOV #HAKAD,C				;ADDRESS OF START OF PAGE
	MOV D,E					;SKIP SOME ENTRIES
	BEQ PODIR3
PODIR2:	CMP C,(P)				;CHECK EOF
	BLO PODI10
PODI12:	TST (P)+
	RTS PC					;NO MORE ENTRIES SO RETURN
PODI10:	MOV (C),F
	INC F
	BIC #177401,F				;SIZE OF THIS ENTRY
	ADD F,C
	SOB E,PODIR2				;SKIP ANOTHER ENTRY
	CMP C,(P)
	BHIS PODI12
PODIR3:	MOVB 1(C),F
	BIC #177761,F				;GET TYPE FIELD
	SAVE C
	JMP @PODIRT(F)				;DISPATCH TO SERVICE ROUTINE

PODIRL:	BPT					;BUG LINKS NOT IMPLEMENTED
	BR PODIRP				;JUST SKIP THE ENTRY
PODIRS:	TST A					;ENTER HERE FOR SELF ENTRY
	BEQ PODIR7				;DON'T PRINT "I" AT TOP LEVEL
	MOV A,F					;LEVEL IS IN A
	SUB #2,F				;PRINT LEVEL-2 SPACES	
PODIR4:	BEQ PODIR6				;DON'T TRY TO PRINT ZERO SPACES
PODIR5:	JSR PC,PODIRB				;PRINT (F) BLANKS
PODIR6:	SAVE D
	MOV #'I,D
	JSR PC,@PCHR
	SPACE
	REST D					;INDICATES INFERIOR DIRECTORY
PODIR7:	MOV #-1,E
	JSR PC,PODIRI				;PRINT NAME,VERSION, AND SIZE
PODIRP:	INC D					;ENTER HERE FOR PARENT TYPE ENTRY
	REST C
	BR PODI11				;DO THE NEXT ENTRY

;FALLS INTO NEXT PAGE
;FALLS IN FROM ABOVE

PODIRF:	MOV A,F					;ENTER HERE FOR FILES
	ADD #2,F				;NUMBER OF SPACES BEFORE NAME
	JSR PC,PODIRB				;PRINT THE BLANKS
	JSR PC,PODIRN
	BR PODIRP				;PRINT REST OF INFORMATION
PODIRD:	TST B					;ENTER HERE FOR DIRECTORY ENTRY
	BNE PODIR8
	MOV A,F					;NUMBER OF PRECEDING SPACES
	BR PODIR4				;SUPPRESS LISTING OF INFERIOR DIRECTORY
PODIR8:	MOV D,(P)
	SAVE <@DIRCAP>				;SAVE THE WORLD
	ADD #2,A				;INCREMENT THE LEVEL
	SAVE <#-1,#0,@DIRCAP>
	BIS #.CPYCP,(P)				;COPY THE CAP.
	$INVOK
	JSR PC,PODIRE				;SKIP TO NAME
	MOV @DIRCAP,@CAPSP
	ADD #2,CAPSP
	SPOP @DIRCAP
	MOV #BUFFER,E				;PUT NAME FOR MUTATE INTO BUFFER
PODIR9:	MOVB (C)+,(E)+
	BPL PODIR9				;MOVE THE NAME
	BICB #200,-1(E)				;CLEAR BIT IN LAST CHARACTER
	CLRB (E)				;ZERO BYTE AT END OF ASCII STRING
	CLR -(P)
	SAVE <#BUFFER,@DIRCAP>
	BIS #.FAMU,(P)				;MUTATE THE NEW CAP.
	$INVOK
	JSR PC,PODIR				;LIST INFERIOR
	CMP -(P),-(P)
	SAVE #-3
	MOVB #HAKPG+10,1(P)
	SAVE #1
	$MAP					;DELETE PAGE
	CMP -(P),-(P)
	SAVE <@DIRCAP>
	BIS #.DELCP,(P)				;DELETE THE CAP.
	$INVOK
	SUB #2,CAPSP
	CLR @CAPSP
	REST <@DIRCAP,D>				;RESTORE WORLD
	SUB #2,A				;DECREMENT THE LEVEL
	INC D
	REST C
	JMP PODIR0				;CONTINUE LISTING THIS DIRECTORY

;PRINT (F) BLANKS ON THE OUTPUT DEVICE

PODIRB:	SAVE <D>
	MOV #' ,D				;PUT ASCII BLANK IN D
PODIB1:	JSR PC,@PCHR				;PRINT A CHARACTER
	SOB F,PODIB1
	REST <D>
	RTS PC
;SKIP TO BEGINNING OF NAME
;(C)= POINTER TO BEGINNING OF ENTRY

PODIRE:	MOV (C)+,F				;GET THE HEADER WORD
	TST (C)+				;SKIP VERSION NUMBER
	CLR DATE				;NOW TEST BITS IN HEADER WORD
	ROL F
	BCC 1$
	ADD #4,C
	MOV (C)+,DATE
	MOV (C)+,TIME
1$:	ROL F
	BCC PODIE2
PODIE1:	ADD #2,C				;SKIP ACCESS CODES
	TSTB (C)+
	BLT PODIE1				;MORE ACCESS CODES?
PODIE2:	RTS PC
;PRINT OUT A LINE OF INFORMATION ABOUT FILE
;(C)= POINTS TO ENTRY TO PRINT
;SAVE REGISTERS A,B,D

PODIRN:	MOV 6(C),F				;BYTE PONTER
	ADD #1777,F				;ROUND UP TO BLOCK BOUNDARY
	CLR E					;CLEAR HIGH PART
	ASHC #3,E
	ADD 4(C),E				;PAGE NUMBER
	ASHC #3,E				;NOW LEGNTH IN BLOCKS
PODIRI:	SAVE <A,D,E,2(C)>			;SAVE LEGNTH AND VERSION NUMBER
	JSR PC,PODIRE				;SKIP TO BEGINNING OF NAME
PODIN2:	MOVB (C),D				;NOW PRINT NAME
	BIC #177600,D				;CLEAR TOP BIT OF BYTE
	CMPB #'#,D
	BEQ PODIN8
	CMPB #'",D
	BEQ PODIN8
	CMPB #'>,D
	BEQ PODIN8
	CMPB #'<,D
	BNE PODIN9
PODIN8:	SAVE D
	MOV #'",D
	JSR PC,@PCHR
	REST D
PODIN9:	JSR PC,@PCHR				;PRINT A CHARACTER
	TSTB (C)+				;LAST BYTE HAS 200 BIT SET
	BPL PODIN2
	REST <A>				;VERSION NUMBER
	BLT PODIN3				;NO VERSION NUMBER
	MOV #'#,D
	JSR PC,@PCHR
	JSR PC,PRDN				;PRINT THE VERSION NUMBER
PODIN3:	REST <A>				;PRINT THE BLOCK LEGNTH
	BLT 1$
	SPACE
	SPACE
	JSR PC,PRDN
1$:	JSR PC,PRDAT
	JSR PC,.CRLF
	REST <D,A>
	RTS PC					;DONE WITH THIS ENTRY


;PRDAT PRINTS DATE & TIME, IF ANY
PRDAT:	JSR F,ACSAV				;SAVE ALL REGISTERS  
	MOV #11,D				;TAB
	JSR PC,@PCHR
	MOV DATE,E				;PUT DATE IN E 
	BEQ 5$					;IF NO DATE & TIME, RETURN
	CMP #-1,E				;SEE IF INITIALIZED
	BNE PRDAT1				;GO ON IF INITIALIZED
	SPACE
	MOV #'-,D				;PRINT " -" IF NOT
	JSR PC,@PCHR
5$:	JSR F,ACRES				;RESTORE ALL REGISTERS
	RTS PC

;CONTROL INSTRUCTIONS FOR PRDAT2
PRDAT1:	MOV #DTTAB,B				;POINT TO BEG. OF DTTAB	
	JSR PC,PRDAT2				;PRINT DATE IN E
	MOV TIME, E				;PUT TIME IN E				
	JSR PC,PRDAT2				;PRINT TIME
	JSR F,ACRES				;RESTORE ALL REGISTERS
	RTS PC

;TABLE DRIVEN ROUTINE TO PRINT DATE & TIME SEGMENT BY SEGMENT
	;ZTYPE & PRDN TAKE ARGUMENT IN A 
PRDAT2:	MOV #3,C				;C IS LOOP INDEX
PRDAT3:	MOV E,A					;PUT DATE OR TIME IN A
	ASH (B)+,A				;SHIFT QUANTITY TO LOW BYTE
	BIC (B)+,A				;ZAP ALL BUT RELEVANT BITS
	ASH (B)+,A				;MULT. FACTOR: 0 EXCEPT FOR SEC/2
	CMP #3,C				;FIRST TIME THRU LOOP?
	BEQ 1$				
	JSR PC,ZPRDN				;PRINT WITH LEADING 0 IF < 10
	BR 2$
1$:	JSR PC,PRDN				;PRINT WITHOUT LEADING 0 IF < 10	
2$:	MOV (B)+,A				;PICK UP DELIMITER CHARACTER
	MOV A,D					;PUT CHARACTER IN D
	JSR PC,@PCHR				;PRINT CHARACTER
	SOB C,PRDAT3				;DO NEXT SEGMENT
PRDAT4:	RTS PC






.CRINDEX:
	JSR PC,DSET	;SET THE DIRECTORY
	JSR PC,NNFNGT	;GET THE NAME
	SAVE <#.FADIR,#NAME,CURCAP>
	BIS #.FAAD,(P)
	.INVOK		;TRY TO CREATE THE DIRECTORY
	BNE 1$
	JSR PC,DIRFUL	;SEE IF DIRECTORY FULL
	ERROR+EAES
1$:	SAVE <#0,CURCAP>
	.WRDO		;MAKE FILE FILE 1 BLOCK LONG
	BNE 2$
	ERROR+DFU
2$:	SAVE <,,CURCAP>
	BIS #.FAMD,(P)
	$INVOK		;MAKE INTO A DIR
	SEZ
	RTS PC

	.STITL LINEPRINTER AND PAPER TAPE ROUTINES
WRITEP:	MOV #.TPCAP*400,F	;CREATE TAPE PUNCH
	BR LPRIN1
LPRINT:	MOV #.LPCAP*400,F	;CREAT LINEPRINTER
LPRIN1:	JSR PC,FILCHK
	REST <A,B>	;GET RET ADDR + NUM ARGS
	SAVE A		;PUT BACK ADDR
	TST B		;ZERO ARGS?
	BNE LPRINF	;JUST WRITE OUT FILE
	JSR PC,OPNDEV	;OPEN LPT OR PAPERTAPE
	JSR PC,FORMFD
	MOV PC,WRTFLG
	MOV #TMPOUT,PCHR
	JSR PC,SHOWAL
	JSR PC,FORMFD
	MOV #TYO,PCHR
	JSR PC,DELTMP
	SEZ
	RTS PC

LPRINF:	CMP #1,B	;EXACTLY 1?
	BEQ 1$		;YUP
	ERROR+WNA
1$:	SAVE F
	JSR PC,DSET	;SET THE DIRECTORY
	JSR PC,NNFNGT	;GET THE NAME OF THE FILE
	JSR PC,FREADR	;GET THE FILE
	BNE 3$		;GOT IT
	ERROR+FNF
3$:	REST F
	JSR PC,OPNDEV
LINEP1:	JSR PC,FORMFD	;FORMFEED IF LPT
	MOV FEOF+2,A	;GET THE LENGTH IN BYTES
	MOV FEOF,B	;AND SECOND PART
	MOV B,C		;GET COPY BYTE LENGTH
	BIC #176000,C	;GET THE LENGTH OF THE LAST BLOCK IN BYTES
	ASHC #-10.,A	;SHIFT TO GET A BLOCK COUNT
	TST C		;ARE THERE ANY BYTES IN THE LAST BLOCK?
	BEQ 1$		;NO
	INC B		;BECAUSE THERE REALLY IS ONE MORE BLOCK
1$:	CLR E		;THE BLOCK NUMBER WE ARE CURENTLY AT
LINMAP:	MOV B,A		;COPY THE NUMBER OF BLOCKS LEFT
	CMP B,#10	;MORE THAN 8 BLOCKS
	BLOS LINMP1	;NO
	MOV #10,A	;FIX A TO ONLY TAKE 8
LINMP1:	DEC A		;BECAUSE MAP LIKES NUMBERS BETWEEN 0 AND 7
	SWAB A		;INTO THE TOP BYTE
	SAVE <A,E,CURCAP,#1>	;MAP IN THE FILE
	BIS #.CRRD,(P)	;ONLY READ ONLY ACCESS
	MOVB #HAKPG+10,3(P)	;USE THE HACK PAGE FOR THIS
	SWAB A		;GET BACK THE NUMBER OF BLOCKS WE ARE TRANSFERRING
	INC A
	$MAP		;MAP IT IN
	INC E		;SO THAT IT IS CORRECT THE NEXT TIME
	SUB A,B		;CORRECT NUMBER OF BLOCKS TAKEN
	BNE FULBUF	;TRANSFER A FULL BUFFER
	ASH #10.,A	;GET THE NUMBER OF BYTES IN THIS PAGE
	SUB #2000,C	;GET THE NEGATIVE OF THE NUMBER OF BAD BYTES ON THIS PAGE
	ADD C,A		;GET THE TOTAL NUMBER OF BYTES ON THE PAGE
	BR TRNBUF	;TRANSFER THE BUFFER
FULBUF:	MOV #2000*10,A	;NUMBER OF BYTES IN A FULL PAGE
TRNBUF:	NEG A		;WANT A NEGATIVE BYTE COUNT
	SAVE <#HAKAD,A,TMPCP>	;OUTPUT TO THE LINEPRINTER
	.BLKO		;OUTPUT THE BLOCK
	BEQ LPTERR	;ERROR
	TST B		;DONE?
	BNE LINMAP	;NO
	JSR PC,FORMFD
DELWLD:	MOV CURCAP,A	;GET THE FILE CAP
	JSR PC,DELCAP	;DELETE IT
	CLR CURCAP	;NO CURRENT CAP
	CLR FILFLG	;SAY THAT THE FILE IS NOT OPEN
	JSR PC,DELTMP
	SAVE <,,#-3,#1>	;DELETE THE HACK PAGE
	MOVB #HAKPG+10,3(P)
	$MAP		;BYE BYE
	SEZ		;NO OUTPUT
	RTS PC

FORMFD:	CMP #.LPCAP*400,F
	BNE 1$
	SAVE <#14,TMPCP>	;OUTPUT A FORMFEED
	.BYTO
	BEQ LPTERR
2$:	RTS PC
1$:	CMP #.TPCAP*400,F
	BNE 2$
	SAVE A
	MOV #100.,A
3$:	SAVE <#0,TMPCP>
	.BYTO
	BEQ LPTERR
	SOB A,3$
	REST A
	RTS PC

TMPOUT:	SAVE <D,TMPCP>
	.BYTO
	BEQ LPTERR
	RTS PC

LPTERR:	JSR PC,DELWLD	;DELETE THE WORLD
	ERROR+DNR	;DEVICE NOT READY
OPNDEV:	JSR PC,DELTMP
	SAVE <#-1,#0,F>
	.INVOK
	BNE 2$		;CANT
	ERROR+DIU
2$:	REST TMPCP
	RTS PC

LOAD25:	MOV S,A		;GET POINTER TO THE S PDL
	MOV (A),B	;EXCHANGE THE TWO ARGUMENTS
	MOV 2(A),(A)+
	MOV B,(A)
	JSR PC,UGTTYG	;GET THE USER TTY
	BEQ MYTTY
	SAVE E		;SAVE THE TTY NUMBER
	JSR PC,.READF	;READ THE FILE NAME
	MOV (P),E	;RESTORE THE TTY NUMBER
	MOVB TTYCPS(E),E	;GET THE CAPABILITY NUMBER TO THIS TTY
	BIC #177400,E	;CLEAR OUT THE TOP BYTE
LOAD26:	JSR PC,.READC	;GET A CHARACTER
	CMP #EOFCHR,D	;EOF?
	BEQ LOAD27	;YES
	TST BRAKE	;BREAKING?
	BNE LOAD28	;YES
	SAVE <D,E>	;PUT IT ON THE STACK
	$BYTO		;OUTPUT IT
	BR LOAD26	;CONTINUE UNTIL END OF FILE
LOAD28:	JSR PC,.CLOSF	;CLOSE THE FILE
LOAD27:	REST E		;GET BACK TTY NUMBER
	JMP CLOSE1	;CLOSE THE TTY, AND RETURN
MYTTY:	JSR PC,SETTIM
	JSR PC,.POF
	JMP RESTTY


.POF:	JSR PC,.READF
.POF1:	JSR PC,.READC
	CMP #EOFCHR,D
	BEQ .POF2
	JSR PC,@PCHR
	BR .POF1
.POF2:	CLR FILFLG
	RTS PC

.ENDC	;END OF LSICOND

GNWRD:	;INPUT	POINTER TO LIST OF WORDS ON S
	;OUTPUT	-IF LIST IS NOT EMPTY,
	;	 POINTER TO  FIRST OF LIST ON TOP OF S
	;	 POINTER TO BF OF LIST NEXT
	;	 Z WILL BE CLEAR
	;	-IF LIST IS EMPTY, POP S AND SET Z
	;IF F LIST ISNT A WORD, WTA ERROR ISSUED
	JSR F,CACSAV
	MOV @S,B
	BIT #7777,B	;IS LIST EMPTY?
	BEQ GNWRD1
	JSR PC,.LOADB	;NO GET 1ST NODE
	MOV A,@S	;SAVE BF ON S
	PUSHS B		;YES - PUSH FIRST ON S
	JSR F,CACRES
	CLZ
	RTS PC
GNWRD1:	POPS A		;EMPTY LIST QUIT
	JSR F,CACRES
	SEZ
	RTS PC
NNFNGT:	MOV #NAME,E
NFNGET:		;INPUT	ADDRESS OF BLOCK IN E
		;	PTR TO LSTR ON S
		;OUTPUT	PUT 1ST 10. CHAR OF LSTR INTO BLOCK
		;	SET 200 BIT IN LAST CHAR, POP S
	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,B	;POINTER TO FILE NAME IN B
	MOV #LSTR,A	;DATA TYPE FOR CONVERSION
	JSR PC,CONVER	;MAKE NAME AN LSTR
	BNE 1$
	ERROR+IFN	;INVALID FILE NAME (CONVERSION FAILED)
1$:	MOV B,@S	;POINTER TO NEW DATA ON STACK
	BIC #170000,B	;LEAVE DATA TYPE
	MOV B,GNCN	;"GET NEXT CHARACTER" NODE
	MOV #10.,C	;TAKES ONLY THIS MANY CHARACTERS
NFNG1:	JSR PC,GNC	;GET NEXT CHAR
	CMP #15,D	;UGH! (IS IT A CARRIAGE RETURN?)
	BEQ NFNG2	;YES- NO MORE CHARACTERS
	MOVB D,(E)+	;STORE THE NEXT CHARACTER
	MOV D,TEMP
	SOB C,NFNG1	;KEEP GOING UNTIL WE HIT TEN
NFNG2:	CLRB (E)	;CLREAR LAST BYTE
	JSR F,CACRES	;GET BACK THE OLD REGISTERS
	JSR PC,SPOPT
	RTS PC
SETNM:		;INPUT	LIST OR WoRD ON S
		;OUTPUT	IF WORD, OUTPUT WORD AND SET Z
		;	IF LIST, OUTPUT LAST AND BL OF LIST ON S
		;		PUT BL ON TOP AND CLEAR Z
		;	OTHERWISE ERROR
	TST FILFLG	;IS FILE OPEN?
	BEQ 1$		;NO
	ERROR+FAO	;FILE ALREADY OPEN
1$:	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,C	;GET INPUT
	BIT #7777,C
	BNE 2$
	ERROR+IFN	;INVALID FILE NAME
2$:	MOV C,B		;SEE IF IT'S A LIST
	BIC #7777,C
	CMP C,#LIST
	BEQ SETNM1	;YES, IT IS
SETNM2:	JSR F,CACRES	;OK, SET Z AND QUIT
	SEZ
	RTS PC
SETNM1:	JSR PC,COPYL	;COPY LIST - INPUT IN B
		;OUTPUT IN B;  C POINTS TO LAST NODE IN NEW LIST
		; E POINTS TO 2ND TO LAST NODE
	JSR PC,.LDP2
	MOV A,@S
	MOV E,C
	BEQ SETNM3	;NO BUTLAST
	JSR PC,.LDP1	;FIX UP  LINK
	BIC #7777,A
	JSR PC,.STP1
	BIS #LIST,B
SETNM4:	PUSHS B
	JSR F,CACRES
	CLZ
	RTS PC
SETNM3:	MOV #LSTR,B
	BR SETNM4
	.STITL MISC ROUTINES

CACSAV:	JSR PC,PPUSHT	;CAREFUL AC SAVE
ACSAV:	MOV E,-(P)
	MOV D,-(P)
	MOV C,-(P)
	MOV B,-(P)
	MOV A,-(P)
	JMP (F)

CACRES:	JSR PC,PPOPT	;CAREFUL AC RESTORE
ACRES:	TST (P)+
	MOV (P)+,A
	MOV (P)+,B
	MOV (P)+,C
	MOV (P)+,D
	MOV (P)+,E
	RTS F

PPUSHT:	CMP P,PPUSHL
	BLOS 1$
	RTS PC
1$:	JMP PPSWPO	;PDL REALLY OVERFLOWED

PPOPT:	CMP P,PPOPL
	BHIS 1$
	RTS PC
1$:	JMP PPSWPI

SPUSHT:	SUB #2,S
	CMP S,SPUSHL
	BLOS 1$
	RTS PC
1$:	JMP SPSWPO

SPOPT:	ADD #2,S
SPOPT1:	CMP S,SPOPL
	BHI 1$
	RTS PC
1$:	JMP SPSWPI

.SPACE:	SAVE D
	MOV #' ,D
.SPAC1:	JSR PC,@PCHR
	REST D
	RTS PC

.CRLF:	SAVE D
	MOV #15,D
	BR .SPAC1

	.STITL P AND S PDL SWAP OUTERS

;** NOTE: ALTHO PDL EMERGENCIES WITH DISK CAN ONLY OCCUR WHEN TIMESHARING,
;** WITHOUT THE DISK PDL EMERGENCIES CAN *ALWAYS* OCCUR (DUE TO NODE/ARRAY SPACE
;** HAVING SNUCK UP ON THE PDL BUFFERS) AND THUS MUST BE ACCOUNTED FOR REGARDLESS
;** OF TS.

.IFNZ DSK

PPSWPO:	JSR F,ACSAV	;TIME TO WORK!
.IFNZ TS
	TST PPEMR	;HAS A P PDL EMERGENCY ALREADY OCCURED?
	BEQ 1$		;NOPE
	ERROR+BUG	;SYSTEM BUG!!
1$:	JSR F,SETUPP
	.BLKO
	BEQ PPEMRP	;GO DO AN EMERGENCY PUSH OF THE STACK
	CMP PPLIMT,PRBAO	;ARE WE BEYOND THE LIMIT ON P YET?
	BHI PPSWP1
	BIS #DSAMFL,FLAGS2	;YES, SET DISK ALMOST FULL
.ENDC
PPSWP1:	MOV POPLM,PPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #PPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV IP,A
	MOV #PSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,P
	BHIS .-4
	ADD #PPDLL,P	;PDL HAS MOVED!
	ADD #PPDLL,PRBAO
	JSR F,ACRES
	RTS PC

.IFNZ TS
PPEMRP:	MOV PC,PDLEMR	;FLAG THAT A PDL EMERGENCY OCCURED
	MOV PC,PPEMR	;FLAG A P PDL EMERGENCY
	CLR -(P)
	CLR -(P)
	SAVE PPDLCP
	BIS #.FASP,(P)
	$INVOK		;SET POINTER TO BEG OF FILE
	$BLKO		;OUTPUT THIS PDL BLOCK (CAN'T FAIL!!)
	BIS #DSAMFL,FLAGS2	;WARN THE REST OF THE SYSTEM WE ARE IN TROUBLE
	BR PPSWP1
.ENDC
.ENDC
.IFZ DSK

;ROUTINE TO EXTEND P-PDL SPACE (IN LIEU OF SWAPPING OUT)
PPSWPO:	JSR F,ACSAV
	TST PPEMR	;PENDING EMERGENCY?
	BEQ 1$
	ERROR+BUG
1$:	BIS #PPNAIF,FLAGS2	;NOT ALL "SWAPPED IN" (IE, >1 PDL BLOCK EXISTS)
	MOV PPDTOP,A	;A_TOP OF STACK SPACE
	SUB #PPDLL,A	;EXTEND IT
	CMP A,ARTOP	;BUMP INTO ARRAY SPACE?
	BLO PPEMRP	;IF SO, EMERGENCY PUSH
	MOV A,PPDTOP	;ANOTHER BLOCK ALLOCATED
	SUB #PPDLL,PPUSHL	;PPUSHL MOVED ACCORDINGLY
	ADD #<2*PPDLL>-<PDSLOP/3>,A
	MOV A,PPOPL	;AS WELL AS PPOPL
PPSWP2:	ADD #PPDLL,PRB	;ONE MORE BLOCK "ALREADY OUT"
	JSR F,ACRES
	RTS PC

PPEMRP:	BIS #DSAMFL,FLAGS2	;SINGAL "DISK" ALMOST FULL
	MOV PC,PPEMR	;FLAG P PDL EMER
	SUB #PPDLL-PDSLOP,PPUSHL	;PPUSHL IS NOW JUST UNDER TOP OF EMER BLK
	MOV PPDTOP,PPOPL	;NEW PPOPL
	ADD #PPDLL-<PDSLOP/3>,PPOPL
	BR PPSWP2
.ENDC
.IFNZ DSK

SPSWPO:	JSR F,ACSAV	;TIME TO WORK!
.IFNZ TS
	TST SPEMR	;HAS A P PDL EMERGENCY ALREADY OCCURED?
	BEQ 1$		;NOPE
	ERROR+BUG	;SYSTEM BUG!!
1$:	JSR F,SETUPS
	.BLKO
	BEQ SPEMRP	;GO DO AN EMERGENCY PUSH OF THE STACK
	CMP SPLIMT,SPRBAO	;ARE WE BEYOND THE LIMIT ON P YET?
	BHI SPSWP1
	BIS #DSAMFL,FLAGS2	;YES, SET DISK ALMOST FULL
.ENDC
SPSWP1:	MOV SPOPLM,SPOPL
	BIS #SPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV IS,A
	MOV #SSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,S
	BHIS .-6
	ADD #SPDLL,S	;PDL HAS MOVED!
	ADD #SPDLL,SPRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC

.IFNZ TS
SPEMRP:	MOV PC,PDLEMR	;FLAG THAT A PDL EMERGENCY OCCURED
	MOV PC,SPEMR	;FLAG A P PDL EMERGENCY
	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK		;SET POINTER TO BEG OF FILE
	$BLKO		;OUTPUT THIS PDL BLOCK (CAN'T FAIL!!)
	BIS #DSAMFL,FLAGS2	;WARN THE REST OF THE SYSTEM WE ARE IN TROUBLE
	BR SPSWP1
.ENDC
.ENDC

.IFZ DSK

;ROUTINE TO EXTEND S-PDL SPACE (IN LIEU OF SWAPPING OUT)
;THIS REQUIRES MOVING THE P-PDL
SPSWPO:	JSR F,ACSAV
	TST SPEMR	;EMERGENCY IN PROGRESS?
	BEQ 1$
	ERROR+BUG
1$:	BIS #SPNAIF,FLAGS2	;NOT ALL "SWAPPED IN"
	MOV PPDTOP,A	;A_TOP OF *P*PDL SPACE
	SUB #SPDLL,A	;MOVE IT
	CMP A,ARTOP	;BUMP INTO ARRAY SPACE?
	BLO SPEMRP	;IF SO, EMERGENCY PUSH
	MOV A,PPDTOP	;NEW PDL TOP
	MOV P,A		;SAVE P-PDL PTR
SPSWPL:	MOV (P)+,-<SPDLL+2>(P)	;SLIDE P-PDL UP (DOWN) ONE BLOCK
	CMP P,IP	;REACHED THE BOTTOM YET?
	BLO SPSWPL	;IF NOT, CONTINUE

	SUB #SPDLL,A	;UPDATE P
	MOV A,P
	SUB #SPDLL,IP	;ADJUST REMAINING PARAMETERS
	SUB #SPDLL,PPUSHL
	SUB #SPDLL,PPOPL
	SUB #SPDLL,SPUSHL
	MOV IP,SPOPL
	ADD #<2*SPDLL>-<PDSLOP/3>,SPOPL
SPSWP2:	ADD #SPDLL,SPRB	;ONE MORE BLOCK "ALREADY OUT"
	JSR F,ACRES
	RTS PC

SPEMRP:	BIS #DSAMFL,FLAGS2	;SIGNAL "DISK" ALMOST FULL
	MOV PC,SPEMR	;FLAG S-PDL EMERGENCY
	SUB #SPDLL-PDSLOP,SPUSHL	;SPUSHL NOW JUST UNDER TOP OF EMER BLOCK
	MOV IP,SPOPL
	ADD #SPDLL-<PDSLOP/3>,SPOPL	;NEW SPOPL
	BR SPSWP2
.ENDC
	.STITL P AND S PDL SWAPER INERS

.IFNZ DSK

PPSWPI:	BIT #PPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE 1$			;NO (PRAISE THE LORD!)
	.BUG.
1$:	JSR F,ACSAV
	MOV #PSWPAD,A
	MOV A,B
	ADD #PPDLL,A
	MOV -(A),-(B)
	CMP A,P
	BHI .-4
	SUB #PPDLL,P
	SUB #PPDLL,PRBAO
	BNE PSWPI3
	BIC #PPNAIF,FLAGS2
	MOV IP,PPOPL
PSWPI3:
.IFNZ TS
	JSR F,SETUPP
	$BLKI
.ENDC
	JSR F,ACRES
	RTS PC
.IFNZ TS
SETUPP:	TST (P)+
	TST SPEMR	;IS THERE A S PDL EMRG?
	BNE 1$		;YES
	BIC #DSAMFL,FLAGS2	;NO, DISK IS NOW NOT ALMOST FULL
1$:	TST PPEMR	;HAS A P PDL EMERGENCY OCCURED?
	BEQ SETUP1	;NO, DO NORMAL THING
	CLR -(P)	;GO TO START OF FILE FOR EMERGENCY BLOCK
	CLR PPEMR	;NO MORE EMERGENCY!
	BR SETUP2
SETUP1:	SPUSH PRBAO
	ADD #PPDLL,(P)	;SKIP THE EMERGENCY BLOCK
SETUP2:	CLR -(P)
	SPUSH PPDLCP
	BIS #.FASP,(P)
	$INVOK
	SPUSH #PSWPAD
	SPUSH #-PPDLL
	SPUSH PPDLCP
	JMP (F)
.ENDC
.ENDC

.IFZ DSK

;ROUTINE TO CONTRACT P-PDL SPACE (IN LIEU OF SWAPPING IN)

PPSWPI:	BIT #PPNAIF,FLAGS2	;ANYTHING TO POP?
	BNE 1$		;YES (THANK TOASTER!)
	.BUG.
1$:	JSR F,ACSAV
	SUB #PPDLL,PRB	;ONE LESS BLOCK
	BNE PSWPI3	;IF THAT LEAVES NO EXTRAS,
	BIC #PPNAIF,FLAGS2	; SO FLAG
	MOV IP,PPOPL	;NEW PPOPL FOR BLOCK 0
	BR PSWPI4
PSWPI3:	ADD #PPDLL,PPOPL	;NEW PPOPL FOR BLOCK > 0
PSWPI4:	TST SPEMR	;SPDL EMERGENCY?
	BNE 1$
	BIC #DSAMFL,FLAGS2	;NO, SO "DISK" NO LONGER FULL
1$:	TST PPEMR	;PPDL EMERGENCY?
	BEQ SETUP1
	CLR PPEMR	;NO MORE
	ADD #PPDLL-PDSLOP,PPUSHL	;YES, NEW PPUSHL
	BR SETUP2	;NO BLOCK POPPED HERE
SETUP1:	ADD #PPDLL,PPUSHL	;NEW PPUSHL
	ADD #PPDLL,PPDTOP	;POP TO NEW PPDTOP
SETUP2:	JSR F,ACRES
	RTS PC
.ENDC


.IFNZ DSK

SPSWPI:	BIT #SPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE 1$		;NO (PRAISE THE LORD!)
	.BUG.
1$:	JSR F,ACSAV
	MOV #SSWPAD,A
	MOV A,B
	ADD #SPDLL,A
	MOV -(A),-(B)
	CMP A,S
	BHI .-6
	SUB #SPDLL,S
	SUB #SPDLL,SPRBAO
	BNE SPSWI3
	MOV IS,SPOPL
	BIC #SPNAIF,FLAGS2
SPSWI3:
.IFNZ TS
	JSR F,SETUPS
	$BLKI
.ENDC
	JSR F,ACRES
	RTS PC
.IFNZ TS
SETUPS:	TST (P)+
	TST PPEMR	;IS THERE A P PDL EMRG?
	BNE 1$		;YES
	BIC #DSAMFL,FLAGS2	;NO, DISK IS NOW NOT ALMOST FULL
1$:	TST SPEMR	;HAS EMERGENCY OCCURED?
	BEQ SETUS1	;NOPE
	CLR -(P)	;GET EMERGENCY BLOCK THEN
	CLR SPEMR	;NO MORE EMERGENCY
	BR SETUS2
SETUS1:	SPUSH SPRBAO
	ADD #SPDLL,(P)	;PASS BY EMRG BLOCK
SETUS2:	CLR -(P)
	SPUSH SPDLCP
	BIS #.FASP,(P)
	$INVOK
	SPUSH #SSWPAD
	SPUSH #-SPDLL
	SPUSH SPDLCP
	JMP (F)
.ENDC
.ENDC

.IFZ DSK

;ROUTINE TO CONTRACT S-PDL SPACE (IN LIEU OF SWAPPING IN)
;THIS REQUIRES SLIDING THE P-PDL UP

SPSWPI:	BIT #SPNAIF,FLAGS2	;ANYTHING TO POP?
	BNE 1$
	.BUG.
1$:	JSR F,ACSAV
	SUB #SPDLL,SPRB		;ONE LESS BLOCK
	BNE SPSWI3		;IF THAT LEAVES NO EXTRAS,
	BIC #SPNAIF,FLAGS2	; SO FLAG
	MOV IS,SPOPL		;NEW SPOPL FOR BLOCK 0
	BR SPSWI4
SPSWI3:	ADD #SPDLL,SPOPL	;NEW SPOPL FOR BLOCK > 0
SPSWI4:	TST PPEMR		;PPDL EMERGENCY?
	BEQ 1$
	BIC #DSAMFL,FLAGS2	;NO, SO "DISK" NO LONGER FULL
1$:	TST SPEMR		;SPDL EMERGENCY?
	BEQ SETUS1
	CLR SPEMR		;NO MORE
	ADD #SPDLL-PDSLOP,SPUSHL	;YES, NEW SPUSHL
	BR SETUS2		;NO PPDL SLIDE NEEDED
SETUS1:	ADD #SPDLL,SPUSHL	;YES, NEW SPUSHL
	MOV IP,A
	ADD #SPDLL,IP		;POP TO NEW SPDL TOP
SETUSL:	MOV -(A),SPDLL(A)
	CMP A,P
	BHI SETUSL
	ADD #SPDLL,P		;ADJUST PPDL PARAMETERS
	ADD #SPDLL,PPDTOP
	ADD #SPDLL,PPUSHL
	ADD #SPDLL,PPOPL
SETUS2:	JSR F,ACRES
	RTS PC
.ENDC
	.STITL P AND S PDL POPPERS
PPTA:		;POP PP PDL TO (A) RELATIVE
		;USES A,F
	SPOP F
PPTA1:	CMP A,PRBAO
	BHIS PPTA3
	MOV PPOPL,P
	JSR PC,PPSWPI
	BR PPTA1
PPTA3:	SUB PRBAO,A
	SUB IP,A
	NEG A
	CMP A,P
	BHIS 1$
	.BUG.	;OVER POPPING
1$:	MOV A,P
	JSR PC,PPOPT
	JMP (F)
PSTA:		;POP S PDL TO (A) RELATIVE
		;USES A
	CMP A,SPRBAO
	BHIS PSTA3
	MOV SPOPL,S
	JSR PC,SPSWPI
	BR PSTA
PSTA3:	SUB SPRBAO,A
	SUB IS,A
	NEG A
	CMP A,S
	BHIS 1$
	.BUG.	;OVER POPPING
1$:	MOV A,S
	JMP SPOPT1
.STITL INITIALIZE NODE SPACE
INIT:	MOV #ZEROS,A
	MOV #<EZEROS-ZEROS>/2,B
4$:	CLR (A)+
	SOB B,4$
	MOV #'?,PRMTCH
	MOV #27.,RNSEED
	MOV IS,S
	MOV #UHCT,A	;CLEAR OUT THE USER HASH TABLE
	MOV #HCC,B	;THUS MAKING EVERYTHING GARBAGE
1$:	CLR (A)+
	SOB B,1$
	MOV #GCMKL,A	;CLEAR ALL THE THINGS THAT GET MARKED ON
2$:	MOV (A)+,B
	BEQ 3$
	CLR (B)
	BR 2$
3$:
.IFNZ LSI
	MOV #NODESP+2000,ARYAD
	CLR ASPACE	;RESET ARRAY PARAMETERS
	MOV #NODESP+2000,ARTOP
.ENDC
.IF Z BEEF
	MOV #PSTP15,ERFRET
	MOV #RET,DOFRET
.ENDC
	MOV #NODESP,A
	MOV #INODES,B
	MOV #400,C
	MOV #IDLE,D
INODCP:	MOV (B)+,(A)+
	MOV (B)+,(A)+
	DEC C
	INC D
	CMP #ASOFN,B
	BNE INODCP
	MOV #NODESP+<400*4>,NODTOP
	JSR PC,.GCOLL
	RTS PC

INIT1:	BIS #PADERF,FLAGS2	;SO OCTAL ERROR ADDR IS PRINTED
STARTF:	RTS PC
.IFNZ LSI
SINIT:	MOV #INITTB,A
	MOV #HICORE,B
1$:	SUB (A)+,B
	MOV B,@(A)+
	CMP A,#INITTE
	BNE 1$
	RTS PC
.ENDC

	.STITL READ-EVAL LOOP DRIVER (THE ONE-USER MAIN LOOP)
.IFNZ LSI
CHKIN:	MOV #RSTPDL,P
	JSR PC,SORT
	JSR PC,SYSCHK	;TO INIT XORS BEFORE DUMPING
	HALT
.ENDC

START:
	.IF NZ LSI
	RESET
	.ENDC
	MOV #.TICTM!.TIECM!.TLIPM!.TICVM,TTYST
	MOV #TYO,PCHR
	MOV #TYI,GCHR
	TST RAN		;DID WE EVER RUN?
	BEQ 2$		;NOPE
	JMP RESTART	;EITHER WE ARE A RELOADED DUMP OR A RESTARTED LIVE PROGRAM
2$:	MOV PC,RAN	;NEXT TIME WE WON'T GET TO HERE
START1:.IFNZ LSI
	MOV #RSTPDL,P
	JSR PC,SORT
	JSR PC,SYSCHK
	JSR PC,SINIT	;INIT STORAGE
.ENDC
	MOV IP,P	;INIT P PDL

.IFNZ TS

	TST INITED	;HAS THE PURIFYING ALREADY BEEN DONE?
	BNE 1$
	JSR PC,PURINT
1$:
	SPUSH #0*400+0		;LENGTH AND START
	TST -(P)		;PAGE TO GET NOT USED WITH SOURCE=FRESH
	SPUSH #<10+NODPG>*400+377	;40000-60000, FRESH PAGE
	SPUSH #<.CRWRT+1>	;INSERT INTO SELF
	$MAP
.IFF
	MOV #LSTOEN,LSRCSR	;INIT TTY STATUS REGISTERS,CAUSING INTERRUPTS
.ENDC
	JSR PC,SETTTY
.IIF NZ DSK,	JSR PC,DSKINT
.IIF Z LSI,	JSR PC,BRKINT	;SET UP THE BREAK PROCESS
.IIF NZ TVS,	JSR PC,TVCHK				;SET THE TV FLAG
.IF NZ FPPF
.IIF Z LSI,	$FLOAT
	LDFPS #40300
.ENDC
	JSR PC,INIT
.IFZ LSI
	SAVE <#-1,#0,#.QUCAP*400>
	$INVOK		;CREATE A SEMAPHORE
	REST DRBUFF
	SAVE <#-1,#0,#.QUCAP*400>
	$INVOK		;AND ANOTHER
	REST DRSTUF
	JSR PC,RINIT
.IFF
	JSR PC,ONETYI
.ENDC
	JSR PC,HELMES
	JMP MLOOP

RESTAR:	MOV #RSTPDL,P	;TEMP PDL
.IFZ LSI
	SAVE <,,#.SPKIL*400+1>	;KILL ALL PROCESSES BUT ME
	$INVOK
	MOV MAINPR,A	;MAIN PROCESS
	JSR PC,DELCP	;DELETE IT
	$SINK		;I WILL BECOME THE BREAK PROCESS, DON'T NEED FLOATING POINT
	JSR PC,BRKINT	;MAKE SURE BREAK PROCESS IS RUNNING
	$FLOAT		;MAKE SURE WE HAVE FLOATING POINT
.IFF
	MOV #100,LSRCSR
.ENDC
	LDFPS #40300
	JMP TOPLEVEL	;GO TOP LEVEL US
1$:	BPT		;DOESN'T WORK

HELMES:
LANGC <	CPRTXT ^/WELCOME TO 11LOGO />,<
	CPRTXT ^/BIENVENUE A 11LOGO />
	MOV LVERNF,A
	JSR PC,PRDN
	TST DEBSW
	BEQ 1$	;IF DEBUG SWITCH IS ON
		;PRINT MESSAGE
	CPRTXT ^/LOGO BEING DEBUGGED!/
1$:	PRCR		;PRINT CR
	RTS PC

.IFNZ DSK
DSKINT:
	SAVE <#PSWPAD,#-PPDLL>			;KLUDGE, TEHSE ARGS FOR BLKO
	SAVE <#-1,#PCRBLK,#.FACAP*400+0>	;THESE ARGS FOR THE INVOKE
	$INVOK
	MOV (P),PPDLCP
	$BLKO			;RESEVRE THE EMERG BLOCK
	SAVE <#SSWPAD,#-SPDLL>			;ARGS FOR BLKO
	SAVE <#-1,#SCRBLK,#.FACAP*400+0>	;ARGS FOR INVOK
	$INVOK
	MOV (P),SPDLCP
	$BLKO			;FOR EMRG BLOCK
	SAVE <#0,#4,#<1*400>+1>
	$INVOK			;READ THE C-LIST AT 4 (DEFAULT DIR)
	TST (P)+		;IS ANYTHING THERE?
	BNE HAVDEF		;YES, WE HAVE A DEFAULT DIR.
	SAVE <#-1,#0,#.CPYCP+10>	;NO DEFAULT DIRECTORY,
	$INVOK			;SO USE THE ROOT
	SPOP DEFCAP
HAVDEF:	SAVE <,,DEFCAP>	
	BIS #.FADI,(P)		;WANT TO GET DISK NUMBER
	$INVOK
	REST <A,A>	;DISK NUMBER IS SECOND ON STACK
	ADD #10,A	;CONVERT TO ROT CAP NUMBER
	MOV A,DEFROT	;THIS IS THE DEFAULT ROOT
	MOV #10,C		;FIRST DISK CAP
	CLR A
DSKNAM:	SAVE <#DNAME,#<4+MXNAME>*2,C>	
	BIS #.FARI,(P)		;WANT TO GET DISK NAME
	.INVOK
	BEQ OPNDON		;IF IT FAILS WE MUST BE DONE
	INC DISKS		;ONE MORE DISK
	MOV DNAMEP(A),E		;POINTER TO NAME BLOCK
	MOV #DNAM,F		;POINTER TO NAME READ IN
1$:	MOVB (F)+,(E)+
	BNE 1$
	ADD #2,A		;NEXT DISK NUMBER
	INC C			;POINT TO THE NEXT CAPABILITY
	BR DSKNAM
OPNDON:	CLR (A)			;TERMINATE DISKS
	ADD #6,P		;FIX PDL
	RTS PC
.ENDC

.IFZ LSI
BRKINT:	SAVE <#-1,#BRKIN1,#.PRCAP*400+0>
	$INVOK		;CREATE THE MAIN PROCESS
	REST MAINPR	;SAVE CAP TO IT
	SAVE <,MAINPR,#<.SPPTP*400>+1>
	$INVOK		;PUT PROCESS INTO OURSELF
	MOV P,A		;PDL FOR MAIN PROCESS
	SAVE <,A,MAINPR>
	BIS #<.PRREG!.PRWRT!6>*400,(P)	;WRITE PDL POINTER
	$INVOK
	SAVE <,#0,MAINPR>
	BIS #<.PRSTOP!.PRWRT>*400,(P)
	$INVOK		;START MAIN PROCESS
	BR BRKPRS	;WE AR ETHE BREAK PROCESS

BRKIN1:	RTS PC		;MAIN PROCESS RETURNS

EBREAK:	ERROR+BRK	;CLOBBER THE MAIN PROCESS TO COME HERE IF HUNG

BRKPRS:	MOV #BRKPDL,P	;MY OWN SPECIAL PDL
BRKPR3:	SAVE <#0,#<'Z-100>*400+'G-100,TYICP>
	MOVB #.TTBRK,1(P)	;TO WAIT FOR ONE OF THESE CHARS
	$INVOK		;WAIT
	CMPB #'Z-100,(P)	;WAS IT A PAUSE?
	BNE BRKPR1
	MOV #-1,BRAKE
BRKPR1:	CMPB #'G-100,(P)	;WAS IT A BREAK?
	BNE BRKPR2
	MOV #1,BRAKE
BRKPR2:	TST (P)+
	TST BRAKE
	BEQ BRKPRS
	SAVE <,#1,MAINPR>
	BIS #<.PRSTOP!.PRWRT>*400,(P)	;WANT TO STOP THE MAIN PROCESS
	$INVOK
	SAVE <,,MAINPR>
	BIS #<.PRREG+7>*400,(P)	;WANT TO READ IT'S PC
	$INVOK
	MOV #BREAKS,A	;TEHMS THE BREAKS
2$:	CMP (P),(A)	;IS THE PC THERE?
	BEQ 1$		;YUP
	TST (A)+	;NEXT
	BNE 2$
	BR BRKPR4
1$:	SAVE <,#EBREAK,MAINPR>
	BIS #<.PRREG+7+.PRWRT>*400,(P)
	$INVOK
BRKPR4:	TST (P)+	;POP PC
	SAVE <,#0,MAINPR>
	BIS #<.PRSTOP!.PRWRT>*400,(P)
	$INVOK
	SAVE <,#.TIRST!.TORST,TYICP>
	MOVB #.TTBIS,1(P)
	$INVOK		;RESET TTY INPUT AND OUTPUT
	BR BRKPR3
.ENDC
MLOOP:	BIC #HERRF,FLAGS2
	JSR PC,GETSTR
	JSR PC,MREAD
	BEQ MLOOP	;NO TOKEN LIST
	JSR PC,EVLINE
	BEQ MWDW
.IFNZ BEEF
	BR MLOOP		;LOOP BACK
.IFF
	POPS A
	BR MLOOP
.ENDC
MWDW:	ERROR+WDW	;WHAT SHOULD I DOO WITH (S)

.IFNZ TS
PURIFY:	MOV IP,P
	JSR PC,PURINT
	SAVE <#7_8.+0,,#<20+PURPG>_8.+374,#.CRRD+1>
	$MAP			;MAKE PURE CONSTANTS PURE
	MOV #PURPG+1,A		;FIRST I SPACE ONLY PAGE
	MOV #<<LOGEND_-10.>&77>-<<PURPG+1>*8.>,B	;NUMBER OF 512 WORD BLOCKS OF CODE
PURLOP:	SAVE <#7_8.+0,,#374>
	MOVB A,1(P)		;THE PAGE NUMBER
	SAVE <#.CRRD+1>		;ACCESS DESIRED AND SPHERE CAP
	SUB #10,B		;ABOUT TO HACK THIS MANY BLOCKS
	BLT PURLP1		;WE ARE ON LAST PAGE
	INC A			;NEXT PAGE
	$MAP			;MAKE PAGE READ ONLY
	BR PURLOP
PURLP1:	ADD #10,B		;GET LENGTH FOR LAST PAGE
	MOVB B,7(P)		;CLOBBER LENGTH
	$MAP			;PURIFY AND SHORTEN LAST PAGE
	MOV PC,INITED
	CLR DEBSW
	BPT
	JMP START

PURINT:	MOV #PURPG+1+10,A
DELPAG:	CMP -(P),-(P)		;IN DELETE, NOT USED
	SAVE #-3		;DELETE FUNCTION
	MOVB A,1(P)		;WHICH PAGE
	SAVE #1			;SELF
	$MAP		;BETTER NOT FAIL!
	INC A
	BIT #7,A		;LAST PAGE DONE?
	BNE DELPAG
	SAVE <#LSUPBL_8.+0,,#20_8.+374,#.CRWRT+1>	;SHRINK PAGE 0
	$MAP
	JSR PC,SORT
	RTS PC

;THE EXPAND SPACE ROUTINE
;CALL WITH A POINTER IN A TO A BLOCK:
;(A) CURRENT HIGHEST PAGE
;2(A) CURRENT LENGTH OF HIGHEST PAGE
;4(A) HIGHEST PAGE TO USE FOR THIS SPACE
;MAY CLOBBER B AND C
EXSPAC:	INC 2(A)	;INCREASE HIGH PAGE?
	CMP #10,2(A)	;IS IT ALREADY 4K?
	BEQ EXSPA1	;YUP
	SAVE <#0,#0,#10_8.+374,#.CRWRT+1>	;TO EXPAND THE PAGE
	MOVB 2(A),7(P)	;HOW LONG?
	BISB (A),3(P)	;WHICH PAGE?
	.MAP 		;ATTEMPT TO EXPAND
	BNE EXSPA2	;LOSE?
	ADD #10,P	;POP ARGS OF FAILED CALL
	DEC 2(A)	;WE DIDN'T DO WHAT WE SET OUT TO
EXSPA3:	SEZ		;INFORM OF FAILURE
EXSPA2:	RTS PC
EXSPA1:	DEC 2(A)	;NOT INCREASING PAGE SIZE AFTER ALL
	CMP (A),4(A)	;ALREADY ON LAST PAGE?
	BEQ EXSPA3	;IF YES LOSE
	INC (A)		;GO TO NEXT PAGE
	CLR 2(A)	;START WITH 512 WORDS
	SAVE <#0,#0,#10_8.+377,#.CRWRT+1>	;TO CREATE NEW PAGE
	BISB (A),3(P)	;WHICH PAGE?
	.MAP		;TRY TO CREATE
	BNE EXSPA2	;BR ON WINNING
	ADD #10,P	;POP ARGS
	MOV #7,2(A)	;BACK UP
	DEC (A)		;TO PREVIOUS PAGE
	BR EXSPA3	;GO FAIL
.ENDC
RUNRUG:	JSR PC,CKSST
	BPT
	SEZ
	RTS PC

TSSET:	TST -(P)
	SPUSH D
	SPUSH #.TTMOV*400+2	;SET THE TTY STATUS
	$INVOK
	SEZ
	RTS PC

SETTTY:	SAVE D
	MOV TTYST,D
SETTT1:	JSR PC,TSSET
	REST D
	SEZ		;DON'T RETURN VALUE
	RTS PC

WHERE:	SAVE <,,#.TTCNO*400+2>
	$INVOK
	REST B
	JMP R1NARG	

TINECH:	SAVE D
	MOV #.TLIPM!.TICVM,D
	BR SETTT1

ECHOSW:	MOV #.TIECM,C
	BR CASES1
CASESW:	MOV #.TICVM,C
CASES1:	JSR PC,G1NARG
	CLR A
	TST B
	BEQ 1$
	MOV C,A
1$:	BIC C,TTYST
	BIS A,TTYST
	JMP SETTTY

TVTEST:		BIT #TVF,DFLAGS
	BNE 1$
	ERROR+OTVS
1$:	RTS PC

.IFNZ TVS
.TVP:	BIT #TVF,DFLAGS
	BEQ 1$
	JMP RTTRUE
1$:	JMP RTFALS

SMALLF:	MOV #1,A
	BR BIGFO1
BIGFON:	MOV #0,A
BIGFO1:	JSR PC,TVTEST
	SAVE <,A,TYICP>
	BIS #.TVFNT*400,(P)
	.INVOK
	BNE 1$
	ERROR+WTA
1$:	BIT #DISPF,DFLAGS,DFLAGS	;IS DISPLAY TURNED ON?
	BEQ 2$				;NOPE
	JMP TVSTR1			;GO INIT TV
2$:	JMP KILLD9			;GO RECOMUTE ECHO AREA WITH NO DISPLAY

.ENDC
DELCP:
.IFZ LSI
DELCAP:	TST A
	BEQ DELCP1
	CMP -(P),-(P)
	SAVE A
	BIS #.DELCP,(P)
	$INVOK
DELCP1:	RTS PC
.ENDC
	.STITL GET A STRING
.IFZ BEEF
GSTR4:	PUSHS C
	PUSH GCHR
	SPUSH PCHR
	SPUSH PRMTCH
	CLR PRMTCH
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	JSR PC,.LOADC
	PUSHS B
	JSR PC,PRLN
	POPS B
	JSR PC,RDSTR
	BEQ GSTR5
GSTR7:	POPS A		;IGNORE ANY LINE TYPED IN
GSTR10:	POP PRMTCH
	SPOP PCHR
	SPOP GCHR
	POPS C
	JSR PC,.LOADC
	JSR PC,.LOADB	;PUT THINGS BACK AS THEY WERE
	BR GSTR3

GSTR5:	BIT #RBRKF,TFLAGS
	BEQ GSTR10
	POP PRMTCH
	ERROR+BRK
GETSTR:	TST FUNLEV	;ARE WE IN A PROC
	BEQ GSTR0	;NO
	BIT #BRKF,FLAGS	;ERROR, MAYBE
	BNE GSTR0	;YES
	MOV CLP,B	;NO, GET THIS NODE OF LLP
	BEQ GSTR9
	JSR PC,.LOAD
	BIT #7777,A	;IS IT LAST NODE
	BNE GSTR8
	SPOP A		;POP RETURN ADDR
	JMP PSTOP
GSTR9:	MOV CPLN,B
	JSR PC,GTLINE
	BNE 1$
	ERROR+LDE	;LINE ..(B).. DOESN'T EXIST
1$:	MOV C,A
GSTR8:	CLR CLP
	MOV A,C
	JSR PC,.LOADC
	JSR PC,.LOAD	;OK, GET FIRST NODE OF LINE, = LINE #
	MOV B,CPLN
	BIT #TPSF,FLAGS
	BNE GSTR4
GSTR3:	MOV C,CLP
	MOV A,CTP	;IN CASE THERE IS NO GENERATION #
	MOV A,C
	JSR PC,.LOADC	;GET SECOND NODE
	CLR CLGN	; IF TYPE = SNUM, IT IS GEN #
	MOV A,C
	BIC #7777,C
	CMP #SNUM,C
	BNE GSTR6
	MOV B,CLGN	;IT IS
	MOV A,CTP
GSTR6:	BIS #LIST,CTP
	PUSHS CTP
	BIT #TRACEF,FLAGS2
	BEQ GSTRT
	CPRTXT ^\ #\
	MOV CPP,B
	JSR PC,PPNAME	;PRINT PNAME
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRCR
	JSR PC,PRLN
	PRCR
GSTRT:	RTS PC
GSTR0:
GSTR1:	JSR PC,RDSTR
	BNE GSTRT
GSTR2:	BIT #RBRKF,TFLAGS
	BEQ GSTR1
	ERROR+BRK
.ENDC
	.STITL GET A STRING
.IFNZ BEEF
GETSTR:	TST FUNLEV	;IN A PROC?
	BNE GETLIN	;YES, GET A LINE FROM IT
GETST0:	JSR PC,RDSTR	;GET THE CHARACTERS FOR THE LINE INTO AN LSTR
	BNE GETST1	;GOT SOMETHING
	BIT #RBRKF,TFLAGS	;BREAK?
	BEQ GETST0	;NOTHING, TRY AGAIN
	ERROR+BRK	;ERROR OUT
GETST1:	RTS PC

GETLIN:	BIT #BRKF,FLAGS	;ARE WE IN A BREAK LOOP?
	BNE GETST0	;THEN READ FROM THE TTY
	MOV NEXLIN,A	;POINT TO THE NEXT LINE
	BEQ ENDPRO	;THE END OF THIS PROCEDURE
	ASR A		;IS IT ODD?
	BCC LINGO1	;NO, JUST USE THIS POINTER
;HERE WE JUST EXECUTED A GO, AND MUST SEARCH FOR THE LINE
LINGO:	MOV CPLN,B	;THE LINE WE ARE TO GO TO
	JSR PC,GTLINE	;GET A POINTER TO THE LINE
	BNE 1$
	ERROR+LDE	;LINE B DOESN'T EXIST
1$:	SUB @CPBND,B	;MAKE B RELATIVE
	MOV B,NEXLIN	;PRETEND THIS WAS THE NEXT LINE ALL ALONG
LINGO1:	MOV NEXLIN,C	;POINT TO THE NEXT LINE
	MOV @CPBND,F	;GET POINTER TO START OF ARRAY
	MOV C,CTP
	ADD F,C		;MAKE IT AN ABSOLUTE POINTER
	MOV 2(C),CPLN	;GET THE LINE NUMBER
NEXEXC:	MOV C,A		;SAVE POINTER TO THE CURRENT LINE
	ADD (C)+,C	;GET THE NEXT LINE LOCATION
	SUB F,C		;MAKE IT RELATIVE AGAIN
	CMP C,5*2(F)	;ARE WE AT THE END OF THE ARRAY
	BLO 1$		;NO
	BNE GSTBUG	;BUG IF WE ARE PAST IT
	CLR C		;NO NEXT LINE, JUST RETURN
1$:	MOV C,NEXLIN	;PUT IN POINTER TO THE NEXT LINE
	BIT #TPSF,FLAGS	;PROCEDURES STEPPED?
	BEQ 2$		;NOPE
	JSR PC,LINSTP		;PRINT THE LINE, AND WAIT FOR CR.
2$:	BIT #TRACEF,FLAGS2	;ARE WE TRACED
	BEQ GSTDON	;NO, WE ARE DONE
	SPUSH A		;SAVE THE POINTER TO THE LINE
	CPRTXT ^\ #\
	MOV CPP,B
	JSR PC,PPNAME	;PRINT PNAME
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRCR
	SPOP F		;GET BACK POINTER
	JSR PC,PRLN
	PRCR
GSTDON:	RTS PC
GSTBUG:	.BUG.		;PROCEDURE SCREWED
ENDPRO:	TST (P)+	;POP OFF THE RETURN ADDRESS
	JMP PSTOP	;STOP THIS PROCEDURE
.ENDC

.IFNZ BEEF
;CURRENT LINE POINTED TO BY A
LINSTP:	PUSH GCHR		;SAVE THE PRINTING AND RECIEVING WORLD
	SPUSH PCHR
	SPUSH PRMTCH		;SAVE THE PROMPT CHARACTER
	CLR PRMTCH		;DONT PROMPT AT ALL
	MOV #TYI,GCHR		;RECIEVE CHARACTER FROM THE TTY
	MOV #TYO,PCHR		;AND PRINT THE LINE THERE
	MOV A,F			;GET THE POINTER TO THE CURRENT LINE
	JSR PC,PRLN		;AND PRINT IT OUT
	JSR PC,RDSTR		;READ A STRING
	BEQ LINST1		;EMPTYP, MIGHT BE A BREAK RECIEVED
	POPS A			;IGNORE LINE TYPED IN
LINST2:	POP PRMTCH		;POP PROMPT AND REST OF WORLD
	SPOP PCHR
	SPOP GCHR
	RTS PC
LINST1:	BIT #RBRKF,TFLAGS	;BREAK?
	BEQ LINST2		;NOPE
	POP PRMTCH		;NEED THE PROMPT CHARACTER
	ERROR+BRK		;AND ERROR OUT

.ENDC
	.STITL MORE READ ROUTINES!!!
MREAD:	TST FUNLEV	;ARE WE IN PROC?
	BEQ MREAD1	;NO
	BIT #BRKF,FLAGS	;YES, BUT ERROR?
	BEQ MRD3
MREAD1:	CLR ILINEL
	JSR PC,READ	;CONVERT CHAR STRING TO TOKEN LIST
	BEQ MRD4	;NO TOKENS
.IFZ BEEF
	MOV @S,ILINEL
.IFF
	POPS A
	MOV A,ILINEL	;GC PROTECT THIS CRUFT
	JSR PC,WRTLIN	;WRITE LINE INTO THE COMMAND BUFFER
.ENDC
MRD3:	CLZ
MRD4:	RTS PC

CKSTG:	;CKECK IF DISC OR NODES ARE ALMOST GONE
	BIT #DSAMFL,FLAGS2
	BNE CKSTG1
	CMP NNIFSL,#NBN
	BHIS MRD4
	JSR PC,.GCOLL	;GC AND EXPAND IF NEEDED
	CMP NNIFSL,#NBN
	BHIS MRD4
CKSTG1:	CLR ERPROC
	ERROR+NSL

.IFNZ BEEF
;WRITE LINE POINTED TO BY A INTO COMMAND BUFFER
WRTLIN:	MOV #CURLIN+4,C	;POINTER TO THE CURRENT LINE
	CLR D		;COUNTER OF TOKENS
WRTLOP:	JSR PC,.LOADA	;GET THE FIRST NODE IN A,,B
	MOV B,(C)+	;WRITE IT INTO THE BUFFER
	INC D		;ONE MORE TOKEN
	BIT #7777,A	;DONE?
	BEQ WRTDON	;YES
	CMP D,#INLEN	;HAVE WE DONE ALL OF THEM?
	BNE WRTLOP	;NO
;HERE THE BUFFER IS FULL
	ERROR+NAS	;NOT ENOUGH ARRAY SPACE (SHOULD BE TOO MANY TOKENS)
WRTDON:	INC D		;SO THAT WE HAVE A LINE NUMBER
	ASL D		;WANT A BYTE COUNT
	MOV D,CURLIN	;AND PUT IN THE LENGTH
	CLR CTP		;OFFSET IS 0 FOR THE START OF THE LINE FROM THE START OF BUFFER
	MOV #CURPNT,CPBND	;MAKE CPBND POINT TO SOMETHING
				;THAT ALWAYS HAS CURLIN
	RTS PC
.ENDC
	.STITL EVAL 1 LINE
;EVAL THE LINE ON THE S PDL,
;IN THE NEW SCHEME, EVAL THE LINE POINTED TO BY CTP

EVLINE:	BRAKET
.IFZ BEEF
	TST TOPRNM
	BNE EVLI4
EVLI6:
.ENDC
	BIC #EVIFS,FLAGS
	CLR CO
	CLR NOR
	CLR COF
	CLR LO
.IFZ BEEF
	CLR LO+2
	CLR CO+2
.ENDC
	JSR PC,IGNT
EVLI1:	BIT #CRF,FLAGS
	BNE EVLI2
.IFNZ BEEF
	TST TOPRNM	;IN PROCEDURE?
	BNE EVLI4	;NO, JUST FORGET IT
EVLI6:
.ENDC
	JSR PC,EVAL
	BEQ EVLI3	;NO OUTPUT, OK
	JSR PC,CKSTG
	SEZ
	RTS PC
EVLI3:	JSR PC,CKSTG
	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,GNT
	BIS #RTF,FLAGS
	BR EVLI1
EVLI4:
.IFZ BEEF
	JSR PC,CKSTG
	MOV @S,B
	JSR PC,.LOAD
	MOV A,D
.ENDC
	BIC #7777,A
	CMP #SNUM,A
	BEQ EVLI5	;AN SNUM
	CMP #INUM,A
	BEQ EVLI8	;AN INUM
	CMP #LSTR,A
	BNE EVLI6	;NOT AN SNUM, INUM OR LSTR
	JSR PC,.CLSIN	;CONVERT LSTR TO INUM
	BEQ EVLI6	;NOT NO. OR TOO BIG
EVLI8:	BIT #SPDF,FLAGS	;IS THIS PROC DEF. BEING SKIPPED?
	BNE EVLI2
	JSR PC,.CINSN	;CONVERT INUM TO SNUM
	BEQ EVLI7	;TOO BIG
	TST B	;IS NO. TOO SMALL?
	BGT 1$
	ERROR+LNTS
1$:
.IFZ BEEF
	MOV D,A
	BIC #170000,A	;MAKE IT INTO AN SNUM
	BIS #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	MOV C,@S
.IFF
	BIC #RTF,FLAGS	;DONT WANT TO REPEAT THIS TOKEN
.ENDC
EVLI5:	JSR PC,ADLN
EVLI2:	CLZ
	RTS PC
EVLI7:	ERROR+LNTB	;LINE # TOO BIG
	.STITL GET NEXT TOKEN
.IFZ BEEF
GNT:
	MOV CT,A
	MOV CT+2,B
	BIT #RTF,FLAGS	;IS REPEAT TOKEN FLAG SET?
	BEQ GNT1
	BIC #RTF,FLAGS	;YES
	CMP #SFUN,A
	BNE GNT6
	TST B
	BNE GNT6
	BIS #CRF,FLAGS
GNT6:	RTS PC
GNT1:	BIC #PTLPF,FLAGS
	CMP #$LLPAR,B	;IS CT "("
	BEQ GNT3
	CMP #$LPAR,B
	BNE GNT3A
GNT3:	BIS #PTLPF,FLAGS	;YES, SET PTLPF
GNT3A:	MOV A,CTP	;GET LINK TO NEXT TOKEN
	BIT #7777,A
	BEQ GNT2	;ANY TOKENS LEFT
	JSR PC,.LOADA	;YES
	INC CTN
GNT3B:	CMP #$COMT,B
	BEQ SKPCOM
GNT4:	MOV A,CT
	MOV B,CT+2
	RTS PC
GNT2:	BIT #CRF,FLAGS
	BNE GNT5
	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR GNT4
GNT5:	ERROR+OOT	;OUT OF TOKENS
SKPCOM:	MOV A,CTP	;SKIP OVER A COMMENT
	BIT #7777,A
	BEQ GNT2	;END ON CR FOUND
	JSR PC,.LOADA
	INC CTN
	CMP #$COMT,B
	BNE SKPCOM	;DON'T STOP TILL CR OR CLOSING "!"
	BR GNT3A	;RETURN TOKEN AFTER CLOSING "!"

IGNT:	MOV @S,B	;INIT "GNT"
	BIT #7777,B
	BEQ IGNT1
	BIC #CRF,FLAGS
	MOV B,CTP
	JSR PC,.LOAD
IGNT2:	MOV A,CT
	MOV B,CT+2
	BIS #RTF,FLAGS
	MOV #1,CTN
	BR GNT3B
IGNT1:	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR IGNT2
.ENDC

.IFNZ BEEF
GNT:	MOV CT,B		;GET THE OLD CURRENT TOKEN
	BIT #RTF,FLAGS		;SHOULD WE REPEAT THIS TOKEN
	BEQ GNT1		;NO
	BIC #RTF,FLAGS		;CLEAR THE FLAG
	TST B			;END OF LINE?
	BNE 1$			;NO
	BIS #CRF,FLAGS		;SAY IT IS
1$:	MOV B,A			;COPY IT
	RTS PC
GNT1:	BIC #PTLPF,FLAGS	;SET FLAG FOR PARENS
	CMP #$LLPAR,B		;IS IT "!("
	BEQ GNTPAR		;YES, OKAY
	CMP #$LPAR,B		;IS IT "("
	BNE GNT3		;NO, LEAVE THE FLAG CLEAR
GNTPAR:	BIS #PTLPF,FLAGS	;SET THE PARENS FLAG
GNT3:	DEC CLCNT		;DECREMENT THE NUMBER OF TOKENS LEFT ON THIS LINE
	BMI GNT2		;DONE WITH THIS LINE
	MOV CTP,A		;GET THE NEXT TOKEN POINTER
	ADD @CPBND,A		;MAKE IT UNRELATIVE
	MOV (A)+,B		;GET THE TOKEN
	ADD #2,CTP		;POINT TO THE NEXT TOKEN
GNT5:	CMP #$COMT,B		;IS IT A COMMENT
	BEQ SKPCOM		;SKIP THE COMMENT
GNT4:	MOV B,CT		;PUT THE TOKEN INTO CT
	MOV B,A			;COPY IT FOR SOME APPLICATIONS
	RTS PC
GNT2:	BIT #CRF,FLAGS		;AT THE END OF LINE THE TIME BEFORE?
	BNE 1$			;YES, LOSER
	BIS #CRF,FLAGS		;SAY AT END OF LINE
	CLR B			;SAY NO MORE TOKENS
	BR GNT4			;FINISH UP
1$:	ERROR+OOT		;OUT OF TOKENS
SKPCOM:	DEC CLCNT		;GET THE NEXT TOKEN
	BMI GNT2		;END OF LINE
	MOV (A)+,B		;GET THE NEXT TOKEN
	ADD #2,CTP
	CMP #$COMT,B		;IS IT A COMMENT?
	BNE SKPCOM		;NO, JUST CONTINUE
	BR GNT3			;GET THE NEXT TOKEN

IGNT:	MOV CTP,B		;POINTER TO THE START OF THE LINE
	ADD @CPBND,B		;MAKE IT ABSOLUTE
	BIC #CRF,FLAGS		;CLEAR THE END OF LINE FLAG
	CMP #2,(B)		;IS THE LENGTH OF THE TOKEN STRING 0 
	BEQ GNT2		;YES, SIGNAL IT
	BIS #RTF,FLAGS		;REPEAT THIS TOKEN
	MOV (B),A		;GET THE NUMBER OF TOKENS IN THIS LINE
	ASR A			;FROM BYTES TO WORDS
	DEC A			;FOR THE LINE NUMBER
	MOV A,CLCNT		;SET UP THE TOKEN COUNT
	ADD #4,CTP		;POINT TO THE FIRST TOKEN IN THE LINE
	BR GNT3			;CONTINUE WITH THE REST OF THE LINE.
.ENDC
	.STITL LOGO TYI/O
ONETYI:	MOV #.TICVM!.TIECM,D
	JSR PC,TSSET
	JSR PC,TYI	;GET THE CHARACTER
	JSR PC,SETTTY
	RTS PC
CTYI:	JSR PC,SAVTTY
	TST -(P)
	SPUSH #.TLIPM+.TIEDM+.TIRBM
	SPUSH TYICP
	BISB #.TTBIC,1(P)
	$INVOK
	SPUSH TYICP
TYWAIT:	$BYTI
	JSR PC,RESTTY
	SPOP B
	JMP R1NARG
CTYO:	JSR PC,G1NARG	;GET ARGUMENT IN B
CTYO1:	JSR PC,SETTIM	;SET TTY TO IMAGE MODE
	SPUSH B
	SPUSH TYICP
	$BYTO
	JSR PC,RESTTY
	SEZ
	RTS PC
SETTIM:	JSR PC,SAVTTY
	TST -(P)
	SPUSH #.TIMGO	;IMAGE OUT
	SPUSH TYICP
	BISB #.TTBIS,1(P)
	$INVOK
	RTS PC

RESTTY:	TST -(P)
	SPUSH TTYST
	SPUSH TYICP
	BISB #.TTMOV,1(P)
	$INVOK
	SEZ
	RTS PC

SAVTTY:	SUB #4,P
	SPUSH TYICP
	BISB #.TTRD,1(P)
	$INVOK
	SPOP A
	MOV A,TTYST
	RTS PC

TYI:
.IFZ TS+LSI
	WAIT
RLWAIT:	TST CHI
	BEQ TYI
	MOVB CHI,D
	CLR	CHI
	BIC #177600,D
.IFF
	SPUSH TYICP
RLWAIT:	$BYTI
	SPOP D
	RTS PC
.ENDC

TYO:
.IFZ TS+LSI
	TSTB 177564
	BPL .-4
	MOVB D,177566
	CMP #15,D
	BEQ 1$
	RTS PC
1$:	MOV D,-(P)
	MOV #12,D
	JSR PC,TYO
	SPOP D
	RTS PC
TYIBRK:	MOV 177562,CHI
	RTT
.IFF
	TST BRAKE
	BNE 1$
	SPUSH D
	SPUSH TYOCP
	$BYTO
1$:	RTS PC
.ENDC
.IFNZ GTI
.GTIOUT:	JSR PC,G1NARG
	JSR PC,GTOUT
	SEZ
	RTS PC

GTOUT:	SAVE <A,B,D,E>
	JSR PC,SETTIM
	CLR A
	ASL B
	MOV #3,D
	MOV #GTIBUF+1,E
GTOUT1:	ASHC #5,A
	BIC #177740,A
	ADD #100,A
	MOVB A,(E)+
	SOB D,GTOUT1
	SAVE <#GTIBUF,#-4,TYOCP>
	$BLKO
	JSR PC,RESTTY
	REST <E,D,B,A>
	RTS PC
.ENDC
MYSPEED:	JSR PC,G1NARG
	BIC #177760,B
	MOV B,C
	ASH #4,C
	BIS B,C
	ASH #6,C
	BIS #22,C
	CMP #3,B
	BLT 1$
	BIS #4,C
1$:	SAVE <,C,#.TTSPD*400>
	MOVB TYOCP,(P)
	.INVOK
	BNE 2$
	ERROR+TDE
2$:	SEZ
	RTS PC


.IFZ LSI
UGTTYG:	POPS	E	;DEVICE SPEC (NAME OR NUMBER)
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
	JSR	PC,OPEN1
	RTS PC

.TTYP:	JSR PC,UGTTYG
	BEQ TTYP	;SPECIFIED HIS TTY
	SUB #4,P
	MOVB TTYCPS(E),-(P)
	BR TTYP1
.ENDC

TTYP:	SUB #4,P
	SAVE TYICP
TTYP1:	MOVB #.TTPEK,1(P)
	$INVOK		;FIND OUT IF THERE IS A CHARACTER
	TST (P)+	;NEGATIVE IF NONE
	BGE 1$		;YES RETURN TRUE
	JMP RTFALS
1$:	JMP RTTRUE

.IFZ LSI

;DEVTYI-- TYI N OUTPUTS A CHAR FROM TTY N
DEVTYI:	JSR PC,UGTTYG
	BNE 1$		;ANOTHER TTY
	JMP CTYI	;WANTED IT FROM HIS TTY
1$:	CLR -(P)
	MOVB TTYCPS(E),(P)	;CAP WE HAVE TO THE TTY
DTWAIT:	$BYTI		;GET A BYTE
	REST B		;FOR THE USER
	JMP	R1NARG

;DEVTYO-- TYO N M SENDS CHAR M TO TTY N. N MAY BE NAME OR NUMBER.
DEVTYO:	JSR	PC,G1NARG	;B _ CHAR
	POPS	E	;DEVICE SPEC
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
	JSR	PC,OPEN1	;MAKE SURE TTY OK
	BNE 1$			;ANOTHER TTY
	JMP CTYO1		;OUTPUT IT TO OUR TTY
1$:	SAVE <B,#0>
	MOVB TTYCPS(E),(P)	;OUR CAP TO THIS TTY
	$BYTO
RTSPC:	SEZ
	RTS	PC

TTYCHK:	CMP E,#TTYHGH	;TO BIG?
	BLO 1$		;NO
	CMP E,#-1	;IS IT HIS TTY?
	BEQ 1$		;FINE
	ERROR+TDE	;DONT EXIST
1$:	RTS PC

OPEN1:	JSR PC,TTYCHK	;TO BIG A NUMBER
	BEQ 3$		;HIS TTY, DO NOTHING
	TSTB TTYCPS(E)	;ALREADY OPEN?
	BEQ 1$		;NO
	RTS PC
1$:	SAVE <#-1,E,#.TTCAP*400>	;TRY TO CREATE IT
	.INVOK
	BNE 2$		;GOT IT
	ERROR+DIU	;ALREADY IN USE
2$:	MOV (P)+,F	;GET THE CAP NUMBER
	MOVB F,TTYCPS(E)	;SAY THAT WE HAVE IT
	SAVE <,#.TIMGO+.TIMGI,F>	;SET THE STATUS TO IMAGE IN AND OUT
	BISB #.TTMOV,1(P)	;DO A MOVE INTO THE STATUS WORD
	$INVOK
3$:	RTS PC

CLOSE:	POPS E		;GET NUMBER OR SPEC
	JSR PC,DEVNUM	;GET THE NUMBER OR DEVICE
CLOSE1:	JSR PC,TTYCHK	;CHECK FOR VALID NUMBER
	BEQ 1$		;WAS HIS TTY
	MOVB TTYCPS(E),A	;GET THE CAP NUMBER IF OPEN
	BEQ 1$		;NOT OPEN FORGET IT
.IFNZ TVS
	JSR PC,TVTCHK
	BEQ 2$
	SAVE <#0>
	MOVB TTYCPS(E),(P)
	MOVB #.VICAM,1(P)
	SAVE #<.VIABS*400>+17
	$VIDSW			;SWITHC TO BLANKNESS
.ENDC
2$:	CLRB TTYCPS(E)	;CLEAR IT
	JSR PC,DELCAP
1$:	SEZ
	RTS PC

.IFNZ TVS
TVGRAB:	JSR PC,UGTTYG	;OPEN THE TTY
	BEQ TVGRB3	;HIS TTY DOES NOTHING
	JSR PC,TVTCHK
	BNE TVGRB2	;YES TV, GO AHEAD AND TRY TO INIT
TVGRB1:	JSR PC,CLOSE1	;GIVE UP ON THIS ONE
	ERROR+TDE	;DOESN'T EXIST? (WELLL)
TVGRB2:	SAVE <#-1,#140000,#.DSCAP*400+0>	;CREATE A DISPLAY
	MOVB TTYCPS(E),2(P)	;FOR THIS TTY CAP
	.INVOK		;TRY TO GET A DISPLAY
	BEQ TVGRB1	;TOUGH LUCK BUNKY
	MOV (P)+,A	;SAVE CAP TO DISPLAY
	CMP (P)+,(P)+	;EXTRA STUFF NO GOOD FOR TV DISPLAY
	TST -(P)
	SAVE <A,#0>		;CAP TO DISPLAY AGAIN
	MOVB TTYCPS(E),(P)	;TO ATTACH KEYBOARD TO TTY
	MOVB #.TVATC,1(P)	;USE DUMMY FROM ABOVE, DS CAP ON STACK AND THIS
	$INVOK		;SHOULD NEVER FAIL
	JSR PC,DELCP	;NOW WE CAN GET RID OF THE DISPLAY CAP
	CMP -(P),-(P)	;DUMMIES
	SAVE #0
	MOVB TTYCPS(E),(P)
	MOVB #.TVCL,1(P)	;CLEAR SCREEN FUNCTION
	$INVOK
	CMP -(P),-(P)	;DUMMIES
	SAVE #0
	MOVB TTYCPS(E),(P)
	MOVB #.TVREV,1(P)	;REVERSE SCREEN
	$INVOK
	SAVE <,#0,#0>
	MOVB TTYCPS(E),(P)
	MOVB #.TVFNT,1(P)
	$INVOK			;SET FONT 0
	SAVE #0
	MOVB TTYCPS(E),(P)
	MOVB #.VICAM,1(P)	;TTY IS DEST
	SAVE (P)		;AND SOURCE
	$VIDSW			;SWITCH!
TVGRB3:	SEZ
	RTS PC

.SETFO:	JSR PC,G1NARG		;B GETS FONT NUMBER
	SPOPS E			;GET TTY NUMBER
	JSR PC,DEVNUM		;GET NUMBER INTO E
	SAVE <,B,#.TVFNT*400>
	TST E			;IS IT FOR ANOTHER TTY, OR ME
	BPL 1$			;ANOTHER TTY
	MOVB #2,(P)		;MY CONSOLE
	BR 2$
1$:	MOVB TTYCPS(E),(P)
2$:	.INVOK
	BNE 3$
	ERROR+WTA
3$:	SEZ
	RTS PC

.TVOMODE:
	MOV S,A			;REVERSE THE TWO ARGS
	EXCH (A),2(A)
	JSR PC,UGTTYG		;GET THE TTY
	BEQ TVOMOD		;IT IS OUR TTY
	MOVB TTYCPS(E),F	;GET THE TTY NUMBER
	JSR PC,TVTCHK		;BE SURE IT IS A TTY
	BNE TVMOD1		;IT IS A TV
	ERROR+OTVS
TVOMODE:
	MOV #2,F		;THIS CONSOLE
	JSR PC,TVCNSL		;MAKE SURE IT IS A TV
TVMOD1:	JSR PC,G1NARG		;B_ ARGUMENT
	INC B			;CHANGE TO REAL NUMBER SYSTEM UNDERSTANDS
	BEQ TVMOD2		;BARF BAD STUFF
	CMP B,#.TVMOV		;IS IT LEGAL
	BHI TVMOD2		;BAD ARGUMENT
	SAVE <,B,F>		;SAVE ARG AND TTY NUMBER
	BIS #.TVMOD*400,(P)	;SET IN THE FUNCTION
	$INVOK			;SHOULDN'D FAIL
	SEZ
	RTS PC
TVMOD2:	ERROR+WTIB		;BAD ARGUMENT

.TVHERE:
	JSR PC,UGTTYG		;GET THE TTY NUMBER INTO E
	BEQ TVHERE
	MOVB TTYCPS(E),F	;GET THE CAPABILITY NUMBER
	JSR PC,TVTCHK		;IS IT A TV
	BNE TVHER1		;IT IS A TV
	ERROR+OTVS
TVHERE:	MOV #2,F		;FOR THE CAPABILITY FOR THE INPUT CAP
	JSR PC,TVCNSL		;MAKE SURE WE ARE ON TV
TVHER1:	SAVE <,,F>		;READ THE CURSOR POSITION
	BIS #.TVSET*400,(P)	;READ IT,
	$INVOK
	REST <C,B>		;GET THE LINE, THEN CURSOR
	SAVE C			;RESAVE THE LINE NUMBER
	JSR PC,PSHNUM		;PUSH CHARACTER NUMBER ONTO THE S PDL
	REST B			;GET BACK THE LINE NUMBER
	JSR PC,PSHNUM		;PUSH IT
	MOV #2,D		;TELL SENTENCE THERE ARE TWO THINGS TO BE HACKED
	JMP SENT.		;RETURN IT TO THE USER

.CURSET:
	MOV S,A			;POINT INTO THE S STACK
	EXCH (A),2(A)		;EXCHANGE THE TWO ARGUMENTS
	JSR PC,UGTTYG		;GET THE TTY NUMBER INTO E
	BEQ CURSET		;JUST MY CONSOLE
	MOVB TTYCPS(E),F	;GET THE TTY CAPABILITY
	JSR PC,TVTCHK		;IS IT A TV
	BNE CURST1		;YES
	ERROR+OTVS
CURSET:	MOV #2,F		;FOR THE TTY INPUT CAP
	JSR PC,TVCNSL		;MAKE SURE IT IS A TV
CURST1:	MOV @S,C		;GET POINTER TO THE STRING
	MOV #7777,D
	BIT D,C			;BETTER NOT BE EMPTY
	BNE 3$			;OKAY
2$:	ERROR+WTA		;LOSER
3$:	JSR PC,.LOADC		;A,B<= (C)
	MOV A,C			;NEXT ELEMENT
	MOV #SNUM,A		;CONVERT TO SNUM
	JSR PC,CONVERT
	BEQ 2$			;LOST FOR SOME REASON
	SPUSH B			;THERE IS THE CHARACTER NUMBER
	BIT D,C			;STILL LIST LEFT
	BEQ 2$			;NOPE
	JSR PC,.LOADC		;LOAD UP NEXT ELEMENT
	BIT D,A			;FINISHED
	BNE 2$			;NO, WHAT A LOSER
	MOV #SNUM,A		;CONVERT AGAIN
	JSR PC,CONVERT
	BEQ 2$
	SPUSH B			;SAVE THE LINE NUMBER
	SPUSH F			;AND THE TTY CAPABILITY
	BIS #<.TVSET+.TTWRT>*400,(P)	;SET THE CURSOR POSITION
	.INVOK			;HOPE THIS WINS
	BEQ 1$			;FAILED (BAD POSITION?)
	SEZ			;RETURN TRIUMPHANT
	RTS PC
1$:	ERROR+OOB		;TO FAR ONE WAY OR THE OTHER

TVCNSL:	SAVE <,,#2>		;MAKE SURE A TV
	BIS #.TTTYP*400,(P)	;SET IN THE FUNCTION
	$INVOK			;GET THE TYPE OF THE TTY
	BIT #200,(P)+		;CHECK THE TV BIT
	BEQ 1$			;NOT A TV
	RTS PC
1$:	ERROR+OTVS

TVTCHK:	SAVE <,,#0>
	MOVB TTYCPS(E),(P)
	BIS #.TTTYP*400,(P)	;GET THE TYPE
	$INVOK
	BIT #200,(P)+	;IS IT A TV?
	RTS PC
.ENDC

DEVNUM:	PUSH A
	SPUSH B
	MOV #SNUM,A	;TRY TO CONVER TO NUMBER
	MOV E,B		;POINTER TO THE STRING OR NUMBER
	JSR PC,CONVERT
	BEQ 1$		;FAILED TRY TO GET A STRING
	MOV B,E		;RETURN VALUE IN E
2$:	JMP RETB	;RETURN
1$:	MOV #LSTR,A	;INTO STRING
	JSR PC,CONVERT
	BEQ DNUM2	;FAILED IN BOTH
	MOV B,E		;POINTER TO THE NAME
	JSR PC,DEVNAM	;FIND THE DEVICE NAME
	BNE 2$		;GOT IT
DNUM2:	PUSHS E		;PUSH BACK THE INVALID NAME
	ERROR+DNA	;BAD NAME

DEVNAM:	ERROR+SIT

.IFNZ PTBOX
TBREST:	PUSH C
	MOV #CONSO,C
	JSR PC,TBINIT
	POP C
	RTS PC
TBINIT:	TST PTBF
	BNE 1$		;OWNS ONE
	RTS PC
1$:	SPUSH A
	SPUSH B
	SPUSH D
	SPUSH E
	SPUSH F
	MOV #PTBTAB,B
TBINT2:	MOV #4,A
TBINT3:	CMPB C,(B)
	BEQ TBINT4
	TST (B)+
	SOB A,TBINT3
TBINSZ:	SPOP F
	SPOP E
	SPOP D
	SPOP B
	SPOP A
	SEZ
	RTS PC
TBINT4:	TST F
	BMI TBINT5
	TST (B)
	BPL TBINT5
TBINCZ:	SPOP F
	SPOP E
	SPOP D
	SPOP B
	SPOP A
	CLZ
	RTS PC
TBINT5:	TST -(P)	;FOR THE SETTING OF THE STATUS BELOW
	CMP -(P),-(P)
	SPUSH TYOCP
	BIS #.TTRD*400,(P)
	$INVOK		;READ OLD STATUS
	TST -(P)
	SPUSH #.TIMGO
	SPUSH TYOCP
	BIS #.TTBIS*400,(P)	;BIS THE IMAGE OUT BIT
	$INVOK
;NOTE HERE ON THE STACK IS THE OLD STATUS, THEN AN EMPTY WORD
	MOV #21,D
	JSR PC,TYO	;OUTPUT THE ATTENTION CHARACTER TO THE THORTON BOX
	MOV B,D
	SUB #PTBTAB,D	;GET THE INDEX OF THE THING SELECTED
	MOV TBCCHR(D),D	;GET THE SELECT CHARACTER
	JSR PC,TYO
	BIS #100000,(B)
	MOV (B),C
	BIC #TBMASK,C
	CMP C,#CONSO
	BNE TBINT6
	MOV OTTYST,(P)	;CHANGE THE STATUS
	BIS #.TIRST,(P)
	BR TBINT7	;DESTROY OLD USER
TBINT6:	BIS #.TIMGO,(P)
TBINT7:	SAVE TYOCP	;THE CAPABILITY
	BIS #.TTMOV*400,(P)	;SET THE TTY STATUS
	$INVOK
	MOV #PTBTAB,C		;POINT TO THE TABLE AGAIN
	MOV #4,D
TBINT8:	TST (C)
	BGE TBINT9
	CMP C,B
	BEQ TBINT9	;DONT CLEAR THE ONE WE JUST SET
	BIC #100000,(C)
TBINT9:	TST (C)+
	SOB D,TBINT8
	BR TBINCZ
.ENDC
.ENDC	;END TYI/O LSICOND
	.STITL	GARBAGE COLLECTOR
NNODES==4096.
GCBTL== NNODES/8./2.*2.	;GARBAGE COLLECT BIT TABLE LENGTH

MARKNI:	SPUSH A
	SPUSH B
	BR MARKN4
MARKN:	SPUSH A	;MARK NODE(B)
	SPUSH B
;DEBUGGING FEATURE
	JSR PC,.LOAD	;ARE WE MARKING AN IDLE NODE
	BIC #7777,A
	CMP #IDLE,A
	BNE 1$
	.BUG.
1$:	MOV (P),B
;
MARKN4:	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;ALREADY MARKED?
	BEQ MARKN1	;NO
MARKN3:	SPOP B
	SPOP A
	SEZ
	RTS PC
MARKN1:	BISB B,(A)
MARKN2:	SPOP B
	SPOP A
	CLZ
	RTS PC
MARKDN:	;SKIP IF NODE (B) IS MARKED
	SPUSH A
	SPUSH B
	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;MARKED?
	BEQ MARKN3	;NO
	BR MARKN2	;YES-SKIP

MARKL:	PUSH A	;MARK LIST
	SPUSH B	;NODE ADDS IN B
	SPUSH C
	JSR	PC,MKLIST
	BR MARKV1

MARKV:	PUSH	A	;MARK VARIABLE
	SPUSH	B	;NODE ADDS IN B
	SPUSH	C
	CLR	A
	MOV	B,C
	JSR	PC,MARKF1	;TREAT POINTER AS A FIRST PTR
MARKV1:	SPOP C
	SPOP B
	POP A
MARKV2:	RTS PC

MARKF:	MOV A,C	;MARK FIRST OF A DATUM (NODE) IN A,,B
MARKF1:	BIT #DSAMFL,FLAGS2
	BEQ MARKF2	;DISK NOT ALMOST FULL
.IFNZ DSK
	TST SPMSWP	;TOP OF PDL SWAPED OUT FOR MARKING?
	BEQ MARKF4	;NO, JUST ERROR OUT
	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK		;ACCESS BEG OF FILE
	SAVE <#SSWPAD,#-SPDLL,SPDLCP>	;INPUT THE BLOCK IT WAS SAVES ON
	$BLKI
.ENDC
MARKF4:	CLR ERPROC
	.IFNZ NDISP
	ADD #2,S	;POP SNLIST OFF S PDL
	.ENDC
	ERROR+NSL
MARKF2:	ASH #-11.,C
	BIC #177741,C	;GET THE DATA TYPE
	JMP	@LMT(C)	;WHICH YOU MIGHT MARK ON

	.IFNZ NDISP
MKSNAP:	JSR	PC,MKDC	;MARK DISPLAY CODE
	.ENDC
MKLIST:	BIT	#7777,B	;IS THIS NODE REALLY HERE?
	BEQ	MARKV2	;NO. RETURN
MKL1:	PUSH	A	;SAVE BUTFIRST OF CURRENT (I.E. PARENT) NODE
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MKL2
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	JSR	PC,MARKBF	;MARK BUTFIRST OF  NEWTHIS NODE
MKL2:	POP A
	RTS PC

MKATOM:		;MARK ATOM CELL BUT NOTHING INSIDE IT
MKINUM:	JMP MARKNI

GCDIE:	ERROR+FBUG

MARKBF:	BIT	#7777,A	;MARK BUTFIRST OF LIST
	BEQ	MARKV2	;AT END OF LIST
MKBF1:	MOV	A,B
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MARKV2	;ALREADY MARKED, QUIT
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	BR	MARKBF	;MARK BUTFIRST OF  NEW NODE

GCOLL:
.GCOLL:	JSR F,ACSAV
	PUSH GNCN
	SPUSH GNCN+2
	SPUSH TMPBLK
.GCOL2:	MOV #GCBITS,A	;GARBAGE COLLECT
	MOV #GCBTL/2-1,B	;CLEAR BIT TABLE
	MOV #1,(A)+	;ALWAYS PROTECT NODE ZERO
.GCOL1:	CLR (A)+
	DEC B
	BGT .GCOL1
;	CLR SSAVEA	;MAKE SURE THIS IS CLEAR
;NOW MARK EVERYTHING POINTED BY OBLIST.  DONT MARK OBLIST NODES YET
	JSR PC,GNOLEI
MKUOBJ:	JSR PC,GNOLE	;GET NEXT UOE PTR
	BEQ MKTPS
	MOV B,C
	JSR PC,.LOADC	;GET THE NODE
	MOV A,C
MKUOE:	BIT #7777,C	;ONE OTHER NODE?
	BEQ MKUOBJ	;NO
	MOV C,B	;YES
	JSR PC,MARKN	;MARK IT
	JSR PC,.LOADC
	MOV A,C
	BIC #7777,A
	CMP #FBIND,A
	BEQ MKFB	;FUNCTION BINDING
	CMP #VBIND,A
	BEQ MKVB	;VARIABLE BINDING
	CMP #ABIND,A
	BEQ MKARR
	CMP #SVBIND,A
	BEQ MKSVB	;SWAPPED VB
.IFNZ BEEF
	CMP #DBIND,A	;DELETED PROC BINDING?
	BEQ MKFB	;MARK LIKE REGULAR PROCEDURE BINGING
.ENDC
	.BUG.		;BUG
MKVB:	JSR PC,MARKV	;MARK VARIABLE
	BR MKUOE
.IFZ BEEF
MKFB:	JSR PC,MARKL
	BR MKUOE
.ENDC
MKSVB:	BR MKUOE
MKARR:	TSTB 5(B)	;IS IT A POINTER ARRAY?
	BNE MKUOE
	MOV B,F		;POINT TO BEG OF ARRAY
	MOV 2(B),-(P)	;PUSH COUNT
	SUB #HEADER,(P)
	ASR (P)
	ADD #HEADER,F
MKAR1:	MOV (F)+,B
	JSR PC,MARKV
	DEC (P)
	BNE MKAR1
	TST (P)+
	BR MKUOE

.IFNZ BEEF
MKFB:	SPUSH C		;POINTS TO NEXT BINDING
	SPUSH E		;USED BY GNOLE
	MOV 5*2(B),F	;THE END OF THE PROCEDURE
	ADD B,F		;MAKE IT ABSOLUTE POINTER
	MOV B,D		;POINTER TO THE START OF THE PROCEDURE
	ADD #HEADER,D	;POINT TO THE FIRST LINE OF THE PROCEDURE
	ADD (D)+,D	;SKIP THE INFO LINE
	MOV D,E		;SHOULD BE POINTER TO START OF NEXT LINE
MKLINE:	CMP D,F		;AT THE END OF THE PROCEDURE?
	BEQ MKFBD	;YES, JUST CONTINUE WITH NEXT BINDING
	BHI MKFBUG	;BUGGY IF WE ARE PAST IT
	ADD (E)+,E	;POINT TO THE START OF THE NEXT LINE
	ADD #4,D	;POINT TO THE START OF THE ELEMENTS FOR THIS LINE
MKNTOK:	CMP D,E		;ARE WE AT THE END OF THIS LINE?
	BEQ MKLINE	;YES, TRY THE NEXT LINE
	BHI MKFBUG	;ERROR IF WE ARE BEYOND THIS POINT
	MOV (D)+,B	;GET THE VARIABLE TO MARK
	MOV B,C		;COPY IT FOR THE TYPE
	JSR PC,MARKF1	;MARK THE FIRST OF IT (THE WHOLE TOKEN)
	BR MKNTOK	;NEXT TOKEN
MKFBD:	SPOP E		;POINTER TO NEXT OBLIST ELEMENT
	SPOP C
	BR MKUOE	;MARK THE NEXT BINDING FOR THIS ATOM
MKFBUG:	.BUG.
.ENDC

	;MARK FROM GCMKL LIST
MKTPS:	MOV #GCMKL,F
MKRNDM:	MOV (F)+,B	;POINTER TO POINTER
	BEQ MKSPDL	;LAST ONE
	MOV (B),B	;REAL NODE ADDRESS
	BEQ MKRNDM	;NOTHING THERE
	BIT #170000,B	;IS TYPE FIELD BLANK
	BEQ MKRND1	;YES, MAKE IT LIKE LIST
	JSR PC,MARKV	;MARK VARIABLE
	BR MKRNDM
MKRND1:	JSR PC,MKL1
	BR MKRNDM

;MARK FROM THE SYSTEM REDEFINED FUNCTION TABLE

MKSPDL:	MOV IS,E
MKSP1:	MOV -(E),B	;GET A S PDL WORD
	CMP E,S	;END OF S PDL?
	BLO MKSP2	;YES
	JSR PC,MARKV	;MARK S PDL WORD
	BR MKSP1
MKSP2:


.IFNZ COLOR

MKPALETTE:		;Mark the palette.
	MOV #PALETTE, E
	MOV #PALMAX, F
MKPALUP:
	MOV (E)+, B
	JSR PC, MARKV
	SOB F, MKPALUP	
.ENDC	


.IFNZ DSK
	TST SPRBAO
	BEQ MKSP4
	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK		;GO TO BEG OF FILE
	SAVE <#SSWPAD,#-SPDLL,SPDLCP>
	$BLKO
	CLR SPMSWP
MKSP8:	ADD #2000,SPMSWP
	CMP SPMSWP,SPRBAO
	BHI MKSP6	;NO
MKSP5:	SAVE <#SSWPAD,#-SPDLL,SPDLCP>
	$BLKI
	MOV #SSWPAD,E
	MOV #SPDLL/2,F
MKSP7:	MOV (E)+,B	;MARK THIS PIECE OF S PDL
	JSR PC,MARKV
	SOB F,MKSP7
	BR MKSP8

MKSP6:	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK
	SAVE <#SSWPAD,#-SPDLL,SPDLCP>
	$BLKI
	CLR SPMSWP
;FALLS THROUGH
.ENDC
;FALLS IN
MKSP4:
;OK, NOW MARK ALL UOE'S THAT POINT TO FUNCION OR VARIABLE BINDING
	JSR PC,GNOLEI
MKOBL:	JSR PC,GNOLE	;GET NEXT UOE PTR IN B
	BEQ MKOBL6	;NONE LEFT
	MOV B,C
	JSR PC,.LOADC	;GET THE PNAME NODE
	MOV B,D
	BIT #7777,A	;DOES IT POINT TO ANYTHING?
	BNE MKOBL2	;YES, MARK IT
	MOV C,B	;NO WAS IT MARKED?
	JSR PC,MARKDN
	BEQ MKOBL3	;NO - LINK IT OUT
	BR MKOBL7	;YES - ALSO MARK PNAME & BUCKET PTR
MKOBL2:	; - MARK THE UOE ETC.
	MOV C,B	;  -THE UOE NODE
	JSR PC,MARKN
MKOBL7:	MOV D,B	;  -THE PNAME LSTR
	JSR PC,MARKL
	MOV GNCN+2,B	;  -THE BUCKET LIST NODE
	JSR PC,MARKN
	BR MKOBL
	;THIS UOE IS NOT MARKED AND POINTS TO NOTHING - LINK IT OUT
MKOBL3:	MOV TMPBLK,C	;GET PTR TO PREDECESSOR NODE
	BNE MKOBL4	;NONE, SO UHCT WAS PRED.
	MOV GNCN,-2(E)	;SO CHANGE IT
	BR MKOBL5
MKOBL4:	MOV GNCN,A	;CHANGE PTR IN PRED NODE
	JSR PC,.STP1
MKOBL5:	MOV C,GNCN+2	;SO GNOLE WILL WORK
	BR MKOBL
MKOBL6:

	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;IF GUY HAS DISPLAY
	BEQ	GCDIS2
	JSR PC,DSGCF		;GCOLL IT, TOO
GCDIS2:
GCDIS:
	.ENDC
;FALLS THROUGH
;FALLS IN
		;OK NOW RETURN ALL IN MARKED NODES
		;RA ADDS OF LIT MAP
		;RB NODE ADDS
		;RC ACTUAL ADDER OF NODE
		;RD BIT MAP
		;RE POINT TO LIST OF FREE STORAGE RECYCLED NODES
		;RF NUMBER NODES LEFT TO CHECK
		;START COLLECTING AT LUNN(LOWEST UNPROTECTED NODE #)
	CLR E
	CLR NNGC
	MOV #NODESP,C	;NODE ZERO ADDRESS
	MOV NODTOP,F
	SUB C,F		;COMPUTE LEGNTH OF NODESP
	ASR F
	ASR F		;COMPUTE NUMBER OF NODES
	CLR B		;NODE ZERO
	MOV #GCBITS,A	;BIT TABLE ADDR
GCRT2A:	MOV (A)+,D	;GET NEXT WORD OF BIT MAP
	SEC
	ROR D

GCRT2:	BCS GCRT3
	CMP B,#LUNN
	BLOS GCRT3
	TST E		;WE HAVE A FREE NODE; IS FIRST FREE FOUND?
	BNE GCRT2B
	MOV B,FREE	;NO, THIS IS IT
	BR GCRT2C	;(NO LAST-FREE TO UPDATE)

GCRT2B:	BIS B,(E)	;ELSE: 	,E		;THIS NODE IS NEW LAST-FREE
GCRT2C:	MOV C,E
	MOV #IDLE,(C)+	;MAKE NEW IDLE NODE, POINTS NOWHERE
	CLR (C)+
	INC NNGC
	BR GCRT4
GCRT3:	CMP (C)+,(C)+
GCRT4:	INC B
	DEC F
	BLE GCRT5
	CLC
	ROR D
	BNE GCRT2
	BR GCRT2A
GCRT5:	MOV NNGC,NNIFSL
;DEBUGGING FEATURE
	BIT #PNNLF,FLAGS2
	BEQ GCRT6
	CPRTXT ^/[NODES LEFT /
	MOV NNGC,A
	JSR PC,PRDN
	PRTXTC ^/ ]/
;
GCRT6:
;	TST FILFLG
;	BEQ GCRT7	;NO
;	MOV #DREADC,E
;	JSR PC,GBITGS	;GET BACK THE BUFFERS
GCRT7:	POP TMPBLK
	SPOP GNCN+2
	SPOP GNCN
	CMP NNIFSL,#200.	;LESS THAN A BLOCK LEFT
	BHIS 1$
	JSR PC,EXNODE		;EXPAND NODE SPACE
1$:	JSR F,ACRES
	SEZ
	RTS PC
	.STITL GET NEXT OBLIST ELEMENT
GNOLE:		;GET NEXT USER OBLIST ELEMENT - PTR
		;INPUT - VIA GNOLEI
		;OUTPUT - PTR TO THIS BUCKET IN B & GNCN
		;	   " " NEXT " " GNCN+2
		;	   " " PRED " " TMPBLK
		;	   IF NO PREV BUCKET, TMPBLK = 0
		;USES E.  SKIPS UNTIL NO UOE PTRS LEFT
	PUSH A
	MOV GNCN,B
	MOV GNCN+2,TMPBLK
GNOLE2:	MOV B,GNCN+2
	BIC #170000,B
	BEQ GNOLE1
	JSR PC,.LOAD	;GET NEXT PTR ON BUCKEN LIST
	MOV A,GNCN
	JMP SRETA
GNOLE1:	CLR TMPBLK
	MOV (E)+,B	;GET NEXT BUCKET LIST
	BGE GNOLE2
	JMP RETA	;DONE
GNOLEI:	MOV #UHCT,E
	CLR GNCN
	RTS PC
.IFZ LSI

EXNODE:	MOV #NODEHP,A	;POINTER TO BLOCK
	JSR PC,EXSPAC	;TRY TO EXPAND NODE SPACE
	BEQ EXNOD1	;FAILED
	ADD #2000,NODTOP
	JSR PC,.GCOLL	;CAUSE GC TO GOBBLE NEW FREE SPACE
EXNOD1:	RTS PC		;LOSE OR WIN

.IFF

;ROUTINE TO EXTEND NODE SPACE; MUST SLIDE ARRAY SPACE DOWN
;TO MAKE ROOM
;CLOBBERS A,B,C
EXNODE:	MOV NODTOP,A	;A_TOP OF NODE SPACE
	ADD #2000,A	;EXTEND IT
	CMP A,#NODESP+40000	;MORE THAN 8K WORDS?
	BHI 1$		;SORRY, CAN'T DO THAT (ONLY 12 BITS OF NODE PTRS)
	MOV ARTOP,B	;B_ARTOP
	ADD #2000,B	;ARRAY SPACE WILL BE SLID UP IF NODESP EXPANDED
	CMP B,PPDTOP	;IS THERE ROOM TO SLIDE?
	BLOS EXNOD1	;YUP, GO ON
1$:	SEZ
	RTS PC
			;NOW, ADVANCE ARRAY SPACE POINTERS
EXNOD1:	MOV AFREE,C	;C_PTR TO NEXT FREE BLOCK
	BEQ EXNOD2	;UNLESS PTR WAS NULL,
	ADD #2000,AFREE	; ADVANCE IT
EXNOD2:	MOV ARYAD,D	;D_PTR TO BLOCK AFTER CURRENT ARRAY
	ADD #2000,ARYAD	;ADVANCE ARYAD (AND NODTOP)
EXNODL:	CMP D,ARTOP	;END OF SPACE?
	BEQ EXNODD	;YES, DONE WITH POINTERS
	BLO 1$		;NO, CONTINUE
	ERROR+BUG
1$:	CMP C,D		;IS NEXT BLOCK FREE?
	BEQ EXNOD3
	ADD #2000,@(D)	;NO, IT'S AN ARRAY. ADJUST PTR TO IT
	ADD 2(D),D	;AND POINT TO NEXT BLOCK
	BR EXNODL
EXNOD3:	ADD 2(D),D	;POINT TO NEXT BLOCK
	MOV (C),E	;POINT TO NEXT FREE BLOCK
	BEQ EXNODL	;IF THERE WAS NONE, PROCEED.
	ADD #2000,C	;ELSE, ADVANCE OLD BLOCK'S FWD PTR
	ADD #2000,4(E)	;AND NEW BLK'S BK PTR
	MOV E,C		;OLD IS NEW
	BR EXNODL

EXNODD:	MOV B,ARTOP	;SHIFTED BOUND
	MOV B,A
	SUB ARYAD,A
	ASR A		;# OF WORDS IN ARRAY SPACE
	BEQ EXNOD4
EXNDL1:	MOV -2002(B),-(B)	;SLIDE ARRAY SPACE
	SOB A,EXNDL1
EXNOD4:	JSR PC,.GCOLL	;CAUSE GC TO GOBBLE NEW FREE SPACE
	RTS PC
.ENDC
.IFNZ LSI
;SSYTEM CHECKING CODE

;ROUTINE TO XOR ALL PURE CODE
XORPUR:	MOV #PURES,A
	MOV #<PUREE-PURES>/2,B	;COUNT OF PURE WORDS
	CLR F		;WHERE THE XOR IS KEPT
1$:	MOV (A)+,C	;GET A WORD
	XOR C,F		;XOR IT IN
	SOB B,1$
	RTS PC

SETXOR:	JSR PC,XORPUR
	MOV F,SYSXOR	;SAVE THE XOR OF THE SYSTEM
	RTS PC

CHKXOR:	JSR PC,XORPUR
	MOV SYSXOR,C
	XOR F,C	
	RTS PC

;XOR ADDRESS+2 IN FOR EVERY WORD THAT HAS BIT SET
;BIT NUMBER IN D, RETURNS WITH TABLE ADDRESS IN E
BITXOR:	MOV #PURES,A
	MOV #<PUREE-PURES>/2,B
	MOV #1,C
	ASH D,C
	MOV D,E
	ASL E
	ADD #SYSTAB,E
	CLR F
1$:	BIT C,(A)+	;TEST FOR BIT IN C
	BEQ 2$
	XOR A,F
2$:	SOB B,1$
	RTS PC

;SET BIT XOR FOR BIT (D)
SETBIT:	JSR PC,BITXOR
	MOV F,(E)
	RTS PC

;CHECK BIT XOR FOR BIT (D)
CHKBIT:	JSR PC,BITXOR
	MOV (E),A
	XOR A,F
	RTS PC

;SETUP TABLES FOR FIRST TIME, OR AFTER A PATCH
SETTAB:	JSR PC,SETXOR	;DO THE XOR
	MOV #15.,D	;START AT THE TOP
1$:	JSR PC,SETBIT
	DEC D
	BGE 1$
	MOV PC,XORFLG	;INDICATE THAT SYSTEM HAS BEEN XORED
	SEZ		;IF CALLED BY USER
	RTS PC

;CHECK THE WORLD
CHKTAB:	JSR PC,CHKXOR
	BEQ XRTSPC
	SAVE #0		;ADDRESS+2 OF CHANGED WORD
	SAVE C		;THESE ARE THE BITS THAT CHANGED IN THE WORD
	MOV #15.,D
CHKTA1:	JSR PC,CHKBIT	;CHECK THIS BIT
	BEQ CHKTA2		;THIS BIT SHOULD BE RIGHT
	BIT C,(P)	;THIS BIT SHOULD BE WRONG
	BEQ MULERR	;MULTIPLE ERROR
CHKTA4:	TST 2(P)	;HAVE WE ALREADY GOT AN ADDRESS?
	BNE CHKTA3		;YUP
	MOV F,2(P)	;THIS IS THE ERROR ADDRESS
CHKTA3:	CMP F,2(P)	;SAME ERROR ADDRESS?
	BNE MULERR	;NOPE, MULTIPLE WORD ERROR
CHKTA5:	DEC D
	BGE CHKTA1
	REST <A,B>	;A GETS WRONG BITS, B GETS ADDRESS+2	
	XOR A,-(B)	;FIX THE ERROR
	MOV A,WRNGBT	;SAVE FOR LATER
	MOV B,WRNGAD
	PRTXT <MEM ERR CORRECTED>
	INC WRNGCN	;ONE MORE CORRECTED
	RTS PC

CHKTA2:	BIT C,(P)
	BNE MULERR	;THIS BIT SHOULD BE RIGHT, IS WRONG
	BR CHKTA5

MULERR:	PRTXT <WARNING, MULTIPLE MEMORY ERROR DETECTED, IGNORING>
	MOV PC,IGNERR
	CMP (P)+,(P)+
XRTSPC:	RTS PC

SYSCHK:	TST IGNERR	;TOO MANY ERRORS?
	BNE SYSCH1
	JSR F,ACSAV
	TST XORFLG	;HAS SYS BEEN XORED?
	BNE 1$
	JSR PC,SETTAB	;XOR THE SYSTEM
1$:	JSR PC,CHKTAB	;CHECK THE SYSTEM
	JSR F,ACRES		
SYSCH1:	SEZ
	RTS PC

;INCREMENTAL CHECK
INCHK:	TST IGNERR	;IGNOREING ERRORS?
	BNE INCHK3	;THEN DON'T LOOK FOR ANY
	JSR F,ACSAV
	MOV INCNT,B	;GET OLD LEFTOVER COUNT
	BEQ INCHK1	;FINISHED LAST CHECK, RESTART
	MOV INADDR,A	;OLD ADDRESS
	MOV INXOR,F	;OLD XOR
	SUB #500.,B
	BLT 1$
	MOV B,INCNT
	MOV #500.,B
	BR 2$
1$:	ADD #500.,B	;THE REAL COUNT LEFT OVER
	CLR INCNT	;FLAG THAT WE WILL BE FINISHED THIS CHECK
2$:	MOV (A)+,C	;GET A WORD
	XOR C,F		;PUT INTO CHECKSUM
	SOB B,2$
	TST INCNT	;DONE?
	BNE INCHK2	;NOPE, SAVE FOR NEXT TIME
	TST F		;SHOULD BE ZERO
	BEQ INCHK1	;YUP, WIN
	JSR PC,SYSCHK	;CHECK FOR REAL
INCHK1:	MOV #PURES,A
	MOV #<PUREE-PURES>/2,INCNT
	MOV SYSXOR,F
INCHK2:	MOV A,INADDR
	MOV F,INXOR
	JSR F,ACRES
INCHK3:	RTS PC

.ENDC
.STITLE SYSTEM OBLIST SORT
PUREE==.
;KLUDEGY SELF MODIFIYING CODE
SORT:	.IFNZ LSI
	MOV #207,SORT	;CLOBBER YOURSELF
STORAG=.		;THE REST OF THE ROUTINE IS USED FOR FREE STORAGE
.ENDC
	MOV #SOBLST+2,A	;POINTER TO START AT
	MOV #SOBLSU,B	;PLACE TO FINISH
	MOV PC,F	;SET "SOMETHING MOVED" FLAG
SORTUG:	TST F	;DID SOMETHING GET MOVED LAST PASS?
	BEQ SORTDN	;NO, WE ARE DONE
	CLR F	;NOTHING SO FAR THIS PASS
	MOV A,C	;POINTER INTO TABLE
SORTU:	MOV (C)+,D	;START OF SORT UP
	MOV (C),E	;THINGS TO SORT
	ADD #4+SOBLST,D	;GET TO STRING
	ADD #4+SOBLST,E	;FOR BOTH
SORTU3:	CMPB (D),(E)	;COMPARE THE WORDS
	BLT SORTU2	;IN ORDER, GO TO NEXT PAIR
	BEQ SORTU1	;SAME, CHECK NEXT WORD
	INC F	;HAVE TO SWITHC THEM
	MOV -(C),D
	MOV 2(C),(C)+
	MOV D,(C)
SORTU2:	CMP C,B	;ARE WE AT END?
	BNE SORTU	;NO, CONTINUE
	TST -(B)	;YES, NEXT TIME NOT SO FAR
	BR SORTDG	;GO TO DOWNWARD SORT
SORTU1:	TSTB (D)+
	BNE 1$	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
1$:	TSTB (E)+
	BNE 2$
	MOV #ZERO,E
2$:	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTU3	;OK, CONTINUE
	BPT	;BARF, THEY'RE EQUAL????
	BR SORTU3

SORTDG:	TST F	;DID WE MOVE ANY ON THE UP PASS?
	BEQ SORTDN	;NO,DONE
	CLR F	;CLEAR FLAG
	MOV B,C	;SET POINTER
SORTD:	MOV (C),D
	MOV -(C),E
	ADD #4+SOBLST,D
	ADD #4+SOBLST,E
SORTD3:	CMPB (D),(E)
	BGT SORTD2
	BEQ SORTD1
	INC F
	MOV (C)+,D
	MOV (C),-(C)
	MOV D,2(C)
SORTD2:	CMP C,A
	BNE SORTD
	TST (A)+
	BR SORTUG
SORTD1:	TSTB (D)+
	BNE 1$	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
1$:	TSTB (E)+
	BNE 2$
	MOV #ZERO,E
2$:	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTD3
	BPT
	BR SORTD3

SORTDN:	RTS PC
.IIF P2,PAD ^\CODEND=\,\.
.IIF NZ LSI, .=HICORE
LOGEND=.
.IIF P2,PAD ^\LOGEND=\,\.
	.END START
