	.TITLE PDP11 LOGO

	FOO==VERNF
	FOO==ASWFOO
	VERN==%FNAM2
	FOO==VERNF
	FOO==ASWFOO
	.STITL CONFIGURATION PARAMETERS

.IF1
	.PRINT /0=>FULL 1=>NO DEBUG 2=>QUERY
ASSSW=/
	.TTYMAC FLAG
	ASSSW==FLAG
	.ENDM
ASWFOO==ASSSW
	.PRINT /0=AI 1=GUY 2=SIMPLE
DEVSW=/
	.TTYMAC	FLAG
	DEVSW==FLAG
	.ENDM
	.IFL	DEVSW
	DEVSW==0
	.ENDC
	.IFG	DEVSW-2
	DEVSW==0
	.ENDC
	.IFZ DEVSW
	AI==1
	GUY==0
	SIMP==0
	.ENDC
	.IFZ <DEVSW-1>
	AI==0
	GUY==1
	SIMP==0
	.ENDC
	.IFZ <DEVSW-2>
	AI==0
	GUY==0
	SIMP==1
	.ENDC

NEWERS==1
	.IFZ ASSSW
		DEBUG==1
	.IFZ DEVSW
		MNUSRS==10
		MNSLTS==1
	.ENDC
	.IFZ <DEVSW-1>
	MNUSRS==11
	MNSLTS==1
	.ENDC
	.IFZ <DEVSW-2>
	MNUSRS==1
	MNSLTS==1
	.ENDC
	.ENDC

	.IFZ <ASSSW-1>
		DEBUG==0
	.IFZ DEVSW
		MNUSRS==7
		MNSLTS==1
	.ENDC
	.IFZ <DEVSW-1>
	MNUSRS==11
	MNSLTS==1
	.ENDC
	.IFZ <DEVSW-2>
	MNUSRS==1
	MNSLTS==1
	.ENDC
	.ENDC

	.IFZ <ASSSW-2>
		.MACR SETFLG FLG
		.PRINT /FLG=/
		.TTYMAC FLAG
		FLG==FLAG
		.ENDM
		.ENDM
	
		SETFLG NEWERS
		SETFLG DEBUG
		SETFLG MNUSRS
		SETFLG MNSLTS
	.ENDC

.ENDC

	.MACR FOR FLG
	.XLIST
	.IFNZ FLG
	.LIST
	.ENDM

	.MACR ENDC FLG
	.XLIST
	.IFZ FLG
	.LIST
	.ENDC
	.LIST
	.ENDM

	.MACR JIGGLE
	.IFNZ DEBUG
	JSR PC,JIGLR
	.ENDC
	.ENDM
	.STITL SYSTEM PARAMETERS

A=%0
B=%1
C=%2
D=%3
E=%4
F=%5
U=%5
P=%6
SP=%6
PC=%7

EOFCHR==3

ERROR==TRAP

SKPRET==EMT

.BUG.==ERROR+BUG

.XCREF A,B,C,D,E,F,U,P,SP,PC,S
.XCREF OBADD1,OBADD2,OBSTRT,OBX0,OBX1,OBX2
.XCREF ERMNO,NNUMF
.XCREF TEXT,SPOP,SPUSH,POP,PUSH,OLE,ENDER,BEGER,ERMM
.XCREF Z,ZED,ZPLUS,ZEPT
	.STITL MACROS

	.MACR PUSH AA
	MOV AA,-(P)
	JSR PC,PPUSHT
	.ENDM

	.MACR POP AA
	MOV (P)+,AA
	JSR PC,PPOPT
	.ENDM

	.MACR PUSHS AA
	JSR PC,SPUSHT
	MOV AA,@S
	.ENDM

	.MACR POPS AA
	MOV @S,AA
	JSR PC,SPOPT
	.ENDM

	.MACR SPUSH AA
	MOV AA,-(P)
	.ENDM

	.MACR SPOP AA
	MOV (P)+,AA
	.ENDM

	.MACR SPUSHS AA
	SUB #2,S
	MOV AA,@S
	.ENDM

	.MACR SPOPS AA
	MOV @S,AA
	ADD #2,S
	.ENDM

.MACR	TEXT AA
	.ASCII ÁA‰;DON'T TRY TO INCLUDE RUBOUTS IN TEXT
	.BYTE 0
	.EVEN
.ENDM

.MACR	PRTXT AA
	JSR	A,ERTAS
	TEXT ^\AA\
.ENDM

.MACR	CPRTXT	AA
	JSR	A,ERTAS
	.BYTE	15
	TEXT ^\AA\
.ENDM

.MACR	BPRTXT X
	JSR	A,ERTAS
	.BYTE	7,7,15
	TEXT	^\X\
.ENDM

.MACR	PRTXTC	AA
	JSR	A,ERTAS
	.ASCII	\AA\
	.BYTE	15,0
	.EVEN
.ENDM

.MACR PAD A,B
	.PRINT \A B
\
.ENDM

.MACR PRCR
	JSR PC,.CRLF
.ENDM

.MACR SPACE
	JSR PC,.SPACE
.ENDM

.MACR SPREND
	SPOP	USER
	SPOP	A
.ENDM

.MACR REPT1 A,B
	.REPT A
	B
	.ENDR
.ENDM

.MACR REPT2 A,B,C
	.REPT A
	B
	C
	.ENDR
.ENDM

.MACR SDPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
.ENDC
.ENDM

.MACR SDPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
.ENDC
.ENDM

.MACR VERR
.IFLE .-.VERR-127.
	BVS	.VERR
.ENDC
.IFG .-.VERR-127.
	BVC	.+4
	.VERR==.
	ERROR+RTB
.ENDC
.ENDM

.MACR DPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPCLR HIGH,LOW
	CLR	HIGH
	CLR	LOW
.ENDM

.MACR DPINC HIGH,LOW
	DPADD ,#1,HIGH,LOW
.ENDM

.MACR DPDEC HIGH,LOW
	DPSUB ,#1,HIGH,LOW
.ENDM

.MACR DPNEG HIGH,LOW
	NEG LOW
	ADC HIGH
	NEG HIGH
.ENDM

.MACR NOP NUM
	.IFG NUM
	BR .+<NUM*2>
	NOP <NUM-1>
	.ENDC
.ENDM

.MACR EXCH LOC1,LOC2
	MOV	LOC1,EXCH1
	MOV	LOC2,LOC1
	MOV	EXCH1,LOC2
.ENDM

.MACR	ZED
	Z==0
.ENDM

.MACR	ZPLUS
	Z==Z+1
.ENDM

.MACR	ZEPT A,B
	ZED
	.REPT	A
	B
	ZPLUS
	.ENDR
.ENDM

.MACR	CONS	A,B,C
	A'B'C
.ENDM

.MACR CONC6 A,B,C,D,E,F
	A'B'C'D'E'F
.ENDM

.MACR	DINFO DEV,NUM,DTLST
	CONS N,DEV,<==NUM>
	TY==0
	TB==0
	SPC==0
	ZED
	.IRP	A,DTLST
	CONC6	DEV,\Z,<DT==>,A
	ZPLUS
		.IFZ	<A-TYDT>*<A-MODT>
		TY==TY+1
		.ENDC
		.IFZ	<A-TBDT>*<A-TBMDT>
		TB==TB+1
		.ENDC
		.IFZ	A-SPDT
		SPC==SPC+1
		.ENDC
	.ENDM
	CONS N,DEV,TY==TY
	CONS N,DEV,TB==TB
	CONS N,DEV,SPEC==SPC
.ENDM

.MACR	TBINFO NUM,DEV,LDLST
	CONS DEV,TBN==NFTBOX+<2*NUM>
	CONC6 TB,NUM,SND=,DEV,SND
	CONC6 TB,NUM,TB==,DEV,TB
	ZED
	.IRP	A,LDLST
		CONC6 A,SND=TB,NUM,SND
		CONS A,<TBN==DEV>,TBN
	ZPLUS
	.ENDM
	.MACR TB'NUM'LTB
		.IRP A,LDLST
		A
		.ENDM
	.ENDM
	CONS NTB,NUM,LD==Z
.ENDM

TYDT==1	;TTY
TBDT==2	;THORTON BOX
SPDT==3	;SPECIAL
MODT==4	;TTY MODEM
TBMDT==5	;THORTON BOX MODEM.STITL	DEVICE CONFIGURATION

.IFZ	DEVSW		;AI DEVICES
	NDISP==4
	CLKFRQ==60.
	NTBOX==1
	NTUR==3	;KLUGE (INCLUDES PLOTTER)
	NMBX==1
	NTY==1
	DINFO	DC,2,<<TBDT,MODT>>
		.MACR DCITB
		.WORD 111,113,100,103
		.ENDM
	DINFO	KL,0
	NDM==1
		NDMTY==7
		NDMTB==0
		NDMSP==0
	DINFO	DP,0,
	DINFO	DN,0,
	TBINFO	0,DC0,<<TU0,TU1,MB0,TU2>>
.ENDC
.IFZ DEVSW-1			;GUY
	NDISP==0
	CLKFRQ==60.
	NTBOX==1
	NTUR==2
	NMBX==1
	NTY==1
	DINFO DC,5,<<MODT,MODT,MODT,MODT,TBDT>>
		.MACR DCITB
		.WORD  100,103,100,103,120,123,120,123,131,133
		.ENDM
	DINFO KL,4,<<TYDT,TYDT,TYDT,TYDT>>
	DINFO DM,0,
	DINFO DP,0,
	DINFO DN,0,
	TBINFO 0,DC4,<<TU0,TU1,MB0>>
.ENDC
.IFZ	DEVSW-2
		NDISP==0
	CLKFRQ==60.
	NTBOX==0
	NTUR==0
	NMBX==0
	NTY==1
	DINFO DC,0,
	DINFO KL,0,
	DINFO DM,0,
	DINFO DP,0,
	DINFO DN,0,
.ENDC

	NLDEV==NTUR+NMBX
	ZEPT NTUR,<
	CONS TU,\Z,==NFTUR+<2*Z>
>
	ZEPT NMBX,<
	CONS MB,\Z,==NFMBX+<2*Z>
>

	NFTY==0
	NFDCTY==2*NTY
	NFKLTY==2*<NTY+NDCTY>
	NFDPTY==2*<NTY+NKLTY+NDCTY>
	NFDMTY==2*<NTY+NKLTY+NDCTY+NDPTY>
	NTTY==NTY+NKLTY+NDCTY+NDPTY+NDMTY
	NFTBOX==2*NTTY
	NFTUR==2*<NTTY+NTBOX>
	NFLDEV==NFTUR
	NFMBX==2*<NTTY+NTBOX+NTUR>
	NTYDV==NTTY+NTBOX+NLDEV

	MBDN==NFMBX	;NGKLUGE
	NFPLOT==NFTUR+4	;MORE KLUGE

;CONSOLE SWITCHES
SWB=177570	;CONSOLE SWITCH DATA
;CONSOLE TELETYPE
;BREAK LEVEL 4
TKBRV=60	;CONSOLE KEYBOARD BREAK VECTOR
TKS=177560	;CONSOLE KEYBOARD STATUS
TKB=177562	;CONSOLE KEYBOARD DATA
TPBRV=64	;CONSOLE PRINTER BREAK VECTOR
TPS=177564	;CONSOLE PRINTER STATUS
TPB=177566	;CONSOLE PRINTER DATA
;PROGRAMMABLE CLOCK
;BREAK LEVEL 6
PCBRV=104	;PROGRAMMABLE CLOCK BREAK VECTOR
PCS=172540	;PROGRAMMABLE CLOCK STATUS
PCSTBF=172542	;PROGRAMMABLE CLOCK SET BUFFER
PCCNT=172544	;PROGRAMMABLE CLOCK COUNTER
;RK05 DISK
;BREAK LEVEL 5
RKBRV=220
RKDS=177400
RKER=177402
RKCS=177404
RKWC=177406
RKBA=177410
RKDA=177412
;RF11/RS11 DISK
;BREAK LEVEL 5
DSKBRV=204	;DISK BREAK VECTOR
DSKS=177460	;DISK STATUS REGISTER
DSKDBR=177472	;DISK DATA REGISTER
DSKWC=177462	;DISK WORD COUNT
DSKCA=177464	;DISK CURRENT ADDRESS
DSKA=177466	;DISK ADDRESS
DSKAE=177470	;DISK EXTENDED ADDRESS
DSKMT=177474	;DISK MAINTENCE(WELL...)
DSKSG=177476	;DISK SEGMENT
;PAPER TAPE PUNCH
;BREAK LEVEL 4
PPBRV=74
PPB=177556
PPS=177554
;PAPER TAPE READER
;BREAK LEVEL 4
PRBRV=70
PRB=177552
PRS=177550
;DR11 INTERFACE
;BREAK LEVEL 5
DRBRV=110	;INTERUPT A
DRBRVB=114	;INTERUPT B
DRS=177520
DROB=177522
DRIB=177524
;LINE CLOCK
;BREAK LEVEL 6
LKBRV=100
LKS=177546
;TK DISPLAY
;BREAK LEVEL 7?
DISBRV=270	;DISPLAY BREAK VECTOR
NGCSR=164040	;DISPLAY CONTROL AND STATUS REGISTER
NGREL=164042	;DISPLAY RELOCATION REGISTER

;POWER FAIL
PFBRV=24
;BUS ERRORS
BEBRV=4
BPT=3
;TRAPS
TRPBRV=34
EMTBRV=30
IOTBRV=20
BPTBRV=14
PWFBRV=24
;EAE REGISTERS
DIVIDE=177300
AC=177302
MQ=177304
MULTIP=177306
SR=177310
EAESR==177311
NORMAL=177312
LGS=177314
ARS=177316
SIPRBT==2
MQZ==10
;PSSESOR STATUS
PS=177776

	.STITL ALLOCATION PARAMETERS

SYPDLL==100
DSECLN==400
PPDLL==600
SPDLL==600
PDSLOP==100
PDSWOP==374
MAXARG==32.
.IF1
.IFG MAXARG-<SPDLL-PDSWOP>/4
.ERROR \CHANGE MAXARG OR SPDLL SIZE
\
.ENDC
.ENDC
DBUFL==400
DDBUFL==400
	.IFNZ AI
	FDSCSZ==20
	.ENDC
	.IFNZ GUY
	FDSCSZ==40
	.ENDC
	FDSCMS==FDSCSZ-1	;SECTOR MASK

DTIBFL==2000
DEDBFL==2000

DWRTEC==103
DREADC==105
DWRTCC==107

FRTRCF==1
SWTRCF==2
SPTRCF==4
GCTRCF==10

		;200 BIT MEANS NEVER RUN
FRSCED==1	;FLUSHED DUE TO SCHEDULEING
FRJIG==2	;JIGGLIFING
FRDSKW==3	;HANGING ON DISK
FRTYIW==4	;HANGING ON TYI OF CHAR
FRTYOW==5	;HANGING ON FULL TYO BUFFER
FRRAND==6	;HANGING FOR "UNKNOWN" REASON
FRNEWU==7	;HANGING BECAUSE HAVE NOT YET BEEN INITIALIZED
FRTYIH==210	;HANGING ON LINE INPUT
FREDW==11	;HANGING ON EDIT TYO
FRTURW==12	;HARE (SEE AESOP)
	;NODE TYPES
SFUN==000000
INFIX==10000
UFUN==20000
UVAR==30000
IDLE==40000
;THE FOLLOWING TYPES ARE NEEDED IN THIS ORDER BY THE CONVERT ROUTINES
SSTR==70000	;NOT VALID TOKEN TYPE
SNP==100000
ATOM==110000
SNUM==120000	;NOT A VALID TOKEN TYPE
LNUM==130000
INUM==LNUM	;INTEGER NUMBER
LSTR==140000
RNUM==150000
LIST==170000
SENT==LIST
;END OF ORDER

	;BINDING TYPES
FBIND==20000
VBIND==30000
SVBIND==130000	;SWAPPED OUT  VARIABLE BINDING


	;SOE FLAGS SEE OLE MACRO STUFF
VNAF==2000

	;READ FLAGS SEE DTBL:
DOTF==400	;IN LEFT HALF
	;EVAL FLAGS - PUSHED BY PEVAL
PTLPF==1	;PREVIOUS TOKEN WAS LEFT PAREN
RTF==2	;REPEAT TOKEN
CRF==4	;CURRENT TOKEN IS CR
EDITF==10	;EDIT FLAG
TOF==20	;TO FLAG
IFF==40	;IF FLAG
TSTFLG==100	;TEST FLAG FOR TEST, IFTRUE AND IFFALSE
SPDF==200	;SKIP PROC DEF. FLAG
TPTF==400	;THIS PROCEDURE TRACED FLAG	;MUST BE IN LEFT HALF
EDTIF==1000	;EDIT TITLE FLAG
BRKF==2000	;BREAK MODE FLAG
ERRF==4000	;ERROR FLAG
ONF==10000	;ORT/NORT FLAG

	;EVAL FLAGS2 - NOT PUSHED
TESTF==1
TRACEF==2
PQF==4		;PRINT QUOTE FLAG - FOR PRSTR
DPQF==10	;DONT " " "
MMF==20	;MULTIPLE MAKE FLAG
SSF==40	;SPECIAL STATUS FLAG
PADERF==100	;PRINT ADDRESS OF ERROR
MGCF==200	;MANY G. C.'S FLAG
PNNLF==400	;PRINT NO. NODES LEFT
DSAMFL==1000	;DISK ALMOST FULL
PPNAIF==2000	;P PDL NOT ALL THE WAY IN
SPNAIF==4000	;S PDL NOT ALL THE WAY IN
HERRF==10000	;HARD ERROR

	;TEMP FLAGS IN TFLAGS
TF6==1
RBRKF==2	;BREAK FLAG - FOR ROUTINE THAT CALLS RDSTR
TF7==4
TF1==100	
TF2==200
TF3==400
TF4==10000
TF5==20000

	;FLAGS IN LEFT HALF OF 1ST NODE OF SWAPPED PROC LIST
; TPTF==400	DEFINED ABOVE
NBN==40	;# BUFFER NODES - IF FREE NODES < THIS, == NO STG LEFT


;DISPLAY COMMANDS
ADDX==150000
ADDY==144000
ADDXY==ADDX!ADDY
DPUSHJ==100000
DPOP==140200
DPOPJ==140100
DSTOP==140400
DRSTXY==143000	;RESET X AND Y TO 0
DINC==40000

TURSIZ==6	;THE SIZE OF THE TURTLE

;FLAGS USED FOR DFLAGS
PENUF==1
HIDETF==4
TURTF==10
TEMF==20
DISPF==40
WRAPF==100


TKRUN==4000
TKGO==10000
TKSTOP==20000
.STITL TRAP VECTORS


;TRAP VECTORS
;UNUSED VECTORS
.=0
	BPT	;DIE ON JUMP TO ZERO
GUNU==.
	-1	;USER TO GUN DOWN

	REPT2 77,.+2,IOT	;GO TO 2ND WORD OF VECTOR AND DIE

	.=TRPBRV
	ERRBK	;TRAP IS USED FOR ERRORS
	0

	.=TKBRV
	TKBRK	;CONSOLE TTY KEYBOARD
	200	;IS ON BR4

	.=TPBRV
	TPBRK	;CONSOLE TTY PRINTER
	200	;IS ON BR4

	.=LKBRV
	CLKBRK
	300

	.=PCBRV
	CLKBRK	;PROGRAMMABLE CLOCK
	300	;IS ON BR6

	.=DSKBRV
	DSKBRK	;FIXED HEAD DISK
	300	;IS ON BR5, INT ROUTINE RUNS ON LEVEL 6

	.=RKBRV
	RKBRK
	300

	.=DISBRV
	DISBRK	;DISPLAY
	240	;???????????

	.=IOTBRV
	IOTBRK
	340

	.=EMTBRV
	EMTBK
	340

	.=PRBRV
	PRBRK
	200

	.=PPBRV
	PPBRK
	200

	.=PFBRV
	PWRDWB
	340
	.STITL	FLOATING TRAP VECTORS & DEVICE INFO

	.=300	;START OF FLOATING VECTORS
;DC11 (BR5)
ZEPT	NDC,<
	CONS DC,\Z,<RS=174000+<Z*10>>	;RCV STATUS REG
	CONS DC,\Z,<RB=174002+<Z*10>>	;RCV BUFFER
	CONS DC,\Z,<TS=174004+<Z*10>>	;TRANSMIT STATUS
	CONS DC,\Z,<TB=174006+<Z*10>>	;TRANS BUF

	CONS DC,\Z,RV=.	;RCV VECTOR
	CONS DC,\Z,TV=.+4	;TRANS VECTOR
	CONS DC,\Z,RK
	240
	CONS DC,\Z,TK
	240
>
;KL11  (BR4)
ZEPT	NKL,<
	CONS KL,\Z,<RS=176500+<Z*10>>	;RCV STATUS REG
	CONS KL,\Z,<RB=176502+<Z*10>>	;RCV BUFFER
	CONS KL,\Z,<TS=176504+<Z*10>>	;RCV BUFFER
	CONS KL,\Z,<TB=176506+<Z*10>>	;TRANS BUF

	CONS KL,\Z,RV=.	;RCV VECTOR
	CONS KL,\Z,TV=.+4	;TRANS VECTOR
	CONS KL,\Z,RK
	200
	CONS KL,\Z,TK
	200
>
;DP11  (BR5)
ZEPT	NDP,<
	CONS DP,\Z,<RS=174770-<Z*10>>	;RCV STATUS REG
	CONS DP,\Z,<RB=174772-<Z*10>>	;RCV BUFFER
	CONS DP,\Z,<SR=174773-<Z*10>>	;SYNCH REGISTER
	CONS DP,\Z,<TS=174774-<Z*10>>	;TRANSMIT STATUS
	CONS DP,\Z,<TB=174776-<Z*10>>	;TRANS BUF
	CONS DP,\Z,<ESR=174777-<Z*10>>	;EXTENDED SYNCH REGISTER

	CONS DP,\Z,RV=.	;RCV VECTOR
	CONS DP,\Z,TV=.+4	;TRANS VECTOR
	CONS DP,\Z,RK
	240
	CONS DP,\Z,TK
	240
>
;DM11 (BR5)
ZEPT	NDM,<
	CONS DM,\Z,<CSR=175000+<Z*10>>	;CONTROL STATUS REG
	CONS DM,\Z,<BAR=175002+<Z*10>>	;BUFFER ACTIVE REGISTER
	CONS DM,\Z,<BCR=175004+<Z*10>>	;BREAK CONTROL REGISTER
	CONS DM,\Z,<TBR=175006+<Z*10>>	;TABLE BASE REGISTER

	CONS DM,\Z,RV=.	;RCV VECTOR
	CONS DM,\Z,TV=.+4	;TRANS VECTOR
	CONS DM,\Z,RK
	240
	CONS DM,\Z,TK
	240
>
	.STITL SYSTEM VARIABLES(ONE COPY)


	.=400
	JMP START
	.=.+SYPDLL	;SYSTEM PDL
SJPDLP:SPDLP:	.	;SYSTEM PDL POINTER
LVERNF:	VERNF
PAT:
PATCH:	.=.+400	;PATCH AREA
PATEND=1400
.IFNZ	NDMTY
.=1400
	DMCA=.-NFDMTY
	.=.+40	;DM11 CURRENT ADDRESS
	DMWC=.-NFDMTY
	.=.+40	;DM11 -BYTE COUNT
	.=.+40	;DM11 BIT ASSEMBLY TABLE
DM0RK:	.=.+40	;UNUSED -- RCV INT HALT
DMTT:	.=.+200	;DM11 TUMBLE TABLE
.ENDC
RUG=2000
.=2400

DISBRK:	HALT
	ZEPT NDC,<
	CONC6 <
	.IFZ DC>,\Z,<DT-SPDT
CONS DC,\Z,RK:
	0
CONS DC,\Z,TK:
	0
	.ENDC
>>
	ZEPT NKL,<
	CONC6 <
	.IFZ KL>,\Z,<DT-SPDT
CONS KL,\Z,RK:
	0
CONS KL,\Z,TK:
	0
	.ENDC
>>
	.STITL SYSTEM OBLIST

VARIABLE==4	;FOR VARIABLE NUMBER OF ARGUMENTS
YINFIX==20	;"YES INFIX" FLAG FOR OLE

;SOE FIELDS		1.==RIGHT BYTE (EVEN ADDR) 2.==LEFT BYTE
	;		1.1==RIGHT BIT  2.8==LEFT BIT
	;1.1-1.8 UNUSED
	;2.1-2.2 "STANDARD" NO. OF INPUT ARGS
	;2.3 VNAF 1==CAN TAKE "ANY" NO. OF ARGS
	;2.5 INFIX 1==THIS IS AN INFIX PROCEDURE
	;2.6-2.8 PRECEDENCE

	.MACR NGPTWO A
	.XLIST
	NGP2=NGP2*2
	FOO==A
	.IFLE NGP2-FOO
	NGPTWO A
	.ENDC
	.LIST
	.ENDM

;****************************************************
;MACRO TO DEFINE SYSTEM OBLIST ELEMENTS
;THE PARAMETERS ARE:
;1)	THE PRINT NAME
;2)	THE NAME OF THE POINTER TO THE OBLIST ELEMENT.
;3)	THE ADDRESS OF THE PROGRAM
;4)	THE PRECEDENCE.  A NUMBER FROM 0-7
;5)	THE NUMBER OF ARGUMENTS, AND THE SYMBOL "VARIABLE"
;	IF IT CAN ALSO TAKE A VARIABLE NUMBER OF ARGUMENTS
;7)	THE SYMBOL "YINFIX" IF THIS IS AN INFIX OPERATOR



.MACR OLE PNAME,OBNAME,ADDR,PRECED,NUMARG,QINFIX,ASSX
	.XLIST
	.IIF B ASSX,.IFZ 0
	.IIF NB ASSX,.IFNZ ASSX
	OBX0=OBSTRT-.	;CHECK TO SEE THAT THE OBLIST DOESN'T
			;OVERWRITE THE OBLIST ELEMENTS
	.IF2
	.IFNDF OBNAME
	OBNAME=0	;TO AVOID UNDEFINED SYMBOL ERROR
	.ENDC
	.ENDC
	.IFG	OBX0
	OBADD2	;POINTER TO OBLIST ELEMENT
	OBADD1=.
	.=OBADD2
	.IFB OBNAME
	.XCREF $'PNAME
	$'PNAME=.
	.ENDC
	.IFNB OBNAME
	$'OBNAME=.
	.ENDC


	.BYTE 0
	OBX1=NUMARG+0
	OBX2=PRECED+0*40
	.BYTE QINFIX+OBX1+OBX2

	.IFB ADDR
	PNAME
	.ENDC
	.IFNB ADDR
	ADDR+0
	.ENDC

	TEXT ^@PNAME@

	OBADD2=.
	.=OBADD1
	.ENDC

	.IFLE	OBX0
	.LIST
.ERR	NUMOBS IS LESS THAN THE NUMBER OF SYSTEM OBLIST ELEMENTS.
	.XLIST
	.ENDC
	.ENDC
	.LIST
.ENDM
	.MACR CDM A
A==<.-SOBLSU>/2
	.ENDM

.MACR ABRV PNAME,OBNAME,ASSX
	.IIF B ASSX,.IFZ 0
	.IIF NB ASSX,.IFNZ ASSX
	OBX0=OBSTRT-.
	.IFG OBX0
	OBADD2
	OBADD1=.
	.=OBADD2
	1
	OBNAME
	TEXT ^\PNAME\
	OBADD2=.
	.=OBADD1
	.ENDC
	.ENDC
.ENDM
;THE SYSTEM OBLIST
	;ADD ITEMS (EXCEPT FOR SPECIAL CHAR ITEMS) ALPHABETICALLY.


;****
NUMOBS==221.	;THE NUMBER OF OBLIST ELEMENTS
;****	WHENEVER YOU ADD AN OBLIST ELEMENT, MAKE SURE YOU INCREMENT
	.IFZ 0		;NOBODY HAS A VOICE BOX.
	NUMOBS=NUMOBS-8	;NUMBER OF OBLIST ELEMENTS IF NO VOICE BOX
	.ENDC
	.IFZ NDISP
	NUMOBS=NUMOBS-26.	;IF NO DISPLAYS
	.ENDC
;****	NUMOBS !!!!!!
SOOMX:	2+SOBLSU	;2 > THAN HIGHEST ADDR USED IN SYS OBLIST
	NGP2==1
	NGPTWO SOBLSU-SOBLST+2
SOBP2:	NGP2	;( SMALLEST POWER OF 2 >= NUMOBS )*2
OBADD1=.
OBADD2=.+<2*NUMOBS>
OBSTRT=OBADD2	;WHERE THE SYSTEM OBLIST ELEMENTS START

SOBLST:	OLE 0
	OLE ADVANCE,,,2,,,0
	OLE ALL,,NOTPRO
	OLE AND,,NOTPRO
	OLE BACK,,,2,1
	OLE BELL,,,2
	ABRV BF,$BUTFI
	ABRV BK,$BACK
	ABRV BL,$BUTLA
	OLE BOTH,,,2,2
	OLE BTOUCH,,,2
	OLE BUTFIRST,,,2,1
	OLE BUTLAST,,,2,1
	OLE CASESW,,,2
	OLE CGCF,,,2
	OLE CLEARSCREEN,,,2,,,NDISP
	OLE CLOCK,,,2
	OLE COMPRESS,,,2
	OLE CONTENTS,,,2
	OLE COUNT,,,2,1
	OLE CPNF,,,2
	OLE CR,,,2
	ABRV CS,$CLEAR,NDISP
	OLE CTF,,CLRSTF,2
	OLE DATE,,UDATEG,2
	OLE DEBUG,,DEBUGL,2
	OLE DELETE,,,2
	OLE DEPOSIT,,,2,1
	OLE DIFFERENCE,,DIFF,2,2
	OLE DISPLAY,,,2,1,,NDISP
	OLE DO,,,2,1
	OLE EAN,,,2
	ABRV ED,$EDIT
	OLE EDIT,,,2
	OLE EDL,,EDLINE,2
	OLE EDT,,EDTITL,2
	OLE EITHER,,,2,2
	OLE ELSE,,,2
	OLE EMPTYP,EMPTYP,EMPTYP,2,1
	OLE END,,,2
	OLE EQUAL,EQUAL,EQUAL,2,2
	ABRV ER,$ERASE
	OLE ERASE,,,2
	OLE ERL,,,2
	OLE ERTR,,,2
	OLE EXAMINE,,,2,1
	OLE EXCHD,,,2
	OLE EXIT,,,2
	ABRV F,$FIRST
	ABRV FD,$FORWA
	OLE FILE,,NOTPRO
	OLE FILES,,NOTPRO
	OLE FIRST,,,2,1
	OLE FORWARD,,,2,1
	ABRV FP,$FPRINT
	OLE FPRINT,,,2,1+VARIABLE
	OLE FPUT,,,2,2+VARIABLE
	OLE FTOUCH,,,2
	OLE GO,,,2,1
	OLE GOODBYE,,,2
	OLE GREATER,GRTRP,GREATR,2,2
	OLE GUN,,,2,1
	OLE HEADING,,,2,,,NDISP
	OLE HELLO,,,2
	OLE HERE,,,2,,,NDISP
	OLE HIDETURTLE,,,2,,,NDISP
	OLE HOME,,,2,,,NDISP
	ABRV HT,$HIDET,NDISP
	OLE IF,,,2,,1
	ABRV IFF,$IFFAL
	OLE IFFALSE,,,2
	ABRV IFT,$IFTRU
	OLE IFTRUE,,,2
	OLE IN,,,2,,,0
	OLE INDEX,,NOTPRO
	OLE INFL,,,2,1,,0
	OLE IS,IS,EQUAL,2,2
	OLE KILLDISPLAY,,,2,,,NDISP
	OLE KILLTURTLE,,,2
	ABRV L,$LAST
	OLE LAMPOFF,LPOFF,,2
	OLE LAMPON,LPON,,2
	OLE LAST,,,2,1
	OLE LBTOUCH,,,2
	OLE LEFT,,,2,1
	OLE LESS,LESSP,LESSP,2,2
	OLE LEVEL,,FLEV,2
	OLE LFTOUCH,,,2
	OLE LINE,,NOTPRO
	OLE LIST,,LIST.P,2,2+VARIABLE
	OLE LISTP,LISTP,LISTP,2,1
	OLE LOCAL,,,2,1
	OLE LPUT,,,2,2+VARIABLE
	ABRV LT,$LEFT
	OLE LTOUCH,,,2
	OLE MAKE,,,2,2
	OLE MCLEAR,,,2
	OLE MLEN,,,2
	OLE MOD,,,2,2
	OLE MOUNT,,,2,1
	OLE NAMES,,NOTPRO
	OLE NEWSNAP,,,2,,,NDISP
	OLE NODES,,,2
	OLE NOMUSIC,,,2
	OLE NORM,,,2,,,0
	OLE NOT,,,2,1
	OLE NOWRAP,,,2,,,NDISP
	OLE NUMBERP,NUMBERP,NUMBP,2,1
	OLE NVOICES,,,2,1
	OLE OF,,NOTPRO
	ABRV OP,$OUTPUT
	OLE OUT,,,2,,,0
	OLE OUTPUT,,,2,1
	ABRV P,$PRINT
	OLE PAUSE,,,2
	ABRV PD,$PENDO
	OLE PEEK,,,2
	OLE PENDOWN,,,2
	OLE PENUP,,,2
	OLE PM,,,2
	ABRV PO,$PRTO
	OLE POF,,SHOW3,2
	OLE POI,,SAFL,2
	OLE POL,,SHLINE,2
	OLE PON,,SAN,2
	OLE POT,,TITHIS,2
	OLE POTS,,SATI,2
	ABRV PR,$PROCD
	OLE PREAD,,,2
	OLE PRINT,,,2,1+VARIABLE
	OLE PRINTOUT,PRTO,SHOW,2
	OLE PROCEDURES,,NOTPRO
	OLE PROCEED,PROCD,,2
	OLE PRODUCT,,PROD,2,2+VARIABLE
	ABRV PRS,$PROCE
	ABRV PU,$PENUP
	OLE PWRCLR,,,2
	OLE PWRITE,,,2
	OLE QUOTIENT,,DIVDE,2,2
	OLE RANDOM,,,2
	OLE RBTOUCH,,,2
	OLE READ,,FREAD,2
	OLE READPTR,,,2
	OLE READY,READYP,READYP,2,,,0
	OLE REPEAT,,,2,,,0
	OLE REQUEST,,RQUEST,2
	OLE RFTOUCH,,,2
	OLE RIGHT,,,2,1
	OLE RJLDSK,,NOTPRO
	ABRV RT,$RIGHT
	OLE RTOUCH,,,2
	OLE RUG,,RUNRUG
	ABRV S,$SENTE
	OLE SAY,,,2,1,,0
	OLE SENTENCE,,,2,2+VARIABLE
	OLE SETHEADING,,,2,1,,NDISP
	ABRV SETT,$SETTU,NDISP
	OLE SETTURTLE,,,2,1,,NDISP
	OLE SETTV,,,2,2
	OLE SETX,,,2,1,,NDISP
	OLE SETXY,,,2,2,,NDISP
	OLE SETY,,,2,1,,NDISP
	OLE SGCF,,,2
	OLE SHOWTURTLE,,,2,,,NDISP
	OLE SING,,,2,2+VARIABLE
	OLE SNAP,,,2,,,NDISP
	OLE SPNF,,,2
	ABRV ST,$SHOWT,NDISP
	OLE STARTDISPLAY,,,2,,,NDISP
	OLE STARTTURTLE,,,2,1
	OLE STATUS,,,2
	OLE STF,,SETSTF,2
	OLE STOP,,,2
	OLE SUM,,,2,2+VARIABLE
	ABRV T,$TEST
	OLE TEST,,,2,1
	OLE THEN,,,2
	OLE THING,,DOTS,2,1
	OLE TIME,,UTIMEG,2
	OLE TITLE,,NOTPRO
	OLE TITLES,TITLS,NOTPRO
	OLE TO,,,2
	OLE TOOT,,,2,1
	OLE TRACE,,,2
	OLE TYPE,,,2,1+VARIABLE
	OLE TYPEIN,,,2
	OLE UNDELETE,,UNDELE,2
	OLE UNMOUNT,,,2,1
	OLE USE,,,2
	OLE USERS,,NOTPRO
	OLE VERSION,,VERSN,2
	OLE VLEN,,,2,
	OLE VOICE,,,2,1
	OLE WAIT,,UWAIT,2,1
	ABRV WC,$WIPEC,NDISP
	OLE WIPE,,,2,1,,NDISP
	OLE WIPECLEAN,,,2,,,NDISP
	OLE WORD,,,2,2+VARIABLE
	OLE WORDP,WORDP,WORDP,2,1
	OLE WRAP,,,2,,,NDISP
	OLE WRITE,,FWRITE,2
	OLE WRITEPTP,,,2
	OLE XCOR,,,2,,,NDISP
	OLE YCOR,,,2,,,NDISP
SOBLSU=.-2	;MUST BE ON LAST ENTRY BEFORE SINGLE CHAR ENTRIES
	OLE ^\!\,LLPAR,LLPAR,1,1
	CDM HASH$
	OLE ^\#\,PROC,PROC,7,1
	CDM LP$
	OLE ^\(\,LPAR,LPAR,1,1
	CDM RP$
	OLE ^\)\,RPAR,RPAR,1
	CDM PRD$
	OLE ^\*\,STAR,PROD,6,2+VARIABLE,YINFIX
	CDM PLU$
	OLE ^\+\,PLUS,SUM,5,2+VARIABLE,YINFIX
	OLE ^\++\,UPLUS,UPLUS,7,1
	CDM MIN$
	OLE ^\-\,MINUS,DIFF,5,2,YINFIX
	OLE ^\--\,UMINS,UMINS,7,1
	CDM DIV$
	OLE ^\/\,SLSH,DIVDE,6,2,YINFIX
	CDM DOTS$
	OLE ^\:\,DOTS,DOTS,7,1
	CDM LSS$
	OLE ^\<\,LESS,LESS,4,2,YINFIX
	CDM EQL$
	OLE ^\=\,EQUAL,EQUAL,4,2,YINFIX
	CDM GTR$
	OLE ^\>\,GRTR,GREATR,4,2,YINFIX
	CDM BKSL$
	OLE ^/\/,BKSL,MOD,6,2,YINFIX
	CDM BKAR$
	OLE ^/_/,BKAR,MAKE,3,2,YINFIX
	OLE ^/__/,TBKAR,MMAKE,3,2,YINFIX

.=OBADD2
.STITL SYSTEM VARIABLES (ONE COPY PER SYSTEM)

DEBSW:	0	;DEBUG SWITCH, NON-ZERO IF BEING DEBUGGED
ERBASE:	0	;PALCE ON DISK WHERE ERRORS ARE STORED
	0
NOADDR:	0	;NON-ZERO MEANS PRINT ADDRESS OF ERRORS
USER:	-1
ULAST:	0	;LAST USER WHO WAS RUN
QUANT:	6	;UQUANT SET FRCM THIS
UQUANT:	0	;TIME IN 1/100THS USER SHOULD RUN
UTIME:	0
NRABLU:	0	;NUMBER OF USERS WITH FLSADR=0
NSWPU:	0	;NUMBER OF USERS ASSIGNED TO SLOTS BUT NOT YET IN
NINU:	0	;   "    "    "      "      "   "   AND ALREADY IN
PUSPSL:	0	;PREFERED USER SLOT TO SWAP
PUSRSP:	0	;PREFERED USER TO SWAP OUT
SWPLEP:	SWPLST	;PLACE TOO PUT NEXT REQ
SWPLST:	.=.+<MNSLTS*2>+2	;LIST OF SWAP REQUESTS
MSWPOR:	.=.+<16*MNSLTS*2>	;MOBY SWAP IN AND OUT BLOCKS
SYSWPR:	.=.+<16*MNUSRS>	;10 DISK REQUEST BLOCKS FOR GENERAL USE
DSKCRB:	0	;CURRENT DISK REQUEST
DSKRUN:	DSKS	;THE DISK WHICH IS RUNNING
SLOTST:	.=.+<MNSLTS*4>	;WORD 1 = SLOT USER
			;WORD 2 = NEG, USER COMING IN; 1, USER JUST IN, >1 USER IN A WHILE
	0	;SO END TEST ALWAYS WORKS
	0

WRTELC:	-1	;DISK WRITE LOCK SWITCH (ONE USER AT A TIME!)
NRKERS:	0	;NUMBER OF RK ERRORS
NRFERS:	0	;NUMBER OF RF ERRORS
DKRTYS:	0	;# OF DISK RETRYS
DKNRTY:	-10.
DKPWFR:	0
NUNODE:	0	;NUMBER OF NODES PER USER
NUSERS:	1	;NUMBER OF USERS
NSLOTS:	1	;NUMBER OF IN CORE SLOTS
NUSER2:	2
FOO==0
	.MACR MSWF
	MSWPOR+FOO
FOO==FOO+34
	.ENDM
SLTCAD:	REPT2 MNSLTS,MSWF,0	;ADR OF DISK REQUEST BLK
				;SLOT CORE ADRESS
USWCNT:	0	;NEGATIVE LENGTH OF USER SLOT
USLENT:	0	;LENGHT OF SLOT IN BYTES
USNSEC:	0	;NUMBER OF SECTORS FOR A SLOT
DBGRBD:	0	;GRABBED DISK BLOCK
DUSECT:	0	;COUNT OF SYSTEM DISK USAGES MOD 256
DCLRUS:	0	;ADDRESS OF CLEAR USER IMAGE
	0
DSKRND:	0	;START OF RANDOM USER STORAGE
	0
TTYUGO:	-1
PWFPDL:	0
FOO==.
LOCKUS:	-1	;INDEX OF USER LOCKED IN CORE
GCLOCK:	-1
NLOCKS==.-FOO/2
PBUF:	.=.+40
PBUFE:
PGRAB:	-1
PBFPTI:	0
PBFPTM:	0
NPCHRS:	0
RWWSW:	0
JIGSW:	0
	FOR NDISP
;DISPLAY SYSTEM VARIABLES
DLEN==4400	;LENGTH OF EACH DISPLAY LIST (IN BYTES)
DPDLL==60	;LENGTH OF EACH DISPLAY PDL (IN BYTES)
TLEN==20	;LENGTH OF EACH TURTLE LIST (IN BYTES)
SDPDLL==NDISP*DPDLL	;TOTAL LENGTH OF DISPLAY PDL AREA (IN BYTES)
SDLEN==NDISP*DLEN	;TOTAL LENGTH OF DISPLAY LIST AREA (IN BYTES)
STLEN==NDISP*TLEN	;TOTAL LENGTH OF TURTLE LIST AREA (IN BYTES)

DSTAT:	REPT1	NDISP,-1	;CONTAINS -1 IF DISPLAY INACTIVE
;	OTHERWISE CONSOLE NUMBER SHIFTED OVER TO MUNG NGCSR

DCONS:		;USER DISPLAY CONSOLE TABLE
		;FOR NOW, USER 1 GETS DISP 0, USER 1 DISP 2, ETC.
	.BYTE	-1
	REPT1	NDISP,.BYTE <.RPCNT>
	REPT1	<<MNUSRS-1>-NDISP>,.BYTE -1	;USERS WITHOUT DISPLAYS
	.EVEN

SDPDLP:		;DISPLAY PDL POINTER TABLE
	REPT1	NDISP,<<DPDL+<DPDLL*.RPCNT>-DISREL>/2>
SDWD1:	;FIRST WORD FOR EACH DISPLAY
	REPT1	NDISP,<<DLIST+<.RPCNT*DLEN>-DISREL>/2!DPUSHJ>
STLIST:	;TURTLE DISPLAY LIST AREA
	REPT1	NDISP,<TLIST+<TLEN*.RPCNT>>

;DISPLAY TEMPORARIES
;THESE MUST BE IN THIS ORDER
NEWX:	.WORD 0,0	;NEWX IS A TEMPORARY STORAGE FOR ROUTINES
;			LIKE SETXY. IT CONTAINS WHAT CURX WILL BE SET
;			TO IF THE ROUTINE DOESN'T
;			ENCOUNTER A FATAL ERROR
NEWY:	.WORD 0,0	;LIKE NEWX
;END OF ORDER
	.ENDC
	ENDC NDISP
TUT:	0	;TURTLE TOP.  POINTS TO TOP OF TURTLE DISPLAY LIST
SNPTEM:	0	;USED BY GARBAGE COLLECTOR

	MUSBEG==.	;MUSIC BOX VARIABLES (ONE SET FOR EACH MUSIC BOX)
		;KEEP VARIABLES IN THIS ORDER
MUSER:	-1	;USER USING THE BOX -1 MEANS ITS FREE
VLAST:	.WORD	0,0,0,0	;POINTERS TO LAST NODE IN LIST
VOICLN:	.WORD	0,0,0,0	;NUMBER OF NOTES IN EACH VOICE
VOICEN:	0	;INDEX FOR CURRENT ACTIVE VOICE
NVOIC:	0	;NUMBER OF ACTIVE VOICES
	MUSEND==.

TEM0:	0
TEM1:	0
ANSWER:	.WORD	0,0	;USED BY DOUBLE PRECISION ROUTINES
SHFCNT:	0		;USED BY DOUBLE PRECISION ROUTINES
EXCH1:	0
.VERR==-128.
.VRTS==-128.
GCMKL:	TOPS
	TOPS1
	GCP1
	GCP2
	GCPREV
	MVOC
	MVOC+2
	MVOC+4
	MVOC+6
	0

;DISK DIRECTORY ADDRESSES
;-1 IF NOT USED
FHEADD:	0	;FIXED HEAD DISK (LOGO COMMANDS MOUNT 0, UNMOUNT 0)
MOV0D:	20000	;MOVING HEAD, FIXED PLATTER (MOUNT 1)
MOV1D:	-1	;MOVING HEAD, REMOVABLE PLATTER (MOUNT 2)
	.STITL SYSTEM VARIABLES (ONE COPY PER USER)

UBLK=.
FILFLG:	0
JMTU:	0
FLSRES:	0	;REASON USER NOT RUNNING
FLSADR:	0	;ADDRESS TO START AT AFTER FLUSH
LFLSAD:	0	;LAST FLUSH ADDR
OFLSAD:	0	;ONE BEFORE THAT
UACA:	0
UACB:	0
UACC:	0
UACD:	0
UACE:	0
UAC:	0	;EAE AC
UMQ:	0	;EAE MQ
USR:	0	;EAE STATUS REGISTER
UPC:	0	;PROGRAM COUNTER
UTTY:	0
BRAKE:	0
;DO NOT CHANGE THE ORDER BELOW
USWPAD:	.=.+4	;BEGINNING OF SWAP AREA
UDBFSV:	.=.+4	;PALCE TO SAVE THE DISK BUFFERS DURING GC
DTYIBF:	.=.+4	;BEGINING OF TYI BUFFER ON DISK
DEDTBF:	.=.+4	;BEGINNG OF EDIT BUFFER
UDSKAD:	0	;RANDOM DISK STORAGE AREA

LUBLK==.-UBLK
L==LUBLK

	.=.+<MNUSRS*LUBLK>
SYSIDX==MNUSRS*LUBLK

	.STITLE	DISPATCH TABLE (ENGLISH)
;FLAGS--
;FSF -- SPECIAL ON INPUT
;FOF -- SPECIAL ON OUTPUT
;FQF -- QUOTING CHARACTER
;SEPF -- SEPARATOR CHARACTER
;WSF -- WORD SEPARATOR
;NNUMF -- NOT A NUMBER
;OPERF -- OPERATOR

	;FLAGS--BYTE ONE		NUMBER--BYTE TWO
;	FSF FOF FQF SEPF WSF NNUMF OPERF	#
;^@	.   .   .   .    .   NNUMF .    	.
;^A	.   FOF .   .    .   NNUMF .    	20
;^B	.   FOF .   .    .   NNUMF .    	0
;^C	FSF .   .   .    .   NNUMF .    	0
;^D	FSF .   .   .    .   NNUMF .    	2
;^E	.   .   .   .    .   NNUMF .    	.
;^F	.   .   .   .    .   NNUMF .    	.
;^G	FSF FOF .   .    .   NNUMF .    	4
;^H	.   FOF .   .    .   NNUMF .    	2
;^I	.   FOF .   SEPF WSF NNUMF .    	10
;^J	.   FOF .   SEPF WSF NNUMF .    	12
;^K	.   FOF .   SEPF WSF NNUMF .    	14
;^L	.   FOF .   SEPF WSF NNUMF .    	16
;^M	FSF FOF .   SEPF WSF NNUMF .    	6
;^N	FSF .   .   .    .   NNUMF .    	10
;^O	.   .   .   .    .   NNUMF .    	.
;^P	.   .   .   .    .   NNUMF .    	.
;^Q	FSF .   .   .    .   NNUMF .    	12
;^R	FSF .   .   .    .   NNUMF .    	14
;^S	FSF .   .   .    .   NNUMF .    	16
;^T	.   .   .   .    .   NNUMF .    	.
;^U	.   .   .   .    .   NNUMF .    	.
;^V	.   .   .   .    .   NNUMF .    	.
;^W	FSF .   .   .    .   NNUMF .    	20
;^X	FSF .   .   .    .   NNUMF .    	22
;^Y	FSF .   .   .    .   NNUMF .    	24
;^Z	FSF .   .   .    .   NNUMF .    	26
;^[	.   .   .   .    .   NNUMF .    	.
;^\	.   .   .   .    .   NNUMF .    	.
;^]	.   .   .   .    .   NNUMF .    	.
;^^	.   .   .   .    .   NNUMF .    	.
;^_	.   .   .   .    .   NNUMF .    	.

;SP	.   .   .   SEPF WSF NNUMF .    	.
;!	.   .   .   .    .   NNUMF .    	.
;"	.   .   .   SEPF .   NNUMF .    	.
;#	.   .   .   SEPF .   NNUMF OPERF	HASH$
;$	.   .   .   .    .   NNUMF .    	.
;%	.   .   .   .    .   NNUMF .    	.
;&	.   .   .   .    .   NNUMF .    	.
;'	.   .   .   SEPF .   NNUMF .    	.
;(	.   .   .   SEPF .   NNUMF OPERF	LP$
;)	.   .   .   SEPF .   NNUMF OPERF	RP$
;*	.   .   .   SEPF .   NNUMF OPERF	PRD$
;+	.   .   .   SEPF .   NNUMF OPERF	PLU$
;,	.   .   .   .    .   NNUMF .    	.
;-	.   .   .   SEPF .   NNUMF OPERF	MIN$
;.	.   .   .   .    .   NNUMF .    	.
;/	.   .   .   SEPF .   NNUMF OPERF	DIV$
;0	.   .   .   .    .   .     .    	.
;1	.   .   .   .    .   .     .    	.
;2	.   .   .   .    .   .     .    	.
;3	.   .   .   .    .   .     .    	.
;4	.   .   .   .    .   .     .    	.
;5	.   .   .   .    .   .     .    	.
;6	.   .   .   .    .   .     .    	.
;7	.   .   .   .    .   .     .    	.
;8.	.   .   .   .    .   .     .    	.
;9.	.   .   .   .    .   .     .    	.
;:	.   .   .   SEPF .   NNUMF OPERF	DOTS$
;;	.   .   .   SEPF .   NNUMF .    	.
;<	.   .   .   SEPF .   NNUMF OPERF	LSS$
;=	.   .   .   SEPF .   NNUMF OPERF	EQL$
;>	.   .   .   SEPF .   NNUMF OPERF	GTR$
;?	.   .   .   .    .   NNUMF .    	.

;@	.   .   .   .    .   NNUMF .    	.
;A	.   .   .   .    .   NNUMF .    	.
;B	.   .   .   .    .   NNUMF .    	.
;C	.   .   .   .    .   NNUMF .    	.
;D	.   .   .   .    .   NNUMF .    	.
;E	.   .   .   .    .   NNUMF .    	.
;F	.   .   .   .    .   NNUMF .    	.
;G	.   .   .   .    .   NNUMF .    	.
;H	.   .   .   .    .   NNUMF .    	.
;I	.   .   .   .    .   NNUMF .    	.
;J	.   .   .   .    .   NNUMF .    	.
;K	.   .   .   .    .   NNUMF .    	.
;L	.   .   .   .    .   NNUMF .    	.
;M	.   .   .   .    .   NNUMF .    	.
;N	.   .   .   .    .   NNUMF .    	.
;O	.   .   .   .    .   NNUMF .    	.
;P	.   .   .   .    .   NNUMF .    	.
;Q	.   .   .   .    .   NNUMF .    	.
;R	.   .   .   .    .   NNUMF .    	.
;S	.   .   .   .    .   NNUMF .    	.
;T	.   .   .   .    .   NNUMF .    	.
;U	.   .   .   .    .   NNUMF .    	.
;V	.   .   .   .    .   NNUMF .    	.
;W	.   .   .   .    .   NNUMF .    	.
;X	.   .   .   .    .   NNUMF .    	.
;Y	.   .   .   .    .   NNUMF .    	.
;Z	.   .   .   .    .   NNUMF .    	.
;[	.   .   FQF SEPF WSF NNUMF .    	0
;\	.   .   .   SEPF .   NNUMF OPERF    	BKSL$
;]	.   .   FQF SEPF WSF NNUMF .    	2
;^	.   .   .   .    .   NNUMF .    	.
;_	.   .   .   SEPF .   NNUMF OPERF    	BKAR$

;`	.   .   .   .    .   NNUMF .    	.
;a	.   .   .   .    .   NNUMF .    	.
;b	.   .   .   .    .   NNUMF .    	.
;c	.   .   .   .    .   NNUMF .    	.
;d	.   .   .   .    .   NNUMF .    	.
;e	.   .   .   .    .   NNUMF .    	.
;f	.   .   .   .    .   NNUMF .    	.
;g	.   .   .   .    .   NNUMF .    	.
;h	.   .   .   .    .   NNUMF .    	.
;i	.   .   .   .    .   NNUMF .    	.
;j	.   .   .   .    .   NNUMF .    	.
;k	.   .   .   .    .   NNUMF .    	.
;l	.   .   .   .    .   NNUMF .    	.
;m	.   .   .   .    .   NNUMF .    	.
;n	.   .   .   .    .   NNUMF .    	.
;o	.   .   .   .    .   NNUMF .    	.
;p	.   .   .   .    .   NNUMF .    	.
;q	.   .   .   .    .   NNUMF .    	.
;r	.   .   .   .    .   NNUMF .    	.
;s	.   .   .   .    .   NNUMF .    	.
;t	.   .   .   .    .   NNUMF .    	.
;u	.   .   .   .    .   NNUMF .    	.
;v	.   .   .   .    .   NNUMF .    	.
;w	.   .   .   .    .   NNUMF .    	.
;x	.   .   .   .    .   NNUMF .    	.
;y	.   .   .   .    .   NNUMF .    	.
;z	.   .   .   .    .   NNUMF .    	.
;{	.   .   .   .    .   NNUMF .    	.
;|	.   .   .   .    .   NNUMF .    	.
;}	.   .   .   .    .   NNUMF .    	.
;~	.   .   .   .    .   NNUMF .    	.
;RBO	FSF .   .   .    .   NNUMF .    	30

	.STITLE SYSTEM DISPATCH TABLE (BYTE ONE)

;FLAG DEFINITIONS
FSF==200	;SPECIAL INPUT
FOF==100	;SPECIAL OUTPUT
FQF==20		;QUOTING
SEPF==4		;SEPARATOR
WSF==2		;WORD SEPARATOR
NNUMF==40	;NOT A NUMBER
OPERF==10	;OPERATOR

DTBL:
.BYTE	NNUMF,FOF!NNUMF		;^@	;^A ECHOES AS CR
.BYTE	FOF!NNUMF,FSF!NNUMF	;^B ECHOES AS BLANK	;^C COPYS NEXT CHARACTER
.BYTE	FSF!NNUMF,NNUMF		;^D DELETES NEXT CHARACTER	;^E
.BYTE	NNUMF,FSF!FOF!NNUMF	;^F	;^G BREAK
.BYTE	FOF!NNUMF,FOF!SEPF!WSF!NNUMF	;^H BACKSPACE	;^I TABULATE
.BYTE	FOF!SEPF!WSF!NNUMF,FOF!SEPF!WSF!NNUMF	;^J LINE FEED	;^K TABULATE VERTICALLY
.BYTE	FOF!SEPF!WSF!NNUMF,FSF!FOF!SEPF!WSF!NNUMF	;^L FORM FEED	;^M CARRIAGE RETURN	ECHOES AS CARRIAGE RETURN LINE FEED
.BYTE	FSF!NNUMF,NNUMF		;^N GET NEXT WORD	;^O
.BYTE	NNUMF,FSF!NNUMF		;^P	;^Q SUPER-QUOTE
.BYTE	FSF!NNUMF,FSF!NNUMF	;^R COPY REST OF LINE	;^S SKIP NEXT WORD
.BYTE	NNUMF,NNUMF		;^T	;^U
.BYTE	NNUMF,FSF!NNUMF		;^V	;^W ERASE LAST WORD
.BYTE	FSF!NNUMF,FSF!NNUMF	;^X CLARIFY INPUT	;^Y EDIT PREVIOUS LINE
.BYTE	FSF!NNUMF,NNUMF		;^Z DESTROY INPUT BUFFER	;^[ MAYBE ALTMODE
.BYTE	NNUMF,NNUMF		;^\	;^]
.BYTE	NNUMF,NNUMF		;^^	;^_ WELL, ANY BETTER IDEAS FOR THEM?
.BYTE	SEPF!WSF!NNUMF,NNUMF	;SP	;! ?????
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;"	;# ACTION OF
.BYTE	NNUMF,NNUMF		;$	;%
.BYTE	NNUMF,NNUMF!OPERF	;&	;' (MAYBE LE)
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;( ARITHMETIC GROUPING	;) DITTO
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;* MULTIPLY	;+ ADD
.BYTE	NNUMF,SEPF!NNUMF!OPERF	;,	;- SUBTRACT
.BYTE	NNUMF,SEPF!NNUMF!OPERF	;.	;/ DIVIDE
.BYTE	0,0	;0	;1
.BYTE	0,0	;2	;3
.BYTE	0,0	;4	;5
.BYTE	0,0	;6	;7
.BYTE	0,0	;8.	;9.
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF	;: THING OF	;; PROPERTY OF
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;<	;=
.BYTE	SEPF!NNUMF!OPERF,NNUMF	;>	;?
.BYTE	NNUMF,NNUMF		;@	;A
.BYTE	NNUMF,NNUMF		;B	;C
.BYTE	NNUMF,NNUMF		;D	;E
.BYTE	NNUMF,NNUMF		;F	;G
.BYTE	NNUMF,NNUMF		;H	;I
.BYTE	NNUMF,NNUMF		;J	;K
.BYTE	NNUMF,NNUMF		;L	;M
.BYTE	NNUMF,NNUMF		;N	;O
.BYTE	NNUMF,NNUMF		;P	;Q
.BYTE	NNUMF,NNUMF		;R	;S
.BYTE	NNUMF,NNUMF		;T	;U
.BYTE	NNUMF,NNUMF		;V	;W
.BYTE	NNUMF,NNUMF		;X	;Y
.BYTE	NNUMF,FQF!SEPF!WSF!NNUMF	;Z	;[
.BYTE	SEPF!NNUMF!OPERF,FQF!SEPF!WSF!NNUMF	;\ MODULO	;]
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;^	EXPONENTIATE, MAYBE	;_ MAKE
.BYTE	NNUMF,NNUMF		;` GRAVE ACCENT. LOOK THAT UP ON YOUR TELTERM.	;a LOWER CASE
.BYTE	NNUMF,NNUMF		;b LOWER CASE	;c LOWER CASE
.BYTE	NNUMF,NNUMF		;d LOWER CASE	;e LOWER CASE
.BYTE	NNUMF,NNUMF		;f LOWER CASE	;g LOWER CASE
.BYTE	NNUMF,NNUMF		;h LOWER CASE	;i LOWER CASE
.BYTE	NNUMF,NNUMF		;j LOWER CASE	;k LOWER CASE
.BYTE	NNUMF,NNUMF		;l LOWER CASE	;m LOWER CASE
.BYTE	NNUMF,NNUMF		;n LOWER CASE	;o LOWER CASE
.BYTE	NNUMF,NNUMF		;p LOWER CASE	;q LOWER CASE
.BYTE	NNUMF,NNUMF		;r LOWER CASE	;s LOWER CASE
.BYTE	NNUMF,NNUMF		;t LOWER CASE	;u LOWER CASE
.BYTE	NNUMF,NNUMF		;v LOWER CASE	;w LOWER CASE
.BYTE	NNUMF,NNUMF		;x LOWER CASE	;y LOWER CASE
.BYTE	NNUMF,NNUMF		;Z LOWER CASE	;LEFT BRACE
.BYTE	NNUMF,NNUMF		;VERTICAL BAR	;RIGHT BRACE
.BYTE	NNUMF,FSF!NNUMF		;TILDE	;RUBOUT

	.STITLE SYSTEM DISPATCH TABLE (BYTE TWO)
;NUMBERS POINT TO OTHER TABLES
;$ POINTS TO SYSTEM OBLIST

DTBL2:
.BYTE	0,20		;^@ 			;^A
.BYTE	0,0		;^B ECHOES AS BLANK		;^C COPYS NEXT CHARACTER
.BYTE	2,0		;^D DELETES NEXT CHARACTER	;^E
.BYTE	0,4		;^F 			;^G BREAK
.BYTE	2,10		;^H BACKSPACE		;^I TABULATE
.BYTE	12,14		;^J LINE FEED		;^K TABULATE VERTICALLY
.BYTE	16,6		;^L FORM FEED		;^M CARRIAGE RETURN	ECHOES AS CARRIAGE RETURN LINE FEED
.BYTE	10,0		;^N GET NEXT WORD		;^O
.BYTE	0,12		;^P 			;^Q SUPER-QUOTE
.BYTE	14,16		;^R 			;^S SKIP NEXT WORD
.BYTE	0,0		;^T	;^U
.BYTE	0,20		;^V	;^W ERASE LAST WORD
.BYTE	22,24		;^X CLARIFY INPUT	;^Y
.BYTE	26,0		;^Z DESTROY INPUT BUFFER	;^[ MAYBE ALTMODE
.BYTE	0,0		;^\	;^]
.BYTE	0,0		;^^	;^_ WELL, ANY BETTER IDEAS FOR THEM?
.BYTE	0,0		;SP	;! ?????
.BYTE	0,HASH$		;"	;# ACTION OF
.BYTE	0,0		;$	;%
.BYTE	0,0		;&	;' (MAYBE LE)
.BYTE	LP$,RP$		;( ARITHMETIC GROUPING	;) DITTO
.BYTE	PRD$,PLU$	;* MULTIPLY	;+ ADD
.BYTE	0,MIN$		;,	;- SUBTRACT
.BYTE	0,DIV$		;.	;/ DIVIDE
.BYTE	0,0		;0	;1
.BYTE	0,0		;2	;3
.BYTE	0,0		;4	;5
.BYTE	0,0		;6	;7
.BYTE	0,0		;8.	;9.
.BYTE	DOTS$,0		;: THING OF	;; PROPERTY OF
.BYTE	LSS$,EQL$	;<	;=
.BYTE	GTR$,0		;>	;?
.BYTE	0,0		;@	;A
.BYTE	0,0		;B	;C
.BYTE	0,0		;D	;E
.BYTE	0,0		;F	;G
.BYTE	0,0		;H	;I
.BYTE	0,0		;J	;K
.BYTE	0,0		;L	;M
.BYTE	0,0		;N	;O
.BYTE	0,0		;P	;Q
.BYTE	0,0		;R	;S
.BYTE	0,0		;T	;U
.BYTE	0,0		;V	;W
.BYTE	0,0		;X	;Y
.BYTE	0,0		;Z	;[
.BYTE	BKSL$,2		;\ MODULO	;]
.BYTE	0,BKAR$		;^	 (MAYBE EXPONENTIATE)	;_ MAKE
.BYTE	0,0		;` GRAVE ACCENT. LOOK THAT UP ON YOUR TELTERM.	;a LOWER CASE
.BYTE	0,0		;b LOWER CASE	;c LOWER CASE
.BYTE	0,0		;d LOWER CASE	;e LOWER CASE
.BYTE	0,0		;f LOWER CASE	;g LOWER CASE
.BYTE	0,0		;h LOWER CASE	;i LOWER CASE
.BYTE	0,0		;j LOWER CASE	;k LOWER CASE
.BYTE	0,0		;l LOWER CASE	;m LOWER CASE
.BYTE	0,0		;n LOWER CASE	;o LOWER CASE
.BYTE	0,0		;p LOWER CASE	;q LOWER CASE
.BYTE	0,0		;r LOWER CASE	;s LOWER CASE
.BYTE	0,0		;t LOWER CASE	;u LOWER CASE
.BYTE	0,0		;v LOWER CASE	;w LOWER CASE
.BYTE	0,0		;x LOWER CASE	;y LOWER CASE
.BYTE	0,0		;z LOWER CASE	;{ OPEN BRACE
.BYTE	0,0		;| VERTICAL BAR, MAYBE OR, MAYBE XOR	;} CLOSE BRACE
.BYTE	0,30		;~ TILDE, LOGICAL NOT	;RBO	RUBOUT????
	.STITL LOSS CHECKING ROUTINES

IOTBRK:	TST USER
	BLT BADTRP
	CMP P,#SPDLP
	BLOS BADTRP
	BIT #340,6(P)
	BNE BADTRP
	CLR PS
	CMP	-(P),-(P)	;FOOL PRBTRP
	JSR	PC,PRBTRP
	CMP (P)+,(P)+
	TST DEBSW
	BEQ .+4
	BPT	;BREAK IF DEBUGGING
	.BUG.
BADTRP:	INC #-4
LOSSCT=.-2
	BEQ LOSER
	BGT LOST
	JSR	A,SPRINT	;ON SYS CONSOLE
	JSR	PC,PRBTRP	;PRINT MESSAGE
	SPREND
	CMP	(SP)+,(SP)+
	BPT
	RTI

EMTBRK:	BPT
LOSER:	PRTXT ^/I GIVE UP!/
LOST:	BPT
	BR .-2

PRBTRP:	BPRTXT ^/BAD TRAP: VECTOR /
	MOV 6(SP),A
	SUB #4,A	;MAKE IT REAL
	JSR PC,PRON
IOTBR1:	PRTXT ^/ TRAPPED FROM /
	MOV 12(SP),A
	JSR PC,PRON
	PRCR
	RTS	PC

SIMBPT:	HALT	;BPT TRAPS HERE IN SIMULATOR
	RTI

PWRDWB:	JSR F,ACSAV
	MOV #PWFNXM,BEBRV
	SPUSH SR
	SPUSH AC
	SPUSH MQ
	SPUSH PPS
	.IFNZ NDM
	SPUSH DM0BAR
	.ENDC
	MOV P,PWFPDL
	MOV #PWRUPB,PFBRV
	HALT

PWRUPB:	MOV PWFPDL,P
	JSR PC,DEVCLR
	.IFNZ NDM
	SPOP DM0BAR
	.ENDC
	SPOP PPS
	SPOP MQ
	SPOP AC
	SPOP SR
	JSR F,ACRES
	MOV #BEBRV+2,BEBRV
	MOV #PWRDWB,PFBRV
PWFNXM:	RTI
PWRCLR:	RESET
	RESET
	MOV #PWFNXM,BEBRV
	JSR PC,DEVCLR
	MOV #BEBRV+2,BEBRV
	JMP NORT
DEVCLR:
	.IFNZ NDISP
	MOV #DISREL,NGREL
	.ENDC
	MOV #100,LKS
	MOV #200.,PCSTBF
	MOV #113,PCS
	JSR PC,TINITH
	MOV #100000,DKNRTY
	MOV #30.,DKPWFR
	MOV DSKCRB,A
	BEQ NODISK
	CMP #-1,10(A)
	BEQ RKREST
	JSR PC,DSKSG1
	BR NODISK
RKREST:	JSR PC,RKSG1
NODISK:	RTS PC
	.STITL DISK STARTER
DSKFOO:	.=.+<2*FDSCSZ>
DSKFOE:
DSKRFO:	.WORD 0,-FDSCSZ,DSKFOO,0,0,0,0
DSKCFO:	GDJDC
	.=.+14



DSKSRT:
	MOV #SYSWPR,A	;LOOK FOR MOVING HEAD REQESTS
RKSR1:	TSTB 14(A)
	BEQ RKSR2
	CMP #-1,10(A)
	BEQ RKSGO
RKSR2:	ADD #16,A
	CMP #16*MNUSRS+SYSWPR,A
	BHI RKSR1
	MOV #SYSWPR,A	;NEXT LOOK AT SYSTEM REQUESTS
DSKSR1:	TSTB 14(A)	;IS THE FUNCTION NON ZERO?
	BNE DSKSGO	;FOUND A REQUEST, GO DO IT
	ADD #16,A	;LOOK AT NEXT BLOCK
	CMP #16*MNUSRS+SYSWPR,A	;LAST BLOCK?
	BHI DSKSR1
	MOV SWPLST,A	;MOOBY SWAP OUT REQS?
	BNE DSKSGO
	RTS PC	;NO DISK REQUESTS EXTANT, BETTER LUCK NEXT TIME

DSKSGO:	MOV DKNRTY,DKRTYS	;SET NUMBER OF POSSIBLE RETRYS
	MOV A,DSKCRB	;ADDRESS OF BLOCK ABOUT TO BE SERVICED
	MOV (A),B
	BEQ DSKSG1	;BRANCH IF NO
	JSR PC,(B)	;RUN START ROUTINE
DSKSG1:	TST (A)+
	BIT #FDSCMS,4(A)
	BNE DBLECH
	MOV #DSKS,B	;START OF DISK I/O WORDS
	MOV #400,(B)+
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
	MOV (A)+,(B)+	;LOW ORDER DISK ADDRESS
	MOV (A)+,(B)+	;HIGH "      "     "
	TST (A)+	;GO PAST UNUSED WORD
	MOV #DSKS,DSKRUN
	MOVB (A),B
	MOV B,DSKS	;SET FUNCTION, ENABLE INTERUPT, GO!!
	RTS PC

RKSGO:	MOV DKNRTY,DKRTYS
	MOV A,DSKCRB
	MOV (A),B
	BEQ RKSG1
	JSR PC,(B)
RKSG1:	TST (A)+
	MOV #RKWC,B
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
	MOV (A)+,(B)+	;DISK ADDRESS
	CMP (A)+,(A)+	;UNUSED WORDS
	MOV #RKCS,DSKRUN
	MOVB (A),B
	MOV B,RKCS
	RTS PC

DPROVK:	BIS #FDSCSZ,@DSKRUN
	RTS PC

DBLECH:	MOV #DSKCFO+2,B
	MOV A,DSKCFO+12
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	CMP (A)+,(B)+
	MOV (A),(B)
	MOV #DSKCFO+6,A
	MOV #DSKRFO,B
	MOV B,DSKCRB
	MOV #DBLER,(B)+
	CMP (B)+,(B)+
	MOV (A)+,(B)
	BIC #FDSCMS,(B)+
	MOV (A),(B)+
	SUB #6,A
	MOV A,(B)+
	MOV #DREADC,(B)
	MOV DSKCRB,A
	BR DSKSG1

DBLER:	SPUSH C
	SPUSH D
	MOV 12(A),A
	MOV 4(A),B
	BIC #-FDSCSZ,B
	SUB #FDSCSZ,B
	MOV B,C
	ASL C
	ADD #DSKFOE,C
	BIC #FDSCMS,4(A)
	ADD #FDSCSZ,4(A)
	ADC 6(A)
	MOV 2(A),D
	BIT #2,12(A)
	BNE DBLEWD
DBLER2:	MOV (C)+,(D)+
	INC B
	BEQ DBLER1
	INC (A)
	BNE DBLER2
DBLER3:	TST -(A)
	CLRB 14(A)
	MOV (A),B
	BEQ .+4
	JSR 7,(B)
	SPOP D
	SPOP C
	RTS PC
DBLER1:	INC (A)
	BEQ DBLER3
	MOV D,2(A)
	TST -(A)
DBLER4:	MOV A,DSKCRB
	JSR PC,DSKSG1
	SPOP D
	SPOP C
	TST (P)+
	SPOP B
	SPOP A
	RTI

DBLEWD:	MOV (D)+,(C)+
	INC B
	BEQ DBLEW1
	INC (A)
	BNE DBLEWD
DBLEW2:	MOV #-FDSCSZ,(A)+
	MOV #DSKFOO,(A)+
	SUB #FDSCSZ,(A)+
	SBC (A)
	SUB #10,A
	BR DBLER4
DBLEW1:	INC (A)
	BEQ DBLEW2
	MOV #DWRTEC,DSKRFO+14
	MOV #DSKRFO,A
	MOV #DBLEWW,(A)
	BR DBLER4
DBLEWW:	MOV 12(A),A
	BR DBLER4

GDJDC:	MOV 12(A),A
	CLRB 12(A)
	MOV -(A),B
	BEQ .+4
	JMP (B)
	RTS PC
.STITL DISK REQUEST BLOCK GRABBER

SYDRBG:	SPUSH PS	;SAVE OLD PROSSESOR LEVEL
	MOV #340,PS	;LOCK OUT INTERUPTS
	MOV #SYSWPR,A	;LOOK FOR A FREE SYSTEM DISK REQUEST BLOCK
SDRBG1:	TST 14(A)	;IS IT FREE?
	BEQ SDRBG2
	ADD #16,A	;LOOK AT NEXT ONE
	CMP #16*MNUSRS+SYSWPR,A	;ANY MORE?
	BHI SDRBG1	;YES, SEE IF FREE
	SPOP PS	;NO MORE, WE HAVE LOST BIG
	WAIT	;THIS WILL PROBABLY NOT DO ANY GOOD
	BR SYDRBG	;AND CERTAINLY WON'T UNLESS OUR PRIORITY IS <5
SDRBG2:	MOV DUSECT,14(A)	;LABEL BLOCK AS IN USE, BUT NO REQUEST
	INCB DUSECT+1	;SO PEOPLE CAN DISTINGUISH
	SPOP PS	;YOU CAN INTERUPT NOW.
	INC (PC)+
NDSKRQ:	0
	RTS PC


;USER ROUTINE TO FLUSH UNTIL DISK REQUEST POINTED TO BY A DONE

DSKWA2:	ADD #14,A
DSKWAI:	MOV USER,U
	JSR PC,DPROVK
DSKWA1:	TSTB (A)
	BNE DNDONE
	CLR (A)
	JSR PC,RUNME
	RTS PC
DNDONE:	MOV #FRDSKW,FLSRES(U)
	JSR PC,FLUSH
	BR DSKWA1
;GRABS A DISK BLOCK
;DISK BLOCK ADDR RETURNS IN B AND C
UBLKGR:	BIC #DSAMFL,FLAGS2
	MOV #DBITTB,A
	MOV #1,C
	MOV #-1,D
	CLR E
BLKGR1:	BIT C,(A)
	BNE BLKGR3
	INC D
	BGT BLKGR2
	BIS C,(A)
	MOV E,B
	MOV USER,U
	ADD UDSKAD(U),B
	MOV B,DBGRBD
BLKGR2:	CMP #2,D
	BLE BLKGR4
BLKGR3:	INC E
	ASL C
	BNE BLKGR1
	ROL C
	TST (A)+
	CMP #DBITBE,A
	BGE BLKGR1
	BIS #DSAMFL,FLAGS2
BLKGR4:	TST D
	BLT UBLKF2
	SKPRET

;FREES THE DISK BLOCK WHOSE LOW ORDER ADDR IS IN C
;BASE OF THIS DISK SPACE IS IN D
;ADDRESS OF THE APPRPRIATE BIT TABLE IS IN E
UBLKFR:	MOV USER,U
UBLKF1:	BIC #DSAMFL,FLAGS2
	SUB UDSKAD(U),C
	MOV #DBITTB,E
	MOV C,B
	BIC #177770,B
	ASR C
	ASR C
	ASR C
	ADD C,E
	BICB BMT(B),(E)
UBLKF2:	RTS PC

LCGRAB:	MOV USER,U
	MOV (E)+,D
	CMP U,(D)
	BEQ LCGRA1
LCGRA2:	TST (D)
	BLT LCGRA1
	JSR PC,FLUSH
	BR LCGRA2
LCGRA1:	MOV U,(D)
	JSR PC,RUNME
	RTS E

LCUGRB:	MOV (E)+,U
	CMP USER,(U)
	BNE .+6
	MOV #-1,(U)
	RTS E
	.STITL DISK INTERUPT ROUTINE

DSKBRK:	SPUSH A
	SPUSH B
	MOV DSKS,A	;GET STATUS REGISTER
	TST A
	BLT DSKLOS
	MOV #400,DSKS
DSKBR2:	MOV DSKCRB,A	;POINTER TO FUNCTION WORD
	BEQ DSKBR1
	CLR DSKCRB
	CLRB 14(A)	;REQUEST HAS BEEN SERVICED
	DEC NDSKRQ
	MOV (A),B
	BEQ .+4	;NO
	JSR PC,(B)	;YES, GO DO IT
DSKBR1:	JSR PC,DSKSRT	;LOOK FOR SOMETHING ELSE TO DO
DSKRET:	SPOP B
	SPOP A
	RTI

DSKLOS:	INC NRFERS
	BIT #40000,A	;IS IT FROZEN?
	BNE DSKLS1	;YES
	BIT #26000,A	;IS IT ONE OF WRITE CHECK, NED OR WRITE LOCKOUT?
	BEQ DSKRTY	;NO, MEANS IT IS ADDRESS PARITY OR
DKLOSE:	JSR	B,PLOCS	;PRINT CONTENTS OF FOLLOWING ON SYS CONSOLE
	DSKS
	DSKAE
	0
	HALT	;BIT THE BAG
	BR DSKRT1
DSKLS1:	BIT #2000,DSKAE	;NXM?
	BNE DKLOSE	;YES
DSKRTY:	INC DKRTYS	;HAVE WE BEEN THROUGH THIS BEFORE?
	BGE DKLOSE	;YES, TOO MANY TIMES
DSKRT1:	MOV #400,DSKS	;POWER CLEAR THE DISK
	MOV DSKCRB,A	;RETRY THE LAST OPERATION
	JSR PC,DSKSG1
	BR DSKRET

RKBRK:	SPUSH A
	SPUSH B
	MOV RKCS,A
	TST A
	BLT RKLOS
	CLR RKCS
	BR DSKBR2
RKLOS:	INC NRKERS
	BIT #66340,RKER	;BAD ERROR?
	BEQ RKSOFT
RKLOST:	JSR	B,PLOCS	;PRINT FOLLOWING LOCS ON SYS CONSOLE
	RKDS
	RKER
	RKCS
	0
	HALT
	BR RKRT1
RKSOFT:	INC DKRTYS
	BGE RKLOST
RKRT1:	MOV #1,RKCS
	TSTB RKCS
	BGE .-4
	MOV DSKCRB,A
	JSR PC,RKSG1
	BR DSKRET
;JSR F,FSEARC	FIND FILE IN DIRECTORY
;DIRECTORY POINTER IN A (RETURNS POINTING TO END OR FOUND FILE)
;FILE NAME POINTER IN B
;SECTOR ADDRESS OF FILE RETURNS IN D
;SKIPS 2 BYTES IF HIT END OF DIRECTORY
;SKIPS 0 BYTES IF HIT END OF DIRECTORY BLOCK (ANOTHER BLOCK AVAILABLE)
;SKIPS 4 BYTES IF FOUND FILE
FSEARC:	TST (A)	;IS THIS ALREADY THE END?
	BEQ FSEAR3	;YES
FSEAR0:	SPUSH A
	SPUSH B	;SAVE DIRECTORY AND FILE NAME POINTERS
	MOV #4,E	;NUMBER OF WORDS TO COMPARE
FSEAR1:	CMP (A)+,(B)+	;SAME NAME?
	BNE FSEAR2	;DEFINITLY NOT!
	DEC E	;END ?
	BGT FSEAR1	;NO, CHECK NEXT WORD
	SPOP B
	SPOP A
	TST (F)+	;FOUND THE FILE
	BR FSEAR3
FSEAR2:	SPOP B
	SPOP A
	ADD #10,A
	ADD (A)+,D	;NUMBER OF SECTORS FOR THAT FILE
	TST (A)	;ZERO IS THE NAME OF THE LAST FILE
	BGT FSEAR0	;LOOK AT THIS FILE
	BLT FSEAR5	;ANOTHER BLOCK AVAILABLE
	;NEGATIVE FILE NAME INDICATES ANOTHER BLOCK
FSEAR3:	TST (F)+	;ZERO FILE NAME IS LAST FILE
FSEAR5:	BIC #160000,D	;CLEAR EXTRA BITS IN SECTOR ADDR
	RTS F

;JSR F,LSH7
;ADDR
;CONVERTS SECTOR ADDR IN D TO WORD ADDR IN ADDR AND ADDR+2
;CLOBBERS D
LSH7:	MOV D,MQ	;SECTOR ADDR
	MOV #7,LGS	;SHIFT 8 PLACES
	MOV (F)+,D	;ADDRESS TO PUT RESULT
	MOV MQ,(D)+	;LOW ORDER
	MOV AC,(D)	;HIGH ORDER
	RTS F
FILFIN:	SPUSH #DDIRLS	;LIST OF DIRECORY ADDRESSES
FILFN1:	MOV	@(P),E
	BLT	FILFN4
	ADD	#2,(P)
	CMP	#-1,(E)
	BEQ	FILFN1
	MOV	(E),DSKDAD
	MOV DSKDAD,DSKADR
	BIC #17777,DSKADR	;SAVE WHICH DISK
	CLR D
FILFN2:	SPUSH B
	SPUSH D
	JSR E,DSKSEC
	DDIRAD
	DSKDAD
	DREADC
	SPOP D
	SPOP B
	INC DSKDAD
	MOV DDIRAD,A
	JSR F,FSEARC
	BR FILFN2
	BR FILFN1
	TST (P)+
	DEC DSKDAD
	ADD D,DSKADR
	JMP SRET
FILFN4:	TST (P)+
	DEC DSKDAD
	ADD D,DSKADR
	RTS PC
;JSR E,DSKSEC
;POINTER TO CORE ADDRESS
;POINTER TO DISK SECTOR ADDRESS
;READ OR WRITE COMMAND
;	USES 4 WORDS ON PDL;
;	IF THIS INCREASES CHECK PPUSHL.
DSKSEC:	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-200,(A)+	;ALWAYS THIS LONG
	MOV @(E)+,(A)+	;CORE ADDRESS
	MOV @(E)+,D	;DISK ADDRESS
	SPUSH SR
	SPUSH AC
	SPUSH MQ
	BIT #160000,D	;IS IT THE FIXED HEAD DISK?
	BNE DSKSC1	;NO
	MOV A,DSKSC2	;PLACE TO PUT MULTIPLYED DISK ADDR
	JSR F,LSH7
DSKSC2:	0
	ADD #4,A
	BR DSKSC3
DSKSC1:	SUB #20000,D	;MAKE IT INTO A REAL MOVING DISK ADDR
	SPUSH D
	BIC #17777,(SP)
	BIC #160000,D
	MOV D,MQ
	MOV #12.,DIVIDE
	MOV AC,D
	MOV #4,LGS
	ADD MQ,D
	ADD (SP)+,D
	MOV D,(A)+
	MOV #-1,(A)+	;THIS IS A MOVING HEAD REQUEST
DSKSC3:	SPOP MQ
	SPOP AC
	SPOP SR
	TST (A)+
	MOVB (E),(A)	;ENTER REQUEST BYTE
	JSR PC,DSKWAI	;WAIT FOR COMPLETION
	TST (E)+
	RTS E
	.STITL FILEING

;SET UP TO READ FILE SPECIFIED IN DIRNAM AND FNAME
READF:	MOV #DIRNAM,B
	TST (B)
	BEQ IUNERR	;BAD USER NAME
	JSR PC,FILFIN	;TRY TO FIND FILE
	BR FNFERR	;CAN'T
	MOV 10(A),DSKNSC	;NUMBER OF SECTORS IN FILE
	BIC #170000,DSKNSC	;CLEAR TYPE BITS
READF1:	MOV #400,DSKNCH	;NUMBER OF CHARS IN A BLOCK
	MOV DBUFAD,DBUFPT
	DEC DSKNSC	;ONE LESS SECTOR
	BLT NMSERR	;WHAT, NO MORE SECTORS???
	JSR E,DSKSEC	;READ THE SECTOR
	DBUFAD
	DSKADR
	DREADC
	INC DSKADR
READF2:	CLR A	;SUCCESS!
	RTS PC
FNFERR:	MOV #2,A	;FILE NOT FOUND ERR
	RTS PC
NMSERR:	BPT		;NO MORE SECTORS??
	MOV #3,@DBUFAD	;PUT AN END OF FILE CHAR
	BR READF2

;READ A CHAR FROM DISK BUFFER, GET A NEW BLOCK IF NEEDED
READCH:	TST DSKNCH	;IS THERE A FILE OPEN?
	BLE READEF	;NO, GIVE AN EOF CHAR
	MOVB @DBUFPT,D	;GET CHAR
	CMP #EOFCHR,D	;END OF FILE?
	BEQ READE1	;CLOSE FILE AND GIVE EOF
	INC DBUFPT
	DEC DSKNCH	;ANY MORE CHARS IN THIS BUFFER?
	BGT READC1	;YES
	JSR F,ACSAV
	JSR PC,READF1
	JSR F,ACRES
READC1:	RTS PC
READE1:	CLR DSKNCH
READEF:	MOV #EOFCHR,D
	RTS PC

WRITEF:	TST DIRNAM
	BEQ IUNERR
	JSR E,LCGRAB
	WRTELC
	MOV #DIRNAM,B
	JSR PC,FILFIN	;IS THE FILE ON DISK ALREADY?
	BR WRTEF2	;NO, WE CAN PUT IT THERE
	MOV #6,A
	BR WRTRET
WRTEF2:	CMP #-1,12(A)
	BNE WRTEF3
	MOV #4,A
	BR WRTRET
WRTEF3:	MOV #4,E	;COPY NAME INTO DIRECTORY
	MOV (B)+,(A)+
	DEC E
	BGT .-4
	MOV A,DDIRPT	;POINTER INTO DIRECTORY
	MOV (A),DSKNSC
	BIC #160000,DSKNSC	;NUMBER OF AVAILABLE SECTORS
	MOV #400,DSKNCH
	MOV DBUFAD,DBUFPT
	CLR A
	RTS PC
IUNERR:	MOV #12,A
	RTS PC
WRTRET:	JSR E,LCUGRB
	WRTELC
	RTS PC
WRITEC:	TST DSKNCH	;FILE OPEN?
	BNE .+4
	BPT
	MOVB D,@DBUFPT
	INC DBUFPT
	DEC DSKNCH	;BUFFER FULL?
	BGT WRTEC2
WRTEBF:	DEC DSKNSC	;MORE ROOM ON DISK
	BLT WRTEC1	;NO, MAKE OFF YOU WROTE BLOCK
	JSR F,ACSAV
	JSR E,DSKSEC
	DBUFAD
	DSKADR
	DWRTEC
	INC DSKADR
	JSR F,ACRES
WRTEC1:	MOV #400,DSKNCH
	MOV DBUFAD,DBUFPT
WRTEC2:	RTS PC
WRITCU:	MOV #EOFCHR,D
	JSR PC,WRITEC
	CMP #400,DSKNCH	;DID WE JUST OUTPUT A BLOCK?
	BNE WRITCU	;NO, PUT EOFS IN BLOCK
	CLR DSKNCH
	MOV DDIRPT,A
	TST DSKNSC	;NEG NO OF SECTORS IS DISK FULL FLAG
	BGE WRTCU1	;OK, THERE WAS ROOM
	MOV #10,A
	BR WRTCU3
WRTCU1:	MOV (A),B	;NUMBER OF SECTORS AVAILABLE ON DISK
	SUB DSKNSC,B	;RESULT IS FILE LENGTH
	MOV B,(A)+	;PUT IT INTO FILE DESCRIPTION
	TST (A)	;IS THIS THE END OF THE DIRECTORY BLOCK?
	BGE WRTCU2	;NO, PUT NEW END FILE IN
	JSR E,DSKSEC	;WRITE OUT THIS DIRECTORY BLOCK
	DDIRAD
	DSKDAD
	DWRTEC
	INC DSKDAD
	MOV DDIRAD,A
	INC 372(A)	;ONE LESS BLOCK LEFT
WRTCU2:	CLR (A)+
	CLR (A)+
	CLR (A)+
	CLR (A)+
	MOV DSKNSC,(A)	;NUMBER OF SECTORS LEFT
	JSR E,DSKSEC	;WRITE OUT THIS DIRECTORY BLOCK
	DDIRAD
	DSKDAD
	DWRTEC
	CLR A
WRTCU3:	BR WRTRET
DELETF:	MOV #DIRNAM,B
	TST (B)
	BEQ IUNERR
	JSR E,LCGRAB
	WRTELC
	JSR PC,FILFIN
	BR DFNFER
	TST 10(A)
	BGE .+4
	ERROR+CDF
	BIS #200,(A)
DELET1:	JSR E,DSKSEC
	DDIRAD
	DSKDAD
	DWRTEC
	CLR A
	BR WRTRET
DFNFER:	MOV #2,A
	BR WRTRET

UDELEF:	MOV #DIRNAM,B
	TST (B)
	BEQ IUNERR
	BIS #200,(B)
	JSR E,LCGRAB
	WRTELC
	JSR PC,FILFIN
	BR UFNFER
	BIC #200,(A)
	BIC #200,(B)
	BR DELET1
UFNFER:	BIC #200,(B)
	BR DFNFER
READPT:	JSR PC,PINIT
	MOV #101,PRS
	MOV #PRGET,GCHR
	JMP NORT
PREAD:	TST PRS
	BGE .+4
	ERROR+DNR
	JSR PC,PINIT
	JSR F,G1FN
	FNAME
	ERROR+IFN
	JSR PC,WRITEF
	TST A
	BEQ PREAD1
	MOV #-1,PGRAB
	JSR PC,FILERR
PREAD1:	MOV #101,PRS
PREAD2:	JSR PC,PRGET
	JSR PC,WRITEC
	CMP #EOFCHR,D
	BNE PREAD2
	MOV #-1,PGRAB
	JSR PC,WRITCU
	JSR PC,FILERR
	JMP NORT
PINIT:	TST PGRAB
	BLT .+4
	ERROR+DIU
	MOV USER,PGRAB
	MOV #PBUF,PBFPTI
	MOV #PBUFE-1,PBFPTM
	CLR NPCHRS
	RTS PC
PRGET:	SPUSH U
	MOV USER,U
PRGET2:	TST NPCHRS
	BNE PRGET1
	JSR PC,FLUSH
	BR PRGET2
PRGET1:	JSR PC,RUNME
	SPOP U
	BIC #100,PRS
	DEC NPCHRS
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	MOVB @PBFPTM,D
	BIS #100,PRS
	RTS PC
PRBRK:	SPUSH A
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOV PRB,A
	TST PRS
	BGE PRBRK1
	MOV #EOFCHR,A
PRBRK1:	BIC #200,A
	BEQ PRBRK2
	MOVB A,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	CMP #PBUFE-PBUF,NPCHRS
	BNE .+10
	BIC #100,PRS
PRBRK2:	SPOP A
	INC PRS
	RTI
PWRITE:	JSR F,G1FN
	FNAME
	ERROR+IFN
	JSR PC,READF
	JSR PC,FILERR
	JSR PC,PINIT
	JSR PC,FEED
PWRIT1:	JSR PC,READCH
	JSR PC,PPPUT
	CMP #EOFCHR,D
	BNE PWRIT1
	MOV #10.,A
	JSR PC,FEED1
	JSR PC,FEED
	MOV #-1,PGRAB
	JMP NORT

WRITEP:	JSR PC,PINIT
	JSR PC,FEED
	INC DSKNCH	;FAKE OUT WORLD
	MOV #PPPUT,PCHR
	JSR PC,SHOWAL
	BR .+2
	CLR DSKNCH
	MOV #TYO,PCHR
	MOV #EOFCHR,D
	MOV #10.,A
	JSR PC,FEED1
	JSR PC,FEED
	MOV #-1,PGRAB
	JMP NORT

FEED:	MOV #100.,A
	CLR D
FEED1:	JSR PC,PPPUT
	DEC A
	BNE FEED1
	RTS PC

PPPUT:	SPUSH U
PPPUT2:	MOV USER,U
	CMP #PBUFE-PBUF,NPCHRS
	BNE PPPUT1
	JSR PC,FLUSH
	BR PPPUT2
PPPUT1:	JSR PC,RUNME
	SPOP U
	TST PPS
	BPL .+4
	ERROR+DNR
	CLR PPS
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOVB D,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	BIS #100,PPS
	RTS PC

PPBRK:	TST NPCHRS
	BEQ PPBRK1
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	DEC NPCHRS
	MOVB @PBFPTM,PPB
	RTI
PPBRK1:	CLR PPS
	RTI
	FOR 0
	.STITL STUFF FOR VOICE BOX

READYP:	BIT #200,DRS
	BEQ .+6
	JMP RTTRUE
	JMP RTFALS

IN:	MOV #37377,B
IN1:	MOV B,DROB
	MOV #10000.,B
	DEC B
	BGT .-2
	MOV #37777,DROB
	JMP NORT

OUT:	MOV #36777,B
	BR IN1

NORM:	MOV #35777,B
	BR IN1

REPEAT:	MOV #33777,B
	BR IN1

ADVANC:	MOV #27777,B
	BR IN1

INFLE:	ERROR+NOG
INFL:	JSR PC,G1NARG
	CMP #1,B
	BGT INFLE
	CMP #4,B
	BLT INFLE
	MOVB INFLS-1(B),SAYTNG
	JMP NORT

SAYTNG:	77777
INFLS:	.BYTE 200,300,0,100

SAY:	JSR PC,G1NARG
	BIC #77,SAYTNG
	BIC #177700,B
	BIS B,SAYTNG
	MOV USER,U
SAY3:	TST BRAKE(U)
	BNE SAY1
	TSTB DRS
	BLT SAY2
	JSR PC,FLUSH
	BR SAY3
SAY2:	MOV SAYTNG,DROB
SAY1:	JSR PC,RUNME
	BIC #40000,DROB
	JMP NORT
	.ENDC
	ENDC 0
MOUNT:	JSR PC,CKSST
	JSR	PC,G1NARG
	MOV	B,F
	TST	B
	BGE	.+4
MOUNT1:	ERROR+IFN
	CMP	#3,B
	BLT	MOUNT1
	ASL	B
	ROR	F
	ROR	F
	ROR	F
	ROR	F
	MOV	F,FHEADD(B)
	JMP	NORT

UNMOUNT:	JSR PC,CKSST
	JSR	PC,G1NARG
	TST	B
	BLT	MOUNT1
	CMP	#3,B
	BLT	MOUNT1
	ASL	B
	MOV	#-1,FHEADD(B)
	JMP	NORT

EXCHD:	JSR PC,CKSST
	MOV	DDIRLS,A
	MOV	DDIRLS+2,DDIRLS
	MOV	DDIRLS+4,DDIRLS+2
	MOV	A,DDIRLS+4
	JMP	NORT

;COMMON LIST FILE DIRECTORY CODE
;JSR E,CLISTF
;ADDRESS OF ROUTINE TO CALL FOR EACH FILE
CLISTF:	SPUSH (E)+	;SAVE NAME OF ROUTINE TO CALL
	SPUSH #DDIRLS
CLIST2:	MOV	@(P),D
	BLT	CLIST1
	ADD	#2,(P)
	CMP	#-1,(D)
	BEQ	CLIST2
	MOV	(D),D
	MOV	D,DSKDAD
	BIC #17777,D
CLIST3:	MOV DDIRAD,DDIRPT
	JSR E,DSKSEC
	DDIRAD
	DSKDAD
	DREADC
	INC DSKDAD
CLIST4:	MOV DDIRPT,A
	TST (A)
	BLT CLIST3	;TRY NEXT BLOCK OF DIRECTORY
	JSR PC,@2(P)
	TST @DDIRPT
	BEQ CLIST2
	ADD #12,DDIRPT
	BR CLIST4
CLIST1:	ADD #4,P
	RTS E

;THIS CRETIN LISTS EVERYTING!!
LSTALF:	BIT #200,(A)	;EVEN DELETED FILES
	BEQ LSTAL1
	PRTXT ^X!X
LSTAL1:	JSR PC,TYPE4
	SPACE
	JSR PC,TYPE4
	SPACE
	MOV (A),A	;SECTOR COUNT AND TYPE BITS
	JSR PC,PRON	;IN OCTAL!!!
	JMP .CRLF

LSTAUF:	TST (A)
	BEQ LSTFBL
	BIT #200,(A)	;IS THE FILE THERE?
	BNE LSTAU1	;NO
	CMP DIRNAM,(A)+	;THIS USER?
	BNE LSTAU1	;NO
	CMP DIRNAM+2,(A)+
	BNE LSTAU1
	JSR PC,TYPE4
	SPACE
	MOV (A),A
	BIC #170000,A
	JSR PC,PRDN
	JMP .CRLF

LSTAUS:	BIT #200,(A)
	BNE LSTAU1
	MOV DBUFAD,B
LSTUS4:	TST (B)
	BEQ LSTUS1
	CMP (A),(B)+
	BNE LSTUS2
	CMP 2(A),(B)
	BEQ LSTAU1
LSTUS2:	TST (B)+
	BR LSTUS4
LSTUS1:	MOV (A),(B)+
	MOV 2(A),(B)+
	CLR (B)+
	JSR PC,TYPE4
	JMP .CRLF
LSTAU1:	RTS PC

TYPE4:	MOV #4,C
TYPE41:	MOVB (A),D
	BNE .+6
	MOV #40,D
	JSR PC,@PCHR
	INC A
	DEC C
	BGT TYPE41
	RTS PC

LSTFBL:	MOV 10(A),A
	JSR PC,PRDN
	PRTXT ^/ FREE BLOCKS./
	JMP .CRLF
;DISK COMPRESOR
COMPRE:	JSR PC,CKSST
	CLR DSKNSC
	CLR DSKADR
	JSR E,CLISTF	;COMPRESS FILES
	COMPF
	MOV #-1,DSKNSC
	JSR E,CLISTF	;COMPPRESS DIRECTORYS
	COMPD
	JMP NORT

;COMPRESS FILES ON ALL DISKS (CALLED BY CLISTF)
COMPF:	TST (A)	;IS THIS THE LAST FILE ON THIS DISK?
	BEQ COMPF4
	CMP DSKADR,DSKNSC	;HAVE ANY FILES BEEN REMOVED YET?
	BNE COMPF1	;YES
COMPF3:	ADD 10(A),DSKADR	;ADDRESS OF THE NEXT FILE
	BIC #160000,DSKADR	;CLEAR TYPE BITS
	BIT #200,(A)	;IS THIS FILE DELETED?
	BNE COMPF2	;YES
	ADD 10(A),DSKNSC	;NO, PPRESERVE IT
	BIC #160000,DSKNSC
COMPF2:	RTS PC
COMPF1:	BIT #200,(A)	;IS THIS FILE DELETED?
	BNE COMPF3	;YES, IGNORE IT
	MOV 10(A),C	;NO, THIS IS NO OF BLOCKS TO COPY
	BIC #170000,C
	MOV DSKDAD,D
	BIC #17777,D	;GIVES US WHICH DISK
	BIS D,DSKADR
	BIS D,DSKNSC
COMPF5:	DEC C	;ANY MORE BLOCKS?
	BLT COMPF2	;NO
	JSR E,DSKSEC	;TRANSFER A BLOCK
	DBUFAD
	DSKADR
	DREADC
	INC DSKADR
	JSR E,DSKSEC
	DBUFAD
	DSKNSC
	DWRTEC
	INC DSKNSC
	BR COMPF5
COMPF4:	CLR DSKADR	;SET UP FOR NEW DISK
	CLR DSKNSC
	RTS PC

;COMPRESS DIRECTORY
COMPD:	CMP #-1,DSKNSC	;IS THIS THE FIRST FILE?
	BEQ COMPD1	;YES
COMPD3:	BIT #200,(A)	;THIS FILE DELETED?
	BEQ COMPD4	;NO
	ADD 10(A),DSKNSC	;YES, THAT MANY SECTORS SAVED
COMPD5:	RTS PC
COMPD4:	MOV DBUFPT,C
	MOV #5,B
COMPD6:	MOV (A)+,(C)+
	DEC B
	BGT COMPD6
	MOV C,DBUFPT
	TST -12(A)	;DID WE JUST COPY THE END BLOCK?
	BEQ COMPD2	;YES
	TST (C)	;IS THIS THE END OF THE DIRECTORY BLOCK?
	BGE COMPD5	;NO, JUST RETURN
COMPD7:	JSR E,DSKSEC	;WRITE OUT THIS DIRECTORY BLOCK
	DBUFAD
	DSKADR
	DWRTEC
	INC DSKADR
	INC (C)	;NEXT DIRECTORY BLOCK
	MOV DBUFAD,DBUFPT
	RTS PC
COMPD2:	ADD DSKNSC,-(C)	;NEW NUMBER OF FREE BLOCKS
	BIC #170000,(C)
	JSR PC,COMPD7	;WRITE OUT DIRECTORY BLOCK
	MOV #-1,DSKNSC	;NEXT TIME WILL BE NEW DISK
	RTS PC
COMPD1:	MOV DSKDAD,DSKADR
	DEC DSKADR
	CLR DSKNSC
	MOV DDIRAD,B	;SET UP FOR NEW DISK
	MOV DBUFAD,C
	MOV C,DBUFPT
	MOV #125.,D
	CLR (C)+
	DEC D
	BGT .-4
	MOV 250.(B),(C)	;NUMBER OF DIRECTORY BLOCKS
	BR COMPD3	;GO DO FIRST FILE
	.STITL SCHEDUALER


RUNME:	TST USER
	BGE RUNME1
RUNME2:	RTS PC	;SYSTEM CALLED RUNME
RUNME1:	TST FLSADR(U)	;IF HE WANTS TO RUN HE SHOULD JSR HERE
	BEQ RUNME2	;IF FLSADR IS ZERO, JUST KEEP RUNNING HIM
	MOV #-1,USER	;SYSTEM IS NOW USER
	JSR PC,UACSAV	;STORE HIS ACS
	MOV LFLSAD(U),OFLSAD(U)
	MOV FLSADR(U),LFLSAD(U)
	CLR FLSADR(U)	;GUY IS NOW RUNABLE
	CLR FLSRES(U)
	INC NRABLU
	SPOP UPC(U)	;HE SHOULD START AFTER THE JSR PC,RUNME
NEXTU1:	MOV #SLOTST,A	;TRY TO RUN USER IN U
	CMP #SYSIDX,U	;IS IT THE SYSTEM JOB?
	BNE NEXTU2
	MOV P,SPDLP	;SET UP SYS JOB PDL
	MOV SJPDLP,P
	JMP RUNUS7
NEXTU2:	CMP U,(A)+	;IS HE ASSIGNED A SLOT IN CORE?
	BNE NEXTU3	;NOT THIS ONE, ANYWAY
	TST (A)	;IS HE ALL THE WAY IN?
	BLT NEXTUS	;NO CAN'T RUN HIM YET
	BEQ NEXTU3
	CMP #FRNEWU,FLSRES(U)	;RELOAD USER
	BNE NEXT14
	MOV #UGO,FLSADR(U)	;RESTART HIM
	TST RWWSW	;ALWAYS ZERO?
	BNE NEXT15
	MOV SLTCAD-SLOTST-2(A),C
	MOV #16,D
	JMP NEXT11

NEXT14:	CLR FLSRES(U)
	JMP RUNUSR



;CALL TO GET INDEX OF NEXT USER TO RUN

NEXTUS:	MOV TTYUGO,U	;DID SOMEONE JUST TYPE CR?
	BGE NEXT15
	SUB #LUBLK,ULAST	;COUNT BACKWARDS
	BGE .+10	;DON'T GO NEG
	MOV #MNUSRS*LUBLK,ULAST	;LAST POSSIBLE USER INDEX
	MOV ULAST,U	;SEE IF THIS IS A GOOD GUY TO RUN
NEXT15:	MOV #-1,TTYUGO
	TST FLSADR(U)	;IF FLSADR IS ZERO, RUNABLE(???)
	BEQ NEXTU1	;RUN HIM.
	BLT NEXTUS	;NEG=>NON EX USER
	MOV GUNU,MQ
	BLT NEXT21
	MOV #LUBLK,MULTIP
	CMP U,MQ
	BNE NEXT21
	MOV #-1,GUNU
	MOV U,USER	;USER IS NOW USER
	MOV PC,BRAKE(U)
	JMP GOODBY
NEXT21:	TSTB	FLSRES(U)
	BMI	NEXTUS
	MOV U,USER	;USER IS NOW USER
	JSR PC,UACRES	;RESTORE HIS ACS
	JMP @FLSADR(U)	;SEE IF HE SHOULD REALLY RUN



NEXTU3:	TST (A)+	;EXTANT CORE SLOT?
	BNE NEXTU2	;YES, CHECK NEXT ONE
	MOV PUSPSL,A	;SEE IF THERE IS A PREFERED SLOT
	BGT NEXTU6
NEXT20:	MOV #SLOTST,A
NEXTU4:	TST (A)+
	TST (A)+
	BLT NEXTU4
	BEQ NEXTUS
	CMP #1,-2(A)
	BEQ NEXTU4	;GUY HASN'T RUN YET, DON'T SWAP HIM OUT
	TST NSWPU	;ARE THERE USERS BEING SWAPED?
	BEQ NEXTU6	;NO, SWAP ONE
	CMP NINU,#1	;IS THERE ONLY ONE USER IN CORE?
	BEQ NEXTUS	;YES, RUN HIM
NEXTU6:	MOV -4(A),B	;USER THAT MAY BE SWAPED OUT
	CMP #FRTYIW,FLSRES(B)
	BEQ NEXT17
	MOV #LOCKUS,D
	MOV #NLOCKS,E
NEXT18:	CMP B,(D)+
	BNE NEXT19	;LOCKED IN CORE, DO NOT DISTURB
NEXT17:	TST PUSPSL
	BEQ NEXTU4
	CLR PUSPSL
	BR NEXT20
NEXT19:	DEC E
	BGT NEXT18
	CLR PUSPSL	;IF THERE WAS A PREFERED SLOT, WE ARE DOING IT
	TST -(A)
	MOV -2(A),B	;FOUND A GOOD SLOT, USER TO SWAP OUT INTO B
	MOV U,-2(A)	;NEW OCCUPANT OF SLOT

;FALLS THROUGH

;FALLS IN

NEXTU5:	CLR D
	MOV SLTCAD-SLOTST-2(A),C	;MOBY SWAP OUT BLOCK FOR THIS SLOT
	MOV #SWPOST,(C)+	;SWAP OUT USER START ROUTINE
	MOV USWCNT,(C)+	;WORD COUNT OF A USER SLOT
	MOV SLTCAD-SLOTST(A),(C)+	;SLOT CORE ADDRESS
	MOV USWPAD(B),(C)+	;LOW ORDER SWAP OUT ADDR OF U TO SWAP OUT
	MOV USWPAD+2(B),(C)+	;HIGH OORDER
	TST (C)+	;WASTED WORD
	MOV #DWRTEC,(C)+	;DISK WRITE COMMAND
	INC NDSKRQ
NEXT11:	DEC NINU	;ONE LESS IN CORE
	INC NSWPU	;ONE MORE MOVING AROUND
	MOV #SWPIST,(C)+	;SWAP IN USER START ROUTINE
	MOV USWCNT,(C)+	;SLOT WORD COUT
	MOV SLTCAD-SLOTST(A),(C)+	;SLOT CORE ADDRESS
	CMP #FRNEWU,FLSRES(U)
	BNE NEXT12
	MOV DCLRUS,(C)+	;DISK ADDRESS OF CLEAR USER
	MOV DCLRUS+2,(C)+
	MOV #UGO,FLSADR(U)
	BR NEXT13
NEXT12:	MOV USWPAD(U),(C)+	;  "    "   
	MOV USWPAD+2(U),(C)+	;USER ADDRESS ON DISK
NEXT13:	MOV A,(C)+	;ADDRESS OF PLACE TO ZAP TO 1 WHEN DONE
	MOV #DREADC,(C)	;READ FROM DISK
	INC NDSKRQ
	SUB #32,C	;BEGINING OF MOOBY SWAP REQ PAIR
	ADD D,C		;INDEX TO RIGHT ONE OF PAIR
	SPUSH PS
	MOV #340,PS	;NO INTS!
	MOV C,@SWPLEP
	ADD #2,SWPLEP	;GRONK ONTO REQ LIST
	SPOP PS
	MOV #-1,(A)	;NOT IN YET: -1 TO SLOTST+2 OF GUY
	JSR PC,DPROVK
	BR NEXT10

NEXTU7:	BR .+2	;CHANGE TO WAIT IF ONLY ONE USER
	MOV #-1,USER	;FLUSH ENTERS HERE, SYSTEM NOW USER
	MOV #SLOTST,A	;SEE IF THIS SUPER FLUSHED GUY IS IN CORE
NEXTU8:	CMP U,(A)+
	BNE NEXTU9	;NOT HERE.
	TST (A)+	;IS HE REALLY IN?
	BLE NEXT10	;NO, NOT REALLY
	CMP #FRDSKW,FLSRES	;IF JUST HUNG ON DISK
	BEQ NEXT10	;FORGET HIM
	MOV A,PUSPSL	;HE IS PREFERED OUT
	MOV U,PUSRSP
	BR NEXT10
NEXTU9:	TST (A)+
	BNE NEXTU8
NEXT10:	JMP NEXTUS
FLUSH:	TST USER
	BGE FLUSH4
	RTS PC
FLUSH4:	JSR PC,UACSAV	;STOP USER; STORE HIS ACS
	MOV FLSADR(U),A
	SPOP FLSADR(U)	;SAVE PC
	TST A	;IS THIS GUY ALREADY STOPED?
	BNE NEXTU7	;GO TRY ANOTHER GUY
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
	MOV #-1,USER
	ADD UTIME,JMTU(U)
	TST FLSRES(U)
	BNE .+10
	MOV #FRRAND,FLSRES(U)
	DEC NRABLU
	CMP #SYSIDX,U
	BEQ FLUSH7
	MOV P,UPDLP	;SAVE USER'S POINTER
	MOV SPDLP,P	;SYSTEM PDL
FLUSH3:	.IFNZ DEBUG
	CMP #FRJIG,FLSRES(U)
	BNE FLUSH5
	TST NDSKRQ
	BNE FLUSH5
	CMP #1,NSLOTS
	BGE FLUSH5
	MOV #LOCKUS,A
	MOV #NLOCKS,B
JIG1:	CMP U,(A)+
	BEQ FLUSH5
	DEC B
	BNE JIG1
	MOV SLTCAD+2,A
	MOV SLTCAD+6,B
	MOV B,SLTCAD+2
	MOV A,SLTCAD+6
	MOV USWCNT,C
JIG2:	MOV (A),D
	MOV (B),(A)+
	MOV D,(B)+
	INC C
	BNE JIG2
	.ENDC
FLUSH5:	JMP NEXTUS
FLUSH7:	MOV P,SJPDLP
	MOV SPDLP,P
	JMP NEXTUS
	.IFNZ DEBUG
JIGLR:	TST JIGSW
	BEQ JIGLR1
	SPUSH U
	MOV USER,U
	MOV #FRJIG,FLSRES(U)
	JSR PC,FLUSH
	JSR PC,RUNME
	SPOP U
JIGLR1:	RTS PC
	.ENDC
	.IFNZ DEBUG
JIGLER:	TST JIGSW
	BEQ NOJIG
	SPUSH U
	MOV USER,U
	MOV #FRJIG,FLSRES(U)
	JSR PC,FLUSH
	JSR PC,RUNME
	SPOP U
NOJIG:	RTS PC
	.ENDC
;RUNUSR, THE "MAIN LOOP"

RUNUSR:	CMP U,PUSRSP	;AM I THE GUY THEY WANT OUT?
	BNE .+6	;BRANCH IF NO
	CLR PUSPSL	;I DON'T WANT TO GO!
	INC (A)	;INDICATE THAT THIS GUY HAS BEEN RUN
	BVC .+6
	MOV #2,(A)
	MOV SLTCAD-SLOTST(A),D	;SLOT ADDRESS THIS GUY IS IN
	MOV D,BASEUS
	MOV P,SPDLP	;SAVE SYSTEM PDL POINTER
	MOV UPDLP,P	;GET USER PDL POINTER
RUNUS7:	MOV U,USER	;NOW HE'S REALLY THE GUY
	SPUSH UPC(U)	;PLACE TO START USER
	MOV QUANT,UQUANT	;RUN FOR 3 1/100TH'S????
	CLR UTIME
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
	JMP UACRES	;RESTORE USER ACS AND START USER


SCHEDP:	TST UQUANT	;SEE IF IT'S TIME TO FLUSH
	BLE .+4	;NOT YET
	RTS PC
	SPUSH U
	MOV USER,U
	MOV #FRSCED,FLSRES(U)
	JSR PC,FLUSH
	JSR PC,RUNME
	SPOP U
	RTS PC
.STITL CLOCK BREAK ROUTINE

CLKBRK:	SPUSH A
	SPUSH B
	SPUSH	C
	ADD #40,UTIME
	INC TIME
	BNE CLKTOV
	INC TIME+2
CLKTOV:	DEC UQUANT
	JSR PC,DPROVK
	DEC (PC)+	;HAS THIS BEEN ONE SECOND?
N50THS:	CLKFRQ
	BLE DATEC	;YES, CHANGE THE SECOND
	;NEXT FIVE LINES ARE FOR TESTING DISPLAY
CLKBR1:
	.IFZ NDISP
	BR CLKB11
	.ENDC
	.IFNZ NDISP
	DECB	DISTIM	;TIME (HO HUM) TO START THE DISPLAYS?
	BGT	CLKB11	;NO
	MOVB	#1,DISTIM
	MOV	#NDISP-1,C
	ASL	C	;TO USE AS INDEX
	CLR	B
CLKDIS:	CMP	B,C	;ALL DISPLAYS CHECKED?
	BGT	CLKB11
	MOV	DSTAT(B),A
	TST	(B)+
	TST	A
	BLT	CLKDIS	;THIS ONE INACTIVE
	MOV	A,NGCSR
	BIT	#TKRUN,NGCSR
	BNE	CLKDIS	;STILL RUNNING
	BIS #TKGO,A
	MOV A,NGCSR
	BR	CLKDIS
	.ENDC

DATEC:	DEC DKPWFR
	BGT .+10
	MOV #-20.,DKNRTY
	MOV #CLKFRQ,N50THS
	MOV #MNUSRS,A
	CLR B
	SPUSH C
JMTUD2:	MOV JMTU(B),C
	BEQ JMTUD1
	ASR C
	ASR C
	ASR C
	INC C
	SUB C,JMTU(B)
	BGE .+6
	CLR JMTU(B)
JMTUD1:	ADD #LUBLK,B
	DEC A
	BNE JMTUD2
	SPOP C
	MOVB RMONTH,A
	MOVB DMON(A),DAYLIM
	MOV #SECLIM,A
	MOV #RSEC,B
DATEC1:	INCB (B)
	CMPB (A)+,(B)
	BGT CLKBR1
	CLRB (B)+
	BR DATEC1

CLKB11:
CLKBDM:	BIT	#1,TIME	;EVERY OTHER BREAK (=1/25 SEC)
	BNE	CLKQBK	;
.IFNZ	NDMTY
	JSR	PC,DMSQ
.ENDC
	JSR	PC,TI2Q

CLKQBK:	DEC	@CLKQT
CLKQB1:	TST	@CLKQT
	BNE	CLKQB2
	MOV	CLKQT,A
	MOV	2(A),CLKQT	;PUT NXT BLK AT TOP OF Q
	JSR	PC,@4(A)		;DO CURRENT REQUEST
	BR	CLKQB1
CLKQB2:	MOV	#-1,CLKINF
	SPOP	C
	SPOP B
	SPOP A
	RTI

CLKQT:	CLKINF
CLKINF:	-1
	0
	CLKINE

CLKINE:	JSR	A,SPRINT
	BPRTXT	^/CLKQBK RAN CLKINE/
	PRCR
	SPREND
	MOV	#-1,CLKINF
	RTS	PC

.STITL	CLOCK QUEUE ROUTINES

;CLKQAD --
;CLOCK QUEUE ADD
;WORKS ONLY AT CLK BRK LEVEL OR LOWER 
;ADD BLOCK POINTED TO BY A TO SYSTEM CLOCK QUEUE
;1ST WD # OF TICKS TO WAIT
;2ND WD EMPTY (USED BY SYSTEM)
;3RD WD ADDR TO JSR TO

CLKQAD:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST CLKQ ENTRY
	MOV	(C),D
	BR	CLKQA2

CLKQA1:	MOV	D,C	;PNT C TO NEXT BLK
	MOV	2(D),D	;PNT D TO ONE AFTER
	SUB	(C)+,(A)	;MAKE TIME IN A BLK REL TO C BLK
CLKQA2:	TST	2(D)
	BEQ	CLKQA3	;BR IF NO MORE BLKS LEFT 
	CMP	(A),(D)
	BHI	CLKQA1
CLKQA3:			;INSRT ABLK BETWEEN C BLK AND D BLK
	MOV	D,2(A)	;PNT A BLK TO D BLK
	MOV	A,(C)	;PNT C BLK TO A BLK
	SUB	(A),(D)	;MAKE D TIME REL TO A TIME

CLKQRS:	SPOP	D
	SPOP	PS
	SPOP	C
	RTS	PC

CLKQSV:	SPUSH	PS
	MOV	PCBRV+2,PS	;RUN AT CLK BK LEVEL
	SPUSH	D
	JMP	(C)

;CLKQDL--
;CLOCK QUEUE DELETE
;DELETE BLOCK POINTED TO BY A FROM CLOCK Q

CLKQDL:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST ENTRY
	BR	CLKQD2
CLKQD1:	MOV	(C),C	;GET NEXT ENTRY
	TST	(C)+	;MAKE IT POINT TO NEXT+1 ENTRY
	TST	(C)	
	BEQ	CLKQD3	;BRANCH IF NO MORE ENTRIES
CLKQD2:	CMP	A,(C)	;IS THIS THE ENTRY WE WANT
	BNE	CLKQD1	;NO
	ADD	(A),@2(A)	;INCREASE TIME IN NEXT BLK
	MOV	2(A),(C)	;CORRECT PNTR IN PREV BLOCK
CLKQD3:	JMP	CLKQRS

TIME:	0
	0
DISTIM:	.BYTE	1
SECLIM:	.BYTE 60.
MINLIM:	.BYTE 60.
HORLIM:	.BYTE 24.
DAYLIM:	.BYTE 0
MONLIM:	.BYTE 12.
YERLIM:	.BYTE 177
RSEC:	.BYTE 0
RMIN:	.BYTE 0
RHOUR:	.BYTE 0
RDAY:	.BYTE 0
RMONTH:	.BYTE 0
RYEAR:	.BYTE 0

DMON:	.BYTE 30.,27.,30.,29.,30.,29.,30.,30.,29.,30.,29.,30.
	.EVEN


UTIMEG:	MOV #RHOUR+1,D
	CLR E
	BR UTIME1
UDATEG:	MOV #RYEAR+1,D
	MOV #1,E
UTIME1:	MOV #3,F
UTIME2:	MOVB -(D),B
	ADD E,B
	JSR PC,PSHNUM
	DEC F
	BGT UTIME2
	SPUSH #3
	JSR PC,SENTENCE
	.BUG.
	SKPRET

PEEK:	CLR E
	PRTXT ^\
USER  %TIM  FLSRES
\
	MOV #MNUSRS,F
PEEK1:	MOV E,A
	JSR PC,PRDN
	PRTXT ^\     \
	MOV JMTU(E),MQ
	MOV #1.,DIVIDE
	MOV MQ,A
	JSR PC,PRDN
	PRTXT ^\   \
	MOV FLSRES(U),A
	JSR PC,PRON
	MOV #15,D
	JSR PC,TYO
	ADD #LUBLK,E
	DEC F
	BNE PEEK1	;NEXT USER
	MOV NRFERS,A
	JSR PC,PRDN
	PRTXT ^\  FIXED HEAD ERRS  \
	MOV NRKERS,A
	JSR PC,PRDN
	PRTXT ^\  MOVING HEAD ERRS
\
	RTS PC

CLOCK:	MOV TIME+2,A
	MOV TIME,B
	JMP R1I.N

UWAIT:	JSR PC,G1IARG
	ADD TIME,C
	ADC B
	ADD TIME+2,B
	MOV USER,U
UWAIT1:	JSR PC,FLUSH
	TST BRAKE(U)
	BNE UWAIT2
	MOV B,A
	MOV C,D
	SUB TIME,D
	SBC A
	SUB TIME+2,A
	BGE UWAIT1
UWAIT2:	JSR PC,RUNME
	JMP NORT

SETTV:	JSR PC,CKSST
	JSR PC,G1IARG
	SPUSH C
	JSR PC,G1IARG
	TST C
	BLT SETTV1
	CMP #6,C
	BLE SETTV1
	CMPB (P),SECLIM(C)
	BGT SETTV1
	MOVB (P),RSEC(C)
	TST (P)+
	JMP NORT
SETTV1:	ERROR+NTL
	.STITL	SWAP START+STOP ROUTINES

SWPOST:	CLR (A)
	ADD #16,SWPLST
	RTS PC

SWPIST:	MOV #SWPISP,(A)	;SWAP IN START, SET UP STOP
	RTS PC

SWPISP:	CLR UQUANT	;SCHED REAL SOON
	MOV #1,@12(A)	;THIS GUY IS IN AND NOT RUN YET
	SUB #2,SWPLEP
	SPUSH A
	MOV #SWPLST+2,A
	MOV #SWPLST,B
	MOV (A)+,(B)+
	BNE .-2
	INC NINU	;ONE MORE GUY IN
	DEC NSWPU	;ONE LESS GUY MOVING
	SPOP A
	RTS PC
	.STITL MISC ROUTINES

ACSAV:	MOV E,-(P)
	MOV D,-(P)
	MOV C,-(P)
	MOV B,-(P)
	MOV A,-(P)
	JMP (F)

ACRES:	TST (P)+
	MOV (P)+,A
	MOV (P)+,B
	MOV (P)+,C
	MOV (P)+,D
	MOV (P)+,E
	RTS F

UACSAV:	MOV A,UACA(U)
	MOV B,UACB(U)
	MOV C,UACC(U)
	MOV D,UACD(U)
	MOV E,UACE(U)
	MOV	AC,UAC(U)
	MOV	MQ,UMQ(U)
	MOV	SR,USR(U)
	RTS PC

UACRES:	MOV UACA(U),A
	MOV UACB(U),B
	MOV UACC(U),C
	MOV UACD(U),D
	MOV UACE(U),E
	MOV	UMQ(U),MQ
	MOV	UAC(U),AC
	MOV	USR(U),SR
	RTS PC



PPUSHT:	JIGGLE
	CMP P,#PPUSHL
	BLOS .+4
	RTS PC
	BIT #177000,P	;IS IT THE SYSYTEM PDL?
	BNE .+4
	RTS PC	;YES, IGNORE
	JMP PPSWPO	;PDL REALLY OVERFLOWED

PPOPT:	JIGGLE
	CMP P,PPOPL
	BHIS .+4
	RTS PC
	JMP PPSWPI

SPUSHT:	JIGGLE
	SUB #2,S
	CMP S,#SPUSHL
	BLOS .+4
	RTS PC
	JMP SPSWPO

SPOPT:	ADD #2,S
SPOPT1:	JIGGLE
	CMP S,SPOPL
	BHI .+4
	RTS PC
	JMP SPSWPI

.SPACE:	PRTXT ^\ \
	RTS PC

.CRLF:	JSR	A,ERTAS	;PRTXT \^M\
	15
	RTS	PC
	.STITL P AND S PDL SWAP OUTERS

PPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	.BUG.	;WHAT, NO DISK SPACE
	SPUSH B	;SAVE ADDRESS
	JSR E,DSKSEC
	PSWPAD
	DBGRBD
	DWRTEC
	SPOP IP
	BIT #PPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,PPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #PPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IP,A
	MOV PSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,P
	BHIS .-4
	ADD #PDSWOP,P	;PDL HAS MOVED!
	ADD #PDSWOP,PRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC


SPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	.BUG.	;WHAT, NO DISK SPACE
	SPUSH B	;SAVE ADDRESS
	JSR E,DSKSEC
	SSWPAD
	DBGRBD
	DWRTEC
	SPOP IS
	BIT #SPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,SPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #SPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IS,A
	MOV SSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,S
	BHIS .-6
	ADD #PDSWOP,S	;PDL HAS MOVED!
	ADD #PDSWOP,SPRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC

	.STITL P AND S PDL SWAPER INERS
PPSWPI:	BIT #PPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV PSWPAD,A
	MOV A,B
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,P
	BHI .-4
	SUB #PDSWOP,P
	SUB #PDSWOP,PRBAO
	MOV IP,C
	MOV C,DBGRBD
	JSR E,DSKSEC
	PSWPAD
	DBGRBD
	DREADC
	MOV #IP,D
	TST (D)
	BNE PSWPI2
	BIC #PPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW, THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,PPOPL
PSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC

SPSWPI:	BIT #SPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV SSWPAD,A
	MOV A,B
	MOV (A),(B)
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,S
	BHI .-6
	SUB #PDSWOP,S
	SUB #PDSWOP,SPRBAO
	MOV IS,C
	MOV C,DBGRBD
	JSR E,DSKSEC
	SSWPAD
	DBGRBD
	DREADC
	MOV #IS,D
	TST (D)
	BNE SSWPI2
	BIC #SPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW, THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,SPOPL
SSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC


PPTA:		;POP PP PDL TO (A) RELATIVE
		;USES A,F
	JIGGLE
	SPOP F
PPTA1:	CMP A,PRBAO
	BHIS PPTA3
	MOV PPOPL,P
	JSR PC,PPSWPI
	BR PPTA1
PPTA3:	SUB PRBAO,A
	SUB #IP,A
	NEG A
	CMP A,P
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,P
	JSR PC,PPOPT
	JMP @F
PSTA:		;POP S PDL TO (A) RELATIVE
		;USES A
	JIGGLE
	CMP A,SPRBAO
	BHIS PSTA3
	MOV SPOPL,S
	JSR PC,SPSWPI
	BR PSTA
PSTA3:	SUB SPRBAO,A
	SUB #IS,A
	NEG A
	CMP A,S
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,S
	JMP SPOPT1
.STITL INITIALIZE NODE SPACE
;ON ENTRY B = START OF FREE NODES NODE #
;	C = " " " " NODE ADDRESS
;	D = FIRST WORD AFTER END OF SLOT
INIT1:	INC B
	INC NNGC
	BIT #10000,B	;HIGHEST POSSIBLE NODE ADR + 1
	BNE INIT2
	MOV B,(C)
	BIS #IDLE,(C)+
	CLR (C)+
	CMP D,C
	BHI INIT1
	SUB #4,C	;BACK UP: PREVIOUS NODE IS LAST FREE
INIT2:	MOV #IDLE,(C)+
	CLR @C
	MOV NNGC,NNIFSL
	MOV B,NUNODE	;NUMBER OF NODES PER USER
	BIS #PADERF,FLAGS2	;SO OCTAL ERROR ADDR IS PRINTED
	MOV #UVBLK,A	;TO INITIALIZE USER VARIABLES IN SWAPPED OUT USERS
	MOV #SLOT1,B	;SET UP FOR BLT
SETUVS:	MOV (A)+,(B)+	;BLLLLLLLLLLLLLLLLLT
	CMP #UVBLK+LUVBLK,A
	BHI SETUVS
	TST RWWSW
	BNE STARTF
	JSR PC,SYDRBG	;GET A SYSTEM DISK REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV USWCNT,(A)+	;LENGTH OF A USER SLOT
	MOV #SLOT1,(A)+	;SWAP OUT SLOT1
	MOV DCLRUS,(A)+	;GETS PUT INTO THE CLEAR USER PLACE
	MOV DCLRUS+2,(A)+
	CLRB 1(A)
	TST (A)+
	MOV #DWRTEC,(A)
STARTF:	MOV	NUSERS,NUSER2
	ASL	NUSER2
	JMP	TINIT

INIT3:	HALT

UGO:	JSR PC,RUNME
	TST JIGSW
	BNE UGODBG
	CPRTXT ^/WELCOME TO 11LOGO /
	MOV LVERNF,A
	JSR PC,PRDN
	TST DEBSW
	BEQ UGO1	;IF DEBUG SWITCH IS ON
		;PRINT MESSAGE
	CPRTXT ^/LOGO BEING DEBUGGED!/
UGO1:	PRTXT ^/ USER # /
UGODBG:	MOV USER,MQ
	MOV #LUBLK,DIVIDE
	MOV MQ,A
	JSR PC,PRON
	PRCR		;PRINT CR
RSTART:
;	MOV SALTL,ALTL
TEST1:
MLOOP:	JSR	PC,UCHECK	;CHECK SOME USER VARIABLES
	JSR PC,SCHEDP
	BIC #HERRF,FLAGS2
	MOV	USER,U
	TST BRAKE(U)
	BEQ .+4
	ERROR+BRK
	JSR PC,GETSTR
	JSR PC,MREAD
	BR MLOOP	;NO TOKEN LIST
	JSR PC,EVLINE
	ERROR+WDW	;WHAT SHOULD I DOO WITH (S)
	POPS A	;EVLINE LEAVES PTR TO TOKEN LIST ON S
	BR MLOOP
RUNRUG:	JSR PC,CKSST
	BPT
	BR .+2	;RUG  SHOULD RETURN HERE IF $P'ED
	BR .+2
	JMP NORT

SYSJOB:	JSR PC,FLUSH
	BR SYSJOB


;CHECK SOME USER VARIALBES -- DEBUGGING FEATURE
UCHECK:	TST	NODESP
	BNE	UCHEC1
	TST	NODESP+2
	BEQ	UCHEC2
UCHEC1:	TST	(P)+	;POP STACK SO IT LOOKS LIKE BUG CAME FROM CALLING ROUTINE
	.BUG.	;1ST 2 WORDS OF NODE SPACE NOT ZERO
UCHEC2:	RTS	PC
	.STITL GET A STRING

GSTR9:	MOV CPLN,B
	JSR PC,GTLINE
	ERROR+LDE	;LINE ..(B).. DOESN'T EXIST
	MOV C,A
	BR GSTR8

GETSTR:	TST FUNLEV	;ARE WE IN A PROC
	BEQ GSTR0	;NO
	BIT #BRKF,FLAGS	;ERROR, MAYBE
	BNE GSTR0	;YES
	MOV CLP,B	;NO, GET THIS NODE OF LLP
	BEQ GSTR9
	JSR PC,.LOAD
	BIT #7777,A	;IS IT LAST NODE
	BNE GSTR8
	SPOP A		;POP RETURN ADDR
	JMP PSTOP
GSTR8:	MOV A,CLP
	MOV A,C
	JSR PC,.LOADC
	JSR PC,.LOAD	;OK, GET FIRST NODE OF LINE, = LINE #
	MOV B,CPLN
	MOV A,CTP	;IN CASE THERE IS NO GENERATION #
	MOV A,C
	JSR PC,.LOADC	;GET SECOND NODE
	CLR CLGN	; IF TYPE = SNUM, IT IS GEN #
	MOV A,C
	BIC #7777,C
	CMP #SNUM,C
	BNE GSTR6
	MOV B,CLGN	;IT IS
	MOV A,CTP
;FALLS THROUGH

;FALLS IN
GSTR6:	BIS #LIST,CTP
	PUSHS CTP
	BIT #TRACEF,FLAGS2
	BEQ GSTRT
	CPRTXT ^\ #\
	MOV CPP,B
	JSR PC,PPNAME	;PRINT PNAME
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRCR
	JSR PC,PRLN
GSTRT:	RTS PC


GSTR0:
	FOR 0
	BIT #TESTF,FLAGS2
	BEQ GSTR1
	MOV ALTL,A
	MOV (A)+,B
	BEQ DONE
	MOV A,ALTL
	PUSHS B
	CPRTXT ^/TEST LINE /
	INC LINENO
	MOV LINENO,A
	JSR PC,PRDN
	PRCR
	JSR PC,PRLN
	CLR FLAGS
	CLR CO
	CLR CO+2
	CLR NOR
	RTS PC
	POP A	;GET RETURN ADDR
	PUSH #1
	JMP @A
DONE:	PRTXTC ^/ALL DONE!/
	SPOP A	;CROCK!!!
	JMP RSTART	;BLECTCH?
	.ENDC
	ENDC 0
GSTR1:	JSR PC,RDSTR
	BR GSTR2
	BR GSTRT
GSTR2:	BIT #RBRKF,TFLAGS
	BEQ GSTR1
	ERROR+BRK
	.STITL MORE READ ROUTINES!!!
MREAD:	TST FUNLEV	;ARE WE IN PROC?
	BEQ MRD1	;NO
	BIT #BRKF,FLAGS	;YES, BUT ERROR?
	BNE MRD1	;YES
	SKPRET
MRD1:	JMP READ	;CONVERT CHAR STRING TO TOKEN LIST
CKSTG:	;CKECK IF DISC OR NODES ARE ALMOST GONE
	BIT #DSAMFL,FLAGS2
	BEQ .+4
CKSTG1:	ERROR+NSL	;NO STORAGE LEFT!!
	CMP NNIFSL,#NBN
	BHIS CKSTG2
	JSR PC,.GCOLL
	CMP NNIFSL,#NBN
	BLO CKSTG1
CKSTG2:	RTS PC
	.STITL EVAL 1 LINES

TBF1:	JSR	PC,BRAKR	;BREAK
	JMP ERTLN

EVLINE:	MOV	USER,U	;EVALUATES 1 LINE ON S
	TST	BRAKE(U)
	BEQ .+4
	ERROR+BRK
	TST TOPRNM
	BNE EVLI4
EVLI6:	JSR PC,IGNT
EVLI1:	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,EVAL
	BR EVLI3	;NO OUTPUT, OK
	JSR PC,CKSTG
	RTS PC
EVLI3:	JSR PC,CKSTG
	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,GNT
	BIS #RTF,FLAGS
	BR EVLI1
EVLI4:	JSR PC,CKSTG
	MOV @S,B
	JSR PC,.LOAD
	MOV A,D
	BIC #7777,A
	CMP #SNUM,A
	BEQ EVLI5	;AN SNUM
	CMP #INUM,A
	BEQ EVLI8	;AN INUM
	CMP #LSTR,A
	BNE EVLI6	;NOT AN SNUM, INUM OR LSTR
	JSR PC,.CLSIN	;CONVERT LSTR TO INUM
	BR EVLI6	;NOT NO. OR TOO BIG
EVLI8:	BIT #SPDF,FLAGS	;IS THIS PROC DEF. BEING SKIPPED?
	BNE EVLI9
	JSR PC,.CINSN	;CONVERT INUM TO SNUM
	BR EVLI7	;TOO BIG
	TST B	;IS NO. TOO SMALL?
	BGT .+4
	ERROR+LNTS
	MOV D,A
	BIC #170000,A	;MAKE IT INTO AN SNUM
	BIS #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	MOV C,@S
EVLI5:	JSR PC,ADLN
EVLI9:
EVLI2:	SKPRET
EVLI7:	ERROR+LNTB	;LINE # TOO BIG
	.STITL GET NEXT TOKEN

GNT:	BIT #RTF,FLAGS	;IS REPEAT TOKEN FLAG SET?
	BEQ GNT1
	BIC #RTF,FLAGS	;YES
	MOV CT,A
	MOV CT+2,B
	BNE GNT6
	CMP #SFUN,A
	BNE GNT6
	BIS #CRF,FLAGS
GNT6:	RTS PC
GNT1:	BIC #PTLPF,FLAGS
	CMP #$LLPAR,CT+2	;IS CT "("
	BEQ GNT3
	CMP #$LPAR,CT+2
	BNE .+8.
GNT3:	BIS #PTLPF,FLAGS	;YES, SET PTLPF
	MOV CT,B	;GET LINK TO NEXT TOKEN
	MOV B,CTP
	BIT #7777,B
	BEQ GNT2	;ANY TOKENS LEFT
	JSR PC,.LOAD	;YES
	INC CTN
GNT4:	MOV A,CT
	MOV B,CT+2
	RTS PC
GNT2:	BIT #CRF,FLAGS
	BNE GNT5
	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR GNT4
GNT5:	ERROR+OOT	;OUT OF TOKENS
IGNT:	MOV @S,B	;INIT "GNT"
	BIT #7777,B
	BEQ IGNT1
	BIC #CRF,FLAGS
	MOV B,CTP
	JSR PC,.LOAD
IGNT2:	MOV A,CT
	MOV B,CT+2
	BIS #RTF,FLAGS
	MOV #1,CTN
	RTS PC
IGNT1:	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR IGNT2
UTYI:	WAIT
	TST CHI
	BEQ UTYI
	MOVB CHI,D
	CLR	CHI
	BIC #177600,D
TYO:	JMP @#STYO

TYI:	JMP @#STYI
STYI:	WAIT
	TSTB TKS
	BPL STYI
	MOVB TKB,D
	BIC #177600,D
STYO:
UTYO:	TSTB TPS
	BPL .-4
	MOVB D,TPB
	CMP #15,D
	BNE UTYOR
	MOV #12,D
	JSR PC,STYO
	MOV #15,D
UTYOR:	RTS PC
CHI:	0

;SPRINT-- START SYSTEM PRINT.  CALL WITH JSR A,
SPRINT:	SPUSH	USER
	MOV	#-1,USER
	JMP	(A)
;RESTORE WITH SPREND

;PRINT LOCATIONS ON SYSTEM CONSOLE
;CALL WITH JSR B,
;	LOCS TO BE PRINTED
;	0
PLOCS:	JSR	A,SPRINT	;START SYS PRINT
	BPRTXT	;RING BELL, C.R.
PLOCS1:	JSR	PC,PLOC
	TST	(B)+
	TST	(B)
	BNE	PLOCS1
	SPREND	;END SYSTEM PRINT
	TST	(B)+
	RTS	B

;PRINT (B)/ @(B)
PLOC:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	(B),U
PLOC1:	MOV	(U),D
	JSR	PC,PGEN1	;PRINT (U)/ (D)
	SPOP	U
	SPOP	D
	SPOP	A
	RTS	PC

;PRINT B/(B)
PLOCB:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	B,U
	BR	PLOC1
	.STITL	GARBAGE COLLECTOR
NNODES==4096.
GCBTL== NNODES/8./2.*2.+2.	;GARBAGE COLLECT BIT TABLE LENGTH

MARKN:	SPUSH A	;MARK NODE(B)
	SPUSH B
;DEBUGGING FEATURE
	JSR PC,.LOAD	;ARE WE MARKING AN IDLE NODE
	BIC #7777,A
	CMP #IDLE,A
	BNE .+4
	.BUG.
	MOV (P),B
;
	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASR A
	ASR A
	ASR A
	ADD #GCBITS,A
	BITB B,(A)	;ALREADY MARKED?
	BEQ MARKN1	;NO
	SPOP B
	SPOP A
	RTS PC
MARKN1:	BISB B,(A)
	SPOP B
	SPOP A
	ADD #2,(P)
	RTS PC

BMT:	.BYTE 1,2,4,10,20,40,100,200
LMT:	MKL3	;SYSTEM FUNCTION
	MKL3	;INFIX (SYSTEM FUNCTION)
	MKL3	;USER FUNCTION
	MKL3	;VARIABLE BINDING
	GCDIE	;UNUSED
	GCDIE	;UNUSED
	GCDIE	;UNUSED
	MKSSTR	;SHORT STRING
	.IFNZ NDISP
	MKSNAP	;SNAP
	.ENDC
	.IFZ NDISP
	GCDIE
	.ENDC
	MKL3	;ATOM
	MKL3	;SHORT NUMBER
	MKINUM	;INTEGER NUMBEB
	MKLIST	;LONG STRING
	GCDIE	;TBA
	MKLIST	;SENTENCE
	MKLIST	;LIST

MARKL:	PUSH A	;MARK LIST
	SPUSH B	;NODE ADDS IN B
	SPUSH C
	JSR	PC,MKLIST
	BR MARKV1

MARKV:	PUSH	A	;MARK VARIABLE
	SPUSH	B	;NODE ADDS IN B
	SPUSH	C
	CLR	A
	MOV	B,C
	JSR	PC,MARKF1	;TREAT POINTER AS A FIRST PTR
MARKV1:	SPOP C
	SPOP B
	POP A
	RTS PC

MARKF:	MOV A,C	;MARK FIRST OF A DATUM (NODE) IN A,,B
MARKF1:	BIT #DSAMFL,FLAGS2
	BEQ MARKF2	;DISK NOT ALMOST FULL
	TST DSKNCH
	BEQ MARKF3
	JSR E,GBITGS	;SET DISK BUFFER BACK UP
	DREADC
MARKF3:	TST SSAVEA	;TOP OF SPDL SWAPPED OUT FOR MARKING?
	BEQ MARKF4	;NO
	JSR E,DSKSEC	;YES, SWAP IT BACK IN
	SSWPAD
	SSAVEA
	DREADC
	MOV SSAVEA,C	;FREE THE REQUEST BLOCK
	CLR SSAVEA	;CLEAR THIS: IT WORKS AS A FLAG
	JSR PC,UBLKFR	;(NOW FREE IT)
MARKF4:	.IFNZ NDISP
	ADD #2,S	;POP SNLIST OFF S PDL
	.ENDC
	JSR E,LCUGRB	;UNLOCK GC SWITCH
	GCLOCK
	ERROR+NSL
MARKF2:	BIC	#7777,C	;A TELLS WHAT TYPE OF DATUM IT IS
	SWAB	C
	ASR	C
	ASR	C
	ASR	C	;ALL THIS GIVES YOU THE TYPE*2
	JMP	@LMT(C)	;WHICH YOU MIGHT MARK ON

	.IFNZ NDISP
MKSNAP:	JSR	PC,MKDC	;MARK DISPLAY CODE
	.ENDC
MKLIST:	BIT	#7777,B	;IS THIS NODE REALLY HERE?
	BEQ	MKL3	;NO. RETURN
MKL1:	PUSH	A	;SAVE BUTFIRST OF CURRENT (I.E. PARENT) NODE
	JSR	PC, MARKN	;MARK NEXT NODE
	BR MKL2
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	JSR	PC,MARKBF	;MARK BUTFIRST OF  NEWTHIS NODE
MKL2:	POP A
	RTS PC

MKINUM:	JSR	PC,MARKN
	BR .+2
MKSSTR:
MKL3:	RTS	PC

GCDIE:	ERROR+FBUG

MARKBF:	BIT	#7777,A	;MARK BUTFIRST OF LIST
	BEQ	MKL3	;AT END OF LIST
MKBF1:	MOV	A,B
	JSR	PC, MARKN	;MARK NEXT NODE
	BR MKL3	;ALREADY MARKED, QUIT
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	BR	MARKBF	;MARK BUTFIRST OF  NEW NODE


.GCOLL:	JSR F,ACSAV
	MOV USER,U
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
	TST DSKNCH	;ARE THE DISK BUFFERS IN USE?
	BEQ .GCOL2
	JSR E,GBITGS	;SAVE THE BUFFERS
	DWRTEC
.GCOL2:	JSR E,LCGRAB
	GCLOCK
	MOV #GCBITS,A	;GARBAGE COLLECT
	MOV #GCBTL/2-1,B	;CLEAR BIT TABLE
	MOV #1,(A)+	;ALWAYS PROTECT NODE ZERO
.GCOL1:	CLR (A)+
	DEC B
	BGT .GCOL1
	CLR SSAVEA	;MAKE SURE THIS IS CLEAR
	.IFNZ NDISP
	PUSHS	SNLIST	;PROTECT THESE LOSERS
	.ENDC
	MOV #UHCT,E	;ADDRESS OF HASH TABLE
MKUOBL:	MOV (E)+,D	;GET A USER OBLIST BUCKET
	BLT MKTPS	;NO MORE
MKUOBI:	MOV D,C		;GET NEXT NODE IN THIS BUCKET
	BEQ MKUOBL	;NO MORE
	MOV D,B		;MARK THE NODE
	JSR PC,MARKN
	BR .+2
	JSR PC,.LOADC	;GET THE NODE, CONTAINS UOE POINTER
	MOV A,D
	MOV B,C
	JSR PC,MARKN	;MARK NODE POINTED TO BY THIS ONE
	BR .+2
	JSR PC,.LOADC	;THEN GET IT
	JSR PC,MARKL	;SHOULD BE PNAME POINTER NODE OF UOE
	MOV A,C
MKUOE:	BIT #7777,C	;ONE OTHER NODE?
	BEQ MKUOBI	;NO
	MOV C,B	;YES
	JSR PC,MARKN	;MARK IT
	BR .+2
	JSR PC,.LOADC
	MOV A,C
	BIC #7777,A
	CMP #FBIND,A
	BEQ MKFB	;FUNCTION BINDING
	CMP #VBIND,A
	BEQ MKVB	;VARIABLE BINDING
	CMP #SVBIND,A
	BEQ MKSVB	;SWAPPED VB
	.BUG.		;BUG
MKVB:	JSR PC,MARKV	;MARK VARIABLE
	BR MKUOE
MKFB:	JSR PC,MARKL
	BR MKUOE
MKSVB:	BR MKUOE


MKTPS:	MOV #GCMKL,F
MKRNDM:	MOV (F)+,B	;POINTER TO POINTER
	BEQ MKSPDL	;LAST ONE
	MOV (B),B	;REAL NODE ADDRESS
	BEQ MKRNDM	;NOTHING THERE
	BIT #170000,B	;IS TYPE FIELD BLANK
	BEQ MKRND1	;YES, MAKE IT LIKE LIST
	JSR PC,MARKV	;MARK VARIABLE
	BR MKRNDM
MKRND1:	JSR PC,MKL1
	BR MKRNDM
MKSPDL:	MOV #IS,E
MKSP1:	MOV -(E),B	;GET A S PDL WORD
	CMP E,S	;END OF S PDL?
	BLO MKSP2	;YES
	JSR PC,MARKV	;MARK S PDL WORD
	BR MKSP1
MKSP2:	TST IS
	BEQ MKSP4
MKSP3:	JSR PC,UBLKGR
	.BUG.
	MOV B,SSAVEA
	JSR E,DSKSEC
	SSWPAD
	SSAVEA
	DWRTEC
MKSP8:	TST IS
	BEQ MKSP6	;NO
MKSP5:	MOV IS,DBGRBD
	JSR E,DSKSEC
	SSWPAD
	DBGRBD
	DREADC
	MOV #176,F
	MOV #IS,E
MKSP7:	MOV -(E),B	;MARK THIS PIECE OF S PDL
	JSR PC,MARKV
	DEC F
	BGT MKSP7
	BR MKSP8

MKSP6:	JSR E,DSKSEC
	SSWPAD
	SSAVEA
	DREADC
	MOV SSAVEA,C
	CLR SSAVEA	;SWAPPED BACK IN
	JSR PC,UBLKFR
MKSP4:



	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;IF GUY HAS DISPLAY
	BEQ	GCDIS2
	JSR PC,DSGCF		;GCOLL IT, TOO
GCDIS2:	ADD #2,S	;TO GET RID OF GUY PUSHED BEFORE
GCDIS:
	.ENDC


		;OK NOW RETURN ALL IN MARKED NODES
		;RA ADDS OF LIT MAP
		;RB NODE ADDS
		;RC ACTUAL ADDER OF NODE
		;RD BIT MAP
		;RE POINT TO LIST OF FREE STORAGE RECYCLED NODES
		;RF NUMBER NODES LEFT TO CHECK
		;START COLLECTING AT LUNN(LOWEST UNPROTECTED NODE #)
	CLR E
	CLR NNGC
	CLR B	;NODE ZERO
	MOV UAB,C	;NODE ZERO ADDRESS
	MOV NUNODE,F	;NUMBER OF NODES
	MOV #GCBITS,A	;BIT TABLE ADDR
GCRT2A:	MOV (A)+,D	;GET NEXT WORD OF BIT MAP
	SEC
	ROR D

GCRT2:	BCS GCRT3
	CMP B,#LUNN
	BLOS GCRT3
	TST E		;WE HAVE A FREE NODE; IS FIRST FREE FOUND?
	BNE GCRT2B
	MOV B,FREE	;NO, THIS IS IT
	BR GCRT2C	;(NO LAST-FREE TO UPDATE)

GCRT2B:	BIS B,(E)	;ELSE: POINT LAST-FREE TO THIS NODE
GCRT2C:	MOV C,E		;SEE IF NODE IN PHASE WITH START OF NODE SPACE
	SUB #N,E
	BIT #3,E	;(LAST TWO BITS =)
	BEQ .+4
	.BUG.		;OUT OF PHASE!!
	MOV C,E		;THIS NODE IS NEW LAST-FREE
	MOV #IDLE,(C)+	;MAKE NEW IDLE NODE, POINTS NOWHERE
	CLR (C)+
	INC NNGC
	BR GCRT4
GCRT3:	CMP (C)+,(C)+
GCRT4:	INC B
	DEC F
	BLE GCRT5
	CLC
	ROR D
	BNE GCRT2
	BR GCRT2A
GCRT5:	MOV NNGC,NNIFSL
;DEBUGGING FEATURE
	BIT #PNNLF,FLAGS2
	BEQ GCRT6
	CPRTXT ^/<NODES LEFT /
	MOV NNGC,A
	JSR PC,PRDN
	PRTXTC ^/ >/
;
GCRT6:	TST DSKNCH	;BUFFERS IN USE?
	BEQ .+10	;NO
	JSR E,GBITGS	;GET BACK THE BUFFERS
	DREADC
	JSR E,LCUGRB
	GCLOCK
	JSR F,ACRES
	RTS PC

GBITGS:	MOV USER,U
	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+
	MOV #-DBUFL-DDBUFL/2,(A)+
	MOV #GCBITS,(A)+
	MOV UDBFSV(U),(A)+
	MOV UDBFSV+2(U),(A)+
	TST (A)+
	MOV (E)+,(A)
	JSR PC,DSKWAI
	RTS E
GNOLE:		;GET NEXT OBLIST ELEMENT
		;INPUT - VIA GNOLEI
		;OUTPUT - UOE PTR IN B
		;USES E.  SKIPS UNTIL NO UOE PTRS LEFT
	PUSH A
	MOV GNCN,B
GNOLE2:	BEQ GNOLE1
	JSR PC,.LOAD	;GET NEXT PTR ON BUCKEN LIST
	MOV A,GNCN
	JMP SRETA
GNOLE1:	MOV (E)+,B	;GET NEXT BUCKET LIST
	BGE GNOLE2
	JMP RETA	;DONE
GNOLEI:	MOV #UHCT,E
	CLR GNCN
	RTS PC
