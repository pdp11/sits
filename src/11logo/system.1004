	.STITL LOSS CHECKING ROUTINES
	FOO==%FNAM2
	VERN==VERN+%FNAM2


IOTBRK:	TST USER
	BLT BADTRP
	CMP P,#SPDLP
	BLOS BADTRP
	BIT #340,6(P)
	BNE BADTRP
	CLR PS
	SPUSH A
	CMP -(P),-(P)	;FOOL PRBTRP
	JSR	PC,PRBTRP
	CMP (P)+,(P)+
	SPOP A
	CLR ERPROC
	TST DEBSW
	BEQ IOTBR2
	SPUSH E
	MOV USER,E
	MOV UTTY(E),E
	TST TOTN(E)	;WAIT UNTIL THROUGH PRINTING
	BGT .-4
	SPOP E
	BPT	;BREAK IF DEBUGGING
IOTBR2:	.BUG.
BADTRP:	INC LOSSCT
	BEQ LOSER
	BGT LOST
	JSR	A,SPRINT	;ON SYS CONSOLE
	JSR	PC,PRBTRP	;PRINT MESSAGE
	SPREND
	CMP	(SP)+,(SP)+
	BPT
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT

EMTBRK:	BPT
LOSER:	PRTXT ^/I GIVE UP!/
LOST:	BPT
	BR .-2

PRBTRP:	BPRTXT ^/BAD TRAP: VECTOR /
	MOV 10(SP),A
	SUB #4,A	;MAKE IT REAL
	JSR PC,PRON
IOTBR1:	PRTXT ^/ TRAPPED FROM /
	MOV 14(SP),A
	JSR PC,PRON
	PRCR
	RTS	PC

SIMBPT:	HALT	;BPT TRAPS HERE IN SIMULATOR
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT
BEBRK:	TST P
	BNE .+6
	MOV #PFPDL,P
	IOT
.HALT:	JSR PC,CKSST
	SPOP A
	SPUSH #0
	SPUSH A

PWRDWB:	JSR F,ACSAV
	JSR F,DEVSAV
	MOV #PWRUPB,PFBRV
	RESET
	HALT

PWRUPB:	JSR F,DEVRES
	JSR F,ACRES
	MOV #BEBRK,BEBRV
	MOV #PWRDWB,PFBRV
PWFNXM:
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT
PWRCLR:	JSR F,DEVSAV
	RESET
	RESET
	JSR F,DEVRES
	MOV #BEBRK,BEBRV
	RTS PC

DEVCLR:
	.IFNZ NDISP
	MOV #DISREL,NGREL
	.ENDC
	.IIF NZ SEG,	JSR PC,SEGSET
	MOV #100,LKS
	MOV #200.,PCSTBF
	MOV #113,PCS
	JSR PC,TINITH
	MOV #100000,DKNRTY
	MOV #30.,DKPWFR
	MOV DSKCRB,A
	BEQ NODISK
	CMP #-1,10(A)
	BEQ RKREST
	JSR PC,DSKSG1
	BR NODISK
RKREST:	JSR PC,RKSG1
NODISK:	RTS PC
DEVSAV:	TST (P)+	;FLUSH SAVED F
	MOV #PWFNXM,BEBRV
	MOV SP,PFPDL
	MOV #PFPDL,SP
.IFNZ A1120
	SPUSH SR
	SPUSH AC
	SPUSH MQ
.ENDC
	SPUSH PPS
	.IFZ DHON
	.IFNZ NDM
	SPUSH DM0BAR
	.ENDC
	.ENDC
	.IFNZ SEG
	SPUSH SSR0
	SPUSH PUREAR
	SPUSH PUREAR+2
	SPUSH PUREAR+4
	SPUSH TEMPDR	;THESE ARE THE SAME AS DISPAR+DR IF NEWDIS=1
	SPUSH TEMPAR
	.ENDC
	MOV P,PWFPDL
	JMP (F)
DEVRES:	MOV PWFPDL,P
	JSR PC,DEVCLR
	.IFNZ SEG
	SPOP TEMPAR
	SPOP TEMPDR
	SPOP PUREAR+4
	SPOP PUREAR+2
	SPOP PUREAR
	SPOP SSR0
	.ENDC
	.IFZ DHON
	.IFNZ NDM
	SPOP DM0BAR
	.ENDC
	.ENDC
	SPOP PPS
.IFNZ A1120
	SPOP MQ
	SPOP AC
	SPOP SR
.ENDC
	SPOP SP
	JMP (F)
	.STITL DISK STARTER

DSKSRT:
	MOV #SYSWPR,A	;LOOK FOR MOVING HEAD REQESTS
RKSR1:	BIT #100,14(A)
	BEQ RKSR2
	CMP #-1,10(A)
	BEQ RKSGO
RKSR2:	ADD #16,A
	CMP #16*MNUSRS+SYSWPR,A
	BHI RKSR1
	MOV #SYSWPR,A	;NEXT LOOK AT SYSTEM REQUESTS
DSKSR1:	BIT #100,14(A)
	BNE DSKSGO	;FOUND A REQUEST, GO DO IT
	ADD #16,A	;LOOK AT NEXT BLOCK
	CMP #16*MNUSRS+SYSWPR,A	;LAST BLOCK?
	BHI DSKSR1
	MOV SWPLST,A	;MOOBY SWAP OUT REQS?
	BNE DSKSGO
	RTS PC	;NO DISK REQUESTS EXTANT, BETTER LUCK NEXT TIME

DSKSGO:	MOV DKNRTY,DKRTYS	;SET NUMBER OF POSSIBLE RETRYS
	MOV A,DSKCRB	;ADDRESS OF BLOCK ABOUT TO BE SERVICED
	MOV (A),B
	BEQ DSKSG1	;BRANCH IF NO
	JSR PC,(B)	;RUN START ROUTINE
DSKSG1:	TST (A)+
	BIT #FDSCMS,4(A)
	BNE DBLECH
	.IFZ SEG
	CMPB #DREADC,12(A)
	.IFF
	MOVB 12(A),B
	BIC #70,B
	CMPB #DREADC,B
	.ENDC
	BEQ DSKSG2
	BIT #FDSCMS,(A)
	BNE DBLECH
DSKSG2:	MOV #DSKS,B	;START OF DISK I/O WORDS
	MOV #400,(B)+
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
	.IFNZ MVONLY
	MOV C,-(P)
	MOV D,-(P)
	MOV (A)+,D
	MOV (A)+,C
	ASHC #-8.,C
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	ADD #20000,D
	MOV D,(B)+
	MOV (P)+,D
	MOV (P)+,C
	.IFF
	MOV (A)+,(B)+	;LOW ORDER DISK ADDRESS
	MOV (A)+,(B)+	;HIGH "      "     "
	.ENDC
	TST (A)+	;GO PAST UNUSED WORD
	MOV #DSKS,DSKRUN
	MOVB (A),B
	MOV B,DSKS	;SET FUNCTION, ENABLE INTERUPT, GO!!
	RTS PC

RKSGO:	MOV DKNRTY,DKRTYS
	MOV A,DSKCRB
	MOV (A),B
	BEQ RKSG1
	JSR PC,(B)
RKSG1:	TST (A)+
	MOV #RKWC,B
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
	MOV (A)+,(B)+	;DISK ADDRESS
	CMP (A)+,(A)+	;UNUSED WORDS
	MOV #RKCS,DSKRUN
	MOVB (A),B
	MOV B,RKCS
	RTS PC

DPROVK:	BIS #100,@DSKRUN
	RTS PC

;THIS CRETIN ROUTINE TAKES A RANDOM WORD ADDRESSED DISK
;REQUEST AND TRANSFORMS IT INTO SOMETHING THAT A SECTORIZED
;DISK WILL BE HAPPY WITH I.E.
;READING- IF TRANSFER DOES NOT START
;ON A SECTOR BOUNDARY, READ THE NEAREST SECTOR TO THE
;BEGGINING OF THE TRANSFER , THEN COPY THE WORDS NEEDED
;OUT OF A SPECIAL BUFFER, INTO THE USERS BUFFER
;IF THAT DOES NOT FINISH THE TRANSFER, READ THE REST
;OF THE WORDS NORMALLY
;WRITING (BLETCH!) IF TRANSFER DOES NOT START ON SECTOR
;BOUNDARY, READ FIRST SECTOR, COPY WORDS FROM USERS BUFFER
;INTO SPECIAL BUFFER, WRITE OUT THAT SECTOR. IF THAT
;DOESN'T FINISH THE TRANSFER, ROUND THE REQUEST TO
;A WHOLE NUMBER OF SECTORS AND DO A NOORMAL WRITE
;IF THAT DOES NOT FINISH THE TRANSFER, READ IN THE NEXT
;SECTOR, TRANSFER THE WORDS FROM THE USERS BUFFER TO THE
;SPECIAL BUFFER, AND WRITE THE SECTOR BACK OUT.
;THUS, IN THE WORST CASE, A WRITE REQUEST MAY REQUIRE
;2 READS AND 3 WRITES, OR A TOTAL OF 5(COUNT THEM!) TRANSFERS.
	.IFNZ SEG
	.IFNZ NEWDIS
	TEMPAR=DISPAR
	TEMPDR=DISPDR
	TEMPPG==DISPPG
	.IFF
	TEMPPG==120000
	TEMPAR==KDAR+<<TEMPPG_-12.>&17>
	TEMPDR==KDDR+<<TEMPPG_-12.>&17>
	.ENDC
	.ENDC

DBLECH:	CLR DBLFAK	;INDICATE WE SHOULD NOT FAKE INTERUPT RETURN
	MOV A,DBLASV	;TO MAKE THINGS LOOK RIGHT WHEN WE FINISH
DBLE14:	SPUSH C	;ENTER HERE TO PERFORM PRATIAL SECTOR TRANSFER
	SPUSH D	;AT BEG FOR READ ANN WRITE, AND AT END FOR WRITE(MAYBE)
	MOV #6,D	;FIRST, SAVE AWAY EITHER THE REAL REQUEST
	MOV #DBLPRO+2,B	;OR THE ONE WHICH IS IN PROGRESS
	MOV #DBLDO+2,C
DBLEC1:	MOV (A),(B)+	;THIS IS NOP ON SECOND ENTRY
	MOV (A)+,(C)+
	DEC D
	BNE DBLEC1
	SPOP D
	SPOP C
	BIT #FDSCMS,DBLPDA	;DOES IT BEGIN ON A SECTOR BOUNDARY?
	BNE .+6
	JMP DBLEC2
	BIC #FDSCMS,DBLDDA	;MOVE TO BEG OF SECTOR
DBLE16:	MOV #DSKFOO,DBLDCA	;ENTER HERE IF LESS THAN ONE SECTOR TRANSFER ON WRITE
	MOV #-FDSCSZ,DBLDWC
	MOV #DREADC,DBLDCM	;THIS IS A READ IN ANY CASE
	MOV #DBLDO,A
	MOV #DBLEC3,(A)	;SET UP PLACE TO RETURN
	BR DBLEC9

DBLEC3:	MOV DBLPDA,A	;GET PLACE WE REALLY WANT TO START AT
	BIC #-FDSCSZ,A	;MASK OFF HIGH BITS
	ASL A	;CHANGE TO CORE OFFSET
	ADD #DSKFOO,A	;REAL CORE ADDRESS
	MOV DBLPCA,B	;REAL BUFFER ADDRESS
.IFNZ SEG
	SPUSH TEMPAR
	SPUSH TEMPDR
	SPUSH B
	SPUSH A
	MOV DBLPCM,A
	ASH #-4,A
	BIC #177774,A
	ASHC #-6,A
	MOV #77406,TEMPDR
	MOV B,TEMPAR
	SPOP A
	SPOP B
	BIC #177700,B
	ADD #TEMPPG,B
.IFF
	CMPB #DREADC,DBLPCM	;IS IT A READ?
.IFT
	MOVB DBLPCM,DBLDDE+2
	BIC #70,DBLDDE+2
	CMPB #DREADC,DBLDDE+2
.ENDC
	BEQ DBLEC8	;YES
DBLEC5:	MOV (B)+,(A)+	;FROM REAL BUFFER TO SPECIAL
	INC DBLPDA	;INCREMENT THE DISK ADDRESS WE ARE AT
	BIT #FDSCMS,DBLPDA	;ARE WE AT THE END OF A SECTOR?
	BEQ DBLE10	;YES
	INC DBLPWC	;HAVE WE TRANFERED ALL THE WORDS WE NEED?
	BNE DBLEC5	;NO
	DEC DBLPWC
	BR DBLE10
DBLEC6:	MOV #DWRTEC,DBLDCM	;WRITE OUT THIS SECTOR
	MOV #DBLDO,A
	MOV #DBLEC7,(A)	;PALCE TO RETURN WHEN DONE
DBLEC9:	MOV A,DSKCRB	;THIS KLUDGE FAKES OUT THE WORLD
	TST DBLFAK	;SHOUDL WE FAKE INTERUPT RETURN?
	BNE DBLE20	;YES
	INC DBLFAK	;NO, BUT NEXT TIME
	JMP DSKSG1
DBLE20:	JSR PC,DSKSG1	;BY MAKING LIKE THE DISK IS STILL RUNNING
	TST (P)+	;AND EXITS THE INTERUPT ROUTINE
	SPOP B	;WITHOUT RETURNING TO IT
	SPOP A
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT

DBLE15:	MOV A,(B)	;COME HERE FOR A WRITE OF LESS THAN A SECTOR
	CMP #-FDSCSZ,A
	BEQ DBLE19
	BR DBLE16	;BEGINNING ON A SECTOR

DBLE11:
.IF NZ SEG
	SPOP TEMPDR
	SPOP TEMPAR
	.ENDC
	JSR PC,DBLEC4	;CORRECT DSIK ADDRESS AND WORD COUNT
	BR DBLEC7
DBLE10:
.IF NZ SEG
	SPOP TEMPDR
	SPOP TEMPAR
	.ENDC
	SPUSH #DBLEC6	;FAKE JSR PC,
DBLEC4:
.IFZ SEG
	MOV B,DBLPCA	;FIX PROGRESS CORE ADDRESS
.IFF
	SUB #TEMPPG,B
	BIC #77,DBLPCA
	ADD B,DBLPCA
	BCC .+10
	ADD #20,DBLPCM
.ENDC
	TST DBLPDA	;DID WE PRODUCE A CARRY
	BNE .+6	;NO
	INC DBLPDE	;YES, INCREMENT EXTENSION
	INC DBLPWC	;DON'T NEGLECT WORD COUNT
	RTS PC

DBLEC8:	MOV (A)+,(B)+	;COME HERE FOR A READ
	INC DBLPDA
	BIT #FDSCMS,DBLPDA	;DONE WITH THIS SECTOR?
	BEQ DBLE11	;YES, GO MAKE CORRECTIONS
	INC DBLPWC
	BNE DBLEC8
	DEC DBLPWC
	BR DBLE11	;GO MAKE CORRECTIONS

DBLEC7:	TST DBLPWC	;ARE WE DONE?
	BNE DBLEC2	;NO, DO MULTI SECTOR TRANSFER
DBLE18:	MOV DBLASV,A	;REMEMBER HIM?
	CLRB 12(A)
	MOV -(A),B	;ADDRESS OF STOP ROUTINE
	BEQ .+4	;IF NO STOP ROUTINE
	JMP (B)	;LET IT DO THE RTS PC
	RTS PC	;OR WE'LL DO IT IF NONE

DBLEC2:	MOV #DBLPWC,B	;REMAINING WORD COUNT
	CLR A	;LEFTOVERS, IF ANYONE ASKS
.IFZ SEG
	CMPB #DREADC,DBLPCM	;IF IT IS A READ
.IFF
	MOVB DBLPCM,DBLDDE+2
	BIC #70,DBLDDE+2
	CMPB #DREADC,DBLDDE+2
.ENDC
	BEQ DBLE17	;THEN THINGS ARE SIMPLE
	MOV (B),A	;IT IS WRITE, GET THE REAL WORD COUNT
	BIC #FDSCMS,(B)	;MAKE IT INTO A WHOLE NUMBER OF SECTORS
	ADD #FDSCSZ,(B)	;LESS ONE SECTOR
	BEQ DBLE15	;LESS THAN ONE SECTOR TO WRITE
	SUB (B),A	;NUMBER OF WORDS LEFTOVER
	CMP #-FDSCSZ,A	;EXACTLY ONE SECTOR?
	BNE DBLE17	;NO
	ADD A,(B)	;A WHOLE NUMBER OF SECTORS
DBLE19:	CLR A	;WITH NO LEFTOVERS
DBLE17:	MOV A,DBLDWC	;SAVE COUNT OF LEFTOVERS
	MOV #DBLE13,-(B)	;PALCE TO RETURN TO
	MOV B,A	;PLACE WHERE REQUEST IS
	BR DBLEC9

DBLE13:	MOV #DBLPWC,A	;ADDRESS OF LEFTOVER COUNT
.IFZ SEG
	SUB (A),DBLPCA	;FIX UP CORE ADDRESS
	SUB (A),DBLPCA
.IFF
	SPUSH B
	MOV (A),B
	NEG B
	ASL B
	ADD B,DBLPCA
	BCC .+10
	ADD #20,DBLPCM
	SPOP B
.ENDC
	SUB (A),DBLPDA	;AND DISK ADDRESS
	BCS .+6	;OPISITE OF ADC
	INC DBLPDE
	MOV DBLDWC,(A)	;SETUP FOR REMAINDER
	BEQ DBLE18	;TRANSFER REMAINDER
	JMP DBLE14	;NO REMAINDER
.STITL DISK REQUEST BLOCK GRABBER

SYDRBG:	SPUSH PS	;SAVE OLD PROSSESOR LEVEL
	MOV #340,PS	;LOCK OUT INTERUPTS
	MOV #SYSWPR,A	;LOOK FOR A FREE SYSTEM DISK REQUEST BLOCK
SDRBG1:	TST 14(A)	;IS IT FREE?
	BEQ SDRBG2
	ADD #16,A	;LOOK AT NEXT ONE
	CMP #16*MNUSRS+SYSWPR,A	;ANY MORE?
	BHI SDRBG1	;YES, SEE IF FREE
	SPOP PS	;NO MORE, WE HAVE LOST BIG
	BPT
	BR SYDRBG	;AND CERTAINLY WON'T UNLESS OUR PRIORITY IS <5
SDRBG2:	MOV #400,14(A)	;LABEL BLOCK AS IN USE, BUT NO REQUEST
	SPOP PS	;YOU CAN INTERUPT NOW.
	RTS PC


;USER ROUTINE TO FLUSH UNTIL DISK REQUEST POINTED TO BY A DONE

DSKWAI:	MOV USER,U
	JSR PC,DPROVK
DSKWA1:	TSTB (A)
	BNE DNDONE
	CLR (A)
	JSR PC,RUNME
	RTS PC
DNDONE:	MOV #FRDSKW,FLSRES(U)
	JSR PC,FLUSH
	BR DSKWA1
;GRABS A DISK BLOCK
;DISK BLOCK ADDR RETURNS IN B AND C
UBLKGR:	BIC #DSAMFL,FLAGS2
	MOV #DBITTB,A
	MOV #1,C
	MOV #-1,D
	CLR E
BLKGR1:	BIT C,(A)
	BNE BLKGR3
	INC D
	BGT BLKGR2
	BIS C,(A)
	MOV E,B
	MOV USER,U
	ADD UDSKAD(U),B
	MOV B,DBGRBD
BLKGR2:	CMP #2,D
	BLE BLKGR4
BLKGR3:	INC E
	ASL C
	BNE BLKGR1
	ROL C
	TST (A)+
	CMP #DBITBE,A
	BGE BLKGR1
	BIS #DSAMFL,FLAGS2
BLKGR4:	TST D
	BLT UBLKF2
	SKPRET

;FREES THE DISK BLOCK WHOSE LOW ORDER ADDR IS IN C
;BASE OF THIS DISK SPACE IS IN D
;ADDRESS OF THE APPRPRIATE BIT TABLE IS IN E
UBLKFR:	MOV USER,U
UBLKF1:	BIC #DSAMFL,FLAGS2
	SUB UDSKAD(U),C
	MOV #DBITTB,E
	MOV C,B
	BIC #177770,B
	ASR C
	ASR C
	ASR C
	ADD C,E
	BICB BMT(B),(E)
UBLKF2:	RTS PC

LCGRAB:	MOV USER,U
	CMP U,(D)
	BEQ LCGRA1
LCGRA2:	TST (D)
	BLT LCGRA1
	JSR PC,FLUSH
	BR LCGRA2
LCGRA1:	MOV U,(D)
	JSR PC,RUNME
	RTS PC

LCUGRB:	CMP USER,(D)
	BNE .+6
	MOV #-1,(D)
	RTS PC	.STITL DISK INTERUPT ROUTINE

DSKBRK:	SPUSH A
	SPUSH B
	MOV DSKS,A	;GET STATUS REGISTER
	TST A
	BLT DSKLOS
	MOV #400,DSKS
DSKBR2:	MOV DSKCRB,A	;POINTER TO FUNCTION WORD
	BEQ DSKBR1
	CLR DSKCRB
	CLRB 14(A)	;REQUEST HAS BEEN SERVICED
	MOV (A),B
	BEQ .+4	;NO
	JSR PC,(B)	;YES, GO DO IT
DSKBR1:	JSR PC,DSKSRT	;LOOK FOR SOMETHING ELSE TO DO
DSKRET:	SPOP B
	SPOP A
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT

DSKLOS:	INC NRFERS
	BIT #40000,A	;IS IT FROZEN?
	BNE DSKLS1	;YES
	BIT #26000,A	;IS IT ONE OF WRITE CHECK, NED OR WRITE LOCKOUT?
	BEQ DSKRTY	;NO, MEANS IT IS ADDRESS PARITY OR
DKLOSE:	MOV #DKWLST,B
	JSR PC,PLOCS	;PRINT CONTENTS OF FOLLOWING ON SYS CONSOLE
			;DSKS
			;DSKAE
			;0
	HALT	;BIT THE BAG
	BR DSKRT1
DSKLS1:	BIT #2000,DSKAE	;NXM?
	BNE DKLOSE	;YES
DSKRTY:	INC DKRTYS	;HAVE WE BEEN THROUGH THIS BEFORE?
	BGE DKLOSE	;YES, TOO MANY TIMES
DSKRT1:	MOV #400,DSKS	;POWER CLEAR THE DISK
	MOV DSKCRB,A	;RETRY THE LAST OPERATION
	JSR PC,DSKSG1
	BR DSKRET

RKBRK:	SPUSH A
	SPUSH B
	MOV RKCS,A
	TST A
	BLT RKLOS
	CLR RKCS
	BR DSKBR2
RKLOS:	INC NRKERS
	BIT #66340,RKER	;BAD ERROR?
	BEQ RKSOFT
RKLOST:	MOV #RKWLST,B
	JSR PC,PLOCS	;PRINT FOLLOWING LOCS ON SYS CONSOLE
			;RKDS
			;RKER
			;RKCS
			;0
	HALT
	BR RKRT1
RKSOFT:	INC DKRTYS
	BGE RKLOST
RKRT1:	MOV #1,RKCS
	TSTB RKCS
	BGE .-4
	MOV DSKCRB,A
	JSR PC,RKSG1
	BR DSKRET
;JSR F,FSEARC	FIND FILE IN DIRECTORY
;DIRECTORY POINTER IN A (RETURNS POINTING TO END OR FOUND FILE)
;FILE NAME POINTER IN B
;SECTOR ADDRESS OF FILE RETURNS IN D
;SKIPS 2 BYTES IF HIT END OF DIRECTORY
;SKIPS 0 BYTES IF HIT END OF DIRECTORY BLOCK (ANOTHER BLOCK AVAILABLE)
;SKIPS 4 BYTES IF FOUND FILE
FSEARC:	TST (A)	;IS THIS ALREADY THE END?
	BEQ FSEAR3	;YES
FSEAR0:	SPUSH A
	SPUSH B	;SAVE DIRECTORY AND FILE NAME POINTERS
	MOV #4,E	;NUMBER OF WORDS TO COMPARE
FSEAR1:	CMP (A)+,(B)+	;SAME NAME?
	BNE FSEAR2	;DEFINITLY NOT!
	DEC E	;END ?
	BGT FSEAR1	;NO, CHECK NEXT WORD
	SPOP B
	SPOP A
	TST (F)+	;FOUND THE FILE
	BR FSEAR3
FSEAR2:	SPOP B
	SPOP A
	ADD #10,A
	ADD (A)+,D	;NUMBER OF SECTORS FOR THAT FILE
	TST (A)	;ZERO IS THE NAME OF THE LAST FILE
	BGT FSEAR0	;LOOK AT THIS FILE
	BLT FSEAR5	;ANOTHER BLOCK AVAILABLE
	;NEGATIVE FILE NAME INDICATES ANOTHER BLOCK
FSEAR3:	TST (F)+	;ZERO FILE NAME IS LAST FILE
FSEAR5:	BIC #160000,D	;CLEAR EXTRA BITS IN SECTOR ADDR
	RTS F

;	PUSH F
;	SPUSH ADDR
;	JSR PC,LSH7
;CONVERTS SECTOR ADDR IN D TO WORD ADDR IN ADDR AND ADDR+2
;D STAYS INTACT (AS OPPOSED TO PREVIOUS VERSION)
LSH7:	MOV P,F		;POINT F AT PUSHED ADDR
	TST (F)+	;(SKIP PUSHED PC)
	SPUSH D
.IFNZ A1120
	MOV D,MQ	;SECTOR ADDR
	MOV #7,LGS	;SHIFT 7 PLACES
	MOV (F)+,D	;ADDRESS TO PUT RESULT
	MOV MQ,(D)+	;LOW ORDER
	MOV AC,(D)	;HIGH ORDER
.IFF		;11/45
	SPUSH A
	SPUSH C
	CLR C		;EXTEND SECTOR ADDR
	ASHC #7,C	;SHIFT 7 PLACES
	MOV (F)+,A	;ADDRESS TO PUT RESULT
	MOV D,(A)+	;LOW ORDER
	MOV C,(A)	;HIGH ORDER
	SPOP C
	SPOP A
.ENDC
	SPOP D
	SPOP F		;RETURN ADDRESS TO F
	TST (P)+	;POP ADDR
	RTS F		;RETURN, RESTORING F

	.IFNZ OFILES
FILFIN:	SPUSH #DDIRLS	;LIST OF DIRECORY ADDRESSES
FILFN1:	MOV	@(P),E
	BLT	FILFN4
	ADD	#2,(P)
	CMP	#-1,(E)
	BEQ	FILFN1
	MOV	(E),DSKDAD
	MOV DSKDAD,DSKADR
	BIC #17777,DSKADR	;SAVE WHICH DISK
	CLR D
FILFN2:	SPUSH B
	SPUSH D
	SPUSH #DIRRED	;READ INTO (DDIRAD) FROM (DSKDAD)
	JSR PC,DSKSEC
	SPOP D
	SPOP B
	INC DSKDAD
	MOV DDIRAD,A
	JSR F,FSEARC
	BR FILFN2
	BR FILFN1
	TST (P)+
	DEC DSKDAD
	ADD D,DSKADR
	JMP SRET
FILFN4:	TST (P)+
	DEC DSKDAD
	ADD D,DSKADR
	RTS PC
	.ENDC
;SPUSH #(ADDR OF 3-WORD BLOCK)
;JSR PC,DSKSEC
;	3-WORD BLOCK:
;POINTER TO CORE ADDRESS
;POINTER TO DISK SECTOR ADDRESS
;READ OR WRITE COMMAND
;	USES 4 WORDS ON PDL;
;	IF THIS INCREASES CHECK PPUSHL.
DSKSEC:	SPUSH E
	MOV 4(P),E	;E POINTS TO FIRST WORD OF 3-WD BLOCK
	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-200,(A)+	;ALWAYS THIS LONG
	.IFZ SEG
	MOV @(E)+,(A)+	;CORE ADDRESS
	.IFF
	MOV @(E)+,D
	SPUSH B
	SPUSH F
	MOV USER,F
	MOV SLOTAS(F),F
	MOV SLOTHA(F),B
	SUB #PURE,D
	ADD SLOTCA(F),D
	ADC B
	MOV D,(A)+
	ASH #4,B
	BIS B,6(A)
	SPOP F
	SPOP B
	.ENDC
	MOV @(E)+,D	;DISK ADDRESS
.IFNZ A1120
	SPUSH SR
	SPUSH AC
	SPUSH MQ
.ENDC
	BIT #160000,D	;IS IT THE FIXED HEAD DISK?
	BNE DSKSC1	;NO
	SPUSH F
	SPUSH A		;PLACE TO PUT WORDED DISK ADDR
	JSR PC, LSH7
	ADD #4,A
	BR DSKSC3
DSKSC1:	SUB #20000,D	;MAKE IT INTO A REAL MOVING DISK ADDR
	SPUSH D
	BIC #17777,(SP)
	BIC #160000,D
.IFNZ A1120
	MOV D,MQ
	MOV #12.,DIVIDE
	MOV AC,D
	MOV #4,LGS
	ADD MQ,D
.IFF
	SPUSH C
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	SPOP C
.ENDC
	ADD (SP)+,D
	MOV D,(A)+
	MOV #-1,(A)+	;THIS IS A MOVING HEAD REQUEST
DSKSC3:
.IFNZ A1120
	SPOP MQ
	SPOP AC
	SPOP SR
.ENDC
	TST (A)+
	BISB (E),(A)	;ENTER REQUEST BYTE
	JSR PC,DSKWAI	;WAIT FOR COMPLETION
	SPOP E
	SPOP (P)
	RTS PC
	.STITL NEW FILING

	.IFNZ NFILES
;USER PRIMITIVE ROUTINES

;DIRSET TAKES A LIST AND SETS THE CURRENT DIRECTORY

DSET:	JSR PC,SETNM
	BNE DSET1
	MOV DEFDIR,CURDIR
	RTS PC
DSET1:	MOV DEFDIR,CURDIR
DIRSET:	JSR PC,GNWRD	;GET A WORD FROM THE LIST
	BNE .+4		;ANY LEFT?
	RTS PC		;NONE LEFT, DONE
	JSR PC,DIRGET
	BR DIRSET	;AND CONTINUE WITH THE NEXT NAME


DIRGET:	MOV #NAME,E	;PLACE TO STORE THE NAME
	JSR PC,NFNGET	;GET A FILE NAME
	MOV #NAME,E
	CMPB #';+200,(E)
	BNE DIRGT1
	MOV #46,CURDIR
	RTS PC
DIRGT1:	CMPB #'^+200,(E)
	BNE UDREAD
	MOV CURDIR,E
	JSR PC,DBREAD
	MOV #DBUF,ENTBEG
	BR DIRGT2
UDREAD:	JSR PC,DIRSER	;LOOK FOR THAT NAME
	BNE .+4		;FIND IT?
	ERROR+NED	;NON EXISTENT DIRECTORY
DRREAD:	MOVB @ENTBEG,A	;GET TYPE OF ENTRY FOUND
	BIC #177477,A	;FLUSH EVERYTING BUT TYPE
	CMP #300,A	;IS IT A DIRECTORY?
	BEQ .+4
	ERROR+ENDR	;ENTRY NOT A DIRECTORY
DIRGT2:	JSR PC,DESSET	;SET UP NEW DIRECTORY
	MOV DSKADR,CURDIR	;AND MAKE THIS THE CURRENT DIRECTORY
	RTS PC
.DIRSET:
	BIT #7777,@S
	BNE .DIRS1
	SPOPS A
	RTS PC
.DIRS1:	JSR PC,DSET
	JSR PC,DIRGET
USEENT:	MOV CURDIR,DEFDIR
	RTS PC
.USE:	MOV #46,CURDIR
	MOV #USRFIL,E
	JSR PC,UDREAD
	JSR PC,SETNM
	BNE .USE1
.USE3:	MOV #NAME,E
	JSR PC,NFNGET
.USE4:	MOV #NAME,E
	JSR PC,DIRSER
	BNE .USE2
	ERROR+NED
.USE2:	JSR PC,DRREAD
	BR USEENT
.USE1:	JSR PC,DIRSET
	BR .USE3
LOGIN:	MOV @S,A
	SPUSHS A
	JSR PC,.USE
	MOV USER,E
	ADD #UNAME,E
	JSR PC,NFNGET
	MOV #NAME+4,E
	MOV #"IT+100000,-(E)
	MOV #"IN,-(E)
	JSR PC,DIRSER
	BEQ LOGIN2
	JSR PC,GETFI1
	CMP #200,A
	BNE LOGIN2
	JSR PC,.REDF4
	JSR PC,.READ1
LOGIN2:	MOV #NAME+4,E
	MOV #"IL+100000,-(E)
	MOV #"MA,-(E)
	JSR PC,DIRSER
	BEQ LOGIN1
	JSR PC,GETFI1
	CMP #200,A
	BNE LOGIN1
	PRTXT ^/PRINT MAIL?/
	JSR PC,QUEST
	BNE LOGIN1
	JSR PC,.REDF4
	JSR PC,.POF1
	PRTXT ^/DELETE MAIL?/
	JSR PC,QUEST
	BNE LOGIN1
	JSR PC,GCDIR
	JSR PC,.DELT5
LOGIN1:	RTS PC

.DELETE:
	MOV #WDIRSW,D
	JSR PC,LCGRAB
	JSR PC,GETFIL
	CMP #200,A	;IS IT A FILE?
	BEQ .+4		;IF YES, OK
	ERROR+CDE	;CAN'T DELETE THAT ENTRY
	CMP #46,CURDIR
	BNE .+6
	JSR PC,CKSST
.DELT5:	JSR PC,DESSET
	JSR PC,.DELT3
	JSR PC,DELENT
	JSR PC,WBITS
	MOV #WDIRSW,D	;WE'RE DONE, FREE THE WORLD UP
	JMP LCUGRB
WDELBL:	JSR PC,DESINC
.DELBL:	JSR PC,DESST	;SET UP DESCRIPTOR
	CLR FILFLG
.DELT3:	BIT #4000,DESSAV
	BNE .DELT2
	MOV DSKADR,A	;ADDRESS OF THE BLOCK
	TST DEOFBL	;ARE WE BEYOND THE LAST BLOCK?
	BGT .DELT2
	JSR PC,BITGET	;GET THE APPROPRIATE BIT
	INC NBLKFR
	BICB BMT(B),FDBITS+2(C)	;FREE THE BLOCK
	JSR PC,GNBLK	;GET THE NEXT BLOCK ADDRESS
	BR .DELT3
.DELT2:	RTS PC
DELENT:	MOV @ENTBEG,A	;GET FIRST WORD
	BIC #177700,A	;LENGTH OF ENTRY IN WORDS
	ASL A		;NOW IN BYTES
	MOV #DBUF+1776,D	;HOPEFULLY, THE NUMBER OF FREE BYTES
	ADD A,(D)	;CORRECT IT
	MOV ENTBEG,B	;BEGINNING OF ENTRY TO FLUSH
	MOV B,C
	ADD A,C		;BEGGINING OF NEXT ENTRY
	SUB (D),D	;END OF USEFUL INFORMATION
.DELT4:	MOV (C)+,(B)+	;COPY USEFUL STUFF OVER USELESS
	CMP B,D		;DONE?
	BLE .DELT4
	MOV (C)+,(B)+	;MAKE SURE
	MOV CURDIR,E	;WRITE OUT THE DIRECTORY
	JSR PC,DBWRTE
	RTS PC
MAIL:	SPUSH DEFDIR
	JSR PC,.USE
	SPOP DEFDIR
	MOV #"MA,NAME
	MOV #"IL+100000,NAME+2
	JSR PC,.OPNA3
	MOV #.WRTEC,PCHR
	PRTXTC ^/------/
	PRTXT ^/MAIL FROM /
	MOV USER,A
	ADD #UNAME,A
	JSR PC,POIHD2
	JSR PC,.CRLF
	JSR PC,UDATEG
	.BUG.
	SPUSH #1
	JSR PC,PRINT
	JSR PC,.SPACE
	JSR PC,UTIMEG
	.BUG.
	SPUSH #1
	JSR PC,PRINT
	SPUSH PRMTCH
	MOV #'_,PRMTCH
	MOV #TYO,PCHR
MAIL2:	JSR PC,RDSTR
	BR MAIL3
	MOV @S,B
	JSR PC,.LOADB
	CMP #'.,B
	BEQ MAIL1
	JSR PC,.FILEP
	BR MAIL2
MAIL1:	SPOP PRMTCH
	MOV #.WRTEC,PCHR
	SPOPS A
	PRTXTC ^/------/
	MOV #TYO,PCHR
	JMP .WRTCL
MAIL3:	BIT #RBRKF,TFLAGS
	BEQ MAIL2
	MOV USER,U
	CLR BRAKE(U)
	JSR PC,BRAKR	;ALLOW TYPING
	PRTXTC ^/BREAK/
	BR MAIL2

.READ:	JSR PC,.READF
.READ1:	MOV #.READCH,GCHR
	MOV PC,REDFLG
	JSR PC,SAVEVL
RMLOOP:	CMP #TYI,GCHR
	BEQ RMLOO1
	JSR PC,RDSTR
	BR RMLOO2
	JSR PC,READ
	BR RMLOOP	;NO TOKENS
	JSR PC,EVLINE
	ERROR+WDW
	POPS A
	BR RMLOOP	;NO OUTPUT - OK
RMLOO1:	TST TOPRNM	;DONE, PROC DEF PENDING?
	BEQ .+6
	JSR PC,END
	MOV #PSNORT,PSTOPR
	JSR PC,RESEVL
	MOV CTP,C
	CLR D
	JMP PSTOP6
RMLOO2:	BIT #RBRKF,TFLAGS
	BEQ .+4
	ERROR+BRK
	CMP #TYI,GCHR
	BEQ RMLOO1
	BR RMLOOP

.WRITE:	JSR PC,.WRTEF
	MOV #.WRTEC,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	BR .+2
	CLR WRTFLG
	JSR PC,.WRTCL
	MOV #TYO,PCHR
	RTS PC

.READF:.OPENR:	JSR PC,GETFIL
.REDF5:	CMP #200,A
	BEQ .+4
	ERROR+CRE	;CAN'T READ THAT ENTRY
.REDF4:	JSR PC,DESSET
	MOV #1,FILFLG
.REDF1:	MOV #-1,A
	TST DEOFBL
	BGT .REDF2
	MOV DSKADR,E
	JSR PC,DBREAD
	MOV #2000,A
	TST DEOFBL
	BNE .REDF2
	BITB #40,DESSAV+1
	BEQ .REDF3
	SUB DBUF+1776,A
	BR .REDF2
.REDF3:	BITB #20,DESSAV+1
	BEQ .REDF2
	DEC A
.REDF2:	MOV A,DSKNCH
	RTS PC

.READC:	TST FILFLG
	BLE .REDC1
	TST DEOFBL
	BGT .REDC1
	MOVB @DBUFPT,D
	INC DBUFPT
	DEC DSKNCH
	BGT .REDC2
	JSR F,ACSAV
	JSR PC,GNBLK
	JSR PC,.REDF1
	JSR F,ACRES
	RTS PC
.REDC1:	CLR FILFLG
	CLR REDFLG
	CLR DSKNCH
	MOV #EOFCHR,D
.REDC2:	RTS PC
.OPENA:	JSR PC,DSET
	MOV #NAME,E
	JSR PC,NFNGET
.OPNA3:	MOV #NAME,E
	JSR PC,DIRSER
	BEQ .WRTF2
	MOV @ENTBEG,A
	BIC #177477,A
	CMP #200,A
	BEQ .+4
	ERROR+CRE
	JSR PC,DESSET
	JSR PC,DELENT
.OPNA2:	JSR PC,.REDF1
	TST DEOFBL
	BGE .OPNA1
	JSR PC,GNBLK
	BR .OPNA2
.OPNA1:	MOV DSKADR,LBLKAD
	MOV DSKADR,DBGOT
	BIC #177477,DESSAV
	MOV CURDIR,WRTDIR
	MOV #2000,A
	SUB DSKNCH,A
	BEQ .WRTF1
	ADD DSKNCH,DBUFPT
	MOV A,DSKNCH
	MOV #-1,FILFLG
	RTS PC
QUEST:	MOV USER,U
	MOV UTTY(U),E
	BIS #TIMAGI,TTYST(E)
	BIC #TILIPM,TTYST(E)
	JSR PC,GTYI
	SPUSH D
	JSR PC,.CRLF
	SPOP D
	CMP #'Y,D
	RTS PC

.WRTEF:.OPENW:	JSR PC,DSET
	MOV #NAME,E
	JSR PC,NFNGET
	MOV #NAME,E
	JSR PC,DIRSER
	BEQ .WRTF2
	PRTXT ^/FILE ALREADY EXISTS.  DELETE IT?/
	JSR PC,QUEST
	BEQ .+4
	ERROR+EAES
	JSR PC,.DELT5
.WRTF2:	MOV #200,DESSAV
	JSR PC,DESWST
.WRTF1:	JSR PC,DBGET
	MOV #2000,DSKNCH
	MOV #DBUF,DBUFPT
	MOV #-1,FILFLG
	MOV CURDIR,WRTDIR
	RTS PC

.WRTEC:	DEC DSKNCH
	BLT .WRTC1
	MOVB D,@DBUFPT
	INC DBUFPT
	RTS PC
.WRTC1:	JSR F,ACSAV
	MOV DBGOT,E
	JSR PC,DBWRTE
	JSR PC,.WRTF1
	JSR F,ACRES
	BR .WRTEC

.WRTCL:	MOV DSKNCH,A
	BEQ .WRCL1
	CMP #1,A
	BEQ .WRCL2
	MOV A,DBUF+1776
	BISB #40,DESSAV+1
.WRCL1:	MOV DBGOT,E
	JSR PC,DBWRTE
	MOV #WDIRSW,D
	JSR PC,LCGRAB
	MOV WRTDIR,CURDIR
	JSR PC,DESINS
	JSR PC,WBITS
	CLR FILFLG
	MOV #WDIRSW,D
	JMP LCUGRB
.WRCL2:	BISB #20,DESSAV+1
	BR .WRCL1

.DELI:	MOV #WDIRSW,D
	JSR PC,LCGRAB
	JSR PC,GETFIL
	CMP #300,A
	BEQ .+4
.DELI1:	ERROR+CDE
	JSR PC,DESSET
	MOV DSKADR,E
	JSR PC,DBREAD
	MOV #DBUF,A
	MOV (A),B
	BIC #177700,B
	ASL B
	ADD B,A
	TST (A)
	BNE .DELI1
	MOV CURDIR,E
	JSR PC,DBREAD
	JMP .DELT5

.FILEP:	TST FILFLG
	BLT .+4
	ERROR+IFN
	SPUSH PCHR
	MOV #.WRTEC,PCHR
	SPUSH #1
	JSR PC,PRINT
.FILP1:	SPOP PCHR
	RTS PC

.FILER:	TST FILFLG
	BGT .+4
	ERROR+IFN
	SPUSH GCHR
	MOV #.READC,GCHR
	JSR PC,RQUEST
	.BUG.
	SPOP GCHR
	SKPRET

.CLOSF:	CLR REDFLG
	CLR WRTFLG
	TST FILFLG
	BLT .WRTCL
	CLR FILFLG
	RTS PC

GETFIL:	JSR PC,DSET
	MOV #NAME,E
	JSR PC,NFNGET	;WHAT FILE?
GETFI1:	MOV #NAME,E
	JSR PC,DIRSER	;FIND THE FILE
	BNE .+4		;NOT THERE!
	ERROR+FNF
	MOV @ENTBEG,A	;WHAT TYPE OF ENTRY
	BIC #177477,A
	RTS PC

.POI:	TST FILFLG
	BEQ .+4
	ERROR+FAO
	CLR DBGOT
	MOV DEFDIR,CURDIR
	JSR PC,GCDIR	;GET THE DIRECTORY
	MOV #DBUF,ENTBEG
.POI1:	MOV @ENTBEG,A
	BEQ .POI3
	BIC #177477,A
	ASH #-5,A
	JSR PC,@POITAB(A)
.POI2:	MOV @ENTBEG,A
	BIC #177700,A
	ASL A
	ADD A,ENTBEG
	BR .POI1

POIHED:	JSR PC,POFNM
	JMP .CRLF
POILNK:	.BUG.
POIFLE:	SPACE
	SPACE
	JSR PC,POFNM
	SPACE
	JSR PC,DESSET
	CLR -(P)
POIFL2:	TST DEOFBL
	BGT POIFL1
	INC (P)
	JSR PC,GNBLK
	BR POIFL2
POIFL1:	SPOP A
	ADD A,DBGOT
	JSR PC,PRDN
	JMP .CRLF
POIDIR:	INC DBGOT
	MOV #'I,D
	JSR PC,TYO
	SPACE
	BR POIHED
.POI3:	MOV DBGOT,A
	JSR PC,PRDN
	PRTXTC ^/ BLOCKS./
	MOV NBLKFR,A
	JSR PC,PRDN
	PRTXTC ^/ FREE BLOCKS./
	RTS PC
POFNM:	MOV ENTBEG,A
	TST (A)+
POIHD2:	MOVB (A)+,D
	BLT POIHD1
	JSR PC,@PCHR
	BR POIHD2
POIHD1:	JSR PC,@PCHR
	RTS PC
POTHED:	CMP CURDIR,DEFDIR
	BEQ POIHED
	RTS PC
.POTREE:
	CLR DBGOT
	MOV DEFDIR,CURDIR
	CLR DSKNSC
.POTR2:	JSR PC,GCDIR
	MOV #DBUF,ENTBEG
.POTR1:	MOV @ENTBEG,F
	BEQ .POTR3
	BIT #300,F
	BEQ .POTR4
	MOV DSKNSC,A
	BEQ .POTR4
.POTR6:	JSR PC,.SPACE
	JSR PC,.SPACE
	SOB A,.POTR6
	BR .POTR4
.POTR3:	DEC DSKNSC
	BLT .POI3
	MOV (P),E
	SPOP CURDIR
	POP ENTBEG
	JSR PC,DBREAD
	BR .POTR5
.POTR4:	BIC #177477,F
	ASH #-5,F
	JSR PC,@POTTAB(F)
.POTR5:	MOV @ENTBEG,A
	BIC #177700,A
	ASL A
	ADD A,ENTBEG
	BR .POTR1

POTDIR:	JSR PC,POIDIR
	INC DSKNSC
	TST (P)+
	PUSH ENTBEG
	SPUSH CURDIR
	JSR PC,DRREAD
	BR .POTR2

.CRINDEX:
	JSR PC,DSET
	MOV #NAME,E
	JSR PC,NFNGET
.CRIN1:	JSR PC,GCDIR
	MOV #WDIRSW,D
	JSR PC,LCGRAB
	MOV #20300,DESSAV
	JSR PC,DESWST
	JSR PC,DBGET
	JSR PC,DESINS
	BIC #377,DESSAV
	JSR PC,DESWST
	MOV CURDIR,A
	JSR PC,DBGOTN
	MOV DBGOT,CURDIR
	MOV #2000,DBUF+1776
	MOV #DBUF,ENTBEG
	JSR PC,DESINX
	JSR PC,WBITS
	MOV #WDIRSW,D
	JMP LCUGRB

.POF:	JSR PC,.READF
.POF1:	JSR PC,.READC
	CMP #EOFCHR,D
	BEQ .POF2
	JSR PC,@PCHR
	BR .POF1
.POF2:	RTS PC
.PREAD:.PWRIT:	ERROR+OOP

GNWRD:	;INPUT	POINTER TO LIST OF WORDS ON S
	;OUTPUT	-IF LIST IS NOT EMPTY,
	;	 POINTER TO  FIRST OF LIST ON TOP OF S
	;	 POINTER TO BF OF LIST NEXT
	;	 Z WILL BE CLEAR
	;	-IF LIST IS EMPTY, POP S AND SET Z
	;IF F LIST ISNT A WORD, WTA ERROR ISSUED
	JSR F,CACSAV
	MOV @S,B
	BIT #7777,B	;IS LIST EMPTY?
	BEQ GNWRD1
	JSR PC,.LOADB	;NO GET 1ST NODE
	MOV A,@S	;SAVE BF ON S
	PUSHS B		;YES - PUSH FIRST ON S
	JSR F,CACRES
	CLZ
	RTS PC
GNWRD1:	POPS A		;EMPTY LIST QUIT
	JSR F,CACRES
	SEZ
	RTS PC
NFNGET:		;INPUT	ADDRESS OF BLOCK IN E
		;	PTR TO LSTR ON S
		;OUTPUT	PUT 1ST 10. CHAR OF LSTR INTO BLOCK
		;	SET 200 BIT IN LAST CHAR, POP S
	JSR F,CACSAV
	MOV @S,B
	MOV #LSTR,A
	JSR PC,CONVER
	ERROR+IFN
	MOV B,@S
	BIC #170000,B
	MOV B,GNCN
	MOV #10.,C
NFNG1:	JSR PC,GNC	;GET NEXT CHAR
	CMP #15,D	;UGH!
	BEQ NFNG2
	MOVB D,(E)+
	SOB C,NFNG1
NFNG2:	BISB #200,-(E)	;SET 200 BIT IN LAST CHAR AND QUIT
	JSR F,CACRES
	JSR PC,SPOPT
	RTS PC
SETNM:		;INPUT	LIST OR WoRD ON S
		;OUTPUT	IF WORD, OUTPUT WORD AND SET Z
		;	IF LIST, OUTPUT LzST AND BL OF LIST ON S
		;		PUT BL ON TOP AND CLEAR Z
		;	OTHERWISE ERROR
	TST FILFLG
	BEQ .+4
	ERROR+FAO
	JSR F,CACSAV
	MOV @S,C	;GET INPUT
	BIT #7777,C
	BNE .+4
	ERROR+IFN
	MOV C,B		;CHECK IF LIST
	BIC #7777,C
	CMP C,#LIST
	BEQ SETNM1
SETNM2:	JSR F,CACRES	;OK, SET Z AND QUIT
	SEZ
	RTS PC
SETNM1:	JSR PC,COPYL	;COPY LIST - INPUT IN B
		;OUTPUT IN B;  C POINTS TO LAST NODE IN NEW LIST
		; E POINTS TO 2ND TO LAST NODE
	JSR PC,.LDP2
	MOV A,@S
	MOV E,C
	BEQ SETNM3	;NO BUTLAST
	JSR PC,.LDP1	;FIX UP  LINK
	BIC #7777,A
	JSR PC,.STP1
	BIS #LIST,B
SETNM4:	PUSHS B
	JSR F,CACRES
	CLZ
	RTS PC
SETNM3:	MOV #LSTR,B
	BR SETNM4
;LOWER LEVEL ROUTINES

;GCDIR GET CURRENT DIRECTORY
;READS IN BIT TABLE IF IT IS NOT ALREADY IN

GCDIR:	TST FDBITI	;IS THE BIT TABLE IN?
	BGE GCDIR1	;YES, GO AHEAD
	CMP USER,WDIRSW	;AM I ALREADY BRINGING IN THE BIT TABLE?
	BEQ GCDIR1	;YES, GO AHEAD WITHOUT BIT TABLE
	MOV #WDIRSW,D	;NO, LOCK THE WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB
	TST FDBITI	;IS IT IN NOW?
	BLT GCDIR2	;NO, IT'S NOW OUR RESPONSIBLITY
	MOV #WDIRSW,D	;SOMEONE ELSE BROUGHT IT IN
	JSR PC,LCUGRB	;RELEASE THE SWITCH
	BR GCDIR1
GCDIR2:	MOV #46,CURDIR	;GET THE ROOT DIRECTORY IN
	MOV #BITS,E	;THE NAME OF THE BIT TABLE
	JSR PC,DIRSER	;TRY TO FIND IT
	BNE .+4
	ERROR+BDD	;BAD DISK
	JSR PC,DESSET	;SETUP THE DESCRIPTOR
	MOV DSKADR,DBITAD	;ADDRESS OF THE BIT TABLE
	JSR PC,RBITS
	MOV FDBITS,A
	MOV A,D
	DEC A
GCDIR3:	JSR PC,BITGET
	BITB BMT(B),FDBITS+2(C)
	BEQ .+4
	DEC D
	DEC A
	BGE GCDIR3
	MOV D,NBLKFR
	INC FDBITI
	MOV #WDIRSW,D
	JSR PC,LCUGRB
GCDIR1:	MOV CURDIR,E
	JMP DBREAD


;DIRSER  DIRECTORY SEARCH
;SEARCH CURRENT DIRECTORY FOR SPECIFIED FILE
;ENTER WITH POINTER TO FILE NAME IN E
;Z IS SET IF FOUND, ELSE CLEARED
DIRSER:	SPUSH E
	JSR PC,GCDIR
	MOV #DBUF,ENTBEG
DIRSR1:	MOVB @ENTBEG,B
	BIC #177700,B
	ASL B
	ADD B,ENTBEG
DIRSR4:	MOV (P),E
	MOV ENTBEG,B
	TST (B)+	;SKIP THE FIRT WORD
	BEQ DIRSR3	;FOUND THE END OF THE DIRECTORY
DIRSR2:	CMPB (B)+,(E)+	;COMPARE NAMES BYTE BY BYTE
	BNE DIRSR5	;MISMATCH
	TSTB -1(B)	;END OF NAMES?
	BGE DIRSR2	;NOT YET
	TST (P)+	;YES, FLUSH TEMP ON STACK
	CLZ
	RTS PC
DIRSR3:	TST (SP)+
	SEZ
	RTS PC
DIRSR5:	MOVB -(B),A	;MISMATCHED CHARACTER IN DIRECTORY
	MOVB -(E),E	;SAME THING IN DESIRED NAME
	BIC #177600,A	;GET RID OF CRAP
	BIC #177600,E	;SAME
	CMP A,E		;WHAT IS THE REAL RELATIONSHIP?
	BGT DIRSR3	;DIRECTORY>DESIRED, WE ARE PAST WHAT WE WANT
	BLT DIRSR1	;DESIRED>DIRECTORY, MAYBE IT'S FURTHER ON.
	TSTB (B)	;SAME, IS DIRECTORY SHORTER?
	BLT DIRSR1	;YES, MAYBE FURTHER ON.
	BR DIRSR3


;DESSET SET UP DESCRIPTOR

DESSET:	CLR DBCNT
	CLR DSKADR
	MOV #-1,DEOFBL
	MOV ENTBEG,A
	MOV #DESSAV,B
	MOV (A),C
	BIC #177700,C
	CMP C,#31.
	BLE .+4
	ERROR+BADD	;BAD DIRECTORY?
	MOV C,D
	MOV (A)+,(B)+
	SOB C,.-2
DESST:	MOV #DESSAV,A
	MOV A,C
	MOV (A),E
	BIC #177477,E
	CMP #200,E
	BNE .+6		;NO, DIRECTORY
	SUB #2,D	;YES, DATE IS NOT PART OF DESCRIPTOR
	ASL D		;NUMBER OF WORDS
	ADD D,C		;END OF DESCRIPTOR
DESST2:	TSTB -(C)
	BEQ .-2
DESST1:	MOV C,DESEPT	;REAL END OF ESCRIPTOR
	CMP #100,E
	BNE .+4
	ERROR+BADE	;BAD ENTRY TYPE
	TST (A)+	;SKIP FIRST WORD
	TSTB (A)+	;FIND END OF NAME
	BGE .-2
	BR GNBLK1


;GNBLK GET THE ADDRESS OF THE NEXT BLOCK INTO DSKADR
GNBLK:	INC DSKADR
	DEC DBCNT
	BLT GNBLK2
GNBLK3:	BNE GNBLK4	;MORE THAN THIS BLOCK LEFT
	CMP DESPNT,DESEPT	;AT END OF DESCRIPTOR?
	BLOS GNBLK4	;NO, HAPPY
	CLR DEOFBL	;READING LAST BLOCK
GNBLK4:	MOV #DBUF,DBUFPT
	RTS PC
GNBLK2:	MOV DESPNT,A	;NO BLOCKS LEFT TO COUNT, LOOK INTO DESCRIPTOR
GNBLK1:	CMP A,DESEPT
	BLOS GNBLK7
	MOV #1,DEOFBL
	RTS PC
GNBLK7:	MOVB (A)+,B
	MOV A,DESPNT	;NEW POINTER
	MOV B,C
	BIC #177477,B	;WHAT KIND OF BYTE?
	BIC #177700,C	;WITH WHAT DATA
	ASH #-5,B
	MOV #DESMOD,F
	JMP @GNBTAB(B)	;SERVICE THAT TYPE

GNBSKP:	TST C	;ZERO IS THE NULL BYTE
	BEQ GNBLK1	;REALLY ONLY FOR THE END OF DESCRIPTOR, BUT...
	ADD C,DSKADR
	MOV #DBGSKP,(F)
	CLR DBCNT
	BR GNBLK3

GNBCNT:	MOV #DBGCNT,(F)
	MOV C,DBCNT
	BR GNBLK3

GNBADR:	MOVB (A)+,DSKADR
	MOVB (A)+,DSKADR+1
	MOV A,DESPNT
	MOV #DBGADR,(F)
	MOV C,DBCNT
	BR GNBLK3

GNBSCN:	MOV C,B
	BIC #177770,B
	BIC #177707,C
	ASH #-3,C
	ADD C,DSKADR
	MOV #DBGSCT,(F)
	MOV B,DBCNT
	BR GNBLK3

DESWST:	MOV #NAME,A
	TSTB (A)+
	BGE .-2
	CLRB (A)
	MOV A,DESPNT
	MOV #-1,LBLKAD
	MOV #DBGSKP,DESMOD
	RTS PC

DBGET:	MOV FDBITS,E
	CLR A
DBGET1:	JSR PC,BITGET
	BITB BMT(B),FDBITS+2(C)
	BEQ DBGET2
	INC A
	SOB E,DBGET1
	ERROR+DFU
DBGET2:	DEC NBLKFR
	MOV A,DBGOT
	BISB BMT(B),FDBITS+2(C)
DBGOTN:	MOV A,B
	SUB LBLKAD,B
	MOV A,LBLKAD
	MOV #DESMOD,F
	DEC B
	BEQ DBGET3
	CMP B,#7
	BLE DBGET4
	CMP B,#77
	BLE DBGET5
	MOV DESPNT,B
	MOVB #200,(B)+
	MOVB LBLKAD,(B)+
	MOVB LBLKAD+1,(B)+
	MOV B,DESPNT
	MOV #DBGADR,(F)
	RTS PC
DBGET4:	ASH #3,B
	BIS #300,B
	MOV #DBGSCT,(F)
DBGET6:	MOVB B,@DESPNT
	INC DESPNT
	RTS PC
DBGET5:	MOV #DBGSKP,(F)
	BR DBGET6
DBGET3:	MOV DESPNT,A
	JMP @DESMOD

DBGSK1:	INC A
DBGSKP:	MOVB #100,(A)
	INC DESPNT
	MOV #DBGCNT,(F)
	RTS PC
DBGCNT:	MOVB -(A),B
	BIC #177700,B
	INC B
	BIT #100,B
	BNE DBGSK1
	INCB (A)
	RTS PC
DBGADR:	MOVB -3(A),B
	BIC #177700,B
	INC B
	BIT #100,B
	BNE DBGSKP
	INCB -3(A)
	RTS PC
DBGSCT:	MOVB -(A),B
	BIC #177770,B
	INC B
	BIT #10,B
	BNE DBGSK1
	INCB (A)
	RTS PC

DESINS:	CMP #46,CURDIR
	BNE DESIN5
	BIT #SSF,FLAGS2
	BNE DESIN5
	JSR PC,WDELBL
	ERROR+DRF
DESIN5:	MOV #NAME,E
	JSR PC,DIRSER
	BEQ DESINX
	JSR PC,WDELBL
	ERROR+EAES
DESINX:	JSR PC,DESINC
	ASL A
	MOV #DBUF+1776,B
	SUB (B),B
	TST (B)+
	MOV B,C
	ADD A,C
	CMP #DBUF+1770,C
	BGT DESIN4
	JSR PC,.DELBL
	ERROR+DRF
DESIN4:	CLR (C)
DESIN2:	CMP B,ENTBEG
	BEQ DESIN3
	MOV -(B),-(C)
	BR DESIN2
DESIN3:	MOV #DESSAV,C
	SUB A,DBUF+1776
	ASR A
	MOV (C)+,(B)+
	SOB A,.-2
	MOV CURDIR,E
	JMP DBWRTE
DESINC:	MOV DESPNT,A
	BIT #1,A
	BEQ .+4
	CLRB (A)+
	MOV DESSAV,B
	BIC #177477,B
	CMP #200,B
	BNE DESIN1
	MOV #-1,(A)+
	MOV #-1,(A)+
DESIN1:	SUB #DESSAV,A
	ASR A
	ADD A,DESSAV
	RTS PC




;ENTER DBREAD AND DBWRTE WITH ADDRESS OF BLOCK TO HACK IN E
DBREAD:	MOV #DREADC,F
	BR .+6
DBWRTE:	MOV #DWRTEC,F
	MOV E,D
	SPUSH A
	SPUSH B
	SPUSH C
	JSR PC,SYDRBG	;GET THE REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-1000,(A)+	;ONE SIZE, ONE PRICE, ONE QUALITY!
	MOV #DBUF,(A)+	;AND ONE PLACE TO PUT IT
	.IFNZ SEG
	MOV USER,B	;TO FIND THE APPROPRIATE SLOT
	MOV SLOTAS(B),B
	SUB #PURE,-(A)
	MOV SLOTHA(B),C
	ADD SLOTCA(B),(A)+
	ADC C
	ASH #4,C
	BIS C,6(A)
	.ENDC
DBWRT1:	ASL D
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	MOV D,(A)+
	MOV #-1,(A)+
	TST (A)+
	BISB F,(A)
	JSR PC,DSKWAI
	SPOP C
	SPOP B
	SPOP A
	RTS PC

WBITS:	JSR PC,WBITS1
WCBITS:	MOV #DWRTCC,F
	BR .+6
RBITS:	MOV #DREADC,F
	BR .+6
WBITS1:	MOV #DWRTEC,F
	JSR PC,SYDRBG
	CLR (A)+
	MOV #-NBTTL,(A)+
	MOV #FDBITS,(A)+
	SUB #6,P
	MOV DBITAD,D
	BR DBWRT1

BITGET:	MOV A,B		;A CONTAINS THE BLOCK NUMBER
	MOV A,C		;B WILL CONTAIN THE BIT NUMBER
	BIC #177770,B	;THERE!
	ASH #-3,C	;AND C GETS THE BYTE NUMBER
	RTS PC

	.ENDC		;END OF NFILES CONDITIONAL
	.STITL FILEING
	.IFNZ OFILES

;SET UP TO READ FILE SPECIFIED IN DIRNAM AND FNAME
READF:	MOV #DIRNAM,B
	TST (B)
	BEQ IUNERR	;BAD USER NAME
	JSR PC,FILFIN	;TRY TO FIND FILE
	BR FNFERR	;CAN'T
	MOV 10(A),DSKNSC	;NUMBER OF SECTORS IN FILE
	BIC #170000,DSKNSC	;CLEAR TYPE BITS
READF1:	MOV #400,DSKNCH	;NUMBER OF CHARS IN A BLOCK
	MOV DBUFAD,DBUFPT
	DEC DSKNSC	;ONE LESS SECTOR
	BLT NMSERR	;WHAT, NO MORE SECTORS???
	SPUSH #BUFRED
	JSR PC,DSKSEC	;READ THE SECTOR
			;INTO (DBUFAD)
			;FROM (DSKADR)
			;DREADC
	INC DSKADR
READF2:	CLR A	;SUCCESS!
	RTS PC
FNFERR:	MOV #2,A	;FILE NOT FOUND ERR
	RTS PC
NMSERR:	BPT		;NO MORE SECTORS??
	MOV #3,@DBUFAD	;PUT AN END OF FILE CHAR
	BR READF2

;READ A CHAR FROM DISK BUFFER, GET A NEW BLOCK IF NEEDED
READCH:	TST DSKNCH	;IS THERE A FILE OPEN?
	BLE READEF	;NO, GIVE AN EOF CHAR
	MOVB @DBUFPT,D	;GET CHAR
	CMP #EOFCHR,D	;END OF FILE?
	BEQ READE1	;CLOSE FILE AND GIVE EOF
	INC DBUFPT
	DEC DSKNCH	;ANY MORE CHARS IN THIS BUFFER?
	BGT READC1	;YES
	JSR F,ACSAV
	JSR PC,READF1
	JSR F,ACRES
READC1:	RTS PC
READE1:	CLR DSKNCH
READEF:	MOV #EOFCHR,D
	RTS PC

WRITEF:	TST DIRNAM
	BEQ IUNERR
	MOV #WRTELC,D
	JSR PC,LCGRAB
	MOV #DIRNAM,B
	JSR PC,FILFIN	;IS THE FILE ON DISK ALREADY?
	BR WRTEF2	;NO, WE CAN PUT IT THERE
	MOV #6,A
	BR WRTRET
WRTEF2:	CMP #-1,12(A)
	BNE WRTEF3
	MOV #4,A
	BR WRTRET
WRTEF3:	MOV #4,E	;COPY NAME INTO DIRECTORY
	MOV (B)+,(A)+
	DEC E
	BGT .-4
	MOV A,DDIRPT	;POINTER INTO DIRECTORY
	MOV (A),DSKNSC
	BIC #160000,DSKNSC	;NUMBER OF AVAILABLE SECTORS
	MOV #400,DSKNCH
	MOV DBUFAD,DBUFPT
	CLR A
	RTS PC
IUNERR:	MOV #12,A
	RTS PC
WRTRET:	MOV #WRTELC,D
	JSR PC,LCUGRB
	RTS PC
WRITEC:	TST DSKNCH	;FILE OPEN?
	BNE .+4
	BPT
	MOVB D,@DBUFPT
	INC DBUFPT
	DEC DSKNCH	;BUFFER FULL?
	BGT WRTEC2
WRTEBF:	DEC DSKNSC	;MORE ROOM ON DISK
	BLT WRTEC1	;NO, MAKE OFF YOU WROTE BLOCK
	JSR F,ACSAV
	SPUSH #BUFWRT
	JSR PC,DSKSEC	;WRITE (DBUFAD) OUT TO (DSKADR)
	INC DSKADR
	JSR F,ACRES
WRTEC1:	MOV #400,DSKNCH
	MOV DBUFAD,DBUFPT
WRTEC2:	RTS PC
WRITCU:	MOV #EOFCHR,D
	JSR PC,WRITEC
	CMP #400,DSKNCH	;DID WE JUST OUTPUT A BLOCK?
	BNE WRITCU	;NO, PUT EOFS IN BLOCK
	CLR DSKNCH
	MOV DDIRPT,A
	TST DSKNSC	;NEG NO OF SECTORS IS DISK FULL FLAG
	BGE WRTCU1	;OK, THERE WAS ROOM
	MOV #10,A
	BR WRTCU3
WRTCU1:	MOV (A),B	;NUMBER OF SECTORS AVAILABLE ON DISK
	SUB DSKNSC,B	;RESULT IS FILE LENGTH
	MOV B,(A)+	;PUT IT INTO FILE DESCRIPTION
	TST (A)	;IS THIS THE END OF THE DIRECTORY BLOCK?
	BGE WRTCU2	;NO, PUT NEW END FILE IN
	SPUSH #DIRWRT
	JSR PC,DSKSEC	;WRITE OUT THIS DIRECTORY BLOCK
			;FROM (DDIRAD)
			;OUT TO (DSKDAD)
			;DWRTEC
	INC DSKDAD
	MOV DDIRAD,A
	INC 372(A)	;ONE LESS BLOCK LEFT
WRTCU2:	CLR (A)+
	CLR (A)+
	CLR (A)+
	CLR (A)+
	MOV DSKNSC,(A)	;NUMBER OF SECTORS LEFT
	SPUSH #DIRWRT
	JSR PC,DSKSEC	;WRITE OUT THIS DIRECTORY BLOCK
			;FROM (DDIRAD)
			;OUT TO (DSKDAD)
			;DWRTEC
	CLR A
WRTCU3:	BR WRTRET
DELETF:	MOV #DIRNAM,B
	TST (B)
	BEQ IUNERR
	MOV #WRTELC,D
	JSR PC,LCGRAB
	JSR PC,FILFIN
	BR DFNFER
	TST 10(A)
	BGE .+4
	ERROR+CDF
	BIS #200,(A)
DELET1:	SPUSH #DIRWRT
	JSR PC,DSKSEC	;WRITE OUT THIS DIRECTORY BLOCK
			;FROM (DDIRAD)
			;OUT TO (DSKDAD)
			;DWRTEC
	CLR A
	BR WRTRET
DFNFER:	MOV #2,A
	BR WRTRET

UDELEF:	MOV #DIRNAM,B
	TST (B)
	BEQ IUNERR
	BIS #200,(B)
	MOV #WRTELC,D
	JSR PC,LCGRAB
	JSR PC,FILFIN
	BR UFNFER
	BIC #200,(A)
	BIC #200,(B)
	BR DELET1
UFNFER:	BIC #200,(B)
	BR DFNFER
	.IFTF
READPT:	JSR PC,PINIT
	MOV #101,PRS
	MOV #PRGET,GCHR
	RTS PC
	.IFT
PREAD:	TST PRS
	BGE .+4
	ERROR+DNR
	JSR PC,PINIT
	MOV #FNAME,C
	JSR PC,G1FN
	ERROR+IFN
	JSR PC,WRITEF
	TST A
	BEQ PREAD1
	MOV #-1,PGRAB
	JSR PC,FILERR
PREAD1:	MOV #101,PRS
PREAD2:	JSR PC,PRGET
	JSR PC,WRITEC
	CMP #EOFCHR,D
	BNE PREAD2
	MOV #-1,PGRAB
	JSR PC,WRITCU
	JSR PC,FILERR
	RTS PC
	.IFTF
PINIT:	TST PGRAB
	BLT .+4
	ERROR+DIU
	MOV USER,PGRAB
	MOV #PBUF,PBFPTI
	MOV #PBUFE-1,PBFPTM
	CLR NPCHRS
	RTS PC
PRGET:	SPUSH U
	MOV USER,U
PRGET2:	TST NPCHRS
	BNE PRGET1
	JSR PC,FLUSH
	BR PRGET2
PRGET1:	JSR PC,RUNME
	SPOP U
	BIC #100,PRS
	DEC NPCHRS
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	MOVB @PBFPTM,D
	BIS #100,PRS
	RTS PC
PRBRK:	SPUSH A
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOV PRB,A
	TST PRS
	BGE PRBRK1
	MOV #EOFCHR,A
PRBRK1:	BIC #200,A
	BEQ PRBRK2
	MOVB A,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	CMP #PBUFE-PBUF,NPCHRS
	BNE .+10
	BIC #100,PRS
PRBRK2:	SPOP A
	INC PRS
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT
	.IFT
PWRITE:	MOV #FNAME,C
	JSR PC,G1FN
	ERROR+IFN
	JSR PC,READF
	JSR PC,FILERR
	JSR PC,PINIT
	JSR PC,FEED
PWRIT1:	JSR PC,READCH
	JSR PC,PPPUT
	CMP #EOFCHR,D
	BNE PWRIT1
	MOV #10.,A
	JSR PC,FEED1
	JSR PC,FEED
	MOV #-1,PGRAB
	RTS PC

	.IFTF
WRITEP:	JSR PC,PINIT
	JSR PC,FEED
	INC DSKNCH	;FAKE OUT WORLD
	MOV #PPPUT,PCHR
	JSR PC,SHOWAL
	BR .+2
	CLR DSKNCH
	MOV #TYO,PCHR
	MOV #EOFCHR,D
	MOV #10.,A
	JSR PC,FEED1
	JSR PC,FEED
	MOV #-1,PGRAB
	RTS PC

FEED:	MOV #100.,A
	CLR D
FEED1:	JSR PC,PPPUT
	DEC A
	BNE FEED1
	RTS PC

PPPUT:	SPUSH U
PPPUT2:	MOV USER,U
	CMP #PBUFE-PBUF,NPCHRS
	BNE PPPUT1
	JSR PC,FLUSH
	BR PPPUT2
PPPUT1:	JSR PC,RUNME
	SPOP U
	TST PPS
	BPL .+4
	ERROR+DNR
	CLR PPS
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOVB D,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	BIS #100,PPS
	RTS PC

PPBRK:	TST NPCHRS
	BEQ PPBRK1
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	DEC NPCHRS
	MOVB @PBFPTM,PPB
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT
PPBRK1:	CLR PPS
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT
	.IFT
MOUNT:	JSR PC,CKSST
	JSR	PC,G1NARG
	MOV	B,F
	TST	B
	BGE	.+4
MOUNT1:	ERROR+IFN
	CMP	#3,B
	BLT	MOUNT1
	ASL	B
	ROR	F
	ROR	F
	ROR	F
	ROR	F
	MOV	F,FHEADD(B)
	RTS PC

UNMOUNT:	JSR PC,CKSST
	JSR	PC,G1NARG
	TST	B
	BLT	MOUNT1
	CMP	#3,B
	BLT	MOUNT1
	ASL	B
	MOV	#-1,FHEADD(B)
	RTS PC

EXCHD:	MOV	DDIRLS,A
	MOV	DDIRLS+2,DDIRLS
	MOV	DDIRLS+4,DDIRLS+2
	MOV	A,DDIRLS+4
	RTS PC

;COMMON LIST FILE DIRECTORY CODE
;MOV #<ADDR OF ROUTINE TO CALL FOR EACH FILE>,E
;JSR PC,CLISTF
CLISTF:	SPUSH #DDIRLS
CLIST2:	MOV	@(P),D
	BLT	CLIST1
	ADD	#2,(P)
	CMP	#-1,(D)
	BEQ	CLIST2
	MOV	(D),D
	MOV	D,DSKDAD
	BIC #17777,D
CLIST3:	MOV DDIRAD,DDIRPT
	SPUSH #DIRRED
	JSR PC,DSKSEC	;READ ANOTHER BLOCK OF DIRECTORY
			;INTO (DDIRAD)
			;FROM (DSKDAD)
			;DREADC
	INC DSKDAD
CLIST4:	MOV DDIRPT,A
	TST (A)		;IS THERE AN ENTRY?
	BLT CLIST3	;TRY NEXT BLOCK OF DIRECTORY
	JSR PC,@E	;PROCESS ENTRY
	TST @DDIRPT
	BEQ CLIST2
	ADD #12,DDIRPT
	BR CLIST4
CLIST1:	TST (P)+
	RTS PC

;THIS CRETIN LISTS EVERYTING!!
LSTALF:	BIT #200,(A)	;EVEN DELETED FILES
	BEQ LSTAL1
	PRTXT ^X!X
LSTAL1:	JSR PC,TYPE4
	SPACE
	JSR PC,TYPE4
	SPACE
	MOV (A),A	;SECTOR COUNT AND TYPE BITS
	JSR PC,PRON	;IN OCTAL!!!
	JMP .CRLF

LSTAUF:	TST (A)
	BEQ LSTFBL
	BIT #200,(A)	;IS THE FILE THERE?
	BNE LSTAU1	;NO
	CMP DIRNAM,(A)+	;THIS USER?
	BNE LSTAU1	;NO
	CMP DIRNAM+2,(A)+
	BNE LSTAU1
	JSR PC,TYPE4
	SPACE
	MOV (A),A
	BIC #170000,A
	JSR PC,PRDN
	JMP .CRLF

LSTAUS:	BIT #200,(A)
	BNE LSTAU1
	MOV DBUFAD,B
LSTUS4:	TST (B)
	BEQ LSTUS1
	CMP (A),(B)+
	BNE LSTUS2
	CMP 2(A),(B)
	BEQ LSTAU1
LSTUS2:	TST (B)+
	BR LSTUS4
LSTUS1:	MOV (A),(B)+
	MOV 2(A),(B)+
	CLR (B)+
	JSR PC,TYPE4
	JMP .CRLF
LSTAU1:	RTS PC

TYPE4:	MOV #4,C
TYPE41:	MOVB (A),D
	BNE .+6
	MOV #40,D
	JSR PC,@PCHR
	INC A
	DEC C
	BGT TYPE41
	RTS PC

LSTFBL:	MOV 10(A),A
	JSR PC,PRDN
	PRTXT ^/ FREE BLOCKS./
	JMP .CRLF
;DISK COMPRESOR
COMPRE:	JSR PC,CKSST
	CLR DSKNSC
	CLR DSKADR
	MOV #COMPF,E
	JSR PC,CLISTF	;COMPRESS FILES
	MOV #-1,DSKNSC
	MOV #COMPD,E
	JSR PC,CLISTF	;COMPPRESS DIRECTORYS
	RTS PC

;COMPRESS FILES ON ALL DISKS (CALLED BY CLISTF)
COMPF:	TST (A)	;IS THIS THE LAST FILE ON THIS DISK?
	BEQ COMPF4
	CMP DSKADR,DSKNSC	;HAVE ANY FILES BEEN REMOVED YET?
	BNE COMPF1	;YES
COMPF3:	ADD 10(A),DSKADR	;ADDRESS OF THE NEXT FILE
	BIC #160000,DSKADR	;CLEAR TYPE BITS
	BIT #200,(A)	;IS THIS FILE DELETED?
	BNE COMPF2	;YES
	ADD 10(A),DSKNSC	;NO, PPRESERVE IT
	BIC #160000,DSKNSC
COMPF2:	RTS PC
COMPF1:	BIT #200,(A)	;IS THIS FILE DELETED?
	BNE COMPF3	;YES, IGNORE IT
	MOV 10(A),C	;NO, THIS IS NO OF BLOCKS TO COPY
	BIC #170000,C
	MOV DSKDAD,D
	BIC #17777,D	;GIVES US WHICH DISK
	BIS D,DSKADR
	BIS D,DSKNSC
COMPF5:	DEC C	;ANY MORE BLOCKS?
	BLT COMPF2	;NO
	SPUSH #BUFRED
	JSR PC,DSKSEC	;TRANSFER A BLOCK
			;INTO (DBUFAD)
			;FROM (DSKADR)
			;DREADC
	INC DSKADR
	SPUSH #NSCWRT
	JSR PC,DSKSEC	;AND BACK OUT
			;FROM (DBUFAD)
			;OUT TO (DSKNSC)
			;DWRTEC
	INC DSKNSC
	BR COMPF5
COMPF4:	CLR DSKADR	;SET UP FOR NEW DISK
	CLR DSKNSC
	RTS PC

;COMPRESS DIRECTORY
COMPD:	CMP #-1,DSKNSC	;IS THIS THE FIRST FILE?
	BEQ COMPD1	;YES
COMPD3:	BIT #200,(A)	;THIS FILE DELETED?
	BEQ COMPD4	;NO
	ADD 10(A),DSKNSC	;YES, THAT MANY SECTORS SAVED
COMPD5:	RTS PC
COMPD4:	MOV DBUFPT,C
	MOV #5,B
COMPD6:	MOV (A)+,(C)+
	DEC B
	BGT COMPD6
	MOV C,DBUFPT
	TST -12(A)	;DID WE JUST COPY THE END BLOCK?
	BEQ COMPD2	;YES
	TST (C)	;IS THIS THE END OF THE DIRECTORY BLOCK?
	BGE COMPD5	;NO, JUST RETURN
COMPD7:	SPUSH #BUFWRT
	JSR PC,DSKSEC	;WRITE OUT THIS DIRECTORY BLOCK
			;FROM (DBUFAD)
			;OUT TO (DSKADR)
			;DWRTEC
	INC DSKADR
	INC (C)	;NEXT DIRECTORY BLOCK
	MOV DBUFAD,DBUFPT
	RTS PC
COMPD2:	ADD DSKNSC,-(C)	;NEW NUMBER OF FREE BLOCKS
	BIC #170000,(C)
	JSR PC,COMPD7	;WRITE OUT DIRECTORY BLOCK
	MOV #-1,DSKNSC	;NEXT TIME WILL BE NEW DISK
	RTS PC
COMPD1:	MOV DSKDAD,DSKADR
	DEC DSKADR
	CLR DSKNSC
	MOV DDIRAD,B	;SET UP FOR NEW DISK
	MOV DBUFAD,C
	MOV C,DBUFPT
	MOV #125.,D
	CLR (C)+
	DEC D
	BGT .-4
	MOV 250.(B),(C)	;NUMBER OF DIRECTORY BLOCKS
	BR COMPD3	;GO DO FIRST FILE
	.ENDC
	.STITL SCHEDULER


RUNME:	TST USER
	BGE RUNME1
RUNME2:	RTS PC	;SYSTEM CALLED RUNME

RUNME1:	TST FLSADR(U)	;IF HE WANTS TO RUN HE SHOULD JSR HERE
	BEQ RUNME2	;IF FLSADR IS ZERO, JUST KEEP RUNNING HIM
	MOV #-1,USER	;SYSTEM IS NOW USER
	JSR PC,UACSAV	;STORE HIS ACS
	CLR FLSADR(U)	;GUY IS NOW RUNABLE
	CLR FLSRES(U)
	INC NRABLU
	SPOP UPC(U)	;HE SHOULD START AFTER THE JSR PC,RUNME
NEXTU1:	CMP #SYSIDX,U	;IS IT THE SYSTEM JOB?
	BNE NEXTU2
	MOV P,SPDLP	;SET UP SYS JOB PDL
	MOV SJPDLP,P
	JMP RUNUS7

NEXTU2:	MOV SLOTAS(U),A	;IS HE ASSIGNED A SLOT?
	BLT NEXTU3	;NO, SEE IF WE CAN GET ONE
	TST SLOTST(A)	;YES, WHAT IS IT'S STATUS?
	BEQ NEXTUS	;GUY BEING SWAPPED IN
;WE GET HERE IF THE GUY IS IN CORE
	CMP #FRNEWU,FLSRES(U)	;RELOAD USER
	BNE NEXT14	;IN CORE AND NOT BEING GUNNED, RUN HIM
	CLR TIMUSD(U)
	MOV #UGO,FLSADR(U)	;RESTART HIM
NEXT16:	MOV A,SLOTAS(U)
	MOV U,SLOTU(A)
	MOV SLOTRB(A),C	;CORE ADDRESS OF ASSIGNED SLOT
	MOV #16,D
	JMP NEXT11	;GO DO A SPECIAL SWAPIN

NEXT14:	CLR FLSRES(U)
	JMP RUNUSR



;CALL TO GET INDEX OF NEXT USER TO RUN

NEXTUS:	MOV TTYUGO,U	;DID SOMEONE JUST TYPE CR?
	BGE NEXT15
	SUB #LUBLK,ULAST	;COUNT BACKWARDS
	BGE .+10	;DON'T GO NEG
	MOV #MNUSRS*LUBLK,ULAST	;LAST POSSIBLE USER INDEX
	MOV ULAST,U	;SEE IF THIS IS A GOOD GUY TO RUN
NEXT15:	MOV #-1,TTYUGO
	TST FLSADR(U)	;IF FLSADR IS ZERO, RUNABLE(???)
	BEQ NEXTU1	;RUN HIM.
	CMP #-1,FLSADR(U)	;-1 => NON EX USER
	BEQ NEXTUS
.IFNZ A1120
	MOV GUNU,MQ
	BLT NEXT21
	MOV #LUBLK,MULTIP
	CMP U,MQ
	BNE NEXT21
.IFF
	SPUSH B
	MOV GUNU,B
	BLT NEX21B
	MUL #LUBLK,B
	CMP U,B
	BNE NEX21B
	SPOP B
.ENDC
	MOV #-1,GUNU
	MOV U,USER	;USER IS NOW USER
	MOV PC,BRAKE(U)
	JMP GOODBY

.IIF NZ A1145,NEX21B:	SPOP B
NEXT21:	TSTB	FLSRES(U)
	BMI	NEXTUS
	MOV U,USER	;USER IS NOW USER
	JSR PC,UACRES	;RESTORE HIS ACS
	JMP @FLSADR(U)	;SEE IF HE SHOULD REALLY RUN



NEXTU3:	MOV PUSPSL,A	;SEE IF THERE IS A PREFERED SLOT
	BGE NEXTU6
NEXT20:	CLR A
	MOV NSLOTS,C
NEXTU4:	TST SLOTST(A)
	BLT NEXT16	;AN UNUSED SLOT!
	CMP #1,SLOTST(A)
	BGE NEXTU5	;GUY HASN'T RUN YET, DON'T SWAP HIM OUT
	TST NSWPU	;ARE THERE USERS BEING SWAPED?
	BEQ NEXTU6	;NO, SWAP ONE
	CMP NINU,#1	;IS THERE ONLY ONE USER IN CORE?
	BEQ NEXTUS	;YES, RUN HIM
NEXTU6:	MOV SLOTU(A),B	;USER THAT MAY BE SWAPED OUT
	BLT NEXT20
	CMP #FRTYIW,FLSRES(B)
	BEQ NEXT17
	MOV #LOCKUS,D
	MOV #NLOCKS,E
NEXT18:	CMP B,(D)+
	BNE NEXT19	;LOCKED IN CORE, DO NOT DISTURB
NEXT17:	TST PUSPSL
	BLT NEXTU5
	MOV #-1,PUSPSL
	BR NEXT20
NEXTU5:	TST (A)+
	.IFNZ A1120
	DEC C
	BNE NEXTU4
	.ENDC
	.IIF NZ A1145,SOB C,NEXTU4
	BR NEXTUS

NEXT19:
	.IFNZ A1120
	DEC E
	BGT NEXT18
	.ENDC
	.IIF NZ A1145,SOB E,NEXT18
	MOV #-1, PUSPSL	;IF THERE WAS A PREFERED SLOT, WE ARE DOING IT
	MOV SLOTU(A),B	;FOUND A GOOD SLOT, USER TO SWAP OUT INTO B
	MOV U,SLOTU(A)	;NEW OCCUPANT OF SLOT
	MOV #-1,SLOTAS(B)
	MOV A,SLOTAS(U)

;FALLS THROUGH

;FALLS IN

	CLR D
	MOV SLOTRB(A),C	;MOBY SWAP OUT BLOCK FOR THIS SLOT
	MOV #SWPOST,(C)+	;SWAP OUT USER START ROUTINE
	MOV USWCNT,(C)+	;WORD COUNT OF A USER SLOT
	MOV SLOTCA(A),(C)+	;SLOT CORE ADDRESS
	MOV USWPAD(B),(C)+	;LOW ORDER SWAP OUT ADDR OF U TO SWAP OUT
	MOV USWPAD+2(B),(C)+	;HIGH OORDER
	TST (C)+	;WASTED WORD
	.IFNZ SEG
	MOV SLOTHA(A),E
	ASH #4,E
	BIS E,(C)
	.ENDC
	BIS #DWRTEC,(C)+	;DISK WRITE COMMAND
	DEC NINU	;ONE LESS IN CORE
NEXT11:	CLR SLOTST(A)	;NOT IN YET: -1 TO SLOTST+2 OF GUY
	INC NSWPU	;ONE MORE MOVING AROUND
	MOV #SWPIST,(C)+	;SWAP IN USER START ROUTINE
	MOV USWCNT,(C)+	;SLOT WORD COUT
	MOV SLOTCA(A),(C)+	;SLOT CORE ADDRESS
	CMP #FRNEWU,FLSRES(U)
	BNE NEXT12
	MOV DCLRUS,(C)+	;DISK ADDRESS OF CLEAR USER
	MOV DCLRUS+2,(C)+
	CLR FLSRES(U)
	MOV #UGO,FLSADR(U)
	BR NEXT13

NEXT12:	MOV USWPAD(U),(C)+	;  "    "   
	MOV USWPAD+2(U),(C)+	;USER ADDRESS ON DISK
NEXT13:	MOV A,(C)+	;ADDRESS OF PLACE TO ZAP TO 1 WHEN DONE
	.IFNZ SEG
	MOV SLOTHA(A),E
	ASH #4,E
	BIS E,(C)
	.ENDC
	BIS #DREADC,(C)	;READ FROM DISK
	SUB #32,C	;BEGINING OF MOOBY SWAP REQ PAIR
	ADD D,C		;INDEX TO RIGHT ONE OF PAIR
	SPUSH PS
	MOV #340,PS	;NO INTS!
	MOV C,@SWPLEP
	ADD #2,SWPLEP	;GRONK ONTO REQ LIST
	SPOP PS
	JSR PC,DPROVK
	BR NEXT10

NEXTU7:	BR .+2	;CHANGE TO WAIT IF ONLY ONE USER
	MOV #-1,USER	;FLUSH ENTERS HERE, SYSTEM NOW USER
	BLT NEXT10
	MOV SLOTAS(U),A
	TST (A)	;IS HE REALLY IN?
	BLE NEXT10	;NO, NOT REALLY
	CMP #FRDSKW,FLSRES(U)	;IF JUST HUNG ON DISK
	BEQ NEXT10	;FORGET HIM
	MOV A,PUSPSL	;HE IS PREFERED OUT
	MOV U,PUSRSP
	BR NEXT10

NEXT10:	JMP NEXTUS
FLUSH:	TST USER
	BGE FLUSH4
	RTS PC

FLUSH4:	.IIF NZ A1145, CLR 177570	;CLEAR DISPLAY REGISTER
.IIF NZ NEWDIS,CLR DISPDR
	JSR PC,UACSAV	;STOP USER; STORE HIS ACS
	MOV FLSADR(U),A
	SPOP FLSADR(U)	;SAVE PC
	TST A	;IS THIS GUY ALREADY STOPED?
	BNE NEXTU7	;GO TRY ANOTHER GUY
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
	MOV #-1,USER
	MOV UTIME,A
	ADD A,JMTU(U)
	.IFNZ A1120
	ASR A
	ASR A
	ASR A
	ASR A
	ASR A
	.ENDC
	.IIF NZ A1145, ASH #-5,A
	ADD A,TIMUSD(U)
	ADD A,TUTIME
	ADC TUTIME+2
	MOV #4,A
	MOV #LSTIM,B
	ADD U,B
	MOV #RSEC,C
FLUSH3:	MOVB (C)+,(B)+
	.IFNZ A1120
	DEC A
	BNE FLUSH3
	.ENDC
.IIF NZ A1145, SOB A,FLUSH3
	TST FLSRES(U)
	BNE .+10
	MOV #FRRAND,FLSRES(U)
	DEC NRABLU
	CMP #SYSIDX,U
	BEQ FLUSH7
	CLR 177774
	MOV P,UPDLP	;SAVE USER'S POINTER
	MOV SPDLP,P	;SYSTEM PDL
FLUSH5:	JMP NEXTUS

FLUSH7:	MOV P,SJPDLP
	MOV SPDLP,P
	JMP NEXTUS
;RUNUSR, THE "MAIN LOOP"

RUNUSR:	CMP U,PUSRSP	;AM I THE GUY THEY WANT OUT?
	BNE .+10	;BRANCH IF NO
	MOV #-1,PUSPSL
	INC SLOTST(A)	;INDICATE THAT THIS GUY HAS BEEN RUN
	BVC .+10
	MOV #2,SLOTST(A)
	.IFNZ SEG
	MOV SLOTAR(A),B
	MOV #PUREAR,C
	MOV B,(C)+
	ADD #200,B
	MOV B,(C)+
	ADD #200,B
	MOV B,(C)
	.IFNZ NEWDIS
	CLR DISPDR
	MOV DISAS(U),A
	BLT RUNUS8
	MOV DISAR(A),DISPAR
	MOV DISDR(A),DISPDR
	.ENDC
	.ENDC
	.IFZ SEG
	MOV SLOTCA(A),BASEUS
	.IFF
RUNUS8:	MOV #PURE,BASEUS
	.ENDC
	MOV P,SPDLP	;SAVE SYSTEM PDL POINTER
	MOV UPDLP,P	;GET USER PDL POINTER
RUNUS7:	MOV U,USER	;NOW HE'S REALLY THE GUY
	SPUSH UPC(U)	;PLACE TO START USER
	MOV QUANT,UQUANT	;RUN FOR 3 1/100TH'S????
	CLR UTIME
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
	.IFNZ A1145
	CLR A		;DISPLAY USER # IN DISPLAY REG
	MOV USER,B
	DIV #L,A	;(71027 000056)
	MOV #1,B
	ASH A,B		;(72100)
	MOV B,177570
	.ENDC
	JMP UACRES	;RESTORE USER ACS AND START USER


SCHEDP:	TST UQUANT	;SEE IF IT'S TIME TO FLUSH
	BLE .+4	;NOT YET
	RTS PC
	SPUSH U
	MOV USER,U
	MOV #FRSCED,FLSRES(U)
	JSR PC,FLUSH
	JSR PC,RUNME
	SPOP U
	RTS PC
.STITL CLOCK BREAK ROUTINE

CLKBRK:	SPUSH A
	SPUSH B
	SPUSH	C
	ADD #40,UTIME
	INC TIME
	BNE CLKTOV
	INC TIME+2
CLKTOV:	DEC UQUANT
	DEC N50THS	;HAS THIS BEEN ONE SECOND?
	BLE DATEC	;YES, CHANGE THE SECOND
	;NEXT FIVE LINES ARE FOR TESTING DISPLAY
CLKBR1:
	.IFZ NDISP
	BR CLKB11
	.ENDC
	.IFNZ NDISP
	DECB	DISTIM	;TIME (HO HUM) TO START THE DISPLAYS?
	BGT	CLKB11	;NO
	MOVB	#1,DISTIM
	MOV	#NDISP-1,C
	ASL	C	;TO USE AS INDEX
	CLR	B
CLKDIS:	CMP	B,C	;ALL DISPLAYS CHECKED?
	BGT	CLKB11
	MOV	DSTAT(B),A
	TST	(B)+
	TST	A
	BLT	CLKDIS	;THIS ONE INACTIVE
	MOV	A,NGCSR
	BIT	#TKRUN,NGCSR
	BNE	CLKDIS	;STILL RUNNING
	BIS #TKGO,A
	MOV A,NGCSR
	BR	CLKDIS
	.ENDC

DATEC:	JSR PC,DPROVK
	DEC DKPWFR
	BGT .+10
	MOV #-20.,DKNRTY
	MOV #CLKFRQ,N50THS
	MOV #MNUSRS,A
	CLR B
	SPUSH C
JMTUD2:	MOV JMTU(B),C
	BEQ JMTUD1
	ASR C
	ASR C
	ASR C
	INC C
	SUB C,JMTU(B)
	BGE .+6
	CLR JMTU(B)
JMTUD1:	ADD #LUBLK,B
	DEC A
	BNE JMTUD2
	SPOP C
	MOVB RMONTH,A
	MOVB DMON(A),DAYLIM
	MOV #SECLIM,A
	MOV #RSEC,B
DATEC1:	INCB (B)
	CMPB (A)+,(B)
	BGT CLKBR1
	CLRB (B)+
	BR DATEC1

CLKB11:
CLKBDM:	BIT	#1,TIME	;EVERY OTHER BREAK (=1/25 SEC)
	BNE	CLKQBK	;
.IFNZ	NDMTY
	JSR	PC,DMSQ
.ENDC
	JSR	PC,TI2Q

CLKQBK:	DEC	@CLKQT
CLKQB1:	TST	@CLKQT
	BNE	CLKQB2
	MOV	CLKQT,A
	MOV	2(A),CLKQT	;PUT NXT BLK AT TOP OF Q
	JSR	PC,@4(A)		;DO CURRENT REQUEST
	BR	CLKQB1
CLKQB2:	MOV	#-1,CLKINF
	SPOP	C
	SPOP B
	SPOP A
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT

CLKINE:	TST DEBSW
	BNE CLKIN2
	JSR	A,SPRINT
	BPRTXT	^/CLKQBK RAN CLKINE/
	PRCR
	SPREND
CLKIN1:	MOV #CLKINF,CLKQT
	MOV	#-1,CLKINF
	RTS	PC

CLKIN2:	BPT	;CLKQBK RAN OFF END OF CLK QUEUE
	BR CLKIN1
.STITL	CLOCK QUEUE ROUTINES

;CLKQAD --
;CLOCK QUEUE ADD
;WORKS ONLY AT CLK BRK LEVEL OR LOWER 
;ADD BLOCK POINTED TO BY A TO SYSTEM CLOCK QUEUE
;1ST WD # OF TICKS TO WAIT
;2ND WD EMPTY (USED BY SYSTEM)
;3RD WD ADDR TO JSR TO

CLKQAD:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST CLKQ ENTRY
	MOV	(C),D
	BR	CLKQA2

CLKQA1:	MOV	D,C	;PNT C TO NEXT BLK
	MOV	2(D),D	;PNT D TO ONE AFTER
	SUB	(C)+,(A)	;MAKE TIME IN A BLK REL TO C BLK
CLKQA2:	TST	2(D)
	BEQ	CLKQA3	;BR IF NO MORE BLKS LEFT 
	CMP	(A),(D)
	BHI	CLKQA1
CLKQA3:			;INSRT ABLK BETWEEN C BLK AND D BLK
	MOV	D,2(A)	;PNT A BLK TO D BLK
	MOV	A,(C)	;PNT C BLK TO A BLK
	SUB	(A),(D)	;MAKE D TIME REL TO A TIME

CLKQRS:	SPOP	D
	SPOP	PS
	SPOP	C
	RTS	PC

CLKQSV:	SPUSH	PS
	MOV	PCBRV+2,PS	;RUN AT CLK BK LEVEL
	SPUSH	D
	JMP	(C)

;CLKQDL--
;CLOCK QUEUE DELETE
;DELETE BLOCK POINTED TO BY A FROM CLOCK Q

CLKQDL:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST ENTRY
	BR	CLKQD2
CLKQD1:	MOV	(C),C	;GET NEXT ENTRY
	TST	(C)+	;MAKE IT POINT TO NEXT+1 ENTRY
	TST	(C)	
	BEQ	CLKQD3	;BRANCH IF NO MORE ENTRIES
CLKQD2:	CMP	A,(C)	;IS THIS THE ENTRY WE WANT
	BNE	CLKQD1	;NO
	ADD	(A),@2(A)	;INCREASE TIME IN NEXT BLK
	MOV	2(A),(C)	;CORRECT PNTR IN PREV BLOCK
CLKQD3:	JMP	CLKQRS


UTIMEG:	MOV #RHOUR+1,D
	CLR E
	BR UTIME1
UDATEG:	MOV #RYEAR+1,D
	MOV #1,E
UTIME1:	MOV #3,F
UTIME2:	MOVB -(D),B
	ADD E,B
	JSR PC,PSHNUM
	DEC F
	BGT UTIME2
	SPUSH #3
	JSR PC,SENTENCE
	.BUG.
	SKPRET

PEEK:	CLR -(P)
	CLR E
	PRTXTC ^\USER	%TIM	FLSRES	TIMUSD	LSTIM\
	MOV NUSERS,F
PEEK1:	MOV (P),A
	JSR PC,PRDN
	SPACE
	MOV E,A
	ADD #UNAME,A
	JSR PC,POIHD2
	PRTXT ^\	\
.IFNZ A1120
	MOV JMTU(E),MQ
	MOV #144.,DIVIDE
	MOV MQ,A
.ENDC
.IFNZ A1145
	CLR A
	MOV JMTU(E),B
	DIV #144.,A
.ENDC
	JSR PC,PRDN
	PRTXT ^\	\
	MOV FLSRES(E),A
	JSR PC,PRON
	PRTXT ^\	\

	MOV TIMUSD(E),A
	JSR PC,PRDN
	PRTXT ^\	\
	MOV #LSTIM+3,B
	ADD E,B
	MOVB @B,A
	INC A
	JSR PC,PRDN
	SPACE
	MOV #3,C
	MOV #':,D
	BR .+6
PEEK4:	JSR PC,TYO	;PRINT :
	MOVB -(B),A
	JSR PC,PRDN
.IIF NZ A1145, SOB C,PEEK4
.IFNZ A1120
	DEC C
	BGT PEEK4
.ENDC
	PRCR
	ADD #LUBLK,E
	INC (P)
	DEC F
	BLE .+6
	JMP PEEK1
	MOV NRFERS,A
	BEQ PEEK2
	JSR PC,PRDN
	PRTXT ^\  FIXED HEAD ERRS  \
PEEK2:	MOV NRKERS,A
	BEQ PEEK3
	JSR PC,PRDN
	PRTXT ^\  MOVING HEAD ERRS\
PEEK3:	PRCR
	TST (P)+
	RTS PC

CLOCK:	MOV TIME+2,A
	MOV TIME,B
CLOCK1:	JMP R1I.N

USRTIM:	MOV TUTIME+2,A
	MOV TUTIME,B
	BR CLOCK1

UWAIT:	JSR PC,G1IARG
	ADD TIME,C
	ADC B
	ADD TIME+2,B
	MOV USER,U
UWAIT1:	JSR PC,FLUSH
	TST BRAKE(U)
	BNE UWAIT2
	MOV B,A
	MOV C,D
	SUB TIME,D
	SBC A
	SUB TIME+2,A
	BGE UWAIT1
UWAIT2:	JSR PC,RUNME
	RTS PC

SETTV:	JSR PC,CKSST
	JSR PC,G1IARG
	SPUSH C
	JSR PC,G1IARG
	TST C
	BLT SETTV1
	CMP #6,C
	BLE SETTV1
	CMPB (P),SECLIM(C)
	BGT SETTV1
	MOVB (P),RSEC(C)
	TST (P)+
	RTS PC
SETTV1:	ERROR+NTL
	.STITL	SWAP START+STOP ROUTINES

SWPOST:	CLR (A)
	ADD #16,SWPLST
	RTS PC

SWPIST:	MOV #SWPISP,(A)	;SWAP IN START, SET UP STOP
	RTS PC

SWPISP:	MOV 12(A),B
	MOV #1,SLOTST(B)
	SUB #2,SWPLEP
	SPUSH A
	MOV #SWPLST+2,A
	MOV #SWPLST,B
	MOV (A)+,(B)+
	BNE .-2
	INC NINU	;ONE MORE GUY IN
	DEC NSWPU	;ONE LESS GUY MOVING
	SPOP A
	RTS PC
	.STITL MISC ROUTINES

CACSAV:	JSR PC,PPUSHT	;CAREFUL AC SAVE
ACSAV:	MOV E,-(P)
	MOV D,-(P)
	MOV C,-(P)
	MOV B,-(P)
	MOV A,-(P)
	JMP (F)

CACRES:	JSR PC,PPOPT	;CAREFUL AC RESTORE
ACRES:	TST (P)+
	MOV (P)+,A
	MOV (P)+,B
	MOV (P)+,C
	MOV (P)+,D
	MOV (P)+,E
	RTS F

UACSAV:	MOV A,UACA(U)
	MOV B,UACB(U)
	MOV C,UACC(U)
	MOV D,UACD(U)
	MOV E,UACE(U)
.IFNZ A1120
	MOV	AC,UAC(U)
	MOV	MQ,UMQ(U)
	MOV	SR,USR(U)
.ENDC
	RTS PC

UACRES:	MOV UACA(U),A
	MOV UACB(U),B
	MOV UACC(U),C
	MOV UACD(U),D
	MOV UACE(U),E
.IFNZ A1120
	MOV	UMQ(U),MQ
	MOV	UAC(U),AC
	MOV	USR(U),SR
.ENDC
	RTS PC



PPUSHT:	CMP P,#PPUSHL
	BLOS .+4
	RTS PC
	BIT #177000,P	;IS IT THE SYSYTEM PDL?
	BNE .+4
	RTS PC	;YES, IGNORE
	JMP PPSWPO	;PDL REALLY OVERFLOWED

PPOPT:	CMP P,PPOPL
	BHIS .+4
	RTS PC
	JMP PPSWPI

SPUSHT:	SUB #2,S
	CMP S,#SPUSHL
	BLOS .+4
	RTS PC
	JMP SPSWPO

SPOPT:	ADD #2,S
SPOPT1:	CMP S,SPOPL
	BHI .+4
	RTS PC
	JMP SPSWPI

.SPACE:	PRTXT ^\ \
	RTS PC

.CRLF:	.PRTXT <.BYTE 15,0>
	RTS	PC
	.STITL P AND S PDL SWAP OUTERS

PPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	.BUG.	;WHAT, NO DISK SPACE
	SPUSH B	;SAVE ADDRESS
	SPUSH #PSWPWR
	JSR PC,DSKSEC	;WRITE OUT P-PDL BLOCK
			;FROM (PSWPAD)
			;OUT TO (DBGRBD)
			;DWRTEC
	SPOP IP
	BIT #PPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,PPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #PPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IP,A
	MOV PSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,P
	BHIS .-4
	ADD #PDSWOP,P	;PDL HAS MOVED!
	ADD #PDSWOP,PRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC


SPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	.BUG.	;WHAT, NO DISK SPACE
	SPUSH B	;SAVE ADDRESS
	SPUSH #SSWPWR
	JSR PC,DSKSEC	;WRITE OUT S-PDL BLOCK
			;FROM (SSWPAD)
			;OUT TO (DBGRBD)
			;DWRTEC
	SPOP IS
	BIT #SPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,SPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #SPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IS,A
	MOV SSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,S
	BHIS .-6
	ADD #PDSWOP,S	;PDL HAS MOVED!
	ADD #PDSWOP,SPRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC

	.STITL P AND S PDL SWAPER INERS
PPSWPI:	BIT #PPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV PSWPAD,A
	MOV A,B
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,P
	BHI .-4
	SUB #PDSWOP,P
	SUB #PDSWOP,PRBAO
	MOV IP,C
	MOV C,DBGRBD
	SPUSH #PSWPRD
	JSR PC,DSKSEC	;READ IN P-PDL BLOCK
			;INTO (PSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #IP,D
	TST (D)
	BNE PSWPI2
	BIC #PPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW,
				; THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,PPOPL
PSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC

SPSWPI:	BIT #SPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV SSWPAD,A
	MOV A,B
	MOV (A),(B)
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,S
	BHI .-6
	SUB #PDSWOP,S
	SUB #PDSWOP,SPRBAO
	MOV IS,C
	MOV C,DBGRBD
	SPUSH #SSWPRD
	JSR PC,DSKSEC	;READ IN S-PDL BLOCK
			;INTO (SSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #IS,D
	TST (D)
	BNE SSWPI2
	BIC #SPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW,
				; THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,SPOPL
SSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC


	.STITL P AND S PDL POPPERS
PPTA:		;POP PP PDL TO (A) RELATIVE
		;USES A,F
	SPOP F
PPTA1:	CMP A,PRBAO
	BHIS PPTA3
	MOV PPOPL,P
	JSR PC,PPSWPI
	BR PPTA1
PPTA3:	SUB PRBAO,A
	SUB #IP,A
	NEG A
	CMP A,P
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,P
	JSR PC,PPOPT
	JMP @F
PSTA:		;POP S PDL TO (A) RELATIVE
		;USES A
	CMP A,SPRBAO
	BHIS PSTA3
	MOV SPOPL,S
	JSR PC,SPSWPI
	BR PSTA
PSTA3:	SUB SPRBAO,A
	SUB #IS,A
	NEG A
	CMP A,S
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,S
	JMP SPOPT1
.STITL INITIALIZE NODE SPACE
;ON ENTRY B = START OF FREE NODES NODE #
;	C = " " " " NODE ADDRESS
;	D = FIRST WORD AFTER END OF SLOT
INIT:	MOV #SOFN,B
	MOV #ASOFN,C
	.IFNZ SEG
	MOV #PURE-4,D
	.IFF
	MOV #SLOT1,D
	.ENDC
	ADD USLENT,D
INIT4:	INC B
	INC NNGC
	BIT #10000,B	;HIGHEST POSSIBLE NODE ADR + 1
	BNE INIT2
	MOV B,(C)
	BIS #IDLE,(C)+
	CLR (C)+
	CMP D,C
	BHI INIT4
	SUB #4,C	;BACK UP: PREVIOUS NODE IS LAST FREE
INIT2:	MOV #IDLE,(C)+
	CLR @C
	MOV NNGC,NNIFSL
	MOV B,NUNODE	;NUMBER OF NODES PER USER
	RTS PC

INIT1:	BIS #PADERF,FLAGS2	;SO OCTAL ERROR ADDR IS PRINTED
	JSR PC,SYDRBG	;GET A SYSTEM DISK REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-CLSLTL,(A)+
	MOV #SLOT1,(A)+	;SWAP OUT SLOT1
	MOV DCLRUS,(A)+	;GETS PUT INTO THE CLEAR USER PLACE
	MOV DCLRUS+2,(A)+
	CLRB 1(A)
	TST (A)+
	MOV #DWRTEC,(A)
STARTF:	MOV	NUSERS,NUSER2
	ASL	NUSER2
	.IFNZ SEG
	JSR PC,SEGSET
	.ENDC
	JMP	TINIT

	.IFNZ SEG
SEGSET:	CLR SSR0
	MOV #KIDR,A
	MOV #20,B
	MOV #77406,(A)+
	SOB B,.-4
	MOV #10,C
SEGST1:	MOV B,20(A)
	MOV B,(A)+
	ADD #200,B
	SOB C,SEGST1
	MOV #SLOTDR,A
	MOV #PUREDR,B
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A),(B)
	MOV #7600,KDAR+16
	MOV #4,SSR3
	MOV #1,SSR0
	RTS PC
	.ENDC
	.STITL READ-EVAL LOOP DRIVER (THE ONE-USER MAIN LOOP)

UGO:	JSR PC,RUNME
	MOV USER,A
	ADD #UNAME,A
	MOV #'?+200,(A)
	CPRTXT ^/WELCOME TO 11LOGO /
	.IFNZ SEG
	PRTXT ^/SEG /
	.ENDC
	MOV LVERNF,A
	JSR PC,PRDN
	TST DEBSW
	BEQ UGO1	;IF DEBUG SWITCH IS ON
		;PRINT MESSAGE
	CPRTXT ^/LOGO BEING DEBUGGED!/
UGO1:	PRTXT ^/ USER # /
UGODBG:
.IFNZ A1120
	MOV USER,MQ
	MOV #LUBLK,DIVIDE
	MOV MQ,A
.IFF
	CLR A
	MOV USER,B
	DIV #LUBLK,A
.ENDC
	JSR PC,PRDN
	PRCR		;PRINT CR
	JSR PC,INIT
.IFNZ NFILES
	MOV #DESSAV,E
	JSR PC,DIRSER
	BEQ MLOOP
	TST DEBSW
	BNE MLOOP
	JSR PC,.REDF4
	JSR PC,.POF1
.ENDC
MLOOP:	JSR	PC,UCHECK	;CHECK SOME USER VARIABLES
	JSR PC,SCHEDP
	BIC #HERRF,FLAGS2
	MOV	USER,U
	TST BRAKE(U)
	BEQ .+4
	ERROR+BRK
	JSR PC,GETSTR
	JSR PC,MREAD
	BR MLOOP	;NO TOKEN LIST
	JSR PC,EVLINE
	ERROR+WDW	;WHAT SHOULD I DOO WITH (S)
	POPS A	;EVLINE LEAVES PTR TO TOKEN LIST ON S
	BR MLOOP

RUNRUG:	JSR PC,CKSST
	BPT
	RTS PC

SYSJOB:	JSR PC,FLUSH
	BR SYSJOB


;CHECK SOME USER VARIALBES -- DEBUGGING FEATURE
UCHECK:	TST	NODESP
	BNE	UCHEC1
	TST	NODESP+2
	BEQ	UCHEC2
UCHEC1:	TST	(P)+	;POP STACK SO IT LOOKS LIKE BUG CAME FROM CALLING ROUTINE
	.BUG.	;1ST 2 WORDS OF NODE SPACE NOT ZERO
UCHEC2:	RTS	PC
	.STITL GET A STRING
GSTR4:	PUSHS C
	PUSH GCHR
	SPUSH PCHR
	SPUSH PRMTCH
	CLR PRMTCH
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	JSR PC,.LOADC
	PUSHS B
	JSR PC,PRLN
	POPS B
	JSR PC,RDSTR
	BR GSTR5
GSTR7:	POPS A		;IGNORE ANY LINE TYPED IN
GSTR10:	POP PRMTCH
	SPOP PCHR
	SPOP GCHR
	POPS C
	JSR PC,.LOADC
	JSR PC,.LOADB	;PUT THINGS BACK AS THEY WERE
	BR GSTR3

GSTR5:	BIT #RBRKF,TFLAGS
	BEQ GSTR10
	POP PRMTCH
	ERROR+BRK
GETSTR:	TST FUNLEV	;ARE WE IN A PROC
	BEQ GSTR0	;NO
	BIT #BRKF,FLAGS	;ERROR, MAYBE
	BNE GSTR0	;YES
	MOV CLP,B	;NO, GET THIS NODE OF LLP
	BEQ GSTR9
	JSR PC,.LOAD
	BIT #7777,A	;IS IT LAST NODE
	BNE GSTR8
	SPOP A		;POP RETURN ADDR
	JMP PSTOP

GSTR9:	MOV CPLN,B
	JSR PC,GTLINE
	ERROR+LDE	;LINE ..(B).. DOESN'T EXIST
	MOV C,A
GSTR8:	CLR CLP
	MOV A,C
	JSR PC,.LOADC
	JSR PC,.LOAD	;OK, GET FIRST NODE OF LINE, = LINE #
	MOV B,CPLN
	BIT #TPSF,FLAGS
	BNE GSTR4
GSTR3:	MOV C,CLP
	MOV A,CTP	;IN CASE THERE IS NO GENERATION #
	MOV A,C
	JSR PC,.LOADC	;GET SECOND NODE
	CLR CLGN	; IF TYPE = SNUM, IT IS GEN #
	MOV A,C
	BIC #7777,C
	CMP #SNUM,C
	BNE GSTR6
	MOV B,CLGN	;IT IS
	MOV A,CTP
GSTR6:	BIS #LIST,CTP
	PUSHS CTP
	BIT #TRACEF,FLAGS2
	BEQ GSTRT
	CPRTXT ^\ #\
	MOV CPP,B
	JSR PC,PPNAME	;PRINT PNAME
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRCR
	JSR PC,PRLN
	PRCR
GSTRT:	RTS PC


GSTR0:
GSTR1:	JSR PC,RDSTR
	BR GSTR2
	BR GSTRT
GSTR2:	BIT #RBRKF,TFLAGS
	BEQ GSTR1
	ERROR+BRK
	.STITL MORE READ ROUTINES!!!
MREAD:	TST FUNLEV	;ARE WE IN PROC?
	BEQ MRD1	;NO
	BIT #BRKF,FLAGS	;YES, BUT ERROR?
	BNE MRD1	;YES
	SKPRET
MRD1:	CLR ILINEL
	JSR PC,READ	;CONVERT CHAR STRING TO TOKEN LIST
	RTS PC	;NO TOKENS
	MOV @S,ILINEL
	SKPRET

CKSTG:	;CKECK IF DISC OR NODES ARE ALMOST GONE
	BIT #DSAMFL,FLAGS2
	BEQ CKSTG3
CKSTG1:	CLR ERPROC
	ERROR+NSL	;NO STORAGE LEFT!!
CKSTG3:	CMP NNIFSL,#NBN
	BHIS CKSTG2
	JSR PC,.GCOLL
	CMP NNIFSL,#NBN
	BLO CKSTG1
CKSTG2:	RTS PC
	.STITL EVAL 1 LINE

EVLINE:	MOV	USER,U	;EVALUATES 1 LINE ON S
	TST	BRAKE(U)
	BEQ .+4
	ERROR+BRK
	TST TOPRNM
	BNE EVLI4
EVLI6:	BIC #EVIFS,FLAGS
	CLR CO
	CLR CO+2
	CLR NOR
	CLR COF
	CLR LO
	CLR LO+2
	JSR PC,IGNT
EVLI1:	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,EVAL
	BR EVLI3	;NO OUTPUT, OK
	JSR PC,CKSTG
	RTS PC
EVLI3:	JSR PC,CKSTG
	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,GNT
	BIS #RTF,FLAGS
	BR EVLI1
EVLI4:	JSR PC,CKSTG
	MOV @S,B
	JSR PC,.LOAD
	MOV A,D
	BIC #7777,A
	CMP #SNUM,A
	BEQ EVLI5	;AN SNUM
	CMP #INUM,A
	BEQ EVLI8	;AN INUM
	CMP #LSTR,A
	BNE EVLI6	;NOT AN SNUM, INUM OR LSTR
	JSR PC,.CLSIN	;CONVERT LSTR TO INUM
	BR EVLI6	;NOT NO. OR TOO BIG
EVLI8:	BIT #SPDF,FLAGS	;IS THIS PROC DEF. BEING SKIPPED?
	BNE EVLI9
	JSR PC,.CINSN	;CONVERT INUM TO SNUM
	BR EVLI7	;TOO BIG
	TST B	;IS NO. TOO SMALL?
	BGT .+4
	ERROR+LNTS
	MOV D,A
	BIC #170000,A	;MAKE IT INTO AN SNUM
	BIS #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	MOV C,@S
EVLI5:	JSR PC,ADLN
EVLI9:
EVLI2:	SKPRET
EVLI7:	ERROR+LNTB	;LINE # TOO BIG
	.STITL GET NEXT TOKEN

GNT:	MOV CT,A
	MOV CT+2,B
	BIT #RTF,FLAGS	;IS REPEAT TOKEN FLAG SET?
	BEQ GNT1
	BIC #RTF,FLAGS	;YES
	CMP #SFUN,A
	BNE GNT6
	TST B
	BNE GNT6
	BIS #CRF,FLAGS
GNT6:	RTS PC
GNT1:	BIC #PTLPF,FLAGS
	CMP #$LLPAR,B	;IS CT "("
	BEQ GNT3
	CMP #$LPAR,B
	BNE GNT3A
GNT3:	BIS #PTLPF,FLAGS	;YES, SET PTLPF
GNT3A:	MOV A,CTP	;GET LINK TO NEXT TOKEN
	BIT #7777,A
	BEQ GNT2	;ANY TOKENS LEFT
	JSR PC,.LOADA	;YES
	INC CTN
GNT3B:	CMP #$COMT,B
	BEQ SKPCOM
GNT4:	MOV A,CT
	MOV B,CT+2
	RTS PC
GNT2:	BIT #CRF,FLAGS
	BNE GNT5
	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR GNT4
GNT5:	ERROR+OOT	;OUT OF TOKENS
SKPCOM:	MOV A,CTP	;SKIP OVER A COMMENT
	BIT #7777,A
	BEQ GNT2	;END ON CR FOUND
	JSR PC,.LOADA
	INC CTN
	CMP #$COMT,B
	BNE SKPCOM	;DON'T STOP TILL CR OR CLOSING "!"
	BR GNT3A	;RETURN TOKEN AFTER CLOSING "!"

IGNT:	MOV @S,B	;INIT "GNT"
	BIT #7777,B
	BEQ IGNT1
	BIC #CRF,FLAGS
	MOV B,CTP
	JSR PC,.LOAD
IGNT2:	MOV A,CT
	MOV B,CT+2
	BIS #RTF,FLAGS
	MOV #1,CTN
	BR GNT3B
IGNT1:	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR IGNT2
	.STITL LOGO TYI/O
UTYI:	WAIT
	TST CHI
	BEQ UTYI
	MOVB CHI,D
	CLR	CHI
	BIC #177600,D
TYO:	JMP @ITYO

TYI:	JMP @ITYI
STYI:	WAIT
	TSTB TKS
	BPL STYI
	MOVB TKB,D
	BIC #177600,D
STYO:
UTYO:	TSTB TPS
	BPL .-4
	MOVB D,TPB
	CMP #15,D
	BNE UTYOR
	MOV #12,D
	JSR PC,STYO
	MOV #15,D
UTYOR:	RTS PC

;SPRINT-- START SYSTEM PRINT.  CALL WITH JSR A,
SPRINT:	SPUSH	USER
	SPUSH PCHR
	MOV	#-1,USER
	MOV #STYO,PCHR
	JMP	(A)
SPEND:	TST (P)+
	SPOP PCHR
	SPOP USER
	RTS A

;PRINT LOCATIONS ON SYSTEM CONSOLE
;CALL WITH
;	MOV #WDLIST,B
;	JSR PC,PLOCS
;WHERE	WDLIST:	LOCS TO BE PRINTED
;		0
PLOCS:	JSR	A,SPRINT	;START SYS PRINT
	BPRTXT	;RING BELL, C.R.
PLOCS1:	JSR	PC,PLOC
	TST	(B)+
	TST	(B)
	BNE	PLOCS1
	SPREND	;END SYSTEM PRINT
	RTS	PC

;PRINT (B)/ @(B)
PLOC:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	(B),U
PLOC1:	MOV	(U),D
	JSR	PC,PGEN1	;PRINT (U)/ (D)
	SPOP	U
	SPOP	D
	SPOP	A
	RTS	PC

;PRINT B/(B)
PLOCB:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	B,U
	BR	PLOC1
	.STITL	GARBAGE COLLECTOR
NNODES==4096.
GCBTL== NNODES/8./2.*2.	;GARBAGE COLLECT BIT TABLE LENGTH

MARKNI:	SPUSH A
	SPUSH B
	BR MARKN4
MARKN:	SPUSH A	;MARK NODE(B)
	SPUSH B
;DEBUGGING FEATURE
	JSR PC,.LOAD	;ARE WE MARKING AN IDLE NODE
	BIC #7777,A
	CMP #IDLE,A
	BNE .+4
	.BUG.
	MOV (P),B
;
MARKN4:	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;ALREADY MARKED?
	BEQ MARKN1	;NO
MARKN3:	SPOP B
	SPOP A
	RTS PC
MARKN1:	BISB B,(A)
MARKN2:	SPOP B
	SPOP A
	ADD #2,(P)
	RTS PC
MARKDN:	;SKIP IF NODE (B) IS MARKED
	SPUSH A
	SPUSH B
	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;MARKED?
	BEQ MARKN3	;NO
	BR MARKN2	;YES-SKIP

MARKL:	PUSH A	;MARK LIST
	SPUSH B	;NODE ADDS IN B
	SPUSH C
	JSR	PC,MKLIST
	BR MARKV1

MARKV:	PUSH	A	;MARK VARIABLE
	SPUSH	B	;NODE ADDS IN B
	SPUSH	C
	CLR	A
	MOV	B,C
	JSR	PC,MARKF1	;TREAT POINTER AS A FIRST PTR
MARKV1:	SPOP C
	SPOP B
	POP A
	RTS PC

MARKF:	MOV A,C	;MARK FIRST OF A DATUM (NODE) IN A,,B
MARKF1:	BIT #DSAMFL,FLAGS2
	BEQ MARKF2	;DISK NOT ALMOST FULL
.IFNZ FILES
.IIF NZ OFILES,	TST DSKNCH
.IIF NZ NFILES,TST FILFLG
	BEQ MARKF3
	MOV #DREADC,E
	JSR PC,GBITGS	;SET DISK BUFFER BACK UP
.ENDC
MARKF3:	TST SSAVEA	;TOP OF SPDL SWAPPED OUT FOR MARKING?
	BEQ MARKF4	;NO
	SPUSH #SSAVRD
	JSR PC,DSKSEC	;YES, SWAP IT BACK IN
			;INTO (SSWPAD)
			;FROM (SSAVEA) WHERE GCOLL PUTS IT
			;DREADC
	MOV SSAVEA,C	;FREE THE REQUEST BLOCK
	CLR SSAVEA	;CLEAR THIS: IT WORKS AS A FLAG
	JSR PC,UBLKFR	;(NOW FREE IT)
MARKF4:	CLR ERPROC
	.IFNZ NDISP
	ADD #2,S	;POP SNLIST OFF S PDL
	.ENDC
	ERROR+NSL
MARKF2:	BIC	#7777,C	;A TELLS WHAT TYPE OF DATUM IT IS
	SWAB	C
	ASR	C
	ASR	C
	ASR	C	;ALL THIS GIVES YOU THE TYPE*2
	JMP	@LMT(C)	;WHICH YOU MIGHT MARK ON

	.IFNZ NDISP
MKSNAP:	JSR	PC,MKDC	;MARK DISPLAY CODE
	.ENDC
MKLIST:	BIT	#7777,B	;IS THIS NODE REALLY HERE?
	BEQ	MKL3	;NO. RETURN
MKL1:	PUSH	A	;SAVE BUTFIRST OF CURRENT (I.E. PARENT) NODE
	JSR	PC, MARKN	;MARK NEXT NODE
	BR MKL2
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	JSR	PC,MARKBF	;MARK BUTFIRST OF  NEWTHIS NODE
MKL2:	POP A
	RTS PC

MKATOM:		;MARK ATOM CELL BUT NOTHING INSIDE IT
MKINUM:	JSR	PC,MARKNI
	BR .+2
MKSSTR:
MKL3:	RTS	PC

GCDIE:	ERROR+FBUG

MARKBF:	BIT	#7777,A	;MARK BUTFIRST OF LIST
	BEQ	MKL3	;AT END OF LIST
MKBF1:	MOV	A,B
	JSR	PC, MARKN	;MARK NEXT NODE
	BR MKL3	;ALREADY MARKED, QUIT
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	BR	MARKBF	;MARK BUTFIRST OF  NEW NODE

GCOLL:.GCOLL:	JSR F,ACSAV
	PUSH GNCN
	SPUSH GNCN+2
	SPUSH TMPBLK
	MOV USER,U
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
.IFNZ FILES
.IIF NZ OFILES,	TST DSKNCH	;ARE THE DISK BUFFERS IN USE?
.IIF NZ NFILES,	TST FILFLG
	BEQ .GCOL2
	MOV #DWRTEC,E
	JSR PC,GBITGS	;SAVE THE BUFFERS
.ENDC
.GCOL2:	MOV #GCBITS,A	;GARBAGE COLLECT
	MOV #GCBTL/2-1,B	;CLEAR BIT TABLE
	MOV #1,(A)+	;ALWAYS PROTECT NODE ZERO
.GCOL1:	CLR (A)+
	DEC B
	BGT .GCOL1
	CLR SSAVEA	;MAKE SURE THIS IS CLEAR
;NOW MARK EVERYTHING POINTED BY OBLIST.  DONT MARK OBLIST NODES YET
	JSR PC,GNOLEI
MKUOBJ:	JSR PC,GNOLE	;GET NEXT UOE PTR
	BR MKTPS
	MOV B,C
	JSR PC,.LOADC	;GET THE NODE
	MOV A,C
MKUOE:	BIT #7777,C	;ONE OTHER NODE?
	BEQ MKUOBJ	;NO
	MOV C,B	;YES
	JSR PC,MARKN	;MARK IT
	BR .+2
	JSR PC,.LOADC
	MOV A,C
	BIC #7777,A
	CMP #FBIND,A
	BEQ MKFB	;FUNCTION BINDING
	CMP #VBIND,A
	BEQ MKVB	;VARIABLE BINDING
	CMP #SVBIND,A
	BEQ MKSVB	;SWAPPED VB
	.BUG.		;BUG
MKVB:	JSR PC,MARKV	;MARK VARIABLE
	BR MKUOE
MKFB:	JSR PC,MARKL
	BR MKUOE
MKSVB:	BR MKUOE

	;MARK FROM GCMKL LIST
MKTPS:	MOV #GCMKL,F
MKRNDM:	MOV (F)+,B	;POINTER TO POINTER
	BEQ MKSPDL	;LAST ONE
	MOV (B),B	;REAL NODE ADDRESS
	BEQ MKRNDM	;NOTHING THERE
	BIT #170000,B	;IS TYPE FIELD BLANK
	BEQ MKRND1	;YES, MAKE IT LIKE LIST
	JSR PC,MARKV	;MARK VARIABLE
	BR MKRNDM
MKRND1:	JSR PC,MKL1
	BR MKRNDM
	;MARK FROM S PDL
MKSPDL:	MOV #IS,E
MKSP1:	MOV -(E),B	;GET A S PDL WORD
	CMP E,S	;END OF S PDL?
	BLO MKSP2	;YES
	JSR PC,MARKV	;MARK S PDL WORD
	BR MKSP1
MKSP2:	TST IS
	BEQ MKSP4
MKSP3:	JSR PC,UBLKGR
	.BUG.
	MOV B,SSAVEA
	SPUSH #SSAVWR
	JSR PC,DSKSEC	;SAVE TOP OF S-PDL ON DISK
			;FROM (SSWPAD)
			;OUT TO (SSAVEA)
			;DWRTEC
MKSP8:	TST IS
	BEQ MKSP6	;NO
MKSP5:	MOV IS,DBGRBD
	SPUSH #SSWPRD
	JSR PC,DSKSEC	;GET NEXT PIECE OF S-PDL
			;INTO(SSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #176,F
	MOV #IS,E
MKSP7:	MOV -(E),B	;MARK THIS PIECE OF S PDL
	JSR PC,MARKV
	DEC F
	BGT MKSP7
	BR MKSP8

MKSP6:	SPUSH #SSAVRD
	JSR PC,DSKSEC	;RESTORE TOP OF S-PDL
			;INTO (SSWPAD)
			;FROM (SSAVEA)
			;DREADC
	MOV SSAVEA,C
	CLR SSAVEA	;SWAPPED BACK IN
	JSR PC,UBLKFR
MKSP4:
;OK, NOW MARK ALL UOE'S THAT POINT TO FUNCION OR VARIABLE BINDING
	JSR PC,GNOLEI
MKOBL:	JSR PC,GNOLE	;GET NEXT UOE PTR IN B
	BR MKOBL6	;NONE LEFT
	MOV B,C
	JSR PC,.LOADC	;GET THE PNAME NODE
	MOV B,D
	BIT #7777,A	;DOES IT POINT TO ANYTHING?
	BNE MKOBL2	;YES, MARK IT
	MOV C,B	;NO WAS IT MARKED?
	JSR PC,MARKDN
	BR MKOBL3	;NO - LINK IT OUT
	BR MKOBL7	;YES - ALSO MARK PNAME & BUCKET PTR
MKOBL2:	; - MARK THE UOE ETC.
	MOV C,B	;  -THE UOE NODE
	JSR PC,MARKN
	BR .+2
MKOBL7:	MOV D,B	;  -THE PNAME LSTR
	JSR PC,MARKL
	MOV GNCN+2,B	;  -THE BUCKET LIST NODE
	JSR PC,MARKN
	BR MKOBL
	BR MKOBL
	;THIS UOE IS NOT MARKED AND POINTS TO NOTHING - LINK IT OUT
MKOBL3:	MOV TMPBLK,C	;GET PTR TO PREDECESSOR NODE
	BNE MKOBL4	;NONE, SO UHCT WAS PRED.
	MOV GNCN,-2(E)	;SO CHANGE IT
	BR MKOBL5
MKOBL4:	MOV GNCN,A	;CHANGE PTR IN PRED NODE
	JSR PC,.STP1
MKOBL5:	MOV C,GNCN+2	;SO GNOLE WILL WORK
	BR MKOBL
MKOBL6:



	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;IF GUY HAS DISPLAY
	BEQ	GCDIS2
	JSR PC,DSGCF		;GCOLL IT, TOO
GCDIS2:
GCDIS:
	.ENDC


		;OK NOW RETURN ALL IN MARKED NODES
		;RA ADDS OF LIT MAP
		;RB NODE ADDS
		;RC ACTUAL ADDER OF NODE
		;RD BIT MAP
		;RE POINT TO LIST OF FREE STORAGE RECYCLED NODES
		;RF NUMBER NODES LEFT TO CHECK
		;START COLLECTING AT LUNN(LOWEST UNPROTECTED NODE #)
	CLR E
	CLR NNGC
	CLR B	;NODE ZERO
	MOV #NODESP,C	;NODE ZERO ADDRESS
	MOV NUNODE,F	;NUMBER OF NODES
	MOV #GCBITS,A	;BIT TABLE ADDR
GCRT2A:	MOV (A)+,D	;GET NEXT WORD OF BIT MAP
	SEC
	ROR D

GCRT2:	BCS GCRT3
	CMP B,#LUNN
	BLOS GCRT3
	TST E		;WE HAVE A FREE NODE; IS FIRST FREE FOUND?
	BNE GCRT2B
	MOV B,FREE	;NO, THIS IS IT
	BR GCRT2C	;(NO LAST-FREE TO UPDATE)

GCRT2B:	BIS B,(E)	;ELSE: POINT LAST-FREE TO THIS NODE
GCRT2C:	MOV C,E		;SEE IF NODE IN PHASE WITH START OF NODE SPACE
	SUB #N,E
	BIT #3,E	;(LAST TWO BITS =)
	BEQ .+4
	.BUG.		;OUT OF PHASE!!
	MOV C,E		;THIS NODE IS NEW LAST-FREE
	MOV #IDLE,(C)+	;MAKE NEW IDLE NODE, POINTS NOWHERE
	CLR (C)+
	INC NNGC
	BR GCRT4
GCRT3:	CMP (C)+,(C)+
GCRT4:	INC B
	DEC F
	BLE GCRT5
	CLC
	ROR D
	BNE GCRT2
	BR GCRT2A
GCRT5:	MOV NNGC,NNIFSL
;DEBUGGING FEATURE
	BIT #PNNLF,FLAGS2
	BEQ GCRT6
	CPRTXT ^/[NODES LEFT /
	MOV NNGC,A
	JSR PC,PRDN
	PRTXTC ^/ ]/
;
GCRT6:
.IFNZ FILES
.IIF NZ OFILES,	TST DSKNCH	;BUFFERS IN USE?
.IIF NZ NFILES,	TST FILFLG
	BEQ GCRT7	;NO
	MOV #DREADC,E
	JSR PC,GBITGS	;GET BACK THE BUFFERS
.ENDC
GCRT7:	POP TMPBLK
	SPOP GNCN+2
	SPOP GNCN
	JSR F,ACRES
	RTS PC

GBITGS:	MOV USER,U
	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+
	MOV #-DBUFL-DDBUFL/2,(A)+
	.IFZ SEG
	MOV #GCBITS,(A)+
	.IFF
	MOV #GCBITS-PURE,(A)
	MOV SLOTAS(U),B
	MOV SLOTHA(B),C
	ADD SLOTCA(B),(A)+
	ADC C
	ASH #4,C
	MOVB C,6(A)
	.ENDC
	MOV UDBFSV(U),(A)+
	MOV UDBFSV+2(U),(A)+
	TST (A)+
	BIS E,(A)
	JSR PC,DSKWAI
	RTS PC
	.STITL GET NEXT OBLIST ELEMENT
GNOLE:		;GET NEXT USER OBLIST ELEMENT - PTR
		;INPUT - VIA GNOLEI
		;OUTPUT - PTR TO THIS BUCKET IN B & GNCN
		;	   " " NEXT " " GNCN+2
		;	   " " PRED " " TMPBLK
		;	   IF NO PREV BUCKET, TMPBLK = 0
		;USES E.  SKIPS UNTIL NO UOE PTRS LEFT
	PUSH A
	MOV GNCN,B
	MOV GNCN+2,TMPBLK
GNOLE2:	MOV B,GNCN+2
	BIC #170000,B
	BEQ GNOLE1
	JSR PC,.LOAD	;GET NEXT PTR ON BUCKEN LIST
	MOV A,GNCN
	JMP SRETA
GNOLE1:	CLR TMPBLK
	MOV (E)+,B	;GET NEXT BUCKET LIST
	BGE GNOLE2
	JMP RETA	;DONE
GNOLEI:	MOV #UHCT,E
	CLR GNCN
	RTS PC
