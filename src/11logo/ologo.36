	.TITLE PDP11 LOGO
	.ABS
	%COMPAT==0
	VERN==%FNAM2
	FOO==VERNF
	FOO==ASWFOO
	.STITL CONFIGURATION PARAMETERS
.IF1
GTI==1
DRIBF==0
SITSD==1
LPF==0
SWAPF==1
NINT==0
SYSP==1
DPHK==0
NTUR==2
WADESW==1
CJR==0
HALFLG==0
JRDF==0
NTVS=0
NTVCHN==0
;	.PRINT /TVS=/
;.TTYMAC FLAG
;.IFNZ FLAG
;NTVS==4
;NTVCHN==8.
;.ENDC
;.ENDM

	.PRINT /0=>REGULAR 1=> GUY 2=>QUERY 3=> NO DISK CHECKING 4=> GUY+SITSD
ASSSW=/
	.TTYMAC FLAG
	ASSSW==FLAG
	.ENDM
ASWFOO==ASSSW
NATG==0
DSKCHK==1
RAF==0
.IFZ ASSSW-4
ASSSW==1
.ENDC
.IFZ ASSSW-3
	DSKCHK==0
	ASSSW==0
.ENDC
	NPLOT==1
	MVONLY==0
	FXONLY==0
TM==1
	DHON==1
	DDF==1
	FPPF==1

GUY==0
AI==0
	.IFZ ASSSW
	DRIBF==0
	MVONLY==1
	LPF==1
	ENG==1
	FR==0
	AI==1
	MNUSRS==15+NTVS
	MNSLTS==6
	.ENDC

	.IFZ ASSSW-1
	ENG==1
	FR==1
	LPF==1
	MVONLY==1
	GUY==1
	NTUR==2
	MNUSRS==13
	MNSLTS==4
	.ENDC

	.IFZ ASSSW-2
		.MACR SETFLG FLG
		.PRINT /FLG=/
		.TTYMAC FLAG
		FLG==FLAG
		.ENDM
		.ENDM
	
		SETFLG DEBUG
		SETFLG MVONLY
		SETFLG MNUSRS
		SETFLG MNSLTS
		SETFLG FPPF
		SETFLG DDF
		SETFLG FR
		SETFLG ENG
		SETFLG NPLOT
	.ENDC

.ENDC

	.MACR FOR FLG
	.XLIST
	.IFNZ FLG
	.LIST
	.ENDM

	.MACR ENDC FLG
	.IFZ FLG
	.LIST
	.ENDC
	.ENDM
	.STITL SYSTEM PARAMETERS
.IIF Z GUY,.INSRT 11LOGO;ERRORS SYMS
.IIF NZ GUY,.INSRT 11LOGO;GUYERR SYMS
A=%0
B=%1
C=%2
D=%3
E=%4
F=%5
U=%5
P=%6
SP=%6
PC=%7

FA==%0
FB==%1
FC==%2
FD==%3
FE==%4
FF==%5

EOFCHR==3

ERROR==TRAP

SKPRET==EMT

.BUG.==ERROR+BUG

.XCREF FOO,A,B,C,D,E,F,U,P,SP,PC,S
.XCREF OBADD1,OBADD2,OBSTRT,OBX0,OBX1,OBX2
.XCREF ERMNO,NNUMF
.XCREF TEXT,SPOP,SPUSH,POP,PUSH,OLE,BEGER,ERMM
.XCREF Z,ZED,ZPLUS,ZEPT
	.STITL MACROS

	.MACR PUSH AA
	MOV AA,-(P)
	JSR PC,PPUSHT
	.ENDM

	.MACR POP AA
	MOV (P)+,AA
	JSR PC,PPOPT
	.ENDM

	.MACR PUSHS AA
	JSR PC,SPUSHT
	MOV AA,@S
	.ENDM

	.MACR POPS AA
	MOV @S,AA
	JSR PC,SPOPT
	.ENDM

	.MACR SPUSH AA
	MOV AA,-(P)
	.ENDM

	.MACR SPOP AA
	MOV (P)+,AA
	.ENDM

	.MACR SPUSHS AA
	SUB #2,S
	MOV AA,@S
	.ENDM

	.MACR SPOPS AA
	MOV @S,AA
	ADD #2,S
	.ENDM

.MACR	TEXT AA
	.ASCII ÁA‰;DON'T TRY TO INCLUDE RUBOUTS IN TEXT
	.BYTE 0		;('CAUSE DELIMITERS ARE RUBOUTS)
	.EVEN
.ENDM

.MACR	.PRTXT AA
	JSR A,ERTAS
	AA
.ENDM

.MACR	PRTXT AA
	.PRTXT ^ÔEXT ^&AA&‰;RUBOUTS AROUND .PRTXT ARG
.ENDM

.MACR	CPRTXT	AA
	.PRTXT ^®BYTE	15
	TEXT ^&AA&‰;RUBOUTS!
.ENDM

.MACR	BPRTXT X
	.PRTXT ^®BYTE	7,7,15
	TEXT	^&X&‰;RUBOUTS!
.ENDM

.MACR	PRTXTC	AA
	.PRTXT ^®ASCII	&AA&
	.BYTE	15,0
	.EVEN‰	;RUBOUTS!
.ENDM

.MACR PAD A,B
	.PRINT &A B
&
.ENDM

.MACR PRCR
	JSR PC,.CRLF
.ENDM

.MACR SPACE
	JSR PC,.SPACE
.ENDM

.MACR SPREND
	JSR A,SPEND
.ENDM
LGNSYM==0
.MACRO LANGC EN,F
.IFNZ <ENG&FR>
	BIT #PFRFLG,LANG
	CONS BNE ,LS,\LGNSYM
.ENDC
.IF NZ ENG
EN
.ENDC
.IF NZ <FR&ENG>
CONS BR ,LS,\LGNSYM+1
CONS LS,\LGNSYM,::
.ENDC
.IF NZ FR
F
.ENDC
.IF NZ <FR&ENG>
CONS LS,\LGNSYM+1,::
LGNSYM==LGNSYM+2
.ENDC
.ENDM

.MACR REPT1 A,B
	.REPT A
	B
	.ENDR
.ENDM

.MACR REPT2 A,B,C
	.REPT A
	B
	C
	.ENDR
.ENDM

.MACR SDPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
.ENDC
.ENDM

.MACR SDPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
.ENDC
.ENDM

.MACR VERR
.IFLE .-.VERR-127.
	BVS	.VERR
.ENDC
.IFG .-.VERR-127.
	BVC	.+4
	.VERR==.
	ERROR+RTB
.ENDC
.ENDM

.MACR DPADD HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	ADD	LOW1,LOW2
	ADC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	ADD	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPSUB HIGH1,LOW1,HIGH2,LOW2
.IFNB LOW1
	SUB	LOW1,LOW2
	SBC	HIGH2
	VERR
.ENDC
.IFNB HIGH1
	SUB	HIGH1,HIGH2
	VERR
.ENDC
.ENDM

.MACR DPCLR HIGH,LOW
	CLR	HIGH
	CLR	LOW
.ENDM

.MACR DPINC HIGH,LOW
	DPADD ,#1,HIGH,LOW
.ENDM

.MACR DPDEC HIGH,LOW
	DPSUB ,#1,HIGH,LOW
.ENDM

.MACR DPNEG HIGH,LOW
	NEG LOW
	ADC HIGH
	NEG HIGH
.ENDM

.MACR NOP NUM
	.IFG NUM
	BR .+<NUM*2>
	NOP <NUM-1>
	.ENDC
.ENDM

.MACR EXCH LOC1,LOC2
	MOV	LOC1,EXCH1
	MOV	LOC2,LOC1
	MOV	EXCH1,LOC2
.ENDM

.MACR	ZED
	Z==0
.ENDM

.MACR	ZPLUS
	Z==Z+1
.ENDM

.MACR	ZEPT A,B
	ZED
	.REPT	A
	B
	ZPLUS
	.ENDR
.ENDM

.MACR	CONS	A,B,C
	A'B'C
.ENDM

.MACR CONC6 A,B,C,D,E,F
	A'B'C'D'E'F
.ENDM

.MACR	DINFO DEV,NUM,DTLST
	CONS N,DEV,<==NUM>
	TY==0
	TB==0
	SPC==0
	ZED
	.IRP	A,DTLST
	CONC6	DEV,\Z,<DT==>,A
	ZPLUS
		.IFZ	<A-TYDT>*<A-MODT>
		TY==TY+1
		.ENDC
		.IFZ	<A-TBDT>*<A-TBMDT>
		TB==TB+1
		.ENDC
		.IFZ	A-SPDT
		SPC==SPC+1
		.ENDC
	.ENDM
	CONS N,DEV,TY==TY
	CONS N,DEV,TB==TB
	CONS N,DEV,SPEC==SPC
.ENDM

.MACR	TBINFO NUM,DEV,LDLST
	CONS DEV,TBN==NFTBOX+<2*NUM>
	CONC6 TB,NUM,SND=,DEV,SND
	CONC6 TB,NUM,TB==,DEV,TB
	ZED
	.IRP	A,LDLST
		CONC6 A,SND=TB,NUM,SND
		CONS A,<TBN==DEV>,TBN
	ZPLUS
	.ENDM
	.MACR TB'NUM'LTB
		.IRP A,LDLST
		A
		.ENDM
	.ENDM
	CONS NTB,NUM,LD==Z
.ENDM

TYDT==1	;TTY
TBDT==2	;THORTON BOX
SPDT==3	;SPECIAL
MODT==4	;TTY MODEM
TBMDT==5	;THORTON BOX MODEM
.STITL	DEVICE CONFIGURATION

.IFNZ	AI		;AI DEVICES
	NDISP==4	;CHECK DLENGT IN SYS VARS IF THIS IS CHANGED
.IFF
	NDISP==0
.IFTF
	CLKFRQ==60.
	NTBOX==1
	NMBX==1
	NTY==1
	DINFO	DC,2,<<TBDT,MODT>>
		.MACR DCITB
		.WORD 111,113,100,103
		.ENDM
	DINFO	KL,0
	NDM==1
		NDMTY==MNUSRS-1
		NDMTB==0
		NDMSP==0
	DINFO	DP,0,
	DINFO	DN,0,
.IFT
	TBINFO	0,DC0,<<MB0,TU0,TU1,PL0>>
.IFF
	TBINFO 0,DC0,<<MB0,TU0,TU1,TU2>>
.ENDC

	NLDEV==NTUR+NMBX+NPLOT
	ZEPT NTUR,<
	CONS TU,\Z,==NFTUR+<2*Z>
>
	ZEPT NMBX,<
	CONS MB,\Z,==NFMBX+<2*Z>
>
	ZEPT NPLOT,<
	CONS PL,\Z,==NFPLOT+<2*Z>
>

	NFTY==0
	NFDCTY==2*NTY
	NFKLTY==2*<NTY+NDCTY>
	NFDPTY==2*<NTY+NKLTY+NDCTY>
	NFDMTY==2*<NTY+NKLTY+NDCTY+NDPTY>
	NFTV==2*<NTY+NKLTY+NDCTY+NDPTY+NDMTY>
	NTTY==NTY+NKLTY+NDCTY+NDPTY+NDMTY+NTVS
	NFTBOX==2*NTTY
	NFTUR==2*<NTTY+NTBOX>
	NFLDEV==NFTUR
	NFMBX==2*<NTTY+NTBOX+NTUR>
	NFPLOT==2*<NTTY+NTBOX+NTUR+NMBX>
	NTYDV==NTTY+NTBOX+NLDEV

	NPTBOX==2	;NUMBER OF PRIVATE TBOX
	MBDN==NFMBX	;NGKLUGE

;CONSOLE SWITCHES
SWB=177570	;CONSOLE SWITCH DATA
;CONSOLE TELETYPE
;BREAK LEVEL 4
TKBRV=60	;CONSOLE KEYBOARD BREAK VECTOR
TKS=177560	;CONSOLE KEYBOARD STATUS
TKB=177562	;CONSOLE KEYBOARD DATA
TPBRV=64	;CONSOLE PRINTER BREAK VECTOR
TPS=177564	;CONSOLE PRINTER STATUS
TPB=177566	;CONSOLE PRINTER DATA
;PROGRAMMABLE CLOCK
;BREAK LEVEL 6
PCBRV=104	;PROGRAMMABLE CLOCK BREAK VECTOR
PCS=172540	;PROGRAMMABLE CLOCK STATUS
PCSTBF=172542	;PROGRAMMABLE CLOCK SET BUFFER
PCCNT=172544	;PROGRAMMABLE CLOCK COUNTER
;RK05 DISK
;BREAK LEVEL 5
RKBRV=220
RKDS=177400
RKER=177402
RKCS=177404
RKWC=177406
RKBA=177410
RKDA=177412
;RF11/RS11 DISK
;BREAK LEVEL 5
DSKBRV=204	;DISK BREAK VECTOR
.IIF Z MVONLY, DSKS=177460	;DISK STATUS REGISTER
.IIF NZ MVONLY, DSKS=RKCS
DSKDBR=177472	;DISK DATA REGISTER
DSKWC=177462	;DISK WORD COUNT
DSKCA=177464	;DISK CURRENT ADDRESS
DSKA=177466	;DISK ADDRESS
DSKAE=177470	;DISK EXTENDED ADDRESS
;PAPER TAPE PUNCH
;BREAK LEVEL 4
PPBRV=74
PPB=177556
PPS=177554
;PAPER TAPE READER
;BREAK LEVEL 4
PRBRV=70
PRB=177552
PRS=177550
.IFNZ AI
;DR11 INTERFACE
;BREAK LEVEL 5
DRBRV=110	;INTERUPT A
DRBRVB=114	;INTERUPT B
DRS=177520
DROB=177522
DRIB=177524
;RJL A/D KLUDGE
ATODB=160104
DIGO=160102
DIGI=160100
.ENDC
;LINE CLOCK
;BREAK LEVEL 6
LKBRV=100
LKS=177546
;TK DISPLAY
NGCSR=164040	;DISPLAY CONTROL AND STATUS REGISTER
NGREL=164042	;DISPLAY RELOCATION REGISTER
;PARITY OPTION
PARCSR=172100	;FIRST STATUS REGISTER
PARBRV=114

;POWER FAIL
PFBRV=24
;BUS ERRORS
BEBRV=4
BPT=3
;TRAPS
TRPBRV=34
EMTBRV=30
IOTBRV=20
BPTBRV=14
PWFBRV=24

SSR0=177572
SSR1=177574
SSR2=177576
SSR3=172516
KIAR=172340
KIDR=172300
KDAR=172360
KDDR=172320

;PROCESSOR STATUS
PS=177776

;LINE PRINTER
LPBRV==200
LPCSR==177514
LPDBAR==177506
TVINCR=164140	;THE INCREMENT REGISTER FOR THE TV'S
TVINC==77	;THE MASK FOR THE INCREMENT
TVRSET==100000	;THE RESET BIT
TVCLRW==400	;THE COLOR WRITE BIT

TVSEL=164142	;THE CONSOLE SELECT REGISTER
TVRCNS==77	;THE CONSOLE NUMBER MASK
TVRWMD==300	;THE REGULAR WRITE MODE MASK
TVNSH==0	;NO SHIFT WRITE MODE
TVIOR==100	;THE INCLUSIVE OR MODE
TVXOR==200	;THE XOR MODE
TVMOV==300	;THE MOVE FUNCTION
TVDCNS==TVRCNS*400	;THE DISK CONSOLE NUMBER (SAME, BUT IN TOP BYTE)
TVDWMD==TVRWMD*400	;THE DISK WRITE MODE MASK

TVRADR=164144	;THE REGULAR ADDRESS REGISTER

TVWC=164146	;THE WORD COUNT FOR THE BLOCK WRITE

TVDADR=164150	;THE DISK TRANSFER ADDRESS REGISTER

TVSHR=164152	;THE SHIFT REGISTER
TVSHCN==17	;THE SHIFT COUNT
TVMAP==17400	;THE START OF THE 16K PAGE (IN 4K BLOCKS)
TVAMAP==20000	;THE ACTIVATE TVMAP BIT

TVMSK=164154	;THE MASK REGISTER

TVDWIN=164156	;THE WINDOW FOR DISK TRANSFERS

TVRWIN=164160	;THE WINDOW FOR REGULAR TRANSFERS

TVCNSL=164162	;THE CONSOLE REGISTER FOR THE MEMORY
TVCLR==160000	;THE COLOR NUMBER

LKBB==164100	;LEBEL KEYBOARD INTERFACE

VIDSW=164104	;VIDEO SWITCH
TVDOIT==11
	.STITL ALLOCATION PARAMETERS

SYPDLL==240
DSECLN==400
PPDLL==1000
SPDLL==1000
PDSLOP==140
PDSWOP==374
MAXARG==32.
.IF1
.IFG MAXARG-<SPDLL-PDSWOP>/4
.ERROR \CHANGE MAXARG OR SPDLL SIZE
\
.ENDC
.ENDC
DBUFL==2000
	.IIF NZ AI, FDSCSZ==20
	.IIF NZ GUY, FDSCSZ==40
	.IIF NZ MVONLY, FDSCSZ==400
	FDSCMS==FDSCSZ-1	;SECTOR MASK

DTIBFL==2000
DEDBFL==2000

DWRTEC==103
DREADC==105
DWRTCC==107

FRTRCF==1
SWTRCF==2
SPTRCF==4
GCTRCF==10

FRBKBT==200	;200 BIT MEANS NEVER RUN
FRSCED==1	;FLUSHED DUE TO SCHEDULEING
FRDSKW==3	;HANGING ON DISK
FRTYIW==4	;HANGING ON TYI OF CHAR
FRTYOW==5	;HANGING ON FULL TYO BUFFER
FRRAND==6	;HANGING FOR "UNKNOWN" REASON
FRNEWU==7	;HANGING BECAUSE HAVE NOT YET BEEN INITIALIZED
FRTYIH==210	;HANGING ON LINE INPUT
FRLINW==FRTYIH
FREDW==11	;HANGING ON EDIT TYO
FRTURW==12	;HARE (SEE AESOP)
FRTYIC==13	;HANGING ON INIT TYI OF CHAR
.IIF NZ NINT,	FRNIU==211	;HANGING ON NON-INITIALIZED USER
	;NODE TYPES
SFUN==000000
INFIX==10000
UFUN==20000
UVAR==30000
IDLE==40000
BUKTEL==60000	;NODE IN BUCKET OF OBLIST (INVALID TOKEN TYPE)
;THE FOLLOWING TYPES ARE NEEDED IN THIS ORDER BY THE CONVERT ROUTINES
SSTR==70000	;NOT VALID TOKEN TYPE
SNP==100000
ATOM==110000
SNUM==120000	;NOT A VALID TOKEN TYPE
LNUM==130000
INUM==LNUM	;INTEGER NUMBER
LSTR==140000
FNUM==150000
LIST==170000
SENT==LIST
;END OF ORDER

	;BINDING TYPES
FBIND==20000
VBIND==30000
;DON'T USE 40000, IT IS "IDLE" (UGH)
ABIND==50000
SVBIND==130000	;SWAPPED OUT  VARIABLE BINDING


	;SOE FLAGS SEE OLE MACRO STUFF
VNAF==2000

	;READ FLAGS SEE DTBL:
DOTF==400	;IN LEFT HALF
	;EVAL FLAGS - PUSHED BY PEVAL
PTLPF==1	;PREVIOUS TOKEN WAS LEFT PAREN
RTF==2	;REPEAT TOKEN
CRF==4	;CURRENT TOKEN IS CR
EDITF==10	;EDIT FLAG
DORF==20	;SET IF THIS FRAME IS A DO OR A READ
;	TOF==20	;TO FLAG
;	IFF==40	;IF FLAG
TSTFLG==100	;TEST FLAG FOR TEST, IFTRUE AND IFFALSE
SPDF==200	;SKIP PROC DEF. FLAG
TPTF==400	;THIS PROCEDURE TRACED FLAG	;MUST BE IN LEFT HALF
EDTIF==1000	;EDIT TITLE FLAG
BRKF==2000	;BREAK MODE FLAG
ERRF==4000	;ERROR FLAG
EDTIF2==10000	;BECOMES EDTIF ON LEAVING EVAL
TPSF==20000	;THIS PROCEDURE STEPPED FLAG	;MUST BE IN LEFT HALF
TPBF==40000	;THIS PROCEDURE BURIED FLAG	; "   "  "   "    "
EVIFS==PTLPF+RTF+CRF	;FLAGS CLEARED BY EVLINE

	;EVAL FLAGS2 - NOT PUSHED
CPTBF==1	;CHANGE % TO BLANK
TRACEF==2
PQF==4		;PRINT QUOTE FLAG - FOR PRSTR
DPQF==10	;DONT " " "
MMF==20	;MULTIPLE MAKE FLAG
SSF==40	;SPECIAL STATUS FLAG
PADERF==100	;PRINT ADDRESS OF ERROR
MGCF==200	;MANY G. C.'S FLAG
PNNLF==400	;PRINT NO. NODES LEFT
DSAMFL==1000	;DISK ALMOST FULL
PPNAIF==2000	;P PDL NOT ALL THE WAY IN
SPNAIF==4000	;S PDL NOT ALL THE WAY IN
HERRF==10000	;HARD ERROR
CHEKUF==20000	;TURNS ON VARIOUS USER CHECKING THINGS
DRIBBF==40000	;DRIBBLE OUTPUT
	;TEMP FLAGS IN TFLAGS
TF6==1
RBRKF==2	;BREAK FLAG - FOR ROUTINE THAT CALLS RDSTR
TF7==4
TF1==100	
TF2==200
TF3==400
TF4==10000
TF5==20000

	;FLAGS IN LEFT HALF OF 1ST NODE OF SWAPPED PROC LIST
; TPTF==400	DEFINED ABOVE- SET BY "TRACE FOO" CLEARED BY "ERASE TRACE FOO"
; TPSF==20000	DEFINED ABOVE- SET BY "STEP FOO" CLEARED BY "ERASE STEP FOO"
; TPBF==40000	DEFINED ABOVE- SET BY "BURY FOO" CLEARED BY "ERASE BURY FOO"

NBN==40	;# BUFFER NODES - IF FREE NODES < THIS, == NO STG LEFT


	.IFNZ NDISP
;DISPLAY COMMANDS
ADDX==150000
ADDY==144000
ADDXY==ADDX!ADDY
DPUSHJ==100000
DPOP==140200
DPOPJ==140100
DSTOP==140400
DRSTXY==143000	;RESET X AND Y TO 0
DINC==40000

TURSIZ==6	;THE SIZE OF THE TURTLE

TKRUN==4000
TKGO==10000
TKSTOP==20000
.ENDC


.IFNZ GTI
GTNOP==0	;NOP
GTHOME==4000	;HOME
GTPEND==4400	;PENDOWN
GTPENU==4407	;PENUP
GTSTUR==5001	;SHOWTURTLE
GTHTUR==5000	;HIDETURTLE
GTSNAP==5400	;SNAP (ADDRESS IN NEXT WORD)
GTBLNK==6000	;BLINK
GTWRAP==6400	;WRAP
GTCLIP==6401	;CLIP????
GTRSET==7000	;RESET???
GTFD==10000	;FORWARD+11 BITS OF DISTANCE
GTRT==14000	;RIGHT+11 BITS OF ANGLE
GTSHED==20000	;SET HEADING+11 BITS OF HEADING
GTMOVE==24000	;MOVE+11 BITS OF SPEED
GTSPIN==30000	;SPIN+11 BITS OF SPEED
GTDISP==34000	;DISPLAY, ADDRESS IN NEXT WORD
GTSTXY==40000	;SET X+11 BITS, Y IN NEXT WORD
GTDLXY==44000	;DELTA X+11 BITS, Y IN NEXT WORD
GTCS==50000	;CLEAR SCREEN
GTRUB==50000	;RUBOUT+11 BITS OF WORDS TO RUB OUT (SHOULD BE NEGATIVE)

.ENDC

.MACRO GTJUMP ADDR
.IFNZ GTI
	TST GTIDF
	BEQ .+6
	JMP ADDR
.ENDC
.ENDM


;FLAGS USED FOR DFLAGS
PENUF==1
HIDETF==4
TURTF==10
TEMF==20
DISPF==40
WRAPF==100
PLOTF==200
.STITL TRAP VECTORS


;TRAP VECTORS
;UNUSED VECTORS
.=0
	BPT	;DIE ON JUMP TO ZERO
GUNU==.
	-1	;USER TO GUN DOWN

	REPT2 77,.+2,IOT	;GO TO 2ND WORD OF VECTOR AND DIE

	.=BEBRV
	BEBRK
	340

	.=TRPBRV
	ERRBK	;TRAP IS USED FOR ERRORS
	0

	.=TKBRV
	TKBRK	;CONSOLE TTY KEYBOARD
	200	;IS ON BR4

	.=TPBRV
	TPBRK	;CONSOLE TTY PRINTER
	200	;IS ON BR4

	.=LKBRV
	CLKBRK
	300

	.=PCBRV
	CLKBRK	;PROGRAMMABLE CLOCK
	300	;IS ON BR6

	.=DSKBRV
	DSKBRK	;FIXED HEAD DISK
	300	;IS ON BR5, INT ROUTINE RUNS ON LEVEL 6

	.=RKBRV
	RKBRK
	300

	.=IOTBRV
	IOTBRK
	340

	.=EMTBRV
	EMTBK
	340

	.=PRBRV
	PRBRK
	200

	.=PPBRV
	PPBRK
	200

	.=PFBRV
	PWRDWB
	340

	.=40
	LOGON
LVERNF:	VERNF
TIME:	0
	0

	.=PARBRV
	PARBRK
	340

.IFNZ LPF
	.=LPBRV
	LPBRK
	240
.ENDC
	.STITL	FLOATING TRAP VECTORS & DEVICE INFO

	.=300	;START OF FLOATING VECTORS
;DC11 (BR5)
ZEPT	NDC,<
	CONS DC,\Z,<RS=174000+<Z*10>>	;RCV STATUS REG
	CONS DC,\Z,<RB=174002+<Z*10>>	;RCV BUFFER
	CONS DC,\Z,<TS=174004+<Z*10>>	;TRANSMIT STATUS
	CONS DC,\Z,<TB=174006+<Z*10>>	;TRANS BUF

	CONS DC,\Z,RV=.	;RCV VECTOR
	CONS DC,\Z,TV=.+4	;TRANS VECTOR
	CONS DC,\Z,RK
	240
	CONS DC,\Z,TK
	240
>
;KL11  (BR4)
ZEPT	NKL,<
	CONS KL,\Z,<RS=176500+<Z*10>>	;RCV STATUS REG
	CONS KL,\Z,<RB=176502+<Z*10>>	;RCV BUFFER
	CONS KL,\Z,<TS=176504+<Z*10>>	;RCV BUFFER
	CONS KL,\Z,<TB=176506+<Z*10>>	;TRANS BUF

	CONS KL,\Z,RV=.	;RCV VECTOR
	CONS KL,\Z,TV=.+4	;TRANS VECTOR
	CONS KL,\Z,RK
	200
	CONS KL,\Z,TK
	200
>
;DP11  (BR5)
ZEPT	NDP,<
	CONS DP,\Z,<RS=174770-<Z*10>>	;RCV STATUS REG
	CONS DP,\Z,<RB=174772-<Z*10>>	;RCV BUFFER
	CONS DP,\Z,<SR=174773-<Z*10>>	;SYNCH REGISTER
	CONS DP,\Z,<TS=174774-<Z*10>>	;TRANSMIT STATUS
	CONS DP,\Z,<TB=174776-<Z*10>>	;TRANS BUF
	CONS DP,\Z,<ESR=174777-<Z*10>>	;EXTENDED SYNCH REGISTER

	CONS DP,\Z,RV=.	;RCV VECTOR
	CONS DP,\Z,TV=.+4	;TRANS VECTOR
	CONS DP,\Z,RK
	240
	CONS DP,\Z,TK
	240
>
.IFZ DHON
;DM11 (BR5)
ZEPT	NDM,<
	CONS DM,\Z,<CSR=175000+<Z*10>>	;CONTROL STATUS REG
	CONS DM,\Z,<BAR=175002+<Z*10>>	;BUFFER ACTIVE REGISTER
	CONS DM,\Z,<BCR=175004+<Z*10>>	;BREAK CONTROL REGISTER
	CONS DM,\Z,<TBR=175006+<Z*10>>	;TABLE BASE REGISTER

	CONS DM,\Z,RV=.	;RCV VECTOR
	CONS DM,\Z,TV=.+4	;TRANS VECTOR
	CONS DM,\Z,RK
	240
	CONS DM,\Z,TK
	240
>
.IFF
;DH11 (BR5)
ZEPT	NDM,<
	CONS DH,\Z,<SCR=160020+<Z*20>>	;SYSTEM CONTROL REGISTER
	CONS DH,\Z,<NRC=160022+<Z*20>>	;NEXT RECIEVED CHARACTER
	CONS DH,\Z,<LPR=160024+<Z*20>>	;LINE PARAMTER REGISTER
	CONS DH,\Z,<CAR=160026+<Z*20>>	;CORE ADDRESS REGISTER
	CONS DH,\Z,<BCR=160030+<Z*20>>	;BYTE COUNT REGISTER
	CONS DH,\Z,<BAR=160032+<Z*20>>	;BUFFER ACTIVE REGISTER
	CONS DH,\Z,<BRC=160034+<Z*20>>	;BREAK CONTROL REGISTER
	CONS DH,\Z,<SSR=160036+<Z*20>>	;SILO STATUS REGISTER
;CROCK
.=340
	CONS DH,\Z,RV=.
	CONS DH,\Z,TV=.+4
	CONS DM,\Z,RK
	240
	CONS DM,\Z,TK
	240
>
.ENDC
	.STITL SYSTEM VARIABLES(ONE COPY)


	.=400
	BR .+6
	JMP @#PWRUPB
	JMP @#START
	.=.+SYPDLL	;SYSTEM PDL
SJPDLP:SPDLP:	.	;SYSTEM PDL POINTER
	.=.+60
PFPDL:	0
PAT:
PATCH:	.=.+400	;PATCH AREA
PATEND=1400
LOGON:	.ASCIZ /LOGO/
.EVEN
.IFZ DHON
.IFNZ	NDMTY
.=1400
	DMCA=.-NFDMTY
	.=.+40	;DM11 CURRENT ADDRESS
	DMWC=.-NFDMTY
	.=.+40	;DM11 -BYTE COUNT
	.=.+40	;DM11 BIT ASSEMBLY TABLE
;DM0RK:	.=.+40	;UNUSED -- RCV INT HALT
	.=.+40
DMTT:	.=.+200	;DM11 TUMBLE TABLE
.ENDC
.ENDC
	ZEPT NDC,<
	CONC6 <
	.IFZ DC>,\Z,<DT-SPDT
CONS DC,\Z,RK:
	0
CONS DC,\Z,TK:
	0
	.ENDC
>>
	ZEPT NKL,<
	CONC6 <
	.IFZ KL>,\Z,<DT-SPDT
CONS KL,\Z,RK:
	0
CONS KL,\Z,TK:
	0
	.ENDC
>>
	.STITL SYSTEM OBLIST

VARIABLE==4	;FOR VARIABLE NUMBER OF ARGUMENTS
YINFIX==20	;"YES INFIX" FLAG FOR OLE

;SOE FIELDS		1.==RIGHT BYTE (EVEN ADDR) 2.==LEFT BYTE
	;		1.1==RIGHT BIT  2.8==LEFT BIT
ABRFLG==1
FRFLG==2
ENGFLG==4
PFRFLG==10
	;1.4-1.8 UNUSED
	;2.1-2.2 "STANDARD" NO. OF INPUT ARGS
	;2.3 VNAF 1==CAN TAKE "ANY" NO. OF ARGS
	;2.5 INFIX 1==THIS IS AN INFIX PROCEDURE
	;2.6-2.8 PRECEDENCE

	.MACR NGPTWO A
	NGP2=NGP2*2
	FOO==A
	.IFLE NGP2-FOO
	NGPTWO A
	.ENDC
	.ENDM

;****************************************************
;MACRO TO DEFINE SYSTEM OBLIST ELEMENTS
;THE PARAMETERS ARE:
;1)	THE PRINT NAME
;2)	PRINT NAME OF ABBREVIATION
;3)	THE NAME OF THE POINTER TO THE OBLIST ELEMENT.
;4)	THE ADDRESS OF THE PROGRAM
;5)	THE PRECEDENCE.  A NUMBER FROM 0-7
;6)	THE NUMBER OF ARGUMENTS, AND THE SYMBOL "VARIABLE"
;		IF IT CAN ALSO TAKE A VARIABLE NUMBER OF ARGUMENTS
;7)	THE SYMBOL "YINFIX" IF THIS IS AN INFIX OPERATOR
	;8)	IF 0, DONT ASSEMBLE THIS PRIMITIVE



;VERSION FOR OBLIST ELEMENTS THAT ARE BOTH FRENCH AND ENGLISH
.MACR OLB PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG!FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG!FRFLG
.ENDC
.ENDC
.ENDM
;VERSION FOR ENGLISH ONLY
.MACR OLE PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ ENG
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG
.ENDC
.ENDC
.ENDC
.ENDM
;VERSION FOR FRENCH ONLY
.MACR OLF PN,ABR,OB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ FR
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
.IFB OB
.IIF P1,.IIF DEF $'PN,.ERROR PN OBLIST CONFLICT
$'PN==.-SOBLST/2
.ENDC
.IFNB OB
.IIF P1,.IIF DEF $'OB,.ERROR OB OBLIST CONFLICT
$'OB==.-SOBLST/2
.ENDC
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,FRFLG
.ENDC
.ENDC
.ENDC
.ENDM
.MACR CDM A
A==<.-SOBLSU>/2
.ENDM

.MACR ABRV PN,OB,FLGS
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
OBLSTL==OBLSTL+4+OBL
.ENDC
.IF2
OBADD2-SOBLST
OBADD1=.
.=OBADD2
ABRFLG!FLGS
OB
TEXT ^\PN\
OBADD2=.
.=OBADD1
.ENDC
.ENDM
.MACR OLT PN,ABR,FPN,FAB,AD,PR,NU,QI,X
.IIF B X,.IFZ 0
.IIF NB X,.IFNZ X
.IFNZ ENG
.IF1
NUMOBS==NUMOBS+1
TEXT ^@PN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE ENGFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@PN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB ABR
ABRV ABR,OLEAD-SOBLST,ENGFLG
.ENDC
.ENDC
.IFNZ FR
.IF1
NUMOBS==NUMOBS+1
TEXT ^@FPN@
.ENDC
.IF2
OBADD2-SOBLST
OBADD1==.
.=OBADD2
OBX1==NU+0
OLEAD==.
.IIF B PR,OBX2==PREPRI*40
.IIF NB PR, OBX2=PR*40
.BYTE FRFLG,QI+OBX1+OBX2
.IIF B AD,PN
.IIF NB AD,AD+0
TEXT ^@FPN@
OBADD2=.
.=OBADD1
.ENDC
.IFNB FAB
ABRV FAB,OLEAD-SOBLST,FRFLG
.ENDC
.ENDC
.ENDC
.ENDM
;THE SYSTEM OBLIST
	;ADD ITEMS (EXCEPT FOR SPECIAL CHAR ITEMS) ALPHABETICALLY.

	.IF1
	NUMOBS==0
	.=.+4	;RESERVE SPACE FOR THE TWO WORDS ON PASS TWO
	.ENDC
	.IF2
SOBLSU=SOBLST+<NUMNSCOBS*2>-2
SOOMX=.
	2+SOBLSU	;2 > THAN HIGHEST ADDR USED IN SYS OBLIST
	NGP2==1
	NGPTWO SOBLSU-SOBLST+2
SOBP2=.
	NGP2	;( SMALLEST POWER OF 2 >= NUMOBS )*2
OBADD1=.
OBADD2=.+<2*NUMOBS>
OBSTRT=OBADD2	;WHERE THE SYSTEM OBLIST ELEMENTS START
	.ENDC

		;PRIORITIES
	PARPRI==1	; (  )
	BAKPRI==2	; _ __ IF TEST NOT BOTH EITHER
	RELPRI==3	; < = >
	PREPRI==4	;PRIORITY FOR MOST PREFIX PRIMITIVES
	PMPRI==5	; + -
	MDPRI==6	; * / \
	HIPRI==7	; : ! # -- ++
SOBLST:	OLB 0
	OLB .CASESW,,CASESW,CASESW,,1
	OLB .CGCF,,CGCF,CGCF
	OLB .CLOSE,,CLOSE,CLOSE,,1
	OLB .CLOSEF,,,.CLOSF
	OLB .CPNF,,CPNF,CPNF
	OLB .CTF,,CTF,CLRSTF
	OLB .CTYI,,CTYI,CTYI
	OLB .CTYO,,CTYO,CTYO,,1
	OLB .DEPOSIT,,DEPOSIT,DEPOSIT,,1
	OLB .ECHOSW,,ECHOSW,ECHOSW,,1
	OLB .EXAMINE,,EXAMINE,EXAMINE,,1
	OLB .FILEO
	OLB .FILEP,,,,,1
	OLB .FILER
	OLB .GCOLL
	OLB .GTIOUT,,,,,1,,GTI
	OLT .GUN,,.POW,,GUN,,1
	OLB .HALT
	OLB .NODES,,NODES,NODES
	OLB .OPENA,,,,,1
	OLB .OPENR,,,,,1
	OLB .OPENW,,,,,1
	OLB .PWRCLR,,PWRCLR,PWRCLR
	OLB .RUG,,RUG,RUNRUG
	OLB .SETTV,,SETTV,SETTV,,2
	OLB .SGCF,,SGCF,SGCF
	OLB .SPNF,,SPNF,SPNF
	OLB .STATUS,,,STATUS
	OLB .STF,,,SETSTF
	OLB .STYO,,,,,2
	OLB .TOP,,,,,1
	OLB .TTYP,,,,,1
	OLB .TYI,,TYI,UGTYI,,1
	OLB .TYO,,TYO,UGTYO,,2
	OLB .USRTIME,,USRTIME,USRTIME
	OLB .VALUE,,VALUE,VALUE
	OLB .VERSION,,VERSION,VERSN
	OLB .XOR,,,,,1,,AI
	OLE ALL,,,NOTPRO
	OLT ALSO,,AUSSI,,,,,,DDF
	OLB ANGLAIS,,,,,,,<ENG&FR>
	OLF ARBRE,,,NOTPRO
	OLB ARCTAN,ATAN,,ATAN,,1,,FPPF
	OLE ARRAY,,,NOTPRO
	OLE ARRAYS,,ARAYS,NOTPRO
	OLT ASIZE,,DIMMAT,,ASIZEX,,1
	OLB ATOD,,,,,1,,AI
	OLT BACK,BK,RECULE,RE,,,1
	OLT BELL,,DING
	OLB BITOUT,,,,,1,,AI
	OLT BLINK,,CLIGNE,,,,,,GTI
	OLT BOTH,,LESDEUX,,,BAKPRI,2
	OLB BOXIN,,,,,1,,AI
	OLT BTOUCH,,TOUCHEAR
	OLE BURY
	OLT BUTFIRST,BF,SAUFPREMIER,SP,,,1
	OLT BUTLAST,BL,SAUFDERNIER,SD,,,1
	OLF CACHE,,,HIDETU,,,,GTI
	OLB CHAR,,,,,1
	OLB CLIP,,,,,,,,NTVS!GTI
	OLT CLEARSCREEN,CS,VIDEECRAN,VE,,,,,NDISP!GTI
	OLT CLOCK,,SECONDES
	OLB CNTRL,,,,,,,DDF
	OLT CONTENTS,,CONTENU
	OLB CONTINUE,CO
	OLB COS,,,COSF,,1,,FPPF
	OLT COUNT,,COMPTE,,,,1
	OLB CRINDEX,,,.CRIND,,1
	OLB CTYOWAIT,,,,,1
	OLB DATE,,,UDATEG
	OLB DEBUG,,,DEBUGL
	OLT DEFINEARRAY,DEFAR,DEFMATRICE,DEFMAT,DEFAR,,3+VARIABLE
	OLT DELETE,,FRDELETE,,.DELET,,1
	OLB DELTAXY,DELXY,,,,1,,GTI
	OLT DELETEINDEX,,FRDLI,,.DELI,,1
	OLB DIFFERENCE,,,DIFF,,2
	OLE DISPLAY,,,,,1,,NDISP!GTI
	OLE DRIBBLE,,,,,1,,DRIBF
	OLB ED,,,EDIT
	OLT EDIT,,EDITE
	OLB EDL,,,EDLINE
	OLB EDT,,,EDTITL
	OLT EITHER,,UNDE,,,BAKPRI,2
	OLE ELSE
	OLT EMPTYP,,VIDE,,EMPTYP,,1
	OLT END,,FIN
	OLE NODRIBBLE,,,,,,,DRIBF
	OLF ENFOUIS,,,BURY
	OLB ENGLISH,,,,,,,<ENG&FR>
	OLT EQUAL,IS,EGAL,,EQUAL,,2
	OLT ERASE,ER,EFFACE,EF
	OLT ERASEFILE,ERF,DETRUIS,,.DELET,,1
	OLT ERASEINDEX,ERI,DETRUISINDEX,,.DELI,,1
	OLB ERBRK,,ERRBREAK,ERRBREAK
	OLB ERCLR,,ERRCLEAR,ERRCLEAR
	OLT ERL,,EFL
	OLB ERLIN,,ERRLINE,ERRLINE
	OLB ERLOC,,ERRLOCATION,ERRLOCATION
	OLB ERNAM,,,ERRNAM
	OLB ERNUM,,ERRNUMBER,ERRNUMBER
	OLB ERPRO,,ERRPROCEDURE,ERRPROCEDURE
	OLB ERRET,,RETURN,RETURN,,1
	OLB ERSET,,ERRSET,ERRSET
	OLB ERTOK,,ERRTOKEN,ERRTOKEN
	OLF EXECUTE,,,DO,,1
	OLE EYETURTLE,,,EYE,,1,,AI
	OLF FICHIER,,,NOTPRO
	OLE FILE,,,NOTPRO
	OLT FIRST,F,PREMIER,PREM,,,1
	OLF FIXEDIR,,,SETHEA,,1,,GTI!NPLOT!NDISP
	OLT FORWARD,FD,AVANCE,AV,,,1
	OLT FPRINT,,ECRISC,,,,1+VARIABLE
	OLT FPUT,,INCLUSD,,,,2+VARIABLE
	OLB FRANCAIS,,,,,,,<ENG&FR>
	OLB FRANGLAIS,,,,,,,<ENG&FR>
	OLB FRENCH,,,,,,,<ENG&FR>
	OLT FTOUCH,,TOUCHEAV
	OLT GET,,SORT,,,,2+VARIABLE
	OLT GO,,VA,,,,1
	OLT GOODBYE,,SALUT
	OLT GREATER,,PLUSGRAND,,GREATR,,2
	OLT GTIDIS,,ECRAN,,,,,,GTI
	OLB HALHACK,,,,,1,,HALFLG
	OLT HEADING,,CAP,,,,,,<NDISP!NPLOT>
	OLT HELLO,,ALLO
	OLT HERE,,ICI,,,,,,<NDISP!NPLOT>
	OLT HIDETURTLE,HT,CACHETORTUE,CTT,,,,,NDISP!GTI
	OLT HISSPEED,,SAVITESSE,,,,2,,DHON
	OLT HOME,H,ORIGINE,ORI,,,,,<NDISP!NPLOT!GTI>
	OLE IF,,,,BAKPRI,1
	OLT IFFALSE,IFF,SIFAUX,SIF
	OLT IFTRUE,IFT,SIVRAI,SIV
	OLB ILINE
	OLB INDEX,,,NOTPRO
	OLB INTEGER,INT,,,,1,,FPPF
	OLT LAMPOFF,,ETEINT
	OLT LAMPON,,ALLUME
	OLT LAST,L,DERNIER,DER,,,1
	OLT LEFT,LT,GAUCHE,GA,,,1
	OLT LESS,,PLUSPETIT,,LESSP,,2
	OLT LEVEL,,NIVEAU,,FLEV
	OLT LIGHT,,LUMIERE
	OLF LIGNE,,,NOTPRO
	OLE LINE,,,NOTPRO
	OLT LINEPRINT,LP,IMPRIMANTE,IMP,LPRINT,,1,,<LPF&AI>
	OLT LINEPRINT,LPT,IMPRIMANTE,IMP,LPRINT,,1,,<LPF&GUY>
	OLT LIST,,LISTE,,LIST.P,,2+VARIABLE
	OLT LISTP,,LISTEP,,LISTP,,1
	OLB LOCAL,,,,,1
	OLT LOGIN,,CEST,,,,1
	OLT LPUT,,INCLUSF,,,,2+VARIABLE
	OLT LTOUCH,,TOUCHEG
	OLT MAIL,,MALLE,,,,1
	OLT MAKE,,RELIE,,,,2
	OLF MATRICE,,,NOTPRO
	OLF MATRICES,,MATRS,NOTPRO
	OLB MCLEAR
	OLT MLEN,,LONGM
	OLF MONTRE,,,DISPLAY,,1,,NDISP!GTI
	OLT MOVETURTLE,MOVET,BOUGE,,MOVE,,1,,GTI
	OLB MUCTRL,,,,,1
	OLB MUTYO,MUT,,,,2+VARIABLE
	OLB MUWAIT,,,,,1
	OLT MYSPEED,,MAVITESSE,,,,1,,DHON
	OLE NAME,,,NOTPRO
	OLE NAMES,,,NOTPRO
	OLT NEWSNAP,,NOUVPHOTO,,,,,,NDISP
	OLT NODISPLAY,,LIBECRAN,,KILLDISPLAY,,,,NDISP
	OLF NOM,,,NOTPRO
	OLF NOMS,,,NOTPRO
	OLT NOMUSIC,,LIBMUSIQUE
	OLT NOPLOTTER,,LIBTRACEUR,,KILLPL,,,,NPLOT
	OLT NOT,,NON,,,BAKPRI,1
	OLE NOTBOX,,,,,,,1
	OLB NOTE,,,SING,,2+VARIABLE
	OLT NOTURTLE,,LIBTORTUE,,KILLTURTLE
	OLT NOWRAP,,DEBORDEPAS,,,,,,NDISP
	OLT NUMBERP,,NOMBREP,,NUMBP,,1
	OLT NVOICES,,NPISTES,,,,1
	OLB OUTPUT,OP,,,,1
	OLF PASAPAS,,,STEP
	OLB PAUSE
	OLB PEEK
	OLB PEEKD,,,PEEKDV
	OLT PENDOWN,PD,DESCENDPLUME,DP
	OLT PENP,,PLUMEP,,,,,,1
	OLT PENUP,PU,LEVEPLUME,LP
	OLE PLOTTER,,,STRTPL,,,,NPLOT
	OLT PM,,JM
	OLT POF,,IMF,,.POF,,1
	OLT POI,,IMI,,.POI
	OLF POINTE,,,SHOWTU,,,,GTI
	OLT POL,,IML
	OLT POT,,IMT
	OLT POTS,,IMTS
	OLT PRINT,PR,ECRIS,EC,,,1+VARIABLE
	OLT PRINTOUT,PO,IMPRIME,IM,SHOW
	OLB PROCEDURES,,,NOTPRO
	OLT PRODUCT,,PRODUIT,,PROD,,2+VARIABLE
	OLB QUOTIENT,,,DIVDE,,2
	OLT RANDOM,,HASARD
	OLT READ,,RAMENE,,.READ,,1
	OLT READPTR,PTR,DECODE,,,,1+VARIAB
	OLT RELAY,RELAIE,,,,,2,,AI
	OLT REMAINDER,MOD,RESTE,,MOD,,2
	OLT REQUEST,RQ,REPONSE,,RQUEST
	OLT RIGHT,RT,DROITE,DR,,,1
	OLT RTOUCH,,TOUCHED
	OLT RUBDIS,,ENLEVE,,,,1,,GTI
	OLE RUN,,DO,DO,,1
	OLT SEND,,MESSAGE,,,,2,,SYSP
	OLT SENTENCE,SE,PHRASE,PH,,,2+VARIABLE
	OLT SETASIZE,,FIXEDIMMAT,,SETASZ,,1
	OLT SETHEADING,,METSLECAP,,,,1,,<NDISP!GTI!NPLOT>
	OLT SETTURTLE,SETT,PLACETORTUE,,,,1,,<NDISP!GTI!NPLOT>
	OLT SETINDEX,SETI,FIXEINDEX,FIXEI,.DIRSE,,1
	OLT SETXY,,FIXEXY,,,,2,,<NDISP!GTI!NPLOT>
	OLT SETX,,FIXEX,,,,1,,<NDISP!NPLOT>
	OLT SETY,,FIXEY,,,,1,,<NDISP!NPLOT>
	OLT SHOWTURTLE,ST,TORTUEPOINTEE,TPT,,,,,NDISP!GTI
	OLF SI,,,IF,BAKPRI,1
	OLB SIN,,,SINEF,,1,,FPPF
	OLF SINON,,,ELSE
	OLT SNAP,,PHOTO,,,,,,NDISP!GTI
	OLB SPIN,,,,,1,,GTI
	OLT SQRT,,RCAR,,,,1,,FPPF
	OLT STARTDISPLAY,SD,BEGECRAN,,,,1,,NDISP
	OLE STEP,,.STEP
	OLB STOP
	OLB STORE,,,,,3+VARIABLE
	OLT SUM,,SOMME,,,,2+VARIABLE
	OLB SWITCH,,,,,2,,AI
	OLT SYSPR,,ATOUS,,,,1,,SYSP
	OLE TBOX,,,,,,,1
	OLT TEST,,TESTE,,,BAKPRI,1
	OLT TEXT,,TEXTE,,TEXTT,,1
	OLT THEN,,ALORS
	OLT THING,,CHOSE,,DOTS,,1
	OLT THINGP,,CHOSEP,,,,1
	OLT TIME,,HEURE,,UTIMEG
	OLE TITLE,,,NOTPRO
	OLE TITLES,,TITLS,NOTPRO
	OLF TITRE,,,NOTPRO
	OLF TITRES,,TITRS,NOTPRO
	OLT TO,,POUR
	OLT TOOT,,BEEP,,,,1
	OLT TOPLEVEL,,NIVEAUSUP,,EXIT
	OLF TORTUE,,,STARTT,,1
	OLF TOUT,,,NOTPRO
	OLB TRACE
	OLF TRACEUR,,TRAC,STRTPL,,,,NPLOT
	OLE TREE,,,NOTPRO
	OLB TTYP
	OLE TURTLE,,STTUR,STARTT,,1
	OLE TVHACK,,,TVWHK,,2,,JRDF
	OLB TYOWAIT,,,,,2
	OLT TYPE,,TAPE,,,,1+VARIABLE
	OLT TYPEIN,,PREPONSE
	OLB UNTIL,,,,,1
	OLT USE,,REFERE,,.USE,,1
	OLT VLEN,,LONGP
	OLT VOICE,,PISTE,,,,1
	OLT WAIT,,ATTENDS,,UWAIT,,1
	OLT WHERE,,OU
	OLT WIPE,,DEGAGE,,,,1,,NDISP
	OLT WIPECLEAN,WC,BALAYE,,,,,,NDISP
	OLT WORD,,MOT,,,,2+VARIABLE
	OLT WORDP,,MOTP,,WORDP,,1
	OLT WRAP,,DEBORDE,,,,,,NDISP
	OLT WRITE,,ENVOIE,,.WRITE,,1
	OLT WRITEPTP,PTP,PERFORE,,,,1+VARIABLE
	OLB XCOR,,,,,,,<NDISP!NPLOT>
	OLB YCOR,,,,,,,<NDISP!NPLOT>
	.IF1
NUMNSC==NUMOBS	;NUMBER OF NON-SPECIAL CHARACTER OBLIST ELEMENTS

	.ENDC
	OLB ^\!(\,,LLPAR,LLPAR,PARPRI,1
	CDM EXCL$
	OLB ^\!\,,COMT,COMT,HIPRI
	CDM HASH$
	OLB ^\#\,,PROC,PROC,HIPRI,1
	CDM LP$
	OLB ^\(\,,LPAR,LPAR,PARPRI,1
	CDM RP$
	OLB ^\)\,,RPAR,RPAR,PARPRI
	CDM PRD$
	OLB ^\*\,,STAR,PROD,MDPRI,2+VARIABLE,YINFIX
	CDM PLU$
	OLB ^\+\,,PLUS,SUM,PMPRI,2+VARIABLE,YINFIX
	OLB ^\++\,,UPLUS,UPLUS,HIPRI,1
	CDM MIN$
	OLB ^\-\,,MINUS,DIFF,PMPRI,2,YINFIX
	OLB ^\--\,,UMINS,UMINS,HIPRI,1
	CDM DIV$
	OLB ^\/\,,SLSH,DIVDE,MDPRI,2,YINFIX
	CDM DOTS$
	OLB ^\:\,,DOTS,DOTS,HIPRI,1
	CDM LSS$
	OLB ^\<\,,LESS,LESS,RELPRI,2,YINFIX
	CDM EQL$
	OLB ^\=\,,EQUAL,EQUAL,RELPRI,2,YINFIX
	CDM GTR$
	OLB ^\>\,,GRTR,GREATR,RELPRI,2,YINFIX
	CDM BKSL$
	OLB ^/\/,,BKSL,MOD,MDPRI,2,YINFIX
	CDM BKAR$
	OLB ^/_/,,BKAR,MAKE,BAKPRI,2,YINFIX
	OLB ^/__/,,TBKAR,MMAKE,BAKPRI,2,YINFIX

	.IF1
.=.+<NUMOBS*6>
	.ENDC
	.IF2
.=OBADD2
	.ENDC
.STITL SYSTEM VARIABLES (ONE COPY PER SYSTEM)

DEBSW:	0	;DEBUG SWITCH, NON-ZERO IF BEING DEBUGGED
ERBASE:	0	;PLACE ON DISK WHERE ERRORS ARE STORED
	0
NOADDR:	1	;ZERO MEANS PRINT ADDRESS OF ERRORS
USER:	-1
.IIF NZ AI,	XORF:	0	;XOR USERS ON SWAP OUT
ULAST:	0	;LAST USER WHO WAS RUN
QUANT:	6	;UQUANT SET FRCM THIS
UQUANT:	0	;TIME IN 1/100THS USER SHOULD RUN
UTIME:	0
TUTIME:	0	;TOTAL USED TIME
	0
NRABLU:	0	;NUMBER OF USERS WITH FLSADR=0
NSWPU:	0	;NUMBER OF USERS ASSIGNED TO SLOTS BUT NOT YET IN
NINU:	0	;   "    "    "      "      "   "   AND ALREADY IN
PUSPSL:	-1	;PREFERED USER SLOT TO SWAP
PUSRSP:	0	;PREFERED USER TO SWAP OUT
SWPLEP:	SWPLST	;PLACE TOO PUT NEXT REQ
SWPLST:	.=.+<MNSLTS*2>+2	;LIST OF SWAP REQUESTS
MSWPOR:	.=.+<16*MNSLTS*2>	;MOBY SWAP IN AND OUT BLOCKS
SYSWPR:	.=.+<16*MNUSRS>	;10 DISK REQUEST BLOCKS FOR GENERAL USE
DSKCRB:	0	;CURRENT DISK REQUEST
DSKRUN:	DSKS	;THE DISK WHICH IS RUNNING
.IIF Z FXONLY,	MVDEAD:	0	;NOT 0 = MOVING HEAD DISK DECLARED DOWN
SLOTST:	REPT1 MNSLTS,-1
SLOTU:	REPT1 MNSLTS,-1
SLOTCA:	.BLKW MNSLTS
FOO==0
	.MACR MSWF
	MSWPOR+FOO
FOO==FOO+34
	.ENDM
SLOTRB:	REPT1 MNSLTS,MSWF
SLOTHA:	.BLKW MNSLTS
SLOTAR:	.BLKW MNSLTS
SLOTDR:	77406
	77406
	77406
ASDIS:	REPT1 NDISP,-1
DISAR:	.BLKW NDISP
DISDR:	.BLKW NDISP
DISMAL==40
DISBIG==100
DLENGT:	REPT1 NDISP-1,DISMAL	;5+1 MUST = NDISP (3 NOW FIT BEFORE RUG,
	REPT1 1,DISBIG	;		 (2 SMALL & 1 BIG AFTER)
PARREG:	.BLKW 21	;INITIALIZE TO ADDRESSES OF EXTANT PARITY REGISTERS
LOSSCT:	-4
WRTELC:	-1	;DISK WRITE LOCK SWITCH (ONE USER AT A TIME!)
NRKERS:	0	;NUMBER OF RK ERRORS
NRFERS:	0	;NUMBER OF RF ERRORS
DKRTYS:	0	;# OF DISK RETRYS
DKNRTY:	-10.
DKPWFR:	0
NDISPS:	NDISP
.IIF Z AI,NUSERS:	MNUSRS	;NUMBER OF USERS
.IIF NZ AI,NUSERS:	MNUSRS-3	;FOR DANNY
NSLOTS:	.IFNZ AI
	6
.IFF
	2
.ENDC
	;NUMBER OF IN CORE SLOTS
ASIZE:	0	;SIZE OF ARRAY SPACE (SHOULD BE ZERO)
ENDWLD:	0	;END OF THE WORLD (DON'T FALL OFF)
NUSER2:	2
USWCNT:	0	;NEGATIVE LENGTH OF USER SLOT
USLENT:	0	;LENGHT OF SLOT IN BYTES
USNSEC:	0	;NUMBER OF SECTORS FOR A SLOT
NDBLKS:	0
DBGRBD:	0	;GRABBED DISK BLOCK
DCLRUS:	0	;ADDRESS OF CLEAR USER IMAGE
	0
DSKRND:	0	;START OF RANDOM USER STORAGE
	0
TTYUGO:	-1
PWFPDL:	0
FOO==.
LOCKUS:	-1	;INDEX OF USER LOCKED IN CORE
NLOCKS==.-FOO/2
PBUF:	.=.+40
PBUFE:
PGRAB:	-1
PBFPTI:	0
PBFPTM:	0
NPCHRS:	0
	FOR NDISP
;DISPLAY SYSTEM VARIABLES
DPDLL==60	;LENGTH OF EACH DISPLAY PDL (IN BYTES)
TLEN==20	;LENGTH OF EACH TURTLE LIST (IN BYTES)
DSTAT:	REPT1	NDISP,-1	;CONTAINS -1 IF DISPLAY INACTIVE
;	OTHERWISE CONSOLE NUMBER SHIFTED OVER TO MUNG NGCSR
DCONS:		;USER DISPLAY CONSOLE TABLE
		;USER 1 GETS DISPLAY 0, USER 2 DISPLAY 1,ETC.
	.BYTE 377,377,0,2,4,377,377,6
	REPT1	<<MNUSRS-4>-NDISP>,.BYTE -1	;USERS WITHOUT DISLAYS
	.EVEN

DSIZES:		;WHAT SIZES THE ARGUMENTS TO STARTDISPLAY REFER TO
			;(IN BLOCKS)
	.BYTE	DISMAL
	.BYTE	DISBIG
	.EVEN
	.ENDC
	ENDC NDISP
TUT:	0	;TURTLE TOP.  POINTS TO TOP OF TURTLE DISPLAY LIST
SNPTEM:	0	;USED BY GARBAGE COLLECTOR

	ZEPT NPTBOX,<
	CONS PTBOX,\Z,:	-1
	.BLKW 4>

	CONSO==20
	PLOTT==40
	PMBOX==100
	INITF==1000	;MUSIC BOX INITIALIZED
	TURT==200
	TBMASK==177417

TEM0:	0
TEM1:	0
ANSWER:	.WORD	0,0	;USED BY DOUBLE PRECISION ROUTINES
SHFCNT:	0		;USED BY DOUBLE PRECISION ROUTINES
EXCH1:	0

.IFNZ NATG
;DAZZLE DART VARIABLES
.INSRT NATG;DAZVAR >
.ENDC



.VERR==-128.
.VRTS==-128.
GCMKL:	TOPS
	TOPS1
	TOPS2
	GCP1
	GCP2
	GCPREV
	MVOC
	MVOC+2
	MVOC+4
	MVOC+6
	ILINEL	;PTR TO TYPED INPUT LINE
	ERPROC	;PTR TO ERRSET PROC
	.IIF NZ NDISP, SNLIST
	0
.IIF NZ MVONLY,FIXFAK:	0
DSKFOO:	.=.+<2*FDSCSZ>
DBLDO:	0
DBLDWC:	0
DBLDCA:	0
DBLDDA:	0
DBLDDE:	0
	0
DBLDCM:	0
DBLPRO:	0
DBLPWC:	0
DBLPCA:	0
DBLPDA:	0
DBLPDE:	0
	0
DBLPCM:	0
DBLASV:	0
DBLFAK:	0

DKSDA:	0	;STORAGE OF WHAT DISK REGISTERS SHOULD BE
DKSCA:	1
DKSAE:	0
DKSCS:	0
DKEPR:	DSKS
	DKSCS
.IFZ MVONLY
	DSKWC
.IFF
	RKWC
.IFTF
	DKZERO
.IFT
	DSKCA
.IFF
	RKBA
.IFTF
	DKSCA
.IFT
	DSKA
.IFF
	RKDA
.IFTF
	DKSDA
.IFT
	DSKAE
	DKSAE
.ENDC
DKZERO:	0

DKWLST:	DSKS		;LOCS PRINTED ON HARD ERROR
	DSKAE
	DSKA
	0
RKWLST:	RKDS
	RKER
	RKCS
	RKDA
	0


PSWPWR:	PSWPAD
	DBGRBD
	DWRTEC

PSWPRD:	PSWPAD
	DBGRBD
	DREADC

SSWPWR:	SSWPAD
	DBGRBD
	DWRTEC

SSWPRD:	SSWPAD
	DBGRBD
	DREADC

SSAVWR:	SSWPAD
	SSAVEA
	DWRTEC

SSAVRD:	SSWPAD
	SSAVEA
	DREADC


SECRET:	TEXT ^/SECRET/

ISSIM:	0		;TO TRY SYSTEM ON SIMULATOR, SET TO -1

CLKQT:	CLKINF
CLKINF:	-1
	0
	CLKINE
N50THS:	CLKFRQ

DISTIM:	.BYTE	1
SECLIM:	.BYTE 60.
MINLIM:	.BYTE 60.
HORLIM:	.BYTE 24.
DAYLIM:	.BYTE 0
MONLIM:	.BYTE 12.
YERLIM:	.BYTE 177
RSEC:	.BYTE 0
RMIN:	.BYTE 0
RHOUR:	.BYTE 0
RDAY:	.BYTE 0
RMONTH:	.BYTE 0
RYEAR:	.BYTE 0
DMON:	.BYTE 30.,27.,30.,29.,30.,29.,30.,30.,29.,30.,29.,30.
	.EVEN

ITYI:	STYI
ITYO:	STYO	;THESE GET CLOBBERED TO JTYI, JTYO IN TINIT

SLASHX:	0	;SAVED CHAR FROM D WHEN ENTERING OR LEAVING
		;RUBOUT STRING
	.STITL GARBAGE COLLECTOR MARK-NODE TABLES

BMT:	.BYTE 1,2,4,10,20,40,100,200
LMT:	MARKV2	;SYSTEM FUNCTION
	MARKV2	;INFIX (SYSTEM FUNCTION)
	MKATOM	;USER FUNCTION
	MKATOM	;VARIABLE BINDING
	GCDIE	;IDLE NODE
	GCDIE	;UNUSED
	GCDIE	;BUCKET ELEMENT
	MARKV2	;SHORT STRING
	.IFNZ NDISP
	MKSNAP	;SNAP
	.ENDC
	.IFZ NDISP
	GCDIE
	.ENDC
	MKATOM	;ATOM
	MARKV2	;SHORT NUMBER
	MKINUM	;INTEGER NUMBEB
	MKLIST	;LONG STRING
.IFZ FPPF
	GCDIE	;TBA
.IFF
	MKINUM
.ENDC
	GCDIE	;UNUSED (WAS "SENTENCE" ONCE)
	MKLIST	;LIST
	.STITL NEW FILE TABLES
NBTTL==160.
.IIF NZ GUY,NDISKS==2
.IIF Z GUY,.IIF NZ SITSD,NDISKS==4
FDBITI:	-NDISKS
FDBITS:	.BLKW NBTTL*NDISKS
FDBITP:	REPT1 NDISKS,<2*.RPCNT*NBTTL+FDBITS>
FDDSKN:	REPT1 NDISKS,<20000*.RPCNT>
FDNAMP:	REPT1 NDISKS,<2*10.*.RPCNT+FDNAMS>
FDNAMS:	.BLKW NDISKS*10.
DDIRIA:	.BLKW NDISKS
FDUSEA:	.BLKW NDISKS
WDIRSW:	-1
NBLKFR:	.BLKW NDISKS
.IF Z SITSD
POTTAB:	POTHED
	POILNK
	POIFLE
	POTDIR
POITAB:	POIHED
	POILNK
	POIFLE
	POIDIR
.IFF
POTTAB:	POIPAR
	POTDIR
	POIFLE
	POILNK
	POTHED
	POILNK
	POILNK
	POILNK
POITAB:	POIPAR
	POIDIR
	POIFLE
	POILNK
	POIHED
	POILNK
	POILNK
	POILNK
.ENDC
GNBTAB:	GNBSKP
	GNBCNT
	GNBADR
	GNBSCN
DBITAD:	.BLKW NDISKS	;BLOCK NO. OF BIT TABLE
USRFIL:	.WORD "US,"ER,'S+200
BITS:	.BYTE 'B,'I,'T,200+'S
DIRID:	.BYTE 'D,'I,'R,'I,200+'D
.EVEN
	.STITL ERROR MACROS

	.MACRO ERMM AA
.IF2
	.IFG FOO-AA'.E
	.ERROR ERROR AA IN WRONG ORDER
	.ENDC
FOO==AA'.E
	AA'.E
.IFF
	0
.ENDC
AA==ERMNO
ERMNO==ERMNO+1
	.ENDM

	.MACRO JROT A
A'.R==A
	.ENDM

	.MACRO ERRM A
.=ROTTAB+<<A'.N-200>*2>
	A'.R
.ENDM

ERRNO==200
ERMNO==0
	.STITL ERROR TABLES

ROTTAB:	PNAB.R==PNODAB
	ERRM PNAB
	JROT PRLO
	ERRM PRLO
	JROT TYO
	ERRM TYO
	JROT PRCO
	ERRM PRCO
	JROT PRS1
	ERRM PRS1
	JROT PRCT
	ERRM PRCT
GDBY.R==GOODBY
	ERRM GDBY
	ERRM CTIT
	ERRM HNM
	ERRM LDE1
	ERRM PAE
PRAB.R=PROAB
	ERRM PRAB
	ERRM PNH1
	ERRM TMAP
	ERRM TDE
	ERRM BUG
	ERRM BRK
	ERRM WTA
	ERRM WTAA
	ERRM WTAB
	ERRM WTIB
.=ROTTAB+<MAXROT*2>
ERTAB:	FOO==BADD.E
	ERMM BADD	;BAD DIRECTORY
	ERMM BADE	;BAD ENTRY
	ERMM BAT	;BAD ARRAY TYPE
	ERMM BDD	;BAD DISK
	ERMM BRK	;BREAK!!
	ERMM BUG	;SYSTEM BUG!!
	ERMM CDE	;CAN'T DELETE ENTRY
	ERMM CDF	;CAN NOT DELETE THAT FILE
	ERMM COP	;CHAR (D) OUT OF PALCE
	ERMM CRE	;CAN'T READ THAT ENTRY
	ERMM CTIT	;CANT "TO" IN "TO"
	ERMM DFU	;DISC FULL
	ERMM DIU	;DEVIVE IN USE
	ERMM DNA	;INVALID DEVICE NAME
	ERMM DNR	;DEVICE NOT READY
	ERMM DOR	;DURATION OUT OF RANGE
	ERMM DRF	;DIRECTORY FULL
	ERMM EAES	;ENTRY ALREADY EXISTS
	ERMM ELW	;EDIT LINE WHAT?
	ERMM ENDR	;ENTRY NOT DIRECTORY
	ERMM ERP	;EXTRA RIGHT PAREN
	ERMM ERW	;ERASE WHAT??
	ERMM FAE	;FILE ALREADY EXISTS
	ERMM FAO	;FILE ALREADY OPEN
	ERMM FBUG	;FATAL SYSTEM BUG
	ERMM FNF	;FILE NOT FOUND
	ERMM HARD	;HARDWARE ERROR
	ERMM HNM	;.(B). HAS NO MEANING
	ERMM HNM1	;..CT.. HAS NO MEANING
	ERMM HNV	;.(CT). HAS NO VALUE
	ERMM IDN	;INVALID DISPLAY NUMBER (UGH!)
	ERMM IFN	;A,,B IS INVALID FILE NAME
	ERMM INF1	;INFIX IN THE WRONG PLACE
	ERMM INVN	;INVALID NODE
	ERMM ITN	;INVALID TURTLE NUMBER
	ERMM IUN	;INVALID USER NAME
	ERMM IVV	;INVALID VOICE NUMBER
	ERMM LCE	;LINE ... CHANGED BY EDIT
	ERMM LDE	;LINE ..(B).. DOESN'T EXIST
	ERMM LNTB	;LINE # TOO BIG
	ERMM LNTS	;LINE # TOO SMALL
	ERMM NAS	;NO ARRAY STORAGE
	ERMM NDU	;NOT A DISPLAY USER
	ERMM NDV	;NO DISPLAY AVAILABLE
	ERMM NEC	;NOT AN EDITING COMMAND
	ERMM NED	;NON EXISTENT DIRECTORY
	ERMM NFO	;NO FILE OPEN
	ERMM NIP	;NOTHING INSIDE PARENS
	ERMM NOG	;NOTE OUT OF RANGE
	ERMM NOU	;NO OUTPUT
	ERMM NSL	;NO STORAGE LEFT
	ERMM NTB	;NO THORTON BOX SLOTS AVAILABLE
	ERMM NTF	;(S) NOT "TRUE" OR "FALSE"
	ERMM OIP	;ONLY IN PROCEDURE
	ERMM OGT	;ONLY ON 2500'S
	ERMM OOB	;OUT OF BOUNDS
	ERMM OOP	;(CO) OUT OF PLACE
	ERMM OOT	;OUT OF TOKENS
	ERMM PAE	;PROCEDURE (TEMP) ALREADY EXIXTS
	ERMM PBE	;PROCEDURE IS BEING EDITED
	ERMM PNH	;PROCEDURE .(CT). NOT HERE
	ERMM PNH1	;PROCEDURE .(CPP). NOT HERE
	ERMM ROB	;INDEX REFERENCE OUT OF BOUNDS
	ERMM RTB	;RESULT TOO BIG
	ERMM SHW	;SHOW WHAT??
	ERMM STD	;SNAP TOO DEEP
	ERMM TDE	;TTY ..(E/2).. DOESN'T  EXIST
	ERMM TGDZ	;TURTLE GETTING DIZZY
	ERMM TIP	;TOO MUCH INSIDE PARENS
	ERMM TMAC	;TOO MANY ARGS (CURRENT PROC)
	ERMM TMAP	;TOO MANY ARGS (PROC BEING TO'ED)
	ERMM TML	;TOO MANY LINES
	ERMM TNR	;TURTLE NOT RESPONDING
	ERMM UBL	;USED BY LOGO
	ERMM UDA	;UNDEFINED ARRAY
	ERMM UEL	;UNEXPECTED END OF LINE
	ERMM UELX	;...(CO) NEEDS ARGS
	ERMM VTD	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE OR A DISPLAY
	ERMM VTU	;..(CO).. ONLY VALID IF YOU HAVE A TURTLE
	ERMM WDIM	;BAD DIMENSIONS
	ERMM WDW	;YOU DON'T SAY WHAT TO DO WITH...
	ERMM WIT	;(CT) IS WRONG INPUT TO "TO"
	ERMM WNA	;WRONG NUMBER OF ARGUMENTS TO ..(CO)
	ERMM WTA	;..(CO)..DOESN'T LIKE..(CT)..AS INPUT
	ERMM WTAA	;..(CO)..DOESN'T LIKE..(A)...AS INPUT
	ERMM WTAB	;..(CO)..DOESN'T LIKE..(B)...AS INPUT
	ERMM WTIB	;..(CO)..DOESN'T LIKE..NUMBER IN B...AS INPUT
ERTEND:	ERREND
	.STITL OTHER TABLES

;THE DISPATCH TABLE FOR CONVERT

CNVTBL:
	.BYTE CNVNOP	;SNAP TO SNAP
REPT1 7,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE 0	;ATOM TO SNUM
	.BYTE 0	;ATOM TO INUM
	.BYTE CA2LS	;ATOM TO LSTR
REPT1 3,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;SNUM TO SNUM
	.BYTE CSN2IN	;SNUM TO INUM
	.BYTE CSN2LS	;SNUM TO LSTR
.IIF NZ FPPF,	.BYTE CSN2FN	;SNUM TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CIN2SN	;INUM TO SNUM
	.BYTE CNVNOP	;INUM TO INUM
	.BYTE CIN2LS	;INUM TO LSTR
.IIF NZ FPPF,	.BYTE CIN2FN	;INUM TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CLS2SN	;LSTR TO SNUM
	.BYTE CLS2IN	;LSTR TO INUM
	.BYTE CNVNOP	;LSTR TO LSTR
.IIF NZ FPPF,	.BYTE CLS2FN	;LSTR TO FNUM
.IIF Z FPPF,	.BYTE 0
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME

.IFNZ FPPF

REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME (RNUM TO ANYTHING)
	.BYTE CFN2SN	;FNUM TO SNUM
	.BYTE CFN2IN	;FNUM TO INUM
	.BYTE CFN2LS	;FNUM TO LSTR
	.BYTE CNVNOP	;FNUM TO FNUM
REPT1 2,^\.BYTE 0\	;NOT USED AT THIS TIME


.IFF

REPT1 8.,^\.BYTE 0\


.ENDC

REPT1 6,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;SENT TO SENT
REPT1 1,^\.BYTE 0\	;NOT USED AT THIS TIME

REPT1 7,^\.BYTE 0\	;NOT USED AT THIS TIME
	.BYTE CNVNOP	;LIST TO LIST

.IIF NZ .-CNVTBL-100,.PRINT /CONVERT TAB SCREWED UP!/
	.EVEN

;THE LIST OF VALID TYPES

CKLIST:	.IIF NZ FPPF,FNUM
	.IIF NZ NDISP,SNAP ;CRACKLE,POP
	LSTR
	LNUM
	LIST
	ATOM
.IIF NZ FPPF,	FNUM
	0
		;MUSIC BOX CHARACTERS

	MBTRAP==43	;TRAP CHARACTER
	MBFCH==100	;SHUT-UP CHARACTER
	MBREST==40	;REST CHARACTER FOR MUSIC BOX
	MBPERC==42	;HIGHEST CODED PERCUSSION EFFECT

MBVCH:	.BYTE	123,42,61,60	;CTL CHARACTERS FOR NUMBER OF VOICES
MBSCH:	.BYTE	103,102,101,100	;LIKE MBVCH, EXCEPT SPECIFIES SILENCE


STURF:	.BYTE 101.,34.,68.,19.	;TURTLE FUDGE FACTORS FOR LEFT AND RIGHT
;	MULTIPLY BY EVEN BYTE AND DIVIDE BY ODD BYTE
.IFZ FPPF

;BEAUTIFUL SINE TABLE IN WHOOPIE FORMAT


SIN:

	0	;0 DEGREES
	2167	;2 DEGREES
	4355	;4 DEGREES
	6541	;6 DEGREES
	10720	;8 DEGREES
	13072	;10 DEGREES
	15234	;12 DEGREES
	17367	;14 DEGREES
	21510	;16 DEGREES
	23615	;18 DEGREES
	25707	;20 DEGREES
	27763	;22 DEGREES
	32017	;24 DEGREES
	34034	;26 DEGREES
	36027	;28 DEGREES
	40000	;30 DEGREES
	41724	;32 DEGREES
	43623	;34 DEGREES
	45474	;36 DEGREES
	47315	;38 DEGREES
	51106	;40 DEGREES
	52646	;42 DEGREES
	54352	;44 DEGREES
	56023	;46 DEGREES
	57437	;48 DEGREES
	61015	;50 DEGREES
	62335	;52 DEGREES
	63615	;54 DEGREES
	65035	;56 DEGREES
	66214	;58 DEGREES
	67331	;60 DEGREES
	70404	;62 DEGREES
	71413	;64 DEGREES
	72357	;66 DEGREES
	73255	;68 DEGREES
	74107	;70 DEGREES
	74674	;72 DEGREES
	75412	;74 DEGREES
	76062	;76 DEGREES
	76463	;78 DEGREES
	77016	;80 DEGREES
	77301	;82 DEGREES
	77514	;84 DEGREES
	77660	;86 DEGREES
	77754	;88 DEGREES
	77777	;90 DEGREES
.ENDC

;PRINTOUT DISPATCH TABLE
.MACRO DT A,B
$'A
B
.ENDM
PODISP:	DT INDEX,.POI
	DT PROCED,SHALPR
.IFNZ ENG
	DT ALL,SHOWAL
	DT FILE,.POFILE
	DT TITLE,POT
	DT LINE,POL
	DT ARRAY,PO1AR
	DT ARAYS,POARR
	DT NAMES,SHALNA
	DT TREE,.POTREE
.ENDC
.IFNZ FR
	DT TOUT,SHOWAL
	DT FICHIER,.POFILE
	DT TITRE,POT
	DT TITRS,POTS
	DT LIGNE,POL
	DT MATRICE,PO1AR
	DT MATRS,POARR
	DT NOMS,SHALNA
	DT ARBRE,.POTREE
.ENDC
	0

;ERASE DISPATCH TABLE
ERSDISP:	DT TRACE,ETRACE
	DT INDEX,ERINDX
	DT PROCE,ERALPR
.IFNZ ENG
	DT ALL,ERALL
	DT .STEP,ESTEP
	DT BURY,EBURY
	DT FILE,ERFI
	DT LINE,ERLINE
	DT NAMES,ERALNA
	DT NAME,ERNAME
	DT ARRAY,ERARAY
	DT ARAYS,ERARAS
.ENDC
.IFNZ FR
	DT TOUT,ERALL
	DT PASAPAS,ESTEP
	DT ENFOUI,EBURY
	DT FICHIER,ERFI
	DT LIGNE,ERLINE
	DT NOMS,ERALNA
	DT NOM,ERNAME
	DT MATRICE,ERARAY
	DT MATRS,ERARAS
.ENDC
	0
;DISPLAY DIRECTION CODES

DREC:	.BYTE 10
	.BYTE 0
	.BYTE 20
	.BYTE 30
	.BYTE 60
	.BYTE 70
	.BYTE 50
	.BYTE 40
	.EVEN
	.STITL SYSTEM VARIABLES (ONE COPY PER USER)

UBLK=.
UNAME:	.BLKW 5
TIMUSD:	0	
LSTIM:	0	;LAST TIME USER RAN
	0
JMTU:	0
SLOTAS:	0	;INDEX OF ASSIGNED SLOT OR -1
DISAS:	0
FLSRES:	0	;REASON USER NOT RUNNING
FLSADR:	0	;ADDRESS TO START AT AFTER FLUSH
GUNSW:	0
UACA:	0
UACB:	0
UACC:	0
UACD:	0
UACE:	0
.IIF NZ AI,	XORUSR:	0
UPC:	0	;PROGRAM COUNTER
UTTY:	0
BRAKE:	0
;DO NOT CHANGE THE ORDER BELOW
USWPAD:	.=.+4	;BEGINNING OF SWAP AREA
UDBFSV:	.=.+4	;PALCE TO SAVE THE DISK BUFFERS DURING GC
UDSKAD:	0	;RANDOM DISK STORAGE AREA
UASIZE:	0	;USER ARRAY SIZE

LUBLK==.-UBLK
L==LUBLK

	.=.+<MNUSRS*LUBLK>
SYSIDX==MNUSRS*LUBLK
	.STITL SYSTEM DISPATCH TABLE (BYTE ONE)

;FLAG DEFINITIONS
FSF==200	;SPECIAL INPUT
FOF==100	;SPECIAL OUTPUT
FQF==20		;QUOTING
SEPF==4		;SEPARATOR
WSF==2		;WORD SEPARATOR
NNUMF==40	;NOT A NUMBER
OPERF==10	;OPERATOR

DTBL:
.BYTE	NNUMF,FOF!NNUMF		;^@	;^A ECHOES AS CR
.BYTE	FSF!NNUMF,FSF!NNUMF	;^B IS CONVERTED TO %
				;^C COPIES NEXT CHARACTER
.BYTE	FSF!NNUMF,NNUMF		;^D DELETES NEXT CHARACTER	;^E
.BYTE	NNUMF,FSF!FOF!NNUMF	;^F	;^G BREAK
.BYTE	FOF!NNUMF,FOF!SEPF!WSF!NNUMF	;^H BACKSPACE	;^I TABULATE
.BYTE	FOF!SEPF!WSF!NNUMF,FOF!SEPF!WSF!NNUMF	;^J LINE FEED
				;^K
.BYTE	FOF!SEPF!WSF!NNUMF,FSF!FOF!SEPF!WSF!NNUMF	;^L FORM FEED
				;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	FSF!NNUMF,NNUMF		;^N GET NEXT WORD	;^O
.BYTE	NNUMF,FSF!NNUMF		;^P	;^Q SUPER-QUOTE
.BYTE	FSF!NNUMF,FSF!NNUMF	;^R COPY REST OF LINE
				;^S SKIP NEXT WORD
.BYTE	NNUMF,NNUMF		;^T	;^U
.BYTE	NNUMF,FSF!NNUMF		;^V	;^W ERASE LAST WORD
.BYTE	FSF!NNUMF,FSF!NNUMF	;^X CLARIFY INPUT
				;^Y EDIT PREVIOUS LINE
.BYTE	FSF!NNUMF,NNUMF		;^Z DESTROY INPUT BUFFER
				;^[ MAYBE ALTMODE
.BYTE	NNUMF,NNUMF		;^\	;^]
.BYTE	NNUMF,NNUMF		;^^	;^_ ANY BETTER IDEAS FOR THEM?
.BYTE	SEPF!WSF!NNUMF,NNUMF!SEPF!OPERF	;SP	;! COMMENT?
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;"	;# ACTION OF
.BYTE	NNUMF,NNUMF		;$	;% PRINTS AS SPACE IN STRINGS
.BYTE	NNUMF,NNUMF!OPERF	;&	;' (MAYBE LE)
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;( ARITHMETIC GROUPING
				;) DITTO
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;* MULTIPLY	;+ ADD
.BYTE	NNUMF,SEPF!NNUMF!OPERF	;,	;- SUBTRACT
.IIF NZ FPPF, .BYTE	0,SEPF!NNUMF!OPERF
.IIF Z FPPF, .BYTE	NNUMF,SEPF!NNUMF!OPERF	;.	;/ DIVIDE
.BYTE	0,0	;0	;1
.BYTE	0,0	;2	;3
.BYTE	0,0	;4	;5
.BYTE	0,0	;6	;7
.BYTE	0,0	;8.	;9.
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF	;: THING OF	;; 
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;<	;=
.BYTE	SEPF!NNUMF!OPERF,NNUMF	;>	;?
.BYTE	NNUMF,NNUMF		;@	;A
.BYTE	NNUMF,NNUMF		;B	;C
.IIF NZ FPPF,	.BYTE	NNUMF,0
.IIF Z FPPF, .BYTE	NNUMF,NNUMF		;D	;E
.BYTE	NNUMF,NNUMF		;F	;G
.BYTE	NNUMF,NNUMF		;H	;I
.BYTE	NNUMF,NNUMF		;J	;K
.BYTE	NNUMF,NNUMF		;L	;M
.IIF NZ FPPF,	.BYTE	0,NNUMF
.IIF Z FPPF,	.BYTE	NNUMF,NNUMF		;N	;O
.BYTE	NNUMF,NNUMF		;P	;Q
.BYTE	NNUMF,NNUMF		;R	;S
.BYTE	NNUMF,NNUMF		;T	;U
.BYTE	NNUMF,NNUMF		;V	;W
.BYTE	NNUMF,NNUMF		;X	;Y
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF	;Z	;[
.BYTE	SEPF!NNUMF!OPERF,FSF!FQF!SEPF!WSF!NNUMF	;\ MODULO	;]
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;^	
				;_ MAKE
.BYTE	NNUMF,NNUMF		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	NNUMF,NNUMF		;b LOWER CASE	;c LOWER CASE
.BYTE	NNUMF,NNUMF		;d LOWER CASE	;e LOWER CASE
.BYTE	NNUMF,NNUMF		;f LOWER CASE	;g LOWER CASE
.BYTE	NNUMF,NNUMF		;h LOWER CASE	;i LOWER CASE
.BYTE	NNUMF,NNUMF		;j LOWER CASE	;k LOWER CASE
.BYTE	NNUMF,NNUMF		;l LOWER CASE	;m LOWER CASE
.BYTE	NNUMF,NNUMF		;n LOWER CASE	;o LOWER CASE
.BYTE	NNUMF,NNUMF		;p LOWER CASE	;q LOWER CASE
.BYTE	NNUMF,NNUMF		;r LOWER CASE	;s LOWER CASE
.BYTE	NNUMF,NNUMF		;t LOWER CASE	;u LOWER CASE
.BYTE	NNUMF,NNUMF		;v LOWER CASE	;w LOWER CASE
.BYTE	NNUMF,NNUMF		;x LOWER CASE	;y LOWER CASE
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF		;Z LOWER CASE	;LEFT BRACE
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF		;VERTICAL BAR	;RIGHT BRACE
.BYTE	NNUMF,FSF!NNUMF		;TILDE	;RUBOUT
	.STITLE SYSTEM DISPATCH TABLE (BYTE TWO)
;NUMBERS POINT TO OTHER TABLES
;$ POINTS TO SYSTEM OBLIST

DTBL2:
.BYTE	0,0		;^@ 			;^A
.BYTE	36,0		;^B BECOMES %, PRINTS AS SPACE IN STRINGS
			;^C COPY NEXT CHARACTER
.BYTE 2,0		;^D DELETES NEXT CHAR	;^E
.BYTE	0,4		;^F 			;^G BREAK
.BYTE	2,10		;^H BACKSPACE		;^I TABULATE
.BYTE	12,14		;^J LINE FEED		;^K 
.BYTE	16,6		;^L FORM FEED
			;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	10,0		;^N GET NEXT WORD		;^O
.BYTE	0,12		;^P 			;^Q SUPER-QUOTE
.BYTE	14,16		;^R 			;^S SKIP NEXT WORD
.BYTE	0,0		;^T	;^U
.BYTE	0,20		;^V	;^W ERASE LAST WORD
.BYTE	22,24		;^X CLARIFY INPUT	;^Y
.BYTE	26,0		;^Z DESTROY INPUT BUFFER
			;^[ MAYBE ALTMODE
.BYTE	0,0		;^\	;^]
.BYTE	0,0		;^^	;^_ WELL, ANY BETTER IDEAS FOR THEM?
.BYTE	0,EXCL$		;SP	;! COMMENT?
.BYTE	0,HASH$		;"	;# ACTION OF
.BYTE	0,0		;$	;% PRINTS AS SPACE IN STRINGS
.BYTE	0,0		;&	;' (MAYBE LE)
.BYTE	LP$,RP$		;( ARITHMETIC GROUPING	;) DITTO
.BYTE	PRD$,PLU$	;* MULTIPLY	;+ ADD
.BYTE	0,MIN$		;,	;- SUBTRACT
.BYTE	0,DIV$		;.	;/ DIVIDE
.BYTE	0,0		;0	;1
.BYTE	0,0		;2	;3
.BYTE	0,0		;4	;5
.BYTE	0,0		;6	;7
.BYTE	0,0		;8.	;9.
.BYTE	DOTS$,0		;: THING OF	;; 
.BYTE	LSS$,EQL$	;<	;=
.BYTE	GTR$,0		;>	;?
.BYTE	0,0		;@	;A
.BYTE	0,0		;B	;C
.BYTE	0,0		;D	;E
.BYTE	0,0		;F	;G
.BYTE	0,0		;H	;I
.BYTE	0,0		;J	;K
.BYTE	0,0		;L	;M
.BYTE	0,0		;N	;O
.BYTE	0,0		;P	;Q
.BYTE	0,0		;R	;S
.BYTE	0,0		;T	;U
.BYTE	0,0		;V	;W
.BYTE	0,0		;X	;Y
.BYTE	0,32		;Z	;[
.BYTE	BKSL$,34	;\ MODULO	;]
.BYTE	0,BKAR$		;^ 		;_ MAKE
.BYTE	0,0		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	0,0		;b LOWER CASE	;c LOWER CASE
.BYTE	0,0		;d LOWER CASE	;e LOWER CASE
.BYTE	0,0		;f LOWER CASE	;g LOWER CASE
.BYTE	0,0		;h LOWER CASE	;i LOWER CASE
.BYTE	0,0		;j LOWER CASE	;k LOWER CASE
.BYTE	0,0		;l LOWER CASE	;m LOWER CASE
.BYTE	0,0		;n LOWER CASE	;o LOWER CASE
.BYTE	0,0		;p LOWER CASE	;q LOWER CASE
.BYTE	0,0		;r LOWER CASE	;s LOWER CASE
.BYTE	0,0		;t LOWER CASE	;u LOWER CASE
.BYTE	0,0		;v LOWER CASE	;w LOWER CASE
.BYTE	0,0		;x LOWER CASE	;y LOWER CASE
.BYTE	0,32		;z LOWER CASE	;{ OPEN BRACE
.BYTE	0,34		;| VERTICAL BAR
			;} CLOSE BRACE
.BYTE	0,30		;~ TILDE	;RBO	RUBOUT

.IFNZ LPF
LPBUF1:	.BLKW 512.
LPBUF2:	.BLKW 512.
MNLPB==40.
BKTBL:	.BLKW MNLPB
LPFLG:	0
FLGTH:	0
LSTBKL:	0
BKSTGO:	0
LPBUFF:	0
PUTLPB:	0
NOWLPR:	0
LPIUFG==4
LPB1FG==1
LPB2FG==2
LPB1MX==0
LPB2MX==0
.ENDC
.STITL TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI TYI

;TO DO:
;FIX INTERRUPT MACROS
;HARDWARE INITIALIZATION
;MODEM AND ERROR CODE
;SYSTEM CODE
;MULTIPLE DM
;PGEN1
;DING

	VERN==VERN+%FNAM2

NMODEM==1
.STITL TELETYPE MACROS

.MACR TBK
	.BLKW	NLTY
.ENDM
.STITL TELETYPE DISPATCH TABLES--DATA SPACE

;ALL FOLLOWING CODE CAN BE IN DATA SPACE ONLY!!!!!!!!!!


;DISPATCH TABLE FOR SPECIAL INPUT CHARS WITH EFFECT ON TYPEOUT LEVEL
TIICTB:	TOICC	;^C COPY NXT CHAR FROM EDIT TO TYI BUFFER
	TOICD	;^D DELETE NEXT CHAR FROM EDIT BUFFER
	TICG
	TOICM	;^M POSSIBLE END OF LINE
	TOICN	;^N COPY NEXT WD FROM EDIT TO TYI BUFFER
	TOICQ	;^Q JUST ECHO
	TOICR	;^R COPY REST OF EDIT BUFFER TO TYI BUF
	TOICS	;^S SKIP NXT WD IN ED. BUF.
	TOICW	;^W RUB OUT UP TO PREVIOUS WD SEPERATOR
	TOICX	;^X CLARIFY INPUT
	TOICY	;^Y RECOVER PREVIOUS LINE
	TICZ
	TOIRB	;RUBOUT
	TOIOB	;[ INCREMENT LIST COUNT
	TOICB	;] DECREMENT LIST COUNT
	TICB


;DISPATCH TABLE FOR CHARS SPECIAL ON OUTPUT
;(HAVE FOF ON IN DTBL(CHARACTER)
TOOCTB:	TOOCA	;^A PRINTS AS C.R.
	TOOCH	;^H BACKSPACE, DECREMENTS CHARNO
	TOTYOC	;^G PRINTS AS SELF
	TOOCM	;^M PRINTS AS CR, LF
	TOOCI	;^I (TAB) SPACES TO NEXT TAB STOP
	TOTYOC	;^J (LINEFEED) PRINTS AS SELF
	TOTYOC	;^K (VERTICAL TAB) PRINTS AS SELF
	TOTYOC	;^L (FORMFEED) PRINTS AS SELF
.IFNZ NTVS
LKBTAB:
.BYTE 0,'+,4,'(
.BYTE '),0,0,0
.BYTE 0,33,11,14
.BYTE 0,15,0,0
.BYTE '-,0,0,0
.BYTE 0,0,0,'/
.BYTE '*,177,0,'_
.BYTE 7,0,0,0
.BYTE 40,'1,';,'3
.BYTE '4,'5,'7,':
.BYTE '9,'0,'8,'<
.BYTE ',,'=,'.,'?
.BYTE '0,'1,'2,'3
.BYTE '4,'5,'6,'7
.BYTE '8,'9,'','"
.BYTE ',,'<,'.,'!
.BYTE '2,'A,'B,'C
.BYTE 'D,'E,'F,'G
.BYTE 'H,'I,'J,'K
.BYTE 'L,'M,'N,'O
.BYTE 'P,'Q,'R,'S
.BYTE 'T,'U,'V,'W
.BYTE 'X,'Y,'Z,'[
.BYTE '],'[,'6,'=
.BYTE '>,'a,'b,'c
.BYTE 'd,'e,'f,'g
.BYTE 'h,'i,'j,'k
.BYTE 'l,'m,'n,'o
.BYTE 'p,'q,'r,'s
.BYTE 't,'u,'v,'w
.BYTE 'x,'y,'z,'%
.BYTE '],'$,'>,0
.ENDC
.STITL TELETYPE VARIABLES

NLTY==NTTY+<5*NTBOX>	;TBOX +4 DEVICES
NMXTY==NTBOX
NPORTS==NLTY+<20*NDM>-NDMTY	;DON'T DUPLICATE DM11 TTYS

;STANDARD DEVICE REGISTER BITS
%ER==1_15	;ERROR
%RDY==1_7	;READY
%INT==1_6	;INTERRUPT ENABLE
%CRDT==1_2	;CARRIER DETECT
%ENB==1		;ENABLE
%DTRDY==1	;DATA TERMINAL READY

TBKCH:	7	;^G BREAK TO LEVEL 0
TBKCHL:	32	;^Z BREAK TO LEVEL N
LINEL:	ZEPT NLTY,70.	;LINE LENGTH

OMXRES=.-NFTBOX
	OMXNUL==OMXRES+1	;RH--RESET CHAR, LH--NULL CHAR
	.BYTE 21,0	;TBOX (DC0)
	.BYTE 0,40	;TURT 1
	.BYTE 0,40	;TU 2
	0	;MBX
	.BYTE 0,21	;DUMMY

TUDN:	ZEPT NTUR,NFTUR+<2*.RPCNT>

	.IFNZ NPLOT
.IIF NZ AI,	PLTDVN=NFTUR+2	;THIS HACK UNTIL WE HOOK 2 CONTROLLERS TO THE SYSTEM
.IIF NZ GUY,	PLTDVN=NFTUR+6	;THIS HACK UNTIL WE HOOK 2 CONTROLLERS TO THE SYSTEM

	.ENDC
.IFNZ NTVS
TVSCJT:	.WORD 0,0,0,0,0,0,0,0
	.WORD 0,0,TVLF,TVSPDN,0,TVCR,0,0
	.WORD 0,0,0,0,0,0,0,0
	.WORD TVSPF,TVSPB,TVSPU,0,0,0,TVCEOL,TVSPBE
UBR:	0	;IF YOU WANT THE UBR RESTORED YOU BETTER PUT IT HERE
TVKBS:	ZEPT NTVCHN,-1
TVUSE:	ZEPT NTVS,-1
TVLOGO:	ZEPT NTVCHN,3*60.
TVCJTB:	.IRPC X,<01234567>
	CHAR'X
	.ENDM
FONTAR:	0
FONTDR:	77406
TVCRM1:	176000
	1760
	17
	37400
	374
	3
	7700
	77
TVCRM2:	0
	0
	140000
	0
	0
	170000
	0
	0
TVEOLM:	-1
	1777
	17
	37777
	377
	3
	7777
	77
TVSPFK:	2
	0
	0
	2
	0
	2
	0
	0

.ENDC

;USE TELETYPE TABLE--LOGICAL TTY FOR EACH USER
UTYTB:	ZEPT NTY,NFTY
	ZEPT NTVS,NFTV+<2*.RPCNT>
	ZEPT MNUSRS-NTVS-NTY,NFDMTY+<2*.RPCNT>

.IFZ CJR

TYRS:	;RECEIVE VECTORS FOR EACH TTY
	TKS	;CONSOLE TTY
	DC1RS	;DC1
.IIF Z DHON,	ZEPT 20,DM0CSR	;DM11 TTYS
.IIF NZ DHON,	ZEPT 20,DH0SCR
	ZEPT NTVS,0
 	DC0RS	;DC0
	ZEPT 4*NMXTY,-1	;PSEUDO TTYS

TYPTYP:		;PHYSCIAL TTY TYPE
	TPMODM==100000	;MODEM
	TPMPX==40000	;MULTIPLEXOR
	TPPTY==20000	;PSEUDO TTY OR MULTIPLEXEE
	TPDM==10000	;DM11 TTY
	TPTV==4000	;TV TTY
		;RH=CPS/10.
.IIF NZ AI,	3		;CONSOLE TTY
.IIF NZ GUY,	1
	3		;DC1, MODEM
	ZEPT 20,TPDM!3	;DM11S
	ZEPT NTVS,TPTV	;TVS KEYBOARDS
	TPMPX!12	;DC0, THORTON BOX
	TPPTY!3		;TURTLE 1
	TPPTY!3		;TURTLE 2
	TPPTY!3		;MUSIC BOX
	TPPTY!3		;DUMMY

TILTTY:		;RH--LOGICAL TTY # OF EACH PHYSICAL TTY
		;-1 IF ILLOGICAL
		;LH--MPXR #, -1 IF NOT MPXED
	ZEPT NTY+NKLTY+NDCTY+NDPTY+NDMTY,<
	.BYTE 2*.RPCNT,-1		;CONS, DCS, KLS AND DM11 TTYS
	>
	ZEPT 20-NDMTY,-1	;REST OF DMS
	ZEPT NTVS,<
	.BYTE NFTV+<2*.RPCNT>,-1
>
	ZEPT NTBOX,<		;THORTON BOXES
	.BYTE NFTBOX+<2*.RPCNT>,-1
	>
	ZEPT 4*NTBOX,<			;LOGICAL DEVICES
	.BYTE NFTUR+<2*.RPCNT>,NFTBOX+<2*<.RPCNT_-2>>
	>

.IFF

PDMAP:	;LOGICAL TTY # OR MPXR OF EACH PHYSICAL DEVICE
	;-1 IF UNASSIGNED

	0	;CONSOLE
	2	;DC
	0	;DC--MPXR 0
	ZEPT NDMTY,4+<2*.RPCNT>	;DM'S
	ZEPT <20*NDM>-NDMTY,-1	;UNUSED DM'S

LDMAP:	;PHYSICAL TTY OR MPXR OF EACH LOGICAL DEVICE OR MPXR

	0	;CONSOLE
	2	;DC
	ZEPT NLTY-2,6+<2*.RPCNT>
	ZEPT 4,NFTBOX	;MPXR 0
	4	;MPXR PHYSICAL DEVICE

PDWORD:	;FOR EACH PHYSICAL TTY

	TPMPX==100000	;MPXR
	TPCON==40000	;CONSOLE
	TPDC==20000î	;DC
	TPKL==10000	;KL
	TPDM==4000	;DM

	TPCON
	TPDC
	TPMPX!TPDC
	ZEPT <20*NDM>,TPDM	;DM'S

LDWORD:
MPWORD:	;FOR EACH LOGICAL DEVICE OR MPXR
	;TPMPX SET UP ABOVE

	TPPTY==40000	;MULTIPLEXEE
	ZEPT NTTY,TPPTY
	ZEPT NTUR,TPPTY
	ZEPT NMBX,TPPTY
	ZEPT NPLOT,TPPTY
	;MULTIPLEXORS
	ZEPT NTBOX,TPMPX

PDRS:	;ADDRESS OF RECEIVE STATUS REGISTER FOR PHYS DEV

	TKS	;CONSOLE
	DC1RS
	DC0RS
.IIF Z DHON,	ZEPT 20,DM0CSR	;DM
.IIF NZ DHON,	ZEPT 20,DH0SCR

.ENDC

TYCKBP:	ZEPT NLTY,TYCKBK+<.RPCNT*10>	;PNTRS TO CLOCK BLOCK
TYCKBK:	ZEPT NLTY,<
	.BLKW 3	;CLOCK BLOCK	(3 WDS FOR EACH MODEM)
	2*.RPCNT	;TTY INDEX (FOR CLOCK LEVEL STUFF)
>


;LOGICAL DEVICE NAME ARRAY
;YOU CAN CALL TYO WITH ONE OF THESE  NAMES
LDEVAR:
	$$TTY
	-1
	$$MUSIC
	MBDN
	$$TUR1
	NFTUR
	$$TUR2
.IFZ GUY
	1	;HOWEVER, WE HAVE A PLOTTER PLUGGED IN NOW
.IFF
	NFTUR+2
.IFT
	$$LIGHT
	NFTUR+6
.ENDC
	$$PLOT
	PLTDVN
	0

;POINTED TO BY LOGICAL DEVICE NAME ARRAY
$$TTY:	TEXT ^/TTY/
$$MUSIC:	TEXT ^/MUSIC/
$$TUR1:	TEXT ^/TUR1/
$$TUR2:	TEXT ^/TUR2/
$$LIGHT:	TEXT ^/LIGHT/
$$PLOT:	TEXT ^/PLOTTER/

TTYU:	TURUSE==.+NFTUR
	ZEPT NLTY,-1	;USER FOR EACH TTY
TIPTTY:	TBK	;FROM TILTTY
MXNUM==TIPTTY+1	;MXPR NUM LH, -1 IF NOT MPXED
TTYTP:	TBK	;TTY TYPE
OTTYST:	.BLKW NLTY
TTYST:	ZEPT NLTY,TIMAGE!TIMAGI	;TTY STATUS
	TICLKQ==100000	;ENTRY ON CLKQ
	TILIPM==40000	;LINE INPUT MODE
	TICVM==20000	;CONVERT CASE MODE
	TIECM==10000	;ECHO MODE (INPUT)
	TIEDM==4000	;EDIT MODE
	TIRBM==2000	;RUBOUT MODE
	TIMAGE==1000	;IMAGE MODE (OUTPUT)
	TIMAGI==400	;INPUT IMAGE MODE
	TOTRAN==200	;CURRENTLY TRANSMITTING
	TIQF==100	;QUOTE NEXT CHAR
	TIBR==40	;BREAK TYPED BUT NOT PROCESSED BY USER
	TIRST==20	;RESET INPUT ON INTERRUPT LEVEL
	PTBF==4
.IIF NZ DPHK,	DPF==10

TIRCV:	ZEPT NLTY,TYRCV	;ADDRESS TO JSR TO WITH RECEIVED CHARACTER

.IIF NZ AI,	TIQSZ==400.
.IIF NZ GUY,	TIQSZ==400.

	;INPUT BUFFER POINTERS
TIBSZ==10.
TIBN:	TBK
TIBI:	ZEPT NLTY,TIBB
TIBO:	ZEPT NLTY,TIBB

	;INPUT Q POINTERS
TTYAR:	TBK
TIQI:	ZEPT NLTY,TIQM	;PNTR TO WHERE NEXT CHAR GOES IN
TIQO:	ZEPT NLTY,TIQM	;PNTR TO WHERE NEXT CHAR COMES OUT
TIQTO:	ZEPT NLTY,TIQM	;PNTR TO WHERE TYO IS PROCESSING
TTYBBL==<<<TIQSZ+TOQSZ+TIBSZ>!77>+1>_-6
TTYDR==<<TTYBBL-1>_8>!6


TITQN:	TBK
TITQ==TIQM+TIQSZ-1

TIEQTN:	TBK
TIQTON:	TBK	;# OF CHARS FOR TYO TO PROCESS
TIQN:	TBK	;# OF CHARS IN INPUT Q
TIBC:	TBK	;# OF UNMATCHED ['S IN TYI BUFFER
MXNCH==TIQN	;DOUBLES AS IMX DEVICE Q

	;EDIT Q PNTRS
TIEQN:	TBK	;# OF CHARS IN EDIT Q
TIEBC:	TBK	;# OF UNMATCHED ['S FROM EDIT BUFFER

TIEQTO:	ZEPT NLTY,TITQ
TIEQO:	ZEPT NLTY,TITQ
TOTSR:	TBK	;ADDR OF TRANSMIT STATUS REGISTER
TOGOC:	ZEPT NLTY,TYGOC	;ADDR OF ROUTINE TO GET OUTPUT CHARS(MXGOC OR TYGOC)
	TOQSZ==100
	;OUTPUT QUEUE POINTERS
TOQI:	ZEPT NLTY,TOQM	;PNTR TO WHERE NEXT CHAR GOES IN
TOQO:	ZEPT NLTY,TOQM	;PNTR TO WHERE NEXT CHAR COMES OUT
TOQN:	TBK	;# OF CHARS IN Q
TOTN==TOQN

CHARNO:	TBK	;# OF CHARS FROM LEFT SIDE OF PAGE
TOPAD:	TBK	;# OF CHARS TO PAD

TOIPC:	TBK	;SAVED PC (FOR ECHO)
TOISVA:	TBK	;SAVED A

TOPC:	TBK	;SAVED PC (FOR OUTPUT)
TOSVC:	TBK	;SAVED C
TOSVD:	TBK	;SAVED D

DMMAX==3	;MAXIMUM # CHARS TO SEND TO EACH DM11 TELETYPE
DMBIT==.-NFDMTY
	ZEPT 20,1_.RPCNT
DMBUF==.-NFDMTY
	ZEPT 20,DMOBUF+<DMMAX*.RPCNT>	;PNTR TO DMOBUF
DHNUMBR==.-NFDMTY
	ZEPT 20,.RPCNT
TVLINE=.-NFTV
	ZEPT NTVS,0
TVHIGH=.-NFTV
	ZEPT NTVS,38.
TVBLNK==.-NFTV
	ZEPT NTVS,-1	;0=> NO CURSOR, POS=> CURSOR ON, NEG=> CURSOR OFF
TVCRPS=.-NFTV
	ZEPT NTVS,0
TVCRLN=.-NFTV
	ZEPT NTVS,0
TVLNNO==.-NFTV
	ZEPT NTVS,0
TVSCRL==.-NFTV
	ZEPT NTVS,0

DMOBUF:	.BLKB DMMAX*16.*NDM	;WHERE DM11 SENDS CHARS FROM
TTP:	0

MXICH==.-MXICMN	;DEVICE FOR EACH IDENTIFIER CHAR
	.BYTE 24,26,30,32
TBCCHR:	.WORD 117,112,105,40

TIANTM:	500.	;TIME TO WAIT FOR CARRIER BEFORE HANGING UP
;TIHGTM:	250.	;TIME TO HANG UP FOR
PURE==<.!17777>+1
.IIF LE PURE-20000,PURE=40000
PUREAR=KDAR+<PURE/10000>
PUREDR=KDDR+<PURE/10000>
	DISPAR=PUREAR+6
	DISPDR=PUREDR+6
	DISPPG==PURE+60000
	DISPAR=PUREAR+6
	DSLOT=DISPPG
	TEMPAR=DISPAR
	TEMPDR=DISPDR
	TEMPPG==DISPPG
	SMLFNT==PURE+40000
	BIGFNT==SMLFNT+400
TIQM==TEMPPG
TOQM==TIQM+TIQSZ
TIBB==TOQM+TOQSZ
TIQLM==TIQM+TIQSZ
TOQLM==TOQM+TOQSZ
TIBT==TIBB+TIBSZ
	.STITL TELETYPE CODE USER LEVEL
.TTYP:	JSR PC,UGTTYG
	BR TTYP1

TTYP:	MOV USER,U
	MOV UTTY(U),E
TTYP1:	TST TIBN(E)	;ANY CHARACTERS YET?
	BNE .+6		;YES RETURN TRUE
	JMP RTFALS
	JMP RTTRUE

;CTYI--OUTPUTS (TO LOGO USER) CHAR FROM USERS TTY
CTYI:	MOV	USER,U
	MOV	UTTY(U),E
	BR	UGTYI2

UGTTYG:	POPS	E	;DEVICE SPEC (NAME OR NUMBER)
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
	JSR	PC,OPEN1
	RTS PC

;UGTYI-- TYI N OUTPUTS A CHAR FROM TTY N
UGTYI:	JSR PC,UGTTYG
	MOV	USER,U
	CMP	UTTY(U),E
	BNE	UGTYI1	;BR IF NOT USER'S CONSOLE
UGTYI2:	BIS	#TIMAGI,TTYST(E)	;IMAGE INPUT AND OUTPUT
	BIC	#TILIPM,TTYST(E)	;CHAR INPUT MODE
UGTYI1:	JSR	PC,GTYI	;GET CHAR IN D
	MOV	D,B
	JMP	R1NARG

;CTYO--PRINTS CHAR ON USERS TTY
CTYO:	JSR	PC,G1NARG	;B _ CHAR
CTYO1:	MOV	USER,U
	MOV	UTTY(U),E
	BR	TYO1

;SUPER .TYO
.STYO:	JSR PC,G1NARG
	MOV B,TOPS	;UGH!
	JSR PC,G1NARG
2$:	JSR A,SENSET
	BCC 1$
	CLR TIQN(E)
	BR 2$
1$:	BIC #TIECM,TTYST(E)
	MOV TOPS,D
	BIS #200,D
	JSR PC,TYO
	JSR A,SENCLR
	CLR TOPS
	SEZ
	RTS PC



;UGTYO-- TYO N M SENDS CHAR M TO TTY N. N MAY BE NAME OR NUMBER.
UGTYO:	JSR	PC,G1NARG	;B _ CHAR
	POPS	E	;DEVICE SPEC
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
TYO1:	JSR	PC,OPEN1	;MAKE SURE TTY OK
	MOV	B,D	;CHAR
	BIT	#TIMAGE,TTYST(E)	;IS TTY IN IMAGE MODE?
	BNE	TYO2	;BR IF YES
	BIS	#200,D	;ELSE SPECIFICALLY IMAGE MODE THIS CHAR
TYO2:	JSR	PC,GTYO	;SEND IT
RTSPC:	SEZ
	RTS	PC

;MUTYO -- LIKE TYO, EXCEPT TO MUSIC BOX SPECIFICALLY
;ALSO TAKES VARIABLE ARGS, AND CONVERTS ARGS TO MUSIC BOX NOTES, ETC.
MUTYO:
	EXCH	(P),2(P)
	JSR	PC,REVS
	MOV	#MBDN,E
	JSR	PC,OPEN1
;LOOP,  PLACING EACH CHAR IN TYO BUFFER
	SPOP	C	;NUMBER OF ARGS
	BEQ	RTSPC	;0 ARGS (OH WELL)
MUTLP:	JSR	PC,G1NARG	;B _ CHAR
	MOV	B,A
	JSR	PC,SINGNO	;NORMALIZES MIDDLE C TO 0. CHECKS NOTE IN RANGE.
	MOV	A,D
	JSR	PC,GTYO
	SOB	C,MUTLP
	SEZ
	RTS	PC


;MUCTRL -- SENDS CONTROL TYPE INFO TO MUSIC BOX
MUCTRL:
	MOV	#MBDN,E
	JSR	PC,OPEN1
	JSR	PC,G1NARG	;B _ WHICH CONTROL FUNCTION
	MOV	B,D
	BLT	MUCERR	;NUMBER MUST BE BETWEEN 0,33
	CMP	D,#33.
	BLE	MUC1
MUCERR:	ERROR+WTIB	;INVALID MUSIC BOX CONTROL FUNCTION
;ARG IS DECODED AS FOLLOWS:
;	TOP DIGIT IS SILENCE CONTROL
;	BOTTOM DIGIT IS LOADING CONTROL
;	(NOTE -- BOTH DIGITS SHOULD BE BETWEEN 0,3)
MUC1:	CLR	C
	DIV	#10.,C	;C _ TENS, D _ ONES
	ASH	#4,C	;SHIFT INTO BITS 6,5
	BIC	#177774,D	;LEAVE ONLY BOTTOM 2 BITS
	BIS	C,D
	BIT	#40,D	;BIT 6 MUST NOT EQUAL BIT 7 (GROAN)
	BNE	MUC2	;BR IF BIT 6 = 1
	BIS	#100,D	;ELSE MAKE BIT 7 = 1
MUC2:	MOV	D,MUCWRD	;KEEP CONTROL WORD CURRENT
	JSR	PC,MUCTYO	;SENDS OUT TRAP CHAR, ETC. TOO
	SEZ
	RTS	PC

;CALL WITH CONTROL CHARACTER IN D.
;FIRST TYOS THE MUSIC BOX TRAP CHAR,
;THEN TYOS THE CHAR IN D
;	(NOTE THAT THIS ISN'T A PRIMITIVE)
MUCTYO:	SPUSH	D
	MOV	#MBTRAP,D	;HARDWARE CATCHES THIS
	SPUSH C
	MOV #PMBOX,C
	JSR PC,TBTYO
	SPOP C
	SPOP	D
	JSR	PC,GTYO
	RTS	PC

TBINIT:	SPUSH A
	SPUSH B
	SPUSH D
	SPUSH E
	SPUSH U
	MOV #NPTBOX,A
	MOV #PTBOX0,B
	TST C
	SXT U
	BPL TBINT1
	NEG C
TBINT1:	CMP USER,(B)+
	BEQ TBINT2
	ADD #4*2,B
	SOB A,TBINT1
	BR TBINSZ
TBINT2:	MOV #4,A
	SPUSH B
TBINT3:	CMPB C,(B)
	BEQ TBINT4
	TST (B)+
	SOB A,TBINT3
	SPOP B
TBINSZ:	SPOP U
	SPOP E
	SPOP D
	SPOP B
	SPOP A
	SEZ
	RTS PC
TBINT4:	TST U
	BMI TBINT5
	TST (B)
	BPL TBINT5
	SPOP B
	MOV USER,U
	MOV UTTY(U),E
TBINCZ:	SPOP U
	SPOP D
	SPOP D
	SPOP B
	SPOP A
	CLZ
	RTS PC
TBINT5:	MOV USER,U
	MOV UTTY(U),E
	SPUSH B
	MOV #21,B
	JSR PC,TYO1
	MOV (P),B
	SUB 2(P),B
	MOV TBCCHR(B),B
	JSR PC,TYO1
	SPOP B
	BIS #100000,(B)
	MOV (B),C
	BIC #TBMASK,C
	CMP C,#CONSO
	BNE TBINT6
	MOV OTTYST(E),TTYST(E)
	BIS #TIRST,TTYST(E)
	BR TBINT7	;DESTROY OLD USER
TBINT6:	BIS #TIMAGE,TTYST(E)
TBINT7:	SPOP C
	MOV #4,D
TBINT8:	TST (C)
	BGE TBINT9
	CMP C,B
	BEQ TBINT9	;DONT CLEAR THE ONE WE JUST SET
	BIC #100000,(C)
TBINT9:	TST (C)+
	SOB D,TBINT8
	BR TBINCZ



;UTYCK RETURNS IF VALID TTY, LOOSE OTHERWISE
UTYCK:	CMP	E,#2*NLTY
	BGE	UTYCL	;TOO HIGH TTY #
	BIT	#100001,E
	BNE	UTYCL	;BR IF TTY NEG OR ODD
	TST	TTYU(E)
	BLT	UTYCK1	;NOT IN USE
	CMP	TTYU(E),USER
	BNE	UTYCL1	;BR IF IN USE BY SOMEONE ELSE
UTYCK1:	RTS	PC

UTYCL:	ERROR+TDE	;NOT A VALID TTY #
UTYCL1:	ERROR+DIU	;DEVICE IN USE

MYSPEE:	MOV USER,U
	MOV UTTY(U),E
MYSPE1:	JSR PC,G1NARG
	BIT #TPDM,TYPTYP(E)
	BEQ UTYCL
	CMP #16,B
	BLE UTYCL
	TST B
	BLT UTYCL
	ASH #6,B
	MOV B,C
	ASH #4,B
	BIS B,C
	BIS #3,C
	SPL 7
	BIC #17,DH0SCR
	BIS DHNUMB(E),DH0SCR
	MOV C,DH0LPR
	SPL 0
	SEZ
	RTS PC
HISSPE:	JSR PC,CKSST
	JSR PC,G1NARG
	CMP #NLTY,B
	BLE UTYCL
	TST B
	BLT UTYCL
	ASL B
	MOV B,E
	BR MYSPE1
;DEVICE NUMBER FROM SPEC
;	CALL WITH POINTER TO EITHER NUMBER OR NAME IN E
;	RETURNS WITH TTY NUMBER IN E , OR ERROR+DNA IF INVALID NAME
DEVNUM:
	PUSH	A
	SPUSH	B
	MOV	#SNUM,A	;IS ARG A NUMBER?
	MOV	E,B
	JSR	PC,CONVERT
	BEQ	DNUM1	;BR IF NOT NUMBER
	MOV	B,E
	ASL	E
	BR	DNUM9

;NOT A NUMBER.  HOPEFULLY THE ARG IS A STRING
DNUM1:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BEQ	DNUM8	;BR IF NOT STRING, EITHER
	MOV	B,E
	JSR	PC,DEVNAM
	BEQ	DNUM8	;BR IF NOT VALID NAME
DNUM9:	JMP	RETB	;POP A,B AND RETURN
DNUM8:	PUSHS	E	;POINTER TO THE INVALID NAME
	ERROR+DNA	;INVALID DEVICE NAME


;CALL WITH POINTER TO DEVICE NAME IN E
;RETURNS WITH DEVICE NUMBER IN E IF VALID, AND CLZ'S
DEVNAM:	PUSH	A
	SPUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F

	SPUSH	#LDEVAR	;LOGICAL DEVICE NAME ARRAY
DNAM1:	MOV	@(P),C	;POINTER TO NEXT TEXT STRING
	BEQ	DNAM9	;BR IF NO MORE STRINGS
	MOV	4(P),B	;POINTER TO ARG
	JSR	PC,EQ.TXT
	BNE	DNAMEQ	;BR IF ARG = CURRENT TEXT STRING
	ADD	#4,(P)	;POINT TO NEXT STRING POINTER
	BR	DNAM1
DNAMEQ:	ADD	#2,(P)	;POINT TO TTY NUMBER FOR THIS DEVICE
	MOV	@(P)+,E
	BGE	DNAM2	;-1 IS FLAG FOR "TTY".  BR IF NOT "TTY"
	MOV	USER,E
	MOV	UTTY(E),E
DNAM2:	BIT	#1,E	;ODD MEANS THE DEVICE ISN'T ATTACHED
	BNE	DNAM9	;BR IF NOT ATTACHED
	SPOP	F	;RESTORE F
	TST	(P)+	;DON'T RESTORE E !!
	JMP	SRETD	;CLZ RETURN
;NO MORE STRINGS LEFT. IE ARG ISN'T VALID DEVICE NAME
DNAM9:	TST	(P)+	;POP OFF LDEVAR
	JMP	RETF	;RESTORE ALL AC'S AND SEZ RETURN



;OPEN--ASSIGNS TTY TO USER IF VALID TTY #
OPEN:	JSR	PC,G1NARG
	ASL B
	MOV	B,E
OPEN1:	JSR	PC,UTYCK	;RETURN IF VALID TTY
	MOV	USER,TTYU(E)	;ASSIGN TTY TO CURRENT USER
	RTS	PC


;CLOSE--CLOSES TTY IF USER HAS IT OPEN
CLOSE:	POPS	E
	JSR	PC,DEVNUM
	JSR	PC,UTYCK
CLOSE1:	MOV	USER,U
	CMP	E,UTTY(U)
	BEQ	.+10	;BR IF USER'S CONSOLE
CLOSE3:	MOV	#-1,TTYU(E)
	SEZ
CLOSE4:	RTS	PC

;LIKE CLOSE1, EXCEPT ONLY CLOSE IF THIS USER ALREADY HAS IT OPEN
CLOSE2:	CMP	USER,TTYU(E)
	BNE	CLOSE4
	BR	CLOSE3

;SLAM--CLOSES ALL USER TTYS BUT CONSOLE
SLAM:	MOV	#NLTY,A
	CLR	E
SLAM1:	CMP	TTYU(E),USER
	BNE	.+6	;BR IF USER DOESN'T OWN THIS TTY
	JSR	PC,CLOSE1
	TST	(E)+
	SOB	A,SLAM1
	RTS	PC

WHERE:	MOV USER,U
	MOV UTTY(U),B
	MOV CHARNO(B),B
	JMP R1NARG

;TURN CASE CONVERSION ON AND OFF
CASESW:	JSR	PC,G1NARG
	TST	B
	BEQ	CASES1	;BR IF ARG=0
	JSR	PC,TICASE	;CONVERT LOWER TO UPPER CASE ON INPUT
	BR	CASES2
CASES1:	JSR	PC,TINCAS	;DON'T CONVERT CASE
CASES2:	SEZ
	RTS	PC

;TURN ECHOING ON AND OFF
ECHOSW:	JSR	PC,G1NARG
	TST	B
	BEQ	ECHOS1	;BR IF ARG=0
	JSR	PC,TIECH	;ECHO
	BR	CASES2
ECHOS1:	JSR	PC,TINECH	;TURN ECHO OFF
	BR	CASES2


			;I SPACE USER MODE
;GET A CHAR IN D FOR USER'S TTY
TTYI:	JSR	A,TYEUSV	;GET USER & TTY
	JSR	PC,TYIGC	;GET A CHARACTER
	TST	TIQN(E)
	BGT	.+10
	MOV #TIQM,TIQO(E)
	JSR	A,TYEURS	;RESTORE E&U
	RTS	PC

;GET A CHAR FOR TNM IN E
GTYI:	JSR	A,TYUSV	;GET USER IN U
	JSR	PC,TYIGC	;GET A CHAR
	JSR	A,TYURS	;RESTORE U
	RTS	PC

;GET A CHAR FOR TTY, DO RIGHT THING IF NONE AVAILABLE
TYIGC1:	BIT	#TILIPM,TTYST(E)
	BEQ	TYIGC2	;BR IF IN CHAR INPUT MODE
	MOV	TBKCHL,D	;RETURN BREAK CHARACTER
	RTS	PC
TYIGC2:	MOV	#FRTYIC,FLSRES(U)
	JSR	PC,FLUSH	;FLUSH USER WITH FLUSH REASON CHAR TYI WAIT
	TST	BRAKE(U)
	BNE	TYIGC3	;BR IF USER TRYING TO BREAK
	TST TIBN(E)
	BLE	TYIGC2
	JSR	PC,RUNME	;FLUSH REASON CLEARED BY INTERRUPT CODE?
TYIGC:	JSR	PC,TIOQ	;TRY TO GET CHAR FROM INPUT Q
	BEQ	TYIGC1	;BR IF NONE AVAILBLE
	RTS	PC

TYIGC3:	JSR	PC,RUNME
	RTS	PC


;SLINE
;START LINE INPUT
SLINE:	JSR	A,TYEUSV
	BIC	#TIMAGI!TIMAGE!TIRBM!TIQF,TTYST(E)	;CLR MISC FLAGS
	BIS	#TILIPM!TIRST,TTYST(E)	;LINE INPUT MODE, INPUT RESET
	JSR	A,TYEURS
	RTS	PC
			;I SPACE USER MODE

;PUT CHAR IN D INTO USER'S TTY'S OUTPUT BUFFER
TTYO:
.IFNZ DRIBF
	BIT #DRIBBF,FLAGS2	;DRIBBLE THE OUTPUT?
	BEQ TTYO3		;NO
	JSR PC,.WRTEC		;OUTPUT THE CHARACTER
.ENDC
TTYO3:	JSR	A,TYEUSV	;GET USER & TTY
	BIT #PTBF,TTYST(E)
	BNE TTYO1
	JSR	PC,GTYO	;SEND CHAR
TTYO2:	JSR	A,TYEURS
	RTS	PC

TTYO1:	SPUSH C
	MOV #CONSO,C
	JSR PC,TBTYO
	SPOP C
	BR TTYO2


;PUT CHAR IN D INTO TTY IN E'S BUFFER
TBTYO:
	JSR PC,TBINIT
GTYO:	JSR	A,TYUSV	;GET USER IN U
	TST	TOPC(E)
	BEQ	GTYO3	;BR IF OUTPUT BUFFER NOT FULL
GTYO2:	MOV	#FRTYOW,FLSRES(U)
	JSR	PC,FLUSH	;KEEP FLUSHING TILL ROOM IN OUTPUT Q
	TST	BRAKE(U)	;USER TRYING TO BREAK?
	BNE	GTYO5
	TST	TOPC(E)
	BNE	GTYO2
	JSR	PC,RUNME
GTYO3:	PUSH	C
	JSR	PC,TOTYO	;PUT CHARACTER IN Q
	POP	C
	JSR	PC,TOCINT	;CAUSE OUTPUT INTERRUPT IF NONE PENDING
GTYO4:	JSR	A,TYURS	;RESTORE U
	RTS	PC

GTYO5:	JSR	PC,RUNME
	BR	GTYO4

;SEND CHAR TO MULTIPLEXEE AND WAIT UNTILL IT SENDS CHAR BACK
;RETURN THAT CHAR IN D
MXWT: TBTW:	PUSH	A
	SPUSH	D
	SPUSH	U
	MOV #TIQSZ,A
	MOV	USER,U
MXWT1:	TST	BRAKE(U)
	BNE	MXWT5
	JSR	PC,TIOQ	;EMPTY TURTLE'S INPUT Q (CLOBBERS D)
	BEQ	MXWT2	;Q EMPTY
	SOB	A,MXWT1
	ERROR+HARD	;JUST GOT 200 CHARS OUT OF Q!! RUNNING OPEN?
MXWT2:	MOV	E,D
	MOVB	MXNUM(D),E	;GET MULTIPLEXOR NUMBER
	JSR	PC,MXQLAD	;ADD THIS TTY TO END OF MULTIPLEXOR'S QUEUE
	BEQ	MXWT6	;Q FULL
		;MAKE SURE HE CAN'T BREAK FROM TYO NOW THAT MPXR EXPECTS CHAR
	MOV	D,E
	TST	TOPC(E)
	BEQ	MXWT4
MXWT3:	MOV	#FRTYOW,FLSRES(U)
	JSR	PC,FLUSH
	TST	TOPC(E)
	BNE	MXWT3	;OUTPUT Q STILL FULL
	JSR	PC,RUNME
MXWT4:	POP	U
	SPOP	D
	SPOP	A
	JSR	PC,GTYO	;SEND CHAR
	JSR	PC,GTYI	;GET CHAR BACK
MXWT5:	RTS	PC

MXWT6:	ERROR+TGDZ
			;I SPACE USER MODE

;START SENDING CHARACTERS TO EDIT BUFFER
EDITA:	JSR	A,TYEUSV
	JSR	PC,TYERT	;RESET EDIT BUFFER
	BR	ETYO1

;END SENDING CHARS TO EDIT BUFFER
EDITE:	JSR A,TYEUSV
	JSR PC,FIXBUF
	BIS	#TIEDM,TTYST(E)
	BR	ETYO1

;PUT CHARACTER IN EDIT BUFFER

ETYO:	JSR A,TYEUSV
	CMP TITQN(E),#TIQSZ
	BGE ETYO1
	JSR F,TTYMPI
	MOVB D,@TIQI(E)
	JSR F,TTYMPO
	INC TIEQN(E)
	INC TIQI(E)
	INC TITQN(E)
ETYO1:	JSR A,TYEURS
	RTS PC

FIXBUF:	JSR F,TTYMPI
	MOV TIEQN(E),C
	MOV TIQI(E),A
	MOV #TITQ,B
FXLOOP:	MOVB -(A),-(B)
	DEC TIQI(E)
	DEC TIEQO(E)
	SOB C,FXLOOP
	JSR F,TTYMPO
	RTS PC

				;I SPACE USER MODE

;TURN ON ECHO MODE
TIECH:	JSR	A,TYEUSV
	BIS	#TIECM,TTYST(E)
TIECH1:	JSR	A,TYEURS
	RTS	PC
;TURN OFF ECHO MODE
TINECH:	JSR	A,TYEUSV
	BIC	#TIECM,TTYST(E)
	BR	TIECH1

;TURN ON CASE SWITCH
TICASE:	JSR	A,TYEUSV
	BIS	#TICVM,TTYST(E)
	BR	TIECH1
;TURN OFF CASE SWITCH
TINCAS:	JSR	A,TYEUSV
	BIC	#TICVM,TTYST(E)
	BR	TIECH1


;BREAK HAS BEEN PROCESSED ON USER LEVEL,
;OK TO ACCEPT CHARS AGAIN
BRAKR:	JSR	A,TYEUSV
	JSR	PC,TTYRT
;	BIS	#TIRST,TTYST(E)	;TELL INT ROUTINES TO RESET BUFFERS
;	JSR	PC,TOCINT	;CAUSE INTERRUPT
	BIC	#TIBR,TTYST(E)
	BR	TIECH1

;INTIALIZE USER CONSOLE
UCINIT:	SPUSH	A
	MOV	TYCKBP(E),A
	JSR	PC,CLKQDL	;DELETE ANY CLOCK QUEUE ENTRY
	BIC	#TICLKQ!TIMAGE!TIMAGI,TTYST(E)	;PUT INTO ASCII MODE
	BIS	#TILIPM!TIECM!TICVM,TTYST(E)	;LINE INPUT, CONVERT CASE, ECHO
	SPOP	A
	RTS	PC
			;I SPACE USER MODE
;SAVE U, GET USER INTO U, CALL WITH JSR A
TYUSV:	SPUSH	U
	MOV	USER,U
	JMP	(A)
;RESTORE U
TYURS:	TST	(P)+	;THIS POPS A SAVED WITH JSR A CALL
	POP	U
	RTS	A	;RESTORING A SAVED BY CALL TO TYUSV

;GET USER IN U, HIS TTY IN E, SAVE BOTH
TYEUSV:	SPUSH	U
	SPUSH	E
	MOV	USER,U
	MOV	UTTY(U),E
	JMP	(A)
;RESTORE
TYEURS:	TST	(P)+
	POP	E
	SPOP	U
	RTS	A
.STITL TELETYPE INPUT INTERRUPT ROUTINES

;BREAK VECTORS POINT TO THESE RECEIVE INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TKBRK:	SPUSH	A
	MOV	#NFTY,A
	JMP	GENRBK
.ENDC

;.IRP	DEV,<DC,KL>	;DC11'S, KL11'S
;TTY==0
;CONS <
;	ZEPT N>,DEV,<,<	;ASSEMBLES AS ZEPT NDC,<
;	CONS DEVTYP==DEV,\Z,DT	;DEVTYP==DC0DT
;	.IFZ <TYDT-DEVTYP>*<MODT-DEVTYP>	;IF TTY OR TTY MODEM
;		CONS DEV,\Z,RK:		;DC0RK:
;		SPUSH A
;		CONS <MOV #NF>,DEV,<TY+TTY,A>	;TTY INDEX
;		JMP GENRBK
;		TTY==TTY+2
;	.ENDC
;	.IFZ <TBDT-DEVTYP>*<TBMDT-DEVTYP>	;IF TB OR TB MODEM
;		CONS DEV,\Z,RK:
;		SPUSH A
;		CONS <MOV #DEV>,\Z,<TBN,A>
;	.ENDC
;>>
;.ENDM

DC0RK:	SPUSH	A
	MOV	#DC0TBN+<2*<20-NDMTY>>,A
	JMP	GENRBK
DC1RK:	SPUSH	A
	MOV	#NFDCTY,A
	JMP	GENRBK

.IFNZ	NTY+NKLTY+NDCTY+NDPTY
;GENRBK--
;GENERAL RECEIVE BREAK FOR TTYS, TBOXS, ETC.
;CALLED WITH	SPUSH A
;		MOV #TTY INDEX,A
;		JMP GENBRK

GENRBK:	JSR	U,ACSAV
	MOVB	TILTTY(A),E	;TTY
	MOV	TYRS(A),U	;RG ADR
	MOV	(U),D	;RG CONTENTS
	BIT	#%ER,D
	BNE	TGENER	;BR IF ERROR BIT ON
	TST	E
	BMI	GENRB1	;BR IF NOT LOGICAL TTY
	MOV	2(U),D	;CHARACTER
	BIC	#177600,D	;ONLY 7 BITS
	BIT	#TIRST,TTYST(E)
	BEQ	.+6
	JSR	PC,TYIRT1	;RESET INPUT
	JSR	PC,@TIRCV(E)	;INPUT ROUTINE FOR THIS PHYSICAL DEV.
GENRB1:	JSR	U,ACRES
	SPOP	A
	RTT

TGENER:	JSR	PC,GENER
	BR	GENRB1

;A PNTS TO BLK
;D REG CONTENTS
;U BUF ADDR
GENER:
.IFG	NMODEM
	TST	E
	BMI	GENER5
	BIT	#TPMODM,TTYTP(E)
	BNE	GENER2	;BR IF MODEM
GENER5:
.ENDC
	JSR	PC,DEVER	;PRINT ERROR MESSAGE
	BR	GENER4
.IFG	NMODEM
GENER2:	MOV	TYCKBP(E),A
	BIT	#TICLKQ,TTYST(E)
	BEQ	GENER1
	JSR	PC,CLKQDL	;DELETE ANY PRESENT CLKQ ENTRY
	BIC	#TICLKQ,TTYST(E)
GENER1:	BIS	#%DTRDY,(U)
	BIT	#%CRDT,D
	BNE	GENER4
	JSR	PC,TISANS	;TRY TO HANG UP
.ENDC
GENER4:	CMP	(U)+,(U)
	RTS	PC

;;!!! CHANGE SYS CONSOLE PRINOUT HACK
DEVER:	JSR	A,SPRINT
	BPRTXT	^\DEV ERR \
	JSR	PC,PGEN1
	SPREND
	RTS	PC

PGEN1:	MOV	U,A
	JSR	PC,PRON		;REGISTER ADDR
	PRTXT	^\/  \
	MOV	D,A
	JSR	PC,PRON		;REG CONTENTS
	PRCR
	RTS	PC

.IFG NMODEM
;TISHNG:	;ASSERT DATA TERM RDY IN TIHGTM TICKS
;	MOV	#TIHGTM,(A)
;	MOV	#TIUNHG,4(A)
;	BR	TICKLA

TISANS:	MOV	#TIANTM,(A)	;IF NO CARRIER IN TIANTM TICKS, HANG UP
	MOV	#TIANS,4(A)

TICLKA:	JSR	PC,CLKQAD
	BIS	#TICLKQ,TTYST(E)
	RTS	PC

TIANS:	JSR	B,TICKS
	BIT	#%CRDT,@U
	BNE	TIANS1
	BIC	#%DTRDY,@U
;	JSR	PC,TISHNG
TIANS1:	SPOP	U
	SPOP	E
	SPOP	B
	RTS	PC


;---FOLLOWING RUN AT CLOCK BREAK LEVEL---

TICKS:	SPUSH	E	;TICLKQ START
	SPUSH	U
	MOV	6(A),E		;TTY
	BIT	#TICLKQ,TTYST(E)
	BEQ	TICKS1
	BIC	#TICLKQ,TTYST(E)
	JMP	(B)

TICKS1:	BPT	;HOW DID THIS GET ON CLOCK Q?
	BR	TIANS1

;TIUNHG:	JSR	B,TICKS
;	BIS	#%DTRDY,@U	;TURN DATA TERM RDY ON
;	BR	TIANS1

;	TIANTM AND ;TIHGTM HAVE BEEN MOVED
;	TO THE START OF TYI WITH THE BUFFERS

.ENDC
.ENDC
.IFZ DHON
.IFG NDMTY
DM0RK:	BIC	#200,DM0CSR	;CLEAR DONE BIT
	JSR U,ACSAV	;SAVE ACS
	MOV #DMTT+200,B	;BOTTOM OF TUMBLE TABLE
	MOV #TTP,C	;TUMBLE TABLE POINTER
	;BR DMRK

;DM11 RECEIVE INTERRUPT
DMRK:	BR	DMRK3

DMRK1:	BIC	#120200,@(C)	;CLR CHAR RCVD, PARITY, AND UNUSED BITS
	BIT	#40000,@(C)
	BNE	DMRK2	;BR IF NO STOP RECEIVED
	MOV	(C),E
	MOVB	1(E),E	;GET LINE #
	ADD	#NFDMTY,E	;GET PHYSICAL TTY NUMBER
	MOVB	TILTTY(E),E	;GET LOGICAL NUMBER
	BMI	DMRK2	;BR IF ILLOGICAL
	MOVB	@(C),D	;CHARACTER
	BIT	#TIRST,TTYST(E)
	BEQ	.+6
	JSR	PC,TYIRT1	;RESET INPUT
	JSR	PC,@TIRCV(E)	;INPUT ROUTINE FOR THIS TTY
DMRK2:	ADD	#2,(C)	;INCREMENT POINTER
	CMP	@C,B
	BLO	DMRK3	;BR IF NOT PAST END OF TABLE
	MOV	B,@C	;RESET POINTER
	SUB	#200,@C
DMRK3:	TST	@(C)
	BMI	DMRK1	;BR IF MORE CHARACTERS
	JSR	U,ACRES	;RESTORE AC'S
	RTT
.ENDC
.ENDC

.IFNZ DHON
.IFG NDMTY
DM0RK:	JSR U,ACSAV
DM0RK2:	MOV DH0NRC,C	;GET THE CHARACTER
	BGE DM0RK3	;NO CHARACTER
	BIC #110200,C	;CLEAR SILLY BITS
	BIT #60000,C	;IS IT A BREAK?
	BEQ DM0RK1	;NOPE
	BIC #60377,C	;CLEAR CHARACTER AND BREAK BITS
	ADD #7,C	;BREAK
DM0RK1:	MOV C,E		;COPY IT
	SWAB E		;GET LINE NUMBER
	BIC #177760,E	;FLUSH CRAP
	ASL E
	MOVB TILTTY+NFDMTY(E),E	;GET LOGICAL NUMBER
	BMI DM0RK2	;ILLOGICAL
	MOV C,D		;COPY AGAIN
	BIC #177600,D	;JUST THE CHARACTER
	BIT #TIRST,TTYST(E)	;RESET INPUT?
	BEQ .+6
	JSR PC,TYIRT1	;GO RESET IT
	JSR PC,@TIRCV(E)	;GOBBLE CHARACTER INTO BUFFER
	BR DM0RK2		;ANY MORE?
DM0RK3:	JSR U,ACRES
	RTT
.ENDC
.ENDC
.IFNZ NTVS
;TV CLOCK TICK ROUTINE
TVTICK:	JSR U,ACSAV
	JSR PC,LKBBRK	;GO COLLECT KEYBOARD CHARACTERS
	JSR PC,TVOUT	;GO EMPTY TV OUTPUT BUFFERS
	MOV #NTVCHN*400-400+17,A
	MOV #TVLOGO,B
TVTIC1:	TST (B)+
	BLT TVTIC4	;HE SHOULDN'T BE DISTURBED
	BEQ TVTIC3	;HE'S ALL DONE THIS TIME
TVTIC2:	DEC -2(B)	;HE GETS IT AT LEAST 1/60TH MORE
TVTIC4:	SUB #400,A
	BGE TVTIC1
	JSR U,ACRES
	RTS PC
TVTIC3:	MOV A,VIDSW	;HE DOESN'T GET IT ANY MORE
	BR TVTIC2

LKBBRK:LKBBR1:	MOV LKBB,C	;GET ANY CHARACTER THAT MIGHT BE THERE
	BEQ LKBBR2	;NONE
	BIC #160200,C	;CLEAR THE GARBAGE
	MOV C,E		;COPY
	SWAB E		;TO GET KEYBOARD NUMBER
	BIC #177740,E
	ASL E
	MOV TVKBS(E),E	;GET THE "REAL" TTY NUMBER (LOGICAL, I HOPE)
	BGE LKBBR3	;BRANCH IF THERE IS SOMEONE THERE ALREADY
	CMPB #TVDOIT,C	;DID HE TYPE "DO IT"?
	BNE LKBBR1	;IF NOT, DON'T DO IT
	CLR E		;NOW SEE IF WE CAN FIND A FREE CONSOLE FOR THIS GUY
LKBBR4:	TST TVUSE(E)	;IS THIS ONE FREE?
	BLT LKBBR5	;YES, GO GOBBLE IT
	TST (E)+	;MOVE ON
	CMP #NTVS*2,E	;AT THE END?
	BNE LKBBR4	;NO, KEEP TRYING
	BIC #160377,C	;HE LOSES
	BIS #16,C	;BUT, AS A CONSOLATION PRIZE
	MOV C,VIDSW	;TELL HIM THAT THE SYS IS ALIVE
	SWAB C
	ASL C
	BIC #177701,C
	MOV #3*60.,TVLOGO(C)	;BUT ONLY FOR 3 SECONDS
	BR LKBBR1	;MAYBE SOMEONE ELSE?
LKBBR5:	MOV PC,TVUSE(E)	;NO LONGER FREE
	MOV E,A		;COPY WHICH TV WE GOT
	BIC #160377,C	;CLOBBER ALL BUT WHICH KEYBOARD
	MOV C,D		;AND COPY THAT
	ASR C
	BIS E,C		;SWITCH HIM IN
	MOV C,VIDSW
	ADD #NFTV,A	;THE LOGICAL NUMBER
	SWAB D		;WHO WAS THAT MASKED MAN?
	ASL D
	MOV #-1,TVLOGO(D)
	MOV A,TVKBS(D)
	BR LKBBR1
LKBBR3:	MOVB C,D
	MOVB LKBTAB(D),D	;TRANSLATE TO REAL CHARACTERS
	BEQ LKBBR1	;IMAGINARY CHARACTER TYPED
	BIT #TIRST,TTYST(E)	;RESET?
	BEQ .+6		;NO
	JSR PC,TYIRT1
	JSR PC,@TIRCV(E)
	BR LKBBR1
LKBBR2:	RTS PC
.ENDC

;MULTIPLEXOR RECIEVE INTERRUPT
MXRCV:	SPUSH	E
	CMP	D,#'_
	BGT	MXRCV3	;BR IF LOWER CASE
	JSR	PC,MXGTY	;GET INDEX OF LOG DEV THIS CHAR BELONGS TO
	BEQ	MXRCV1	;FAIL, THIS CHAR DOESN'T BELONG TO ANYONE
	JSR PC,TYRCV1
	BR MXRCV1

MXICMN==140
MXICMX==137
MXRCV3:	;CHAR IS LOWER CASE, IDENTIFIES WHERE NEXT CHAR COMES FROM
	CMP	D,#MXICMN	;SMALLEST LEGAL IDENTIFIER
	BLT	MXRCV1
	CMP	D,#MXICMX	;LARGEST LEGAL IDENTIFIER
	BGT	MXRCV1
	MOVB	MXICH(D),E	;GET INDEX OF DEVICE
	JSR	PC,MXQTAD	;ADD TO TOP OF QUEUE
MXRCV1:	SPOP E
MXRCV2:	SEZ
	RTS PC


MXGTY:	;GETS TTY # OF NEXT LOG. DEV. IN MX Q, UPDATES Q,
	;FAILS IF NOTHING IN QUEUE
	TST	MXNCH(E)
	BLE	MXRCV2	;Q EMPTY, FAIL
	SPUSH	D
	JSR F,TTYMPI
	MOV #TIQM,D
	MOVB	(D)+,-(P)	;PUSH INDEX OF FIRST DEV ON Q
MXGTY1:	MOVB	(D)+,-2(D)	;MOVE REST OF Q UP ONE BYTE
	CMP D,#TIQLM
	BLO	MXGTY1
	DEC	MXNCH(E)
	MOVB	(P)+,E		;POP DESIRED INDEX
	JSR F,TTYMPO
	SPOP	D
	CLZ
	RTS PC


;ADD CHAR IN D TO TOP OF MX INPUT Q
MXQTAD:
	CMP TIQN(E),#TIQSZ
	BGE	MXRCV2
	SPUSH	A
	JSR F,TTYMPI
	MOV	MXNCH(E),A
	ADD #TIQLM,A
MXQTA1:	MOVB	(A)+,(A)	;MOVE ENTIRE Q DOWN ONE
	SUB	#2,A
	CMP A,#TIQLM
	BHIS	MXQTA1
	INC	MXNCH(E)
	MOVB D,@TIQI(E)
	JSR F,TTYMPI
	SPOP	A
	CLZ
	RTS PC

;ADD CHAR IN D TO BOTTOM OF MX Q
MXQLAD:
	CMP TIQN(E),#TIQSZ
	BGE	MXRCV2
	SPUSH	A
	MOV #TIQM,A
	JSR F,TTYMPI
	ADD	MXNCH(E),A
	MOVB	D,(A)
	INC	MXNCH(E)
	JSR F,TTYMPO
	SPOP	A
	CLZ
	RTS PC
.STITL TYPEIN--INTERRUPT LEVEL
;TELETYPE RECIEVE
;PROCESS CHAR IN D FOR TTY IN E
;CAN CLOBBER A,U

TYRCV:	BIT #TILIPM,TTYST(E)
	BEQ TYRCV1
	MOV TTYU(E),U
	BLT TYRCV1
	CMP D,#7
	BEQ TYRCV2
	CMP D,#32
	BEQ TYRCV3
TYRCV1:	CMP #TIBSZ,TIBN(E)
	BEQ TYRET
	JSR F,TTYMPI
	MOVB D,@TIBI(E)
	JSR F,TTYMPO
	INC TIBN(E)
	INC TIBI(E)
	CMP #TIBT,TIBI(E)
	BHI TYRET
	MOV #TIBB,TIBI(E)
TYRET:	RTS PC
TYRCV2:	JMP TICG
TYRCV3:	JMP TICZ

TICP:	SPUSH B
	BIT #TIRST,TTYST(E)
	BEQ .+6
	JSR PC,TYIRT1
	JSR F,TTYMPI
	MOV TTYU(E),U
	CMP #FRLINW,FLSRES(U)
	BNE TICP5
TICPLT:	CMP #TIBT,TIBO(E)
	BHI TICP7
	MOV #TIBB,TIBO(E)
TICP7:	MOVB @TIBO(E),D
	INC TIBO(E)
	DEC TIBN(E)
	BIT #TIQF,TTYST(E)
	BEQ TICP4
	BIC #TIQF,TTYST(E)
	BIS #200,D
	BR TICP3
TICP4:	BITB #FSF,DTBL(D)
	BEQ TICP3
	MOVB DTBL2(D),C
	JSR PC,@TIICTB(C)
	BEQ TICPLB
TICP3:	JSR PC,TYINQ
	BEQ TICPRT
TICPLB:	TST TIBN(E)
	BNE TICPLT
TICPRT:	JSR PC,TOCINT
TICP5:	JSR F,TTYMPO
	SPOP B
	RTS PC


;PUT CHAR IN D INTO CONSOLE IN E'S INPUT BUFFER
TYINQ:	BIT	#TICVM,TTYST(E)
	BEQ	TIINQ	;BR IF NOT CONVERTING LOWER TO UPPER CASE
	JSR	PC,TICVLU	;CONVERT
;PUT CHAR IN D INTO TTY IN E'S INPUT BUFFER
TIINQ:
	CMP TIQN(E),#TIQSZ
	BGE	TIINQ1	;BR IF BUFFER FULL
	JSR F,TTYMPI
	MOVB	D,@TIQI(E)	;PUT CHAR IN
	JSR F,TTYMPO
	INC	TIQI(E)	;INC POINTER
	INC	TIQN(E)	;INC COUNTER
	INC	TIQTON(E)	;INC OUTPUT LEVEL COUNTER
	INC TITQN(E)
	CLZ
	RTS PC

TIINQ1:	SEZ
	RTS	PC

;*****TIOQ RUNS AT USER LEVEL ALSO******
;GET A CHAR FROM INPUT QUEUE

TIOQ:	BIT #TILIPM,TTYST(E)
	BNE TIOQ1
	TST TIBN(E)
	BLE TIINQ1
	CMP #TIBT,TIBO(E)
	BHI TIBORT
	MOV #TIBB,TIBO(E)
TIBORT:	JSR F,TTYMPI
	MOVB @TIBO(E),D
	JSR F,TTYMPO
	BIC #177400,D
	INC TIBO(E)
	DEC TIBN(E)
	BIT #TIECM,TTYST(E)
	BEQ TIBRET
	JSR PC,TOTYO
	JSR PC,TOCINT
TIBRET:	CLZ
	RTS PC

TIOQ1:	TST TIEQTN(E)
	BLE TIINQ1
	JSR F,TTYMPI
	MOVB @TIEQTO(E),D
	BIC #177400,D
	JSR F,TTYMPO
	INC TIEQTO(E)
	DEC TIEQTN(E)
	CLZ
	RTS PC



;IF CHAR IN D IS LOWER CASE, CONVERT TO UPPER
TICVLU:	TSTB	D
	BMI	TICVL1	;BR IF QUOTED
	CMP	D,#'_
	BLE	TICVL1	;BR IF UPPER CASE
	CMP	D,#177
	BEQ	TICVL1	;DON'T CASE RUBOUT
	SUB	#40,D
TICVL1:	RTS	PC


;QUOTE NEXT CHAR
TICQ:	BIT	#TIQF,TTYST(E)
	BNE	TICQ1	;BR IF ^Q WAS PREVIOUS CHAR
	BIS	#TIQF,TTYST(E)
	RTS	PC
TICQ1:	BIC	#TIQF,TTYST(E)
	RTS	PC

;RESET TTY
TTYRT:TBREST:	JSR	PC,TYORT	;RESET TYO STUFF
	JSR	PC,TYIRT	;RESET TYI STUFF
	JSR PC,TYBRT
	RTS	PC

;RESET TYPEOUT PNTRS
TYORT:	SPUSH F
	MOVB MXNUM(E),F
	BMI TYORT1
	SUB TOQN(E),TOQN(F)
TYORT1:	SPOP F
	CLR	TOQN(E)
	MOV #TOQM,TOQI(E)
	MOV #TOQM,TOQO(E)
	CLR	TOPC(E)
	CLR	TOIPC(E)
	BIT #PTBF,TTYST(E)
	BNE .+4
	RTS PC
	SPUSH C
	MOV #-CONSO,C
	SPUSH PS
	SPL 7
	JSR PC,TBINIT
	SPOP PS
	SPOP C
	RTS	PC

;*** TYIRT RUNS AT USER LEVEL ALSO ***
;RESET INPUT PNTRS
TYIRT:	BIC	#TIEDM!TIQF!TIRBM,TTYST(E)	;CLR MISC FLAGS
TYIRT1:	BIC	#TIRST,TTYST(E)	;RESET FLAG
	CLR	TIQTON(E)
	CLR	TIQN(E)
	MOV #TIQM,TIQI(E)
	MOV #TIQM,TIQO(E)
	MOV #TIQM,TIQTO(E)
	MOV TIEQN(E),TITQN(E)
	CLR	TIBC(E)
	RTS	PC

;RESET EDIT PNTRS
TYERT:	CLR	TIEQN(E)
	MOV #TITQ,TIEQO(E)
	MOV TIQN(E),TITQN(E)
	RTS	PC

TYBRT:	CLR TIBN(E)
	MOV #TIBB,TIBO(E)
	MOV #TIBB,TIBI(E)
	RTS PC

;BREAK TO LEVEL 0
TICG:	MOV	#1,BRAKE(U)	;SET USER BREAK FLAG
	BR	TIBRK
;BREAK TO LEVEL N
TICZ:	MOV	#-1,BRAKE(U)

;BREAK TO LEVEL 0 OR N
;CALL WITH CONTENTS OF BRAKE IN (P)
TIBRK:	BIS	#TIBR,TTYST(E)
	JSR	PC,TTYRT	;RESET INPUT
	CMP	#FRLINW,FLSRES(U)
	BEQ	TIBRK1	;BR IF FLUSHED WAITING FOR LINE
	BIT	#FRBKBT,FLSRES(U)	;SHOULD I UNHANG HIM ANYHOW?
	BEQ	TIBRK2	;BR IF NO
TIBRK1:	CLR	FLSRES(U)	;UNFLUSH
TIBRK2:	RTS	PC

;INTERRUPT LEVEL BREAKPOINT
;CLOBBER ATICZ/  TIIBPT
TIIBPT:	TST	(P)+
	BPT	
	RTS	PC

;REPLACE ^B WITH %
TICB:	MOV #'%,D
	RTS PC


;*** USER AND INTERRUPT LEVEL ***

;IF NOT TRANSMITTING, CAUSE OUTPUT INTERRUPT
TOCINT:	SPUSH	E
TOCIN4:	BIT	#TPPTY,TTYTP(E)
	BNE	TOCIN3
	BIT	#TOTRAN,TTYST(E)
	BNE	TOCIN2	;BR IF TRANSMITTING
.IFNZ NTVS
	BIT #TPTV,TTYTP(E)
	BNE TOCIN2
.ENDC
.IFG NDMTY
	BIT	#TPDM,TTYTP(E)
	BEQ	TOCIN1	;BR IF NOT A DM11 TTY
	BIS	#100000,@TOTSR(E)	;SET TRANS INT BIT
	BR	TOCIN2
TOCIN1:
.ENDC
	BIC	#100,@TOTSR(E)	;CLEAR AND SET INTERRUPT ENABLE
	BIS	#100,@TOTSR(E)
TOCIN2:	SPOP	E
	RTS	PC

TOCIN3:	MOVB	MXNUM(E),E
	BR	TOCIN4

.STITL TYPE OUT--INTERRUPT LEVEL

;BREAK VECTORS POINT TO THESE TRANSMIT INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TPBRK:	SPUSH	A
	MOV	#NFTY,A
	JMP	GENTBK
.ENDC

;.IRP	DEV,<DC,KL>	;DC11'S, KL11'S
;TTY==0
;CONS <
;	ZEPT N>,DEV,<,<	;ASSEMBLES AS ZEPT NDC,<
;	CONS DEVTYP==DEV,\Z,DT	;DEVTYP==DC0DT
;	.IFZ <TYDT-DEVTYP>*<MODT-DEVTYP>	;IF TTY OR TTY MODEM
;		CONS DEV,\Z,TK:		;DC0RK:
;		SPUSH A
;		CONS <MOV #NF>,DEV,<TY+TTY,A>	;TTY INDEX
;		JMP GENTBK
;		TTY==TTY+2
;	.ENDC
;	.IFZ <TBDT-DEVTYP>*<TBMDT-DEVTYP>	;IF TB OR TB MODEM
;		CONS DEV,\Z,TK:
;		SPUSH A
;		CONS <MOV #DEV>,\Z,<TBN,A>
;		JMP GENTBK
;	.ENDC
;>>
;.ENDM

DC0TK:	SPUSH	A
	MOV	#DC0TBN+<2*<20-NDMTY>>,A
	JMP	GENTBK
DC1TK:	SPUSH	A
	MOV	#NFDCTY,A
	JMP	GENTBK

.IFZ DHON
.IFG NDMTY
DM0TK:	JSR U,ACSAV
	MOV #DM0CSR,U	;STATUS REGISTER
	MOV #NFDMTY,A	;# OF FIRST TTY
	BR DMTK

;DM11 TRANSMIT BREAK
DMTK:	MOV	(U),D	;REGISTER CONTENTS
	BIT	#60000,D
	BEQ	.+6	;BR IF NO ERRORS
	JSR	PC,DEVER	;PRINT ERRORS ON SYSTEM CONSOLE
	BIC	#160000,(U)	;CLEAR ERROR &TRANS INTERRUPT BITS
	MOV	U,B
	ADD	#2,B	;ADDR OF BUFFER ACTIVE REGISTER
	MOV	A,U	;# OF FIRST TTY
	MOV	#1,A	;BIT FOR LINE BUFFER ACTIVE REGISTER
DMTK2:	BIT	A,(B)
	BNE	DMTK3	;BR IF THIS LINE TRANSMITTING
	MOVB	TILTTY(U),E	;LOGICAL TTY #
	BMI	DMTK3	;BR IF ILLOGICAL
	SPUSH	A
	JSR	PC,TYXMT	;TRANSMIT
	SPOP	A
DMTK3:	TST	(U)+	;INC TTY
	ASL	A	;SHIFT BAR BIT
	BNE	DMTK2	;BR IF MORE TTYS TO CHECK
	JSR	U,ACRES
	RTT
.ENDC
.ENDC

.IFNZ DHON
.IFG NDMTY
DM0TK:	JSR U,ACSAV
	MOV #DH0SCR,U
	MOV #NFDMTY,A
	MOV (U),D	;GET STATUS OF DH11
	BIT #42000,D	;ANYTHING BAD?
	BEQ .+6		;NOPE
	JSR PC,DEVER	;TELL THE WORLD
	INCB 1(U)	;RESET NXM
	BIC #100000,(U)	;RESET DONE
	MOV U,B
	ADD #12,B	;GET BAR ADDRESS
	MOV A,U
	MOV #1,A
DMTK2:	BIT A,(B)	;THAT LINE TRANSMITING?
	BNE DMTK3	;YES
	MOVB TILTTY(U),E	;GET LOGICAL NUMBER
	BMI DMTK3	;ILLOGICAL
	SPUSH A
	JSR PC,TYXMT	;SEND ANYTHING YOU GOT
	SPOP A
DMTK3:	TST (U)+	;NEXT LINE
	ASL A		;NEXT BAR BIT
	BNE DMTK2	;OUT OF LINES?
	JSR U,ACRES
	RTT
.ENDC
.ENDC

;GENERAL TRANSMIT BREAK
GENTBK:	JSR	U,ACSAV
	MOVB	TILTTY(A),E	;GET LOGICAL TTY #
	BMI	GENTB2	;BR IF ILLOGICAL
	MOV	TOTSR(E),B
	MOV	@B,D	;STATUS REG CONTENTS
	BIT	#%RDY,D
	BEQ	GENTB2	;BR IF NOT RDY, SPURIOUS INTERRUPT
GENTB1:	JSR	PC,TYXMT	;TRANSMIT INT ROUTINE
GENTB2:	JSR	U,ACRES
	SPOP	A
	RTT

;GET NEXT MULTIPLEXOR OUTPUT CHARACTER
;SKIP ONE WORD IF SUCESSFULL
MXGOC:	TST	TOQN(E)
	BLE	MXGOC4	;BR IF NO CHARS TO SEND
	CMP TOQO(E),#TOQM+4
	BLO	.+10	;BR IF OUTPUT PNTR NOT PAST END OF QUEUE
	MOV #TOQM,TOQO(E)
	SPUSH	E
	JSR F,TTYMPI
	MOVB	@TOQO(E),E	;GET NEXT TTY TO SEND STUFF FOR
	JSR F,TTYMPO
	JSR	PC,TOSOP	;START OUTPUT
	BR	.+2	;OUTPUT Q FULL
	JSR	PC,@TOGOC(E)	;GET OUTPUT CHAR
	BR	MXGOC3	;NO CHARS
	SPOP	E
	DEC	TOQN(E)	;DECREMENT MPXRS CHAR COUNT
	BR	.+4
MXGOC1:	SPOP	E
	INC	TOQO(E)	;INC MULTIPLEXOR'S POINTER
MXGOC5:	ADD	#2,@P	;SKIP RETURN
MXGOC2:	RTS	PC

;MULTIPLEXOR HAS CHARS TO SEND, BUT CURRENT MULTIPLEXEE DOESN'T
MXGOC3:	MOVB	OMXNUL(E),D	;RETURN NULL CHAR FOR MULTIPLEXEE
	BR	MXGOC1


;NO CHARACTERS FOR MULTIPLEXOR
MXGOC4:
	CMP TOQO(E),#TOQM
	BEQ MXGOC2
	MOV #TOQM,TOQO(E)
	MOVB	OMXRES(E),D	;SEND MULTIPLEXOR RESET CHARACTER
	BR	MXGOC5

;GET NEXT TTY OUTPUT CHARACTER
;SKIP ONE WD IF SUCCESSFUL
TYGOC:	BIT	#TIMAGE,TTYST(E)
	BNE	TYGOC1	;BR IF IN IMAGE MODE (DON'T PAD)
	TSTB	TOPAD(E)
	BGE	TYGOC4	;BR IF SOME PADDING LEFT
TYGOC1:	JSR	PC,TOOQ	;GET CHAR FROM OUTPUT BUFFER
	BR	TYGOC3	;BR IF BUFFER EMPTY
	BIT	#TIMAGE,TTYST(E)
	BNE	TYGOC2	;BR IF IN IMAGE MODE
	CMP	D,#15
	BNE	TYGOC2
	MOVB	TTYTP(E),TOPAD(E)	;IF CR, SET UP PADDING
TYGOC2:	ADD	#2,@P	;SKIP RETURN
TYGOC3:	RTS	PC
;SEND PADDING CHAR INSTEAD OF NEXT CHAR FROM QUEUE
TYGOC4:	CLR	D
	DECB	TOPAD(E)	;DEC # OF PADS
	BR	TYGOC2


;REMOVE CHAR FROM CIRCULAR OUTPUT QUEUE AND RETURN IT IN D
;SKIP ONE WORD IF SUCCESSFUL
TOOQ:	TST	TOQN(E)
	BLE	TOOQ2	;BR IF NOTHING IN Q
	JSR F,TTYMPI
	CMP TOQO(E),#TOQLM
	BLO TOOQ1
	MOV #TOQM,TOQO(E)
TOOQ1:	MOVB	@TOQO(E),D	;GET CHAR
	JSR F,TTYMPO
	INC	TOQO(E)	;INC PNTR
	DEC	TOQN(E)	;DEC CHARACTER COUNT
	ADD	#2,@P	;SKIP RETURN
TOOQ2:	RTS	PC

;TTY TRANSMIT INTERRUPT
;FIRST SEND CHARS IN OUTPUT Q
;THEN PROCESS CHARS IN INPUT Q
;CAN CLOBBER A&C
TYXMT:	BIC	#TOTRAN,TTYST(E)	;CLEAR XMT INT PENDING BIT
	BIT	#TIBR,TTYST(E)
	BNE	TYXMT4	;BR IF BREAKING
	JSR	PC,TOSOP	;START OUTPUT
	BR	TYXMT3	;OUTPUT BUFFER FILLED AGAIN
TYXMT1:	JSR	PC,TOPIC	;PROCESS CHARS FROM INPUT BUFFER
TYXMT3:		;ACTUALLY SEND CHARACTERS!!!
.IFG	NDMTY
	BIT	#TPDM,TTYTP(E)
	BNE	TYXMT5	;BR IF DM11 TTY
.ENDC
.IFG NTVS
	BIT #TPTV,TTYTP(E)
	BNE TYXMT6
.ENDC
	JSR	PC,@TOGOC(E)	;GET AN OUTPUT CHAR
	BR	TYXMT4	;NONE
	MOV	D,2(B)	;PUT CHAR IN DEVICES OUTPUT BUFFER
	BIS	#TOTRAN,TTYST(E)	;SET XMT INT PENDING FLAG
TYXMT4:	RTS PC
.IFG NTVS
TYXMT6:	JSR PC,TVSND
	RTS PC
.ENDC

;START OUTPUT
;SKIP RETURN IF OUTPUT BUFFER NOT FULL
TOSOP:
	CMP TOQN(E),#TOQSZ
	BGE	TOSOP2	;BR IF Q FULL
	TST	TOPC(E)	;DID WE EXIT FROM MIDDLE OF PROCESSING CHAR TO OUTPUT Q
	BEQ	TOSOP1	;BR IF NO
	MOV	TOSVC(E),C	;RESTORE MISC AC'S
	MOV	TOSVD(E),D
	SPUSH	TOPC(E)	;LOCATION TO JSR TO
	CLR	TOPC(E)
	JSR	PC,@(P)+	;CALL AS COROUTINE
	BR	TOSOP2	;OUTPUT Q FILLED AGAIN
TOSOP1:	ADD	#2,@P	;SKIP RETURN
TOSOP2:	RTS	PC


.IFG NDMTY
TYXMT5:	JSR	PC,DMSND	;TRANSMIT CHARS TO DM TTY
	RTS	PC

;TRANSMIT CHARS TO DM11 TTY
DMSND:	JSR	F,ACSAV
	CLR	A	;-WD CNT
	MOVB	TILTTY(E),U	;PHYSICAL TTY #
	MOV	DMBUF(U),B	;WHERE CHARS ACTUALLY SENT FROM
.IFZ DHON
	MOV	B,DMCA(U)
.IFF
	BIC #17,DH0SCR
	BIS DHNUMB(U),DH0SCR	;SET LINE NUMBER
	MOV B,DH0CAR	;SET THE ADDRESS
.ENDC
	MOV	#DMMAX,C	;MAX NUM OF CHARS TO SEND
DMSND1:	JSR	PC,@TOGOC(E)	;GET AN OUTPUT CHARACTER
	BR	DMSND2	;RETURN HERE IF NO CHARS
	MOVB	D,(B)+	;PUT CHAR IN BUFFER
	DEC	A	;-WD CNT
	DEC	C	;MAX NUM OF CHARS TO SEND
	BGT	DMSND1
DMSND2:	TST	A
	BGE	DMSND3	;BR IF NOTHING TO SEND
.IFZ DHON
	MOV	A,DMWC(U)
	BIS	DMBIT(U),DM0BAR	;TRANSMIT
.IFF
	MOV A,DH0BCR	;SET BYTE COUNT
	BIS DMBIT(U),DH0BAR	;START LINE UP
.ENDC
	BIS	#TOTRAN,TTYST(E)	;SET XMT INT PENDING FLAG
DMSND3:	JSR	F,ACRES
	RTS	PC
.ENDC
.IFNZ NTVS
;CHARACTER GENERATION MACRO
;ASSUMES INCREMENT SET TO 44
;SPECIAL INCREMENT OVERFLOW SET
;ADDRESS TO PUT CHAR IN B
;#TVRWIN IN C
;WRITE MODE SET TO IOR
;NUMBER OF CHARS LEFT ON LINE IN D
;NUMBER OF CHARACTERS IN BUFFER IN E
;CLOBBERS A
.MACRO TVCHAR SHIFT,MASK
	MOV B,TVRADR	;ADDRESS KEPT IN B
	.IFNB SHIFT
	.IFZ SHIFT
	CLR TVSHR
	.IFF
	MOV #SHIFT,TVSHR
	.ENDC
	.ENDC
	MOV #MASK,TVMSK
	.REPT 10.
	MOVB (A)+,(C)
	.ENDR
.ENDM

;ACTUAL CHARACTER GENERATOR, OPEN CODED FOR 8 CHARACTERS
CHAR0:	TVCHAR 10.,1777
	RTS PC
CHAR1:	TVCHAR 4.,176017
	RTS PC
CHAR2:	TVCHAR 14.,177760
	ADD #2,B
	SUB #12,A
	TVCHAR ,37777
	RTS PC
CHAR3:	TVCHAR 8.,140377
	RTS PC
CHAR4:	TVCHAR 2.,177403
	RTS PC
CHAR5:	TVCHAR 12.,177774
	ADD #2, B
	SUB #12,A
	TVCHAR ,7777
	RTS PC
CHAR6:	TVCHAR 6.,170077
	RTS PC
CHAR7:	TVCHAR 0.,177700
	ADD #2,B
	RTS PC
TVOUT:	JSR F,TVSAVE
	SPUSH PS
	SPL 7	;BECAUSE WE USE ONE OF THE SLOT PAGES
	SPUSH PUREAR+4
	SPUSH PUREDR+4
	MOV FONTAR,PUREAR+4
	MOV FONTDR,PUREDR+4
;SINCE THIS ROUTINE GETS CALLED EVERY TICK, WE WILL BLINK THE
;CURSORS HERE, SINCE THE WORLD IS SAVED
	MOV #NTVS,A
	MOV #NFTV,E
	MOV #44,TVINCR
BLNKLP:	TST TVBLNK(E)
	BEQ BLNKL1
	BLT BLNKL2
	DEC TVBLNK(E)
	BNE BLNKL1	;BLINKER IS ON AND IS STAYING ON
	MOV #-15.,TVBLNK(E)	;IT STAYS OFF FOR 1/4 SEC
BLNKL3:	JSR PC,BLINK	;TURN IT OFF
BLNKL1:	TST (E)+
	SOB A,BLNKLP
	BR BLNKL5
BLNKL2:	INC TVBLNK(E)	;BLINKER IS OFF
	BNE BLNKL1	;AND IT IS STAYING OFF
	MOV #15.,TVBLNK(E)
	BR BLNKL3	;TIME TO TURN IT ON
BLINK:	MOV E,C
	SUB #NFTV,C
	ASR C
	MOVB C,TVSEL	;SELECT CORECT CONSOLE
	BISB #TVXOR,TVSEL
	MOV #TVRWIN,C
	MOV TVCRLN(E),TVRADR
	MOV TVCRPS(E),F
	ASL F
	BIC #177761,F
	MOV TVCRM1(F),TVRWIN
	MOV #-8.,TVWC
	TST TVCRM2(F)
	BNE .+4
	RTS PC
	TST TVWC
	BNE .-4
	MOV TVCRLN(E),TVRADR
	ADD #2,TVRADR
	MOV TVCRM2(F),TVRWIN
	MOV #-8.,TVWC
	RTS PC

BLNKL5:	MOV #NFTV,U
TVOUT1:	MOV U,E
	JSR PC,TYXMT
	TST (U)+
	CMP #NFTV+<2*NTVS>,U
	BNE TVOUT1
	SPOP PUREDR+4
	SPOP PUREAR+4
	SPOP PS
	JSR F,TVREST
	RTS PC
TVSAVE:	TST (P)+
	TST TVWC
	BNE .-4
	SPUSH TVMSK
	SPUSH TVRADR
	SPUSH TVSEL
	SPUSH TVINCR
	SPUSH TVSHR
	SPUSH UBR
	JMP (F)

TVREST:	TST (P)+
	TST TVWC
	BNE .-4
	SPOP UBR
	SPOP TVSHR
	SPOP TVINCR
	SPOP TVSEL
	MOV #-1,TVMSK	;SO THAT WE CAN LOAD THE UBR
	MOV UBR,TVRWIN	;IF THE GUY KNOWS, HE WILL SET THIS
	SPOP TVRADR
	SPOP TVMSK
	JMP (F)
TVSND:	JSR F,ACSAV
TVSND1:	MOV #1044,TVINCR
	MOV E,A
	SUB #NFTV,A
	ASR A
	BIS #TVIOR,A
	MOVB A,TVSEL
TVSND3:	JSR PC,@TOGOC(E)
	BR TVSND4
	BIC #177600,D
	TST TVBLNK(E)
	BLE TVSND7	;BLINKER IS ALREADY OFF
	JSR PC,BLINK
	MOV #-15.,TVBLNK(E)
TVSND7:	MOV D,C
	ASL C
	MOV SMLFNT(C),A
	BEQ TVSND2	;SPECIAL CHARACTER
	ADD #SMLFNT,A
	MOV TVCRLN(E),B	;WHERE TO WRITE THE CHARACTER
	MOV #TVRWIN,C
	MOV TVCRPS(E),D	;ACTUALL CHARACTER NUMBER ON LINE
	ASL D
	BIC #177761,D
	JSR PC,@TVCJTB(D)
	MOV B,TVCRLN(E)
	INC TVCRPS(E)
	BR TVSND3
TVSND2:	CMP #40,D
	BLT TVSND3
	MOV TVSCJT(C),A
	BEQ TVSND3
	JSR PC,(A)
	BR TVSND1
TVSND4:	JSR F,ACRES
	RTS PC
TVNLSC==7
TVLF:	ADD #110*12.,TVCRLN(E)
	CMP #77660,TVCRLN(E)
	BHI .+10
	SUB #77660,TVCRLN(E)
	INC TVLINE(E)
	CMP TVLINE(E),TVHIGH(E)
	BLT TVLF1
	ADD #TVNLSC*11*12.,TVSCRL(E)
	CMP #7766,TVSCRL(E)
	BGT .+10
	SUB #7766,TVSCRL(E)
	MOV TVSCRL(E),F
	BIS #10000,F
	MOV F,TVCNSL
	SUB #TVNLSC,TVLINE(E)
	MOV #TVNLSC-1,F
	SPUSH TVCRLN(E)
TVLF2:	JSR PC,TVCEOL
	ADD #110*12.,TVCRLN(E)
	CMP #77660,TVCRLN(E)
	BHI .+10
	SUB #77660,TVCRLN(E)
	SOB F,TVLF2
	SUB #110*2,TVCRLN(E)
	BGE .+10
	ADD #77660,TVCRLN(E)
	JSR PC,TVCEOL
	SPOP TVCRLN(E)
TVLF1:	RTS PC
TVSPF:	INC TVCRPS(E)
	MOV TVCRPS(E),A
	ASL A
	BIC #177761,A
	ADD TVSPFK(A),TVCRLN(E)
TVSPF1:	RTS PC
TVSPB:	TST TVCRPS(E)
	BEQ TVSPF1
	MOV TVCRPS(E),A
	ASL A
	BIC #177761,A
	SUB TVSPFK(A),TVCRLN(E)
	DEC TVCRPS(E)
	RTS PC
TVSPBE:	JSR PC,TVSPB
	TST (A)+
	BIC #20,A
	BIC #300,TVSEL
	MOV TVCRLN(E),TVRADR
	MOV TVCRM1(A),TVMSK
	CLR UBR
	CLR TVRWIN
	MOV #-8.,TVWC
	TST TVCRM2(A)
	BNE .+4
	RTS PC
	TST TVWC
	BNE .-4
	MOV TVCRM2(A),TVMSK
	MOV #-9.,TVWC
	TST TVWC
	BNE .-4
	RTS PC
TVSPU:	SUB #110*12.,TVCRLN(E)
	BGE .+10
	ADD #77660,TVCRLN(E)
	RTS PC
TVSPDN:	ADD #110*12.,TVCRLN(E)
	CMP #77660,TVCRLN(E)
	BHI .+10
	SUB #77660,TVCRLN(E)
	RTS PC
TVCR:	CLR TVCRPS(E)
	MOV TVCRLN(E),B
	CLR A
	DIV #110,A
	MUL #110,A
	MOV B,TVCRLN(E)
	RTS PC
TVCEOL:	BIC #300,TVSEL
	CLR TVMSK
	MOV TVCRLN(E),B
	CLR A
	DIV #110,A
	TST B
	BNE TVCEO1
	MOV TVCRLN(E),TVRADR
	MOV #1001,TVINCR
	CLR UBR
	CLR TVRWIN
	MOV #-12.*36.-1,TVWC
	TST TVWC
	BNE .-4
	RTS PC
TVCEO1:	MOV B,A
	BIC #177761,B
	MOV TVEOLM(B),B
	MOV #12.,C
	MOV TVCRLN(E),TVRADR
	MOV #1044,TVINCR
	BIC B,TVRWIN
	SOB C,.-4
	SUB #106,A
	BEQ TVCEO2
	CLR TVINCR
	MOV TVCRLN(E),B
	ADD #2,B
	MOV B,TVRADR
	MOV #12.,C
	ASR A
	CLR UBR
	CLR TVRWIN
	MOV #1001,TVINCR
TVCEO3:	MOV A,TVWC
	ADD #110,B
	TST TVWC
	BNE .-4
	MOV B,TVRADR
	SOB C,TVCEO3
TVCEO2:	RTS PC

.ENDC

;PROCESS CHARS IN INPUT BUFFER
TOPIC1:	INC	TIQTO(E)	;INC CHAR PNTR
	DEC	TIQTON(E)	;DEC CHAR COUNT
	JSR	PC,TOIEC	;ECHO CHAR
TOPIC:	TST	TOPC(E)
	BNE	TOICM4	;IF OUTPUT BUFFER FULL, GO AWAY
	TST	TIQTON(E)
	BLE	TOICM4	;NO CHARS LEFT
	JSR F,TTYMPI
	MOVB	@TIQTO(E),D	;GET NXT CHAR
	JSR F,TTYMPO
	BR TOPIC1

;^M POSSIBLE END OF LINE
TOICM:	BIT	#TILIPM,TTYST(E)
	BEQ	TOICM3	;BR IF NOT IN LINE INPUT MODE
	TST	TIBC(E)
	BGT	TOICM3	;BR IF INSIDE BRACKETS
	INC	TIQTO(E)
	DEC	TIQTON(E)
	JSR	PC,TOIEC	;ECHO CHAR
	JSR PC,TYINQ
	SPUSH	A
	SPUSH	B
	SPUSH	C
	JSR F,TTYMPI
	MOV TIQI(E),A
	MOV #TITQ,B
	INC B
	MOV TIQN(E),C
	MOV C,TIEQN(E)
	MOVB -(A),-(B)
	SOB C,.-2
	JSR F,TTYMPO
	MOV B,TIEQO(E)
	SPOP	C
	SPOP	B
	SPOP	A
	JSR	PC,TYIRT	;RESET INPUT BUFFER
	MOV TIEQN(E),TIEQTN(E)
	MOV TIEQO(E),TIEQTO(E)
	SPUSH	U
	MOV	TTYU(E),U
	CLR	FLSRES(U)	;RUN THE GUY
	SPOP	U
	MOV #TICP5,(P)
	JSR PC,TOCINT
	SEZ
TOICM4:	RTS	PC
TOICM3:	CLZ	;NOT REALLY SPECIAL
	RTS PC

;^Y EDIT PREVIOUS LINE
TOICY:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^Y?
	JSR	PC,TOIECS	;IF NO, JMP HERE, ECHO ^Y
	MOV	#15,D
	JSR	PC,TOIECS	;ECHO CR
	MOV	#'_,D
	JSR	PC,TOIEC	;ECHO _
	BIS	#TIEDM,TTYST(E)	;PUT TTY IN EDIT MODE
	SEZ
	RTS	PC

;^X CLARIFY INPUT
;TYPE CR, REST OF EDIT BUFFER, CR, INPUT BUFFER
TOICX:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^X?
	MOV	#15,D	;NO
	BIT	#TIEDM,TTYST(E)
	BEQ	TOICX2	;BR IF NOT EDITING
	TST	TIEQN(E)
	BLE	TOICX2	;BR IF NOTHING IN EDIT BUFFER
	MOV	TIEQO(E),B
TOICX1:	JSR	PC,TOIECS	;ECHO CHAR IN D (SKIPS LEVEL IF Q FULL)
	JSR F,TTYMPI
	MOVB	(B)+,D	;GET NEXT EDIT CHAR
	JSR F,TTYMPO
	CMP B,#TITQ
	BLO	TOICX1	;BR IF STILL CHARS TO PRINT
	BHI	TOICX5	;BR IF JUST PRINTED LAST CHAR
	CMP	D,#15
	BNE	TOICX1	;LAST CHAR NOT CR, PRINT IT, THEN PRINT CR.
TOICX5:	MOV	#15,D
TOICX2:	TST	TIQN(E)
	BLE	TOICX4
	MOV #TIQM,B
TOICX3:	JSR	PC,TOIECS
	JSR F,TTYMPI
	MOVB	(B)+,D
	JSR F,TTYMPO
	CMP	B,TIQTO(E)
	BLOS	TOICX3	;BR IF MORE INPUT CHARS TO PRINT
TOICX4:	SEZ
	RTS PC


;ECHO CHAR FROM SPECIAL INPUT CHAR SUBR
TOIECS:	SPUSH	A
	JSR	PC,TOIEC	;ECHO
TOIES1:	SPOP	A
	TST	TOPC(E)
	BEQ	TOIECR
	MOV	(P)+,TOIPC(E)	;WHERE TO RETURN TO
	MOV	A,TOISVA(E)	;SAVE AC A
TOIECR:	RTS	PC

;ECHO RUBBED OUT CHAR
TOIRCS:	SPUSH	A
	JSR	PC,TOPRB
	BR	TOIES1

;ENTER SUBR THAT TOIECS EXITED
TOIENT:	TST	TOIPC(E)
	BEQ	TOIEN1
	MOV	TOIPC(E),@P	;RETURN HERE INSTEAD OF CALLING ROUTINE
	CLR	TOIPC(E)
	MOV	TOISVA(E),A
TOIEN1:	RTS	PC

;^C COPIES NEXT CHAR FROM EDIT QUEUE TO TYI QUEUE
TOICC:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICC1	;BR IF NOT IN EDIT MODE
	JSR PC,TOICN4
TOICC1:	SEZ
	RTS PC


;^N COPIES NEXT WORD FROM EDIT TO TYI Q

TOICN:	BIT #TIEDM,TTYST(E)
	BEQ TOICN3
TOICN5:	JSR PC,TOICN4
	BEQ TOICN3
	JSR PC,TOISWS
	BEQ TOICN5
TOICN3:	SEZ
	RTS PC

TOICN4:	JSR PC,TOGED
	BEQ TOICN3
	JSR F,TTYMPI
	MOVB D,@TIQI(E)
	JSR F,TTYMPO
	JSR PC,TIBCK
	INC TIQN(E)
	INC TIQI(E)
	INC TIQTON(E)
	RTS PC

TIBCK:	CMP D,#'[
	BNE .+6
	INC TIBC(E)
	CMP D,#']
	BNE .+6
	DEC TIBC(E)
	CMP D,#'{
	BNE .+6
	INC TIBC(E)
	CMP D,#'}
	BNE .+6
	DEC TIBC(E)
	RTS PC


;^R COPY REST OF EDIT BUFFER TO INPUT BUFFER
TOICR:	BIT	#TIEDM,TTYST(E)
	BEQ	TOICC1	;BR IF NOT IN EDIT MODE
TOICR1:	JSR PC,TOICN4
	BEQ TOICC1
	BR TOICR1



;SKIP IF CHAR IN D IS WD SEPERATOR
TOISWS:	TSTB	D
	BMI	TOISW1	;BR IF QUOTED (HIGH BIT ON)
	BITB	#WSF,DTBL(D)
TOISW1:	RTS PC

;^D DELETES NEXT CHAR FROM EDIT QUEUE
TOICD:	BIT	#TIEDM,TTYST(E)
	BEQ	TOISW1	;BR IF NOT IN EDIT MODE
	JSR	PC,TOGED	;GET NXT EDIT CHAR
	BEQ TOISW1
	JSR PC,TOPRB	;ECHO RUBBED OUT CHAR
TOICD1:	SEZ
	RTS PC


;^S SKIPS NXT WD IN EDIT QUEUE
TOICS:	BIT #TIEDM,TTYST(E)
	BEQ TOICD1
TOICS1:	JSR PC,TOGED
	BEQ TOICD1
	JSR PC,TOPRB
	JSR PC,TOISWS
	BNE TOICD1
	BR TOICS1


;^Q HAD EFFECT ON INPUT, DELETE FROM Q & ECHO
TOICQ:	JSR PC,TICQ
	JSR PC,TOIECS	;ECHO ^Q
	SEZ
	RTS PC
	
;RUBOUT RUBS OUT PREVIOUSLY PROCESSED CHAR
TOIRB:	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW2	;FAIL
	JSR	PC,TOPRB	;PRINT RUBBED OUT CHAR
	JSR	PC,TOIBCK	;CHECK FOR RUBBED OUT [ OR ]
	JSR PC,TOIOWP	;OVERWRITE RUBBED OUT CHAR
	SEZ
	RTS PC

TOICW2:	BIC	#TIRBM,TTYST(E)	;CLEAR RUB OUT MODE FLAG
	MOV	#15,D	;ECHO A C.R.
	JSR PC,TOIEC
	SEZ
	RTS PC

;^W RUBS OUT PREVIOUS WD
TOICW:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^W?
	JSR	PC,TOIQP	;NO, GET PREVIOUS CHAR
	BEQ	TOICW2	;FAIL
TOICW1:	JSR	PC,TOIBCK	;CHECK FOR BRACKET
	JSR	PC,TOIRCS	;PRINT CHAR
	JSR	PC,TOIOWP	;BLT OVER CHAR
	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW2
	JSR	PC,TOISWS	;SKIP IF WD SEPERATOR
	BEQ	TOICW1
TOICW3:	SEZ
	RTS PC

;[ INCS BRACKET COUNT
TOIOB:	INC TIBC(E)
	BGE	TOICB2
	BPT	;-BRACKETS
	BR TOICB2

;] DECS BRACKET COUNT IF THERE ARE ANY
TOICB:	TST	TIBC(E)
	BLE	TOICW3	;NO BRACKETS, IGNORE
	DEC	TIBC(E)	;DEC COUNT
TOICB2:	CLZ
	RTS PC


;GET PREVIOUS CHARACTER IN INPUT BUFFER AND SKIP
TOIQP:	SPUSH	A
	MOV	TIQTO(E),A	;GET POINTER TO CURRENT CHARACTER
	DEC A
	CMP A,#TIQM
	BLO	TOIQP1	;BR IF NO PREVIOUS CHARACTER
	JSR F,TTYMPI
	MOVB	(A),D
	JSR F,TTYMPO
	SPOP	A
	CLZ
	RTS PC
TOIQP1:
	SPOP	A
	SEZ
	RTS	PC

;CHECK FOR RUBBED OUT [ & ]
TOIBCK:	CMP	D,#'[
	BNE	.+6
	DEC	TIBC(E)	;IF CHAR WAS [, DECREMENT BRACKET COUNT
	CMP	D,#']
	BNE	.+6
	INC	TIBC(E)	;IF RUBBED OUT A ], INC BRACKET COUNT
	CMP D,#'{
	BNE .+6
	DEC TIBC(E)
	CMP D,#'}
	BNE .+6
	INC TIBC(E)
	RTS	PC

;OVERWRITE PREVIOUS CHARACTER
TOIOWP:	DEC TIQTO(E)
	DEC TIQN(E)
	DEC TITQN(E)
	DEC TIQI(E)
	RTS PC

;GET NEXT CHAR FROM EDIT BUFFER INTO D AND SKIP IF SUCCESSFUL
TOGED:	TST	TIEQN(E)
	BLE	TOGED2-2	;BR IF NOTHING LEFT IN EDIT BUFFER
	DEC	TIEQN(E)	;DEC CHAR COUNT
	JSR F,TTYMPI
	MOVB	@TIEQO(E),D	;GET NEXT CHAR
	JSR F,TTYMPO
	INC	TIEQO(E)
	CMP	D,#'[
	BNE	.+6
	INC	TIEBC(E)	;CHAR WAS [
	CMP	D,#']
	BNE	.+6
	DEC	TIEBC(E)	;CHAR WAS ]
	CMP D,#'{
	BNE .+6
	INC TIEBC(E)
	CMP D,#'}
	BNE .+6
	DEC TIEBC(E)
	CMP	D,#15
	BNE	TOGED2	;NOT A CR
	TST	TIEBC(E)	;CR, TEST FOR END OF EDIT LINE
	BGT	TOGED2
	CLR	TIEQN(E)	;EOL, CLR THIS TO BE XTRA CAREFUL
	SEZ
TOGED2:	RTS	PC


;PRINT RUBBED OUT CHAR IN D ON E'S TTY
TOPRB:	BIT	#TIECM,TTYST(E)
	BEQ	TOGED2	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(E)
	BNE	TOIEC2	;ALREADY IN RUBOUT MODE
	BIS	#TIRBM,TTYST(E)
	BR	TOIEC1	;TYPE OPENING \


;ECHO CHARACTER IN D ON E'S TTY
TOIEC:	BIT	#TIECM,TTYST(E)
	BEQ	TOTYC1	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST(E)
	BEQ	TOIEC2	;ALREADY NOT IN RUBOUT MODE
	BIC	#TIRBM,TTYST(E)
	;PRINT CLOSING \
;PRINT \:
TOIEC1:	MOV	D,C	;SAVE CHAR
	MOV	#'\,D
	JSR	PC,TOCINQ	;PUT \ INTO OUTPUT Q
	JSR	PC,TOEXT	;FILLED UP Q
	MOV	C,D	;RESTORE CHAR
TOIEC2:		;PRINT CHAR IN D

;FALLS THROUGH!!!
;FALLS IN!!!

;PROCESS CHAR IN D INTO TTY IN E'S OUTPUT BUFFER
;IF BUFFER FILLS SAVE ACS C,D,PC AND EXIT
TOTYO:	BIT	#TIMAGE,TTYST(E)
	BEQ	TOTYO1	;BR IF NOT IN IMAGE MODE
TOTYOC:	JSR	PC,TOINQ	;PUT CHAR IN OUTPUT BUFFER
	JSR	PC,TOEXT
	RTS PC

TOTYO1:	MOVB	D,C
	BMI	TOTYOC	;BR IF CHAR HAS IMAGE MODE BIT SET
	BITB	#FOF,DTBL(C)
	BNE	TOTYO3	;BR IF SPECIAL ON OUTPUT
	CMP	D,#40
	BLT	TOTYO4	;BR IF CONTROL CHAR
	JSR	PC,TOCINQ
	JSR	PC,TOEXT
TOTYO2:	JMP	TOCLTO	;CHECK FOR LINE TOO LONG

;SPECIAL ON OUTPUT
TOTYO3:	MOVB	DTBL2(C),C
	JMP	@TOOCTB(C)
;CONTROL CHAR
TOTYO4:	MOV	#'^,D
	JSR	PC,TOCINQ	;PRINT ^
	JSR	PC,TOEXT
	MOV	C,D
	ADD	#100,D
	JSR	PC,TOCINQ	;PRINT CHAR +100
	JSR	PC,TOEXT
	MOV	C,D
	BR	TOTYO2

;OUTPUT BUFFER FULL, SAVE STATE OF WORLD AND RETURN ONE LEVEL UP
TOEXT:	MOV	C,TOSVC(E)
	MOV	D,TOSVD(E)
	MOV	(P)+,TOPC(E)
TOTYC1:	RTS	PC

;^A PRINTS AS CR
TOOCA:	CLR	CHARNO(E)
	MOV	#15,D
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	MOV	#1,D
	RTS	PC

;^H BACKSPACE DECREMENTS CHARNO IF NOT AT BEGINNING OF LINE
TOOCH:	TST	CHARNO(E)
	BLE	TOOCH1
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	DEC CHARNO(E)
TOOCH1:	RTS	PC

;CHECK IF LINE TOO LONG, IF SO PRINT CRLF
TOCLTO:	CMP	CHARNO(E),LINEL(E)
	BLT	TOOCM1	;BR IF NOT TOO LONG
;^M PRINTS AS CR LF
TOOCM:	MOV	D,C	;SAVE D
	CLR	CHARNO(E)	;CLR CHAR COUNT
	MOV	#15,D
	JSR	PC,TOINQ	;PRINT CR
	JSR	PC,TOEXT
	MOV	#12,D
	JSR	PC,TOINQ	;PRINT LINEFEED
	JSR	PC,TOEXT
	MOV	C,D
TOOCM1:	RTS	PC

;^I PRINTS SPACES TILL NEXT TAB STOP
TOOCI:	MOV	D,C
	MOV	#40,D
TOOCI1:	JSR	PC,TOCINQ
	JSR	PC,TOEXT
	BIT	#7,CHARNO(E)
	BNE	TOOCI1
	MOV	C,D
	RTS	PC

;*** INTERRUPT AND USER LEVEL ***

;PUT CHAR IN D INTO TTY IN E'S CIRCULAR OUTPUT QUEUE
;SKIP TWO WORDS IF SUCESSFULL
TOCINQ:	INC	CHARNO(E)
TOINQ:
	CMP TOQN(E),#TOQSZ
	BGE TOINQ2
	CMP TOQI(E),#TOQLM
	BLO TOINQ1
	MOV #TOQM,TOQI(E)
TOINQ1:	JSR F,TTYMPI
	MOVB	D,@TOQI(E)	;PUT CHAR IN BUFFER
	JSR F,TTYMPO
	INC	TOQI(E)
	INC	TOQN(E)	;INC # OF CHARS IN OUTPUT BUFFER
	SPUSH	E
	MOVB	MXNUM(E),E	;GET THIS TTY'S MULTIPLEXOR
	BMI	TOINQ4	;BR IF NOT PSEUDO OR MULTIPLEXED TTY
	INC	TOQN(E)	;INC MULTIPLEXOR'S CHARACTER COUNT
TOINQ4:	SPOP	E
	CMP TOQN(E),#TOQSZ
	BGE	TOINQ3	;BR IF Q FILLED NOW
	ADD	#4,@P	;SKIP RETURN TO SUCESS
TOINQ3:	RTS	PC

TOINQ2:
;	BPT	;TRIED TO PUT CHAR IN OUTPUT Q WHEN ALREADY FULL
	RTS	PC	;RETURN TO FAILURE
.STITL TELETYPE INITIALIZATION CODE
;INITIALIZATION CODE
TINIT:
;DECIDE WHICH PORTS TO USE & SET UP LOGICAL VARIABLES
	MOV	#NPORTS,A
	CLR	B	;INDEX TO PHYS TABLES
TINIT1:	MOVB	TILTTY(B),C	;LOGICAL INDEX
	BMI	TINIT2	;NOT LOGICAL
	MOVB	B,TIPTTY(C)	;PHYS TTY #
	MOVB	TILTTY+1(B),TIPTTY+1(C)	;MPXR #
	MOV	TYPTYP(B),TTYTP(C)
	MOV	TYRS(B),TOTSR(C)	;RCV RG ADDR
	BIT	#TPDM!TPTV,TTYTP(C)
	BNE	.+10	;BR IF DM11
	ADD	#4,TOTSR(C)	;TRANS RG ADDR
	BIT	#TPMPX,TTYTP(C)
	BEQ	TINIT2	;BR IF NOT MPXR
	MOV	#MXRCV,TIRCV(C)	;RCV DISPATCH ADDR
	MOV	#MXGOC,TOGOC(C)	;TRANS DISPATCH ADDR
	SPUSH	A
	SPUSH	B
	MOV	#4,A	;# OF MPXED DEVICES
	MOV #TOQM,D
	MOV C,E
	JSR F,TTYMPI
TINIT4:	TST	(B)+
	MOVB	TILTTY(B),(D)+	;PUT #'S OF MULTIPLEXEES IN OUTPUT Q
	SOB	A,TINIT4
	JSR F,TTYMPO
	SPOP	B
	SPOP	A
TINIT2:	TST	(B)+
	SOB	A,TINIT1

;DECIDE WHICH ARE USER TTYS
	MOV	NUSERS,A
	MOV	#UTYTB,B
	CLR	E
	CLR	U
TINIT3:	MOV	(B)+,E	;INDEX OF NEXT USER TTY
	TST	TTYU(E)
	BMI	.+4
	BPT	;ALREADY BELONGS TO A USER
	MOV	U,TTYU(E)
	MOV	E,UTTY(U)
	JSR	PC,TTYRT	;RESET (INITITALIZE) BUFFERS
	JSR	PC,UCINIT	;INITIALIZE CONSOLE VARIABLES
	ADD	#LUBLK,U
	SOB	A,TINIT3
	MOV	#SYSIDX,TTYU+NFTBOX	;MAKE SYS TBOX USER
	MOV	#TTYI,ITYI	;SET UP NEW USER TYI &TYO ADDRS
	MOV	#TTYO,ITYO
	JSR	PC,TINITH	;INIT HARDWARE
	JMP	NEXTUS
TTYMPI:	SPUSH TEMPAR
	SPUSH TEMPDR
	MOV #TTYDR,TEMPDR
	MOV TTYAR(E),TEMPAR
	SPUSH F
	MOV 4(P),F
	RTS PC

TTYMPO:	TST (P)+
	SPOP TEMPDR
	SPOP TEMPAR
	RTS F

;DON'T FORGET TBOXES
;HARDWARE INITIALIZATION
TINITH:	
.IFNZ NTY
	MOV	#100,TKS	;CONSOLE TTY
	MOV	#100,TPS
.ENDC
.IFNZ AI
	MOV	#111,DC0RS
	MOV	#113,DC0TS
.ENDC
.IFNZ GUY
	MOV #121,DC0RS
	MOV #123,DC0TS
.ENDC
	MOV	OMXRES+DC0TBN,DC0TB	;SLIGHT KLUGE, RESET TBOX
.IFZ DHON
	MOV	#DMCA+NFDMTY,DM0TBR
	MOV	#DMTT,TTP
	MOV	#10101,DM0CSR
.IFF
	MOV #20,A	;SET ALL LINES TO 300 BAUD
	CLR DH0SCR	;START AT ZERO
TINITX:	.IIF NZ AI,	MOV #16722,DH0LPR
.IIF NZ GUY,	MOV #6326,DH0LPR
	INC DH0SCR
	SOB A,TINITX
	CLR DH0SSR	;INTERUPT ON > 0 CHARS
	MOV #30100,DH0SCR
.ENDC
.IFNZ NTVS
	MOV #NTVCHN*400-400+16,A
TINITV:	MOV A,VIDSW
	SUB #400,A
	BGE TINITV
	CLR TVSEL
	MOV #NFTV,A
	MOV #1,TVINCR
TINITC:	MOV #90.,LINEL(A)
	TST (A)+
	SPL 7
	CLR TVRWIN
	CLR TVWC
	SPL 0
	TST TVWC
	BNE .-4
	MOV #10000,TVRWIN+2
	SPL 7
	INC TVSEL
	CMPB #NTVS,TVSEL
	BNE TINITC
	CLR TVSEL
	SPL 0
	.ENDC
	RTS	PC

;CROCKS

DMSQ:TI2Q:	RTS	PC

DC0SND:TB0SND:
	BPT
	RTS	PC

.STITL LOSS CHECKING ROUTINES
	FOO==%FNAM2
	VERN==VERN+%FNAM2


PARBRK:	BPT
	RTT
IOTBRK:	TST USER
	BLT BADTRP
	CMP P,#SPDLP
	BLOS BADTRP
	BIT #340,6(P)
	BNE BADTRP
	CLR PS
	SPUSH A
	CMP -(P),-(P)	;FOOL PRBTRP
	JSR	PC,PRBTRP
	CMP (P)+,(P)+
	SPOP A
	CLR ERPROC
	TST DEBSW
	BEQ IOTBR2
	SPUSH E
	MOV USER,E
	MOV UTTY(E),E
	TST TOTN(E)	;WAIT UNTIL THROUGH PRINTING
	BGT .-4
	SPOP E
	BPT	;BREAK IF DEBUGGING
IOTBR2:	.BUG.
BADTRP:	INC LOSSCT
	BEQ LOSER
	BGT LOST
	JSR	A,SPRINT	;ON SYS CONSOLE
	JSR	PC,PRBTRP	;PRINT MESSAGE
	SPREND
	CMP	(SP)+,(SP)+
	BPT
	RTT

EMTBRK:	BPT
LOSER:	PRTXT ^/I GIVE UP!/
LOST:	BPT
	BR .-2

PRBTRP:	BPRTXT ^/BAD TRAP: VECTOR /
	MOV 10(SP),A
	SUB #4,A	;MAKE IT REAL
	JSR PC,PRON
IOTBR1:	PRTXT ^/ TRAPPED FROM /
	MOV 14(SP),A
	JSR PC,PRON
	PRCR
	RTS	PC

SIMBPT:	HALT	;BPT TRAPS HERE IN SIMULATOR
	RTT
BEBRK:	TST P
	BEQ STKSRW
	SPUSH PS
	SPUSH #10
	BR IOTBRK	;FAKE AN IOT FROM LOC 6
STKSRW:	MOV #PFPDL,P	;HELP, I NEED A STACK!
	TST USER	;WAS IT IN USER CODE?
	BLT SYSSTK	;UGH, NO!
	BIT #340,2	;WAS IT IN AN INTERUPT ROUTINE?
	BNE SYSSTK	;UGH, YES!
	MOV #TYO,PCHR	;JUST THE USER LOSES
	JSR PC,STKCLB	;TELL HIM
	MOV UPDLP,P	;TRY TO RECOVER (UGH!)
	.BUG.
SYSSTK:	JSR PC,SPRINT	;MAKE IT PRINT ON SYS CONSOLE
	PRTXT ^/SYSTEM /
	JSR PC,STKCLB
	SPREND
	BPT
	SPL 0
	MOV #SPDLP,P	;IF THIS EVER WORKS
	JMP NEXTUS	;I'LL BE AMAZED

STKCLB:	PRTXT ^/STACK COLOBBERED AT /
	MOV 0,A
	JSR PC,PRON
	MOV #3,0
	MOV #-1,2
	JMP .CRLF
.HALT:	JSR PC,CKSST
	SPOP A
	SPUSH #0
	SPUSH A

PWRDWB:	JSR F,ACSAV
	JSR F,DEVSAV
	MOV #PWRUPB,PFBRV
	RESET
	HALT

PWRUPB:	JSR F,DEVRES
	JSR F,ACRES
	MOV #BEBRK,BEBRV
	MOV #PWRDWB,PFBRV
PWFNXM:
	RTT
PWRCLR:	JSR F,DEVSAV
	RESET
	RESET
	JSR F,DEVRES
	MOV #BEBRK,BEBRV
	SEZ
	RTS PC

DEVCLR:
	.IFNZ NDISP
	MOV #DISREL,NGREL
	.ENDC
	JSR PC,SEGSET
	MOV #100,LKS
	MOV #1666.,PCSTBF
	MOV #111,PCS
	JSR PC,TINITH
	MOV #100000,DKNRTY
	MOV #30.,DKPWFR
	MOV DSKCRB,A
	BEQ NODISK
	CMP #-1,10(A)
	BEQ RKREST
	JSR PC,DSKSG1
	BR NODISK
RKREST:	JSR PC,RKSG1
NODISK:	RTS PC
DEVSAV:	TST (P)+	;FLUSH SAVED F
	MOV #PWFNXM,BEBRV
	MOV SP,PFPDL
	MOV #PFPDL,SP
	SPUSH PPS
	.IFZ DHON
	.IFNZ NDM
	SPUSH DM0BAR
	.ENDC
	.ENDC
	SPUSH SSR0
	SPUSH PUREAR
	SPUSH PUREAR+2
	SPUSH PUREAR+4
	SPUSH TEMPDR	;THESE ARE THE SAME AS DISPAR+DR IF NEWDIS=1
	SPUSH TEMPAR
	MOV P,PWFPDL
	JMP (F)
DEVRES:	MOV PWFPDL,P
	JSR PC,DEVCLR
	SPOP TEMPAR
	SPOP TEMPDR
	SPOP PUREAR+4
	SPOP PUREAR+2
	SPOP PUREAR
	SPOP SSR0
	.IFZ DHON
	.IFNZ NDM
	SPOP DM0BAR
	.ENDC
	.ENDC
	SPOP PPS
	SPOP SP
	JMP (F)
	.STITL DISK STARTER

DSKSRT:
	MOV #SYSWPR,A	;LOOK FOR MOVING HEAD REQESTS
RKSR1:	BIT #100,14(A)
	BEQ RKSR2
	CMP #-1,10(A)
	BEQ RKSGO
RKSR2:	ADD #16,A
	CMP #16*MNUSRS+SYSWPR,A
	BHI RKSR1
	MOV #SYSWPR,A	;NEXT LOOK AT SYSTEM REQUESTS
DSKSR1:	BIT #100,14(A)
	BNE DSKSGO	;FOUND A REQUEST, GO DO IT
	ADD #16,A	;LOOK AT NEXT BLOCK
	CMP #16*MNUSRS+SYSWPR,A	;LAST BLOCK?
	BHI DSKSR1
	MOV SWPLST,A	;MOOBY SWAP OUT REQS?
	BNE DSKSGO
	RTS PC	;NO DISK REQUESTS EXTANT, BETTER LUCK NEXT TIME

DSKSGO:	MOV DKNRTY,DKRTYS	;SET NUMBER OF POSSIBLE RETRYS
	MOV A,DSKCRB	;ADDRESS OF BLOCK ABOUT TO BE SERVICED
	MOV (A),B
	BEQ DSKSG1	;BRANCH IF NO
	JSR PC,(B)	;RUN START ROUTINE
DSKSG1:	TST (A)+
	BIT #FDSCMS,4(A)
	BEQ .+6
	JMP DBLECH
	MOVB 12(A),B
	BIC #70,B
	CMPB #DREADC,B
	BEQ DSKSG2
	BIT #FDSCMS,(A)
	BNE DBLECH
DSKSG2:	MOV #DSKS,B	;START OF DISK I/O WORDS
	MOV #400,(B)+
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
.IFNZ MVONLY
	MOV C,-(P)
	MOV D,-(P)
	MOV (A)+,D
	MOV (A)+,C
	ASHC #-8.,C
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
.IIF Z GUY,.IIF Z SITSD,.IIF Z RAF,ADD #20000,D
.IIF NZ GUY,ADD #20000,D
	MOV D,(B)+
	MOV (P)+,D
	MOV (P)+,C
	MOV PC,FIXFAK
.IFF
	MOV (A)+,(B)+	;LOW ORDER DISK ADDRESS
	MOV (A)+,(B)+	;HIGH "      "     "
.ENDC
	TST (A)+	;GO PAST UNUSED WORD
	MOV #DSKS,DSKRUN
	MOVB (A),B
.IIF NZ DSKCHK,	JSR PC,DSKGNR
	MOV B,DSKS	;SET FUNCTION, ENABLE INTERUPT, GO!!
	RTS PC

RKSGO:	MOV DKNRTY,DKRTYS
	MOV A,DSKCRB
	MOV (A),B
	BEQ RKSG1
	JSR PC,(B)
RKSG1:	CLR FIXFAK
	TST (A)+
	MOV #RKWC,B
	MOV (A)+,(B)+	;WORD COUNT
	MOV (A)+,(B)+	;CORE ADDRESS
	MOV (A)+,(B)+	;DISK ADDRESS
	CMP (A)+,(A)+	;UNUSED WORDS
	MOV #RKCS,DSKRUN
	MOVB (A),B
.IIF NZ MVONLY,.IIF NZ DSKCHK, JSR PC,DSKGNR
	MOV B,RKCS
	RTS PC

DPROVK:	BIS #100,@DSKRUN
	RTS PC


.IFNZ DSKCHK
.IIF NZ GUY,DAMSK==37
.IIF NZ AI,DAMSK==17
DSKGNR:	JSR F,ACSAV
.IIF Z MVONLY,	MOV DSKWC,F	;THE NUMBER OF WORDS
.IIF NZ MVONLY,	MOV RKWC,F
	NEG F		;MAKE IT POSITIVE
	MOV F,D
.IFZ MVONLY
	MOV DSKAE,E	;THE DISK EXTENTION
	BIC #177740,E	;CLEAR ALL BUT THE TRACK EXT.
	ADD #DAMSK,D
	BIC #DAMSK,D
	ADD DSKA,D	;THE DISK ADDRESS
	BCC .+4
	INC E
	MOV D,DKSDA	;THIS IS WHAT THE DISK ADRESS SHOULD BE WHEN DONE
	MOV E,DKSAE	;THIS IS WHAT THE TRACK EXT. SHOULD BE
	MOV DSKCA,E	;GET THE CORE ADDRESS
.IFF
	ADD #377,D	;ROUND IT UP
	CLR C		;FOR THE DIVIDE
	ASH #-8.,D	;GET THE NUMBER OF SECTORS
	BIC #177400,D	;CLEAR THE TOP BYTE
	DIV #12.,C	;GET THE NUMBER OF TRACKS, AND SECTORS
	ASH #4,C	;PUT THE NUMBER OF TRACKS IN THE CORRECT PLACE
	MOV RKDA,B	;GET THE DISK ADDRESS
	ADD B,C		;GET TOTAL NUMBER OF TRACKS
	BIC #17,C	;CLEAR THE SECTORS IN THE TRACK ADDRESS
	BIC #177760,B	;THE NUMBER OF SECTORS
	ADD B,D		;GET FINAL SECTOR NUMBER
	CMP D,#14	;IS IT TO LARGE
	BLT .+6		;NO
	ADD #4,D	;SUBTRACT 14 AND ADD 20 TO TRACK
	ADD D,C		;GET THE TOTAL FINAL DISK ADDRESS
	MOV C,DKSDA	;THIS IS WHAT THE DISK ADDRESS SHOULD BE
	MOV RKBA,E	;GET THE BUSS ADDRESS
.ENDC
	MOV 2(P),D	;DSKS WITH MEM EX.
	BIC #177717,D	;CLEAR ALL BUT THE MEM EXT.
	ASL F		;TURN IT INTO A BYTE INDEX
	BCC .+6		;BRANCH IF IT DIDN'T OVERFLOW
	ADD #20,D	;INC THE MEM EXT
	ADD F,E		;WHAT THE CORE ADDRESS SHOULD BE
	BCC .+6		;DID IT OVERFLOW AGAIN
	ADD #20,D	;INC THE MEM EXT
	MOV D,DKSCS	;SAVE THE MEM EXT
	MOV E,DKSCA	;SAVE THE CORE ADDRESS
	JSR F,ACRES
	RTS PC		;DONE
.ENDC

;THIS CRETIN ROUTINE TAKES A RANDOM WORD ADDRESSED DISK
;REQUEST AND TRANSFORMS IT INTO SOMETHING THAT A SECTORIZED
;DISK WILL BE HAPPY WITH I.E.
;READING- IF TRANSFER DOES NOT START
;ON A SECTOR BOUNDARY, READ THE NEAREST SECTOR TO THE
;BEGGINING OF THE TRANSFER , THEN COPY THE WORDS NEEDED
;OUT OF A SPECIAL BUFFER, INTO THE USERS BUFFER
;IF THAT DOES NOT FINISH THE TRANSFER, READ THE REST
;OF THE WORDS NORMALLY
;WRITING (BLETCH!) IF TRANSFER DOES NOT START ON SECTOR
;BOUNDARY, READ FIRST SECTOR, COPY WORDS FROM USERS BUFFER
;INTO SPECIAL BUFFER, WRITE OUT THAT SECTOR. IF THAT
;DOESN'T FINISH THE TRANSFER, ROUND THE REQUEST TO
;A WHOLE NUMBER OF SECTORS AND DO A NOORMAL WRITE
;IF THAT DOES NOT FINISH THE TRANSFER, READ IN THE NEXT
;SECTOR, TRANSFER THE WORDS FROM THE USERS BUFFER TO THE
;SPECIAL BUFFER, AND WRITE THE SECTOR BACK OUT.
;THUS, IN THE WORST CASE, A WRITE REQUEST MAY REQUIRE
;2 READS AND 3 WRITES, OR A TOTAL OF 5(COUNT THEM!) TRANSFERS.
DBLECH:	CLR DBLFAK	;INDICATE WE SHOULD NOT FAKE INTERUPT RETURN
	MOV A,DBLASV	;TO MAKE THINGS LOOK RIGHT WHEN WE FINISH
DBLE14:	SPUSH C	;ENTER HERE TO PERFORM PRATIAL SECTOR TRANSFER
	SPUSH D	;AT BEG FOR READ ANN WRITE, AND AT END FOR WRITE(MAYBE)
	MOV #6,D	;FIRST, SAVE AWAY EITHER THE REAL REQUEST
	MOV #DBLPRO+2,B	;OR THE ONE WHICH IS IN PROGRESS
	MOV #DBLDO+2,C
DBLEC1:	MOV (A),(B)+	;THIS IS NOP ON SECOND ENTRY
	MOV (A)+,(C)+
	DEC D
	BNE DBLEC1
	SPOP D
	SPOP C
	BIT #FDSCMS,DBLPDA	;DOES IT BEGIN ON A SECTOR BOUNDARY?
	BNE .+6
	JMP DBLEC2
	BIC #FDSCMS,DBLDDA	;MOVE TO BEG OF SECTOR
DBLE16:	MOV #DSKFOO,DBLDCA	;ENTER HERE IF LESS THAN ONE SECTOR TRANSFER ON WRITE
	MOV #-FDSCSZ,DBLDWC
	MOV #DREADC,DBLDCM	;THIS IS A READ IN ANY CASE
	MOV #DBLDO,A
	MOV #DBLEC3,(A)	;SET UP PLACE TO RETURN
	BR DBLEC9

DBLEC3:	MOV DBLPDA,A	;GET PLACE WE REALLY WANT TO START AT
	BIC #-FDSCSZ,A	;MASK OFF HIGH BITS
	ASL A	;CHANGE TO CORE OFFSET
	ADD #DSKFOO,A	;REAL CORE ADDRESS
	MOV DBLPCA,B	;REAL BUFFER ADDRESS
	SPUSH TEMPAR
	SPUSH TEMPDR
	SPUSH B
	SPUSH A
	MOV DBLPCM,A
	ASH #-4,A
	BIC #177774,A
	ASHC #-6,A
	MOV #77406,TEMPDR
	MOV B,TEMPAR
	SPOP A
	SPOP B
	BIC #177700,B
	ADD #TEMPPG,B
	MOVB DBLPCM,DBLDDE+2
	BIC #70,DBLDDE+2
	CMPB #DREADC,DBLDDE+2
	BEQ DBLEC8	;YES
DBLEC5:	MOV (B)+,(A)+	;FROM REAL BUFFER TO SPECIAL
	INC DBLPDA	;INCREMENT THE DISK ADDRESS WE ARE AT
	BIT #FDSCMS,DBLPDA	;ARE WE AT THE END OF A SECTOR?
	BEQ DBLE10	;YES
	INC DBLPWC	;HAVE WE TRANFERED ALL THE WORDS WE NEED?
	BNE DBLEC5	;NO
	DEC DBLPWC
	BR DBLE10
DBLEC6:	MOV #DWRTEC,DBLDCM	;WRITE OUT THIS SECTOR
	MOV #DBLDO,A
	MOV #DBLEC7,(A)	;PALCE TO RETURN WHEN DONE
DBLEC9:	MOV A,DSKCRB	;THIS KLUDGE FAKES OUT THE WORLD
	TST DBLFAK	;SHOUDL WE FAKE INTERUPT RETURN?
	BNE DBLE20	;YES
	INC DBLFAK	;NO, BUT NEXT TIME
	JMP DSKSG1
DBLE20:	JSR PC,DSKSG1	;BY MAKING LIKE THE DISK IS STILL RUNNING
	TST (P)+	;AND EXITS THE INTERUPT ROUTINE
	SPOP B	;WITHOUT RETURNING TO IT
	SPOP A
	RTT

DBLE15:	MOV A,(B)	;COME HERE FOR A WRITE OF LESS THAN A SECTOR
	CMP #-FDSCSZ,A
	BEQ DBLE19
	BR DBLE16	;BEGINNING ON A SECTOR

DBLE11:
	SPOP TEMPDR
	SPOP TEMPAR
	JSR PC,DBLEC4	;CORRECT DSIK ADDRESS AND WORD COUNT
	BR DBLEC7
DBLE10:
	SPOP TEMPDR
	SPOP TEMPAR
	SPUSH #DBLEC6	;FAKE JSR PC,
DBLEC4:
	SUB #TEMPPG,B
	BIC #77,DBLPCA
	ADD B,DBLPCA
	BCC .+10
	ADD #20,DBLPCM
	TST DBLPDA	;DID WE PRODUCE A CARRY
	BNE .+6	;NO
	INC DBLPDE	;YES, INCREMENT EXTENSION
	INC DBLPWC	;DON'T NEGLECT WORD COUNT
	RTS PC

DBLEC8:	MOV (A)+,(B)+	;COME HERE FOR A READ
	INC DBLPDA
	BIT #FDSCMS,DBLPDA	;DONE WITH THIS SECTOR?
	BEQ DBLE11	;YES, GO MAKE CORRECTIONS
	INC DBLPWC
	BNE DBLEC8
	DEC DBLPWC
	BR DBLE11	;GO MAKE CORRECTIONS

DBLEC7:	TST DBLPWC	;ARE WE DONE?
	BNE DBLEC2	;NO, DO MULTI SECTOR TRANSFER
DBLE18:	MOV DBLASV,A	;REMEMBER HIM?
	CLRB 12(A)
	MOV -(A),B	;ADDRESS OF STOP ROUTINE
	BEQ .+4	;IF NO STOP ROUTINE
	JMP (B)	;LET IT DO THE RTS PC
	RTS PC	;OR WE'LL DO IT IF NONE

DBLEC2:	MOV #DBLPWC,B	;REMAINING WORD COUNT
	CLR A	;LEFTOVERS, IF ANYONE ASKS
	MOVB DBLPCM,DBLDDE+2
	BIC #70,DBLDDE+2
	CMPB #DREADC,DBLDDE+2
	BEQ DBLE17	;THEN THINGS ARE SIMPLE
	MOV (B),A	;IT IS WRITE, GET THE REAL WORD COUNT
	BIC #FDSCMS,(B)	;MAKE IT INTO A WHOLE NUMBER OF SECTORS
	ADD #FDSCSZ,(B)	;LESS ONE SECTOR
	BEQ DBLE15	;LESS THAN ONE SECTOR TO WRITE
	SUB (B),A	;NUMBER OF WORDS LEFTOVER
	CMP #-FDSCSZ,A	;EXACTLY ONE SECTOR?
	BNE DBLE17	;NO
	ADD A,(B)	;A WHOLE NUMBER OF SECTORS
DBLE19:	CLR A	;WITH NO LEFTOVERS
DBLE17:	MOV A,DBLDWC	;SAVE COUNT OF LEFTOVERS
	MOV #DBLE13,-(B)	;PALCE TO RETURN TO
	MOV B,A	;PLACE WHERE REQUEST IS
	BR DBLEC9

DBLE13:	MOV #DBLPWC,A	;ADDRESS OF LEFTOVER COUNT
	SPUSH B
	MOV (A),B
	NEG B
	ASL B
	ADD B,DBLPCA
	BCC .+10
	ADD #20,DBLPCM
	SPOP B
	SUB (A),DBLPDA	;AND DISK ADDRESS
	BCS .+6	;OPISITE OF ADC
	INC DBLPDE
	MOV DBLDWC,(A)	;SETUP FOR REMAINDER
	BEQ DBLE18	;TRANSFER REMAINDER
	JMP DBLE14	;NO REMAINDER
.STITL DISK REQUEST BLOCK GRABBER

SYDRBG:	SPUSH PS	;SAVE OLD PROSSESOR LEVEL
	MOV #340,PS	;LOCK OUT INTERUPTS
	MOV #SYSWPR,A	;LOOK FOR A FREE SYSTEM DISK REQUEST BLOCK
SDRBG1:	TST 14(A)	;IS IT FREE?
	BEQ SDRBG2
	ADD #16,A	;LOOK AT NEXT ONE
	CMP #16*MNUSRS+SYSWPR,A	;ANY MORE?
	BHI SDRBG1	;YES, SEE IF FREE
	SPOP PS	;NO MORE, WE HAVE LOST BIG
	BPT
	BR SYDRBG	;AND CERTAINLY WON'T UNLESS OUR PRIORITY IS <5
SDRBG2:	MOV #400,14(A)	;LABEL BLOCK AS IN USE, BUT NO REQUEST
	SPOP PS	;YOU CAN INTERUPT NOW.
	RTS PC


;USER ROUTINE TO FLUSH UNTIL DISK REQUEST POINTED TO BY A DONE

DSKWAI:	MOV USER,U
	JSR PC,DPROVK
DSKWA1:	TSTB (A)
	BNE DNDONE
	CLR (A)
	JSR PC,RUNME
	RTS PC
DNDONE:	MOV #FRDSKW,FLSRES(U)
	JSR PC,FLUSH
	BR DSKWA1
;GRABS A DISK BLOCK
;DISK BLOCK ADDR RETURNS IN B AND C
UBLKGR:	BIC #DSAMFL,FLAGS2
	MOV #DBITTB,A
	MOV #1,C
	MOV #-1,D
	CLR E
BLKGR1:	BIT C,(A)
	BNE BLKGR3
	INC D
	BGT BLKGR2
	BIS C,(A)
	MOV E,B
	MOV USER,U
	ADD UDSKAD(U),B
	MOV B,DBGRBD
BLKGR2:	CMP #2,D
	BLE BLKGR4
BLKGR3:	INC E
	ASL C
	BNE BLKGR1
	ROL C
	TST (A)+
	CMP #DBITBE,A
	BGE BLKGR1
	BIS #DSAMFL,FLAGS2
BLKGR4:	TST D
	BLT BLKGR5
	RTS PC
BLKGR5:	.BUG.

;FREES THE DISK BLOCK WHOSE LOW ORDER ADDR IS IN C
;BASE OF THIS DISK SPACE IS IN D
;ADDRESS OF THE APPRPRIATE BIT TABLE IS IN E
UBLKFR:	MOV USER,U
UBLKF1:	BIC #DSAMFL,FLAGS2
	SUB UDSKAD(U),C
	MOV #DBITTB,E
	MOV C,B
	BIC #177770,B
	ASR C
	ASR C
	ASR C
	ADD C,E
	BICB BMT(B),(E)
UBLKF2:	RTS PC

LCGRAB:	MOV USER,U
	CMP U,(D)
	BEQ LCGRA1
LCGRA2:	TST (D)
	BLT LCGRA1
	JSR PC,FLUSH
	BR LCGRA2
LCGRA1:	MOV U,(D)
	JSR PC,RUNME
	RTS PC

LCUGRB:	CMP USER,(D)
	BNE .+6
	MOV #-1,(D)
	SEZ
	RTS PC	.STITL DISK INTERUPT ROUTINE

DSKBRK:	SPUSH A
	SPUSH B
	MOV DSKS,A	;GET STATUS REGISTER
	TST A
	BLT DSKLOS
.IIF NZ DSKCHK,	JSR PC,DSKCK
DSKBR9:	MOV #400,DSKS
DSKBR2:	MOV DSKCRB,A	;POINTER TO FUNCTION WORD
	BEQ DSKBR1
	MOV (A),B
	BEQ .+4	;NO
	JSR PC,(B)	;YES, GO DO IT
	MOV DSKCRB,A
	CLR DSKCRB
	CLRB 14(A)	;REQUEST HAS BEEN SERVICED
DSKBR1:	JSR PC,DSKSRT	;LOOK FOR SOMETHING ELSE TO DO
DSKRET:	SPOP B
	SPOP A
	RTT

DSKLOS:	INC NRFERS
	BIT #40000,A	;IS IT FROZEN?
	BNE DSKLS1	;YES
	BIT #26000,A	;IS IT ONE OF WRITE CHECK, NED OR WRITE LOCKOUT?
	BEQ DSKRTY	;NO, MEANS IT IS ADDRESS PARITY OR
DKLOSE:	MOV #DKWLST,B
	JSR PC,PLOCS	;PRINT CONTENTS OF FOLLOWING ON SYS CONSOLE
			;DSKS
			;DSKAE
			;0
	HALT	;BIT THE BAG
	BR DSKRT1
DSKLS1:	BIT #2000,DSKAE	;NXM?
	BNE DKLOSE	;YES
DSKRTY:	INC DKRTYS	;HAVE WE BEEN THROUGH THIS BEFORE?
	BGE DKLOSE	;YES, TOO MANY TIMES
DSKRT1:	MOV #400,DSKS	;POWER CLEAR THE DISK
	MOV DSKCRB,A	;RETRY THE LAST OPERATION
	JSR PC,DSKSG1
	BR DSKRET

RKBRK:	SPUSH A
	SPUSH B
	MOV RKCS,A
	TST A
	BLT RKLOS
.IIF NZ MVONLY,	JSR PC,DSKCK	;CHECK THE DISKS
	CLR RKCS
	BR DSKBR2
RKLOS:	INC NRKERS
	BIT #66340,RKER	;BAD ERROR?
	BEQ RKSOFT
RKLOST:	MOV #RKWLST,B
	JSR PC,PLOCS	;PRINT FOLLOWING LOCS ON SYS CONSOLE
			;RKDS
			;RKER
			;RKCS
			;0
	HALT
	BR RKRT1
RKSOFT:	INC DKRTYS
	BGE RKLOST
RKRT1:	MOV #1,RKCS
	TSTB RKCS
	BGE .-4
	MOV DSKCRB,A
.IFNZ MVONLY
	TST FIXFAK	;IS IT A FIXED FAKE?
	BEQ RKRT2
	JSR PC,DSKSG1
	BR DSKRET
.ENDC
RKRT2:	JSR PC,RKSG1
	BR DSKRET

.IFNZ DSKCHK
DSKCK:	TST DSKCRB
	BNE .+4
	RTS PC
	SPUSH D
	SPUSH E
	BIT #1,DKSCA	;IS THE CORE ADDRESS CORRECT
	BNE DSKCRT
.IFZ MVONLY
	CMP DSKCA,DKSCA	;IS THE CORE ADDRESS THE SAME
	BNE BADCK	;NO
	CMP DSKA,DKSDA	;IS THE DISK ADDRESS THE SAME
	BNE BADCK	;NO
	MOV DKSAE,D	;THE THE SUPPOSED DISK EXTENSION
	MOV DSKAE,E	;GET THE ACTUAL
	XOR E,D	;CLEAR THE BITS THAT ARE THE SAME
	BIT #37,D	;THE EXTENSION BITS
	BNE BADCK	;SOME BITS WERE DIFFERENT
.IFF
;	CMP DKSCA,RKBA	;IS THE BUSS ADDRESS THE SAME
;	BNE BADCK
	CMP DKSDA,RKDA	;IS THE DISK ADDRESS THE SAME
	BNE BADCK
.ENDC
	MOV DKSCS,D	;GET THE SUPPOSED CORE EXTENSION
	MOV DSKS,E	;GET THE ACTUAL VALUES
	XOR E,D		;CLEAR THE BITS THAT ARE THE SAME
	BIT #60,D	;ARE THE BITS DIFFERENT
	BNE BADCK
DSKCRT:	SPOP E
	SPOP D
	RTS PC
BADCK:	MOV #DSKS,E	;THIS IS A DBUGGING FEATURE
.IIF Z MVONLY,	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	SPUSH (E)+
	JSR F,ACSAV
	JSR A,SPRINT
	MOV #DKEPR,F
DKEPLP:	MOV (F),A
	BEQ EDKEPR
	JSR PC,PRONL
	PRTXT ^\/ IS \
	MOV @(F)+,A
	JSR PC,PRONL
	PRTXT ^/ SB /
	MOV @(F)+,A
	JSR PC,PRONL
	PRCR
	BR DKEPLP
EDKEPR:	SPREND
	JSR F,ACRES
	TST DEBSW
	BEQ .+4
	240
	ADD #14,P
	SPOP E
	SPOP D
.IIF NZ MVONLY,	JMP RKLOS
.IIF Z MVONLY,	JMP DSKLOS
.ENDC
;	PUSH F
;	SPUSH ADDR
;	JSR PC,LSH7
;CONVERTS SECTOR ADDR IN D TO WORD ADDR IN ADDR AND ADDR+2
;D STAYS INTACT (AS OPPOSED TO PREVIOUS VERSION)
LSH7:	MOV P,F		;POINT F AT PUSHED ADDR
	TST (F)+	;(SKIP PUSHED PC)
	SPUSH D
	SPUSH A
	SPUSH C
	CLR C		;EXTEND SECTOR ADDR
	ASHC #7,C	;SHIFT 7 PLACES
	MOV (F)+,A	;ADDRESS TO PUT RESULT
	MOV D,(A)+	;LOW ORDER
	MOV C,(A)	;HIGH ORDER
	SPOP C
	SPOP A
	SPOP D
	SPOP F		;RETURN ADDRESS TO F
	TST (P)+	;POP ADDR
	RTS F		;RETURN, RESTORING F
;SPUSH #(ADDR OF 3-WORD BLOCK)
;JSR PC,DSKSEC
;	3-WORD BLOCK:
;POINTER TO CORE ADDRESS
;POINTER TO DISK SECTOR ADDRESS
;READ OR WRITE COMMAND
;	USES 4 WORDS ON PDL;
;	IF THIS INCREASES CHECK PPUSHL.
DSKSEC:	SPUSH E
	MOV 4(P),E	;E POINTS TO FIRST WORD OF 3-WD BLOCK
	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-200,(A)+	;ALWAYS THIS LONG
	MOV @(E)+,D
	SPUSH B
	SPUSH F
	MOV USER,F
	MOV SLOTAS(F),F
	MOV SLOTHA(F),B
	SUB #PURE,D
	ADD SLOTCA(F),D
	ADC B
	MOV D,(A)+
	ASH #4,B
	BIS B,6(A)
	SPOP F
	SPOP B
	MOV @(E)+,D	;DISK ADDRESS
	BIT #160000,D	;IS IT THE FIXED HEAD DISK?
	BNE DSKSC1	;NO
	SPUSH F
	SPUSH A		;PLACE TO PUT WORDED DISK ADDR
	JSR PC, LSH7
	ADD #4,A
	BR DSKSC3
DSKSC1:	SUB #20000,D	;MAKE IT INTO A REAL MOVING DISK ADDR
	SPUSH D
	BIC #17777,(SP)
	BIC #160000,D
	SPUSH C
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	SPOP C
	ADD (SP)+,D
	MOV D,(A)+
	MOV #-1,(A)+	;THIS IS A MOVING HEAD REQUEST
DSKSC3:
	TST (A)+
	BISB (E),(A)	;ENTER REQUEST BYTE
	JSR PC,DSKWAI	;WAIT FOR COMPLETION
	SPOP E
	SPOP (P)
	RTS PC
	.STITL NEW FILING
.IFZ SITSD
FILE==200
DIR==300
TYPMSK==177477
SHRBB==4000
EOFBIT==0
LBEB==0
.IFF
FILE==2000
DIR==1000
TYPMSK==170777
SHRBB==10000
EOFBIT==100000
LBEB==400
.ENDC

;USER PRIMITIVE ROUTINES

;DIRSET TAKES A LIST AND SETS THE CURRENT DIRECTORY

DSET:	JSR PC,SETNM	;GET NAME OF DIRECTORY
	BNE DSET1	;INPUT IS A LIST
SETDEF:	MOV DEFDIR,CURDIR	;SET CURRENT DIRECTORY
	MOV DEFDSK,WCHDSK	;WHICH DISK?
	RTS PC
DSET1:	JSR PC,SETDEF
DIRSET:	JSR PC,GNWRD	;GET A WORD FROM THE LIST
	BNE .+4		;ANY LEFT?
	RTS PC		;NONE LEFT, DONE
	JSR PC,DIRGET	;GET NEXT ITEM FROM LIST
	BR DIRSET	;AND CONTINUE WITH THE NEXT NAME


DIRGET:	MOV #NAME,E	;PLACE TO STORE THE NAME
	JSR PC,NFNGET	;GET A FILE NAME
	MOV #NAME,E
	CMPB #'^+200,(E)	;IS IT ^?
	BNE DIRGT1	;NOPE
	MOV CURDIR,E	;POINTER TO CURRENT DIRECTORY
	JSR PC,DBREAD	;SET DISK FOR READING
.IF Z SITSD
	MOV #DBUF,ENTBEG	;SET ADDRESS OF START OF ENTRY
.IFF
	MOV DBUF,E
	INC E
	BIC #177401,E
	ADD #DBUF,E
	MOV E,ENTBEG
.ENDC
	BR DIRGT9
DIRGT1:	TSTB (E)	;HAVE WE PASSED LAST CHAR OF NAME?
	BLT DIRGT2	;YES
	TSTB (E)+	;NO, FIND IT
	BGE .-2
	CMPB #';+200,-(E)	;IS THIS THE ROOT DIRECTORY?
	BNE UDREAD	;NO, SET UP DISK BLOCK FOR READ
	BISB #200,-(E)	;YES, SET CODE FOR FILE
	MOV #NDISKS,D	;NO. OF DISKS
	CLR A
DIRGT3:	MOV FDNAMP(A),B	;B NOW POINTS TO ADDRESS FOR NAME
	MOV #NAME,E
	TST DBITAD(A)	;BLOCK NO. OF BIT TABLE
	BLT DIRGT4	;NOT HERE- TRY OTHER DISK
DIRGT6:	CMPB (E)+,(B)	;COMPARE CHARACTERS OF NAME
	BNE DIRGT4	;MISMATCH
	TSTB (B)+	;ANY MORE CHARACTERS?
	BGE DIRGT6	;YES
	MOV A,WCHDSK	;SET DISK
	BR DIRGT8
DIRGT4:	TST (A)+	;NEXT DISK
	SOB D,DIRGT3	;TRY AGAIN
	ERROR+BDD	;NO MORE- BAD DIRECTORY
DIRGT2:	CMPB #';+200,(E)	;ROOT DIRECTORY?
	BNE UDREAD	;NO, A USER'S DIRECTORY
DIRGT8:	MOV #46,CURDIR	;YES, SET IT AS CURRENT DIRECTORY
	RTS PC
UDREAD:	MOV #NAME,E
	JSR PC,DIRSER	;LOOK FOR THAT NAME
	BNE .+4		;FIND IT?
	ERROR+NED	;NON EXISTENT DIRECTORY
DRREAD:	MOV @ENTBEG,A	;GET TYPE OF ENTRY FOUND
	BIC #TYPMSK,A	;FLUSH EVERYTING BUT TYPE
	CMP #DIR,A	;IS IT A DIRECTORY?
	BEQ .+4
	ERROR+ENDR	;ENTRY NOT A DIRECTORY
DIRGT9:	JSR PC,DESSET	;SET UP NEW DIRECTORY
	MOV DSKADR,CURDIR	;AND MAKE THIS THE CURRENT DIRECTORY
	RTS PC
.DIRSET:
	BIT #7777,@S	;CHECK NAME OF DIRECTORY ON S-PDL
	BNE .DIRS1
	SPOPS A		;NOTHING TO DO
	SEZ
	RTS PC
.DIRS1:	JSR PC,DSET	;SET THE DIRECTORY
	JSR PC,DIRGET	;SET UP FILES
USEENT:	MOV CURDIR,DEFDIR	;THIS IS NOW DEFAULT DIRECTORY
	MOV WCHDSK,DEFDSK	;THIS IS NOW DEFAULT DISK
	SEZ
	RTS PC
.USE:	MOV WCHDSK,E	;CURRENT DISK
	MOV FDUSEA(E),CURDIR
	JSR PC,SETNM	;GET THE DIRECTORY NAME
	BNE .USE1	;INPUT IS A LIST (MORE TO COME)
.USE3:	MOV #NAME,E	;POINTER TO  NAME
	JSR PC,NFNGET	;GET THE NAME
.USE4:	MOV #NAME,E
	JSR PC,DIRSER	;LOOK FOR THE SUB-DIRECTORY
	BNE .USE2	;FOUND IT
	ERROR+NED	;NON-EXISTENT DIRECTORY
.USE2:	JSR PC,DRREAD	;MAKE SURE THIS IS A LEGIT. DIRECTORY
	BR USEENT	;SET NEW DISK AND DIRECTORY DEFAULTS
.USE1:	JSR PC,DIRSET	;MORE DIRECTORIES?
	BR .USE3	;SAME THING AGAIN
LOGIN:	MOV @S,A	;GET USER NAME OFF S-PDL
	SPUSHS A	;PUSH A COPY OF IT
	BIT #7777,A	;IS IT LEGAL
	BNE .+4
	ERROR+IUN	;INVALID USER NAME
	JSR PC,.USE	;SET DIRECTORY(IES)
	MOV USER,E	;ADDRESS OF USER TABLE
	ADD #UNAME,E	;ADDRESS OF CURRENT USER NAME
	JSR PC,NFNGET	;GET THE NAME
	MOV #NAME+4,E
	MOV #"IT+100000,-(E)	;SET FILE NAME "INIT"
	MOV #"IN,-(E)
	JSR PC,DIRSER	;IS IT THERE?
	BEQ LOGIN2	;NOPE, LOOK FOR MAIL
	JSR PC,GETFI1	;GET THE FILE AND CHECK ITS TYPE
	CMP #FILE,A	;IS IT A CASE OF MISTAKEN IDENTITY?
	BNE LOGIN2	;YES, INDEED
	JSR PC,.REDF4	;READ THE FILE
	JSR PC,.READ1
LOGIN2:	MOV #NAME+4,E	;SET UP NAME OF MAIL ENTRY
	MOV #"IL+100000,-(E)
	MOV #"MA,-(E)
	JSR PC,DIRSER	;IS THERE ANY MAIL?
	BEQ LOGIN1	;NO
	JSR PC,GETFI1	;GET A COPY OF THE NAME AND CHECK IT
	CMP #FILE,A	;ONCE AGAIN, MAKE SURE ITS A FILE
	BNE LOGIN1	;IT'S NOT, WE'RE THROUGH
LANGC	<PRTXT ^/PRINT MAIL?/>,<
	PRTXT ^/COURRIER A IMPRIMER?/>
	JSR PC,QUEST	;GET THE REPLY
	BNE LOGIN1	;DOESN'T WANT IT- WE'RE THROUGH
	JSR PC,.REDF4	;READ THE MAIL FILE (ISN'T THIS A CRIME?)
	JSR PC,.POF1	;PRINT IT
LANGC	<PRTXT ^/DELETE MAIL?/>,<
	PRTXT ^/MESSAGE RECU?/>
	JSR PC,QUEST	;GET THE REPLY
	BNE LOGIN1	;LEAVE THE MAIL
	JSR PC,GCDIR	;GET THE FILE
	JSR PC,.DELT5	;DELETE IT
LOGIN1:	SEZ
	RTS PC		

.DELETE:
	MOV #WDIRSW,D	;LOCK WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB
	JSR PC,GETFIL	;GET THE ENTRY
	CMP #FILE,A	;IS IT A FILE?
	BEQ .+4		;IF YES, OK
	ERROR+CDE	;CAN'T DELETE THAT ENTRY
	CMP #46,CURDIR	;IS IT THE ROOT DIRECTORY?
	BNE .+6		;NO
	JSR PC,CKSST	;CHECK SYSTEM STATUS
.DELT5:	JSR PC,DESSET	;SET THE DESCRIPTOR
	JSR PC,.DELT3	;FREE THE BLOCK
	JSR PC,DELENT	;DELETE THE ENTRY
	JSR PC,WBITS	;WRITE BIT TABLE ONTO DISK
	MOV #WDIRSW,D	;WE'RE DONE, FREE THE WORLD UP
	JMP LCUGRB
WDELBL:	JSR PC,DESINC
.DELBL:	JSR PC,DESST	;SET UP DESCRIPTOR
	CLR FILFLG
.DELT3:	BIT #SHRBB,DESSAV  ;IS THIS A SHARED BLOCK?
	BNE .DELT2	;YES, DON'T DELETE IT
	MOV DSKADR,A	;ADDRESS OF THE BLOCK
	TST DEOFBL	;ARE WE BEYOND THE LAST BLOCK?
	BGT .DELT2	;YES
	MOV WCHDSK,B	;NO, SET THE DISK
	INC NBLKFR(B)	;ADDRESS OF NEXT BLOCK
	JSR PC,BITGET	;GET THE APPROPRIATE BIT
	BICB BMT(B),(C)	;FREE THE BLOCK
	JSR PC,GNBLK	;GET THE NEXT BLOCK ADDRESS
	BR .DELT3
.DELT2:	RTS PC
DELENT:	.IF Z SITSD
	MOV @ENTBEG,A	;GET FIRST WORD
	BIC #177700,A	;LENGTH OF ENTRY IN WORDS
	ASL A		;NOW IN BYTES
	MOV #DBUF+1776,D	;HOPEFULLY, THE NUMBER OF FREE BYTES
	ADD A,(D)	;CORRECT IT
	MOV ENTBEG,B	;BEGINNING OF ENTRY TO FLUSH
	MOV B,C
	ADD A,C		;BEGGINING OF NEXT ENTRY
	SUB (D),D	;END OF USEFUL INFORMATION
.IFF
	MOV @ENTBEG,A
	INC A
	BIC #177401,A	;LENGTH OFABOUT TO BE DELETED ENTRY IN EVEN BYTES
	MOV #DBUF+6,D	;GET POINTER TO THE EOF BYTE COUNT
	SUB A,(D)	;THE BYTES WE ABOUT TO FREE
	MOV ENTBEG,B	;PLACE WHERE THE ENTRY IS NOW
	MOV B,C
	ADD A,C		;FIRST WORD NOT BELONGING TO ENTRY
	MOV (D),D	;NEEW DIRECTORY END
	ADD #DBUF,D
.ENDC
.DELT4:	MOV (C)+,(B)+	;COPY USEFUL STUFF OVER USELESS
	CMP B,D		;DONE?
	BLE .DELT4
	MOV (C)+,(B)+	;MAKE SURE
	MOV CURDIR,E	;WRITE OUT THE DIRECTORY
	JSR PC,DBWRTE
	RTS PC
MAIL:	SPUSH DEFDIR	;SAVE DEFAULT DIRECTORY
	SPUSH DEFDSK	;SAVE DEFAULT DISK
	JSR PC,.USE	;SET DIRECTORY TREE
	SPOP DEFDSK
	SPOP DEFDIR
.IFZ SITSD
	MOV #"MA,NAME	;SET ENTRY NAME TO "MAIL"
	MOV #"IL+100000,NAME+2
.IFF
	MOV #"MA,NAME+10	;SET ENTRY NAME TO "MAIL"
	MOV #"IL+100000,NAME+12
.ENDC
	JSR PC,.OPNA3	;OPEN MAIL FILE
	MOV #.WRTEC,PCHR	;CHARS. IN BUFFER INTO OUTPUT DEVICE
	PRTXTC ^/------/
LANGC	<PRTXT ^/MAIL FROM />,<
	PRTXT ^/EN PROVENANCE DE />
	MOV USER,A
	ADD #UNAME,A	;USER WHO SENT MAIL
	JSR PC,POIHD2	;PRINT THE NAME
	JSR PC,.CRLF	;CARRIAGE RETURN, LINEFEED
	JSR PC,UDATEG	;SET THE DATE
	SPUSH #1
	JSR PC,PRINT	;PRINT THE DATE
	JSR PC,.SPACE
	JSR PC,UTIMEG	;SET THE TIME
	SPUSH #1
	JSR PC,PRINT	;PRINT THE TIME
	SPUSH PRMTCH	;SAVE NORMAL PROMPT CHARACTER
	MOV #'_,PRMTCH	;NEW ONE IS "_"
	MOV #TYO,PCHR
MAIL2:	JSR PC,RDSTR	;READ A STRING
	BEQ MAIL3	;NO CHARACTERS TYPED
	MOV @S,B	;POINTER TO STRING
	JSR PC,.LOADB	;FIRST CHARACTER
	CMP #'.,B	;IS IT A PERIOD?
	BEQ MAIL1	;YES (NO MORE INPUT)
	JSR PC,.FILEP
	BR MAIL2
MAIL1:	SPOP PRMTCH	;GET BACK OLD PRMTCH ("?")
	MOV #.WRTEC,PCHR
	SPOPS A
	PRTXTC ^/------/
	MOV #TYO,PCHR
	JMP .WRTCL
MAIL3:	BIT #RBRKF,TFLAGS
	BEQ MAIL2
	MOV USER,U
	CLR BRAKE(U)
	JSR PC,BRAKR	;ALLOW TYPING
	PRTXTC ^/STOPPED/
	BR MAIL2

.READ:	JSR PC,.READF
.READ1:	MOV #.READCH,GCHR
	MOV PC,REDFLG
	JSR PC,SAVEVL
	.IF NE WADESW
	PUSH #0	;NO. OF ARGS
	JSR PC,SAVPPS
	BIS #DORF,FLAGS
	BIS #1,CPDLP
	.ENDC
RMLOOP:	CMP #TYI,GCHR
	BEQ RMLOO1
	JSR PC,RDSTR
	BEQ RMLOO2
	JSR PC,READ
	BEQ RMLOOP	;NO TOKENS
	JSR PC,EVLINE
	BEQ RMWDW
	POPS A
	BR RMLOOP
RMWDW:	ERROR+WDW
RMLOO1:	TST TOPRNM	;DONE, PROC DEF PENDING?
	BEQ .+6
	JSR PC,END
	MOV #RET,PSTOPR
	.IF NE WADESW
	JSR PC,RESPPS
	POP B
	.ENDC
	JSR PC,RESEVL
	MOV B,FLAGS
	MOV CTP,C
	CLR D
	JMP PSTOP6
RMLOO2:	BIT #RBRKF,TFLAGS
	BEQ .+4
	ERROR+BRK
	CMP #TYI,GCHR
	BEQ RMLOO1
	BR RMLOOP

.WRITE:	JSR PC,.WRTEF
	MOV #.WRTEC,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	BR .+2
	CLR WRTFLG
	JSR PC,.WRTCL
	MOV #TYO,PCHR
	SEZ
	RTS PC

.READF:.OPENR:	JSR PC,GETFIL	;FIND THE ENTRY
.REDF5:	CMP #FILE,A	;IS IT A FILE?
	BEQ .+4		;YES
	ERROR+CRE	;CAN'T READ THAT ENTRY
.REDF4:	JSR PC,DESSET	;SET THE DESCRIPTOR
	MOV #1,FILFLG	;SET THE OPEN FILE FLAG FOR READ
.REDF1:	MOV #-1,A
	TST DEOFBL	;IS THIS THE LAST BLOCK OF FILE
	BGT .REDF2	;YES
	MOV DSKADR,E	;CURRENT SECTOR FOR THIS FILE
	JSR PC,DBREAD	;SET DISK FOR READING
	MOV #2000,A	;LENGTH OF BLOCK
	TST DEOFBL	;IS THIS THE LAST BLOCK OF FILE?
	BNE .REDF2	;YES, RETURN
.IF Z SITSD
	BITB #40,DESSAV+1	;IS LAST WORD OF BLOCK USED?
	BEQ .REDF3	;YES
	SUB DBUF+1776,A	;NUMBER OF BYTES USED
	BR .REDF2
.REDF3:	BITB #20,DESSAV+1	;IS LAST BYTE OF BLOCK USED?
	BEQ .REDF2	;YES
	DEC A		;NO,ONE LESS BYTE IS USED
.IFF
	MOV FBYTES,A
	BIC #176000,A
.ENDC
.REDF2:	MOV A,DSKNCH	;NUMBER OF CHARACTERS IN DISK BUFFER
	SEZ
	RTS PC

;READ A CHARACTER
.READC:	TST FILFLG	;IS FILE OPEN FOR READING?
	BLE .REDC1	;NO
	TST DEOFBL	;LAST BLOCK OF FILE?
	BGT .REDC1	;YES
	TST DSKNCH	;ARE THERE ANY CHARS?
	BNE .REDC3	;YES
	JSR PC,.REDC3	;GET THE NEXT BLOCK IF IT EXISTS
	BR .READC	;GO CHECK IT OUT
.REDC3:	MOVB @DBUFPT,D	;CHARACTER POINTED TO BY DISK BUFFER POINTER
	INC DBUFPT	;NEXT CHARACTER
	DEC DSKNCH	;ONE LESS CHARACTER IN BUFFER
	BGT .REDC2	;ANY MORE CHARACTERS?
	JSR F,ACSAV	;SAVE REGISTERS
	JSR PC,GNBLK	;GET NEXT BLOCK
	JSR PC,.REDF1	;READ THE FILE
	JSR F,ACRES	;RESTORE REGISTERS
	CLZ
	RTS PC
.REDC1:	CLR FILFLG	;CLEAR FILE FLAG
	CLR REDFLG	;CLEAR READ FLAG
	CLR DSKNCH	;NO MORE CHARACTERS IN BUFFER
	MOV #EOFCHR,D	;D POINTS TO LAST CHARACTER OF FILE
	SEZ
.REDC2:	RTS PC
.OPENA:	JSR PC,DSET	;SETS DIRECTORY
.IIF Z SITSD,	MOV #NAME,E	;NAME OF FILE
.IIF NZ SITSD,	MOV #NAME+10,E
	JSR PC,NFNGET	;SET FILE NAME
.OPNA3:.IIF Z SITSD,	MOV #NAME,E	;NAME OF FILE
.IIF NZ SITSD,	MOV #NAME+10,E
	JSR PC,DIRSER	;FIND THE FILE
	.IFZ <ENG&FR>
	BEQ .WRTF2	;NOT HERE, WRITE A NEW ONE
	.IFF
	BNE .+6
	JMP .WRTF2
	.ENDC
	MOV @ENTBEG,A	;FOUND IT, THIS IS START OF  NTRY
	BIC #TYPMSK,A	;FLUSH ALL BUT TYPE
	CMP #FILE,A	;MAKE SURE IT'S A FILE
	BEQ .+4		;OK
	ERROR+CRE	;NOPE, CAN'T READ THAT ENTRY
	JSR PC,DESSET	;SET THE DESCRIPTOR
	JSR PC,DELENT	;FLUSH THE OLD ENTRY
.OPNA2:	JSR PC,.REDF1	;READ FILE INTO BUFFER
	TST DEOFBL	;ANY MORE BLOCKS LEFT?
	BGE .OPNA1	;NO
	JSR PC,GNBLK	;YES, GET ADDRESS OF  NEXT ONE
	BR .OPNA2	;READ IN NEXT BLOCK
.OPNA1:	MOV DSKADR,LBLKAD	;SAVE LAST BLOCK ADDRESS
	MOV DSKADR,DBGOT	;BACK POINTER TO START OF LAST BLOCK
.IIF Z SITSD,	BIC #TYPMSK,DESSAV
.IIF NZ SITSD,	MOV #EOFBIT!FILE!LBEB,DESSAV
	MOV CURDIR,WRTDIR	;SET CURRENT DIRECTORY TO BE WRITTEN
	MOV #2000,A	;START OF NEW BLOCK
	SUB DSKNCH,A	;GET AMOUNT OF FREE SPACE IN CURRENT BLOCK
	BEQ .WRTF1	;NONE LEFT
.IIF NZ SITSD,	ADD A,FBYTES	;ROUND UP FBYTES
	ADD DSKNCH,DBUFPT	;BUFFER POINTER SET TO FIRST FREE BYTE
	MOV A,DSKNCH	;NEW NUMBER OF CHARACTERS IN BUFFER
	MOV #-1,FILFLG	;SET OPEN FILE FLAG FOR WRITE
	SEZ
	RTS PC
QUEST:	MOV USER,U	;SETS USER
	MOV UTTY(U),E	;USER TELETYPE NUMBER
	BIS #TIMAGI,TTYST(E)	;TTY STATUS TO INPUT IMAGE MODE
	BIC #TILIPM,TTYST(E)	;CLEAR LINE INPUT MODE
	JSR PC,GTYI	;GET THE CHARACTER
	SPUSH D		;SAVE IT
	JSR PC,.CRLF	;PRINT CR AND LINEFEED
	SPOP D		;GET CHARACTER
.IFNZ FR
	CMP #'O,D
	BEQ QUEST1
	CMP #'O+40,D
	BEQ QUEST1
.ENDC
.IFNZ ENG
	CMP #'Y,D	;IS IT "Y"?
	BEQ QUEST1
	CMP #'Y+40,D	;IS IT SMALL Y
.ENDC
QUEST1:	RTS PC

.WRTEF:.OPENW:	JSR PC,DSET	;SET DIRECTORY
.IIF Z SITSD,	MOV #NAME,E	;GET ENTRY NAME
.IIF NZ SITSD,	MOV #NAME+10,E
	JSR PC,NFNGET	;SET IT
.IIF Z SITSD,	MOV #NAME,E	;GET ENTRY NAME
.IIF NZ SITSD,	MOV #NAME+10,E
	JSR PC,DIRSER	;LOOK FOR ENTRY NAME
	BEQ .WRTF2	;NOT HERE
LANGC	<PRTXT ^/FILE ALREADY EXISTS.  DELETE IT?/>,<
	PRTXT ^/FICHIER DEJA EXISTANT. A DETRUIRE?/>
	JSR PC,QUEST	;GET REPLY
	BEQ .+4		;OK, DELETE IT
	ERROR+EAES	;ENTRY ALREADY EXISTS
	JSR PC,.DELT5	;DELETE OLD ENTRY
.WRTF2:	MOV #EOFBIT!FILE!LBEB,DESSAV	;SET DESCRIPTOR TO TYPE FILE
	JSR PC,DESWST	;SET DESCRIPTOR MODE FOR DISK HACKING
.WRTF1:	JSR PC,DBGET	;GET THE RIGHT DISK BLOCK
	MOV #2000,DSKNCH	;LENGTH OF BLOCK
	MOV #DBUF,DBUFPT	;PTR TO START OF DISK BUFFER
	MOV #-1,FILFLG		;SET OPEN FILE FLAG FOR WRITE
	MOV CURDIR,WRTDIR	;CURRENT DIRECTORY BEING WRITTEN
	SEZ
	RTS PC

.WRTEC:	DEC DSKNCH	;ONE LESS CHARACTER IN BUFFER
	BLT .WRTC1	;NO MORE LEFT
	MOVB D,@DBUFPT	;CURRENT CHARACTER INTO BUFFER
	INC DBUFPT	;POINTER TO NEXT BYTE
	RTS PC
.WRTC1:	JSR F,ACSAV	;SAVE REGISTERS
	MOV DBGOT,E	;BACK POINTER TO START OF BLOCK
	JSR PC,DBWRTE	;SET DISK BLOCK FOR WRITING
	JSR PC,.WRTF1	;GET THE BLOCK AND SET ALL THE VARIABLES
	JSR F,ACRES	;RESTORE THE REGISTERS
	BR .WRTEC

.WRTCL:	MOV DSKNCH,A	;NO. OF CHARACTERS IN BUFFER
	BEQ .WRCL1	;NO MORE LEFT
.IF Z SITSD
	CMP #1,A	;IS THERE JUST 1 LEFT?
	BEQ .WRCL2	;YES
	MOV A,DBUF+1776	;LAST WORD OF BLOCK HAS NO. OF CHARS USED
	BISB #40,DESSAV+1
.IFF
	SUB DSKNCH,FBYTES
	BGE .WRCL3
	DEC FPAGE
	ADD #20000,FBYTES
.WRCL3:
.ENDC
.WRCL1:	MOV DBGOT,E	;BACK PTR TO START OF BLOCK
	JSR PC,DBWRTE	;SET BLOCK FOR WRITING
	MOV #WDIRSW,D	;LOCK IN WRITE SWITCH
	JSR PC,LCGRAB	;RUN THE DISK REQUEST
	MOV WRTDIR,CURDIR	;CURRENT DIR HAS BEEN WRITTEN
	JSR PC,DESINS	;INSERT DESCRIPTOR
	JSR PC,WBITS	;WRITE BIT TABLE ONTO DISK
	CLR FILFLG	;CLEAR FILE FLAG
	MOV #WDIRSW,D	;LOCK IN WRITE SWITCH
	JMP LCUGRB
.WRCL2:	BISB #20,DESSAV+1
	BR .WRCL1

.DELI:	MOV #WDIRSW,D	;LOCK IN WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB	;RUN THE DISK REQUEST
	JSR PC,GETFIL	;GET THE ENTRY
	CMP #DIR,A	;IS IT AN INDEX?
	BEQ .+4		;YES
.DELI1:	ERROR+CDE	; CAN'T DELETE THAT ENTRY
	JSR PC,DESSET	;SET THE DESCRIPTOR
	MOV DSKADR,E	;CURRENT SECTOR FOR FILE
	JSR PC,DBREAD	;SET THE BLOCK FOR READING
	MOV #DBUF,A	;POINTER TO DISK BUFFER
.IF Z SITSD
	MOV (A),B	;FIRST WORD OF BUFFER
	BIC #177700,B	;LENGTH OF ENTRY IN WORDS
	ASL B		;NOW IN BYTES
	ADD B,A		;SUPPOSED END OF ENTRY
	TST (A)		;IS SOMETHING THERE?
.IFF
	MOV (A),B	;FIRST WORD OF 1ST ENTRY
	INC B
	BIC #177401,B
	ADD B,A		;GET TO SECOND ENTRY
	MOV (A),B	;THIS IS THE SELF ENTRY
	INC B
	BIC #177401,B
	ADD A,B		;GET END OF SECOND ENTRY
	SUB #DBUF,B	;GET LENGTH OF 1ST+2ND ENTRIES IN BYTES
	CMP DBUF+6,B	;COMPARE WITH LENGTH OF DIR
.ENDC
	BNE .DELI1	;OOPS!
	MOV CURDIR,E	;ADRESS OF CURRENT DIRECTORY
	JSR PC,DBREAD	;HACK BLOCK AT THIS ADDRESS FOR READ
	JMP .DELT5

.FILEP:	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT .+4		;YES
	ERROR+NFO	;NO, INVALID FILE NAME
	SPUSH PCHR
	MOV #.WRTEC,PCHR
	SPUSH #1
	JSR PC,PRINT	;PRINT THE CHARACTERS
.FILP1:	SPOP PCHR
	SEZ
	RTS PC

.FILER:	TST FILFLG	;IS FILE OPEN FOR READ?
	BGT .+4		;YES
	ERROR+NFO	;NO,INVALID FILE NAME
	SPUSH GCHR
	MOV #.READC,GCHR
	JSR PC,RQUEST
	SPOP GCHR
	CLZ
	RTS PC

.CLOSF:
.IIF NZ DRIBF,	BIC #DRIBBF,FLAGS2
	MOV #TYI,GCHR	;RESET IT FOR TTY INPUT
	CLR REDFLG	;CLEAR READFLAG
	CLR WRTFLG	;CLEAR WRITE FLAG
	TST FILFLG	;IS FILE OPEN FOR WRITE?
	BLT .WRTCL
	CLR FILFLG	;CLEAR FILE FLAG
	RTS PC

GETFIL:	JSR PC,DSET	;SET THE DIRECTORY
	MOV #NAME,E
	JSR PC,NFNGET	;WHAT FILE?
GETFI1:	MOV #NAME,E
	JSR PC,DIRSER	;FIND THE FILE
	BNE .+4		;FOUND IT
	ERROR+FNF	;FILE NOT FOUND
	MOV @ENTBEG,A	;WHAT TYPE OF ENTRY
	BIC #TYPMSK,A	;FLUSH ALL BUT TYPE
	RTS PC

.IFNZ AI
.XOR:	JSR PC,CKSST	;CHECK STATUS
	JSR PC,G1NARG	;GET AN ARGUMENT
	MOV B,XORF	;SET THE XOR FLAG
	SEZ
	RTS PC
.ENDC

.FILEO:	TST FILFLG	;IS A FILE OPEN
	BEQ .+6		;NO
	JMP RTTRUE	;RETURN TRUE
	JMP RTFALS	;RETURN FALSE

.POI:	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO
	CLR DBGOT
	JSR PC,SETDEF	;SET DEFAULT DISK AND DIRECTORY
	JSR PC,GCDIR	;GET THE DIRECTORY
	MOV #DBUF,ENTBEG   ;ENTRY AT START OF DISK BUFFER
.POI1:	.IF NZ SITSD
	MOV ENTBEG,A
	SUB #DBUF,A
	CMP A,DBUF+6
	BHIS .POI3
.ENDC
	MOV @ENTBEG,A	;FIRST WORD OF ENTRY
	BEQ .POI3	;NO MORE ENTRIES BELOW THIS INDEX
	BIC #TYPMSK,A
.IIF NZ SITSD,SWAB A
.IIF Z SITSD,ASH #-5,A	;WHAT TYPE OF ENTRY?
	JSR PC,@POITAB(A)	;SERVICE THAT TYPE
.POI2:	MOV @ENTBEG,A
.IF Z SITSD
	BIC #177700,A	;LENGTH OF ENTRY IN WORDS
	ASL A		;NOW IN BYTES
.IFF
	INC A
	BIC #177401,A
.ENDC
	ADD A,ENTBEG	;START OF NEXT ENTRY
	BR .POI1

POIHED:	JSR PC,POFNM	;PRINT OUT HEADING
	JMP .CRLF	;CARRIAGE RETURN, LINEFEED
POILNK:	.BUG.		;NOT IMPLEMENTED
POIFLE:	SPACE		;INDENT TWO SPACES
	SPACE
	JSR PC,POFNM	;PRINT OUT FILE NAME
	SPACE
	JSR PC,DESSET	;SET DESCRIPTOR
	CLR -(P)	;HOLDS NUMBER OF BLOCKS OF CURRENT FILE
POIFL2:	TST DEOFBL	;LAST BLOCK OF FILE?
	BGT POIFL1	;YES
	INC (P)		;NO, INCREMENT NO. OF BLOCKS USED
	JSR PC,GNBLK	;GET ADDRESS OF NEXT BLOCK
	BR POIFL2	;CHECK AGAIN
POIFL1:	SPOP A		;NO. OF BLOCKS USED
	ADD A,DBGOT	;PTR TO LAST BLOCK OF ENTRY
	JSR PC,PRDN	;PRINT NO. OF BLOCKS USED BY FILE
	JMP .CRLF
POIDIR:	INC DBGOT	;NEXT BLOCK
	MOV #'I,D
	JSR PC,TYO	;PRINT "I" TO INDICATE INDEX
	SPACE
	BR POIHED	;PRINT OUT HEADING
.POI3:	MOV DBGOT,A	;TOTAL NUMBER OF BLOCKS USED
	JSR PC,PRDN
LANGC	<PRTXTC ^/ BLOCKS./>,<
	PRTXTC ^/ BLOCS./>
	MOV WCHDSK,A
	MOV NBLKFR(A),A	 ;NO. OF FREE BLOCKS
	JSR PC,PRDN
LANGC	<PRTXTC ^/ FREE BLOCKS./>,<
	PRTXTC ^/ BLOCS LIBRES./>
	SEZ
	RTS PC
POFNM:	MOV ENTBEG,A
	TST (A)+	;SKIP FIRST WORD OF ENTRY
.IF NZ SITSD
	BGE .+6
	ADD #10,A
	TST (A)+
.ENDC
POIHD2:	MOVB (A)+,D	;CHAR. OF FILE NAME
	BLT POIHD1	;NO MORE CHARACTERS
	JSR PC,@PCHR	;PRINT THE CHARACTER
	BR POIHD2	;LOOK FOR NEXT ONE
POIHD1:	JSR PC,@PCHR	;LAST CHARACTER
POIPAR:	RTS PC
POTHED:	CMP CURDIR,DEFDIR	
	BEQ POIHED	;PRINT OUT CURRENT DIRECTORY NAME
	RTS PC		;RETURN IF NOT THE SAME
.POTREE:
	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO	;FILE ALREADY OPEN
	CLR DBGOT
	JSR PC,SETDEF	;SET DEFAULT DISK AND DIRECTORY
	CLR DSKNSC	;NO CHARACTERS IN BUFFER
.POTR2:	JSR PC,GCDIR	;GET CURRENT DIRECTORY
	MOV #DBUF,ENTBEG   ;ENTRY AT START OF DISK BUFFER
.POTR1:	.IF NZ SITSD
	MOV ENTBEG,A
	SUB #DBUF,A
	CMP A,DBUF+6
	BHIS .POTR3
.ENDC
	MOV @ENTBEG,F	;FIRST WORD OF ENTRY
	BEQ .POTR3
.IF Z SITSD
	BIT #300,F	;IS IT TYPE DIRECTORY?
.IFF
	BIC #TYPMSK,F
	BEQ .POTR4	;IGNORE THE SELF ENTRY
	CMP #4000,F
.ENDC
	BEQ .POTR4	;YES
	MOV DSKNSC,A	;NO. OF SECTORS IN FILE
	BEQ .POTR4	;NO MORE
.POTR6:	JSR PC,.SPACE	;INDENT TWO SPACES
	JSR PC,.SPACE
	SOB A,.POTR6	;IS ENTRY ANOTHER LEVEL DOWN?
	BR .POTR4	;NO, PRINT THE NAME
.POTR3:	DEC DSKNSC	;ONE LESS SECTOR
	BLT .POI3	;DONE- PRINT OUT TOTAL NO. OF BLOCKS USED
	MOV (P),E
	SPOP CURDIR	;GET BACK PREVIOUS DIRECTORY
	POP ENTBEG	;GET BACK START OF OLD ENTRY
	JSR PC,DBREAD	;SET BLOCK FOR READING
	BR .POTR5
.POTR4:	BIC #TYPMSK,F	;FIND TYPE OF ENTRY
.IF Z SITSD
	ASH #-5,F
.IFF
	SWAB F
.ENDC
	JSR PC,@POTTAB(F)	;AND SERVICE APPROPRIATE TYPE
.POTR5:	MOV @ENTBEG,A	;FIRST WORD OF ENTRY
.IF Z SITSD
	BIC #177700,A
	ASL A		;NO. OF BYTES IN ENTRY
.IFF
	INC A
	BIC #177401,A
.ENDC
	ADD A,ENTBEG	;START OF NEXT ENTRY
	BR .POTR1	;GO GET IT

POTDIR:	JSR PC,POIDIR	;PRINT OUT INDEX
	INC DSKNSC	;ONE MORE SECTOR (ONE LEVEL DOWN)
	TST (P)+	;BYPASS TOP OF P-PDL
	PUSH ENTBEG	;SAVE START OF ENTRY
	SPUSH CURDIR	;SAVE CURRENT DIRECTORY
	JSR PC,DRREAD	;SET UP NEW CURRENT DIRECTORY
	BR .POTR2

.CRINDEX:
	JSR PC,DSET	;SET THE DIRECTORY
	MOV #NAME,E	;PTR TO INDEX NAME
	JSR PC,NFNGET	;GET THE NAME
.CRIN1:	JSR PC,GCDIR	;GET THE CURRENT DIRECTORY
	MOV #WDIRSW,D	;LOCK IN WRITE DIRECTORY SWITCH
	JSR PC,LCGRAB	;RUN DISK REQUEST
.IF Z SITSD
	MOV #20300,DESSAV  ;DESCRIPTOR SET TO TYPE DIRECTORY
	JSR PC,DESWST	;DESCRIPTOR WRITE MODE SET TO SKIP
	JSR PC,DBGET	;GET THE DISK BLOCK
	JSR PC,DESINS	;INSERT THE DESCRIPTOR
	BIC #377,DESSAV	;CLEAR LOW-ORDER BYTE OF FIRST WORD
	JSR PC,DESWST
	MOV CURDIR,A
	JSR PC,DBGOTN
	MOV DBGOT,CURDIR	;BLOCK OF CURRENT DIRECTORY
	MOV #2000,DBUF+1776	;LENGTH OF ENTRY (BYTES)
	MOV #DBUF,ENTBEG	;START OF ENTRY
	JSR PC,DESINX
	JSR PC,WBITS	;WRITE BIT TABLE OUT
	MOV #WDIRSW,D
	JMP LCUGRB
.IFF
	MOV #DIR,DESSAV
	JSR PC,DESWST
	MOV #-100,LBLKAD	;GARENTEE A SET ADDRESS TYPE
	JSR PC,DBGET		;GET A BLOCK FOR THE DIRECTORY
	JSR PC,DESINS
	MOV DBUF,C
	INC C
	BIC #177401,C
	ADD #DBUF,C
.CRIN3:	MOV -(C),-(P)
	CMP #DBUF,C
	BNE .CRIN3
	MOV @ENTBEG,B
	INC B
	BIC #177401,B
	ADD ENTBEG,B
.CRIN2:	MOV -(B),-(P)
	CMP B,ENTBEG	
	BNE .CRIN2
	MOV #DBUF,A
	MOV (P)+,C
	BIC #177400,C
	MOV C,(A)
	ADD #10,(A)
	BIS #LBEB!EOFBIT!4000,(A)+
	MOV (P)+,(A)+
	SUB #3,C
	ASR C
	CLR (A)+
	CLR (A)+
	MOV #-1,(A)+
	MOV #-1,(A)+
	MOV (P)+,(A)+
	SOB C,.-2
	MOV (P)+,C
	BIC #177400,C
	SUB #10,C
	MOV C,(A)+
	MOV (P)+,(A)+
	SUB #3,C
	ASR C
	ADD #10,P
	MOV (P)+,(A)+
	SOB C,.-2
	CLR (A)
	SUB #DBUF,A
	MOV A,DBUF+6
	MOV DBGOT,E
	JSR PC,DBWRTE
	JSR PC,WBITS
	MOV #WDIRSW,D
	JMP LCUGRB
.ENDC

.POF:	JSR PC,.READF
.POF1:	JSR PC,.READC
	CMP #EOFCHR,D
	BEQ .POF2
	JSR PC,@PCHR
	BR .POF1
.POF2:	CLR FILFLG
	RTS PC
.PREAD:.PWRIT:	ERROR+OOP
.IFNZ DRIBF
DRIBBLE:
	JSR PC,.OPENA	;OPEN THE FILE FOR APPENDING
	BIS #DRIBBF,FLAGS2	;SAY WE ARE DRIBBLING
	SEZ
	RTS PC

NODRIBBLE:
	JSR PC,.CLOSF	;CLOSER THE FILE
	BIC #DRIBBF,FLAGS2	;NO MORE DRIBBLE
	SEZ 
	RTS PC
.ENDC


GNWRD:	;INPUT	POINTER TO LIST OF WORDS ON S
	;OUTPUT	-IF LIST IS NOT EMPTY,
	;	 POINTER TO  FIRST OF LIST ON TOP OF S
	;	 POINTER TO BF OF LIST NEXT
	;	 Z WILL BE CLEAR
	;	-IF LIST IS EMPTY, POP S AND SET Z
	;IF F LIST ISNT A WORD, WTA ERROR ISSUED
	JSR F,CACSAV
	MOV @S,B
	BIT #7777,B	;IS LIST EMPTY?
	BEQ GNWRD1
	JSR PC,.LOADB	;NO GET 1ST NODE
	MOV A,@S	;SAVE BF ON S
	PUSHS B		;YES - PUSH FIRST ON S
	JSR F,CACRES
	CLZ
	RTS PC
GNWRD1:	POPS A		;EMPTY LIST QUIT
	JSR F,CACRES
	SEZ
	RTS PC
NFNGET:		;INPUT	ADDRESS OF BLOCK IN E
		;	PTR TO LSTR ON S
		;OUTPUT	PUT 1ST 10. CHAR OF LSTR INTO BLOCK
		;	SET 200 BIT IN LAST CHAR, POP S
	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,B	;POINTER TO FILE NAME IN B
	MOV #LSTR,A	;DATA TYPE FOR CONVERSION
	JSR PC,CONVER	;MAKE NAME AN LSTR
	BNE .+4
	ERROR+IFN	;INVALID FILE NAME (CONVERSION FAILED)
	MOV B,@S	;POINTER TO NEW DATA ON STACK
	BIC #170000,B	;LEAVE DATA TYPE
	MOV B,GNCN	;"GET NEXT CHARACTER" NODE
	MOV #10.,C	;TAKES ONLY THIS MANY CHARACTERS
NFNG1:	JSR PC,GNC	;GET NEXT CHAR
	CMP #15,D	;UGH! (IS IT A CARRIAGE RETURN?)
	BEQ NFNG2	;YES- NO MORE CHARACTERS
	MOVB D,(E)+	;STORE THE NEXT CHARACTER
	MOV D,TEMP
	SOB C,NFNG1	;KEEP GOING UNTIL WE HIT TEN
NFNG2:	BISB #200,-(E)	;SET 200 BIT IN LAST CHAR AND QUIT
	JSR F,CACRES	;GET BACK THE OLD REGISTERS
	JSR PC,SPOPT
	RTS PC
SETNM:		;INPUT	LIST OR WoRD ON S
		;OUTPUT	IF WORD, OUTPUT WORD AND SET Z
		;	IF LIST, OUTPUT LzST AND BL OF LIST ON S
		;		PUT BL ON TOP AND CLEAR Z
		;	OTHERWISE ERROR
	TST FILFLG	;IS FILE OPEN?
	BEQ .+4		;NO
	ERROR+FAO	;FILE ALREADY OPEN
	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,C	;GET INPUT
	BIT #7777,C
	BNE .+4
	ERROR+IFN	;INVALID FILE NAME
	MOV C,B		;SEE IF IT'S A LIST
	BIC #7777,C
	CMP C,#LIST
	BEQ SETNM1	;YES, IT IS
SETNM2:	JSR F,CACRES	;OK, SET Z AND QUIT
	SEZ
	RTS PC
SETNM1:	JSR PC,COPYL	;COPY LIST - INPUT IN B
		;OUTPUT IN B;  C POINTS TO LAST NODE IN NEW LIST
		; E POINTS TO 2ND TO LAST NODE
	JSR PC,.LDP2
	MOV A,@S
	MOV E,C
	BEQ SETNM3	;NO BUTLAST
	JSR PC,.LDP1	;FIX UP  LINK
	BIC #7777,A
	JSR PC,.STP1
	BIS #LIST,B
SETNM4:	PUSHS B
	JSR F,CACRES
	CLZ
	RTS PC
SETNM3:	MOV #LSTR,B
	BR SETNM4
;LOWER LEVEL ROUTINES

;GCDIR GET CURRENT DIRECTORY
;READS IN BIT TABLE IF IT IS NOT ALREADY IN

GCDIR:	TST FDBITI	;IS THE BIT TABLE IN?
	BGE GCDIR1	;YES, GO AHEAD
	TST USER	;IS IT USER 0?
	BEQ GCDIR1	;HE IS ALLOWED ALWAYS
GCDIR4:	JSR PC,FLUSH	;EVERYONE ELSE
	TST FDBITI	;HAS TO WAIT FOR INITIALIZE TO FINISH
	BLT GCDIR4
	JSR PC,RUNME
GCDIR1:	MOV CURDIR,E
	JMP DBREAD
IDISKS:	TST FDBITI	;IS IT IN NOW?
	BGE GCDIR5	;NO, IT'S NOW OUR RESPONSIBLITY
	CLR WCHDSK
GCDIR2:	MOV #46,CURDIR	;GET THE ROOT DIRECTORY IN
	MOV #BITS,E	;THE NAME OF THE BIT TABLE
	JSR PC,DIRSER	;TRY TO FIND IT
	BNE IDISK1
	MOV #-1,DBITAD(F)
	BR IDISK2
IDISK1:	JSR PC,DESSET	;SETUP THE DESCRIPTOR
	MOV WCHDSK,F
	MOV DSKADR,DBITAD(F)	;ADDRESS OF THE BIT TABLE
	MOV FDNAMP(F),A
.IF Z SITSD
	MOV #DBUF+2,D
.IFF
	MOV #DBUF+14,D
.ENDC
	MOVB (D)+,(A)+
	BGE .-2
	JSR PC,RBITS
	MOV @FDBITP(F),A
	MOV A,D
	DEC A
GCDIR3:	JSR PC,BITGET
	BITB BMT(B),(C)
	BEQ .+4
	DEC D
	DEC A
	BGE GCDIR3
	MOV WCHDSK,F
	MOV D,NBLKFR(F)
	MOV #-1,FDUSEA(F)
	MOV #USRFIL,E
	JSR PC,DIRSER
	BEQ IDISK2
	JSR PC,DESSET
	MOV WCHDSK,F
	MOV DSKADR,FDUSEA(F)
IDISK2:	ADD #2,WCHDSK
	INC FDBITI
	BNE GCDIR2
GCDIR5:	CLR WCHDSK
.IIF NZ SITSD,MOV #4,WCHDSK	;START ON PSEUDO-FIXED DISK IF SITS FORMAT
	RTS PC


;DIRSER  DIRECTORY SEARCH
;SEARCH CURRENT DIRECTORY FOR SPECIFIED FILE
;ENTER WITH POINTER TO FILE NAME IN E
;Z IS SET IF FOUND, ELSE CLEARED
DIRSER:	SPUSH E
	JSR PC,GCDIR	;GET CURRENT DIRECTORY
	MOV #DBUF,ENTBEG  ;DISK BUFFER ADDRESS IS START OF ENTRY
.IF Z SITSD
DIRSR1:	MOVB @ENTBEG,B	;B CONTAINS NO OF WORDS IN ENTRY
	BIC #177700,B
	ASL B		;LENGTH IN BYTES
	ADD B,ENTBEG
.IFF
	MOV @ENTBEG,B
	INC B
	BIC #177401,B
	ADD B,ENTBEG
DIRSR1:	MOV @ENTBEG,B
	INC B
	BIC #177401,B
	ADD B,ENTBEG
.ENDC
DIRSR4:	MOV (P),E
	MOV ENTBEG,B
	TST (B)+	;SKIP THE FIRT WORD
	BEQ DIRSR3	;FOUND THE END OF THE DIRECTORY
.IF NZ SITSD
	BGE .+6
	ADD #10,B
	TST (B)+
.ENDC
DIRSR2:	CMPB (B)+,(E)+	;COMPARE NAMES BYTE BY BYTE
	BNE DIRSR5	;MISMATCH
	TSTB -1(B)	;END OF NAMES?
	BGE DIRSR2	;NOT YET
	TST (P)+	;YES, FLUSH TEMP ON STACK
	CLZ
	RTS PC
DIRSR3:	TST (SP)+
	SEZ
	RTS PC
DIRSR5:	MOVB -(B),A	;MISMATCHED CHARACTER IN DIRECTORY
	MOVB -(E),E	;SAME THING IN DESIRED NAME
	BIC #177600,A	;GET RID OF CRAP
	BIC #177600,E	;SAME
	CMP A,E		;WHAT IS THE REAL RELATIONSHIP?
	BGT DIRSR3	;DIRECTORY>DESIRED, WE ARE PAST WHAT WE WANT
	BLT DIRSR1	;DESIRED>DIRECTORY, MAYBE IT'S FURTHER ON.
	TSTB (B)	;SAME, IS DIRECTORY SHORTER?
	BLT DIRSR1	;YES, MAYBE FURTHER ON.
	BR DIRSR3


;DESSET SET UP DESCRIPTOR

.IF Z SITSD
DESSET:	CLR DBCNT	;CLEAR DISK BLOCK COUNT
	CLR DSKADR	;CLEAR CURRENT SECTOR
	MOV #-1,DEOFBL
	MOV ENTBEG,A	;START OF NEW ENTRY
	MOV #DESSAV,B	;START OF OLD DESCRIPTOR
	MOV (A),C
	BIC #177700,C	;LENGTH OF NEW ENTRY IN WORDS
	MOV (A)+,(B)+	;WRITE OVER OLD STUFF
	SOB C,.-2
DESST:	MOV #DESSAV,A	;START OF NEW DESCRIPTOR
	MOV (A),D	;LENGTH IN BYTES
	BIC #177700,D
	MOV A,C
	MOV (A),E
	BIC #177477,E	;FLUSH ALL BUT TYPE
	CMP #200,E	;IS IT A FILE
	BNE .+6		;NO, DIRECTORY
	SUB #2,D	;YES, DATE IS NOT PART OF DESCRIPTOR
	ASL D		;NUMBER OF BYTES
	ADD D,C		;END OF DESCRIPTOR
DESST2:	TSTB -(C)	;GET RID OF TRAILING BLANKS
	BEQ .-2
DESST1:	MOV C,DESEPT	;REAL END OF ESCRIPTOR
	CMP #100,E
	BNE .+4
	ERROR+BADE	;BAD ENTRY TYPE
	TST (A)+	;SKIP FIRST WORD
	TSTB (A)+	;FIND END OF NAME
	BGE .-2
	BR GNBLK1
.IFF
DESSET:	CLR DBCNT	;CLEAR DISK BLOCK COUNT
	CLR DSKADR	;CLEAR CURRENT SECTOR
	MOV #-1,DEOFBL
	MOV ENTBEG,A	;START OF NEW ENTRY
	MOV #DESSAV,B	;START OF OLD DESCRIPTOR
	MOV (A),C
	BIC #177400,C
	CMP C,#120.
	BLE .+4
	ERROR+BADD
	MOVB (A)+,(B)+
	SOB C,.-2
DESST:	MOV #DESSAV,A
	MOV (A),D
	BIC #177400,D
	ADD A,D
	DEC D
	MOV D,DESEPT
	BIT #EOFBIT,(A)+
	BEQ .+6
	ADD #10,A
	TST (A)+
	TSTB (A)+
	BGE .-2
	BR GNBLK1
.ENDC

;GNBLK GET THE ADDRESS OF THE NEXT BLOCK INTO DSKADR
GNBLK:	INC DSKADR
	DEC DBCNT
	BLT GNBLK2
GNBLK3:	BNE GNBLK4	;MORE THAN THIS BLOCK LEFT
	CMP DESPNT,DESEPT	;AT END OF DESCRIPTOR?
	BLOS GNBLK4	;NO, HAPPY
	CLR DEOFBL	;READING LAST BLOCK
GNBLK4:	MOV #DBUF,DBUFPT
	RTS PC
GNBLK2:	MOV DESPNT,A	;NO BLOCKS LEFT TO COUNT, LOOK INTO DESCRIPTOR
GNBLK1:	CMP A,DESEPT
	BLOS GNBLK7
	MOV #1,DEOFBL
	RTS PC
GNBLK7:	MOVB (A)+,B
	MOV A,DESPNT	;NEW POINTER
	MOV B,C
	BIC #177477,B	;WHAT KIND OF BYTE?
	BIC #177700,C	;WITH WHAT DATA
	ASH #-5,B
	MOV #DESMOD,F
	JMP @GNBTAB(B)	;SERVICE THAT TYPE

GNBSKP:	TST C	;ZERO IS THE NULL BYTE
	BEQ GNBLK1	;REALLY ONLY FOR THE END OF DESCRIPTOR, BUT...
	ADD C,DSKADR
	MOV #DBGSKP,(F)
	CLR DBCNT
	BR GNBLK3

GNBCNT:	MOV #DBGCNT,(F)
	MOV C,DBCNT
	BR GNBLK3

GNBADR:	MOVB (A)+,DSKADR
	MOVB (A)+,DSKADR+1
	MOV A,DESPNT
	MOV #DBGADR,(F)
	MOV C,DBCNT
	BR GNBLK3

GNBSCN:	MOV C,B
	BIC #177770,B
	BIC #177707,C
	ASH #-3,C
	ADD C,DSKADR
	MOV #DBGSCT,(F)
	MOV B,DBCNT
	BR GNBLK3

DESWST:	MOV #NAME,A
.IF NZ SITSD
	BIT #EOFBIT,DESSAV
	BEQ DESWS1
	CLR FPAGE
	CLR FBYTES
	ADD #10,A
DESWS1:
.ENDC
	TSTB (A)+
	BGE .-2
	CLRB (A)
	MOV A,DESPNT
	MOV #-1,LBLKAD
	MOV #DBGSKP,DESMOD
	RTS PC

DBGET:	MOV WCHDSK,E
	JSR PC,BCHK
	MOV @FDBITP(E),E
	CLR A
DBGET1:	JSR PC,BITGET
	BITB BMT(B),(C)
	BEQ DBGET2
	INC A
	SOB E,DBGET1
	ERROR+DFU
DBGET2:	MOV WCHDSK,F
	DEC NBLKFR(F)
	MOV A,DBGOT
	BISB BMT(B),(C)
DBGOTN:	.IF NZ SITSD
	MOV DESSAV,B
	BIC #TYPMSK,B
	CMP #DIR,B
	BEQ DBGET7
	ADD #2000,FBYTES
	CMP #20000,FBYTES
	BNE DBGET7
	CLR FBYTES
	INC FPAGE
DBGET7:
.ENDC
	MOV A,B
	SUB LBLKAD,B
	MOV A,LBLKAD
	MOV #DESMOD,F
	DEC B
	BEQ DBGET3
	CMP B,#7
	BLE DBGET4
	CMP B,#77
	BLE DBGET5
	MOV DESPNT,B
	MOVB #200,(B)+
	MOVB LBLKAD,(B)+
	MOVB LBLKAD+1,(B)+
	MOV B,DESPNT
	MOV #DBGADR,(F)
	RTS PC
DBGET4:	ASH #3,B
	BIS #300,B
	MOV #DBGSCT,(F)
DBGET6:	MOVB B,@DESPNT
	INC DESPNT
	RTS PC
DBGET5:	MOV #DBGSKP,(F)
	BR DBGET6
DBGET3:	MOV DESPNT,A
	JMP @DESMOD

DBGSK1:	INC A
DBGSKP:	MOVB #100,(A)
	INC DESPNT
	MOV #DBGCNT,(F)
	RTS PC
DBGCNT:	MOVB -(A),B
	BIC #177740,B
	INC B
	BIT #40,B
	BNE DBGSK1
	INCB (A)
	RTS PC
DBGADR:	MOVB -3(A),B
	BIC #177700,B
	INC B
	BIT #100,B
	BNE DBGSKP
	INCB -3(A)
	RTS PC
DBGSCT:	MOVB -(A),B
	BIC #177770,B
	INC B
	BIT #10,B
	BNE DBGSK1
	INCB (A)
	RTS PC
BCHK:	JSR F,ACSAV
	MOV FDBITP(E),C
	MOV NBLKFR(E),A
	MOV (C)+,B
BCHK3:	MOV (C)+,D
	BEQ BCHK1
	CMP #-1,D
	BEQ BCHK2
BCHK6:	MOV #20,E
BCHK5:	ROR D
	BCS .+4
	DEC A
	DEC B
	BEQ BCHK4
	SOB E,BCHK5
	BR BCHK3
BCHK1:	CMP #20,B
	BGE BCHK6
	SUB #20,B
	SUB #20,A
	BR BCHK3
BCHK2:	CMP #20,B
	BGE BCHK6
	SUB #20,B
	BR BCHK3
BCHK4:	TST A
	BEQ .+6
BADBIT:	BPT
	BR .-2
	JSR F,ACRES
	RTS PC

DESINS:	CMP #46,CURDIR	;IS THIS THE ROOT DIRECTORY?
	BNE DESIN5
	BIT #SSF,FLAGS2	;YES, IS STATUS ON?
	BNE DESIN5
	JSR PC,WDELBL
	ERROR+DRF	;DIRECTORY FULL
DESIN5:	MOV #NAME,E
.IFNZ SITSD
	BIT #EOFBIT,DESSAV
	BEQ .+6
	ADD #10,E
.ENDC
	JSR PC,DIRSER
	BEQ DESINX
	JSR PC,WDELBL
	ERROR+EAES
DESINX:	JSR PC,DESINC
	ASL A
.IF Z SITSD
	MOV #DBUF+1776,B
	SUB (B),B
	TST (B)+
	MOV B,C
	ADD A,C
	CMP #DBUF+1770,C
	BGT DESIN4
	JSR PC,.DELBL
	ERROR+DRF
DESIN4:	CLR (C)
DESIN2:	CMP B,ENTBEG
	BEQ DESIN3
	MOV -(B),-(C)
	BR DESIN2
DESIN3:	MOV #DESSAV,C
	SUB A,DBUF+1776
	ASR A
	MOV (C)+,(B)+
	SOB A,.-2
	MOV CURDIR,E
	JMP DBWRTE
.IFF
	MOV #DBUF+6,B
	MOV (B),C
	ADD A,C
	CMP #1770,C
	BGT DESIN4
	JSR PC,.DELBL
	ERROR+DRF
DESIN4:	MOV (B),E
	ADD A,(B)
	ADD #DBUF,E
	ADD #DBUF,C
	CLR (C)
DESIN2:	CMP E,ENTBEG
	BEQ DESIN3
	MOV -(E),-(C)
	BR DESIN2
DESIN3:	MOV #DESSAV,B
	ASR A
	MOV (B)+,(E)+
	SOB A,.-2
	MOV CURDIR,E
	JMP DBWRTE
.IFT
DESINC:	MOV DESPNT,A
	BIT #1,A
	BEQ .+4
	CLRB (A)+
	MOV DESSAV,B
	BIC #177477,B
	CMP #200,B
	BNE DESIN1
	MOV #-1,(A)+
	MOV #-1,(A)+
DESIN1:	SUB #DESSAV,A
	ASR A
	ADD A,DESSAV
	RTS PC
.IFF
DESINC:	MOV DESPNT,A
	SUB #DESSAV,A
	ADD A,DESSAV
	INC A
	ASR A
	MOV #-1,FVERN
	BIT #EOFBIT,DESSAV
	BEQ DESIN1
	MOV #-1,FTIME
	MOV #-1,FDATE
DESIN1:	RTS PC
.ENDC


;ENTER DBREAD AND DBWRTE WITH ADDRESS OF BLOCK TO HACK IN E
DBREAD:	MOV #DREADC,F
	BR .+6
DBWRTE:	MOV #DWRTEC,F
	MOV E,D
	SPUSH A
	SPUSH B
	SPUSH C
	JSR PC,SYDRBG	;GET THE REQUEST BLOCK
	CLR (A)+	;NO START ROUTINE
	MOV #-1000,(A)+	;ONE SIZE, ONE PRICE, ONE QUALITY!
	MOV #DBUF,(A)+	;AND ONE PLACE TO PUT IT
	MOV USER,B	;TO FIND THE APPROPRIATE SLOT
	MOV SLOTAS(B),B
	SUB #PURE,-(A)
	MOV SLOTHA(B),C
	ADD SLOTCA(B),(A)+
	ADC C
	ASH #4,C
	BIS C,6(A)
DBWRT1:	ASL D
	CLR C
	DIV #12.,C
	ASH #4,C
	ADD C,D
	MOV WCHDSK,C
	ADD FDDSKN(C),D
	MOV D,(A)+
	MOV #-1,(A)+
	TST (A)+
	BISB F,(A)
	JSR PC,DSKWAI
	SPOP C
	SPOP B
	SPOP A
	RTS PC

WBITS:	JSR PC,WBITS1
WCBITS:	MOV #DWRTCC,F
	BR .+6
RBITS:	MOV #DREADC,F
	BR .+6
WBITS1:	MOV #DWRTEC,F
	JSR PC,SYDRBG
	CLR (A)+
	MOV #-NBTTL,(A)+
	MOV WCHDSK,D
	MOV FDBITP(D),(A)+
	SUB #6,P
	MOV DBITAD(D),D
	BIC #60,6(A)
	BR DBWRT1

BITGET:	MOV A,B		;A CONTAINS THE BLOCK NUMBER
	MOV A,C		;B WILL CONTAIN THE BIT NUMBER
	BIC #177770,B	;THERE!
	ASH #-3,C	;AND C GETS THE BYTE NUMBER
	SPUSH B
	MOV WCHDSK,B
	CMP A,FDBITP(B)
	BLO .+4
	BPT
	ADD FDBITP(B),C
	ADD #2,C
	SPOP B
	RTS PC
READPT:	SPOP A
	SPOP B	;GET RET ADDR + NUM ARGS
	SPUSH A	;PUT BACK RETURN ADDR
	TST B		;ZERO ARGS?
	BEQ READP1	;JUST READ INTO WORKSPACE
	CMP #1,B	;EXACTLY 1?
	BEQ 1$		;YUP
	ERROR+WNA
1$:	JSR PC,PRINIT
	JSR PC,.OPENW	;OPEN FILE FOR OUTPUT
2$:	JSR PC,PRGETR	
	BEQ 3$
	JSR PC,.WRTEC
	BR 2$
3$:	JSR PC,.WRTCL
	MOV #-1,PGRAB
	SEZ
	RTS PC

READP1:	JSR PC,PRINIT
	MOV #PRGET,GCHR
	SEZ
	RTS PC

PRINIT:	JSR PC,PINIT
	MOV #101,PRS
	RTS PC

PINIT:	TST PGRAB
	BLT .+4
	ERROR+DIU
	MOV USER,PGRAB
	MOV #PBUF,PBFPTI
	MOV #PBUFE-1,PBFPTM
	CLR NPCHRS
	RTS PC
PRGETR:	SPUSH U
	MOV USER,U
PRGET2:	TST NPCHRS
	BNE PRGET1
	TST PRS
	BLT PRGET9
	JSR PC,FLUSH
	BR PRGET2
PRGET1:	JSR PC,RUNME
	SPOP U
	BIC #100,PRS
	DEC NPCHRS
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	MOVB @PBFPTM,D
	BIS #100,PRS
	CLZ
	RTS PC

PRGET9:	JSR PC,RUNME
	SPOP U
	MOV #EOFCHR,D
	SEZ
	RTS PC


PRGET:	JSR PC,PRGETR
	CMP #EOFCHR,D
	BNE .+10
	MOV #-1,PGRAB
	RTS PC

PRBRK:	SPUSH A
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOV PRB,A
	TST PRS
	BLT PRBRK1
	BIC #200,A
	BEQ PRBRK2
	MOVB A,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	CMP #PBUFE-PBUF,NPCHRS
	BNE .+10
PRBRK1:	BIC #100,PRS
PRBRK2:	SPOP A
	INC PRS
	RTT

WRITEP:	SPOP A
	SPOP B	;GET RET ADDR + NUM ARGS
	SPUSH A		;PUT BACK ADDR
	TST B		;ZERO ARGS?
	BNE WRTPFL	;JUST WRITE OUT FILE
	JSR PC,PINIT
	JSR PC,FEED
	MOV #PPPUT,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	CLR WRTFLG
	MOV #TYO,PCHR
	MOV #EOFCHR,D
	MOV #10.,A
	JSR PC,FEED1
	JSR PC,FEED
	MOV #-1,PGRAB
	SEZ
	RTS PC



WRTPFL:	CMP #1,B	;EXACTLY 1?
	BEQ 1$		;YUP
	ERROR+WNA
1$:	JSR PC,PINIT
	JSR PC,FEED
	JSR PC,.OPENR
2$:	JSR PC,.READC
	BEQ 3$
	JSR PC,PPPUT
	BR 2$

3$:	JSR PC,.CLOSF
	MOV #EOFCHR,D
	MOV #10.,A
	JSR PC,FEED1
	JSR PC,FEED
	MOV #-1,PGRAB
	SEZ
	RTS PC

FEED:	MOV #100.,A
	CLR D
FEED1:	JSR PC,PPPUT
	DEC A
	BNE FEED1
	RTS PC

PPPUT:	SPUSH U
PPPUT2:	MOV USER,U
	CMP #PBUFE-PBUF,NPCHRS
	BNE PPPUT1
	JSR PC,FLUSH
	BR PPPUT2
PPPUT1:	JSR PC,RUNME
	SPOP U
	TST PPS
	BPL .+4
	ERROR+DNR
	CLR PPS
	CMP #PBUFE,PBFPTI
	BNE .+10
	MOV #PBUF,PBFPTI
	MOVB D,@PBFPTI
	INC PBFPTI
	INC NPCHRS
	BIS #100,PPS
	RTS PC

PPBRK:	TST NPCHRS
	BEQ PPBRK1
	INC PBFPTM
	CMP #PBUFE,PBFPTM
	BNE .+10
	MOV #PBUF,PBFPTM
	DEC NPCHRS
	MOVB @PBFPTM,PPB
	RTT
PPBRK1:	CLR PPS
	RTT
;THE LINE PRINTER/PLOTTER OUTPUT CODE
.IFNZ LPF
LPRINT: BIT #100000,LPCSR  ;ERROR?
	BEQ .+4
	ERROR+DIU
	TST LPFLG  ; IN USE?
	BEQ .+4     ;NO
	ERROR+DIU
	JSR PC,RDBKN
	BIS #LPIUFG,LPFLG  ;LOCK OUT OTHERS
	MOV FLGTH,BKSTGO
	MOV #14,LPCSR+2   ;FORMFEED
	JSR PC,FLPB  ;FILL 1ST BUFFER,ENABLE INTERUPT,GO
        SEZ
	RTS PC


RDBKN:  JSR PC,GETFIL
	CMP #FILE,A
	BEQ .+4
	ERROR+CRE  ;ENTRY ISN'T A FILE
	JSR PC,DESSET
	CLR LSTBKL
	MOV #BKTBL,A
	BR RDBKN4
RDBKN1: SPUSH A
	JSR PC,GNBLK
	SPOP A
RDBKN4:	MOV DSKADR,D   ;CRUNCHES OUT
	ASL D          ;PROPER FORM
	CLR C          ;OF DISK ADDRESS
	DIV #12.,C
        ASH #4,C
	ADD C,D
	MOV WCHDSK,C
	ADD FDDSKN(C),D
	MOV D,(A)+
	TST DEOFBL	;LAST BLOCK
	BEQ RDBKN3		;YES
	CMP A,#BKTBL+<2*MNLPB>  ;AT END OF TABLE?
        BLT RDBKN1       ;NO
        MOV #MNLPB,FLGTH
        MOV #2000,LSTBKL
        RTS PC
RDBKN3:	SUB #BKTBL,A
        ASR A
        MOV A,FLGTH
.IFZ SITSD
        BITB #40,DESSAV+1  ;LAST WORD USED?
        BEQ .+4		;YES
        RTS PC
	MOV #2000,LSTBKL	;HERE EITHER A LAST BYTE OR LAST WORD USED
	BITB #20,DESSAV+1  ;LAST BYTE USED?
	BEQ .+6            ;YES
	DEC LSTBKL
	RTS PC
.IFF
	MOV DESSAV+6,LSTBKL	;THE BYTE COUNT
	BIC #176000,LSTBKL	;THE NUMBER OF BYTES
	RTS PC
.ENDC

FLPB:   TST BKSTGO  ;ANY LEFT?
	BGE .+4     ;YES
	RTS PC
	SPUSH A
	SPUSH B
	JSR PC,SYDRBG
	MOV #LPBDKT,(A)+ ;START ROUTINE
	MOV #-1000,(A)+
	BIT #LPB1FG,LPFLG  ;1ST EMPTY?
	BNE FLPB1          ;NO
	MOV #LPBUF1,(A)+
	MOV #LPB1MX,6(A)
	MOV #LPB1FG,PUTLPB  ;REMEMBER WHICH IS BEING FILLED
	BR FLPB2
FLPB1:  MOV #LPBUF2,(A)+
	MOV #LPB2MX,6(A)
	MOV #LPB2FG,PUTLPB
FLPB2:  MOV FLGTH,B
	SUB BKSTGO,B
	ASL B
	ADD #BKTBL,B    ;ADDRESS OF TABLE ENTRY
	MOV (B),(A)+
	MOV #-1,(A)+
	TST (A)+
	BISB #DREADC,(A)
	SPOP B
	SPOP A
	RTS PC
LPBDKT: MOV #LPADKT,(A)  ;TO RUN AFTER TRANSFER
	RTS PC
LPADKT: BIT #100000,LPCSR  ;ERROR?
	BEQ .+4            ;NO
	RTS PC
	SPUSH A
	SPUSH B
	MOV #2000,B
	CMP #LPB1FG,PUTLPB ;WHICH JUST FILLED?
	BNE LPDKT1
	MOV #LPBUF1,A
	BR LPDKT2
LPDKT1: MOV #LPBUF2,A
LPDKT2: CMPB (A)+,#15  ;CARRIAGE RETURN?
	BNE LPDKT3
	MOVB #12,-1(A) ;YES,REPLACE WITH LINEFEED
LPDKT3: SOB B,LPDKT2
	SPOP B
	SPOP A
	BIS PUTLPB,LPFLG ;TELL WHICH IS FILLED
	DEC BKSTGO
	MOV #100,LPCSR  ;ENABLE INTERRUPT
	RTS PC
LPBRK:  BIT #100000,LPCSR  ;ERROR?
	BEQ LPBRK1  ;NO
	BIC #100,LPCSR
	CLR LPFLG
	JSR PC,DEVER
	RTT
LPBRK1: BIC NOWLPR,LPFLG  ;NOW EMPTIED
	CLR NOWLPR
	BIT #3,LPFLG  ;EITHER BUFFER READY?
	BNE LPBRK2    ;YES
	BIC #100,LPCSR
	TST BKSTGO    ;ANY LEFT?
	BNE LPBRK7
	MOV #4,LPCSR+2 ;SEND AN EOT
	CLR LPFLG  ;ENABLE NEXT JOB
	RTT
LPBRK2: BIT #LPB1FG,LPFLG  ;1ST BUFFER READY?
	BEQ LPBRK3  ;NO
	MOV #1,NOWLPR
	MOV #LPBUF1,LPBUFF ;SAVE ADDRESS
	BR LPBRK4
LPBRK3:	MOV #2,NOWLPR
	MOV #LPBUF2,LPBUFF
LPBRK4: MOV LPBUFF,LPDBAR  ;STARTING ADDRESS FOR DMA
	TST BKSTGO
	BNE LPBRK6
.IFZ SITSD
	TST LSTBKL  ;2000 OR 1777 BYTES USED?
	BNE LPBRK5  ;YES
	ADD #1776,LPBUFF  ;LAST WORD
	MOV #2000,LSTBKL
	SUB @LPBUFF,LSTBKL  ;BYTE COUNT
.ENDC
LPBRK5: MOV LSTBKL,LPDBAR-2  ;STARTS DMA
	RTT
LPBRK6: MOV #2000,LPDBAR-2  ;STARTS DMA
LPBRK7: JSR PC,FLPB   ;FILL OTHER BUFFER
	RTT
.ENDC
	.STITL SCHEDULER


RUNME:	TST USER
	BGE RUNME1
RUNME2:	RTS PC	;SYSTEM CALLED RUNME

RUNME1:	TST FLSADR(U)	;IF HE WANTS TO RUN HE SHOULD JSR HERE
	BEQ RUNME2	;IF FLSADR IS ZERO, JUST KEEP RUNNING HIM
	MOV #-1,USER	;SYSTEM IS NOW USER
	JSR PC,UACSAV	;STORE HIS ACS
	CLR FLSADR(U)	;GUY IS NOW RUNABLE
	CLR FLSRES(U)
	INC NRABLU
	SPOP UPC(U)	;HE SHOULD START AFTER THE JSR PC,RUNME
NEXTU1:	CMP #SYSIDX,U	;IS IT THE SYSTEM JOB?
	BNE NEXTU2
	MOV P,SPDLP	;SET UP SYS JOB PDL
	MOV SJPDLP,P
	JMP RUNUS7

NEXTU2:	MOV SLOTAS(U),A	;IS HE ASSIGNED A SLOT?
	BLT NEXTU3	;NO, SEE IF WE CAN GET ONE
	TST SLOTST(A)	;YES, WHAT IS IT'S STATUS?
	BEQ NEXTUS	;GUY BEING SWAPPED IN
;WE GET HERE IF THE GUY IS IN CORE
	CMP #FRNEWU,FLSRES(U)	;RELOAD USER
	BNE NEXT14	;IN CORE AND NOT BEING GUNNED, RUN HIM
	CLR TIMUSD(U)
	MOV #UGO,FLSADR(U)	;RESTART HIM
NEXT16:	MOV A,SLOTAS(U)
	MOV U,SLOTU(A)
	MOV SLOTRB(A),C	;CORE ADDRESS OF ASSIGNED SLOT
	MOV #16,D
	JMP NEXT11	;GO DO A SPECIAL SWAPIN

NEXT14:	CLR FLSRES(U)
	JMP RUNUSR



;CALL TO GET INDEX OF NEXT USER TO RUN

NEXTUS:	MOV TTYUGO,U	;DID SOMEONE JUST TYPE CR?
	BGE NEXT15
	SUB #LUBLK,ULAST	;COUNT BACKWARDS
	BGE .+10	;DON'T GO NEG
	MOV #MNUSRS*LUBLK,ULAST	;LAST POSSIBLE USER INDEX
	MOV ULAST,U	;SEE IF THIS IS A GOOD GUY TO RUN
NEXT15:	MOV #-1,TTYUGO
	TST FLSADR(U)	;IF FLSADR IS ZERO, RUNABLE(???)
	BEQ NEXTU1	;RUN HIM.
	CMP #-1,FLSADR(U)	;-1 => NON EX USER
	BEQ NEXTUS
	SPUSH B
	MOV GUNU,B
	BLT NEX21B
	MUL #LUBLK,B
	CMP U,B
	BNE NEX21B
	SPOP B
	MOV #-1,GUNU
	MOV U,USER	;USER IS NOW USER
	MOV PC,BRAKE(U)
	JMP GOODBY

NEX21B:	SPOP B
NEXT21:	TSTB	FLSRES(U)
	BMI	NEXTUS
	MOV U,USER	;USER IS NOW USER
	JSR PC,UACRES	;RESTORE HIS ACS
	JMP @FLSADR(U)	;SEE IF HE SHOULD REALLY RUN



NEXTU3:	MOV PUSPSL,A	;SEE IF THERE IS A PREFERED SLOT
	BGE NEXTU6
NEXT20:	CLR A
	MOV NSLOTS,C
NEXTU4:	TST SLOTST(A)
	BLT NEXT16	;AN UNUSED SLOT!
	CMP #1,SLOTST(A)
	BGE NEXTU5	;GUY HASN'T RUN YET, DON'T SWAP HIM OUT
	TST NSWPU	;ARE THERE USERS BEING SWAPED?
	BEQ NEXTU6	;NO, SWAP ONE
	CMP NINU,#1	;IS THERE ONLY ONE USER IN CORE?
	BEQ NEXTUS	;YES, RUN HIM
NEXTU6:	MOV SLOTU(A),B	;USER THAT MAY BE SWAPED OUT
	BLT NEXT20
	CMP #FRTYIW,FLSRES(B)
	BEQ NEXT17
	MOV #LOCKUS,D
	MOV #NLOCKS,E
NEXT18:	CMP B,(D)+
	BNE NEXT19	;LOCKED IN CORE, DO NOT DISTURB
NEXT17:	TST PUSPSL
	BLT NEXTU5
	MOV #-1,PUSPSL
	BR NEXT20
NEXTU5:	TST (A)+
	SOB C,NEXTU4
	BR NEXTUS

NEXT19:	SOB E,NEXT18
	MOV #-1, PUSPSL	;IF THERE WAS A PREFERED SLOT, WE ARE DOING IT
	MOV SLOTU(A),B	;FOUND A GOOD SLOT, USER TO SWAP OUT INTO B
	MOV U,SLOTU(A)	;NEW OCCUPANT OF SLOT
	MOV #-1,SLOTAS(B)
	MOV A,SLOTAS(U)

;FALLS THROUGH

;FALLS IN

	CLR D
	MOV SLOTRB(A),C	;MOBY SWAP OUT BLOCK FOR THIS SLOT
	MOV #SWPOST,(C)+	;SWAP OUT USER START ROUTINE
	MOV USWCNT,(C)+	;WORD COUNT OF A USER SLOT
	MOV SLOTCA(A),(C)+	;SLOT CORE ADDRESS
	MOV USWPAD(B),(C)+	;LOW ORDER SWAP OUT ADDR OF U TO SWAP OUT
	MOV USWPAD+2(B),(C)+	;HIGH OORDER
	MOV B,(C)+	;SAVE USER GOING OUT FOR BRUCE
	MOV SLOTHA(A),E
	ASH #4,E
	BIS E,(C)
	BIS #DWRTEC,(C)+	;DISK WRITE COMMAND
	DEC NINU	;ONE LESS IN CORE
NEXT11:	CLR SLOTST(A)	;NOT IN YET: -1 TO SLOTST+2 OF GUY
	INC NSWPU	;ONE MORE MOVING AROUND
	MOV #SWPIST,(C)+	;SWAP IN USER START ROUTINE
	MOV USWCNT,(C)+	;SLOT WORD COUT
	MOV SLOTCA(A),(C)+	;SLOT CORE ADDRESS
	CMP #FRNEWU,FLSRES(U)
	BNE NEXT12
	MOV DCLRUS,(C)+	;DISK ADDRESS OF CLEAR USER
	MOV DCLRUS+2,(C)
	BIS #100000,(C)+
	CLR FLSRES(U)
	MOV #UGO,FLSADR(U)
	BR NEXT13

NEXT12:	MOV USWPAD(U),(C)+	;  "    "   
	MOV USWPAD+2(U),(C)+	;USER ADDRESS ON DISK
NEXT13:	MOV A,(C)+	;ADDRESS OF PLACE TO ZAP TO 1 WHEN DONE
	MOV SLOTHA(A),E
	ASH #4,E
	BIS E,(C)
	BIS #DREADC,(C)	;READ FROM DISK
	SUB #32,C	;BEGINING OF MOOBY SWAP REQ PAIR
	ADD D,C		;INDEX TO RIGHT ONE OF PAIR
	SPUSH PS
	MOV #340,PS	;NO INTS!
	MOV C,@SWPLEP
	ADD #2,SWPLEP	;GRONK ONTO REQ LIST
	SPOP PS
	JSR PC,DPROVK
	BR NEXT10

NEXTU7:	CMP #1,NUSERS
	BNE .+4
	WAIT
	MOV #-1,USER	;FLUSH ENTERS HERE, SYSTEM NOW USER
	BLT NEXT10
	MOV SLOTAS(U),A
	TST (A)	;IS HE REALLY IN?
	BLE NEXT10	;NO, NOT REALLY
	CMP #FRDSKW,FLSRES(U)	;IF JUST HUNG ON DISK
	BEQ NEXT10	;FORGET HIM
	MOV A,PUSPSL	;HE IS PREFERED OUT
	MOV U,PUSRSP
	BR NEXT10

NEXT10:	JMP NEXTUS
FLUSH:	TST USER
	BGE FLUSH4
	RTS PC

FLUSH4:	CLR 177570	;CLEAR DISPLAY REGISTER
	CLR DISPDR
	JSR PC,UACSAV	;STOP USER; STORE HIS ACS
	MOV FLSADR(U),A
	SPOP FLSADR(U)	;SAVE PC
	TST A	;IS THIS GUY ALREADY STOPED?
	BNE NEXTU7	;GO TRY ANOTHER GUY
	MOV #-1,USER
	MOV UTIME,A
	ADD A,JMTU(U)
	ASH #-5,A
	ADD A,TIMUSD(U)
	ADD A,TUTIME
	ADC TUTIME+2
	MOV #4,A
	MOV #LSTIM,B
	ADD U,B
	MOV #RSEC,C
FLUSH3:	MOVB (C)+,(B)+
	SOB A,FLUSH3
	TST FLSRES(U)
	BNE .+10
	MOV #FRRAND,FLSRES(U)
	DEC NRABLU
	CMP #SYSIDX,U
	BEQ FLUSH7
	CLR 177774
	MOV P,UPDLP	;SAVE USER'S POINTER
	MOV SPDLP,P	;SYSTEM PDL
FLUSH5:	JMP NEXTUS

FLUSH7:	MOV P,SJPDLP
	MOV SPDLP,P
	JMP NEXTUS
;RUNUSR, THE "MAIN LOOP"

RUNUSR:	CMP U,PUSRSP	;AM I THE GUY THEY WANT OUT?
	BNE .+10	;BRANCH IF NO
	MOV #-1,PUSPSL
	INC SLOTST(A)	;INDICATE THAT THIS GUY HAS BEEN RUN
	BVC .+10
	MOV #2,SLOTST(A)
	MOV SLOTAR(A),B
	MOV #PUREAR,C
	MOV B,(C)+
	ADD #200,B
	MOV B,(C)+
	ADD #200,B
	MOV B,(C)
	CLR DISPDR
	MOV DISAS(U),A
	BLT RUNUS8
	MOV DISAR(A),DISPAR
	MOV DISDR(A),DISPDR
RUNUS8:	MOV #PURE,BASEUS
	MOV P,SPDLP	;SAVE SYSTEM PDL POINTER
	MOV UPDLP,P	;GET USER PDL POINTER
RUNUS7:	MOV U,USER	;NOW HE'S REALLY THE GUY
	SPUSH UPC(U)	;PLACE TO START USER
	MOV QUANT,UQUANT	;RUN FOR 3 1/100TH'S????
	CLR UTIME
	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
	CLR A		;DISPLAY USER # IN DISPLAY REG
	MOV USER,B
	DIV #L,A	;(71027 000056)
	MOV #1,B
	ASH A,B		;(72100)
	MOV B,177570
	JMP UACRES	;RESTORE USER ACS AND START USER


SCHEDP:	TST UQUANT	;SEE IF IT'S TIME TO FLUSH
	BLE .+4	;NOT YET
	RTS PC
	SPUSH U
	MOV USER,U
	MOV #FRSCED,FLSRES(U)
	JSR PC,FLUSH
	JSR PC,RUNME
	SPOP U
	RTS PC
.STITL CLOCK BREAK ROUTINE

CLKBRK:	SPUSH A
	SPUSH B
	SPUSH	C
	ADD #40,UTIME
	INC TIME+2
	BNE CLKTOV
	INC TIME
CLKTOV:	DEC UQUANT
	DEC N50THS	;HAS THIS BEEN ONE SECOND?
	BLE DATEC	;YES, CHANGE THE SECOND
	;NEXT FIVE LINES ARE FOR TESTING DISPLAY
CLKBR1:
	.IFZ NDISP
	BR CLKB11
	.ENDC
	.IFNZ NDISP
	DECB	DISTIM	;TIME (HO HUM) TO START THE DISPLAYS?
	BGT	CLKB11	;NO
	MOVB	#1,DISTIM
	MOV	#NDISP-1,C
	ASL	C	;TO USE AS INDEX
	CLR	B
CLKDIS:	CMP	B,C	;ALL DISPLAYS CHECKED?
	BGT	CLKB11
	MOV	DSTAT(B),A
	TST	(B)+
	TST	A
	BLT	CLKDIS	;THIS ONE INACTIVE
	MOV	A,NGCSR
	BIT	#TKRUN,NGCSR
	BNE	CLKDIS	;STILL RUNNING
	BIS #TKGO,A
	MOV A,NGCSR
	BR	CLKDIS
	.ENDC

DATEC:	JSR PC,DPROVK
	DEC DKPWFR
	BGT .+10
	MOV #-20.,DKNRTY
	MOV #CLKFRQ,N50THS
	MOV #MNUSRS,A
	CLR B
	SPUSH C
JMTUD2:	MOV JMTU(B),C
	BEQ JMTUD1
	ASR C
	ASR C
	ASR C
	INC C
	SUB C,JMTU(B)
	BGE .+6
	CLR JMTU(B)
JMTUD1:	ADD #LUBLK,B
	DEC A
	BNE JMTUD2
	SPOP C
	MOVB RMONTH,A
	MOVB DMON(A),DAYLIM
	MOV #SECLIM,A
	MOV #RSEC,B
DATEC1:	INCB (B)
	CMPB (A)+,(B)
	BGT CLKBR1
	CLRB (B)+
	BR DATEC1

CLKB11:
.IFNZ NTVS
	JSR PC,TVTICK
.ENDC
CLKBDM:	BIT	#1,TIME+2	;EVERY OTHER BREAK (=1/25 SEC)
	BNE	CLKQBK	;
	JSR U,ACSAV
	CLR E
	MOV #NLTY,B
TIBLP:	BIT #TILIPM,TTYST(E)
	BEQ TIBLPB
	TST TIBN(E)
	BEQ TIBLPB
	JSR PC,TICP
TIBLPB:	INC E
	INC E
	SOB B,TIBLP
	JSR U,ACRES

CLKQBK:	DEC	@CLKQT
CLKQB1:	TST	@CLKQT
	BNE	CLKQB2
	MOV	CLKQT,A
	MOV	2(A),CLKQT	;PUT NXT BLK AT TOP OF Q
	JSR	PC,@4(A)		;DO CURRENT REQUEST
	BR	CLKQB1
CLKQB2:	MOV	#-1,CLKINF
	SPOP	C
	SPOP B
	SPOP A
	RTT

CLKINE:	TST DEBSW
	BNE CLKIN2
	JSR	A,SPRINT
	BPRTXT	^/CLKQBK RAN CLKINE/
	PRCR
	SPREND
CLKIN1:	MOV #CLKINF,CLKQT
	MOV	#-1,CLKINF
	RTS	PC

CLKIN2:	BPT	;CLKQBK RAN OFF END OF CLK QUEUE
	BR CLKIN1
.STITL	CLOCK QUEUE ROUTINES

;CLKQAD --
;CLOCK QUEUE ADD
;WORKS ONLY AT CLK BRK LEVEL OR LOWER 
;ADD BLOCK POINTED TO BY A TO SYSTEM CLOCK QUEUE
;1ST WD # OF TICKS TO WAIT
;2ND WD EMPTY (USED BY SYSTEM)
;3RD WD ADDR TO JSR TO

CLKQAD:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST CLKQ ENTRY
	MOV	(C),D
	BR	CLKQA2

CLKQA1:	MOV	D,C	;PNT C TO NEXT BLK
	MOV	2(D),D	;PNT D TO ONE AFTER
	SUB	(C)+,(A)	;MAKE TIME IN A BLK REL TO C BLK
CLKQA2:	TST	2(D)
	BEQ	CLKQA3	;BR IF NO MORE BLKS LEFT 
	CMP	(A),(D)
	BHI	CLKQA1
CLKQA3:			;INSRT ABLK BETWEEN C BLK AND D BLK
	MOV	D,2(A)	;PNT A BLK TO D BLK
	MOV	A,(C)	;PNT C BLK TO A BLK
	SUB	(A),(D)	;MAKE D TIME REL TO A TIME

CLKQRS:	SPOP	D
	SPOP	PS
	SPOP	C
	RTS	PC

CLKQSV:	SPUSH	PS
	MOV	PCBRV+2,PS	;RUN AT CLK BK LEVEL
	SPUSH	D
	JMP	(C)

;CLKQDL--
;CLOCK QUEUE DELETE
;DELETE BLOCK POINTED TO BY A FROM CLOCK Q

CLKQDL:	JSR	C,CLKQSV	;PREVENT CLOCK INTERRUPTS
	MOV	#CLKQT,C	;POINTER TO FIRST ENTRY
	BR	CLKQD2
CLKQD1:	MOV	(C),C	;GET NEXT ENTRY
	TST	(C)+	;MAKE IT POINT TO NEXT+1 ENTRY
	TST	(C)	
	BEQ	CLKQD3	;BRANCH IF NO MORE ENTRIES
CLKQD2:	CMP	A,(C)	;IS THIS THE ENTRY WE WANT
	BNE	CLKQD1	;NO
	ADD	(A),@2(A)	;INCREASE TIME IN NEXT BLK
	MOV	2(A),(C)	;CORRECT PNTR IN PREV BLOCK
CLKQD3:	JMP	CLKQRS


UTIMEG:	MOV #RHOUR+1,D
	CLR E
	BR UTIME1
UDATEG:	MOV #RYEAR+1,D
	MOV #1,E
UTIME1:	MOV #3,F
UTIME2:	MOVB -(D),B
	ADD E,B
	JSR PC,PSHNUM
	SOB F,UTIME2
	MOV #3,D
	JMP SENT.

PEEK:	CLR -(P)
	CLR E
	PRTXTC ^\USER	%TIM	FLSRES	TIMUSD	LSTIM\
	MOV NUSERS,F
PEEK1:	MOV (P),A
	JSR PC,PRDN
	SPACE
	MOV E,A
	ADD #UNAME,A
	JSR PC,POIHD2
	PRTXT ^\	\
	CLR A
	MOV JMTU(E),B
	DIV #144.,A
	JSR PC,PRDN
	PRTXT ^\	\
	MOV FLSRES(E),A
	JSR PC,PRON
	PRTXT ^\	\

	MOV TIMUSD(E),A
	JSR PC,PRDN
	PRTXT ^\	\
	MOV #LSTIM+3,B
	ADD E,B
	MOVB @B,A
	INC A
	JSR PC,PRDN
	SPACE
	MOV #3,C
	MOV #':,D
	BR .+6
PEEK4:	JSR PC,TYO	;PRINT :
	MOVB -(B),A
	JSR PC,PRDN
	SOB C,PEEK4
	PRCR
	ADD #LUBLK,E
	INC (P)
	DEC F
	BLE .+6
	JMP PEEK1
	MOV NRFERS,A
	BEQ PEEK2
	JSR PC,PRDN
	PRTXT ^\  FIXED HEAD ERRS  \
PEEK2:	MOV NRKERS,A
	BEQ PEEK3
	JSR PC,PRDN
	PRTXT ^\  MOVING HEAD ERRS\
PEEK3:	PRCR
	TST (P)+

;PEEK THORNTON BOX TYPE DEVICES
PEEKDV:
	MOV	#LDEVAR,A
PEEKD1:	CMP	(A)+,(A)+	;POINT TO NEXT NAME POINTER
	TST	(A)	;0 MARKS END OF LDEVAR NAMES
	BNE	PEEKD2
PEEKRT:	SEZ
	RTS	PC
PEEKD2:	MOV	2(A),B	;TELETYPE NUMBER OF DEVICE
	BIT	#100001,B	;NOT REALLY THERE IF NEG OR ODD
	BNE	PEEKD1	;BR IF NOT REALLY THERE
	JSR	PC,PKDEV	;DO THIS DEVICE
	BR	PEEKD1

;DO PEEK FOR ONE DEVICE.
PKDEV:	SPUSH	A
	MOV	(A),A	;NOW A POINTS TO ACTUAL NAME
	JSR	PC,PRAS	;PRINT STRING IN A
	PRTXT	^\: \
	MOV	TTYU(B),B	;USER WHO HAS DEVICE OPEN
	BGE	PKDEV1
	PRTXT	^\UNUSED\
	BR	PKDEV8
PKDEV1:	SPUSH	B	;SAVE USER
	CLR	A
	DIV	#L,A	;A _ USER NUMBER
	JSR	PC,PRDN
	SPACE
	SPOP	A	;USER
	ADD	#UNAME,A
	JSR	PC,POIHD2	;SOMEHOW THIS IS SUPPOSED TO PRINT USER NAME
PKDEV8:	PRCR
	SPOP	A
	RTS	PC

CLOCK:	MOV TIME,A
	MOV TIME+2,B
.IFZ FPPF
CLOCK1:	JMP R1I.N
.IFF
CLOCK1:	JSR PC,GRBAD
	BIS #INUM,C
	JMP ORTC

.ENDC
USRTIM:	MOV TUTIME+2,A
	MOV TUTIME,B
	BR CLOCK1

UWAIT:	JSR PC,G1IARG
	MOV	USER,U
UWAIT0:	SDPADD	TIME,TIME+2,B,C
	JSR	PC,UWAITS
	BEQ	SETRT	;BR IF WAIT DONE
UWAIT1:	JSR PC,FLUSH
UWAIT3:	TST BRAKE(U)
	BNE UWAIT2
	JSR	PC,UWAITS
	BNE	UWAIT1
UWAIT2:	JSR PC,RUNME
	BR SETRT	;SEZ RETURN

UWAITS:
	CMP	TIME,B
	BNE	UWATS1
	CMP	TIME+2,C
UWATS1:	BGE	SETRT	;BR IF TIME IS OVER AND SEZ RETURN
	CLZ	;HAVE TO WAIT SOME MORE
	RTS	PC


SETTV:	JSR PC,G1IARG
	SPUSH C
	BLT SETTV1
	JSR PC,G1IARG
	TST C
	BLT SETTV1
	CMP #6,C
	BLE SETTV1
	CMP #2,C
	BGE .+4
	DEC (P)
	CMPB (P),SECLIM(C)
	BGT SETTV1
	MOVB (P),RSEC(C)
	TST (P)+
SETRT:	SEZ
	RTS	PC
SETTV1:	ERROR+WTA	;WRONG TYPE OF ARGUMENT


;WAITS UNTIL SPECIFIED DEVICE HAS NO CHARACTERS IN OUTPUT Q
TYOWAIT:
	JSR	PC,G1IARG	;B,C _ AM'T OF ADDITIONAL WAIT
	POPS	E	;DEVICE SPEC
	JSR	PC,DEVNUM	;E _ TTY NUMBER OR ERROR IF INVALID NAME
	CMP	E,#2*NLTY
	BLT	TWAIT1
	ERROR+TDE	;NOT VALID TTY NUMBER
;WAIT UNTIL USER'S CONSOLE HAS FINISHED OUTPUT
CTYOWAIT:
	MOV	USER,U
	MOV	UTTY(U),E
	BR	TWAIT0
;WAIT UNTIL MUSIC BOX HAS FINISHED OUTPUTTING
MUWAIT:
	MOV	#MBDN,E

TWAIT0:	JSR	PC,G1IARG	;B,C _ AM'T OF ADDITIONAL WAIT
TWAIT1:	MOV	USER,U
	JSR	PC,TWAITS
	BEQ	UWAIT0	;BR IF DEVICE DONE
;OTHERWISE, HAVE TO WAIT
TWAIT2:	JSR	PC,FLUSH	;BYE BYE
	TST	BRAKE(U)
	BNE	UWAIT2	;BREAKING, SO GO RUN HIM
	JSR	PC,TWAITS	;IS TTY DONE?
	BNE	TWAIT2	;BR IF DEVICE NOT DONE
;DEVICE DON. NOW WAIT ARG 60THS OF SECONDS
	SDPADD	TIME,TIME+2,B,C
	BR	UWAIT3

;CALL WITH E = TTY NUMBER
;SEZ RETURN IF TTY DONE
TWAITS:
	TST	TOQN(E)
	BNE	TWATS8	;BR IF OUTPUT Q NOT EMPTY
	TSTB	MXNUM(E)	;NOTHING IN BUFFER, BUT ANY IN HARDWARE BUFFER?
	BGE	SETRT	;BR IF DONE
	BIT	#TOTRAN,TTYST(E)	;IS TTY TRANSMITTING
	BNE	SETRT	;BR IF DONE
TWATS8:	CLZ	;NOT DONE
	RTS	PC
	.STITL	SWAP START+STOP ROUTINES

SWPOST:	CLR (A)
	ADD #16,SWPLST
.IFNZ AI
	TST XORF
	BNE SWPST1
	MOV 12(A),B
	CLR XORUSR(B)
	RTS PC
SWPST1:	JSR F,ACSAV	;SAVE THE AC'S
	MOV 2(A),D	;THE WORD COUNT
	MOV 4(A),F	;THE CORE ADDRESS
	MOV 14(A),E	;THE CONTROL REGISTER
	JSR PC,XORREG	;XOR THE TRANSFER
 	MOV (P),B	;THE OLD POINTER TO THE REQUEST BLOCK
	MOV 12(B),B	;THE USER INDEX
	MOV A,XORUSR(B)	;PUT THE CHECKSUM IN HIS VARIABLES
	JSR F,ACRES	;RESTORE THE REGS
.ENDC
	RTS PC

SWPIST:	MOV #SWPISP,(A)	;SWAP IN START, SET UP STOP
	RTS PC

SWPISP:	MOV 12(A),B
	MOV #1,SLOTST(B)
	SUB #2,SWPLEP
	SPUSH A
	MOV #SWPLST+2,A
	MOV #SWPLST,B
	MOV (A)+,(B)+
	BNE .-2
	INC NINU	;ONE MORE GUY IN
	DEC NSWPU	;ONE LESS GUY MOVING
	SPOP A
.IFNZ AI
	MOV 12(A),B
	MOV SLOTU(B),B
	TST XORF
	BEQ SWPIS2
	TST XORUSR(B)
	BNE .+4
SWPIS2:	RTS PC
	JSR F,ACSAV
	MOV 2(A),D	;THE WORD COUNT
	MOV 4(A),F	;THE CORE ADDRESS
	MOV 14(A),E	;THE CONTROL REGISTER
	JSR PC,XORREG	;XOR THE TRANSFER
 	MOV (P),B	;THE OLD POINTER TO THE REQUEST BLOCK
	BIT #100000,10(B)
	BNE SWPIS1
	MOV 12(B),B	;THE SLOT NUMBER
	MOV SLOTU(B),B	;THE UUSER INDEX
	CMP A,XORUSR(B)	;COMPARE THE CHECKSUMS
	BEQ .+4
	BPT		;THEY WERE DIFFERENT
SWPIS1:	JSR F,ACRES
.IFTF
	RTS PC

.IFT
XORREG:	NEG D		;MAKE THE WORD COUNT POSITIVE
	CLR A		;CHECKSUM COMPUTED IN A
	SPUSH TEMPAR	;GET A PAGE
	SPUSH TEMPDR
	MOV #77406,TEMPDR	;MAKE IT 4096. WORDS LONG
	ASH #-4,E	;GET THE EXTENDED MEMORY BITS
	ASHC #-6,E	;TURN THE CORE ADDRESS INTO 32. WORD BLOCKS
	BIC #170000,F	;CLEAR THE EXTRA BITS
	MOV F,TEMPAR	;SET UP THE BOTTOM OF THE PAGE
XOR1:	MOV #4096.,F	;THERE ARE 4096 WORDS IN A PAGE
	CMP D,F		;ARE THERE AT LEAST THAT MANY IN THE TRANSFER
	BHIS .+4	;YES
	MOV D,F		;CORRECT THE NUMBER OF WORDS
	MOV #TEMPPG,B	;THE START OF THE PAGE IN THE VIRTUAL CORE
XOR2:	MOV (B)+,C	;THE ACTUAL WORDS OF THE TRANSFER
	XOR C,A		;CREATE THE CHECKSUM
	SOB F,XOR2	;DO ALL THE WORDS
	ADD #128.,TEMPAR	;GET THE NEXT 4K. WORDS
	SUB #4096.,D	;CORRECT THE WORD COUNT
	BGT XOR1	;MORE WORDS LEFT
	SPOP TEMPDR
	SPOP TEMPAR
	RTS PC
.ENDC
	.STITL MISC ROUTINES

CACSAV:	JSR PC,PPUSHT	;CAREFUL AC SAVE
ACSAV:	MOV E,-(P)
	MOV D,-(P)
	MOV C,-(P)
	MOV B,-(P)
	MOV A,-(P)
	JMP (F)

CACRES:	JSR PC,PPOPT	;CAREFUL AC RESTORE
ACRES:	TST (P)+
	MOV (P)+,A
	MOV (P)+,B
	MOV (P)+,C
	MOV (P)+,D
	MOV (P)+,E
	RTS F

UACSAV:	MOV A,UACA(U)
	MOV B,UACB(U)
	MOV C,UACC(U)
	MOV D,UACD(U)
	MOV E,UACE(U)
	RTS PC

UACRES:	MOV UACA(U),A
	MOV UACB(U),B
	MOV UACC(U),C
	MOV UACD(U),D
	MOV UACE(U),E
	RTS PC



PPUSHT:	CMP P,#PPUSHL
	BLOS .+4
	RTS PC
	BIT #177000,P	;IS IT THE SYSYTEM PDL?
	BNE .+4
	RTS PC	;YES, IGNORE
	JMP PPSWPO	;PDL REALLY OVERFLOWED

PPOPT:	CMP P,PPOPL
	BHIS .+4
	RTS PC
	JMP PPSWPI

SPUSHT:	SUB #2,S
	CMP S,#SPUSHL
	BLOS .+4
	RTS PC
	JMP SPSWPO

SPOPT:	ADD #2,S
SPOPT1:	CMP S,SPOPL
	BHI .+4
	RTS PC
	JMP SPSWPI

.SPACE:	PRTXT ^\ \
	RTS PC

.CRLF:	.PRTXT <.BYTE 15,0>
	RTS	PC
	.STITL P AND S PDL SWAP OUTERS

PPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	SPUSH B	;SAVE ADDRESS
	SPUSH #PSWPWR
	JSR PC,DSKSEC	;WRITE OUT P-PDL BLOCK
			;FROM (PSWPAD)
			;OUT TO (DBGRBD)
			;DWRTEC
	SPOP IP
	BIT #PPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,PPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #PPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IP,A
	MOV PSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,P
	BHIS .-4
	ADD #PDSWOP,P	;PDL HAS MOVED!
	ADD #PDSWOP,PRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC


SPSWPO:	JSR F,ACSAV	;TIME TO WORK!
	JSR PC,UBLKGR	;GET ALL THE GOOD STUFF WE NEED
	SPUSH B	;SAVE ADDRESS
	SPUSH #SSWPWR
	JSR PC,DSKSEC	;WRITE OUT S-PDL BLOCK
			;FROM (SSWPAD)
			;OUT TO (DBGRBD)
			;DWRTEC
	SPOP IS
	BIT #SPNAIF,FLAGS2	;WAS THE PDL NOT ALL THE WAY IN ANYWAY?
	BNE .+10	;PART ALREADY OUT
	SUB #PDSLOP/2,SPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #SPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV #IS,A
	MOV SSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,S
	BHIS .-6
	ADD #PDSWOP,S	;PDL HAS MOVED!
	ADD #PDSWOP,SPRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC

	.STITL P AND S PDL SWAPER INERS
PPSWPI:	BIT #PPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV PSWPAD,A
	MOV A,B
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,P
	BHI .-4
	SUB #PDSWOP,P
	SUB #PDSWOP,PRBAO
	MOV IP,C
	MOV C,DBGRBD
	SPUSH #PSWPRD
	JSR PC,DSKSEC	;READ IN P-PDL BLOCK
			;INTO (PSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #IP,D
	TST (D)
	BNE PSWPI2
	BIC #PPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW,
				; THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,PPOPL
PSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC

SPSWPI:	BIT #SPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE .+4	;NO (PRAISE THE LORD!)
	.BUG.
	JSR F,ACSAV
	MOV SSWPAD,A
	MOV A,B
	MOV (A),(B)
	ADD #PDSWOP,A
	MOV -(A),-(B)
	CMP A,S
	BHI .-6
	SUB #PDSWOP,S
	SUB #PDSWOP,SPRBAO
	MOV IS,C
	MOV C,DBGRBD
	SPUSH #SSWPRD
	JSR PC,DSKSEC	;READ IN S-PDL BLOCK
			;INTO (SSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #IS,D
	TST (D)
	BNE SSWPI2
	BIC #SPNAIF,FLAGS2	;IF BOTH LINKS ARE ZERO NOW,
				; THERE IS NO MORE PDL ON DISK
	ADD #PDSLOP/2,SPOPL
SSWPI2:	JSR PC,UBLKFR
	JSR F,ACRES
	RTS PC


	.STITL P AND S PDL POPPERS
PPTA:		;POP PP PDL TO (A) RELATIVE
		;USES A,F
	SPOP F
PPTA1:	CMP A,PRBAO
	BHIS PPTA3
	MOV PPOPL,P
	JSR PC,PPSWPI
	BR PPTA1
PPTA3:	SUB PRBAO,A
	SUB #IP,A
	NEG A
	CMP A,P
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,P
	JSR PC,PPOPT
	JMP @F
PSTA:		;POP S PDL TO (A) RELATIVE
		;USES A
	CMP A,SPRBAO
	BHIS PSTA3
	MOV SPOPL,S
	JSR PC,SPSWPI
	BR PSTA
PSTA3:	SUB SPRBAO,A
	SUB #IS,A
	NEG A
	CMP A,S
	BHIS .+4
	.BUG.	;OVER POPPING
	MOV A,S
	JMP SPOPT1
.STITL INITIALIZE NODE SPACE
;ON ENTRY B = START OF FREE NODES NODE #
;	C = " " " " NODE ADDRESS
;	D = FIRST WORD AFTER END OF SLOT
INIT:	MOV #PSTP15,ERFRET
	MOV #RET,DOFRET
	MOV USER,B
	MOV UASIZE(B),C	;SAVE USERS ASIZE
	MOV ASIZE,UASIZE(B)
	MOV ENDWLD,D
	MOV D,B
	SUB C,D	;COMPUTE TOP OF NODESP
	SUB #10,D
	MOV D,NODTOP
	MOV D,A
	ADD #4,A
	SUB A,B
	CMP #20,B
	BGE INIT3
	MOV A,AFREE
	MOV A,AROVER
	CLR (A)+
	MOV B,(A)+
	CLR (A)
	MOV B,ASPACE
INIT3:	JSR PC,.GCOLL
	MOV NDBLKS,A
	MOV A,B
	ASH #-4,B
	MOV #DBITTB,C	;SET UP TO INIT DISK BIT TABLE
DALOC5:	DEC B	;20 BLOCKS (=1 WORD IN TABLE)AT A TIME
	BLT DALOC4	;ALL DONE 
	CLR (C)+
	BR DALOC5
DALOC4:	CLR (C)	;ONLY SOME BITS ON IN THIS WORD
	COM (C)
	MOV #1,D
	BIC #177760,A	;# OF WORDS MOD 20
DALOC6:	DEC A
	BLT DALOC7
	BIC D,(C)
	ASL D
	BR DALOC6
DALOC7:	TST (C)+
	CMP C,#DBITBE
	BGT DALOC8
	MOV #-1,(C)
	BR DALOC7
DALOC8:	BIS #100000,DBITBE	;IMPOSSIBLE TO GO OFF TOP
	RTS PC

INIT1:	BIS #PADERF,FLAGS2	;SO OCTAL ERROR ADDR IS PRINTED
STARTF:	MOV	NUSERS,NUSER2
	ASL	NUSER2
	JSR PC,SEGSET
	JMP	TINIT

SEGSET:	CLR SSR0
	MOV #KIDR,A
	MOV #20,B
	MOV #77406,(A)+
	SOB B,.-4
	MOV #10,C
SEGST1:	MOV B,20(A)
	MOV B,(A)+
	ADD #200,B
	SOB C,SEGST1
	MOV #SLOTDR,A
	MOV #PUREDR,B
	MOV (A)+,(B)+
	MOV (A)+,(B)+
	MOV (A),(B)
	MOV #7600,KDAR+16
	MOV #4,SSR3
	MOV #1,SSR0


.IFNZ FPPF
	LDFPS #40300
.ENDC

	RTS PC
	.STITL READ-EVAL LOOP DRIVER (THE ONE-USER MAIN LOOP)

UGO:	JSR PC,RUNME
	MOV #TYO,PCHR
	MOV #TYI,GCHR
	MOV USER,A
	BNE UGO2
	JSR PC,IDISKS
.IIF NZ GUY,CLR WCHDSK
.IIF Z GUY,MOV #4,WCHDSK
	MOV USER,A
UGO2:	CLR GUNSW(A)		;NOT BEING GUNNED NOW!
	ADD #UNAME,A
	MOV #'?+200,(A)
	TST DEBSW
	BNE UGO1
LANGC <	CPRTXT ^/WELCOME TO LOGO />,<
	CPRTXT ^/BIENVENUE A LOGO />
	BR UGO3
UGO1:	PRTXT ^/LOGO BEING DEBUGGED!/
UGO3:	PRTXT ^/VERSION # /
	MOV LVERNF,A
	JSR PC,PRDN
	LANGC <PRTXT ^/, YOU ARE USER # />,<
	PRTXT ^/, VOUS ETES L'UTILISATEUR # />
	CLR A
	MOV USER,B
	DIV #LUBLK,A
	JSR PC,PRDN
	PRCR		;PRINT CR
	JSR PC,INIT
	MOV #DESSAV,E
	JSR PC,DIRSER
	BEQ MLOOP
	TST DEBSW
	BNE MLOOP
	JSR PC,.REDF4
	JSR PC,.POF1
MLOOP:	JSR	PC,UCHECK	;CHECK SOME USER VARIABLES
	JSR PC,SCHEDP
	BIC #HERRF,FLAGS2
	MOV	USER,U
	TST BRAKE(U)
	BEQ .+4
	ERROR+BRK
	JSR PC,GETSTR
	JSR PC,MREAD
	BEQ MLOOP	;NO TOKEN LIST
.IFNZ AI
	TST USER
	BNE MLOP1
	CMPB #105,177570
	BEQ MLOP1
	PRTXT <THIS IS NOT A LOGO CONSOLE
>	
MLOP1:
.ENDC
	JSR PC,EVLINE
	BEQ MWDW
	POPS A
	BR MLOOP
MWDW:	ERROR+WDW	;WHAT SHOULD I DOO WITH (S)

RUNRUG:	JSR PC,CKSST
	BPT
	SEZ
	RTS PC

SYSJOB:	JSR PC,FLUSH
	BR SYSJOB


;CHECK SOME USER VARIALBES -- DEBUGGING FEATURE
UCHECK:	TST	NODESP
	BNE	UCHEC1
	TST	NODESP+2
	BEQ	UCHEC2
UCHEC1:	TST	(P)+	;POP STACK SO IT LOOKS LIKE BUG CAME FROM CALLING ROUTINE
	.BUG.	;1ST 2 WORDS OF NODE SPACE NOT ZERO
UCHEC2:	RTS	PC
	.STITL GET A STRING
GSTR4:	PUSHS C
	PUSH GCHR
	SPUSH PCHR
	SPUSH PRMTCH
	CLR PRMTCH
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	JSR PC,.LOADC
	PUSHS B
	JSR PC,PRLN
	POPS B
	JSR PC,RDSTR
	BEQ GSTR5
GSTR7:	POPS A		;IGNORE ANY LINE TYPED IN
GSTR10:	POP PRMTCH
	SPOP PCHR
	SPOP GCHR
	POPS C
	JSR PC,.LOADC
	JSR PC,.LOADB	;PUT THINGS BACK AS THEY WERE
	BR GSTR3

GSTR5:	BIT #RBRKF,TFLAGS
	BEQ GSTR10
	POP PRMTCH
	ERROR+BRK
GETSTR:	TST FUNLEV	;ARE WE IN A PROC
	BEQ GSTR0	;NO
	BIT #BRKF,FLAGS	;ERROR, MAYBE
	BNE GSTR0	;YES
	MOV CLP,B	;NO, GET THIS NODE OF LLP
	BEQ GSTR9
	JSR PC,.LOAD
	BIT #7777,A	;IS IT LAST NODE
	BNE GSTR8
	SPOP A		;POP RETURN ADDR
	JMP PSTOP

GSTR9:	MOV CPLN,B
	JSR PC,GTLINE
	BNE .+4
	ERROR+LDE	;LINE ..(B).. DOESN'T EXIST
	MOV C,A
GSTR8:	CLR CLP
	MOV A,C
	JSR PC,.LOADC
	JSR PC,.LOAD	;OK, GET FIRST NODE OF LINE, = LINE #
	MOV B,CPLN
	BIT #TPSF,FLAGS
	BNE GSTR4
GSTR3:	MOV C,CLP
	MOV A,CTP	;IN CASE THERE IS NO GENERATION #
	MOV A,C
	JSR PC,.LOADC	;GET SECOND NODE
	CLR CLGN	; IF TYPE = SNUM, IT IS GEN #
	MOV A,C
	BIC #7777,C
	CMP #SNUM,C
	BNE GSTR6
	MOV B,CLGN	;IT IS
	MOV A,CTP
GSTR6:	BIS #LIST,CTP
	PUSHS CTP
	BIT #TRACEF,FLAGS2
	BEQ GSTRT
	CPRTXT ^\ #\
	MOV CPP,B
	JSR PC,PPNAME	;PRINT PNAME
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRCR
	JSR PC,PRLN
	PRCR
GSTRT:	RTS PC


GSTR0:
GSTR1:	JSR PC,RDSTR
	BNE GSTRT
GSTR2:	BIT #RBRKF,TFLAGS
	BEQ GSTR1
	ERROR+BRK
	.STITL MORE READ ROUTINES!!!
MREAD:	TST FUNLEV	;ARE WE IN PROC?
	BEQ MRD1	;NO
	BIT #BRKF,FLAGS	;YES, BUT ERROR?
	BEQ MRD3
MRD1:	CLR ILINEL
	JSR PC,READ	;CONVERT CHAR STRING TO TOKEN LIST
	BEQ MRD4	;NO TOKENS
	MOV @S,ILINEL
MRD3:	CLZ
MRD4:	RTS PC

CKSTG:	;CKECK IF DISC OR NODES ARE ALMOST GONE
	BIT #DSAMFL,FLAGS2
	BNE CKSTG1
	CMP NNIFSL,#NBN
	BHIS MRD4
	JSR PC,.GCOLL
	CMP NNIFSL,#NBN
	BHIS MRD4
CKSTG1:	CLR ERPROC
	ERROR+NSL
	.STITL EVAL 1 LINE

EVLINE:	MOV	USER,U	;EVALUATES 1 LINE ON S
	TST	BRAKE(U)
	BEQ .+4
	ERROR+BRK
	TST TOPRNM
	BNE EVLI4
EVLI6:	BIC #EVIFS,FLAGS
	CLR CO
	CLR CO+2
	CLR NOR
	CLR COF
	CLR LO
	CLR LO+2
	JSR PC,IGNT
EVLI1:	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,EVAL
	BEQ EVLI3	;NO OUTPUT, OK
	JSR PC,CKSTG
	SEZ
	RTS PC
EVLI3:	JSR PC,CKSTG
	BIT #CRF,FLAGS
	BNE EVLI2
	JSR PC,GNT
	BIS #RTF,FLAGS
	BR EVLI1
EVLI4:	JSR PC,CKSTG
	MOV @S,B
	JSR PC,.LOAD
	MOV A,D
	BIC #7777,A
	CMP #SNUM,A
	BEQ EVLI5	;AN SNUM
	CMP #INUM,A
	BEQ EVLI8	;AN INUM
	CMP #LSTR,A
	BNE EVLI6	;NOT AN SNUM, INUM OR LSTR
	JSR PC,.CLSIN	;CONVERT LSTR TO INUM
	BEQ EVLI6	;NOT NO. OR TOO BIG
EVLI8:	BIT #SPDF,FLAGS	;IS THIS PROC DEF. BEING SKIPPED?
	BNE EVLI2
	JSR PC,.CINSN	;CONVERT INUM TO SNUM
	BEQ EVLI7	;TOO BIG
	TST B	;IS NO. TOO SMALL?
	BGT .+4
	ERROR+LNTS
	MOV D,A
	BIC #170000,A	;MAKE IT INTO AN SNUM
	BIS #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	MOV C,@S
EVLI5:	JSR PC,ADLN
EVLI2:	CLZ
	RTS PC
EVLI7:	ERROR+LNTB	;LINE # TOO BIG
	.STITL GET NEXT TOKEN

GNT:	MOV CT,A
	MOV CT+2,B
	BIT #RTF,FLAGS	;IS REPEAT TOKEN FLAG SET?
	BEQ GNT1
	BIC #RTF,FLAGS	;YES
	CMP #SFUN,A
	BNE GNT6
	TST B
	BNE GNT6
	BIS #CRF,FLAGS
GNT6:	RTS PC
GNT1:	BIC #PTLPF,FLAGS
	CMP #$LLPAR,B	;IS CT "("
	BEQ GNT3
	CMP #$LPAR,B
	BNE GNT3A
GNT3:	BIS #PTLPF,FLAGS	;YES, SET PTLPF
GNT3A:	MOV A,CTP	;GET LINK TO NEXT TOKEN
	BIT #7777,A
	BEQ GNT2	;ANY TOKENS LEFT
	JSR PC,.LOADA	;YES
	INC CTN
GNT3B:	CMP #$COMT,B
	BEQ SKPCOM
GNT4:	MOV A,CT
	MOV B,CT+2
	RTS PC
GNT2:	BIT #CRF,FLAGS
	BNE GNT5
	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR GNT4
GNT5:	ERROR+OOT	;OUT OF TOKENS
SKPCOM:	MOV A,CTP	;SKIP OVER A COMMENT
	BIT #7777,A
	BEQ GNT2	;END ON CR FOUND
	JSR PC,.LOADA
	INC CTN
	CMP #$COMT,B
	BNE SKPCOM	;DON'T STOP TILL CR OR CLOSING "!"
	BR GNT3A	;RETURN TOKEN AFTER CLOSING "!"

IGNT:	MOV @S,B	;INIT "GNT"
	BIT #7777,B
	BEQ IGNT1
	BIC #CRF,FLAGS
	MOV B,CTP
	JSR PC,.LOAD
IGNT2:	MOV A,CT
	MOV B,CT+2
	BIS #RTF,FLAGS
	MOV #1,CTN
	BR GNT3B
IGNT1:	BIS #CRF,FLAGS
	MOV #SFUN,A
	CLR B
	BR IGNT2
	.STITL LOGO TYI/O
UTYI:	WAIT
	TST CHI
	BEQ UTYI
	MOVB CHI,D
	CLR	CHI
	BIC #177600,D
TYO:	JMP @ITYO

TYI:	JMP @ITYI
STYI:	WAIT
	TSTB TKS
	BPL STYI
	MOVB TKB,D
	BIC #177600,D
STYO:
UTYO:	TSTB TPS
	BPL .-4
	MOVB D,TPB
	CMP #15,D
	BNE UTYOR
	MOV #12,D
	JSR PC,STYO
	MOV #15,D
UTYOR:	RTS PC

;SPRINT-- START SYSTEM PRINT.  CALL WITH JSR A,
SPRINT:	SPUSH	USER
	SPUSH PCHR
	MOV	#-1,USER
	MOV #STYO,PCHR
	JMP	(A)
SPEND:	TST (P)+
	SPOP PCHR
	SPOP USER
	RTS A

;PRINT LOCATIONS ON SYSTEM CONSOLE
;CALL WITH
;	MOV #WDLIST,B
;	JSR PC,PLOCS
;WHERE	WDLIST:	LOCS TO BE PRINTED
;		0
PLOCS:	JSR	A,SPRINT	;START SYS PRINT
	BPRTXT	;RING BELL, C.R.
PLOCS1:	JSR	PC,PLOC
	TST	(B)+
	TST	(B)
	BNE	PLOCS1
	SPREND	;END SYSTEM PRINT
	RTS	PC

;PRINT (B)/ @(B)
PLOC:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	(B),U
PLOC1:	MOV	(U),D
	JSR	PC,PGEN1	;PRINT (U)/ (D)
	SPOP	U
	SPOP	D
	SPOP	A
	RTS	PC

;PRINT B/(B)
PLOCB:	SPUSH	A
	SPUSH	D
	SPUSH	U
	MOV	B,U
	BR	PLOC1
	.STITL	GARBAGE COLLECTOR
NNODES==4096.
GCBTL== NNODES/8./2.*2.	;GARBAGE COLLECT BIT TABLE LENGTH

MARKNI:	SPUSH A
	SPUSH B
	BR MARKN4
MARKN:	SPUSH A	;MARK NODE(B)
	SPUSH B
;DEBUGGING FEATURE
	JSR PC,.LOAD	;ARE WE MARKING AN IDLE NODE
	BIC #7777,A
	CMP #IDLE,A
	BNE .+4
	.BUG.
	MOV (P),B
;
MARKN4:	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;ALREADY MARKED?
	BEQ MARKN1	;NO
MARKN3:	SPOP B
	SPOP A
	SEZ
	RTS PC
MARKN1:	BISB B,(A)
MARKN2:	SPOP B
	SPOP A
	CLZ
	RTS PC
MARKDN:	;SKIP IF NODE (B) IS MARKED
	SPUSH A
	SPUSH B
	MOV B,A
	BIC #170000,A
	BIC #177770,B
	MOVB BMT(B),B
	ASH #-3,A
	ADD #GCBITS,A
	BITB B,(A)	;MARKED?
	BEQ MARKN3	;NO
	BR MARKN2	;YES-SKIP

MARKL:	PUSH A	;MARK LIST
	SPUSH B	;NODE ADDS IN B
	SPUSH C
	JSR	PC,MKLIST
	BR MARKV1

MARKV:	PUSH	A	;MARK VARIABLE
	SPUSH	B	;NODE ADDS IN B
	SPUSH	C
	CLR	A
	MOV	B,C
	JSR	PC,MARKF1	;TREAT POINTER AS A FIRST PTR
MARKV1:	SPOP C
	SPOP B
	POP A
MARKV2:	RTS PC

MARKF:	MOV A,C	;MARK FIRST OF A DATUM (NODE) IN A,,B
MARKF1:	BIT #DSAMFL,FLAGS2
	BEQ MARKF2	;DISK NOT ALMOST FULL
	TST FILFLG
	BEQ MARKF3
	MOV #DREADC,E
	JSR PC,GBITGS	;SET DISK BUFFER BACK UP
MARKF3:	TST SSAVEA	;TOP OF SPDL SWAPPED OUT FOR MARKING?
	BEQ MARKF4	;NO
	SPUSH #SSAVRD
	JSR PC,DSKSEC	;YES, SWAP IT BACK IN
			;INTO (SSWPAD)
			;FROM (SSAVEA) WHERE GCOLL PUTS IT
			;DREADC
	MOV SSAVEA,C	;FREE THE REQUEST BLOCK
	CLR SSAVEA	;CLEAR THIS: IT WORKS AS A FLAG
	JSR PC,UBLKFR	;(NOW FREE IT)
MARKF4:	CLR ERPROC
	.IFNZ NDISP
	ADD #2,S	;POP SNLIST OFF S PDL
	.ENDC
	ERROR+NSL
MARKF2:	BIC	#7777,C	;A TELLS WHAT TYPE OF DATUM IT IS
	SWAB	C
	ASR	C
	ASR	C
	ASR	C	;ALL THIS GIVES YOU THE TYPE*2
	JMP	@LMT(C)	;WHICH YOU MIGHT MARK ON

	.IFNZ NDISP
MKSNAP:	JSR	PC,MKDC	;MARK DISPLAY CODE
	.ENDC
MKLIST:	BIT	#7777,B	;IS THIS NODE REALLY HERE?
	BEQ	MARKV2	;NO. RETURN
MKL1:	PUSH	A	;SAVE BUTFIRST OF CURRENT (I.E. PARENT) NODE
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MKL2
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	JSR	PC,MARKBF	;MARK BUTFIRST OF  NEWTHIS NODE
MKL2:	POP A
	RTS PC

MKATOM:		;MARK ATOM CELL BUT NOTHING INSIDE IT
MKINUM:	JMP MARKNI

GCDIE:	ERROR+FBUG

MARKBF:	BIT	#7777,A	;MARK BUTFIRST OF LIST
	BEQ	MARKV2	;AT END OF LIST
MKBF1:	MOV	A,B
	JSR	PC, MARKN	;MARK NEXT NODE
	BEQ MARKV2	;ALREADY MARKED, QUIT
	JSR	PC,.LOAD	;GET NEXT NODE
	JSR	PC,MARKF	;MARK FIRST OF  NEW NODE
	BR	MARKBF	;MARK BUTFIRST OF  NEW NODE

GCOLL:.GCOLL:	JSR F,ACSAV
	PUSH GNCN
	SPUSH GNCN+2
	SPUSH TMPBLK
	MOV USER,U
	TST GUNSW(U)
	BEQ NOGUN
	SPOP TMPBLK
	SPOP GNCN+2
	SPOP GNCN
	JSR F,ACRES
	RTS PC
NOGUN:	JSR	PC,UCHECK	;CHECK MISC USER VARIABLES
;	TST FILFLG
;	BEQ .GCOL2
;	MOV #DWRTEC,E
;	JSR PC,GBITGS	;SAVE THE BUFFERS
.GCOL2:	MOV #GCBITS,A	;GARBAGE COLLECT
	MOV #GCBTL/2-1,B	;CLEAR BIT TABLE
	MOV #1,(A)+	;ALWAYS PROTECT NODE ZERO
.GCOL1:	CLR (A)+
	DEC B
	BGT .GCOL1
	CLR SSAVEA	;MAKE SURE THIS IS CLEAR
;NOW MARK EVERYTHING POINTED BY OBLIST.  DONT MARK OBLIST NODES YET
	JSR PC,GNOLEI
MKUOBJ:	JSR PC,GNOLE	;GET NEXT UOE PTR
	BEQ MKTPS
	MOV B,C
	JSR PC,.LOADC	;GET THE NODE
	MOV A,C
MKUOE:	BIT #7777,C	;ONE OTHER NODE?
	BEQ MKUOBJ	;NO
	MOV C,B	;YES
	JSR PC,MARKN	;MARK IT
	JSR PC,.LOADC
	MOV A,C
	BIC #7777,A
	CMP #FBIND,A
	BEQ MKFB	;FUNCTION BINDING
	CMP #VBIND,A
	BEQ MKVB	;VARIABLE BINDING
	CMP #ABIND,A
	BEQ MKARR
	CMP #SVBIND,A
	BEQ MKSVB	;SWAPPED VB
	.BUG.		;BUG
MKVB:	JSR PC,MARKV	;MARK VARIABLE
	BR MKUOE
MKFB:	JSR PC,MARKL
	BR MKUOE
MKSVB:	BR MKUOE
MKARR:	TSTB 5(B)	;IS IT A POINTER ARRAY?
	BNE MKUOE
	MOV B,F		;POINT TO BEG OF ARRAY
	MOV 2(B),-(P)	;PUSH COUNT
	SUB #HEADER,(P)
	ASR (P)
	ADD #HEADER,F
MKAR1:	MOV (F)+,B
	JSR PC,MARKV
	DEC (P)
	BNE MKAR1
	TST (P)+
	BR MKUOE

	;MARK FROM GCMKL LIST
MKTPS:	MOV #GCMKL,F
MKRNDM:	MOV (F)+,B	;POINTER TO POINTER
	BEQ MKSPDL	;LAST ONE
	MOV (B),B	;REAL NODE ADDRESS
	BEQ MKRNDM	;NOTHING THERE
	BIT #170000,B	;IS TYPE FIELD BLANK
	BEQ MKRND1	;YES, MAKE IT LIKE LIST
	JSR PC,MARKV	;MARK VARIABLE
	BR MKRNDM
MKRND1:	JSR PC,MKL1
	BR MKRNDM
	;MARK FROM S PDL
MKSPDL:	MOV #IS,E
MKSP1:	MOV -(E),B	;GET A S PDL WORD
	CMP E,S	;END OF S PDL?
	BLO MKSP2	;YES
	JSR PC,MARKV	;MARK S PDL WORD
	BR MKSP1
MKSP2:	TST IS
	BEQ MKSP4
MKSP3:	JSR PC,UBLKGR
	MOV B,SSAVEA
	SPUSH #SSAVWR
	JSR PC,DSKSEC	;SAVE TOP OF S-PDL ON DISK
			;FROM (SSWPAD)
			;OUT TO (SSAVEA)
			;DWRTEC
MKSP8:	TST IS
	BEQ MKSP6	;NO
MKSP5:	MOV IS,DBGRBD
	SPUSH #SSWPRD
	JSR PC,DSKSEC	;GET NEXT PIECE OF S-PDL
			;INTO(SSWPAD)
			;FROM (DBGRBD)
			;DREADC
	MOV #176,F
	MOV #IS,E
MKSP7:	MOV -(E),B	;MARK THIS PIECE OF S PDL
	JSR PC,MARKV
	DEC F
	BGT MKSP7
	BR MKSP8

MKSP6:	SPUSH #SSAVRD
	JSR PC,DSKSEC	;RESTORE TOP OF S-PDL
			;INTO (SSWPAD)
			;FROM (SSAVEA)
			;DREADC
	MOV SSAVEA,C
	CLR SSAVEA	;SWAPPED BACK IN
	JSR PC,UBLKFR
MKSP4:
;OK, NOW MARK ALL UOE'S THAT POINT TO FUNCION OR VARIABLE BINDING
	JSR PC,GNOLEI
MKOBL:	JSR PC,GNOLE	;GET NEXT UOE PTR IN B
	BEQ MKOBL6	;NONE LEFT
	MOV B,C
	JSR PC,.LOADC	;GET THE PNAME NODE
	MOV B,D
	BIT #7777,A	;DOES IT POINT TO ANYTHING?
	BNE MKOBL2	;YES, MARK IT
	MOV C,B	;NO WAS IT MARKED?
	JSR PC,MARKDN
	BEQ MKOBL3	;NO - LINK IT OUT
	BR MKOBL7	;YES - ALSO MARK PNAME & BUCKET PTR
MKOBL2:	; - MARK THE UOE ETC.
	MOV C,B	;  -THE UOE NODE
	JSR PC,MARKN
MKOBL7:	MOV D,B	;  -THE PNAME LSTR
	JSR PC,MARKL
	MOV GNCN+2,B	;  -THE BUCKET LIST NODE
	JSR PC,MARKN
	BR MKOBL
	;THIS UOE IS NOT MARKED AND POINTS TO NOTHING - LINK IT OUT
MKOBL3:	MOV TMPBLK,C	;GET PTR TO PREDECESSOR NODE
	BNE MKOBL4	;NONE, SO UHCT WAS PRED.
	MOV GNCN,-2(E)	;SO CHANGE IT
	BR MKOBL5
MKOBL4:	MOV GNCN,A	;CHANGE PTR IN PRED NODE
	JSR PC,.STP1
MKOBL5:	MOV C,GNCN+2	;SO GNOLE WILL WORK
	BR MKOBL
MKOBL6:



	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;IF GUY HAS DISPLAY
	BEQ	GCDIS2
	JSR PC,DSGCF		;GCOLL IT, TOO
GCDIS2:
GCDIS:
	.ENDC


		;OK NOW RETURN ALL IN MARKED NODES
		;RA ADDS OF LIT MAP
		;RB NODE ADDS
		;RC ACTUAL ADDER OF NODE
		;RD BIT MAP
		;RE POINT TO LIST OF FREE STORAGE RECYCLED NODES
		;RF NUMBER NODES LEFT TO CHECK
		;START COLLECTING AT LUNN(LOWEST UNPROTECTED NODE #)
	CLR E
	CLR NNGC
	MOV #NODESP,C	;NODE ZERO ADDRESS
	MOV NODTOP,F
	SUB C,F		;COMPUTE LEGNTH OF NODESP
	ASR F
	ASR F		;COMPUTE NUMBER OF NODES
	CLR B		;NODE ZERO
	MOV #GCBITS,A	;BIT TABLE ADDR
GCRT2A:	MOV (A)+,D	;GET NEXT WORD OF BIT MAP
	SEC
	ROR D

GCRT2:	BCS GCRT3
	CMP B,#LUNN
	BLOS GCRT3
	TST E		;WE HAVE A FREE NODE; IS FIRST FREE FOUND?
	BNE GCRT2B
	MOV B,FREE	;NO, THIS IS IT
	BR GCRT2C	;(NO LAST-FREE TO UPDATE)

GCRT2B:	BIS B,(E)	;ELSE: POINT LAST-FREE TO THIS NODE
GCRT2C:	MOV C,E		;THIS NODE IS NEW LAST-FREE
	MOV #IDLE,(C)+	;MAKE NEW IDLE NODE, POINTS NOWHERE
	CLR (C)+
	INC NNGC
	BR GCRT4
GCRT3:	CMP (C)+,(C)+
GCRT4:	INC B
	DEC F
	BLE GCRT5
	CLC
	ROR D
	BNE GCRT2
	BR GCRT2A
GCRT5:	MOV NNGC,NNIFSL
;DEBUGGING FEATURE
	BIT #PNNLF,FLAGS2
	BEQ GCRT6
	CPRTXT ^/[NODES LEFT /
	MOV NNGC,A
	JSR PC,PRDN
	PRTXTC ^/ ]/
;
GCRT6:
;	TST FILFLG
;	BEQ GCRT7	;NO
;	MOV #DREADC,E
;	JSR PC,GBITGS	;GET BACK THE BUFFERS
GCRT7:	POP TMPBLK
	SPOP GNCN+2
	SPOP GNCN
	JSR F,ACRES
	SEZ
	RTS PC

GBITGS:	MOV USER,U
	JSR PC,SYDRBG	;GET A REQUEST BLOCK
	CLR (A)+
	MOV #-DBUFL/2,(A)+
	MOV #GCBITS-PURE,(A)
	MOV SLOTAS(U),B
	MOV SLOTHA(B),C
	ADD SLOTCA(B),(A)+
	ADC C
	ASH #4,C
	MOVB C,6(A)
	MOV UDBFSV(U),(A)+
	MOV UDBFSV+2(U),(A)+
	TST (A)+
	BIS E,(A)
	JMP DSKWAI
	.STITL GET NEXT OBLIST ELEMENT
GNOLE:		;GET NEXT USER OBLIST ELEMENT - PTR
		;INPUT - VIA GNOLEI
		;OUTPUT - PTR TO THIS BUCKET IN B & GNCN
		;	   " " NEXT " " GNCN+2
		;	   " " PRED " " TMPBLK
		;	   IF NO PREV BUCKET, TMPBLK = 0
		;USES E.  SKIPS UNTIL NO UOE PTRS LEFT
	PUSH A
	MOV GNCN,B
	MOV GNCN+2,TMPBLK
GNOLE2:	MOV B,GNCN+2
	BIC #170000,B
	BEQ GNOLE1
	JSR PC,.LOAD	;GET NEXT PTR ON BUCKEN LIST
	MOV A,GNCN
	JMP SRETA
GNOLE1:	CLR TMPBLK
	MOV (E)+,B	;GET NEXT BUCKET LIST
	BGE GNOLE2
	JMP RETA	;DONE
GNOLEI:	MOV #UHCT,E
	CLR GNCN
	RTS PC
.STITL SYSTEM PRIMITIVES
	VERN==VERN+%FNAM2
.IFNZ ENG&FR
ENGLIS:ANGLAI:	MOV #ENGFLG,LANG
ENG1:	SEZ
	RTS PC
FRENCH:FRANCAIS:	MOV #PFRFLG!FRFLG,LANG
	BR ENG1
FRANGLAIS:	BIS #ENGFLG!FRFLG,LANG
	BR ENG1
.ENDC
;THIS IS THE STUFF FOR ARRAY HACKING

SETASZ:	JSR PC,G1NARG
	ASL B
	MOV ENDWLD,A
	SUB B,A		;COMPUTE NODTOP
	CMP #NODESP+400,A
	BLO .+4		;IS THIS POSSIBLE?
	ERROR+NAS	;NO
	MOV USER,A
	MOV B,UASIZE(A)
SEZWHO:	JMP HELLO	;REINITIALIZE USERS SLOT
AMAKE:	MOV 4(SP),D	;NO. OF ARGS
	ASL D
	ADD S,D
	MOV -(D),A	;ADDR OF ARRAY NAME
AMAKE5:	MOV A,B
	BIC #7777,A
	CMP #ATOM,A	;IS A TYPE ATOM?
	BNE AMAKE3	;NO
AMAKE4:	MOV #ABIND,A
	JSR PC,.BINDL
	BEQ AMAKE6
	CLR TOPS
	RTS PC
AMAKE3:	CMP #LSTR,A	;IS A TYPE LSTR?
	BNE AMAKE2	;YES
AMAKE1:	BIT #7777,B	;NULL POIMTER?
	BEQ AMAKE2	;YES
	MOV B,TOPS
	JSR PC,.OBSCH	;GET ATOM
	BNE AMAKE4
AMAKE6:	ERROR+UDA
AMAKE2:	ERROR+WTAB



ARRAD:	MOV B,E
	SPUSH E	;TOP OF ARRAY HEADER
	CMPB 4(E),F	;IS DIM=NO. OF INDICES?
	BEQ ARRAD1	;YES
	ERROR+WNA	;WRONG NO OF ARGS
ARRAD1:	CLR A	;TEMP ACCUMULATOR
	ADD #12,E	;LENGTH OF DIMENSION IN E
ARRAD2:	JSR PC,G1NARG	;GET INDEX OFF S-PDL
	CMP B,(E)	;INDEX IN BOUNDS?
	BGE ARRAD4	;NO
	TST B	;NEGATIVE INDEX?
	BGE .+4	;INDEX OK
ARRAD4:	ERROR+ROB
	ADD B,A
	DEC F
	BEQ ARRAD3	;MORE INPUT
	MUL -(E),A
	MOV B,A
	BR ARRAD2
ARRAD3:	SPOP E	;ADDR OF ARRAY HEADER
	TSTB 5(E)	;IS TYPE PTR?
	BEQ .+4
	ASL A
	ASL A		;TOTAL OFFSET (A*4)
	ADD #14,E	;ADDR OF FIRST VALUE
	ADD E,A		;ADDR OF VALUE TO BE STORED
	RTS PC


STORE:	JSR PC,AMAKE
	SPOP	A	;RETURRN ADDR
	SPOP F		;NO. OF ARGUMENTS
	SPUSH	A
	SUB #2,F
	POPS D		;VALUE TO BE STORED
	JSR PC,ARRAD	;FIND STORAGE LOCATION
	MOV A,F
	MOV -10(E),A
	MOV D,B
	BIC #7777,A
	BEQ STORE1
	JSR PC,CONVERT
	BNE .+4
	ERROR+WTAB
	JSR PC,.LOADB
	MOV A,(F)+
STORE1:	MOV B,(F)	;VALUE IS NOW STORED
	ADD #2,S
	SEZ
	RTS PC


GET:	JSR PC,AMAKE
	SPOP	A	;RETURN ADDR
	SPOP F	;NO. OF ARGUMENTS
	SPUSH	A
	DEC F		;NO. OF INDICES
	JSR PC,ARRAD	;COMPUTE STORAGE LOCATION
	MOV A,F		;STORAGE LOCATION ADDR IN F
	MOV (F),C
	TSTB -7(E)	;TEST TYPE
	BEQ GET1	;TYPE 0 (PTR)
	MOV (F)+,A
	MOV (F),B
	JSR PC,GRBAD	;STORES VALUE IN NODE SPACE
	MOV -10(E),D
	BIC #7777,D
	BIS D,C		;SET TYPE ON PTR TO VALUE
GET1:	MOV C,@S	;PTR ON TOP OF S-PDL
	CLZ
	RTS PC

LIMIT==3
HEADER==14
BKPTR==4
SIZE==2


	;INPUT--B HAS SIZE OF BLOCK TO BE ALLOCATED IN BYTES
	;OUTPUT--A HAS PTR.TO BLOCK IF ALLOCATION SUCESSFUL
	;        SECOND WORD OF BLOCK CONTAINS SIZE OF BLOCK IN BYTES
	;        AND SKIP RETURN


.ALLOC:	CMP	B,ASPACE	;SIZE OF ARRAY .LE. FREE SPACE?
	BLE	.+6		;YES
	SEZ
	RTS	PC		;NO,RETURN

	PUSH	C
	MOV	AROVER,A	;GET FRE BLOCK PTR.
SRCBLK:	CMP	B,SIZE(A)	;IS BLOCK NOW POINTED AT BIG ENOUGH?
	BLE	OKALOC		;YES
	CMP	@A,AROVER	;CHAIN GONE THRU' ONCE?
	BEQ	CMPRES		;YES
	MOV	@A,A		;NEXT FREE BLOCK
	BNE	SRCBLK		;LAST BLOCK IN CHAIN?
	MOV	AFREE,A		;YES,START FROM THE BEGINNING
	CMP A,AROVER
	BNE SRCBLK

CMPRES:	JSR	PC,.PRESS	;GO COMPRESS THE ARRAY SPACE
	MOV	AROVER,A	;A POINTS TO FREE SPACE
OKALOC:	MOV SIZE(A),C
	SUB B,C
	CMP #20,C
	BGE HOLE
	MOV	A,C		;TO ADDR.OF FREE BLOCK
	ADD	B,C		;ADD SIZE OF ALLOCATED BLOCK TO GET NEW FREE BLOCK ADDR.
	SUB	B,SIZE(A)	;GET SIZE OF NEW FREE BLOCK
	MOV	SIZE(A),SIZE(C)	;AND STORE IN SIZE FIELD OF NEW FREE BLOCK
	MOV B,SIZE(A)
	MOV	BKPTR(A),BKPTR(C)	;PTR. MANAGEMENT
	BEQ	NEWBK1		;IF THIS BLOCK FIRST OF CHAIN,SKIP
	MOV	C,@BKPTR(A)	;CHANGE FORWARD PTR. OF LAST BLOCK
NEWBK1:	MOV	(A),(C)		;FORWARD PTR. FOR NEW BLOCK
	BEQ	NEWBK3		;IF THIS BLOCK IS LAST IN CHAIN,SKIP
NEWBK2:	ADD	#BKPTR,@A	;TO ACCESS BKPTR FIELD OF NEXT BLOCK
	MOV	C,@(A)		;AND CHANGE IT
NEWBK3:	MOV	C,AROVER	;UPDATE FREE BLOCK ROVING POINTER
	CMP	AFREE,A		;REQUIRED TO UPDATE AFREE?
	BNE	ALDONE		;NO
	MOV	AROVER,AFREE	;YES
ALDONE:	SUB	SIZE(A),ASPACE	;UPDATE FREE SPACE AVAILABLE
	POP	C
	CLZ
	RTS PC
			;SKIP RETURN

HOLE:	MOV	BKPTR(A),C	;TO LINK UP WITH BLOCK BEFORE THE ONE ALLOCATED
	BNE	NEWBK1		
	MOV (A),C
	BR NEWBK3
	;RELEASE A BLOCK IN THE ARRAY SPACE
	;INPUT--B HAS PHYSICAL PTR TO BLOCK TO BE RELEASED
	;OUTPUT--B UNCHANGED. RELEASED BLOCK INSERTED INTO CHAIN OF FREE BLOCKS


.RELES:	ADD	SIZE(B),ASPACE	;UPDATE ASPACE
	TST	AFREE		;IS ARRAY SPACE EMPTY?
	BEQ	ONEBLK		;YES
	PUSH	A
	SPUSH	C
	SPUSH	D
	MOV	AROVER,C
	CMP	B,C		;ADDR OF RELEASED BLOCK > (AROVER)
	BHI CHAIN		;START TRYING TO INSERT AT AROVER
	MOV	AFREE,C		;OTHERWISE START AT AFREE
	CMP B,C
	BHI CHAIN
	MOV AFREE,A
	JSR PC,ONEBLK
	MOV B,C
	ADD SIZE(B),C
	CMP A,C
	BNE .RELE1
	MOV (C),(B)
	ADD SIZE(C),SIZE(B)
	BR REDONE
.RELE1:	MOV A,(B)
	MOV B,BKPTR(A)
	BR REDONE

CHAIN:	MOV	C,A		;A_CURRENT FREE BLOCK
	MOV	(A),C		;C_NEXT FREE BLOCK
	BEQ	LSTBLK		;CURRENT BLOCK IS LAST IN CHAIN
	CMP	C,B		;ADDR OF NEXT FREE > ADDR OF RELEASED?
	BLT	CHAIN		;NO,TRY NEXT ONE
	MOV	SIZE(B),D	;YES,START INSERTING THE RELEASED BLOCK
	ADD	B,D		;SIZE IN BYTESADDED TO (B) GIVES END OF RELEASED BLOCK
	CMP	C,D		;WHICH MIGHT BE ADJACENT TO NEXT FREE BLK
	BNE	LSTBLK		;NO
	ADD	SIZE(C),SIZE(B)	;YES,COLLAPSE THE TWO
	MOV	(C),C		;UPDATE FWDPTR

LSTBLK:	MOV	SIZE(A),D	;THIS FREE BLOCK 
	ADD	A,D		;MIGHT BE ADJACENT TO THE
	CMP	D,B		;RELEASED BLOCK
	BEQ	CONBLK		;YES
	MOV	C,(B)		;NO,JUST UPDATE PTR
	MOV	A,BKPTR(B)	;SIZE FIELD NEED NOT BE CHANGED
	MOV	B,(A)	
	TST	C		;IF THIS FREE BLOCK IS LAST IN CHAIN
	BEQ	REDONE		;THEN NOTHING
	MOV	B,BKPTR(C)	;ELSE UPDATE BKPTR OF NEXT BLK
REDONE:	POP	D
	SPOP	C
	SPOP	A
	RTS	PC

ONEBLK:	MOV	B,AFREE		;RELEASED BLOCK IS THE ONLY FREE ONE
	MOV	B,AROVER
	CLR	(B)
	CLR	BKPTR(B)
	RTS	PC


CONBLK:	ADD	SIZE(B),SIZE(A)	;COLLAPSE
	MOV	C,(A)		;AND UPDATE PTR
	BR	REDONE
	;THIS ROUTINE COMPRESS THE ARRAY SPACE BY STACKING FREE BLOCKS TOGETHER
	;AFREE POINTS TO FIRST FREE BLOCK IN THE CHAIN
	;FIRST WORD OF USED BLOCK MUST CONTAIN PTR. TO WORD POINTING TO THAT BLOCK FOR RELOCATING

.PRESS:	TST	AFREE		;ARE THERE ANY FREE BLOCKS?
	BNE	.+4		;YES
	RTS	PC		;NO,DONE
	PUSH	A
	SPUSH	B
	SPUSH	C
	SPUSH	D

	MOV	AFREE,A		;A_FIRST FREE BLOCK ADDR
MOVNXT:	MOV	A,B		;B_CURRENT FREE BLOCK ADDR
	MOV	(B),A		;A_NEXT FREE BLOCK ADDR
	BEQ	PSDONE		;IF NEXT FREE BLOCK ADDR = 0,DONE
	MOV	SIZE(B),C	;FREE BLOCK SIZE IN BYTES
	ADD	B,C		;PLUS FREE BLOCK ADDR=STARTING ADDR OF USED BLOCK

COLAPS:	MOV	SIZE(C),D	;GET USED BLOCK SIZE
	ASR	D		;GET SIZE IN WORDS
	MOV	B,@(C)		;CHANGE PTRRR TO ARRAY		
	MOV	(C)+,(B)+	;BLOCK TRANSFER
	SOB	D,.-2		;COUNTER
	CMP	C,A		;THIS BLOC OF USED BLOCKS MOVED?
	BEQ	MOVNXT		;YES,MOVE NEXT BLOC
	BR	COLAPS		;NO,CONTINUE TO TRANSFER NEXT USED BLOCK

PSDONE:	SPOP	D
	SPOP	C
	SPOP	B
	SPOP	A
	MOV	ASPACE,SIZE(B)
	JMP	ONEBLK		;TAKE CARE OF AFREE AND RETURN
	;DEFINE AN ARRAY

DEFAR:	POP	A		;RETURN ADDR
	SPOP	F		;NO. OF ARGS PASSED
	SPUSH	A
	CMP	F,#LIMIT+2	;WHICH SHOULD BE < ALLOWABLE LIMIT
	BLE	OKARAY		;OKAY,THIS IS.
AERROR:	ERROR+WDIM
OKARAY:	SUB	#2,F		;DIMENSION OF ARRAY IN F
	MOV	F,A
	MOV	#1,D		;SET UP FOR MULTIPLICATION
	JSR	PC,G1NARG	;GET TYPE
	MOV	B,E		;SAVE IT
	TST	B
	BEQ	ALNUM		;0 FOR LNUM
	.IFNZ FPPF
	CMP	#1,B
	BEQ	AFNUM		;1 FOR FNUM
	.ENDC
	CMP #2,B
	BEQ NXTIDX	;2 FOR PTR
	ERROR+BAT
ALNUM:	BIS	#LNUM,F
	BR	NXTIDX
	.IFNZ FPPF
AFNUM:	BIS	#FNUM,F
	BR	NXTIDX
	.ENDC
NXTIDX:	JSR PC,G1NARG	;GET MAGNITUDE OF LAST DIMENSION
	PUSH	B		;SAVE THIS DIMENSION
	MUL	B,D		;D IS ODD
	BLE	AERROR		;DIMENSION < 0
	BCS	AERROR		;DIMENSION TOO BIG
	SOB	A,NXTIDX
	SPUSH	F		;SAVE DIMENSION OF ARRAY
	BIT	#160000,D	;SIZE SHOULD NOT BE TOO BIG
	BNE	AERROR
	CMP	#2,E		;IS THIS PTR ARRAY
	BEQ	.+4
	ASL	D		;THIS IS DOUBLE PRECISION ARRAY
	ASL	D		;TO CONVERT TO BYTES
	ADD	#HEADER,D
	SPUSH	D		;SAVE SIZE OF ARRAY BLOCK
	MOV	@S,B		;GET NAME OF ARRAY
	MOV	B,A		
	BIC	#7777,A		;SEE WHETHER IT HAS BEEN INTERNED?
	CMP	#ATOM,A		;BY TESTING ITS TYPE
	BEQ	FABIND		;YES
	CMP	#LSTR,A		;NO,IS NAME ALL RIGHT
	BEQ	.+4		;YES
	ERROR+WTAB
	MOV	B,TOPS
	JSR	PC,.INTRN	;INTERN NAME OF ARRAY
	MOV	B,@S		;SAVE UOE PTR
FABIND:	CLR	TOPS		;NOT TO CHANGE BINDING
	MOV	#ABIND,A	;SEE IF AN ARRAY IS
	JSR	PC,.BIND	;BINDED TO THIS NAME
	BEQ	GETSPA		;NO
	MOV	C,@S		,SAVE PTR TO BINDING NODE
	MOV	B,C
	MOV 2(C),B
	ADD	ASPACE,B	;ADDED TO AVAILABLE FREE SPACE
	CMP	B,@P		;IS SUM ENOUGH FOR NEW BINDING?
	BGE	ERAOLD		;YES
FULL:	ERROR+NAS		;NOT ENOUGH SPACE
ERAOLD:	MOV	C,B
	JSR	PC,.RELES	;RELEASE OLD BINDING

GETSPA: SPOP B	;GET SIZE OF ARRAY
	MOV B,D		;SAVE IT
	JSR	PC,.ALLOC	;ASSIGN SPACE
	BEQ	FULL		;NOT ENOUGH
	SPOPS	B		;UOE PTR
	MOV	A,TOPS		;ARRAY PTR
BINDA:	MOV	#ABIND,A
	JSR	PC,.BIND	;BIND NEW ARRAY
	BIC	#170000,C	;PTR TO BINDING NODE
	ASL	C
	ASL	C
	ADD	#NODESP+2,C	;THIS IS PHYSICAL ADDR OF BINDING NODE
	MOV	TOPS,A		;PTR TO ARRAY
	MOV	C,(A)+		;BACK PTR FIRST ENTRY IN HEADER
	MOV (A)+,D	;SIZE OF ARAY SECOND
	SPOP	F
	MOV	F,(A)+		;DIMENSION OF ARRAY THIRD
	ADD	#LIMIT*2,A	;TO ADVANCE (A)
	BIC	#177400,F	;GET DIMENSION PART
	MOV	F,E
	ASL	E		;TO GET IT INTO BYTES
	SUB	E,A		;FOR OFFSET INTO HEADER
POPDIM:	SPOP	(A)+
	SOB	F,POPDIM
	SUB #HEADER,D
	ASR D
	CLR (A)+	;ZERO ARRAY VALUES
	SOB D,.-2
	SEZ
	RTS	PC
ERARAY:	JSR	PC,GTUOEB	;GET NEXT TOKEN
	BNE	ERARA1
ERARA2:	CLR	TOPS
	MOV	#ABIND,A
	MOV	B,F
	JSR	PC,.BIND
	BEQ ERARAR
	JSR	PC,.RELES	;RELEASE ARRAY BLOCK
	MOV	F,B
	JSR PC,.UNBND
ERARAR:	SEZ
	RTS PC

ERARA1:	CMP	#UFUN,A
	BGT	.+4
	ERROR+ERW
	JSR	PC,CVSFLS
	MOV	#ATOM,A
	JSR	PC,.OBSCH
	BNE	ERARA2
ERARA3:	RTS PC


ERARAS:	JSR	PC,GNOLEI
ERARS1:	JSR	PC,GNOLE
	BEQ ERARAR
	MOV	B,F
	CLR	TOPS
	MOV	#ABIND,A
	JSR	PC,.BIND
	BEQ	ERARS1		;THIS NAME HAS NO ARRAY BINDING
	JSR	PC,.RELES	;RELEASE THIS ARRAYY
	MOV	F,B
	JSR	PC,.UNBND
	BR	ERARS1


;RETURNS SIZE OF ARRAY DIMENSIONS
ASIZEX:	MOV @S,A	;ARRAY NAME
	JSR PC,AMAKE	;FINDS TOP OF ARRAY SPACE
ASIZE2:	PUSH E
	MOV B,E
	MOVB 4(E),D	;TYPE/DIM WORD
	MOV D,F
	SPUSH D		;SAVE IT
	ASL D		;SETS UP OFFSET FOR DIMENSION WORD
	SUB D,E
	ADD #2,S	;POP OFF THE ARRAY NAME
	ADD #14,E	;ADDR. OF FIRST DIM.
ASIZE1:	MOV (E)+,B
	JSR PC,.CSNIN	;CONVERT TO INUM AND PUT IN NODE 
	SPUSHS C	;SAVE PTR ON S-PDL
	SOB F,ASIZE1	;CHECK FO MORE DIMS.
	SPOP D		;NO OF DIMS. IN D
	JSR PC,SENT.	;LINK DIMS. IN LIST
	POP E
	CLZ
	RTS PC


.IFNZ FPPF

;FLOATING POINT MACROS

.MACR FPUSH FF
	STF FF,-(P)
	JSR PC,PPUSHT
.ENDM


.MACR FPOP FF
	LDD (P)+,FF
	JSR PC,PPOPT
.ENDM

.ENDC





.IFZ FPPF


;SINGLE PRECISION ARITHMETIC ROUTINES

UPLUS:	CLZ	;UNARY PLUS - NOTHING TO DO
	RTS PC
UMINS:	JSR PC,G1IARG	;UNARY MINUS
	DPNEG	B,C
DONBC:	JMP	R1I.BC

SUM:
	EXCH (P),2(P)
	CLR	E
	CLR	F
	MOV	(SP)+,D	;NUMBER OF ARGS
	BLE	DIFF.2	;DONE
SUM.1:	JSR	PC,G1IARG	;GET 1 INTEGER
	DPADD	B,C,E,F
	DEC	D	;COUNTER
	BGT	SUM.1
	BR	DIFF.2	;DONE

DIFF:
	JSR	PC,G2IARG	;GET 2 INTEGERS
	DPSUB	B,C,E,F
DIFF.2:	CMP	E,#100000	;IS ANSWER = 100...00 ?
	BNE	DONEMP
	TST	F	;IF SO , THEN ERROR
	BNE	DONEMP
	ERROR+RTB	;SINCE THAT IS SMALLEST NEG NUMBER
DONEMP:	JMP	R1I.EF

PROD:
	EXCH (P),2(P)
	CLR	E
	MOV	#1,F
	MOV	(SP)+,D	;NUMBER OF ARGS
PROD.1:	DEC	D
	BLT	DONEMP	;DONE
	JSR	PC,G1IARG	;GET ONE ARG IN B
	JSR	PC,.DPMUL
	BNE PROD.1
	ERROR+RTB	;RESULT TOO BIG

MOD:
	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONBC
	ERROR+RTB

DIVDE:
DIV.1:	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	BNE DONEMP
	ERROR+RTB


.ENDC


.IFNZ FPPF


;FLOATING POINT ARITHMETIC ROUTINES

ERRET:	ERROR+RTB
UPLUS:	CLZ
	RTS PC
UMINS:	MOV #INUM,F
	JSR PC,G1ARG
	LDD FA,FB
	NEGF FB
	BR .FSTOR	;STORE FB
DIFF:	JSR PC,G2ARG	;LOAD FA AND FB
	SUBF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
SUM:	EXCH (P),2(P)
	MOV #INUM,F
	CLRF FB
	SPOP D		;SET UP COUNTER
	BLE .FSTOR
SUM.1:	JSR PC,G1ARG	;GET A NUMBER
	ADDF FA,FB	
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT SUM.1	;ADD MORE NUMBERS
	BR .FSTOR	;DONE AT LAST
PROD:	EXCH (P),2(P)
	MOV #INUM,F
	LDCFD #40200,FB	;LOAD CONSTANT "1"
	SPOP D
	BLE .FSTOR	;DONE ALREADY
PROD.1:	JSR PC,G1ARG
	MULF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	DEC D
	BGT PROD.1	;LOOK AT COUNTER

;THIS TAKES A NUMBER OUT OF FB AND
;CONVERTS IT ACCORDING TO TYPE IN REG F (INUM,FNUM)
;AND RETURNS

.FSTOR:CMP #FNUM,F	;FNUM OR INUM?
	BEQ .FST.2
	STCFI FB,-(P)	;PUT INUM ON STACK
	BCS ERRET	;OVERFLOW?
.FST.1:	SPOP A
	SPOP B
	JSR PC,GRBAD	;STORE ANSWER
	BIS F,C		;SET TYPE
	JMP ORTC
.FST.2:	STCDF FB,-(P)	;PUT FNUM ON STACK
	JMP .FST.1
DIVDE:	JSR PC,G2ARG	;GET ARGS
	TSTF FA		;TEST ZERO DIVIDE
	CFCC
	BEQ ERRET	;IT WAS!!??
	DIVF FA,FB
	CFCC
	BVS ERRET	;OVERFLOW?
	BR .FSTOR	;STORE IT
MOD:	JSR PC,G2ARG	;GET ARGUMENTS IN FA AND FB
	SPUSH #.FSTOR
.MOD:	TSTF FA		;IS FA 0?
	CFCC
	BEQ ERRET	;IT IS??
	LDD FB,FC	;FC <- FB
	DIVF FA,FC	;FC <- (FB/FA)
	CFCC
	BVS MOD2	;THE ANSWER IS 0
	MODD #40200,FC	;SEPERATE INTEGER AND FRACTION PARTS
	MULF FA,FD	;FD <- FA * (INT (FB/FA))
	SUBF FD,FB	;FB <- MOD (FB,FA)
MOD1:	CFCC
	BGE MOD3	;IS IT POSITIVE?
	ADDF FA,FB	;NO, ADD FA
	BR MOD1
MOD2:	CLRF FB
MOD3:	RTS PC


SQRT:	JSR PC,G1NUM
	BNE .+4
SQRT1:	ERROR+WTA
	TSTF FA
	CFCC
	BMI SQRT1
	BEQ SQRTRT
	LDF FA,FB
	STEXP FA,A
	LDEXP #0,FA
	ASR A
	ADC A
	ADDF #40000,FA
	BCS .+6
	ADDF #40000,FA
	CLRF FC
	LDEXP A,FC
	MULF FC,FA
	MOV #4,A
SQRTLP:	LDF FB,FC	;FC <= X
	DIVF FA,FC	;FC <= X/Y
	ADDF FC,FA	;FA <= Y + X/Y
	MULF #40000,FA	;FA <= 1/2 * (Y + X/Y)
	SOB A,SQRTLP
SQRTRT:	MOV #FNUM,F
	STCDF FA,-(P)
	JMP .FST.1
.ENDC





SENTENCE:
	SPOP EXCH1
	MOV (SP),D
	MOV EXCH1,(SP)	;# OF ARGS . DON'T CHANGE FROM D WITHOUT CHANGING SNAP!!!!
SENT.:	CLR	C
	TST	D
SENT.1:	BLE	SENT.R	;RETURN
	MOV	@S,B	;ARGUMENT.  LEAVE ON S-PDL FOR GARBGE COLLECTOR
	MOV	B,A
	BIC	#7777,A	;LEAVE ONLY DATA TYPE
	CMP	#LIST,A
	BEQ	SENT.S	;ARG IS LIST
	CMP	#ATOM,A
	BNE	SENT.2	;ARG IS LSTR OR INUM

;ARG IS AN ATOM
SENT.A:	JSR	PC,.LOAD	;CONVERT ATOM TO LSTR
	MOV	#LSTR,A

SENT.2:	BIS	C,A	;C POINTS TO PREVIOUS STUFF OF SENTENCE
	JSR	PC,GRBAD

SENT.3:	MOV	C,GCPREV	;POINTER TO PREVIOUS STUFF OF SENTENCE
	BIS	#LIST,GCPREV	;GARBAGE COLLECTOR NEEDS RIGHT DATA TYPE
SENT.4:	JSR	PC,SPOPT	;POP S
	DEC	D	;COUNTER
	BR	SENT.1

SENT.S:	BIT	#7777,B	;ARGUMENT IS A LIST
	BEQ	SENT.4	;EMPTY
	TST	C	;0 IF FIRST TIME CALLED
	BEQ	SENS.1	;NO NEED TO COPY
;SECOND OR LATER TIME THROUGH
SENS.2:	JSR	PC,COPYL	;COPY LIST. RETURN POINTER IN B
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;C STILL POINTS TO LAST NODE COPIED
SENS.1:	BIC	#170000,B	;LEAVE POINTER ONLY
	MOV	B,C
	BR	SENT.3

;RETURN.  POINTER TO SENTENCE IN C
SENT.R:	BIS	#LIST,C
	CLR	GCPREV
	PUSHS	C
	CLZ
	RTS	PC



LIST.P:
	EXCH (P),2(P)
	MOV	(SP),D	;COUNT
	MOV	#ORTC,(SP)	;RETURN ADDRESS
LIST1:	CLR	C
LIST.1:	DEC	D	;COUNT
	BLT	LIST.9	;DONE
	MOV	@S,B
	MOV	B,A
	BIC	#7777,A	;LEAVE DATA TYPE ONLY
LIST.2:	BIS	C,A	;POINTER TO REST OF LIST
	JSR	PC,GRBAD
	MOV	C,GCPREV	;PROTECT FROM GARBAGE COLLECTOR
	BIS	#LIST,GCPREV	;GAR. COLL. NEEDS RIGHT DATA TYPE
	JSR	PC,SPOPT
	BR	LIST.1	;GET NEXT ARG

LIST.9:	CLR	GCPREV
	BIS	#LIST,C
	RTS	PC


FPUT:
	CLR	F
	BR	.+6
LPUT:
	MOV	#<LPUT1-FPUT1>,F
	EXCH (P),2(P)
	MOV	(SP),D	;NUMBER OF ARGS
	MOV	#ORTC,(SP)	;RETURN ADDRESS
	DEC	D
	BGT	.+4
	ERROR+UEL	;NEED AT LEAST 2 ARGS
	JSR	PC,GLWARG
	BEQ	.+4	;LIST
	ERROR+WTA	;FIRST ARG MUST BE LIST
	ADD	F,PC	;CHOOSE BETWEEN LPUT AND FPUT

FPUT1:	MOV	B,A	;POINTS TO ARG
	BIC	#170000,A	;CLEAR DATA TYPE
	JSR	PC,SPOPT
	MOV	@S,B	;FIRST ELEMENT TO BE PUT
	MOV	B,C
	BIC	#7777,C	;THIS DATA TYPE WILL BE SET INTO A
	DEC	D
	BR	LIST.2

LPUT1:	JSR	PC,COPYL	;COPY LIST. RETURN PTR IN B
	MOV	B,GCP1
	JSR	PC,SPOPT	;POP 1ST ARG
	JSR	PC,LIST1	;LIST REST OF ARGS
	TST F
	BEQ LPUT2
	BIC	#170000,C	;POINTER TO THAT LIST
	MOV	C,D	;SAVE IT
	MOV	F,C	;POINTER TO LAST NODE OF COPIED LIST
	JSR	PC,.LDP1
	BIS	D,A	;JOIN COPIED LIST TO LIST OF ARGS
	JSR	PC,.STP1
	MOV	GCP1,C
LPUT2:	CLR	GCP1
	RTS	PC


WORD:
	EXCH (P),2(P)
	CLR	C
	MOV	(SP)+,D	;NUMBER OF ARGS
WORD.1:	BLE	WORDR
	MOV	@S,B	;GET ARG,  BUT LEAVE ON STACK

.IFZ FPPF
	CMP	B,#LNUM	;IS ARG NUMBER?
	BLO	WORD.2
	CMP	B,#<LNUM+10000>
	BLO	WORD.N	;NUMBER
.IFF
	MOV B,A		;DOES B POINT TO INUM OR FNUM
	BIC #170000,A
	CMP #INUM,A
	BEQ WORD.N
	CMP #FNUM,A
	BEQ WORD.N
.ENDC

WORD.2:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BNE .+4
	ERROR+WTAB
	BIT	#7777,B	;IS ARG THE EMPTY WORD
	BEQ	WORD.4	;YES

	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3

;SECOND OR LATER ARG
WORD.5:	JSR	PC,CPYSTR	;COPY STRING
WORD.6:	JSR	PC,.LDP1	;LAST NODE OF COPIED STRING
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;BIS POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;STORE BACK

WORD.3:	BIC	#170000,B
	BIS	#LSTR,B	;GAR. COLL. NEEDS RIGHT DATA TYPE
	MOV	B,GCPREV	;POINTER TO PREVIOUS STUFF
WORD.4:	JSR	PC,SPOPT	;POP S
	DEC	D
	BR	WORD.1

;ARGUMENT IS NUMBER. CONVERT TO STRING
WORD.N:
.IFZ FPPF
	JSR PC,.CINLS
.IFF


.CLNLS:	MOV B,A
	BIC #170000,A
	CMP #INUM,A
	BEQ .CLNL1
	JMP .CINLS
.CLNL1:	JMP .CFNLS
.ENDC
	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3	;IS FIRST ARG
	BR	WORD.6	;SECOND OR LATER, BUT DON'T RECOPY!!

;RETURN
WORDR:	MOV	GCPREV,C
	BIS	#LSTR,C
	CLR	GCPREV
	JMP	ORTC



FIRST:
	JSR	PC,GLWANE
	BEQ	F.SENT	;ARG IS SENTENCE

;ARG IS WORD
	JSR	PC,INSTR	;RETURN ONE CHAR IN D
	BNE	.+4	;FOUND A CHAR
F.WTA:	ERROR+WTA	;NO CHARS IN STRING
	TST	(SP)+	;POP OFF CO-ROUTINE LINK
	MOV	D,B
F.STOR:	CLR	F
	JSR	PC,ACTSTO	;STORE THE CHAR.
	POPS C
	BIC #170000,C
	BIS	#LSTR,C	;POINTER TO THE NODE OF THE CHAR
	JMP	ORTNC

F.SENT:	MOV	B,C
	JSR	PC,.LDP2
	JMP	ORTNA


BUTFIRST:
	JSR	PC,GLWANE
	BEQ	BF.SEN

;ARG IS WORD
BF.W:	JSR	PC,INSTR	;RETURN ONE CHAR
	BEQ	F.WTA	;NO CHARS IN STRING
	TST	(SP)+
;A CONTAINS FIRST 2 CHARS OF THE STRING
;BUT IT MAY ONLY HAVE ONE.
	BIT	#177,A	;IS TOP CHAR OF A 0?
	BEQ BF.W1
	BIT #77400,A
	BEQ	BF.W1	;YES. ONLY ONE CHAR IN A
	CLRB	A	;KILL THE FIRST CHAR
	MOV	A,B
	MOV	C,A	;POINTER TO REST
	JSR	PC,GRBAD
BF.W1:	BIC	#170000,C
	BIS	#LSTR,C
	JMP	ORTNC

;ARG IS SENTENCE
BF.SEN:	MOV	B,C
	JSR	PC,.LDP1	;POINTER TO REST OF SENTENCE
	BIC	#170000,A	;LEAVE ONLY POINTER
	BIS	#SENT,A
	JMP	ORTNA


LAST:
	JSR	PC,GLWANE
	BEQ	L.SENT	;ARG IS SENTENCE

;ARG IS WORD
	MOV	B,C
	SPUSH	#INSTR1	;ADDRESS OF CO-ROUTINE
	CLR	D
L.W1:	MOV	D,B	;SAVE LAST CHAR
	JSR	PC,@(SP)+	;RETURNS CHAR IN D
	BNE	L.W1	;FOUND ONE
	TST	B	;STRING DONE
	BNE	F.STOR	;STORE THE CHAR AND RETURN
	ERROR+WTA	;NO CHARS FOUND

L.SEN1:	MOV	A,B
;ARG IS SENTENCE
L.SENT:	JSR	PC,.LOAD
	BIT	#7777,A	;LAST NODE OF SENTENCE YET?
	BNE	L.SEN1

L.SRET:	JMP	ORTNB


BUTLAST:
	JSR	PC,GLWANE
	BEQ	BL.SEN	;ARG IS A SENTENCE

;ARG IS A WORD
	JSR	PC,CPYSTR	;COPY STRING.
	JSR	PC,.LDP2	;LAST NODE OF NEW STRING
	SWAB	A
	BNE	BL.W2	;THE LAST CHARACTER IS REALLY THERE
	CLR	A	;(WE KNOW THE FIST CHAR IS REALLY THERE)
	CMP	B,C	;IS THERE ONLY ONE NODE
	BNE	BL.W1	;MORE TAN ONE NODE
	CLR	B	;ANSWER IS EMPTY WORD
	BR	BL.W3

BL.W2:	CLRB	A	;CLEAR LAST CHAR
BL.W1:	JSR	PC,.STP2	;STORE NODE BACK
BL.W3:	BIS	#LSTR,B	;POINTER TO THE WORD
BL.ORT:	JMP	ORTNB

;ARG IS A SENTENCE
BL.SEN:	JSR	PC,COPYL	;COPY LIST
	MOV	E,C	;POINTS TO NEXT TO LAST NODE
	BEQ	BL.SR	;ANSWER IS EMPTY
	JSR	PC,.LDP1
	BIC	#7777,A
	JSR	PC,.STP1
	MOV	B,C
BL.SR:	BIS	#LIST,C
	JMP	ORTNC


;INPUT IS NUMBER. OUTPUT IS THE CHARACTER CORRESPONDING TO THAT NUMBER

CHAR:	JSR	PC,G1IARG	;B,,C _ NUMBER
	MOV	C,B
	BIC	#177600,B
	MOV	#SSTR,A
	JSR	PC,GRBAD
	BIS	#LSTR,C
	JMP	ORTC


COUNT:
	JSR	PC,GLWARG
	BEQ	CT.SEN

;ARG IS WORD
	MOV	B,C
	CLR	B
	MOV	#INSTR1,-(SP)	;ADDRESS OF A CO-ROUTINE
CT.W1:	INC	B	;INCREMENT COUNTER
	JSR	PC,@(SP)+	;RETURNS CHAR IN B
	BNE	CT.W1
	DEC	B	;WHEN RETURNS HERE, NO MORE CHARS
CT.ORT:	POPS C
	JMP R1NARG	;C IS A THROW-AWAY

;ARG WAS A SENTENCE
CT.SEN:	MOV	B,C
	JSR	PC,CLE	;RETURNS NUMBER OF LIST ELEMENTS IN B
	BR	CT.ORT


;COPY LIST.
;	CALL WITH B POINTING TO LIST
;	RETURNS B POIOTING TO NEW LIST, C POINTING TO LAST NODE
COPYL:	CLR	E	;WILL POINT TO 2ND NODE FROM LAST
	CLR	F
	BIT #7777,B
	BEQ COPYR1
COPYL1:	BIT	#7777,B
	BEQ	COPYLR	;DONE
	JSR	PC,.LOAD
	MOV	F,E	;LISTB PLACES  LAST NODE PTR INTO F
	JSR	PC,LISTB
	MOV	A,B
	BR	COPYL1

COPYLR:	MOV F,C	;LISTB KEEPS PTR TO LAST NODE OF LIST IN F
	POPS	B	;LISTB KEEPS POINTER TO NEW LIST ON S.
COPYR1:	RTS	PC


;COPY STRING
;CALL WITH B POINTING TO STRING TO BE COPIED,
;ASSUMES THAT INPUT STRING HAS BEEN GARBAGE COLLECT PROTECTED ALREAEDY
;B POINTS TO FIRST NODE OF NEW STRING,  C POINTS TO LAST

CPYSTR:	MOV	#INSTR,A
MAKSTR:	MOV	D,-(SP)
	MOV	E,-(SP)
	MOV	F,-(SP)

	MOV	A,-(SP)	;ADDRESS OF INPUT STRING ROUTINE
	CLR	F

OUTSTR:	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE1	;INPUT STRING DONE

OSTR1:	MOV	D,B	;SAVE CHARACTER
	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE2	;INPUT STRING DONE

OSTR2:	SPUSH	A	;SAVE REGISTERS USED BY INPUT STRING
	SWAB	D
	BIS	D,B	;BIS SECOND CHARACTER
	JSR	PC,ACTSTO	;ACTUAL STORE
	SPOP	A
	BR	OUTSTR

;INPUT STRING HAS ENDED
OSTRE2:	JSR	PC,ACTSTO	;STORE CHAR IN B
OSTRE1:	POPS	B	;POINTER TO FIRST NODE OF STRING
	MOV	F,C	;POINTER TO LAST NODE
	BIC	#170000,B
	BIC	#170000,C
.RDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
	SEZ
OSTRR:	RTS	PC


;ACTUALLY STORE OUTPUT NODE
ACTSTO:	MOV	#SSTR,A
	JMP	LISTB


;INPUT STRING
;A CO-ROUTINE THAT HANDS BACK A CHARACTER IN BOTTOM BYTE OF D
;DOES RTS PC WHEN INPUT STRING FINISHED

INSTR:	MOV	B,C
INSTR1:	BIT	#7777,C
	BEQ	OSTRR	;RTS PC
	JSR	PC,.LDP2I
	MOVB	A,D
	BIC	#177600,D	;CLEAR TOP BYTE
	BEQ	INSTR2	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE

INSTR2:	CLRB A
	SWAB	A
	MOV	A,D
	BIC #177600,D
	BEQ	INSTR1	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE
	BR	INSTR1


;LIKE INSTR, EXCEPT GETS CHAR FROM TEXT STRING (NOT NODE SPACE)
;NOTE -- ENTER AT INTXT
INTXT0:	JSR	PC,@(P)+
INTXT:	MOVB	(C)+,D
	BNE	INTXT0	;BR IF NOT END OF TEXT
	RTS	PC

MAKE:	BIC #MMF,FLAGS2
	BR .+10
MMAKE:	BIS #MMF,FLAGS2
	POPS TOPS	;PUT VALUE INTO TOPS
	MOV @S,B
	MOV B,A
	BIC #7777,A
	CMP #ATOM,A	;IS TYPE ATOM?
	BNE MAKE2
MAKE4:	MOV #VBIND,A	;YES< SET VARIABLE BINDING?
	JSR PC,.BIND
	BIT #MMF,FLAGS2	;IS IT MULTIPLE MAKE?
	BEQ MAKE1
	MOV TOPS,@S
	CLR TOPS
	CLR TOPS1
	CLZ
	RTS PC
MAKE1:	POPS A
	CLR TOPS
	CLR TOPS1
	RTS PC
MAKE2:	CMP #LSTR,A
	BEQ MAKE3
MAKE5:	ERROR+WTAB	;WRONG TYPE OF ARG
MAKE3:	BIT #7777,B
	BEQ MAKE5
	MOV TOPS,@S
	MOV B,TOPS	;FOR .INTRN
	JSR PC,UINTRN	;.INTRN FOR STRINGS THAT MAY INCLUDE NULL CHARS
	MOV @S,TOPS
	BIS #ATOM,B
	MOV B,TOPS1
	BR MAKE4

DOTS:	JSR PC,GETVAL	;GET VALUE IF IT HAS ONE
	BNE .+4
	ERROR+HNV	;HAS NO VALUE
	PUSHS B
	CLR TOPS
	CLZ
	RTS PC

THINGP:	JSR PC,GETVAL	;DOES IT HAVE A VALUE?
	BEQ THNGPF	;NO
	JMP RTTRUE
THNGPF:	JMP RTFALS

GETVAL:	JSR PC,GUOEB	;GET UOE PTR FROM S INTO B
	BEQ GETVA1
	MOV #VBIND,A
	JSR PC,.BINDL
	BEQ GETVA1
	TST B
GETVA1:	RTS PC		;HAS NO VALUE (UNBOUND LOCAL)
GUOEB:	POPS B	;GET UOE OR LSTR IN B FROM S
	MOV B,A	;    SKIP IF UOE
	BIC #7777,A
	CMP #ATOM,A
	BEQ GUOE1
	CMP #LSTR,A
	BEQ GUOE2
	ERROR+WTAB	;.(B). ISWRONG TYPE OF ARG
GUOE2:	MOV B,TOPS
	JMP UOBSCH	;.OBSCH FOR STRINGS THAT HAVE NULL CHARS
GUOE1:	CLZ
	RTS PC
		;PRINT TOP (C) THINGS ON S
FPRINT:	INC NBKTS	;PRINTS OUTER [,]'S
PRINT:	EXCH (P),2(P)
	JSR	PC,REVS	;DOESNT "
	POP	C
	JSR	PC,TYPE1
	JSR	PC,.CRLF
	SEZ
	RTS PC

TYPE:	EXCH (P),2(P)
	JSR	PC,REVS
	POP	C
	JSR	PC,TYPE1	;PRINT WITHOUT CRLF AT END
	SEZ
	RTS PC

TYPE1:	BIS #DPQF+CPTBF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
			;BUT DO  PRINT % AS BLANK
	JSR PC,PRS1
	POPS A
	DEC C
	BGT	TYPE1
	BIC #DPQF+CPTBF,FLAGS2
	RTS	PC

;PREDICATES

EQUAL:	MOV	S,F
	MOV	(F)+,B	;ARG1.  LEAVE ON STACK FOR GC PROTECTION
	MOV	(F),C	;ARG2
	JSR	PC,EQUAL1
	BEQ	EQ.F	;RETURNS HERE IF FALSE
	ADD #4,S
	JMP RTTRUE
EQ.F:	ADD #4,S
	JMP RTFALS


;COMPARE THE DATA ITEM POINTED TO BY B WITH
;THE DATA ITEM POINTED TO BY C.
;SKIP IF THEY ARE EQUAL
EQUAL1:	MOV #7777,E	;AN OFT-USED CONSTANT
	MOV B,A
	MOV C,D
	BIC E,A
	BIC E,D
	CMP A,D
	BNE WEQUAL
	CMP #LIST,A
	BNE WEQUAL
EQ.LST:	BIC #170000,B
	BIC #170000,C
	CMP B,C
	BEQ EQTRUE
	TST B
	BEQ EQFALS
	TST C
	BEQ EQFALS
	JSR PC,.LOAD
	PUSH A
	JSR PC,.LDP2I
	SPUSH C
	MOV A,C
	JSR PC,EQUAL1
	BEQ EQ.FF
	POP B
	SPOP C
	BR EQ.LST

	FOR 0
EQUAL1:	CMP	B,C	;ARE THE POINTERS THE SAME
	BEQ	EQTRUE
	MOV	B,A
	JSR	PC,EQ.SUB	;IS ARG1 A WORD?
	BNE	EQ.W1	;A WORD
	JSR	PC,EQ.SB1	;IS ARG2 A WORD?
	BNE	EQFALS	;ARG1 ISN'T WORD, BUT ARG2 IS.
;BOTH ARGS ARE LISTS
EQ.LST:	JSR	PC,.LOAD	;FIRST NODE OF ARG1
	PUSH	A	;SAVE POINTER TO BF
	JSR	PC,.LDP2I	;FIRST NODE OF ARG2
	SPUSH	C	;SAVE POINTER TO BF
	MOV	A,C	;POINTER TO FIRST OF ARG1
;B POINTS TO FIRST ARG2.  C POINTS TO FIRST ARG1.
	JSR	PC,EQUAL1	;ARE THE FIRSTS EQUAL?
	BR	EQ.FF	;NO.  RETURN FALSE
	POP	B	;POINTER TO BF
	SPOP	C	;POINTER TO BF OF OTHER ARG
	BIC	#170000,B
	BIC	#170000,C
	CMP	B,C
	BEQ	EQTRUE
	JSR	PC,EQ.LST	;ARE THE BF'S EQUAL?
EQFALS:	RTS	PC	;NO
EQTRUE:	CLZ
	RTS PC	;YES


EQ.SB1:	MOV	C,A	;IS ARG A WORD?
EQ.SUB:	BIT	E,A	;EMPTY?
	BEQ	EQFALS	;ONE ARG FINISHED
	BIC	E,A
	CMP	#SENT,A
	RTS	PC

;ARG1 IS A WORD
EQ.W1:	JSR	PC,EQ.SB1	;IS ARG2 A WORD?
	BEQ	EQFALS	;NOT A WORD
;FALLS INTO WEQUAL
	.ENDC
	ENDC 0
EQ.FF:	CMP	(SP)+,(SP)+	;POP OFF THE POINTERS TO THE BF'S
	JSR PC,PPOPT
	SEZ
	RTS PC

;COMPARE TWO WORDS

.IFZ FPPF

WEQUAL:	MOV	#INUM,A
	JSR	PC,CONVERT	;TRY CONVERTING ARG TO INUM
	BEQ	EQ.STR	;NOT NUMERIC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG
	BEQ	EQFALS	;NOT NUMERIC
	JSR	PC,.LOAD	;A,,B HAVE NUMBER
	MOV	A,D
	MOV	B,F
	JSR	PC,.LOADC
	CMP	A,D	;COMPARE 2 INTEGERS
	BNE	EQFALS
	CMP	B,F
	BNE	EQFALS
	BR	EQTRUE
.IFF

WEQUAL:	JSR PC,G1NUMS	;IS IT A NUMBER?
	BEQ EQ.STR
	LDD FA,FB	;IT WAS SO SAVE IT
	MOV C,B		;IS THE SECOND A NUM?
	JSR PC,G1NUMS
	BEQ EQFALS
	CMPF FA,FB	;COMPARE THEM
	CFCC
	BNE EQFALS
	BR EQTRUE

.ENDC


;ARG NOT NUMERIC.  TRY STRING COMPARE
EQ.STR:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BEQ EQFALS	;EQUAL NOT DEFINED FOR SNAPS, ETC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG, TOO
	BEQ	EQFALS	;NOT SAME TYPE AS FIRST ARG
	CMP	B,C
	BEQ	EQTRUE

;COMPARE TWO STRINGS.  POINTERS IN B AND C.
	SPUSH	#INSTR1
	MOV	C,GCP2
CMPSTR:	MOV	B,GCP1
	MOV	B,F
CMPST1:	BIT	E,F	;IS ARG 1 ENDED
	BEQ	CMPSTE	;YES
	SPUSH	A	;SAVE A
	MOV	F,B	;POINTER TO REST OF ARG1
	JSR	PC,.LOAD
	MOV	A,F	;POINTER TO REST OF ARG1
	SPOP	A	;RESTORE A
	BICB #200,B	;IS CHAR REAL OR NULL?
	BEQ	CMPST2	;NULL
	JSR	PC,@(SP)+	;PUTS 1 CHAR OF ARG 2 INTO B
	BEQ	CSFAL1	;ARG 2 ENDED
	CMPB	D,B	;COMPARE CHARS!!
	BNE	CSFALS
CMPST2:	SWAB	B
	BIC #177600,B
	BEQ	CMPST1	;NULL CHAR
	JSR	PC,@(SP)+	;1 CHAR OF ARG 2 IN B
	BEQ	CSFAL1
	CMPB	D,B	;COMPARE CHARS!!
	BEQ	CMPST1
CSFALS:	TST	(SP)+	;POP CO-ROUTINE LINKAGE
CSFAL1:	CLR	GCP1
	CLR	GCP2
EQFALS:	SEZ
	RTS PC

;ARG 1 HAS ENDED
CMPSTE:	JSR	PC,@(SP)+
	BNE	CSFALS	;BUT ARG 2 HASN'T ENDED
	CLR	GCP1
	CLR	GCP2
EQTRUE:	CLZ
	RTS PC	;BOTH ENDED AT THE SAME TIME!!!!



;CALL WITH B = POINTER TO STRING IN NODE SPACE
;	C = POINTER TO STRING IN DATA SPACE
EQ.TXT:	SPUSH	#INTXT	;ADDRESS OF CO-ROUTINE
	MOV	#7777,E	;AN OFT USED CONSTANT
	BR	CMPSTR



;MORE PREDICATES

GREATR:	JSR PC,CMP2IA
	BGT RTTRUE
RTFALS:
LANGC	<PUSHS #FALSE>,<
	PUSHS #FAUX>
RTNCMP:	CLZ
	RTS PC

LESSP:
LESS:	JSR PC,CMP2IA
	BGE RTFALS
RTTRUE:
LANGC	<PUSHS #TRUE>,<
	PUSHS #VRAI>
	BR RTNCMP

GREQ:	JSR PC,CMP2IA
	BGE RTTRUE
	BR RTFALS

LSEQ:	JSR PC,CMP2IA
	BLE RTTRUE
	BR RTFALS

NUMBP:	POPS B
 	MOV #INUM,A
	JSR	PC,CONVERT
.IFZ FPPF
	BEQ	RTFALS	;COULDN'T CONVERT IT
	BR RTTRUE
.IFF
	BNE RTTRUE
	MOV #FNUM,A
	JSR PC,CONVERT
	BEQ RTFALS
	BR RTTRUE
.ENDC

EMPTYP:	POPS B
	BIT	#7777,B
	BEQ	RTTRUE
	BR	RTFALS

LISTP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTTRUE
	BR	RTFALS

WORDP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTFALS
	BR	RTTRUE

.IFZ FPPF

;COMPARE TWO INTEGER ARGUMENTS
CMP2IA:	JSR	PC,G2IARG
;COMPARE 2 INTEGERS IN B,,C & E,,F
.ENDC
CMP2I:	CMP	E,B
	BNE	CMP2IR	;CONDITION CODES SET CORRECTLY
	CMP	F,C
	BEQ	CMP2IR
	BHI	CMP2IH
;E,,F < B,,C
	CMP	#0,(PC)
	RTS	PC
CMP2IH:	TST	(PC)
CMP2IR:	RTS	PC





.IFNZ FPPF


;GET AND COMPARE TWO (FNUM OR INUM) ARGS


CMP2IA:	SPUSH A
	JSR PC,G2ARG
	SPOP A
	CMPF FB,FA
	CFCC
	RTS PC

INTEGER:
	MOV @S,B
	MOV #INUM,A
	JSR PC,CONVERT
	BNE .+4
	ERROR+WTA
	MOV B,@S
	CLZ
	RTS PC


.ENDC


NOT:	JSR	PC,TSTST	;TEST S SKIP IF TRUE
	BEQ	RTTRUE
	BR	RTFALS

BOTH:	JSR	PC,TSTST
	BNE EITH1
	JSR PC,SPOPT
BOTH1:	BR RTFALS
EITH1:	JSR	PC,TSTST
	BEQ	BOTH1
	BR	RTTRUE	;BOTH ARE "TRUE !!

EITHER:	JSR	PC,TSTST
	BEQ	EITH1	;IS 2ND ONE "TRUE?
	JSR	PC,SPOPT	;POP 2ND ARG
	BR	RTTRUE
TEST:	JSR PC,TSTST	;IS TOP OF S "TRUE"?
	BEQ TES1	;NO, CLEAR FLAG
	BIS #TSTFLG,FLAGS	;YES, SET FLAG
	BR IFR
TES1:	BIC #TSTFLG,FLAGS
	BR IFR
IFTRUE:	BIT #TSTFLG,FLAGS	;FLAG SET?
	BNE IFR	;YES, CONTINUE
IFT1:	CLR CT	;NO, MAKE GNT THINK LINE HAS ENDED
	CLR CT+2
	RTS PC
IFFALS:	BIT #TSTFLG,FLAGS	;FLAG CLEARED?
	BEQ IFR	;YES, CONTINUE
	BR IFT1	;NO STOP
UNTIL:	JSR PC,TSTST
	BNE IFR
	JMP GOUNTL
IF:	INC IFLEV
	JSR PC,TSTST	;TEST S, SKIP IF "TRUE"
	BNE IFR
	CLR NOPAR
	JSR PC,STNE
	BEQ IFR
	BIC #RTF,FLAGS
	DEC IFLEV
IFR:	SEZ
	RTS PC
THEN:	TST IFLEV
	BGT IFR
	ERROR+OOP	;THEN OUT OF PLACE
ELSE:	DEC IFLEV
	BGE .+4
ELSE1:	ERROR+OOP	;ELSE OUT OF PLACE
	CLR NOPAR
	JSR PC,STNE
	BEQ IFR
	TST IFLEV
	BLE ELSE1
	BR IFR
STNE:	;SCAN TOO NEXT ELSE, CR OR UNMATCHED );
	;  SET RTF.  SKIP IIF "ELSE"
	JSR PC,GNT
	CMP #$RPAR,B
	BNE STNE4
	DEC NOPAR
	BGE STNE
	BIS #RTF,FLAGS
	SEZ
	RTS PC
STNE4:	CMP #$LPAR,B
	BNE STNE5
	INC NOPAR
	BR STNE
STNE5:	TST NOPAR
	BGT STNE
	.IFNZ ENG
	CMP #$ELSE,B
	BEQ STNE6
	.ENDC
	.IFNZ FR
	CMP #$SINON,B
	BEQ STNE6
	.ENDC
STNE1:	BIT #CRF,FLAGS
	BEQ STNE2
STNE3:	BIS #RTF,FLAGS	;IF "CR" SET RTF AND RETURN
	BIC #CRF,FLAGS
	SEZ
	RTS PC
STNE6:	BIS #RTF,FLAGS	;IF "ELSE", SET RTF AND SKIP RETURN
	RTS PC
STNE2:	.IFNZ ENG
	CMP #$IF,CT+2	;IF "IF", LOOK FOR NEXT ELSE!
	BEQ STNE7
	.ENDC
	.IFNZ FR
	CMP #$SI,CT+2
	BEQ STNE7
	.ENDC
	BR STNE
STNE7:	JSR PC,STNE
	BEQ STNE3
	BIC #RTF,FLAGS
	BR STNE
TSTST:	.IFNZ ENG
	MOV	@S,B		;TEST S, SKIP IF TRUE
	CMP	B,#FALSE
	BEQ	TSTF9	;IT'S "FALSE
.ENDC
.IFNZ FR
	CMP B,#FAUX
	BEQ TSTF9
.ENDC
.IFNZ ENG
	MOV	#TRUE,C	;ERROR IF NEITHER "TRUE" OR "FALSE"
	JSR	PC,EQUAL1
	BNE TESTIT
.ENDC
.IFNZ FR
	MOV @S,B
	MOV #VRAI,C
	JSR PC,EQUAL1
	BNE TESTIT
.ENDC
.IFNZ ENG
	MOV	@S,B
	MOV	#FALSE,C
	JSR	PC,EQUAL1
	BNE TSTF9
.ENDC
.IFNZ FR
	MOV @S,B
	MOV #FAUX,C
	JSR PC,EQUAL1
	BNE TSTF9
.ENDC
	ERROR+NTF	;NOT "FALSE, EITHER
TSTF9:	JSR	PC,SPOPT
	SEZ
	RTS	PC	;"FALSE!!
TESTIT:	JSR	PC,SPOPT
	CLZ
	RTS PC	;"TRUE!!
REVS:	CMP #1,2(P)	;REVERSES THE TOP ((P)+2) THINGS ON S
	BLT .+4	;IF <2 QUIT
	RTS PC
	CMP #MAXARG,2(P)
	BGE .+4
	.BUG.	;BARF, WHO ASKED REVS TO SWITCH > 32 THINGS?
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV 10.(P),C	;GET # TO BE SWITCHED
REVS5:	MOV S,A	;COMPUTE ADDR OF WORD JUST BEYOND BLOCK
	MOV C,B
	ASL B
	ADD A,B
	CMP #SDLINK,B	;SHOULD WE FORCE A SWAPIN?
	BLO REVS4	;YES
	ASR C
	BEQ REVS1
REVS2:	MOV @A,D
	MOV -(B),(A)+
	MOV D,@B
	DEC C
	BGT REVS2
REVS1:	JMP RETD
REVS4:	JSR PC,SPSWPI	;SWAP S PDL BACK IN
	BR REVS5
.STITL DOUBLE PRECISION INTEGER ARITHMETIC
.IFZ FPPF

;INTEGER MULTIPLICATION

;CALL WITH ONE DOUBLE PRECISION ARGUMENT IN B,,C
;AND THE OTHER IN E,,F
;RETURNS PRODUCT IN E,,F.
;ALL OTHER ACCUMULATORS (INCLUDING B,C ARE UNCHANGED)

.DPMUL:	SPUSH	A	;SAVE A
	CLR	A
DVML:	PUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F
	PUSH B		;STUFF ABS(B,,C)
	SPUSH C
	SPUSH E		;AND ABS(E,,F)
	SPUSH F
	CLR	-(SP)	;A FLAG FOR NEG. ARGS
	TST	B	;MAKE SURE ARGS ARE POSITIVE
	BGE	DVML1
	DPNEG	B,C
	DPNEG 10(P),6(P) ;ALSO ON STACK (FOR DIV)
	COM	(SP)
DVML1:	TST	E
	BGE	DVML2
	DPNEG	E,F
	DPNEG 4(P),2(P)
	COM	(SP)
DVML2:	ADD	A,PC	;CHOOSE BETWEEN MUL AND DIV

;DOUBLE PRECISION MULTIPLY (CONT.)

MUL1:	TST	B	;OVERFLOW UNLESS A1*A2=0
	BEQ	MUL2
	TST	E
	BNE	MDV2	;OVERFLOW!
	EXCH	B,E	;WANT ARG1 TO HAVE ZERO HIGH ORDER PART
	EXCH	C,F
MUL2:	CLR	-(SP)	;SET B1 AND B2
	ASL	C
	BCC	.+6
	MOV	#100000,(SP)	;B2
	ASL	F
	BCC	.+6
	ADD	#200,(SP)	;B1 (ALSO CLEARS CARRY)
	ROR	C	;C2
	ROR	F	;C1
;IF B2*A1>0, THEN OVERFLOW
	TST	(SP)
	BGE	MUL3	;B2=0
	TST	E	;A1
	BNE	MDV1	;OVERFLOW

;DOUBLE PRECISION MULTIPLY (CONT.)

;GET A1*C2*(2**16.)
MUL3:
	MOV C,A		;C2*A1
	MUL E,A
	BCS MDV1	;CARRY INTO A IS OVERFLOW
	MOV B,ANSWER+2	;SINCE A1*C2 IS HIGH ORDER OF ANSWER
;GET C1*C2 AND ADD INTO ANSWER
	MOV C,A		;C1*C2
	MUL F,A
	MOV B,ANSWER	;LOW ORDER PARTIAL PRODUCT
	ADD A,ANSWER+2	;ADDED TO A1*C2
	BVS	MDV1	;OVERFLOW
;GET C2*B1*(2**15.) AND ADD INTO ANSWER
	TSTB	(SP)
	BEQ	MUL35	;B1=0
	CLR A
	MOV C,B		;GET C2
	ASHC #15.,A	;SHIFT C2 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
	ADC	ANSWER+2
	BVS	MDV1
	ADD A,ANSWER+2
	BVS	MDV1
;NOW GET B2*C1*(2**15.) AND ADD INTO ANSWER
MUL35:	TST	(SP)
	BGE	MUL4
	CLR A
	MOV F,B		;GET C1
	ASHC #15.,A	;SHIFT C1 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
	ADC	ANSWER+2
	BVS	MDV1
	ADD A,ANSWER+2
	BVS	MDV1
;NOW GET B1*B2*(2**30.)
MUL4:	CMP	(SP)+,#100200	;ARE BOTH B1 AND B2 SET
	BNE	MUL5	;NO (PRODUCT IS ZERO, OBVIOUSLY)
	ADD	#40000,ANSWER+2	;1*2**30. + ANSWER
	BVS	MDV2	;OVERFLOW
;PUT ANSWER IN THE RIGHT PLACE
MUL5:	MOV	ANSWER+2,E	;HIGH ORDER PARTS
	MOV	ANSWER,F	;LOW ORDER PARTS
	TST	(SP)+	;NEGATIVE?
	BEQ	MUL6
	DPNEG	E,F
MUL6:	ADD #14,SP	;THROW AWAY E,,F, ABS(B,,C) AND ABS(E,,F)
	JMP	SRETD	;BUT RESTORE THE REST

;OVERFLOW EXITS
MDV1:	TST (SP)+	;POP 2 WORDS + ABS'S
MDV2:	ADD #12,SP	;POP 1 WORD + ABS'S
	JMP	RETF	;RESTORE ALL AC'S AND RTS


;DOUBLE PRECISION DIVIDE
;	DIVIDE E,F BY B,C
;RETURN QUOTIENT IN E,F  AND REMAINDER IN B,C
.DPDIV:	SPUSH	A
	MOV	#<DIV1-MUL1>,A	;ADD TO THE PC IN A WHILE
	JMP	DVML	;INITIALIZATION.

DIV1:	TST	B	;IS DEN = 0, 1, OR DOUBLE PRECISION ?
	BNE	DIV2	;DOUBLE PRECISION
	TST	C
	BLT	DIV2	;DOUBLE PRECISION (SINCE TOP BIT WAS SET)
;DEN IS SINGLE PRECISION
	BEQ	MDV2	;DEN=0. OVERFLOW!
	CMP	C,#1	;IS IT 1?
	BNE	SPDEN1	;NO
	CLR	B
	CLR	C
	BR	DIV10
SPDEN1:	JSR	PC,.SPDEN	;DO THE DIVISION
	BR	DIV10

;DEN IS DOUBLE PRECISION
DIV2:	JSR	PC,CMP2I	;IS NUM < DEN
	BGE	DIV5	;NO
;NUM<DEN. QUOTIENT=0. REM=NUM
DIV4:	MOV	E,B
	MOV	F,C
	CLR	E
	CLR	F
	BR	DIV10

;NUM>=DEN.
DIV5:	PUSH B		;SAVE DENOMINATOR
	SPUSH C
	MOV B,A		;MOVE B,,C TO A,,B AND NORMALIZE
	MOV C,B
	CLR SHFCNT
DIV5A:	INC SHFCNT	;COUNT A LEFT SHIFT
	ASHC #1,A
	BVC DIV5A	;UNTIL SIGN BIT CHANGES (OVERFLOW)

	ASHC #-1,A	;UNDO LAST SHIFT
	BIC #100000,A	;AND CLEAR SIGN BIT WHICH WAS SET
	DEC SHFCNT	;UNCOUNT THE LAST SHIFT
	MOV A,C		;DIVIDE BY HIGH-ORDER OF NORMED DIVISOR
	JSR PC,.SPDEN	;E,,F _ (E,,F)/(DIVISOR*2^[N-16.])
	MOV E,A		;MOV (QUOTIENT*2^[16.-N]) TO A,,B
	MOV F,B
	ADD #-16.,SHFCNT	;TIMES 2^[N-16.] IS TRIAL QUOTIENT
	ASHC SHFCNT,A
;GET TRIAL NUM_(TRIAL QUOTIENT-1)*DEN. COMPARE WITH TRUE NUM
	POP F		;E,,F _ SAVED DENOMINATOR
	SPOP E
	MOV B,C		;B,,C _ A,,B (TRIAL QUOTIENT)
	MOV A,B
	SUB	#1,C	;TRY FIRST WITH Q_Q-1
	SBC	B
	BVS	MDV2	;OVERFLOW
	JSR	PC,.DPMUL
	BEQ	MDV2	;MULTIPLY GOT AN ERROR (HMM!)
;COMPARE NUM TO TEM
	MOV	B,ANSWER+2	;SAVE TRIAL QUO
	MOV	C,ANSWER
;GET TEM-NUM
	MOV	SP,D
	TST	(D)+
	SUB	(D)+,F
	SBC	E
	BVS	MDV2
	SUB	(D)+,E
	BVS	MDV2
;TURN INTO NUM-TEM
	DPNEG	E,F
	MOV	E,B
	MOV	F,C
	MOV	(D)+,F	;E,,F_DEN
	MOV	(D)+,E
DIV6:	TST	B	;NUM-TEM
	BEQ	DIV7
	BGT	DIV75
;ANSWER TOO BIG. TRY ANSWER _ ANSWER - 2
	SUB	#2,ANSWER
	SBC	ANSWER+2
	BVS	MDV2
;THIS MAKE TEM _ TEM + 2*DEN
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	BR	DIV6
DIV7:	TST	C
	BEQ	DIV9	;TRIAL QUOTIENT = QUOTIENT !!
;TEM < NUM. EITHER QUOT=QUOT OR QUOT+1
DIV75:	JSR	PC,CMP2I	;IS REM < DEN
	BGT	DIV9	;YES
DIV8:	ADD	#1,ANSWER	;QUOT _ QUOT + 1
	ADC	ANSWER+2
	BVS	MDV2
	SUB	F,C	;REM _ REM - DEN
	SBC	B
	BVS	MDV2
	SUB	E,B
	BVS	MDV2
DIV9:	MOV	ANSWER+2,E
	MOV	ANSWER,F
DIV10:	TST	(SP)+	;NEG. IF ANSWER SHOULD BE NEG.
	BGE	DIV11
	DPNEG	B,C
	DPNEG	E,F
DIV11:	ADD #14,SP	;POP ABS(E,,F), ABS(B,,C) AND E,,F
	POP	D	;RESTORE D
	CMP	(SP)+,(SP)+	;THROW AWAY B & C
	SPOP	A	;RESTORE A
	CLZ
	RTS PC



;SINGLE PRECISION DENOMINATOR. DOUBLE PRECISION NUMERATOR.
;C=DEN. E,F=NUM. RETURNS C_REM, E,F_QUOTIENT
.SPDEN:	SPUSH	A
	SPUSH	B
	ASL	E	;DOUBLE E,,F
	ASL	F
	ADC	E
	MOV E,B		;2E/C
	CLR A
	DIV C,A
	MOV A,E		;2*HIGH-QUOTIENT -> E
	MOV B,A		;(2REM + 2F)/2 /C
	MOV F,B
	ASHC #-1,A
	DIV C,A
	MOV A,F		;LOW-QUOTIENT -> F
	MOV B,C		; REMAINDER -> C
	ASR	E	;HALVE E TO GET PROPER HIGH-QUOTIENT
	BCC	.+6
	BIS #100000,F	;& LOW BIT FROM DOUBLE-E CLOBBERS F'S SIGN BIT
	SPOP	B
	SPOP	A
	RTS	PC
.ENDC


.IFNZ FPPF


;FLOATING DIVIDE AND MULTIPLY FROM REGS B,,C AND E,,F

.DPMUL:	PUSH A
	CLR A	;SET SWITCH
.DPMU1:	FPUSH FA
	FPUSH FB
	SPUSH C
	SPUSH B
	LDCIF (P)+,FA
	SPUSH F
	SPUSH E
	LDCIF (P)+,FB	;LOAD FLOATING REGS
	ADD A,PC	;WHICH ENTRY?
.DPMU5:	MULF FA,FB
	BR .DPMU2
.DPMU6:	LDD FB,FC	;SAVE FB
	DIVF FA,FB
.DPMU2:	STCFI FB,-(P)	;STACK QUOTIENT OR PRODUCT
	BCS .DPERR	;TOO BIG!?
	SPOP E
	SPOP F		;LOAD E,,F
	TST A
	BNE .DPMU4	;BRANCH ON DIVIDE
.DPMU3:	FPOP FB
	FPOP FA
	SPOP A
	CLZ
	RTS PC

.DPMU4:	STCFI FB,-(P)
	LDCIF (P)+,FB	;TRUNCATE QUOTIENT
	MULF FA,FB
	SUBF FB,FC	;GET REMAINDER
	STCFI FC,-(P)
	SPOP B
	SPOP C		;LOAD B,,C WITH REMAINDER
	BR .DPMU3


.DPDIV:	TST C				;DIVIDE ENTRY
	BNE .DPDI1
	TST B				;DON'T DIVIDE BY ZERO
	BEQ .DPERQ
.DPDI1:	PUSH A
	MOV #<.DPMU6-.DPMU5>,A		;SET DIVIDE SWITCH
	BR .DPMU1			;GO DO IT

.DPERR:	CMP (P)+,(P)+			;CLEAR STACK
	FPOP FB
	FPOP FA
	SPOP A
	SEZ
.DPERQ:	RTS PC




.ENDC





	.STITL CONVERSION ROUTINES


;CONVERT
;CALL WITH DESIRED DATA TYPE IN A
;CALL WITH POINTER TO DATA IN B
;IF CONVERSION SUCCEEDS, RETURN POINTER TO CONVERTED DATA IN B AND
;LEAVE A UNCHANGED.
;
;IF CONVERSION FAILS, LEAVE B UNCHANGED,BUT RETURN ITS DATA TYPE IN A

CONVERT:
	MOV	A,-(SP)	;SAVE A,B,C HERE
	MOV	B,-(SP)
	MOV	C,-(SP)

	BIC	#107777,A	;LEAVE DATA TYPE ONLY
	MOV	B,C
	BIC	#107777,C
	ASR	A	;SHIFT DESTINATION DATA TYPE 3 PLACES
	ASR	A
	ASR	A
	BIS	C,A	;SET SOURCE DATA TYPE IN THE 3 VACATED BITS
	ASR	A	;AND PLACE THE ENTIRE MESS IN BOTTOM 6 BITS
	SWAB	A
;(A IS NOW A 6 BIT DISPATCH ADDRESS)
	MOVB	CNVTBL(A),A	;PICK UP ENTRY FROM TABLE
	BIC	#177400,A	;CLEAR TOP BYTE
	ASL	A		;IT IS A BYTE ADDRESS
	JSR	PC,CNVTOP(A)	;RELATIVE TO CONVERT TOP
	BEQ	CONV.F	;THE CONVERSION FAILED
	MOV	(SP)+,C
	TST	(SP)+	;DON'T RESTORE B
	MOV	(SP)+,A
	RTS PC

CONV.F:	MOV	(SP)+,C
	MOV	(SP)+,B
	MOV	B,A
	BIC	#7777,A	;DATA TYPE OF ARG LEFT IN A
	TST	(SP)+	;DON'T RESTORE A
			;FALLS THROUGH

;CONVERT ROUTINE JUMPS TO THE PROGRAMS HERE

CNVTOP==.	;TOP OF CONVERT ROUTINES

;THE ARGUMENT CAN'T BE CONVERTED TO DESIRED DATA TYPE
.CERR:	SEZ
	RTS	PC


CA2LS==<.-CNVTOP>/2
;CONVERT ATOM TO LSTR
.CATLS:	JSR	PC,.LOAD

CNVNOP==<.-CNVTOP>/2
;THE ARGUMENT ALREADY HAS THE DESIRED TYPE
.CNOP:	CLZ
	RTS PC


CSN2IN==<.-CNVTOP>/2
;CONVERT SNUM TO INUM.  ASSUME NUMBER IN B, RATHER THAN POINTER
.CSNIN:	CLR	A
	TST	B	;IS NUM NEGATIVE?
	BGE	.+4
	COM	A	;SET TOP PART TO ALL 1'S
	JSR	PC,GRBAD
	BIS	#INUM,C	;C POINTS TO NEW NODE
	MOV	C,B
	RTS PC

;MORE CONVERSION ROUTINES

CIN2SN==<.-CNVTOP>/2
;CONVERT INUM TO SNUM.  RETURN NUMBER IN B
.CINSN:	JSR	PC,.LOAD
	TST B
	SXT C		;SEE IF B'S SIGN EXTENDED FILLS A.
	CMP A,C
	BNE .CERR
	CLZ
	RTS PC


CSN2LS==<.-CNVTOP>/2
;CONVERT SNUM TO LSTR
.CSNLS:	JSR	PC,.CSNIN	;CONVERT TO INUM FIRST

CIN2LS==<.-CNVTOP>/2
;CONVERT INUM TO LSTR
.CINLS:	SPUSH	D
	SPUSH	E
	SPUSH	F
	JSR	PC,.LOAD	;A,B HAS NUMBER
	JSR	PC,.CINST	;CONVERT TO STRING ON P-PDL
.CINL0:	CLR	F
	MOV	#SSTR,A
.CINL1:	SPOP	B
	BEQ	.CINL2		;0 MARKS END OF DIGITS
	JSR	PC,LISTB	;PUT NEXT 2 CHARS ONTO LIST
	BR	.CINL1
.CINL2:	POPS	B	;POINTER TO FIRST NODE OF ANSWER
	BIC	#170000,B	;CLEAR DATA TYPE
	BIS	#LSTR,B	;REPLACE BY LSTR
	MOV F,C	;GET PTR TO LAST NODE IN STRING

.SRDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
	CLZ
	RTS PC


;GET NEXT CHARACTER IN B
;SKIP UNLESS NO MORE CHARS
.CNXTD:	TST	E	;IS THERE MORE NUMBER LEFT
	BNE	.CNXD1	;YES
	TST	F
	BEQ .CNXD2
.CNXD1:	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPDIV	;C_REM, E,,F_QUO
	BEQ .CNXD2
	ADD	#60,C	;TURN TO ASCII
.CNXD2:	RTS PC


;CONVERT INUM TO STRING ON P-PDL
.CINST:	MOV	(SP),TEM1	;RETURN ADDRESS
	CLR	(SP)
	MOV	#10,D
	MOV	A,E
	BGE	.CINI1	;NUMBER IS POSITIVE
	DPNEG	E,B	;NUMBER IS NEG
	CLR	D	;FLAG
.CINI1:	MOV	 B,F

.CINI2:	JSR	PC,.CNXTD	;GET NEXT DIGIT IN C
	BEQ	.CINI5	;NO MORE CHARS
	SWAB	C
	PUSH	C
	JSR	PC,.CNXTD
	BEQ	.CINI6
	BISB	C,(SP)	;SET NEW CHAR INTO PREVIOUS ONE
	BR	.CINI2

.CINI5:	ADD	D,PC	;NEGATIVE?
	SPUSH	#<55*256.>	;PUSH A MINUS SIGN IN HIGH BYTE
.CINIR:	JMP	@TEM1	;RETURN
	BR	.CINI7

.CINI6:	ADD	D,PC	;NEGATIVE?
	BIS	#55,(SP)	;PUT A MINUS SIGN IN LOW BYTE
	JMP	@TEM1
.CINI7:	TST	(SP)	;WERE ANY CHARACTERS GENERATED?
	BNE	.CINIR	;YES, SO RETURN
	SPUSH	#<60*256.>	;NO, SO PUSH A "0 IN HIGH BYTE
	BR	.CINIR

;MORE CONVERSION ROUTINES


CLS2SN==<.-CNVTOP>/2
;CONVERT LSTR TO SNUM
.CLSSN:	JSR	PC,.CLSIN	;CONVERT TO INUM FIRST
	BEQ .CLNR
	JSR	PC,.CINSN	;THEN CONVERT TO SNUM
.CLNR:	RTS	PC	;FAILED

CLS2IN==<.-CNVTOP>/2
;CONVERT LSTR TO INUM
.CLSIN:	BIT	#7777,B	;IS B EMPTY
	BEQ	.CLNR	;CAN'T CONVERT EMPTY
	PUSH	D
	SPUSH	E
	SPUSH	F
	MOV	B,GCP1	;POINT TO INPUT. (GETS CLEARED AT .RDEF & .SRDEF)
	MOV	B,C
	CLR	E
	CLR	F

.CLSS0:	CLR	-(SP)	;A FLAG
	JSR	PC,INSTR1	;GET FIRST CHAR IN D
	BEQ	.CLSS8	;NO CHARS (HMM)
	CMPB	D,#53	;PLUS
	BEQ	.CLSSA
	CMPB	D,#55	;MINUS
	BNE	.CLSS3	;NOT + OR -
	COM	2(SP)	;-1
.CLSSA:	JSR PC,@(SP)+
	BEQ .CLSS8
	BR .+4
.CLSS1:	JSR	PC,@(SP)+	;GET NEXT CHAR INTO D
	BEQ	.CLSS9	;ALL CHARS GOTTEN
.CLSS3:	SPUSH	C	;SAVE C
	SUB	#60,D	;CONVERT FROM ASCII
	BLT	.CLSS7	;NOT DIGIT
	CMPB	D,#10.
	BGE	.CLSS7	;NOT DIGIT
	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPMUL
	BEQ	.CLSS7	;TOO BIG
	ADD	D,F	;ADD NEXT DIGIT IN
	ADC	E
	BVS	.CLSS7	;OVERFLOW
	SPOP	C
	BR	.CLSS1

;EITHER A NON-DIGIT CHARACTER WAS FOUND, OR ELSE 
;THERE WAS OVERFLOW
.CLSS7:	CMP	(SP)+,(SP)+	;POP OFF C & CO-ROUTINE LINKAGE
.CLSS8:	TST	(SP)+	;POP OFF FLAG
	JMP	.RDEF

;ALL CHARS GOTTEN.  NUMBER IS IN E,,F
.CLSS9:	TST	(SP)+	;BUT SHOULD IT BE NEG?
	BGE	.CLSSR	;NO
	DPNEG	E,F
.CLSSR:	MOV	E,A
	MOV	F,B
	JSR	PC,GRBAD
	BIS	#INUM,C
	MOV	C,B
	JMP	.SRDEF
.IFNZ FPPF


;FLOATING POINT CONVERSION ROUTINES

CSN2FN==<.-CNVTOP>/2
.CSNFN:	SPUSH #.CINFN
	JMP .CSNIN


CIN2FN==<.-CNVTOP>/2
.CINFN:	MOV #INUM,A
	JSR PC,.FLOAD
	STCFD FA,-(P)
RFSTR:	SPOP A
	SPOP B
	JSR PC,GRBAD
	BIS #FNUM,C
	MOV C,B
	CLZ
	RTS PC


CFN2IN==<.-CNVTOP>/2
.CFNIN:	MOV #FNUM,A
	JSR PC,.FLOAD
	ADDF #40000,FA
	CFCC
	BVS .LERR1
	BGE .+6
	SUBF #40200,FA
	STCFI FA,-(P)
	BCS .LERR
	SPOP A
	SPOP B
	JSR PC,GRBAD
	MOV C,B
	BIS #INUM,B
	CLZ
	RTS PC
.LERR:	CMP (P)+,(P)+
.LERR1:	SEZ
	RTS PC


CFN2SN==<.-CNVTOP>/2
.CFNSN:	JSR PC,.CFNIN
	BEQ .LERR1
	JMP .CINSN


CFN2LS==<.-CNVTOP>/2
.CFNLS:	SPUSH D
	SPUSH E
	SPUSH F
	MOV #FNUM,A
	JSR PC,.FLOAD
	JSR PC,.CFNST
	JMP .CINL0




CLS2FN==<.-CNVTOP>/2
.CLSFN:	CLR FNPDL+2
	CLR SEXP
	CLR FNPDL
	STF FA,FE	;STORE FLOATING REGISTERS
	STF FB,FF
	CLRF FB
	BIT #7777,B	;CAN'T CONVERT EMPTY LSTR
	BEQ .FNLR
	PUSH D
	SPUSH E
	SPUSH F
	MOV B,GCP1
	MOV B,C
	CLR E	
	CLR F
CLSS0:	CLR -(P)	;A FLAG FOR THE SIGN OF NUMBER
	JSR PC,INSTR1	;GET FIRST CHAR
	BEQ .FERR	;NO CHARS
	SETI		;TO PREPARE FOR MOVES FROM REGS TO FLOAT REGS
	CMPB D,#53	;IS CHAR A "+?
	BEQ CLSSA
	CMPB D,#55	;IS CHAR A "-?
	BNE CLSS3
	COM 2(P)	;SET NEGATIVE NUMBER FLAG
CLSSA:	JSR PC,@(P)+	;GET NEXT CHAR
	BEQ .FERR	;NO MORE CHAR????
	BR .+4
CLSS1:	JSR PC,@(P)+	;GET NEXT CHAR
	BEQ CLSS9
CLSS3:	SUB #60,D	;CONVERT FROM ASCII
	BLT CLSS7	;IT WASN'T A DIGIT
	CMPB D,#12
	BGE CLSS7	;IT WASN'T A DIGIT
	CLR B
	LDCFD #41040,FA	;CONSTANT 10
	MULF FA,FB
	CFCC
	BVS CLSS8
	LDCIF D,FD
	INC FNPDL+2	;SET SWITCH
	ADDF FD,FB
	CFCC
	BVS CLSS8	;OVERFLOWED A FLOATING REGISTER??????!!!
	ADD E,F
	BR CLSS1	;GET ANOTHER CHAR
CLSS8:	TST (P)+	;DESTROY CO-ROUTINE LINKAGE
	JMP .FERR
CLSS9:	CLR B		;NO EXPONENT
	JMP OKY
CLSS7:	INC FNPDL
	CMPB D,#25	;IS IT "E?
	BEQ GTEXP
	CMPB D,#36	;IS IT "N?
	BEQ GTNEXP
	CMPB D,#177776	;ITS NOT ".!!??
	BNE CLSS8
	TST E
	BNE CLSS8	;THERE WERE TWO ".
	DEC E
	BR CLSS1
.FNLR:	LDF FE,FA	;RESTORE REGS
	LDF FF,FB
	SEZ
	RTS PC
FERR2:	POPS GCP1
	FPOP FB
	FPOP FA
.FERR:	TST (P)+
	LDF FF,FB
	LDF FE,FA
	SETL
	JMP .RDEF
GTNEXP:	DEC SEXP	;SET NEG EXPONENT FLAG
GTEXP:	SETL
	SPOP D		;SAVE CO-ROUTINE LINKAGE
	FPUSH FA
	FPUSH FB
	JSR PC,KL	;GET EXPONENT
	BEQ FERR2
	POPS GCP1
	FPOP FB
	FPOP FA
	SPUSH A
	CLR A
	JSR PC,.LOAD	;GET EXPONENT IN A,,B
	TST A
	BEQ OKAY
	SPOP A		;THE EXPONENT WAS TOO TOO LARGE!!!
	BR .FERR
OKAY:	SPOP A
OKY:	TST FNPDL+2
	BEQ .FERR
	SETL
	TST (P)+	;THE NUMBER IS NEGATIVE?
	BGE OKY1
	NEGF FB
OKY1:	LDCDF #40200,D	;CONSTANT 1
	TST SEXP	;GET FINAL EXPONENT
	BGE .+4		;IS EXP NEGATIVE
	NEG B
	CLR SEXP
	ADD B,F
	TST F		;GET ABSOLUTE VALUE IN F
	BGE LOOP
	DEC SEXP
	NEG F
LOOP:	DEC F		;GET 10 TO THE EXPONENT IN FD
	BLT DONEX
	MULF FA,FD
	CFCC
	BVS .FERR+2	;TO BIG
	BR LOOP
DONEX:	TST SEXP	;IF EXP IS POSITIVE MULTIPLY BY IT
	BLT DIVE	;IF NEG DIVIDE BY IT
	MULF FD,FB	;AND PUT RESULT IN FB
	CFCC
	BVS .FERR+2
	BR FIN
DIVE:	DIVF FD,FB
FIN:	STCFD FB,-(P)
	SPOP A		;GET RESULT IN A,,B
	SPOP B
	JSR PC,GRBAD	;STORE RESULT IN NODE SPACE
	BIS #FNUM,C	;PUT POINTER TO DATA IN B
	MOV C,B
	TST FNPDL
	BEQ .FERR+2
	LDF FF,FB	;RESTORE FLOATING REGS
	LDF FE,FA
	JMP .SRDEF
KL:	SPUSH D		;SHORT FOR KLUDGE.
	SPUSH E		;PREPARE TO FAKE OUT .CLSSA
	SPUSH F		;IT WILL GET US AN EXPONENT
	CLR -(P)	;FAKE A FLAG
	SPUSH D		;RESTORE CO-ROUTINE LINKAGE
	CLR E
	CLR F
	PUSHS GCP1
	JMP .CLSSA	;GET POINTER TO EXPONENT



;CONVERT FROM FNUM TO SSTR ON P-PDL

.CFNST:	SPOP SEXP	;SAVE PC
	CLR -(P)
	MOV #FNPDL+16,D	;INITIALIZE STACK POINTER
	TSTF FA
	CFCC
	BEQ .CFNZE	;ITS ZERO
	BGE .CFNS0
	MOVB #'-,-(D)	;PUT IN A MINUS SIGN
	NEGF FA		;PROCESS SIGN OF FNUM
.CFNS0:	CLR A
  	LDCFD #40200,FB	;CONSTANT 1
	LDCFD #41040,FD	;CONSTANT 10
	CMPF FA,FB
	CFCC
	BLT .CFNS2
.CFNS1:	DIVF FD,FA	;NORMALIZE FA
	INC A		;DIVIDE UNTIL 0<FA<1
	CMPF FA,FB
	CFCC
	BGE .CFNS1
.CFNS2:	MULF FD,FA	;MULTIPLY UNTIL 1<F=FA<10
	DEC A
	CMPF FA,FB
	CFCC
	BLT .CFNS2
	SPUSH #66152
	SPUSH #2657
	SPUSH #33675
	SPUSH #33006
	ADDF (P)+,FA	;ADD .0000005 FOR ROUNDING
	CMPF FA,FD	;9.99999999999999 WILL OVERFLOW
	CFCC
	BLT .+6
	DIVF FD,FA
	INC A		;MAKE IT 1.000 WHEN IT WAS 10.000
	MOV A,FNPDL	;SAVE EXPONENT
	MOV #7,B	;COUNTER FOR SEVEN DIGITS
	SETI
	INC A
	BLT .CFNS3-4	;ITS LESS THAN .1
	CMP #7,A
	BLT .CFNS3-4	;ITS GREATER THAN 10000000.
	INC A
	CLR FNPDL
	BR .CFNS3
	MOV #2,A
.CFNS3:	DEC A		;A COUNTS PLACES TO DECIMAL POINT
	BNE .+6
	MOVB #'.,-(D)	;PUT IN ".
	STCFI FA,C	;GET DIGIT
	LDCIF C,FB
	ADD #'0,C
	MOVB C,-(D)	;STACK CHARACTER
	SUBF FB,FA	;GET FRACTIONAL PART OF NUMBER
	MULF FD,FA
	SOB B,.CFNS3
	DEC A
	BNE .+6
	MOVB #'.,-(D)
	SETL
	CLR A
.CFNS4:	INC A		;COUNT ZEROS POPPED
	CMPB #'0,(D)+
	BEQ .CFNS4	;POP INSIGNIFICANT ZEROS
	DEC D		;RESET POINTER
	MOV FNPDL,B	;RETRIEVE EXPONENT
	BEQ .CFNS6	;NO EXPONENT
	BGT .CFNS5
	ADD B,A
	BGE .CFNS8	;IT NOW FITS DUE TO POPPED ZEROS
	NEG B
	MOVB #'N,-(D)	;STACK "N
	BR .CFNS5+4
.CFNS5:	MOVB #'E,-(D)	;STACK "E
	CLR A
	MOV D,FNPDL	;SAVE POINTER
	JSR PC,.CINST	;REDUCE EXPONENT TO SSTR
	SPOP A
	SPOP B
	MOV FNPDL,D	;RESTORE POINTER
	MOVB A,-(D)	;STACK EXPONENT DIGIT
	BNE .+4
	INC D		;IT WASN'T A DIGIT SO KILL IT
	SWAB A
	MOVB A,-(D)	;GET OTHER DIGIT
.CFNS6:	MOVB (D)+,-(P)	;GET HIGH BYTE
	BEQ .CFNS7	;A ZERO BYTE MEANS ITS DONE
	SWAB (P)
	MOVB (D)+,(P)	;GET ANOTHER BYTE
	BNE .CFNS6	;ZERO BYTE SIGNALS END
	SUB #2,P
.CFNS7:	ADD #2,P	;FIX UP STACK POINTER
	JMP @SEXP
.CFNZE:	SPUSH #"0.	;PUT "0. ON STACK
	JMP @SEXP
.CFNS8:	ADD D,B		;CREATE POINTER
	INC B
	MOV B,C		;SAVE IT
.CFNS9:	MOVB (D)+,(B)+	;SHIFT STACK
	CMPB #'.,-1(B)
	BNE .CFNS9
	MOVB (D),-1(B)	;GET LAST DIGIT
	MOV FNPDL,A
	COM A		;COMPUTE HOW MANY ZEROS ARE TO BE ADDED
.CFN10:	MOVB #'0,(B)+
	SOB A,.CFN10
	MOVB #'.,(B)
	MOV C,D		;RESTORE POINTER
	BR .CFNS6	;I HOPE YOUR HAPPY THAT THE EXPONENT IS GONE


.ENDC




	.STITL GET ARGUMENT ROUTINES

;GET 2 SNUM'S OFF OF S PDL
;RETURN TOP ONE IN A, BOTTOM ONE IN B
G2NARG:	JSR	PC,G1NARG	;NUMBER IN B
	MOV	B,A

;GET 1 SNUM OFF OF S PDL
;RETURN IT IN B
G1NARG:	POPS B
G1NAR1:	MOV	A,-(SP)	;ENTER HERE WITH ARG IN B
	MOV	#SNUM,A
	JSR	PC,CONVERT
G1WTA:	BEQ G1ARG1
	MOV	(SP)+,A
G1RET:	RTS	PC

;GET ONE LIST OR WORD ARG
;SKIP IF WORD
GLWARG:	MOV	@S,B	;DON'T POP ARG.  LEAVE IT GC PROTECTED
GLWAR1:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BNE GSW2
GSW1:	CMP	A,#SENT
	BNE	G1ARG1	;NOT SENTENCE EITHER
	SEZ
GSW2:	RTS	PC

;GET ONE LIST OR WORD.  ERRROR IF EMPTY
GLWANE:	MOV	@S,B
	BIT	#7777,B
	BEQ	G1ARG1
	BR	GLWAR1

;RETURN ONE NUMERIC ARGUMENT
;CALL WITH SNUM IN B
R1INT:	JSR	PC,GETINT
R1NARG:	JSR	PC,.CSNIN	;CONVERT SNUM TO INUM
	JMP ORTB

PSHINT:	JSR	PC,GETINT
;PUSH A NUMBER ONTO THE S-PDL
PSHNUM:	JSR	PC,.CSNIN
	SPUSHS	B
	RTS	PC
.IFZ FPPF


;GET 2 INTEGERS FROM THE S-PDL
G2IARG:	JSR	PC,G1IARG
	MOV	B,E
	MOV	C,F
	JSR	PC,G1IARG
	EXCH	B,E
	EXCH	C,F
ILOAD1:	RTS	PC
G1ARG1:	ERROR+WTAB
.ENDC


;GET 1 INTEGER FROM THE S-PDL
G1IARG:	POPS	B
	SPUSH	A	;SAVE A
	MOV	#INUM,A
	JSR	PC,CONVERT
	BEQ G1ARG1
	JSR	PC,.LOAD	;INTEGER IN A,,B
	MOV	B,C
	MOV	A,B
	SPOP	A
	RTS	PC

.IFZ FPPF


;RETURN 1 INTEGER FROM B,,C
R1I.BC:	MOV	B,A
	MOV	C,B
	BR	R1I.N

;;RETURN 1 INTEGER FROM E,,F
R1I.EF:	MOV	E,A
	MOV	F,B
R1I.N:	JSR	PC,GRBAD
	BIS	#INUM,C
	JMP	ORTC
.ENDC

.IFNZ FPPF

;ROUTINES TO LOAD FLOATING REGS FROM NODESPACE

G2ARG:	MOV #INUM,F
	JSR PC,G1NUM	;GET 1 INTO FA
	BEQ G1ARG1
	LDD FA,FC
	JSR PC,G1NUM	;GET ANOTHER
	BEQ G1ARG1
	LDD FA,FB
	LDD FC,FA	;SWITCH THEM
	RTS PC		;F WILL CONTAIN TYPE EXPECTED OF
			;ARITHMETIC RESULT

;LOAD ONE ARG INTO FA AND ERROR+WTA

G1ARG:	JSR PC,G1NUM
	BNE ILOAD1
G1ARG1:	ERROR+WTAB


;LOAD ONE ARG INTO FA AND CLZ

G1NUM:	POPS B
G1NUMS:	MOV B,A	;IS IT ALREADY AN FNUM?
	BIC #7777,A
	CMP #FNUM,A
	BEQ G1FAG
	MOV #INUM,A
	JSR PC,CONVERT	;TRY TO GET AN INUM
	BNE .FLOAD
G1FARG:	MOV #FNUM,A
	JSR PC,CONVERT	;TRY TO GET A FNUM
	BEQ ILOAD1
G1FAG:	MOV A,F		;SET F TO SHOW FNUM

.FLOAD:	BIC #170000,B
	ASL B
	ASL B
	ADD #NODESP,B
	CMP #INUM,A
	BEQ .ILOAD	;LOAD AN INUM?
	LDCFD (B),FA	;LOAD FNUM
	CLZ
	RTS PC
.ILOAD: LDCIF (B),FA	;LOAD INUM
	CLZ
ILOAD1:	RTS PC


.ENDC




;GET 1 SNAP
;	RETURN POINTER TO SNAP IN D, DELTA X IN E, DELTA Y IN F
G1SNAP:	MOV	@S,C	;POINTER TO ARG
	BIT	#7777,C	;IS IT EMPTY?
	BEQ	ILOAD1	;YES. RETURN WITHOUT SKIPPING


;LOAD 3 NUMBERS
;	GROVEL DOWN A LIST OF NUMBERS RETURNING 3 NUMBERS IN D,E,F
;	CALL WITH C POINTING TO LIST
;	IF LIST CONTAINS 1)NON-NUMBERS OR 2)MORE THAN 3 ELEMENTS,
;	THEN ERROR+WTA
LD3NUM:	PUSH	A
	SPUSH	B
	SPUSH	C
	MOV	#7777,D	;AN OFT USED CONSTANT
	MOV	#3,F	;COUNTER
LDN.L:	BIT	D,C	;IS THERE MORE LIST?
	BEQ	LDN.ER	;ERROR
	JSR	PC,.LOADC	;LOAD A WITH NEXT ELEMENT
	MOV	A,C
.IFNZ FPPF
	CMP #3,F
	BGT LDN.E
.ENDC
	MOV	#SNUM,A
	JSR	PC,CONVERT
	BEQ LDN.ER
LDN.E:	SPUSH	B	;PUSH THIS ELEMENT
	SOB F,LDN.L
	BIT	D,C	;IS THE LIST FINISHED?
	BNE	LDN.ER	;NO. ERROR
	JMP	SRETF	;SKIP RETURN AND RESTORE ALL AC'S!

LDN.ER:	ERROR+WTA
	.STITL EVAL

EVAL:	JSR PC,GNT	;GET NEXT TOKEN, RETURNED IN A
	JSR PC,STRACE	;CHECK FOR SYSTEM TRACE
	BIC #DPQF+CPTBF,FLAGS2	;DON'T PRINT QUOTE, CHANGE % TO BLANK
	BIC #7777,A
	CMP A,#UFUN	;USER FUNCTION?
	BLOS EVFUN
	CMP A,#UVAR	;USER VARIABLE?
	BEQ EVVAR
	CMP A,#SSTR
	BHI .+4
EVWHAT:	.BUG.
	CMP A,#ATOM
	BEQ EVATM
	CMP A,#SNUM	;INTEGER?
	BEQ EVWHAT
.IIF Z FPPF,	CMP A,#LSTR
.IIF NZ FPPF,	CMP A,#FNUM
	BLOS EVCON
	CMP A,#LIST
	BNE EVWHAT
EVCON:
EVATM:	PUSHS CT+2	;SAVE ON S-PDL FOR OUTPUT
	BR EVI
EVVAR:	BIC #170000,B
	BIS #ATOM,B
	MOV B,D		;SAVE UOE PTR FOR ERROR
	JSR PC,.BINDL
	BEQ EVVAR2	;NO BINDING FOUND
	TST B		;NIL?
	BNE EVVAR1	;NO, GOOD
	MOV D,B
EVVAR2:	ERROR+HNV	;... HAS NO VALUE
EVVAR1:	PUSHS B		;SAVE IT FOR OUTPUT
EVI:	JSR PC,GNT	;ABOUT TO OUTPUT A VALUE.
			;BEFORE WE DO, CHECK TO SEE IF
			;NEXT TOKEN IS INFIX WHICH SHOULD GOBBLE IT.
	BIC #7777,A	;IS NEXT TOKEN INFIX?
	CMP #INFIX,A
	BEQ CKPRCD	;YES
EVI1:	BIS #RTF,FLAGS	;SET REPEAT TOKEN FLAG
	BIC #CRF,FLAGS	;CLEAR CARRIAGE RETURN TOKEN FLAG
	CLZ
	RTS PC
CKPRCD:	TST CO+2	;COMPARE PRECEDENCE
	BEQ EVI2
	MOV CT+2,A
	ASL A
	MOV SOBLST(A),A	;SYSTEM OBLIST ELEMENT (NEXT OPER.)
	BIC #7777,A
	MOV COF,B	;CURRENT OPERATOR FLAG
	BIC #7777,B
	CMP A,B		;IS PRECD OF CO >= PRECD NEXT OPER
	BLO EVI1	;YES, > - GIVE OUTPUT TO CO
	BEQ EVI4	;YES, = - CHECK FOR _
		;NO - NEXT TOKEN SHOULD GOBBLE THIS OUTPUT
EVI2:	JSR PC,STRACE
EVI12:	CMP #$BKAR,CT+2	;CHECK FOR SUCCESSIVE _'S
	BNE EVI3		;   "A _"B _0
	CMP #$BKAR,CO+2
	BEQ EVI13
	CMP #$TBKAR,CO+2
	BNE EVI3
EVI13:	MOV #$TBKAR,CT+2
EVI3:	PUSH CO
	SPUSH CO+2
	SPUSH NOR	;NO. OF OPERANDS STILL NEEDED
	MOV CT,CO
	MOV CT+2,CO+2
	MOV CO+2,A	;GET FLAGS
	ASL A
	MOV SOBLST(A),COF	;SET CURRENT OPERATOR FLAG
	MOV #1,NOR
	JMP EVW		;CALLS EVAL
EVI4:	CMP #$BKAR,CT+2	;PRECD ARE = - IF _ DO RIGHT ONE FIRST
	BEQ EVI2	;IT IS _
	BR EVI1
EVFUN:	BIT #CRF,FLAGS	;CT IS A FUNCTION
	BEQ .+4
	ERROR+UELX	;UNEXPECTED END OF LINE
	CMP #$LPAR,CT+2	;IS NEXT TOKEN A LEFT PAREN?
	BNE EVF1
	TST CO+2	;NEXT OPERATOR?
	BEQ EVF11	;NOTHING THERE
.IFNZ ENG
	CMP #$DO,CO+2	;IS NEXT OPERATOR A RUN COMMAND?
	BEQ EVF11
.ENDC
.IFNZ FR
	CMP #$EXECUT,CO+2
	BEQ EVF11
.ENDC
	CMP #$LLPAR,CO+2
	BNE EVF1
EVF11:	MOV #$LLPAR,CT+2	;INSERT PARENS.FOR PARSE
EVF1:	PUSH CO
	SPUSH CO+2
	SPUSH NOR	;NO. OF ARGS NEEDED FOR CO'S EXECUTION
	CMP #$LLPAR,CO+2	;IF CO IS !(, PUSH IFLEV INSTEAD OF NOR
	BNE EVF13
	MOV IFLEV,(P)
	CLR IFLEV
EVF13:	MOV CT,CO
	MOV CT+2,CO+2
	BIC #EDTIF2,FLAGS
EVF2:	CMP A,#UFUN	;IS POPPED OPER. A  USER FUNCTION?
	BLO MFUN	;NO, MACHINE
	MOV #<PREPRI_13.>,COF	;SET PRECD TO PREPRI
	JSR PC,GNASN	;GET NO. OF ARGS IN B
	BNE .+4
	ERROR+HNM	;... HAS NO MEANING
	MOVB B,B	;CLEAR ANY LEFT HALF FLAGS
	MOV B,NOR
	BEQ .+6
	JMP EVL1

EVXP:	JSR PC,STRACS	;NO MORE, SPACE AND CHECK FOR SYSTEM TRACE
	JSR PC,PEVAL	;SET TO EVALUATE THIS USER PROCEDURE
	BEQ XNORT	;PEVAL DOES SEZ  IF THERE IS NO OUTPUT
	JMP XORT		;DOES CLZ IF THERE IS
MFUN:	MOV CO+2,A	;GET FLAGS FOR THIS MACHINE PROCEDURE
	ASL A
	MOV SOBLST(A),A
	MOV A,COF
	SWAB A
	BIC #177774,A	;FIND NO. OF ARGS. NECESSARY
	MOV A,NOR
	BNE EVS		;IS  NO. ARGS = 0? (BRANCH IF NO)
	BIT #PTLPF,FLAGS
	BEQ EVXM
	BIT #VNAF,COF
	BNE EVL
EVXM:	JMP MEVAL	;YES.  EXECUTE THIS MACHINE PROCEDURE

XNORT:	BIC #EDTIF,FLAGS
	BIT #EDTIF2,FLAGS
	BEQ .+10
	BIS #EDTIF,FLAGS
NORT0:	MOV #EVDNO,A	;SET RETURN TO INDICATE NO OUTPUT
NORT1:	MOV CO+2,LO+2	;UPDATE OPERATORS
	MOV CO,LO
	POP NOR
	SPOP B
	MOV B,CO+2
	SPOP CO
	CMP #$LLPAR,B	;IF POPPED OPER IS !(, IFLEV_NOR, NOR_1	
	BNE NORT3
	MOV NOR,IFLEV
	MOV #1,NOR
NORT3:	CLR COF
	TST B
	BEQ NORT2	;NO MORE OPERATORS
	BIT #160000,CO	;IS IT A UFUN
	BNE NORT2	;YES
	ASL B		;NO, MUST BE A PRIMITIVE. GET OFFSET IN BYTES
	MOV SOBLST(B),COF
NORT2:	JMP @A		;RETURN DEPENDS ON WHETHER OUTPUT EXISTS
EVDNO:	SEZ
	RTS PC
EVS:	BIT COF,#INFIX	;IS CO INFIX OP
	BEQ EVL		;NO
	JSR PC,CKUI	;CHECK FOR VALID UNARY INFIX +,-
	BNE EVW
	ERROR+INF1	;INFIX IN WRONG PLACE
PROC:	MOV @S,B	;THE WORD
	BIT #7777,B	;IS IT THE EMPTY WORD
	BNE .+4
	ERROR+WTA
	JSR PC,GUOEB	;PEVAL INVOKED VIA "#"
	BEQ PROC1
	MOV B,@P	;OLD RETURN - POPPED LATER
	JSR PC,.BINDF	;IS A PROC DEFINED
	BEQ PROC3	;NO
	MOV #UFUN,CO	;YES
	MOV @P,B
PROC2:	CLR TOPS
	MOV B,CO+2
	SPOP B		;GET P BACK IN PHASE
	JMP EVF2
PROC3:	JSR PC,.LOAD	;GET PNAME FOR UOBSCH
PROC1:	MOV B,TOPS
	MOV #SFUN,A
	JSR PC,UOBSCH	;MAKE SURE CO EXISTS
	BNE .+4
	ERROR+HNM	;HAS NO MEANING
	MOV A,CO
	BR PROC2

EVL:	BIT #PTLPF,FLAGS	;WAS PREVIOUS TOKEN A LEFT PAREN
	BEQ EVL1		;NO
	BIT #VNAF,COF	;DOES CO USE VARIABLE NO. OF ARGS.?
	BEQ EVL1	;NO
	CLR NOR
	BR EVW9
EVL1:	JSR PC,GNT
EVW1:	BIS #RTF,FLAGS	;SET REPEAT TOKEN FLAG
	BIC #CRF,FLAGS
EVW:	JSR PC,EVAL	;EVALUATE THIS ARGUMENT
	BEQ EVW2	;NO OUTPUT FROM EVAL
	DEC NOR
	BEQ EVX		;WHEN NOR = 0, WE'VE ENUF INPUTS
EVW9:	JSR PC,GNT
	TST NOR		;IF NOR < 0 AND NEXT TOKEN IS ")" THEN THE ")" 
	BGT EVW1	;TERMINATES THE ARG SCAN FOR THE CO
	CMP #$RPAR,CT+2  ;IS IT?
	BNE EVW1	;NO
	BIS #RTF,FLAGS
	BIC #CRF,FLAGS
	NEG NOR
	CMP #MAXARG,NOR
	BGE MEVALN	;EXECUTE MACHINE PROC.
	ERROR+TMAC	;TOO MANY ARGS COMMAND/OPERATION
EVX:	BIT #160000,CO	;IS IT A MACHINE PROCEDURE
	BEQ .+6
	JMP EVXP	;NO
	BIT #VNAF,COF	;MACHINE PROC NOW HAS ITS "STD" NO. OF ARGS.
		;IF IT CAN TAKE A VARIABLE NO., THEN THE "STD" NO. HAS
		;BE PUSHED ON P
	BEQ MEVAL	;IT DOESN'T- GO EVALUATE IT
	MOV COF,A
	SWAB A
	BIC #177774,A
	MOV A,NOR
	BR MEVALN	;SAME AS MEVAL BUT SAVES NO. OF ARGS
EVW2:	CMP #$LLPAR,CO+2	;EVAL SHOULD OUTPUT WHEN NOT AT TOP LEVEL
	BEQ EVW		;EXCEPT WHEN CO IS LLPAR
	ERROR+NOU	;WHAT, NO OUTPUT??!!

LLPAR:
LPAR:	JSR PC,GNT
	CMP #$RPAR,CT+2
	BEQ LPAR1
	ERROR+TIP	;TOO MUCH INSIDE PARENS
LPAR1:	CLZ
	RTS PC

RPAR:	BIT #PTLPF,FLAGS
	BEQ .+4
	ERROR+NIP	;NOTHING INSIDE PARENS
	CMP 4(P),#$LLPAR	;IS PENDING COMMAND !(
	BNE RPAR1
RPAR2:	POP A
	MOV (P),IFLEV
	ADD #6,P	;POP !( OFF STACK
	MOV A,(P)
	SEZ
	RTS PC

RPAR1:	ERROR+ERP	;EXTRA RIGHT PAREN
CKUI:	PUSH A
	MOV CO+2,A
	CMP A,#$PLUS	;+
	BNE CKUI1
	MOV #$UPLUS,A
CKUI0:	MOV A,CO+2
	ASL A
	MOV SOBLST(A),COF
	MOV #1,NOR
	JMP SRETA

CKUI1:	CMP A,#$MINUS	;-
	BNE CKUI2
	MOV #$UMINS,A
	BR CKUI0

CKUI2:	POP A
	RTS PC

MEVALN:	PUSH NOR
MEVAL:	JSR PC,STRACS
	MOV CO+2,A	;GET SOE POINTER
	CLR NBKTS
	ASL A
	JSR PC,@2+SOBLST(A)	;JMP ADDR IS IN 2ND WORD
	BNE XORT	;PROCEDUE OUTPUTS
	JMP XNORT	;NO OUTPUT
XORT:	MOV #EVI,A
	JMP NORT1

ORTNA:	MOV A,@S
	BR SRET
ORTNB:	MOV B,@S
	BR SRET
ORTNC:	MOV C,@S
	BR SRET
ORTND:	MOV D,@S
	BR SRET
ORTNE:	MOV E,@S
	BR SRET
ORTNF:	MOV F,@S
	BR SRET
ORTNP:	MOV	(SP)+,@S
	BR SRET


ORTA:	PUSHS A
	BR SRET
ORTB:	PUSHS B
	BR SRET
ORTC:	PUSHS C
	BR SRET
ORTD:	PUSHS D
	BR SRET
ORTE:	PUSHS E
	BR SRET
ORTF:	PUSHS F
	BR SRET
ORTP==.
ORTSP:	PUSHS	(SP)+

RETF:	POP F
	BR RETE1
RETE:	POP E
	BR RETD1
RETD:	POP D
	BR RETC1
RETC:	POP C
	BR RETB1
RETB:	POP B
	BR RETA1
RETA:	POP A
	SEZ
	RTS PC

RETF1:	SPOP F
RETE1:	SPOP E
RETD1:	SPOP D
RETC1:	SPOP C
RETB1:	SPOP B
RETA1:	SPOP A
RET:	SEZ
	RTS PC

SRETF:	POP F
	BR SRETE1
SRETE:	POP E
	BR SRETD1
SRETD:	POP D
	BR SRETC1
SRETC:	POP C
	BR SRETB1
SRETB:	POP B
	BR SRETA1
SRETA:	POP A	;POP A THEN DO CLZ RETURN
	BR SRET

SRETE1:	SPOP E
SRETD1:	SPOP D
SRETC1:	SPOP C
SRETB1:	SPOP B
SRETA1:	SPOP A	;POP A THEN DO CLZ RETURN
CKTYP:
SRET:	CLZ
	RTS PC
	.STITL PROCEDURE EVALUATOR
PEVAL:	JSR PC,CKSTG	;CHECK STORAGE
	MOV CO+2,B	;FIRST CHECK IF PROC IS THERE
	JSR PC,.BINDF	;GET BINDING
	BNE .+4
	ERROR+HNM	;PROCEDURE HAS NO MEANING
	JSR PC,SAVEVL	;SAVE ALL PROCEDURE INFORMATION

	;GET ARG LIST - PUT UOE POINTERS AND VALUES FROM THERE ON S
	MOV A,C		;SAVE PTR TO LLP (LIST OF LINEPTRS)
	JSR PC,.LOAD	;GET FLAGS,,#ARGS
	MOV B,FLAGS
	MOVB B,B
	SPUSH B		;PUSH # ARGS
	BIC #-<TPTF+TPSF>-1,FLAGS  ;CLEAR ALL BUT TRACE AND STEP FLAGS
	BNE PEV3
	BIT #TRACEF,FLAGS2	;IS TRACE SET?
	BEQ PEV6	;NO
PEV3:	MOV CO+2,B
	INC FUNLEV
	JSR PC,TINDNT	;SET SPACING ACCORDING TO FUNCTION LEVEL
	DEC FUNLEV
LANGC	<JSR PC,PPNAME	;PRINT PROCEDURE NAME
	PRTXT ^\'S INPUTS: \>,<
	PRTXT ^/LES INPUTS DE /
	JSR PC,PPNAME
	PRTXT ^/ SONT:/>
	MOV @P,B	;# OF ARGS
PEV6:	SPUSH C		;SAVE FOR BELOW (POINTS TO LASTLINEPTR)
	MOV B,D		;NO. OF ARGS
	BEQ PEV2	;NO ARGS
.IFNZ SWAPF
	JSR PC,.LOADC
	JSR PC,.LOAD
.ENDC
	SPUSH A		;SAVE PTR TO REST OF TITLE LINE
	CMP #SPUSHL,S	;ENOUGH ROOM ON S-PDL?
	BLOS .+6	;OK
	JSR PC,SPSWPO	;SWAP OUT S-PDL
	MOV D,B		;# OF ARGS
	ASL B		;MULTIPLY BY TWO FOR OFFSET
	MOV S,D
	MOV D,E
	SUB B,E
	MOV E,S
	ASR B
PEV7:	MOV (D)+,(E)+	;GET ARGS ON TOP OF STACK
	SOB B,PEV7
	MOV @P,A	;GET SAVED LLP PTR
PEV1:	TST FLAGS
	BNE PEV4	;TRACE IS SET
	BIT #TRACEF,FLAGS2
	BEQ PEV5	;NO TRACE
PEV4:	MOV -2(E),B	;TOP ARGUMENT
	MOV B,A
	INC NBKTS
	SPUSH D
	JSR PC,PRTAB	;PRINT TOKEN IN A,,B
	DEC NBKTS
	SPOP D
	MOV @P,A	;POINTER TO ARG ON TOP OF SATCK
PEV5:	JSR PC,.LOADA	;GET THE ARG
	MOV A,@P	;PTR. TO NEXT NODE
	CMP #$COMT,B	;IS CURRENT NODE A COMMENT?
	BNE PEV10
PEV12:	BIT #7777,A	;END OF ARGUMENT?
	BEQ PEV11	;YES
	JSR PC,.LOADA
	CMP #$COMT,B
	BNE PEV12
	BR PEV5
PEV10:	JSR PC,SAVVAR	;SAVE THIS VARIABLE BINDING
	MOV @P,A
	BIT #7777,A
	BEQ PEV11
	TST FLAGS
	BNE PEV10A
	BIT #TRACEF,FLAGS2
	BEQ PEV1
PEV10A:	PRTXT ^/,/
	BR PEV1		;GO DO NEXT ARG

PEV11:	SPOP C		;USED TITLE LINE POINTER
PEV2:	SPOP C		;PTR TO LLP THAT WAS PUSHED WAY ABOVE
	TST FLAGS
	BNE PEV2A	;TRACE SET
	BIT #TRACEF,FLAGS2
	BEQ PEV2B	;NO TRACE
PEV2A:	PRCR
PEV2B:	JSR PC,SAVPPS	;SAVE PDL PTRS
	BIS #1,CPDLP	;INDICATES PROC PUSH AS OPPOSED TO A LOCAL PUSH
	MOV CO+2,B
	CLR CPLN
	MOV C,CLP
	MOV B,CPP	;GET CPSN IN A
.IFNZ SWAPF
	JSR PC,GNASN
	MOV A,CPSN
.ENDC
	CLR CO
	CLR CO+2
	CLR IFLEV
	INC FUNLEV
	JMP MLOOP
SAVVAR:	;SAVE IN (D) VARIABLE BINDING OF UOE PT'ED TO BY B
		;GIVE IT NEW VALUE WHICH IS AT (E)
		;USES A,C.  TOPS MUST BE 0
		;BOTH D AND E ARE -()ED
	MOV B,-(D)	;SAVE UOE PTR
	MOV #VBIND,A	;THIS WILL CHECK SPDL THINGS--
			;NOP IT IF IT SEEMS TO CAUSE TROUBLE.  RWW
	JSR PC,.BINDL	;NOW GET VARIB. BINDING
	BEQ SAVV2	;NOT THERE
SAVV1:	MOV -(E),A	;GET NEW VALUE PTR
	MOV B,-(D)	;SAVE OLD VALUE PO[NTER
	MOV A,B
	JSR PC,.LDP1
	BIC #100000,A	;MAKE SURE BINDING NODE SAYS "VBIND"
	JSR PC,.STORE	;STORE NEW BINDING AWAY
	RTS PC

SAVV3:	TST -(E)
	CLR -(D)	;THERE IS NO OLD VALUE POINTER
	RTS PC

SAVV2:	TST -2(E)
	BEQ SAVV3	;IF NEW VALUE = 0, DON'T BOTHER TO CREATE CELL
	MOV #VBIND,A
	CLR B
	JSR PC,GRBAD1
	BR SAVV1

SAVPPS:	POP F	;SAVE P AND S PDL PTRS
	SPUSH CSPDLP
	MOV #SDLINK,A	;COMPUTE RELATIVE S PDL PTR
	SUB S,A		;CURRENT TOP OF S-PDL
	ADD SPRBAO,A	;# OF PDL BLOCKS SWAPPED OUT
	MOV A,CSPDLP
	SPUSH CPDLP
	MOV #PDLINK,A	;COMPUTE RELATIVE P PDL PTR
	SUB P,A
	ADD PRBAO,A
	MOV A,CPDLP
	JMP @F

TINDNT:	PUSH A	;TRACE INDENT
	MOV FUNLEV,A
TIND2:	DEC A
	BGT TIND1
	JMP RETA
TIND1:	SPACE
	BR TIND2
LOCAL:	JSR PC,GUOEB	;GET UOE PTR FROM S
LOC9:	MOV #SDLINK,F	;MOVE STUFF FROM S TO P PDLS
	SUB S,F
	ADD SPRBAO,F
	MOV CSPDLP,D
	BIC #1,D
	SUB D,F
	ASR F
	MOV F,A
	BLE LOC2
LOC1:	POPS D
	PUSH D
	DEC A
	BGT LOC1
LOC2:	MOV S,D	;NOW STORE AWAY PTR & OLD VALUE
	PUSHS #0
	MOV S,E
	PUSHS #0
	JSR PC,SAVVAR
	MOV F,A	;NOW RETURN STUFF FROM P TO S
	BLE LOC4
LOC3:	POP D
	PUSHS D
	DEC A
	BGT LOC3
LOC4:	MOV #PDLINK,A	;NOW MOVE STUFF FROM P TO S
	SUB P,A
	ADD PRBAO,A
	MOV CPDLP,D
	BIC #1,D
	SUB D,A
	ASR A
	MOV A,F
	BLE LOC6
LOC5:	POP D
	PUSHS D
	DEC A
	BGT LOC5
LOC6:	PUSH #1	;PUSH GOODIES ON P
	SPUSH CSPDLP
	SPUSH CPDLP
	BIC #1,CPDLP	;INDICATE LOCAL PUSH
	BIC #1,CSPDLP
	ADD #4,CSPDLP
	ADD #6,CPDLP
	MOV F,A
	BLE LOC8
LOC7:	POPS D	;NOW RETURN STUFF TO P
	PUSH D
	DEC A
	BGT LOC7
LOC8:	SEZ
	RTS PC


;CHECK (E) FOR VALID DATA TYPE IF CHEKUF ON
CKSARG:	BIT #CHEKUF,FLAGS2
	BNE .+4
	RTS PC

	SPUSH D		;D & E ARE USED
	SPUSH E
	MOV #CKLIST,D	;THIS RUNS THROUGH THE VALID TYPES
	MOV (E),E	;GET THE DATUM
	BIC #7777,E	;ITS TYPE
CKSAR1:	CMP (D)+,E	;IS THIS A VALID TYPE?
	BEQ CKSRET	;AHA! IS!
	TST (D)		;MORE VALID TYPES?
	BNE CKSAR1	;THERE ARE
	.BUG.		;THERE AIN'T--*DIE*

CKSRET:	SPOP E		;WELL AND GOOD--IT'S VALID.
	SPOP D
	RTS PC

.STITL PROC EVAL - "OUTPUT" "STOP"
OUTPUT:	TST FUNLEV
	BGT .+4
OUTPU1:	ERROR+OIP	;ONLY IN PROCEDURE
	MOV #SRET,PSTOPR ;"OUTPUT" (CLZ FOR RETURN)
	POPS TOPS1	;SAVE THE OUTPUT
	BR PSTP10
STOP:
PSTOP:	TST FUNLEV
	BLE OUTPU1
	MOV #RET,PSTOPR	;"STOP" AND "END" (SEZ FOR RETURN)
	CLR TOPS1
	MOV #PSTP15,ERFRET	;RETURN ADDRESS FROM ERROR SET FRAME
PSTP10:	MOV #PSTP18,DOFRET	;SAME FOR DO FRAME
	BIT #DORF,FLAGS		;IS THIS A DO OR READ FRAME?
	BEQ PSTP12	;NO
PSTP14:	JSR PC,RESPPS	;RESTORE PDLS
	POP B		;RETURN ADDRESS
	BIT #TF7,TFLAGS	;IS THIS AN ERROR SET FRAME?
	BEQ PSTP16	;NO
	MOV B,ERPROC
	BR PSTP14
PSTP16:	JSR PC,RESEVL	;RESTORE PROCEDURE VARIABLES
	MOV B,FLAGS
	BR PSTP10
PSTP12:	BIT #TPTF+TPSF,FLAGS	;STEP OR TRACE FLAGS SET?
	BNE PSTP11	;YES
	BIT #TRACEF,FLAGS2
	BEQ PSTP15	;NO TRACE
PSTP11:	JSR PC,TINDNT
	MOV CPP,B
	JSR PC,PPNAME
	MOV TOPS1,B
	BEQ PSTP13
	PRTXT ^\ OUTPUTS \
	INC NBKTS
	JSR PC,PNODAB	;USES A (PRINTS OUT OBJECT ON S AS STRING)
	DEC NBKTS
	PRCR
	BR PSTP15
PSTP13:	LANGC <PRTXTC ^\ STOPS.\>,<
	PRTXTC ^/ STOPPE./>
PSTP15:	JSR PC,RESPPS	;RESTORE PDLS
	BIT #TF7,TFLAGS	;IF IT WAS AN ERROR SET FRAME, GO TO @ERFRET
	BEQ PSTP21	;IT WASN'T
	POP ERPROC
	JMP @ERFRET
PSTP21:
	SPOP D	;# ARGS SAVED
	BEQ PSTOP4	;NO ARGS
PSTOP3:	POPS E		;GET OLD VARIBLE BINDING
	SPOPS B		;GET NEXT UOE PTR
	MOV #VBIND,A
	TST E		;IS OLD BINDING NIL?
	BNE PSTP31	;NO
	JSR PC,.UNBND	;YES, GET RID OF IT
	BR PSTP33
PSTP31:	JSR PC,.BINDL	;GET VARIB BINDING PTR
	BEQ PSTPE3	;NONE THERE
	MOV E,B		;GET OLD VARIB BINDING
	JSR PC,.STORE	;RESTORE OLD BINDING
PSTP33:	DEC D		;ONE LESS ARG
	BGT PSTOP3	;GET NEXT BINDING IF MORE LEFT
PSTOP4:	BIT #TF3,TFLAGS	;WAS IT A LOCAL PUSH OR PROC PUSH
	BEQ PSTP15	;LOCAL
	CMP #SRET,PSTOPR	;WAS IT "OUTPUT"
	BNE PSTP42	;NO
	PUSHS TOPS1	;PUT THE OUTPUT BACK ON S
	CLR TOPS
	CLR TOPS1
PSTP42:	BIT #DORF,FLAGS	;DO OR READ FRAME?
	BNE PSTP45	;YES
	DEC FUNLEV	;UP ONE LEVEL
PSTP45:
	JSR PC,RESEVL
	MOV B,FLAGS
	BIT #DORF,FLAGS
	BEQ .+6
	JMP @DOFRET
PSTP18:	TST FUNLEV	;IF AT TOP LEVEL, ALMOST DONE!
	BLE PSTOP9	;IT IS
PSTP43:	MOV CPP,B
	JSR PC,.BINDF	;MAKE SURE PROC IS IN
	BEQ PSTPE2	;PROCEDURE ... NOT HERE
.IFNZ SWAPF
	MOV CPP,B	;SEE IF PROC'S CPSN AGREE
	JSR PC,GNASN	;GET CPSN
	BEQ PSTPE3	;IMPOSSIBLE!!!
.ENDC
	MOV CLP,C
	BIS #TF3,TFLAGS
.IFNZ SWAPF
	CMP A,CPSN
	BEQ PSTP41	;OK
	BIC #TF3,TFLAGS
	MOV CPLN,B	;DON'T AGREE, GO RELOCATE LINE WE WERE IN
	JSR PC,GTLINE
	BEQ PSTPE4	;LINE NOT THERE
.ENDC
PSTP41:	MOV C,CLP
	JSR PC,.LOADC	;GET LLP NODE
	JSR PC,.LOAD	;GET LINE #
	MOV A,C
	JSR PC,.LOADC	;GET NEXT NODE-SEE IF SNUM (I.E. GEN NO.)
	BIC #7777,A
	CMP #SNUM,A
	BEQ .+4
	CLR B	;NOT SNUM, SO SET GEN NO. TO 0
	CMP B,CLGN	;ARE GEN #'S =?
	BNE PSTPE4
	BIT #TF3,TFLAGS	;IF PROC WASNT SWAPPED
	BEQ PSTOP8	;THEN CTP IS GOOD
PSTOP9:	CLR D
	MOV CTP,C
	BR PSTOP6
PSTOP8:	MOV CTN,D	;OK, NOW GET NODE NO.
	TST B	;IF B > 0, WE WERE LOOKING GEN NO.
	BEQ PSTOP6
	JSR PC,.LDP1
PSTOP7:	MOV A,C
PSTOP6:	JSR PC,.LOADC
	DEC D
	BGT PSTOP7
	MOV C,CTP
	MOV A,CT
	MOV B,CT+2
	JMP @PSTOPR
PSTPE2:	JSR PC,CHKER
	ERROR+PNH1	;POPPED PROCEDURE NOT HERE
PSTPE3:	JSR PC,CHKER
	.BUG.		;PROCEDURE STRUCTURE SCREWED
PSTPE4:	JSR PC,CHKER
	ERROR+LCE	;LINE CHANGED BY EDIT

RESPPS:	SPOP E	;RESTORE P AND S PDLS
	MOV CPDLP,A
	BIC #TF3+TF7,TFLAGS ;SAVE MODE OF PROC/LOCAL PUSH FLAG
	BIT #1,A
	BEQ .+10
	BIS #TF3,TFLAGS	;SET PROCEDURE PUSH FLAG
	BIC #1,A	;ALWAYS EVEN
	JSR PC,PPTA	;POP P TO (A)
	POP CPDLP	 ;RESTORE OLD CPDLP
	MOV CSPDLP,A
	BIT #1,A
	BEQ .+10
	BIS #TF7,TFLAGS	;ERROR SET FLAG
	BIC #1,A
	JSR PC,PSTA	;POP S TO (A)
	SPOP CSPDLP	;RESTORE OLD CSPDLP
	JMP @E

CHKER:	BIT #HERRF,FLAGS2  ;THIS IS A TERRIBLE THING TO HAPPEN
	BNE CKHER1	;AND IT'S HAPPENED BEFORE!
	BIS #HERRF,FLAGS2  ;OR IF NOT, "DON'T LET IT HAPPEN AGAIN!"
	RTS PC
CKHER1:	CPRTXT ^/HELP!!  RECURSIVE BUG!/
	JSR PC,PPLACE
	CLR CPP
	CLR FUNLEV
	CLR IFLEV
	CLR FLAGS
	JMP ERTL3	;CLEAN UP THE WORLD

DO:	MOV @S,A	;DO...(RUN)
	MOV A,B
	BIC #7777,A
	CMP #LIST,A	;INPUT MUST BE A LIST
	BEQ DO1		;OK
	ERROR+WTAB
DO1:	JSR PC,BLSTI
	PUSH PCHR
	MOV #BLST,PCHR
	CLR NBKTS
	JSR PC,PNODAB	;CONVERT THING ON S TO STRING ON S
	POP PCHR
	JSR PC,BLSTF
	BEQ DO3		;EMPTY STRING
	MOV TOPS,@S
DO2:	JSR PC,READ	;CONVERT STRING ON S TO TOKEN LIST ON S
	BEQ DO4		;NO TOKENS
	JSR PC,SAVEVL
	PUSH #0		;NO. OF ARGS
	JSR PC,SAVPPS	;SAVE PDL POINTERS
	BIS #DORF,FLAGS	;SET FOR DO FRAME
	BIS #1,CPDLP	;RESULTS IN PROC PUSH
	JSR PC,EVLINE	;EVALUATE THE LINE
	BEQ DO5		;NO OUTPUT
	MOV #-1,C
	MOV #RET,PSTOPR	;RETURN ADDRESS (NO OUTPUT)
	BR DO6
DO5:	POPS C		;GET THE "OUTPUT"
	MOV #SRET,PSTOPR	;RETURN ADDRESS (OUTPUT)
DO6:
	JSR PC,RESPPS	;RESTORE PDLS
	POP B
	JSR PC,RESEVL	;RESTORE PROC VALUES
	BIC #EVIFS+DORF,FLAGS
	BIC #-EVIFS-1,B	  ;EVIFS=PTLPF+CRF+RTF
	BIS B,FLAGS
	POPS B
	CMP #-1,C	;WAS THERE OUTPUT?
	BEQ DO7		;NO
	PUSHS C		;PUT "OUTPUT" BACK ON S
DO7:	CLR D
	MOV CTP,C
	JMP	PSTOP6
DO3:	POPS A
DO8:	SEZ
DO4:	RTS PC

SAVEVL:	POP F	;SAVE THE WORLD
	PUSH CPP		;PUSH THE WORLD!
.IFNZ SWAPF
	SPUSH CPSN
.ENDC
	SPUSH CPLN
	SPUSH CLP
	SPUSH CLGN
	SPUSH CTN
	PUSH CTP
	SPUSH FLAGS
	SPUSH CO
	SPUSH CO+2
	SPUSH IFLEV
	SPUSH ERPROC
	JMP @F

RESEVL:	POP F
	POP ERPROC	;PROC, RESTORE REST OF WORLD
	SPOP IFLEV
	SPOP CO+2
	SPOP CO
	SPOP B
	SPOP CTP
	SPOP CTN
	SPOP CLGN
	POP CLP
	SPOP CPLN
.IFNZ SWAPF
	SPOP CPSN
.ENDC
	SPOP CPP
	JMP @F
	.STITL "TO" ETC.
GTLN:	JSR PC,GTUOEB	;GET LINE # FROM NEXT TOKEN INTO B
	BEQ DO8
	MOV #SNUM,A
	JSR PC,CONVER	;MAKE NEXT TOKEN INTO AN SNUM
	RTS PC
GTLP:	PUSH CPP	;GET LINE PTR OF LINE (B) FOR PROC (TOPRNM)
	MOV TOPRNM,CPP	;LEAVE PTR IN C
	JSR PC,GTLINE
	BEQ GTLP1
	POP CPP
	CLZ
	RTS PC

GTLP1:	POP CPP
	ERROR+LDE
EDTITL:	TST TOPRNM
	BNE .+4
	ERROR+OIP	;ONLY IN PROCEDURE
	JSR PC,EDITA	;SET UP FOR EDIT BUFFER INSERT
	PUSH PCHR
	MOV #ETYO,PCHR
	MOV TOPRNM,B
	JSR PC,SHTITL	;"PRINT" TITLE LINE INTO EDIT BUFFER
	BNE .+4
	.BUG.
	JSR PC,EDITE	;CLEAN UP EDIT BUFFER INPUT
	BIS #EDTIF2,FLAGS
	BR EDLIN1
EDLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GET LINE # IN B
	BNE .+4
	ERROR+ELW	;EDIT LINE WHAT
	JSR PC,GTLP	;GET PTR TO THAT LINE
	JSR PC,EDITA
	PUSH PCHR
	MOV #ETYO,PCHR
	JSR PC,.LOADC	;GET PTR TO LINE (IN LLP NODE)
	PUSHS B	;FOR INPUT TO PRLN
	JSR PC,PRLN	;"PRINT" THE LINE TO THE EDIT BUFFER
	POPS B
	JSR PC,EDITE
EDLIN1:	POP PCHR
	SEZ
	RTS PC
EDIT2:	CMP #TYI,GCHR
	BNE EDIT3
	CMP #INFIX,A
	BHIS .+4
	ERROR+WTAB
	ERROR+UBL
EDIT3:	JSR PC,CVSFLS
	MOV TOPS,B
	JSR PC,GRBAD
	MOV C,TEMP
	BIS #LIST,C
	MOV C,TOPS2
	BR TO86
EDIT1:	.IFNZ ENG
	CMP #$TITLE,B
	BEQ EDTITL
	CMP #$LINE,B
	BEQ EDLINE
.ENDC
.IFNZ FR
	CMP #$TITRE,B
	BEQ EDTITL
	CMP #$LIGNE,B
	BEQ EDLINE
.ENDC
		;NOT A VALID EDITING COMMAND
	TST B	;IS THIS A CR?
	BEQ .+4
	ERROR+NEC
	BIS #EDITF,FLAGS
	MOV LASTPR,B
	BNE TO0
	ERROR+UELX
EDIT:	BIC #EDTIF,FLAGS
	JSR PC,GTUOEB	;LOOK AT NEXT TOKEN
	BNE EDIT1	;NOT A UOE
	BIS #EDITF,FLAGS
	BR TO0
TO:	BIC #EDITF,FLAGS
	JSR PC,GTUOEB	;GET UOE PTR FROM NEXT TOKEN
	BNE EDIT2
	BIC #170000,B
	BIS #UFUN,B
	MOV B,TOPS2	;SO THIS "TOTALLY WORTHLESS ATOM WONT BE G.C.
	JSR PC,TITLDF
TO0:	TST TOPRNM
	BEQ TO8
	MOV FNLLP,TMPBLK
	BIT #EDTIF,FLAGS
	BNE TO8
	ERROR+CTIT	;CANT "TO" IN TO
TO8:	MOV B,TEMP
	CLR TOPS
	JSR PC,.BINDF
	BEQ TO6
	BIT #EDTIF,FLAGS
	BEQ TO84
	CMP TOPRNM,TEMP
	BNE TO85
	MOV TOPS1,A
	BIS #LIST,A
	JSR PC,.STP2
	MOV TOPS1,B
	BR TITED1
TO84:	MOV A,FNLLP
	BIT #EDITF,FLAGS	;IS IT "EDIT"?
	BNE TO5	;YES
	CMP #TYI,GCHR	;IS INPUT FROM TTY?
	BNE .+4
	ERROR+PAE	;YES - PROCEDURE ALREADY EXISTS
TO86:	BIS #SPDF,FLAGS	;NO - SET SKIP PROC DEF. FLAG
	MOV TEMP,TOPRNM
TO81:	BIT #CRF,FLAGS
	BNE TO82
	JSR PC,GNT	;READ TO END OF LINE
	BR TO81
TO82:	CLR TOPS
	CLR TOPS1
	CLR TOPS2
	RTS PC
TO7:	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
	JSR PC,.LOAD
	MOV A,FNLLP
TO5:	MOV TEMP,TOPRNM
	MOV #'>,PRMTCH
	BR TO82
TO6:	BIT #EDTIF,FLAGS	;EDITING TITLE?
	BNE TITED
	BIT #EDITF,FLAGS	;IS IT "EDIT"
	BEQ TO7	;NO
	ERROR+PNH	;YES, PROCEDUTE NOT HERE
TO85:	ERROR+PAE	;PROC (TEMP) ALREADY EXISTS
TITED:	;EDIT THAT TITLE...
	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
TITED1:	JSR PC,.LOAD
	MOV A,FNLLP
;MAKE NEW PROC POINT TO OLD LINES
	MOV A,C
	MOV TMPBLK,B
	JSR PC,.LOAD
	JSR PC,.STP1
	CMP TEMP,TOPRNM
	BEQ TITED2
	MOV TOPRNM,B
	MOV #FBIND,A
	JSR PC,.UNBND
	MOV TEMP,TOPRNM
TITED2:	BR TO82
GO:	MOV CPLN,JPLN	;SAVE CURRENT LINE # AS LINE JUMPED-FROM
	JSR PC,G1NARG
	MOV B,CPLN
GOUNTL:	CLR CLP
	CLR CT
	CLR CT+2
	BIC #RTF,FLAGS
	SEZ
	RTS PC

RETURN:	JSR PC,G1NARG
	MOV B,TMPBLK
	MOV #RETU1,PSTOPR
	MOV #RETU3,ERFRET	;CATCH ERROR SET FRAME
	MOV #PSTP15,DOFRET
RETU1:	TST FUNLEV
	BEQ PROCE1
	JMP PSTP15
RETU3:	MOV #RETU2,PSTOPR
	CLR CTN	;SET UP TO RESTART AT BEGINNING OF LINE
.IFNZ SWAPF
	MOV #-1,CPSN
.ENDC
	BR PROCE2
RETU2:	MOV TMPBLK,CPLN
	CLR CTN	;SET UP TO RESTART AT BEGINNING OF LINE
	CLR CTP
	CLR CLP
	JMP MLOOP
CONTINUE:	MOV	USER,U
	JSR	PC,BRKMON	;RESTART MUSIC BOX IF APPROPRIATE
	MOV #MLOOP,PSTOPR
	MOV #PSTP15,DOFRET
PROCE2:	TST FUNLEV
	BEQ PROCE1
	BIT #DORF,FLAGS
	BEQ PROCE3
PROCE4:	JSR PC,RESPPS
	POP B
	JSR PC,RESEVL
	BR PROCE2
PROCE3:	MOV CPDLP,A
	BIC #1,A
	JSR PC,PPTA
	MOV CSPDLP,A
	JSR PC,PSTA
	BIC #BRKF,FLAGS
	JMP PSTP43	;TRY RESTARTING
PROCE1:	JMP ERTL3

GTUOEB: 	JSR PC,GNT	;GET UOE PTR FROM NEXT TOKEN IN B
	BIT #CRF,FLAGS
	BEQ .+4
	ERROR+UEL	;UNEXPECTED END OF LINE
	BIC #7777,A	;SKIP UNLESS NEXT TOKEN NOT UOE.  USES A
	CMP #UFUN,A
	BEQ GTU1
	CMP #ATOM,A
	BEQ GTU1
	CMP #LSTR,A
	BNE GTU2
	MOV B,TOPS
	JSR PC,.INTRN
GTU1:	CLR TOPS
GTU2:	RTS PC
TITLDF:		;INPUT-CURRENT TOKEN LIST VIA GNT
		;OUTPUT-TOPS1  - POINTS TO FIRST NODE OF LLP
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV CT,TEMP
	CLR D
TO3:	JSR PC,GNT
	BIT #CRF,FLAGS
	BNE TO4	;DONE
	BIC #7777,A
	INC D
	CMP #UVAR,A
	BEQ TO3
	ERROR+WIT	;WRONG TYPE OF INPUT TO "TO"
TO4:	CMP #MAXARG,D
	BGE TO9
	ERROR+TMAP	;TOO MANY ARGS (PROCEDURE)
	CLR D	;THIS ERROR RETURNS HERE!!
	CLR TEMP
TO9:	MOV #LIST,A
	MOV A,B
.IFNZ SWAPF
	JSR PC,GRBAD	;ZEROTH NODE IN LLP - PTS TO SWAP INFO
	MOV C,TOPS1	;SAVE - PTR TO LLP
.ENDC
	MOV #SNUM,A
	MOV D,B
.IFNZ SWAPF
	JSR PC,GRBAD2	; - # ARGS NODE
	CLR B
	JSR PC,GRBAD1	; - CPSN NODE (START CPSN AT 0)
	MOV TOPS1,C
.IFF
	JSR PC,GRBAD
	MOV C,TOPS1
.ENDC
	MOV #LIST,A
	MOV A,B
	JSR PC,GRBAD1	;FIRST NODE OF LLP - POINTS TO ARG LIST
	MOV TEMP,A
	BIC #170000,A
	BIS #SNUM,A
	MOV D,B	;# ARGS SAVED ABOVE
	JSR PC,GRBAD2	;FIRST NODE OF LINE 0 (ARG LINE)
	JMP RETD
END:	MOV TOPRNM,B
	BNE .+4
	ERROR+OIP	;ONLY IN PROCEDURE DEFINITION
	MOV B,LASTPR	;SAVE FOR "PO"
	TST REDFLG
	BEQ END4
	BIT #SPDF,FLAGS
	BEQ END3
END4:	TST FUNLEV	;DON'T PRINT "FOO DEFINED" IF NOT AT TOP LEVEL
	BEQ END5
	BIT #BRKF,FLAGS
	BEQ END3
END5:	JSR PC,PPNAME
	BIT #SPDF,FLAGS
	BNE END1
.IFZ ENG&FR
.IIF NZ ENG,	PRTXTC ^\ DEFINED\
.IIF NZ FR,	PRTXTC ^/ EST DEFINI/
.IFF
	BIT #FRFLG,LANG
	BEQ END6
	PRTXTC ^/ EST DEFINI/
	BR END7
END6:	PRTXTC ^/ DEFINED/
END7:
.ENDC
END3:	CLR TOPRNM
	BIC #SPDF,FLAGS
	MOV #'?,PRMTCH
END2:	SEZ
	RTS PC
END1:
.IFZ ENG&FR
.IIF NZ ENG,	PRTXTC ^/ SKIPPED/
.IIF NZ FR,	PRTXTC ^/ A ETE PASSE/
.IFF
	BIT #FRFLG,LANG
	BEQ END8
	PRTXTC ^/ A ETE PASSE/
	BR END9
END8:	PRTXTC ^/ SKIPPED/
END9:
.ENDC
	BR END3
	.STITL UTILITY - COUNT LIST ELEMENTS
CLE:		;COUNT LIST ELEMENTS
		  ;IN - LIST PTR IN C
		 ;OUT - # OF ELEMENTS IN B
	PUSH A
	SPUSH C
	CLR B
	MOV C,A
CLE1:	BIT #7777,A
	BEQ CLE2
	MOV A,C
	JSR PC,.LDP1
	INC B
	BR CLE1
CLE2:	POP C
	SPOP A
	RTS PC
	.STITL UTILITY - ADD A LINE
ADLN:		;ON S IS A "NEW LINE" INSERT IN PROPER PLACE
		;IN LLP POINTED TO BY FNLLP.
		;IF "NEW LINE" # IS NEG, DELETE THE LINE
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	MOV @S,C
	JSR PC,.LOADC
	MOV B,F	;SAVE LINE #
	BLT ADLN6	;IF < 0, THIS IS A DELETE
	BIC #TF4,TFLAGS
ADLN7:	MOV FNLLP,C
	JSR PC,.LOADC	;SKIP OVER ARG LINE
	MOV C,D
	MOV A,C
	;LOOK DOWN LLP FOR LINE #(@P)
ADLN1:	MOV D,E	;SAVE PTR TO PREDECESSOR IN E
	MOV C,D	;SAVE PTR TO CURRENT IN D
	MOV #LIST,A
	BIT #7777,C
	BEQ ADLN2	;AT END, ADD NEW NODE
	JSR PC,.LOADC
	MOV A,C	;SAVE PTR TO SUCCESSOR IN C
	JSR PC,.LOAD
	CMP B,F
	BLT ADLN1	;NOT THERE YET
	BEQ ADLN3	;FOUND LINE
	MOV D,A	;OTHERWISE, INSERT NEW LINE
ADLN2:	BIT #TF4,TFLAGS	;PASSED IT - IF DELETE
	BNE ADLN5	;ALL DONE
	MOV @S,B	;ADD NEW NODE TO END
	MOV E,C
	JSR PC,GRBAD1
ADLN5:	JMP RETF
ADLN3:	BIT #TF4,TFLAGS	;FOUND LINE NO.  DELETE?
	BEQ ADLN31	;NO
	MOV C,A	;YES
	MOV E,C
	JSR PC,.STP1
	BR ADLN5
		;NOT DELETE, REPLACE THEN CHECK GEN. NO.
ADLN31:	MOV A,E	;SAVE A, POINT TO FIRST TOKEN IN OLD LINE
	MOV @S,A
	MOV D,C	;D POINTS TO RELEVENT LLP NODE
	JSR PC,.STP2	;STORE LINK TO NEW LINE
	TST FUNLEV	;IF AT FUNLEV 0, DON'T BOTHER WITH GEN #
	BEQ ADLN5
	MOV E,C	;E POINTS TO OLD LINE
	JSR PC,.LOADC	;GET NEXT NODE IN OLD LINE(1ST TOKEN OR GEN )
	BIC #7777,A
	CMP #SNUM,A
	BEQ ADLN4
	CLR B
ADLN4:	INC B	;ALREADY HAS GEN NO.
	MOV @S,C
	JSR PC,.LDP1
	BIC #170000,A
	BIS #SNUM,A
	JSR PC,GRBAD1
	BR ADLN5
ADLN6:	NEG F
	BIS #TF4,TFLAGS
	BR ADLN7
	.STITL UTILITY - GET A LINE, GET ARGS
GTLINE:		;GET LLP POINTER OF LINE WHOSE NO. IS IN B
			;FOR PROCEDURE PONTED TO BY "CPP"
			;OUTPUT - LLP PTR WILL BE IN C AND WILL SKIP
	BIS #TF1,TFLAGS
	BR .+10
GNLINE:		;SAME EXCEPT LOOKING FOR LINE WHOSE # IS > # IN B
	BIC #TF1,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	MOV B,D
	MOV CPP,B
	JSR PC,.BINDF	;LOOK FOR PROC BINDING
	BNE .+4
	.BUG.	;WHAT NO PROC BINDING??!!
	JSR PC,.LOADA
	MOV A,E
GNL1:	BIT #7777,E
	BEQ GNL4	;NONE LEFT
	MOV E,C
	JSR PC,.LOADC	;GET NEXT NODE IN LLP
	MOV A,E
	JSR PC,.LOADB	;GET FIRST NODE OF THAT LINE
	CMP B,D
	BLT GNL1	;NOT THERE YET
	BEQ GNL2	;FOUND IT
	BIT #TF1,TFLAGS	;WENT PAST, WERE WE LOOKING FOR IT?
	BEQ GNL3	;NO, OK
GNL4:	JMP RETE	;YES "NO SUCH LINE NO."
GNL2:	BIT #TF1,TFLAGS	;FOUND IT, LOOKING FOR IT?
	BEQ GNL1	;NO, GET NEXT
GNL3:	MOV C,4(P)	;OUTPUT (C) INTO C
	JMP SRETE
GNASN:		;GET NO. OF ARGS AND CPSN OF USER PROC
		;IN: PROC PTR IN B
		;OUTPUT: CPSN IN A # IN B
		;DONT SKIP IF NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	BNE .+6
	JMP RETC
	JSR PC,.LOADB
	MOV B,2(P)	;# IN OLD B
.IFNZ SWAPF
	JSR PC,.LOADA
	MOV B,4(P)	;CPSN IN OLD A
.ENDC
	JMP SRETC
	.STITL UTILITY - LOAD AND STORE
.LOADA:	MOV A,B		;(A) -> A,,B
	BR .LOAD
.LOADC:	MOV C,B	;NODE ADDR IN C
		;NODE RETURNED IN A,B
.LOADB:
.LOAD:	BIC #170000,B	;NODE ADDR IN B
	ASL B	;NODE RETURNED IN A,B
	ASL B
	ADD #NODESP,B
	MOV (B)+,A
	MOV @B,B
	RTS PC
.STORE:	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ASL C	;NODE IN A,B IS STORED AT C
	ASL C
	ADD #NODESP,C
	MOV A,(C)+
	MOV B,@C
	SPOP C
	RTS PC

.STP2:		;SAME AS .STP1 EXCEPT STORE IN 2ND WORD OF NODE
	SEC	;THEN RESULT OF ROL'S WILL BE TWO GREATER THAN  .STP1
	BR .+4
.STP1:	CLC	;STORE (A) IN FIRST WORD OF NODE AT C
	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ROL C
	ROL C
	ADD #NODESP,C
	MOV A,@C
	SPOP C
	RTS PC

.LDP2:	SEC		;NODE ADDR IN C (TYPE FIELD =0)
	BR .+4		;LOAD 2ND WORD OF NODE INTO A
.LDP1:	CLC		;SAME AS .LDP2 EXCEPT 1ST WORD
	MOV C,A
	BIC #170000,A
	ROL A
	ROL A
	ADD #NODESP,A
	MOV @A,A
	RTS PC

.LDP2I:	MOV C,A	;SAME AS .LDP2 EXCEPT C WILL
	BIC #170000,A	;CONTAIN ADDR OF NEXT NODE
	ASL A
	ASL A
	ADD #NODESP,A
	MOV (A)+,C
	MOV @A,A
	RTS PC
	.STITL UTILITY - BINDING
	;INPUT:	A=TYPE	B=UOE POINTER
	;		TOPS=0 OR TYPE+VALUE POINTER
	;OUTPUT:	A - UCHANGED
	;		B - EITHER UNCHANGED OR VALUE POINTER
	;		C - POINTS TO BINDING NODE, EITHER 
	;		    RELEVANT ONE OR LAST IN BINDING LIST
	;		IF TOPS = 0, SKIPS IF BINDING FOUND
	;		IF TOPS NOT = 0, TOPS WILL BE INSERTED
	;		   AS THE NEW VALUE POINTER (A NEW BINDING
	;		   NODE WILL BE ADDED IF NECESSARY) NEVER SKIPS.
.BINDL:	TST TOPS
	BEQ .BIND
	PUSHS TOPS
	CLR TOPS
	JSR PC,.BIND
	BEQ .BNDL2
	POPS TOPS
	CLZ
	RTS PC
.BNDL2L:	POPS TOPS
	SEZ
	RTS PC

.BIND:	PUSH D
	SPUSH B
	SPUSH A
	MOV B,A
BINDF1:	MOV A,C
	JSR PC,.LOADC
	MOV A,D
	BIC #7777,D
	CMP @P,D
	BEQ BINDF4	;FOUND IT
	BIT #7777,A
	BNE BINDF1
	TST TOPS	;DIDNT FIND IT
	BEQ BINDF2	;SHOULD ONE BE CREATED?
	SPOP A
	MOV TOPS,B
	JSR PC,GRBAD1
BINDF5:	POP D	;OLD B
BINDF3:	SPOP D
	SEZ
	RTS PC

BINDF2:	POP A	;NO, DONT CREATE NODE
	SPOP B
	BR BINDF3

BINDF4:	TST TOPS	;FOUND, CHANGE VALUE POINTER?
	BEQ BINDF6
	MOV TOPS,A	;YES + DONT SKIP
	JSR PC,.STP2
	POP A
	BR BINDF5

BINDF6:	POP A	;NO, LEAVE VALUE POINTER, BUT SKIP
	SPOP D	;OLD B
	SPOP D
	CLZ
	RTS PC
.UNBND:	PUSH A	;ERASE TYPE (A) FROM UOE (B)
	SPUSH B	;SKIP UNLESS NOT FOUND
	SPUSH C
	SPUSH D
	MOV B,C
.UNB1:	MOV C,D
	MOV B,C
	BIT #7777,C
	BNE .+6
	JMP RETD
	JSR PC,.LOADC
	MOV A,B
	BIC #7777,A
	CMP 6(P),A
	BNE .UNB1
	MOV D,C
	JSR PC,.LDP1
	BIC #7777,A
	BIC #170000,B
	BIS B,A
	JSR PC,.STP1
	JMP SRETD
.BINDF:	MOV #FBIND,A	;GET FUNCTION BINDING, SWAP IN IF NECESSARY
		;PTR TO UOE IN B
		;OUTPUT AS IN .BIND: EXCEPT A,,B = NODE PTD TO BY C
	JSR PC,.BINDL	;LOOK FOR FUNCTION BINDING
	BEQ BIF1
	JSR PC,.LOADB
	BIT #7777,A	;IS PROC SWAPPED IN?
	BNE BIF1	;YEP
	JSR PC,PSWPIN	;GO GET IT
	CLZ
BIF1:	RTS PC

.BNDFS:	MOV #FBIND,A	;SAME AS .BINDF EXCEPT DONT SWAPIN
	JSR PC,.BINDL
	BEQ BIF1
	JSR PC,.LOADB
	CLZ
	RTS PC

	.STITL .INTRN!!
.OBSCH:		;SAME AS .INTRN EXCEPT WONT INSERT IF ENTRY ISNT FOUND
		;(ALSO SEE UOBSCH ON NEXT PAGE)
	BIC #TF5,TFLAGS
	BR .+10
.INTRN:		;(ALSO SEE UINTRN ON NEXT PAGE)
		;INPUT:  TYPE IN A, LSTR IN "TOPS"
		;OUTPUT:  IF TYPE IS UFUN OR SFUN,
		; SEARCH SYSTEM OBLIST FIRST.
		;  IF FOUND THERE, RETURN THAT PTR IN B,
		; MAKING TYPE OF A TO "SFUN".
		;  IF NOT FOUND THERE, AND IF A=UFUN, OR IF TYPE
		;  IS > "UFUN", DO THE LOOKUP IN THE USER OBLIST.
		;  RETURN WITH THE UOE PTR IN B.
		; DONT SKIP IF A NEW ONE HAD TO BE ADDED,
		;  OR IF IN SEARCHING FOR AN SFUN
		;  ONE WAS NOT FOUND.
;*******  NOTE  ********
;A NEW UOE IS "TOTALLY USELESS" AND SO MUST BE PROTECTED FROM G.C.
	BIS #TF5,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
	CMP #UFUN,A	;IS TYPE SFUN OR UFUN
	BLO INT2	;NO
	JSR PC,SSOL	;YES, SEARCH SYSTEM OBLIST
	BEQ INT1	;NOT THERE
	MOV #SFUN,4(P)	;SET TYPE TO "SFUN"
	BR INT5

INT1:	CMP #SFUN,A	;IS A = TYPE SFUN
	BEQ INT0	;YES, DONE, DONT SKIP
INT2:	JSR PC,HSSL	;NO, HASH TO AND SEARCH SUBLIST
	BEQ INT3

INT5:	MOV B,2(P)
	JMP SRETC	;FOUND ATOM

INT3:	BIT #TF5,TFLAGS	;NOT THERE, SHOULD IT BE ADDED
	BEQ INT0	;NO, RETURN AND DONT SKIP
	SPUSH B		;SAVE WORD POINTER TO LAST NODE OF BUCKET
	MOV #LIST,A
	MOV #ATOM,B
	JSR PC,GRBAD	;CONS UP NEW LAST NODE
			;  (STRANGE TYPE LEST GARBAGE COLLECT)
	BIS #LIST,C
	PUSHS C		;SAVE POINTER TO IT, ALSO FOR G.C.
	MOV #ATOM,A
	MOV TOPS,B
	JSR PC,GRBAD2	;CONS UP ATOM NODE; NEW BUCKET NODE PTS TO IT
	MOV C,4(P)	;SO WILL B ON RETURN
	POPS C
	BIC #LIST,C	;GET BACK POINTER TO NEW BUCKET NODE

	MOV #BUKTEL,A
	JSR PC,.STP1	;MAKE IT AN END-OF-BUCKET NODE
	BIS C,A		;OLE & PTR TO IT
	SPOP C		;TO OLD END-OF-BUCKET WORD
	MOV A,(C)

INT0:	JMP RETC


;"UNPURE" .INTRN AND .OBSCH
;BY "UNPURE" IT IS MEANT THAT THE INPUT STRING MAY INCLUDE
;NULL CHARACTERS
;SPECIFICATIONS ARE OTHERWISE IDENTICAL TO .INTRN AND .OBSCH

;ROUTINE TO PURIFY STRING
UINOB:	PUSH A
	PUSH B
	PUSH C
	MOV	TOPS,B
	JSR PC,CPYSTR	;OUTPUT POINTER IN B TO STRING WITH NO NULLS
	BIS #LSTR,B
	MOV	B,TOPS
	POP C
	POP B
	POP A
	RTS PC

UINTRN:	SPUSH #.INTRN
	BR UINOB

UOBSCH:	SPUSH #.OBSCH
	BR UINOB
	.STITL SEARCH SYSTEM OBLIST
SSOL:		;SEARCH SYSTEM OBLIST
		;INPUT:  C POINTS TO STRING
		;OUTPUT:  SKIP = FOUND AND SOE PTR IN B
		;  NO SKIP = NOT FOUND AND NO CHANGE
		;NULL MUST BE USED AS FILLER CHAR BUT NOT BE IMBEDDED
	PUSH A
	SPUSH B
	SPUSH C		; -> STRING (DESIRED PNAME)
	SPUSH D		; -> CURRENT PNAME
	SPUSH E		; 2^N
	SPUSH F		; -> SYSTEM OBLIST ELEMENT
	MOV SOBP2,E	;GET 2^N
	MOV #SOBLST,F	;GET START OF OBLIST
SSOL1:	ASR E		;HALVE 2^N
	BIT #177776,E	;NOT FOUND IF 2^N = 1
	BEQ SSOL5
	ADD E,F		;ADD 2^N TO OBLIST PTR
	CMP F,SOOMX	;OVERSHOT END OF LIST THEN UNDO ADD
	BHIS SSOL2
	MOV @F,D
	ADD #4+SOBLST,D	;FIND START OF THIS PNAME
	MOV C,A		;AND DESIRED PNAME
SSOL4:	JSR PC,.LOADA	;GET TWO CHARS OF DESIRED
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED:  ADD 2^(N-1)
	BLO SSOL2	;PNAME > DESIRED:  UNADD 2^N AND ADD 2^(N-1)
	SWAB B
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED
	BLO SSOL2	;PNAME > DESIRED
	BIT #7777,A	;MORE PNAME TO COMPARE?
	BNE SSOL4	;YES
	TSTB B		;MATCHING NULLS FOUND?
	BEQ SSOL3	;FOUND
	TSTB (D)	;AT END OF STRING, IS IT END OF SYS PNAME
	BNE SSOL2	;NO:  TRY ANOTHER (COUNT AS OVERSHOOT)
SSOL3:	MOV (F),F	;POINTER TO OBLIST ELEMENT
	.IFNZ ENG&FR
	BIT LANG,SOBLST(F)
	BEQ SSOL5
	.ENDC
	BIT #ABRFLG,SOBLST(F)	;IS IT AN ABBRVIATION?
	BEQ .+6
	MOV 2+SOBLST(F),F	;YES, "EXPAND" IT
	ASR F
	MOV F,10(P)	;YES, SAVE F AS OUTPUT
	JMP SRETF

SSOL5:	JMP RETF

SSOL2:	SUB E,F		;UNADD 2^N
	BR SSOL1
	.STITL HASH AND SEARCH USER SUB-OBLIST
HSSL:		;HASH, THEN SEARCH SUB-LIST
		;INPUT:  C POINTS TO LSTR
		;OUTPUT:  IF NOT FOUND, B IS A WORD POINTER
		;	 TO LAST BUCKET ELEMENT.
		;  IF FOUND, B POINTS TO ATOM CELL, AND RETURN SKIPS.
	PUSH A
	SPUSH B		;PTR TO THIS PNAME
	SPUSH C		;PTR TO DESIRED PNAME
	SPUSH D		;NEXT OLE
	SPUSH E		;THIS OLE
	MOV C,A		;PTR TO STRING
	CLR D		;SUM OF WORDS FOR HASHING
HSSLA:	JSR PC,.LOADA	;GET A TWO-LETTER FRAGMENT
	ADD B,D		;ADD IN
	BIT #7777,A	;MORE FRAGMENTS?
	BNE HSSLA	;YES
	MOV D,B		;CREATE SUM OF ALL CHARS
	SWAB B
	ADD D,B		;IN LOWER BYTE (UPPER WON'T HURT)
	CLR A
	DIV #HCC,A
	ASL B
	ADD #UHCT,B
	MOV B,E		;RETURN ADDR OF LAST ELEMENT OF BUCKET IF NOT FOUND
	MOV @B,A	;A POINTS TO FIRST OLE NOW
HSSL1:	BIT #7777,A	;END OF BUCKET?
	BNE HSSLB
	MOV E,6(P)	;YES: NOT-FOUND RETURN:
	JMP RETE	;OUTPUT END-OF-BUCKET POINTER IN B

HSSLB:	MOV A,E		;SAVE PTR TO THIS OLE
	JSR PC,.LOADA	;GET THIS OLE
	MOV A,D		;SAVE PTR TO NEXT ONE
	JSR PC,.LOADB	;GET FIRST NODE OF ATOM STRUCTURE
	JSR PC,CSEQ	;CSEQ COMPARES STRINGS AT (B) AND (C)
	BEQ HSSL2	;NOT EQUAL:  TRY NEXT OLE
	MOV E,A		;EQUAL:
	JSR PC,.LOADA	;OUTPUT ATOM POINTER
	MOV B,6(P)
	JMP SRETE	;SKIP RETURN

HSSL2:	MOV D,A		;NOT FOUND, CHECK NEXT BUCKET ELEMENT
	BIC #LIST,E	;MAKE E A WORD PTR TO FIRST WORD OF PREV. NODE
	ASL E		;IN CASE IT'S THE LAST ONE.
	ASL E
	ADD #NODESP,E
	BR HSSL1
CSEQ:	PUSH A		;COMPARE TWO STRINGS - POINTERS IN B & C
	PUSH B		;SKIP IF EQUAL
	PUSH C		;"NULL" (8-BIT ON) CHARACTERS
	PUSH D		;  DON'T MATCH CORRESPONDING 8-BIT OFF CHARS
	MOV B,D		;SAVE STR 1 PTR
CSEQ1:	BIT #7777,D	;CHECK IF EITHER STRING DONE
	BEQ CSEQ3	;FIRST IS:  IS SECOND?
	BIT #7777,C
	BEQ CSEQ2	;SECOND BUT NOT FIRST:  NOT EQUAL
	MOV D,A
	JSR PC,.LOADA	;GET NEXT NODE OF STR 1: (A) TO A,,B
	MOV A,D	;SAVE POINTER IN D
	JSR PC,.LDP2I	;GET NEXT NODE OF STR 2: (C) TO C,,A
	CMP A,B
	BEQ CSEQ1	;WELL, THESE WORDS MATCH
CSEQ2:	JMP RETD	;STRINGS NOT EQUAL

CSEQ3:	BIT #7777,C	;SEE IF BOTH STRINGS ARE DONE
	BNE CSEQ2	;NOPE, NOT EQUAL
	JMP SRETD	;STRINGS EQUAL
	.STITL MINI SWAPPING
PSWPIN:	BPT
PSWPOT:	BPT
VSWPIN:	BPT
VSWPOT:	BPT
DSVB:	BPT	;DELETE SWAPPED VARIABLE BINDING
	.STITL UTILITY - GRAB NODE ROUTINES
GRBAD2:	SEC	;GRAB A FREE NODE, FILL IT WITH A,,B
			;IF C NOT =0, PUT PTR TO NEW NODE IN WORD 2 OF NODE(C)
			;C ALSO GETS POINTER TO NEW NODE REGARDLESS
	BR .+6
GRBAD:	CLR	C	;SAME AS ABOVE EXCEPT NEW POINTER ALWAYS IN C
GRBAD1:	CLC	;SAME AS ABOVE EXCEPT NEW PTR IN WORD 1
	SPUSH A
	BIC #170000,C
	BEQ GRB2	;C IS ZERO, FORGET STORING NEW NODE PTR
	ROL C
	ROL C
	ADD #NODESP,C	;ELSE MAKE NODE ADDRESS TO STORE AT
GRB2:
;	MOV UNGRAB,A
;	BNE GRB1	;IDLE THEN?
;	JIGGLE
	BIT #MGCF,FLAGS2
	BNE GRB4
	MOV FREE,A
	BNE GRB1
GRB4:	JSR PC,.GCOLL
	MOV FREE,A
	BNE GRB1
	CLR ERPROC	;DISABLE ERRSET IF 0 NODES
	ERROR+NSL	;NO STORAGE LEFT
GRB1:	DEC NNIFSL
	BGE .+4		;NEG NODES LEFT??
	.BUG.
;	CLR UNGRAB
	TST C
	BEQ GRB3
	BIC #170000,A
	BIC #7777,@C
	ADD A,@C
GRB3:	MOV A,C
	JSR PC,.LDP1
	SPUSH A		;CHECK THAT NODE WAS IDLE
	BIC #7777,A
	CMP #IDLE,A
	BEQ .+4
	.BUG.		;GRABBED AN UNIDLE NODE!!!!!
	SPOP A
	BIC #170000,A
	MOV A,FREE
	SPOP A
	JSR PC,.STORE
	RTS PC
	;.STITL UTILITY  -  FREE NODE ROUTINES
.FREE:	SPUSH A	;RETURN NODE IN C TO FREE STORAGE
	SPUSH B
	MOV FREE,A
	BIS #IDLE,A
	CLR B		;MAKE SURE POINTER 2 IS ZERO
	JSR PC,.STORE
	BIC #170000,C
	MOV C,FREE
	INC NNIFSL
	SPOP B
	SPOP A
.FREE1:	RTS PC
FRELST:	BIT #7777,TOPS	;RETURN LIST (TOP-LEVEL ONLY) IN TOPS
			;TO FREE STORAGE
	BEQ .FREE1
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
FRL1:	JSR PC,.LOADC
	JSR PC,.FREE
	BIT #7777,A
	BEQ FRL2
	MOV A,C
	BR FRL1
FRL2:	CLR TOPS
	JMP RETC
	.STITL READ A STRING
	FOO==%FNAM2
	VERN=VERN+%FNAM2

RDSTR7:	BIS #RBRKF,TFLAGS
	SEZ
RDSTR8:	RTS PC
RDSTR1:	PRCR	;OUTPUT - PTR ON S, SKIP UNLESS EMPTY OR BREAK
RDSTR:	CLR NBKTS
	MOV USER,U
	TST	BRAKE(U)
	BNE RDSTR7
	CMP #TYI,GCHR	;WILL CHARS BE COMING FROM TTY?
	BNE RLINE1	;NO
	MOV PRMTCH,D
	BEQ	RLINE
;	TST ALEVN
;	BEQ RLINE2
	BIT #BRKF,FLAGS
	BEQ RLINE2
	MOV FUNLEV,A
	BEQ RLINE2
LANGC	<MOV #'L,D>,<
	MOV #'N,D>
	JSR PC,TYO
	JSR PC,PRDN
	MOV PRMTCH,D
RLINE2:	JSR PC,TYO
RLINE:	TST USER
	BLT RLINE1
	PUSH	U
	MOV	USER,U
	JSR	PC,SLINE
	MOV	#FRTYIH,FLSRES(U)
	JSR	PC,FLUSH
	JSR	PC,RUNME
	POP	U
RLINE1:	JSR PC,BLSTI
RDSTR2:	JSR PC,@GCHR
	BIT #DRIBBF,FLAGS2
	BEQ RDST2B	;NO
.IIF NZ DRIBF,	JSR PC,.WRTEC	;OUTPUT IT TO THE FILE
RDST2B:	CMP #TYI,GCHR
	BEQ RDST2A
	CMP #2,D	;NOT FROM TTY: CHANGE ^B TO %
	BNE RDST2A	;(PRINTS AS SPACE STILL)
RDST2A:	TST	BRAKE(U)
	BNE	RDSTR7
	CMP #EOFCHR,D
	BNE RDSTR9
	MOV #TYI,GCHR	;NON-TTY INPUT DONE
	MOV #'],D	;FILL IN MISSING ]'S
	TST NBKTS
RDSR10:	BLE RDSTR4
	JSR PC,BLST
	DEC NBKTS
	BR RDSR10
RDSTR9:	CMP TBKCH,D	;BREAK TYPED?
	BEQ RDSTR7	;YES
	TST NBKTS	;IN A LIST?
	BGT RDSTR3	;YES
	CMP #15,D	;CR?
	BEQ RDSTR4
RDSTR3:	CMP #'[,D
	BNE RDSTR6
	INC NBKTS
RDSTR6:	CMP #'],D
	BNE RDSTR5
	DEC NBKTS
RDSTR5:	JSR PC,BLST
	BR RDSTR2
RDSTR4:	BIC #RBRKF,TFLAGS
	JSR PC,BLSTF
	BEQ RDSTR8
	PUSHS TOPS
	CLR TOPS
RDSTSR:	CLZ
	RTS PC

	.STITL REQUEST, FILE READ & WRITE
RQUEST:
RQU1:	PUSH PRMTCH
	JSR PC,INPUTL
	BEQ RQU5
	MOV E,C	;E POINTS TO LAST NODE OF STRING
	JSR PC,.LOADC	;NEED TO ADD A "]", IS THERE ROOM?
	BIT #177400,B
	BNE RQU2	;YES
	BIS #']*400,B	;NO - PUT A "]" THERE
	JSR PC,.STORE
RQU3:	MOV @S,GNCN
	BIC #170000,GNCN
	CLR F
	JSR PC,RDLST
	POPS TOPS
RQU4:	MOV TOPS,@S
	CLR TOPS
RQUR:	POP PRMTCH
	CLZ
	RTS PC
RQU2:	MOV #'],B
	JSR PC,GRBAD1
	BR RQU3
RQU5:	MOV #LIST,@S
	BR RQUR
INPUTL:	MOV #'<,PRMTCH
	MOV USER,U
	MOV UTTY(U),A
	TST CHARNO(A)
	BEQ .+6
	CLR PRMTCH
	JSR PC,RDSTR
	BNE IPUL2
IPUL1:	BIT #RBRKF,TFLAGS
	BEQ IPUL3
	POP PRMTCH	;THE RETURN
	SPOP PRMTCH	;NOW THE OLD PRMTCH
	ERROR+BRK
IPUL3:	PUSHS #LSTR
	SEZ
IPUL2:	RTS PC
TYPEIN:	JSR PC,RQU1	;INPUT A WORD FROM TTY
	BIT #7777,@S
	BNE TYPIN2
	MOV #LSTR,@S
	RTS PC
TYPIN2:	JMP FIRST
	.STITLE  READ -

READ:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	CLR RDFLAG
	MOV @S,GNCN
	BIC #170000,GNCN
	CLR F
READA:	JSR PC,RDWRD
	BEQ READB
	BIS #SEPF,RDFLAG
	JSR PC,CKDOTF
READC:	JSR PC,LISTB
	BIT #SEPF,RDFLAG
	BEQ READA
READB:	BIC #SEPF,RDFLAG	;CHECK SPECIAL CHAR IN D
	JSR PC,CKDOTF	;FIRST CHECK FOR PENDING ":"
	CMP #15,D
	BEQ READR	;C-R
	CMP #'",D
	BEQ READS	;STRING
	CMP #'[,D
	BEQ READL	;LIST
	CMP #'],D
	BNE .+4
	ERROR+COP	;CHAR (]) OUT OF PLACE
	CMP #':,D
	BEQ READD	;DOTS
	BITB #OPERF,DTBL(D)	;IS CHAR AN OPERATOR
	BEQ READA	;NO
	MOVB DTBL2(D),A
	ASL A
	MOV SOBLSU(A),B
		;SET TYPE TO SFUN OR INFIX
	MOV SOBLST(B),A	;THIS CROCK WORKS BECAUSE #SFUN=0
	BIC #-INFIX-1,A	; AND #INFIX=10000
	ASR B
	BR READC
READR:	POPS A
	CLR	TOPS
	TST	F
	BNE	READR1
	JMP RETF
READR1:	MOV A,@S
	JMP SRETF

READS:	JSR PC,GNC
	JSR PC,RDST
	BIS #SEPF,RDFLAG
	BR READC
READL:	JSR PC,RDLST
	POPS TOPS
	BIC #SEPF,RDFLAG
	BR READC
READD:	BIS #DOTF,RDFLAG
	BR READA
	.STITLE READ - READ WORD
	;READ CHARS UP THRU NEXT SEPARATOR CHAR.  IF JUST A SEP, RETURN
	;WITH IT IN D.  OTHERWISE NUMBERIFY OR INTERN CHAR STRING,
	;SKIP RETURN WITH TOKEN IN A,,B
RDWRD:	CLRB RDFLAG
	JSR PC,BLSTI
RDWA:	JSR PC,GNC
	JSR PC,GETCHF	;GET FLAGS IN A
	BIT #SEPF,A	;IS THIS CHAR A SEPARATOR?
	BNE RDWB	;YES
	BISB A,RDFLAG
	JSR PC,BLST
	BEQ RDWA
RDWB:	JSR PC,BLSTF	;FINISH OFF STRING
	BEQ RDWR+2
	BIT #NNUMF,RDFLAG
	BNE RDWC	;NOT A POSSIBLE NUMBER
	MOV TOPS,B
	MOV #LNUM,A
	JSR PC,CONVER	;TRY MAKING A #
.IFNZ FPPF
	BNE RDWR1
	MOV #FNUM,A
	JSR PC,CONVER	;IT MIGHT BE AN FNUM
.ENDC
	BNE RDWR1
RDWC:	MOV #UFUN,A	;TRY TO INTERN STRING IN TOPS AS A SYSTEM OR USER FUNCTION
	BIT #DOTF,RDFLAG	; UNLESS DOTF ON, THEN AS USER VARIABLE
	BEQ RDWD
	MOV #UVAR,A
	BIC #DOTF,RDFLAG
RDWD:	JSR PC,.INTRN	;RDST COMES HERE ALSO
	BEQ RDWE
	JSR PC,FRELST
RDWE:	BIC #170000,B
	BIS A,B
	CMP #UFUN,A	;IF WE GOT A UOE
	BHI RDWR+2	;THEN--
RDWR1:	MOV B,TOPS	;PROTECT THIS NEWLY HATCHED UOE FROM G.C.
RDWR:	CLZ
	RTS PC

GETCHF:		;GET FLAGS FOR CHAR IN D INTO A
	MOV #NNUMF,A
	TSTB D	;CHECK FOR 200 BIT
	BLT .+6
	MOVB DTBL(D),A
	RTS PC
	.STITLE READ - READ STRING
	;READ CHAR UP TO NEXT SPACE OR ] IF INSIDE
	;A LIST.  DONT ALLOW ] OR [.
	; SKIPS UNLESS EMPTY STRING
RDST:	CLRB RDFLAG
	JSR PC,BLSTI
	BR RDSB
RDSA:	JSR PC,GNC
RDSB:	JSR PC,GETCHF
	BIT #SEPF,A
	BEQ RDSE
	CMP #' ,D
	BEQ RDSX
	CMP #'],D
	BEQ RDSC
	CMP #'[,D
	BEQ RDSX
	CMP #15,D
	BEQ RDSX
RDSE:	BISB A,RDFLAG
	JSR PC,BLST
	BR RDSA
RDSC:	TST LISTBD	;ARE WE IN LIST
	BNE RDSX	;YES
RDSD:	ERROR+COP	;CHAR (D) OUT OF PLACE
RDSX:	MOV #LSTR,A
	MOV #LSTR, B
	JSR PC,BLSTF
	BEQ RDWR+2
	MOV #LSTR,A
	MOV TOPS,B
	BIT #NNUMF,RDFLAG
	BEQ RDWR	;IT IS A POSSIBLE NUMBER
	BIT #SEPF,RDFLAG
	BNE RDWR+2	;IT HAS A SEP CHAR IN IT
	MOV #ATOM,A
	BR RDWD	; INTERN IT
	.STITL READ - READ LIST
	;READ THRU MATCHING ] MAKING A LIST AS U GO
RDLST:	CLRB RDFLAG
	JSR PC,SLISTB
RDLA:	JSR PC,GNC
	CMP #' ,D
	BEQ RDLA	;SKIP OVER SPACES
	CMP #'[,D
	BEQ RDLB	;READ A LIST
	CMP #'],D
	BEQ RDLY	;DONE
	JSR PC,RDST	;READ A STRING
RDLX:	JSR PC,LISTB	;ADD THIS NODE TO LIST
	CMP #'[,D
	BEQ RDLB
	CMP #'],D	;AT END?
	BNE RDLA	;NO, GET NEXT ELEMENT
RDLY:	JSR PC,FLISTB
	RTS PC
RDLB:	JSR PC,RDLST
	POPS TOPS
	CLR D
	BR RDLX
	.STITLE READ - MISC
CKDOTF:	BIT #DOTF,RDFLAG
	BEQ LISTBR
	BIC #DOTF,RDFLAG
	PUSH A
	SPUSH B
	MOV #SFUN,A
	MOV #$DOTS,B
	JSR PC,LISTB
	JMP RETB
LISTB:	PUSH C
	MOV F,C	;BUILD A LIST, ADD NODE IN A,,B TO
	JSR PC,GRBAD1	;LIST WHOSE LAST NODE PTR IS IN F
	TST F	;CAREFUL - THE FIRST TIME IT IS CALLED, THE
		;POINTER TO THE FIRST NODE IS PUSHED ONTO S
	BNE LISTB1
	PUSHS	C
	BIS #LIST,@S
LISTB1:	MOV C,F
	POP C
LISTBR:	RTS PC
SLISTB:		;START LISTB
	PUSHS F	;SAVE CURRENT LAST NODE PTR
	CLR F
	INC LISTBD
	RTS PC
FLISTB:	TST F
	BNE FLSB1
	PUSHS #LIST
FLSB1:	POPS B	;THIS IS THE OUTPUT
	MOV @S,F	;RESTORE OLD LAST NODE PTR
	MOV B,@S	;THE RESULT
	MOV #LIST,A
	DEC LISTBD
	RTS PC
BLSTI:	CLR NCHR
	CLR E
	CLR TOPS
BLSTI1:	BIS #100000,E
	RTS PC
BLST:		;BUILD STRING - CHAR IN D, USES E
	TST	USER
	BGE	.+6
	JMP	STYO
	PUSH A
	SPUSH B
	SPUSH C
	CMPB #200,D	;CHECK IF NULL CHARACTER
	BEQ BLSTRT
	BIT #177,D	;CHECK IF NULL
	BEQ BLSTRT
	INC NCHR	;WE HAVE A CHAR
	ADD #40000,E
	BGE BLST2	;IS IT  THE SECOND
	MOVB D,TEMP	;NO, 1ST
BLSTRT:	JMP RETC
BLST2:	MOVB D,TEMP+1	;IT IS THE SECOND CHAR
	MOV TEMP,B
	;STORE THE CHARACTERS
BLST3:	JSR PC,BSAN
	BIS #100000,E
	BR BLSTRT
BLSTF:	;FINISH BUILDING STRING, PUT PTR IN TOPS.
		; DONT SKIP IF EMPTY STRING (TOPS=0)
	TST NCHR
	BEQ BSANR	;EMPTY STRING
	ADD #40000,E
	BLT BSANR
	PUSH A
	SPUSH B
	SPUSH C
	MOVB TEMP,B	;YES
	JSR PC,BSAN
BLSTF1:	JMP SRETC
BSAN:	MOV E,C
	MOV #SSTR,A
	JSR PC,GRBAD1
	TST E
	BNE BSAN1
	MOV C,TOPS	;SAVE NEW STRING PTR ON S
	BIS #LSTR,TOPS
BSAN1:	MOV C,E
BSANR:	RTS PC
	.STITL GNC - GET NEXT CHAR
GNC:	PUSH A		;GET NEXT CHAR INTO D
	SPUSH B		;INITIALIZE BY MOVING LSTR PTR INTO GNCN
GNC4:	MOVB GNCN+2,D	;    AND CLEARING TYPE FIELD (#170000)
	MOV GNCN,B	;PUTS CR (=#15) IN D IF NO MORE CHAR
	BLT GNC1	;JUST GOT 2ND CHAR
	BNE GNC3
	MOV #15,D
	JMP RETB	;NONE LEFT
GNC3:	JSR PC,.LOAD	;GET NEXT NODE
	BIS #100000,A	;SET "STILL ANOTHER CHAR" BIT
	MOV A,GNCN
	MOVB B,D	;FOR OUTPUT
	SWAB B
	MOVB B,GNCN+2
GNC2:	TST D
	BEQ GNC4	;IGNORE NULL CHARS
	JMP RETB
GNC1:	BIC #170000,GNCN	;CLEAR "STILL ..." BIT
	BR GNC2
	.STITL PRINT ROUTINES

PRLO:	PUSH A	;PRINT LAST OPERATOR
	SPUSH B
	MOV LO,A
	BEQ EMPTY
	MOV LO+2,B
	BR PRCO1
PRCO:	PUSH A,	;PRINT CURRENT OPERATOR
	SPUSH B
	MOV CO,A
	MOV CO+2,B
	BEQ EMPTY
PRCO1:	SPUSH D
	JSR PC,PROAB
	SPOP D
	JMP RETB
PROAB:	CMP A,#UFUN	;PRINT OPERATOR IN A,B
	BLO PRCO2
	JMP PPNAME	;PRINT PNAME
PRCO2:	MOV B,A	;SYSTEM FUNCTION
	BNE PRCO3
	PRTXT ^\ CR.\
	RTS PC
PRCO3:	ASL A
	ADD #4+SOBLST,A
	BR	PRAS	;PRINT ASCIZ PNAME
NOTPRO:	ERROR+OOP	;SOMETHING OUT OF PLACE
EMPTY:	PRTXT ^\ EMPTY \
	JMP RETB

ERTAS:	SPUSH D
ERTAS1:	MFPI (A)
	MOVB (P),D
	BEQ ERTAS2
	JSR PC,@PCHR
	MOVB 1(P),D
	BEQ ERTAS2
	JSR PC,@PCHR
	ADD #2,A
	TST (P)+
	BR ERTAS1
ERTAS2:	ADD #2,A
	TST (P)+
	SPOP D
	RTS A


PRAS:	SPUSH	D	;PRINT ASCIZ STRING POINTED TO BY A
	BR	.+6
PRAS1:	JSR	PC,@PCHR
	MOVB	(A)+,D
	BNE	PRAS1
	SPOP	D
	RTS	PC

PRON:	BIC #TF2,TFLAGS	;PRINT OCTAL NO., NO. IN A
	BR PRON1	;CALL-	JSR PC,PRON
PRONL:	BIS #TF2,TFLAGS
PRON1:	PUSH A		;PRON DOESN'T PRINT LEADING ZEROS, PRONL DOES
	SPUSH D
	CLR D
	SEC
	ROL A	;TO TELL WHEN WE ARE DONE
	BR PRON2
PRON3:	CLR D
	ASL A
	BEQ PRON5
	ROL D
	ASL A
	ROL D
	ASL A
PRON2:	ROL D
	BNE PRON4
	BIT #TF2,TFLAGS
	BEQ PRON3
PRON4:	BIS #TF2,TFLAGS
	BIS #60,D
	JSR PC,@PCHR
	BR PRON3
PRON5:	BIS #60,D
	BIT #TF2,TFLAGS
	BNE .+6	;IF NOTHING HAS BEEN TYPED, TYPE A ZERO
	JSR PC,@PCHR
	SPOP D
	SPOP A
	RTS PC
PRDN:	PUSH B		;PRINT DECIMAL NO. IN A
	SPUSH C
	SPUSH D
	CLR C
	MOV A,B
	BGT PRDN1	;POSITIVE
	BEQ PRDN0	;ZERO
	NEG B		;NEGATIVE:
	MOV #'-,D	;"-" (ABS VAL)
	JSR PC,@PCHR
PRDN1:	INC C		;COUNT A STORED DIGIT
	CLR A
	DIV #10.,A	;DIVIDE BY 10
	PUSH B		;SAVE REMAINDER = NEW DIGIT
	MOV A,B		;QUOTIENT:  = 0?
	BNE PRDN1	;NO:  GET SOME MORE LOW-ORDER DIGITS
PRDN2:	POP D		;GET SAVED HIGH-ORDER DIGIT
	ADD #'0,D	;ENCODE IT
	JSR PC,@PCHR	;PRINT IT
	DEC C
	BGT PRDN2	;UNTIL NO. DIGITS LEFT = 0
PRDNX:	POP D
	SPOP C
	SPOP B
	RTS PC

PRDN0:	MOV #'0,D	;TYPE "0"
	JSR PC,@PCHR
	BR PRDNX

EMPTY1:	JMP EMPTY
PRS1:	PUSH A	;PRINT TOP ELEMENT OF SS
	SPUSH B
	MOV #IS,A	;COMPUTE RELATIVE S PD PTR
	SUB S,A
	ADD SPRBAO,A
	CMP A,CSPDLP
	BLOS EMPTY1
	MOV @S,B
	SPUSH D
	JSR PC,PNODAB
	SPOP D
	JMP RETB
PNODAB:	MOV B,A
	BIC #7777,A
	CMP #SSTR,A
	BEQ PRS11
	CMP #SNP,A
	BLOS PRS11
	ERROR+INVN	;INVALID NODE
PRS11:	JSR PC,PRDATA
	RTS PC
PRCT:	PUSH A	;PRINT CURRENT TOKEN
	SPUSH B
	SPUSH D
	MOV CT,A
	MOV CT+2,B
	JSR PC,PRTAB
	SPOP D
	JMP RETB
PRTAB:	BIC #7777,A	;PRINT TOKEN IN A,B
	CMP A,#UVAR
	BHIS .+6
	JMP PROAB
	CMP A,#UVAR
	BEQ PRUV
	BR PRDATA
PRATM:	BIS #PQF,FLAGS2	;PRINT ATOM IN A,B
	BR PRUV1
PRUV:	MOVB #':,D	;PRINT USER VARIABLE IN A,B
	JSR PC,@PCHR
PPNAME:	BIC #PQF,FLAGS2	;PRINT PNAME - UOE PTR IN B
PRUV1:	JSR PC,.LOAD
	JMP PRLSTR	;PRINT PNAME
PRDATA:	CMP #INUM,A	;PRINT DATA IN A,B. 7777 FIELD OF A IS 0000
	BEQ PRINUM	;NUMBER
.IFNZ FPPF
	CMP #FNUM,A
	BEQ PRFNUM
.ENDC
	CMP #SNUM,A
	BEQ PRSNUM
	BIS #PQF,FLAGS2	;SET PRINT QUOTE FLAG
	CMP #ATOM,A
	BEQ PRUV1
	CMP #LSTR,A
	BEQ PRLSTR	;LONG STRING
	CMP #SSTR,A
	BEQ PRSSTR	;SHORT STRING
	BIC #PQF,FLAGS2
	CMP #LIST,A
	BEQ PRLST
	TST WRTFLG
	BEQ	PRSNP	;YES
	PRTXT	^/" /	;OUTPUT EMPTY
	BR	PRSRET
PRSNP:	PRTXT ^\%SNAP%\	;CANT PRINT A SNAP
	BR PRSRET
PRLSTR:	JSR PC,.LOAD	;PRINT LONG STRING
PRSSTR:	JSR PC,PRQQ	;PRINT SHORT STRING
PRSTR2:	MOVB B,D
	JSR PC,PRSPT
PRSTR3:	SWAB B
	MOVB B,D
	JSR PC,PRSPT
PRSTR4:	MOV A,B
	BIC #170000,B
	BEQ PRSRET
	JSR PC,.LOAD
	BR PRSTR2
PRSRET:	RTS PC
PRQQ:	BIT #PQF,FLAGS2	;PRINT ' " ' IF PQF=1
	BEQ PRSRET
	BIT #DPQF,FLAGS2
	BNE PRSRET
	MOVB #'",D
	JMP @PCHR
.IFNZ FPPF
PRFNUM:	PUSH C
	JSR PC,.FLOAD
	MOV #FNUM,C
	BR PRFNM1
.ENDC
PRSNUM:	CLR A	;PRINT SNUM
	TST B
	BGE PRINM1
	COM A
	BR PRINM1
PRINUM:	JSR PC,.LOAD	;PRINT INUM
PRINM1:	PUSH C
.IFNZ FPPF
	 MOV #INUM,C	;SET FLAG FOR INUM ENTRY
.ENDC
PRFNM1:	MOV E,TMPBLK+2
	MOV F,TMPBLK+4
.IFNZ FPPF
	CMP #FNUM,C
	BNE .+8
	JSR PC,.CFNST
	BR .+6
.ENDC
	JSR PC,.CINST	;CONVERT INUM IN A,,B TO STRING ON P
	MOV TMPBLK+2,E
	MOV TMPBLK+4,F
	MOV P,A
	MOVB (A)+,D
	BNE PRINM3
PRINM2:	MOVB (A)+,D
	BEQ PRINM4
PRINM3:	JSR PC,@PCHR
	BR PRINM2
PRINM4:	INC A	;TO MAKE IT EVEN (??)
	MOV A,P
	POP C
PRSPT2:	RTS PC

PRSPT:	CMPB #200,D
	BEQ PRSPT2
	TSTB D
	BEQ PRSPT2
	BIT #CPTBF,FLAGS2
	BEQ PRSPT1
	CMPB #'%,D
	BNE .+6
	MOV #' ,D
PRSPT1:	JMP @PCHR
PRLST:	PUSH A	;PRINT LIST, PTR IN B
	SPUSH B
	SPUSH C
	TST NBKTS
	BEQ PRL4
	MOV #'[,D
	JSR PC,@PCHR
PRL4:	INC NBKTS
	MOV B,C
PRL1:	SPUSH FLAGS2
	BIT #7777,C	;EMPTY LIST
	BEQ PRL2	;YES, DONE
	BIS #DPQF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
	BR PRL3
PRL6:	SPACE
PRL3:	JSR PC,.LOADC	;GET THIS NODE
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	JSR PC,PRTAB
	BIT #7777,C
	BNE PRL6
PRL2:	DEC NBKTS
	BEQ PRL5
	MOV #'],D
	JSR PC,@PCHR
PRL5:	BIC #DPQF,FLAGS2
	SPOP C	;GET OLD FLAGS2
	BIC #<-DPQF-1>,C	;MASK ALL BUT DPQF
	BIS C,FLAGS2	;AND RESTORE IT
	JMP RETC
PRNODE:	PUSH A	;PRINT NODE POINTED TO BY B
	SPUSH B
	SPUSH D
	JSR PC,.LOAD
	JSR PC,PRON
	SPACE
	MOV B,A
	JSR PC,PRON
	SPOP D
	JMP RETB

.IFNZ SYSP
SYSPR:	MOV NUSERS,A
	CLR B
	CLR C
SYSLP1:	SEC
	ROL C
	SOB A,SYSLP1
SYSLP2:	ROR C
	BCC SYSTST
	JSR PC,SENDIT
	BCS SYSNT1
SYSTST:	TST C
	BEQ SYSRET
SYSNTS:	INC B
	CMP B,#16.
	BLE SYSP1
	JSR PC,FLUSH
	JSR PC,RUNME
	CLR B
SYSP1:	CLC
	BR SYSLP2
SYSNT1:	MOV USER,D
	TST BRAKE(D)
	BNE SYSLP3
	INC B
	CMP B,#16.
	BLE .+4
	CLR B
	SEC
	BR SYSLP2
SYSRET:	JSR PC,SPOPT
	SEZ
	RTS PC
SYSLP3:	ERROR+BRK


SENDIT:	JSR A,SENSET	;SET UP FOR THE SEND
	BCC 1$
	RTS PC
1$:	MOV @S,B	;THE THING TO PRINT
	MOV B,A
	BIC #7777,A
	JSR PC,.CRLF	;PRINT CR. MESSAGE CR.
	JSR PC,PRDATA	;PRINT ON RECEIVERS TTY
	JSR PC,.CRLF
	JSR A,SENCLR	;GO BACK TO YOUR OWN TTY
	CLC
	RTS PC


SENSET:	SPUSH B		;SAVE B
	TST B		;IS IT A VALID USER NO.
	BGE .+4
SEDIT1:	ERROR+IUN	;INVALID USER
	CMP B,NUSERS	;IS IT TO BIG
	BGE SEDIT1	;YES
	SPUSH C		;SAVE C
	MOV USER,C
	MUL #L,B	;CHANGE INDEX TO USER NO.
	MOV UTTY(B),E	;GET RECEIVERS TTY NO.
	TST TIQN(E)	;DOES HE HAVE ANY INPUT?
	BNE SENDF	;YES, DON'T SEND ANYTHING YET
	SPUSH UTTY(C)	;SPUSH SENDERS TTY
	SPUSH E		;PUSH RECEIVERS TTY
	SPUSH FLSRES(B)	;SAVE RECEIVERS OLD FLUSH REASON
	SPUSH B		;PUSH RECIVERS USER NO.
	MOV #200,FLSRES(B)	;MAKE SURE HE DOESN'T RUN
	MOV E,UTTY(C)	;MAKE SENDERS TTY RECEIVERS OLD TTY
	MOV USER,TTYU(E)	;MAKE THE USER OF THAT TTY THE SENDER
	JMP (A)		;RETURN

SENCLR:	TST (P)+	;FLUSH OLD A AGAIN
	SPOP B		;RESTORE RECEIVERS USER NO.
	SPOP FLSRES(B)	;RESTORE RECEIVERS FLSRES
	SPOP E		;GET RECEIVERS TTY NO.
	MOV E,UTTY(B)	;PUT IT BACK AS HIS TTY
	MOV B,TTYU(E)	;MAKE THE TTY HIS AGAIN
	MOV USER,C	;GET SENDERS USER NO.
	SPOP UTTY(C)	;RESTORE SENDERS TTY NO.
	SPOP C		;RESTORE C AND B
	SPOP B
	CLC
	RTS A		;GET BACK OLD A AND RETURN
SENDF:	SPOP C
	SPOP B
	SEC
	RTS A

SEND:	SPOPS A
	SPOPS B
	SPUSHS A
	SPUSHS B
	JSR PC,G1NARG
	MOV USER,C
SEND1:	JSR PC,SENDIT
	BCC SEND2
	TST BRAKE(C)
	BNE SYSLP3
	BR SEND1
SEND2:	JSR PC,SPOPT
	SEZ
	RTS PC


.ENDC



	.STITL PRINTOUT (ONCE KNOWN AS SHOW)
SHALPR:		;SHOW ALL PROCEDURES
		;USES A-F
	JSR PC,GNOLEI
	BR SHALP2
SHALP1:	JSR PC,.CRLF
SHALP2:	JSR PC,GNOLE
	BEQ SHOWA1
	JSR PC,BURYQ
	BEQ SHALP2
	JSR PC,PSHOW
	BNE .+4
	.BUG.
	CMP PCHR,#TYO
	BNE SHALP2
	BR SHALP1

POTS:
SHALTI:	;SHOW ALL TITLES
	JSR PC,GNOLEI
SHATI1:	JSR PC,GNOLE
	BEQ SHOWA1
	JSR PC,BURYQ
	BEQ SHATI1
	JSR PC,SHTITL
	BR SHATI1

SHOWAL:	JSR PC,SHALPR	;SHOW ALL PROCEDURES
	JSR PC,SHALNA	;SHOW ALL NAMES
	TST WRTFLG	;DON'T SHOW ARRAYS ON WRITE
	BNE .+6
	JSR PC,POARR	;SHOW ALL ARRAYS
SHOWA1:	SEZ
	RTS PC

SHOW:	BIT #7777,CT	;ANY TOKENS LEFT
	BNE SHOW00	;YEP
	MOV TOPRNM,B
	BNE SHOW0
	MOV LASTPR,B
	BNE SHOW0
	ERROR+SHW

SHOW00:	JSR PC,GTUOEB
	BNE SHOW1	;THE TOKEN ISNT A USER PROC
SHOW0:	JSR PC,PSHOW
	BNE SHOWA1
	ERROR+PNH	;PROCEDURE NOT HERE
SHOW1:	CMP #SFUN,A
	BNE SHOWE1
	TST B	;IS IT CR?
	BNE SHOW12	;NO
	MOV TOPRNM,B
	BNE SHOW0
SHOWE1:	ERROR+SHW

SHOW12:	MOV #PODISP,A
SHOW13:	CMP (A)+,B
	BNE SHOW23
	JMP @(A)
SHOW23:	TST (A)+
	TST (A)
	BNE SHOW13
	ERROR+SHW

.IFNZ DDF
CNTRL:	CLR C
	INC C
	BR ALSO2
ALSO:	CLR C
ALSO2:	BIT #7777,CT
	BNE .+4
ALSOWH:	ERROR+WTAB
	JSR PC,GNT
	BIC #7777,A
	CMP #SFUN,A
	BNE ALSOWH
	TST B
	BEQ ALSOWH
.IFNZ ENG
	CMP #$STTUR,B
	BEQ TUR
.IFNZ NDISP
	CMP #$DISPLAY,B
	BEQ DIS
.ENDC
.IFNZ NPLOT
	CMP #$PLOTTER,B
	BEQ PLOT
.ENDC
.ENDC
.IFNZ FR
	CMP #$TORTUE,B
	BEQ TUR
.IFNZ NDISP
	CMP #$ECRAN,B
	BEQ DIS
.ENDC
.IFNZ NPLOT
	CMP #$TRACEUR,B
	BEQ PLOT
.ENDC
.ENDC
	BR ALSOWH
.IFNZ NDISP
DIS:	TST C
	BEQ .+6
	JMP CTRDIS
	JSR PC,EVAL
	BEQ TUR2
	JMP ASTRDI
.ENDC
TUR:	TST C
	BEQ TUR1
	JSR PC,EVAL
	BEQ TUR2
	JMP CTRTUR
TUR1:	JSR PC,EVAL
	BNE .+4
TUR2:	ERROR+WTAB
	JMP ASSTUR
.IFNZ NPLOT
PLOT:	TST C
	BEQ .+6
	JMP CTRPLT
	JMP ASSTPL
.ENDC

.ENDC


POT:	MOV TOPRNM,B	;SHOW THIS TITLE
	BEQ POL1
	JSR PC,SHTITL
	BNE POL2
	.BUG.

POL:	TST TOPRNM
	BNE .+4
POL1:	ERROR+OIP
	JSR PC,GTLN	;GEN LINE NO. FROM NEXT TOKEN INTO B
	BNE .+4
	ERROR+SHW	;SHOW WHAT??
	JSR PC,GTLP	;GET POINTER TO LINE
	JSR PC,.LOADC
	PUSHS B	;FOR PRLN
	JSR PC,PRLN	;PRINT LINE
	PRCR
	POPS C
POL2:	SEZ
POL3:	RTS PC
.POFILE:	JSR PC,EVAL
	BNE .+4
	ERROR+UELX
	JMP .POF

PSHOW:	;SHOW (B).  SKIP UNLESS (B) NOT A USER PROC
	JSR PC,SHTITL	;SHOW TITLE LINE, SKIPS IF PROC THERE
	BEQ POL3
	BIT #7777,A
	BEQ PSHOW4
	MOV A,C
	PUSHS #0
PSHOW3:	JSR PC,.LOADC
	MOV A,C
	MOV B,@S
	JSR PC,PRLN
	PRCR
	BIT #7777,C
	BNE PSHOW3
	POPS A
PSHOW4:	LANGC <PRTXTC ^\END\>,<
	PRTXTC ^/FIN/>
	CLZ
	RTS PC


PON:
SHALNA:		;SHOW ALL NAMES
		;USES A-F
	JSR PC,GNOLEI
SHALN1:	JSR PC,GNOLE	;GET NEXT UOE
	BEQ POL2+2
	MOV B,F
	MOV #VBIND,A
	JSR PC,.BINDL
	BEQ SHALN1	;NO THING FOR THIS UOE
	MOV B,C	;SAVE VALUE PTR
	MOV F,B	;GET UOE PTR
	TST WRTFLG
	BEQ SHALN2	;NO
	TST C		;IS VALUE = "UNBOUND"? (0?)
	BEQ SHALN1	;SKIP THIS ATOM
	SPUSH B
LANGC	<PRTXT ^/MAKE "/>,<
	PRTXT ^/RELIE "/>
	SPOP B
	JSR PC,PPNAME	;PRINT THE NAME
	PRTXT ^\ (\
	BR SHALN3
SHALN2:	JSR PC,PRUV	;PRINT THE NAME
LANGC	<PRTXT ^/ IS/>,<
	PRTXT ^/ EST/>
	TST C		;UNBOUND?
	BEQ SHALN5	;YES; JUST SAY SO
SHALN3:	SPACE
	SPUSHS C
	INC NBKTS
	JSR PC,PRS1
	ADD #2,S
	TST WRTFLG
	BEQ SHALN4
	PRTXT ^\ )\
SHALN4:	PRCR
	BR SHALN1

SHALN5:	PRTXT ^/ UNBOUND./
	BR SHALN4

POARR:	JSR PC,GNOLEI
POARR1:	JSR PC,GNOLE	;GET NEXT UOE
.IFZ <ENG&FR>
	BEQ POARR6
	.IFF
	BNE .+6
	JMP POARR6
.ENDC
	MOV B,F		;PTR TO UOE
	MOV #ABIND,A
	JSR PC,.BINDL	;GET ARRAY BINDING
	BEQ POARR1	;NO BINDING FOUND
	JSR PC,POARR5	;PRINT ARRAY NAME,SIZE,TYPE
	BR POARR1	;LOOK FOR MORE ARRAYS
POARR5:	MOV B,C		;SAVE VALUE PTR
	MOV F,B		;GET UOE PTR
	JSR PC,PPNAME	;PRINT THE NAME
LANGC	<PRTXT ^/ SIZE / >,<
	PRTXT ^/ DIMMENSION />
	MOV C,B	;SAVE VALUE PTR
	PUSH B
	JSR PC,ASIZE2	;PUTS DIMS. OF ARAY IN LIST
	MOV C,B		;PPTR TO LIST
	JSR PC,PRLST	;PRINT IT
	SPACE
	PRTXT ^/ TYPE/
	POP B		;VALUE PTR
	MOV 4(B),B	;TYPE/DIM WORD IN ARRAY HEADER
	BIC #7777,B	;GET THE TYPE
	BEQ POARR2	;TYPE POINTER
	CMP #FNUM,B
	BEQ POARR3	;TYPE FNUM
LANGC	<PRTXT ^/ INTEGER/>,<
	PRTXT ^/ NOMBRE ENTIER/>
	BR POARR4
POARR2: LANGC	<PRTXT ^/ POINTER/>,<
	PRTXT ^/ POINTEUR/>
	BR POARR4
POARR3: LANGC	<PRTXT ^/ FLOATING POINT/>,<
	PRTXT ^/ NOMBRE DECIMAL/>
POARR4:	PRCR		;CARRIAGE RETURN
	SEZ
POARR6:	RTS PC
PO1AR:	JSR PC,GTUOEB
	BEQ .+4
	MOV B,F
	MOV #ABIND,A
	JSR PC,.BINDL
.IFZ <ENG&FR>
	BNE POARR5
	ERROR+UDA
	.IFF
	BEQ .+4
	ERROR+UDA
	JMP POARR5
.ENDC

CONTEN:	;MAKE A LIST OF ALL ATOMS THAT HAVE A PROCEDURE
	JSR PC,SLISTB
	JSR PC,GNOLEI
CONTN1:	JSR PC,GNOLE
	BEQ CONTN2	;DONE
	JSR PC,BURYQ
	BEQ CONTN1
	MOV B,D
	JSR PC,.BINDF	;A PROCEDURE
	BEQ CONTN1	;NOPE
	MOV D,C
	JSR PC,.LOADC	;GET PNAME
	MOV #LSTR,A
	JSR PC,LISTB
	BR CONTN1
CONTN2:	JSR PC,FLISTB
	CLZ
	RTS PC
SHTITL:		;INPUT - UOE PTR IN B
		;OUTPUT - "SHOWS" TITLE LINE
		;	-A POINTS TO LLP NODE FOR 1ST LINE
		;	- SKIPS UNLESS NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BINDF
	BNE .+6
	JMP RETC
	MOV A,4(P)
LANGC	<PRTXT ^\TO \>,<
	PRTXT ^/POUR />
	MOV 2(P),B
	JSR PC,PPNAME
	MOV 4(P),C
	JSR PC,.LOADC
	MOV A,4(P)	;SAVE PTR TO NEXT NODE
	JSR PC,.LOAD	;#ARGS IN B
	BIT #7777,A	;ANY TOKENS LEFT?
	BEQ SHTI1
	MOV A,C
SHTI2:	SPACE
	JSR PC,.LOADC	;NEXT ARG
	MOV A,C
	JSR PC,PRTAB	;PRINT TOKEN
	BIT #7777,C
	BNE SHTI2
SHTI1:	PRCR
	JMP SRETC
PRLN:	PUSH A	;PRINT PROC LINE ON S
	SPUSH B
	SPUSH C
	SPUSH D
	INC NBKTS	;PRINT OUTER LIST BRACKETS
	BIC #DPQF,FLAGS2	;DO PRINT QUOTE BEFORE STRINGS
	MOV @S,C
	JSR PC,.LOADC	;PRINT LINE #
	MOV A,C
	JSR PC,PRTAB
	BIT #7777,C
	BEQ PRLN3	;DONE
	JSR PC,.LOADC	;CHECK FOR TYPE = SNUM
	MOV A,C	;THIS MEANS 2ND TOKEN IS A CLGN & SHOULDNT PRINT
	BIC #7777,A
	CMP #SNUM,A
	BNE PRLN4
	BR PRLN2
PRLN1:	JSR PC,.LOADC
	MOV A,C
PRLN4:	SPACE
	JSR PC,PRTAB
PRLN2:	BIT #7777,C	;DONE?
	BNE PRLN1	;NO
PRLN3:	DEC NBKTS
	JMP RETD
	.STITL TEXT
TEXTT:	;LISTIFY TEXT OF PROC ON (S)
		;OUTPUT ON S
	JSR F,CACSAV
	JSR PC,LISTIT	;LISTIFY THE TITLE
	CLR F	;FOR LISTB
	SPOPS TOPS	;PRESERVE TITLE FROM GC!!!!!
	JSR PC,LISTB	;THE TITLE LINE
	SUB #2,S	;WORK CELL
	BR TEXT2
TEXT1:	JSR PC,.LOADC	;GET NEXT LLP NODE
	MOV A,C	;SAVE PTR TO NEXT ONE
	MOV B,@S	;NPUT TO LISTLN
	JSR PC,LISTLN	;LISTIFY THIS LINE
	JSR PC,LISTB	;ADD TO LIST
TEXT2:	BIT #7777,C
	BNE TEXT1	;NOT DONE YET
	ADD #2,S	;POP WORK CELL
	BR LIL2
LISTIT:	;LISTIFY TITLE LINE OF PROC ON (S)
		;SKIP IF THERE
		;OUTPUT ON S AND IN A,,B.  C POINTS TO LLP NODE FOR 1ST LINE
	JSR F,CACSAV
	JSR PC,GUOEB	;GET UOE PTR FROM S
	BEQ LIT4	;NONE THERE
	MOV B,D	;SAVE UOE PTR
	CLR TOPS
	JSR PC,.BINDF	;GET PROC BINDING
	BEQ LIT4	;NONE THERE
			;RETURNS WITH FIRST NODE OF LLP IN A,,B
	JSR PC,.LOADA	;GET 2ND NODE
	MOV A,4(P)	;SAVE PTR TO 3RD NODE IN SAVED C
	JSR PC,.LOADB	;GET #ARGS NODE
LIT1:	PUSHS A
	JSR PC,LTOK	;LISTIFY THE DUMMY ARGS
	BEQ LIT4	;LOST???
	MOV #LSTR,A	;NOW ADD "TO FOO"
LANGC	<MOV #$TOTO,B>,<
	MOV #$POURX,B>
	JSR PC,GRBAD	;"TO"
	MOV D,B
	JSR PC,.LOADB	;GET PNAME PTR
	MOV @S,A
	MOV A,TOPS
	BIC #170000,A
	BIS #LSTR,A
	BIS #LIST,C
	MOV C,2(P)
	MOV #LIST,(P)
	MOV C,@S
	JSR PC,GRBAD1	;"FOO"
	BR LIL2
LIT4:	ERROR+HNM
LISTLN:	;LISTIFY PROC LINE ON S
		;OUTPUT ON S AND IN A,,B
		;SKIPS UNLESS BAD TOKEN
	JSR F,CACSAV
	MOV @S,C	;GET LLP  IN C
	JSR PC,.LOADC	;GET LINE # NODE
	MOV B,F		;SAVE IT
	MOV A,@S	;SAVE PTR TO REST OF LINE
	MOV A,B
	JSR PC,.LOAD	;GET NEXT TOKEN AND CHECK IF IT IS ALSO SNUM
	BIC #7777,B
	CMP #SNUM,B
	BNE .+6
	MOV A,@S	;IT IS - SKIP OVER IT
	JSR PC,LTOK	;LISTIFY THE REST OF THE TOKENS
	BEQ LIL1		;LOST
	MOV F,B	;NOW ADD LINE # ON FRONT.  GET IT FROM F
	JSR PC,.CSNLS	;CONVERT SNUM TO LSTR
	MOV B,TOPS	;PTR TO LSTR IS IN B - PROTECT FROM G..C.
	MOV @S,A	;PTR TO TOKEN-LISTIFIED
	BIC #170000,A
	BIS #LSTR,A
	JSR PC,GRBAD
	CLR TOPS
	BIS #LIST,C
	MOV C,@S	;OUTPUT ON S
	MOV C,2(P)	;AND IN SAVED A AND B
	MOV #LIST,(P)
LIL2:	JSR F,CACRES
	CLZ
	RTS PC

LIL1:	.BUG.
LTOK:	;LISTIFY TOKEN LIST ON S
		;OUTPUT ON S AND IN A,,B
		;SKIP UNLESS A "BAD" TOKEN IS FOUND
	JSR F,CACSAV
	POPS C	;GET PTR TO TOKEN LIST
	CLR F
	JSR PC,SLISTB
LTOK1:	BIT #7777,C	;ANY TOKENS LEFT
	BEQ LTOKF
	JSR PC,.LOADC	;GET NEXT TOKEN
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	CMP #SNUM,A
	BEQ LTOK1	;IGNORE SNUM'S
	CMP #UFUN,A
	BHI LTOKSF	;MUST BE SFUN OR INFIX
	BEQ LTOKUF	;A USER PROC
	MOV #':,D
	CMP #UVAR,A
	BEQ LTOKCT	;A USER VARIABLE
	MOV #'",D
	CMP #ATOM,A
	BEQ LTOKCT	;A STRING
	BHI LTOKBD
	CMP #LSTR,A
	BNE LTOKAD	;AN INUM OR LIST - OK AS IS
	JSR PC,CONCTL	;AN LSTR, ADD A "
	BR LTOKAD
LTOKBD:	JSR PC,FLISTB	;BAD TOKEN
	POPS A
	BR LIL2
LTOKUF:	JSR PC,.LOAD	;USER PROC
LTOK3:	MOV #LSTR,A
LTOKAD:	JSR PC,LISTB
	BR LTOK1
LTOKSF:	JSR PC,CVSFLS	;CONVERT SYSTEM FUNCTION TO LSTR
	MOV TOPS,B
	BR LTOK3
LTOKCT:	JSR PC,CONCT
	BR LTOK3
LTOKF:	JSR PC,FLISTB
	MOV A,(P)	;SAVED A
	MOV B,2(P)	;SAVED B
LIL3:	BR LIL2
CONCT:	;APPEND CHAR IN D TO BEGINING OF PNAME OF ATOM IN B
		;OUTPUT #LSTR,,PTR IN A,,B
	JSR PC,.LOAD	;GET PNAME PTR
CONCTL:	PUSH C
	MOV B,A
	BIC #170000,A
	BIS #SSTR,A
	MOV D,B
	JSR PC,GRBAD
	MOV C,B
	MOV #LSTR,A
	BIS A,B
	POP C
	MOV B,TOPS
	RTS PC
CVSFLS:	;CONVERT SFUN NAME TO LSTR
		;INPUT - A,,B SFUN OR INFIX TOKEN IN TOPS
		;OUTPUT -  LSTR PTR IN TOPS
	JSR F,CACSAV
	SPUSH PCHR
	JSR PC,BLSTI
	MOV #BLST,PCHR
	JSR PC,PROAB
	JSR PC,BLSTF
	BNE .+4
	.BUG.	;CANT HAVE NO CHARS!!
	POP PCHR
	BR LIL3
	.STITL ILINE & ERSET STUFF
ILINE:	;OUTPUT LAST LINE TYPED IN
	PUSHS ILINEL
	JSR PC,LTOK
	BNE ERRPR2
	.BUG.	;A BAD TOKEN??
ERRPRO:	;OUTPUT NAME OF PROC EXTENT AT LAST ERROR
	MOV NPROCL,B
	BEQ ERRPR1
	JSR PC,.LOAD
	PUSHS B
	CLZ
	RTS PC

ERRPR1:	PUSHS #LSTR
ERRPR2:	RTS PC
ERRLIN:	;OUTPUT LINE # EXTENT AT LAST ERROR
	MOV NLINEL,B
	BR NTOKE1
ERRTOK:	;OUTPUT TOKEN # EXTENT AT LAST ERROR
	MOV NTOKEL,B
NTOKE1:	JMP R1NARG
ERRLOC:	;OUTPUT ADDR OF LAST ERROR
	MOV LASTER,B
	BR NTOKE1
ERRNUM:	;OUTPUT NO. OF LAST ERROR
	MOV ERRBUF+4,B
	BR NTOKE1
ERRNAM:	MOV #4,C	;MAX CHARS
	MOV #ERRBUF,B	;POINT TO CHARS
	BEQ ERRPR1	;NEVER AN ERROR!
	JSR PC,BLSTI	;START AN LSTR
ERRNA2:	MOVB (B)+,D	;GET CHAR
	BEQ ERRNA1
	JSR PC,BLST
	SOB C,ERRNA2	;CONTINUE UNLESS DONE
ERRNA1:	JSR PC,BLSTF
	BEQ ERRPR1
	PUSHS TOPS
	CLZ
	RTS PC

ERRBREAK:	;OUTPUT BRAKE(U)
	MOV BRAKEL,B
	BR NTOKE1
ERRSET:	JSR PC,GTUOEB
	BEQ .+4
	ERROR+HNM
	MOV B,ERPROC
	SEZ
	RTS PC
ERRCLE:	CLR ERPROC
ERRC3:	RTS PC
ERNAME:	;ERASE NAME
	JSR PC,GTUOEB
	BEQ ERN2
ERN1:	CMP #UFUN,A	;AN SFUN OR INFIX?
	BGT .+4
	ERROR+ERW
	JSR PC,CVSFLS
	MOV #ATOM,A
	JSR PC,.OBSCH
	BEQ ERRC3
ERN2:	MOV #VBIND,A
	JSR PC,.UNBND
	SEZ
	RTS PC
	.STITLE ERASE
ERASE:	JSR PC,GTUOEB	;ERASE ...
	BNE ERASE1	;NOT A PROCEDURE
	JSR PC,ERPR
	BEQ ERASER
	SEZ
	RTS PC
ERASER:	ERROR+PNH	;PROCEDURE NOT HERE

ERASE1:	MOV #ERSDISP,A
ERASE2:	CMP (A)+,B
	BNE ERASE4
	JMP @(A)
ERASE4:	TST (A)+
	TST (A)
	BNE ERASE2
ERASE3:	ERROR+ERW	;ERASE WHAT
ERALL:	JSR	PC,ERALPR
	JSR	PC,ERALNA
	JSR PC,ERARAS
	JMP ERTL3
ERL:
ERLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GET LINE # IN B
	BEQ ERASE3
	NEG B		;SO ADLN WILL ERASE IT
	MOV #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	PUSHS C
	JSR PC,ADLN
	ADD #2,S	;POP S
ERL1:	SEZ
	RTS PC
ERPR:		;ERASE PROCEDURE (B)
	BIC #170000,B
	BIS #UFUN,B
	CMP B,TOPRNM
	BNE .+4
	ERROR+PBE	;PROCEDURE IS BEEN EDITED (UGH!!!)
	MOV #FBIND,A
	JMP .UNBND
ERALPR:		;ERASES ALL PROCEDURES
	TST TOPRNM
	BEQ ERALP2
	MOV TOPRNM,B
	BR ERPR
ERALP2:	JSR PC,GNOLEI
	MOV #FBIND,A
ERALP1:	JSR PC,GNOLE	;GET NEXT UOE
	BEQ ERL1+2
	JSR PC,BURYQ
	BEQ ERALP1
	JSR PC,.UNBND
	BR ERALP1
ERALNA:		;ERASE ALL NAMES
	JSR PC,GNOLEI
ERALN1:	JSR PC,GNOLE
	BEQ ERL1+2
	MOV #VBIND,A
	JSR PC,.UNBND
	BR ERALN1	;EVENTUALLY HAVE TO CHECK FOR SVBIND
ERFI:	JSR PC,EVAL
	BEQ ERINX1
	JMP .DELETE
ERINDX:	JSR PC,EVAL
	BNE .+4
ERINX1:	ERROR+UELX
	JMP .DELI
	.STITL TRACE
EBURY:	BIC #TF6,TFLAGS
BURY1:	MOV #TPBF,D
	BR TRA3

ESTEP:	BIC #TF6,TFLAGS
STEP1:	MOV #TPSF,D
	BR TRA3
ERTR:
ETRACE:	BIC #TF6,TFLAGS
TRA1:	MOV #TPTF,D
TRA3:	JSR PC,GTUOEB
	BNE TRA6
	JSR PC,CSSTF
	BNE TRA11
TRA5:	ERROR+PNH	;PROC NOT HERE
TRA6:	CMP #SFUN,A
	BNE TRA5
	.IFNZ ENG
	CMP #$ALL,B
	BEQ TRA10
	.ENDC
	.IFNZ FR
	CMP #$TOUT,B
	BEQ TRA10
	.ENDC
	ERROR+ERW
TRA10:	JSR PC,GNOLEI
TRA7:	JSR PC,GNOLE
	BEQ TRA9
	CMP #TPBF,D	;UNBURY BURIED PROCS
	BEQ TRA8
	JSR PC,BURYQ	;BUT DON'T TRACE UNTRACE STEP OR UNSTEP THEM.
	BEQ TRA7
TRA8:	JSR PC,CSSTF
	BR TRA7

CSSTF:	JSR PC,.BNDFS
	BEQ TRA9
	MOV B,C	;B POINTS TO LIST OF GOODIES. FIRST IS FLAGS,,#ARGS
	JSR PC,.LDP2
	BIC D,A
	BIT #TF6,TFLAGS
	BEQ TRA2
	BIS D,A
TRA2:	JSR PC,.STP2
	CLZ
TRA9:	RTS PC
TRA11:	SEZ
	RTS PC

BURYQ:	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	BEQ BURYQ1
	JSR PC,.LOADB
	BIT #TPBF,B
	BEQ .+6
BURYQ1:	JMP RETC
	JMP SRETC

TRACE:	BIS #TF6,TFLAGS
	BR TRA1
STEP:	BIS #TF6,TFLAGS
	BR STEP1
BURY:	BIS #TF6,TFLAGS
	BR BURY1

STRACS:	BIT #TRACEF,FLAGS2
	BEQ TRA9
	SPACE
	BR STRA1
STRACE:	BIT #TRACEF,FLAGS2	;SYSTEM TRACE
	BEQ TRA9
STRA1:	INC NBKTS
	PUSH A
	PRTXT ^/CT=/
	BIC #DPQF,FLAGS2
	JSR PC,PRCT
	PRTXT ^/ CO=/
	JSR PC,PRCO
	PRTXT ^/ S=/
	BIC #DPQF,FLAGS2
	JSR PC,PRS1
	PRCR
	CLR NBKTS
	POP A
	RTS PC

SETSTF:	BIS #TRACEF,FLAGS2	;SET SYSTEM TRACE FLAG
	SEZ
	RTS PC

CLRSTF:	BIC #TRACEF,FLAGS2
	SEZ
	RTS PC

FLEV:	MOV FUNLEV,B	;RETURN USER PROC CALL DEPTH
FLEV1:	JMP R1NARG
NODES:	;OUTPUT NO. OF NODES IN FREE STG LIST
	MOV NNIFSL,B
	BR FLEV1
.STITL	UTILITY ROUTINES

GOODBYE:	MOV USER,U
	JSR PC,RUNME
LANGC	<CPRTXT ^/AND A PLEASANT DAY TO YOU!/>,<
	CPRTXT ^/BONNE JOURNEE/>
	BR HELLO2

HELLO:	MOV USER,U
	JSR PC,RUNME	;IN CASE CALLED BY GUN
HELLO2:	JSR PC,.CLOSF	;CLOSE THE FILE IF OPEN
	PRCR
	MOV #LOCKUS,D
	JSR	PC,LCUGRB
	JSR	PC,NODEV	;FREE ALL DEVICES
	MOV USER,U
	MOV #FRNEWU,FLSRES(U)
	CLR FLSADR(U)
	CLR BRAKE(U)
	MOV	UTTY(U),E
	JSR	PC,UCINIT	;INITIALIZE CONSOLE
	MOV SPDLP,P
	JMP NEXTUS

.TOP:	JSR PC,G1NARG		;GET THE GUY TO TOPLEVEL
	TST B			;REASONABLE?
	BGE .+4
TOPE:	ERROR+IFN		;BAD NUMBER
	CMP B,NUSERS		;BIG BAD NUMBER?
	BGE TOPE		;TOO BIG
	MUL #L,B		;MAKE A USER INDEX
	CLR FLSRES(B)		;MAKE HIM NOT FLUSHED
	MOV #1,BRAKE(B)		;MAKE HIM BRAKE
	SEZ
	RTS PC

GUN:	JSR	PC,G1NARG
	TST	B
	BGE	.+4
GUNE:	ERROR+IUN
	CMP	B,NUSERS
	BGE	GUNE
	MUL #LUBLK,B
	MOV B,U
	CLR	FLSRES(U)
	CLR	FLSADR(U)
	MOV PC,GUNSW(U)
	MOV	#GOODBYE,UPC(U)
	MOV PC,BRAKE(U)
	SEZ
	RTS PC


VERSN:	MOV LVERNF,B
	BR	RANDO1
RANDOM:
	MOV RNSEED,B	;GET OLD SEED
	MUL #71275,B	;MUL SEED BY GOOD NUMBER!!
	ADD #13713,B	;ADD ANOTHER GOOD NUMBER!! TO LOW ORDER PART
	MOV B,RNSEED	;THIS IS THE NEW SEED
	MOV B,A
	MUL #10.,A	;MULTIPLY IT BY 10
	MOV A,B		;HIGH-ORDER PART IS THE DESIRED DIGIT
	ADD #5,B
RANDO1:	JMP R1NARG
BELL:	MOV #7,D
	BR .+6
CR:	MOV #1,D
	JSR PC,TYO
	SEZ
	RTS PC
DEBUGL:	TST ALEVN
	BEQ DEBUG1
	PRTXTC ^\OFF\
	CLR ALEVN
	JMP ERTL2
DEBUG1:	PRTXTC ^\ON\
	MOV #1,ALEVN
DEBUG2:	SEZ
	RTS PC
SGCF:	JSR PC,CKSST
	BIS #MGCF,FLAGS2
	SEZ
	RTS PC
CGCF:	JSR PC,CKSST
	BIC #MGCF,FLAGS2
	SEZ
	RTS PC
STATUS:	BIT #SSF,FLAGS2
	BNE	STATU2	;IF ON TURN OFF
	JSR PC,TINECH
	JSR PC,RDSTR	;READ A STRING
	BEQ	STATU2	;EMPTY OR BREAK
	MOV @S,B	;SEE IF EQUAL TO "SECRET
	MOV #SECRET,C
	JSR PC,EQ.TXT
	BEQ STATU1	;NOPE
	BIS #SSF,FLAGS2	;YES
	POPS A	;POINTER TO STRING READ IN
	PRTXTC	^\ON\
	BR	STATU3
STATU1:	POPS	A
STATU2:	PRTXTC	^\OFF\
	BIC	#SSF,FLAGS2
STATU3:	JSR	PC,TIECH
	SEZ
	RTS PC

CKSST:	TST DEBSW
	BNE CKSST1
	BIT #SSF,FLAGS2
	BEQ .+4
CKSST1:	RTS PC
	ERROR+HNM1

SPNF:			;SET PRINT NODES FLAG
	BIS #PNNLF,FLAGS2
	SEZ
	RTS PC
CPNF:	BIC #PNNLF,FLAGS2	;CLEAR IT
	SEZ
	RTS PC

COMT:	.BUG.		;GNT SHOULD SWALLOW ALL COMMENTS;
			; THEY SHOULD NEVER BE SEEN BY EVAL

;EXAMINE AN ABSOLUTE LOCATION
EXAMINE: JSR PC,CKSST	;MAKE SURE USER IS PRIVILEGED
	JSR	PC,GLWANE	;GET A WORD OF ARGUMENT
	BEQ DEPO1
	MOV	#INUM,A
	MOV	#8.-10.,ABASE
	JSR	PC,CONVERT	;CONVERT ARGUMENT TO OCTAL NUMBER IN B
	BEQ DEPO1
	MOV B,C
	JSR PC,.LDP2
	MOV A,B
	BIC #1,B	;MAKE SURE NOT BYTE
	MOV (B),WVALUE	;SAVE CONTENTS FOR VALUE TO OUTPUT
	JSR	PC,PLOCB	;PRINT LOCATION & CONTENTS
	CLR	ABASE
	RTS PC

;DEPOSIT IN AN ABSOLUTE LOCATION
DEPOSIT:	JSR PC,EXAMINE	;PRINT LOCATION
	PUSH B		;SAVE LOCATION
	SPUSH	(B)	;AND FORMER CONTENTS
	JSR PC,RDSTR	;READ A LINE FROM THE TTY
	BEQ	DEPOS2	;EMPTY
	MOV #INUM,A
	MOV @S,B
	MOV	#8.-10.,ABASE	;MAKE FOLLOWING CONVERSION OCTAL
	JSR PC,CONVERT	;CONVERT TO NUMBER
	BNE .+4
DEPO1:	ERROR+WTAB	;CONVERSION FAILED
	MOV B,C
	JSR PC,.LDP2	;GET NUMBER BACK IN A
	POP D		;FORMER CONTENTS
	SPOP B		;LOCATION
	MOV A,WVALUE	;SAVE NEW VALUE AS CONTENTS
	MOV A,(B)	;DEPOSIT
	CMP	(B),D
	BEQ	DEPOS1	;BR IF LOCATION NOT CHANGE
	TST USER
	BLE DEPOS1	;IF USER ALREADY ON SYSTEM CONSOLE
	JSR A,SPRINT
	JSR PC,PLOCB	;PRINT LOC AND NEW CONTENTS
	PRTXT ^/ WAS: /
	MOV D,A
	JSR PC,PRON	;PRINT OLD CONTENTS
	PRCR
	SPREND
DEPOS1:	CLR	ABASE	;SET CONVERT BASE BACK TO DECIMAL
	RTS PC		;DONE.
DEPOS2:	POP B
	SPOP B
	BR DEPOS1


;OUTPUT LAST CONTENTS SEEN IN AN EXAMINE OR DEPOSIT
VALUE:	MOV WVALUE,B
	JMP R1NARG
	.STITL ERRORS AND HANDLER
EMTBK:	MOV #SRET,@P	;FAKE IT OUT
	RTT
ERRBK:	PUSH A
ERBK2:	MOV #WDIRSW,D
	JSR PC,LCUGRB
	MOV #PGRAB,D
	JSR PC,LCUGRB	;RLEASE PAPER TAPE
	TST REDFLG
	BEQ ERBK3	;FINISH UP PENDING PROC DEF
	CLR FILFLG
	TST TOPRNM
	BEQ ERBK3
	JSR PC,END
ERBK3:	TST WRTFLG
	BEQ .+6
	JSR PC,WDELBL
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	MOV 2(P),A
	MOV A,LASTER
	MFPI -2(A)	;GET ERROR NUMBER (CROCK!!!)
	MOV (P)+,A
	BIC #177400,A
	CMP A,ERRORN	;SAME OLD ERROR?
	BEQ ERBK4
	MOV A,ERRORN
	ASL A
	SPUSH 	B
	SPUSH A
	JSR PC,SYDRBG
	CLR (A)+
	SPOP B
	MOV ERTAB(B),(A)
	SUB ERTAB+2(B),(A)
	ASR (A)+
	SPUSH C
	SPUSH F
	MOV USER,F
	MOV SLOTAS(F),C
	MOV #ERRBUF-PURE,(A)
	MOV SLOTHA(C),F
	ADD SLOTCA(C),(A)+
	ADC F
	ASH #4,F
	MOVB F,6(A)
	SPOP F
	SPOP C
	CLR 2(A)
	MOV ERTAB(B),(A)
	ASR (A)
	ADD ERBASE,(A)+
	ADC (A)
	ADD ERBASE+2,(A)+
	TST (A)+
	BISB #DREADC,(A)
	JSR PC,DSKWAI
	MOV #ERRBUF,ERRPT
	SPOP B
	MOV ERRORN,A
ERBK4:	CLR NTOKEL
	CLR NLINEL
	MOV CPP,NPROCL
	BEQ ERBK5
	MOV CPLN,NLINEL
	MOV CTN,NTOKEL
ERBK5:	CMP A,#BUG	;DONT ALLOW ERRSET FOR .BUG. OR FBUG
	BEQ ERSET3
	CMP A,#FBUG
	BEQ ERSET3
	TST ERPROC	;ERROR SET ON?
	BEQ ERSET2
	JSR F,CACSAV
	PUSH CO
	SPUSH CO+2
	SPUSH NOR
	MOV USER,U	;SAVE BRAKE STATUS
	SPUSH BRAKE(U)
	CLR BRAKE(U)
	MOV (P),BRAKEL
	BEQ .+6	;IF THERE REALLY WAS A BRAKE PENDING,
	JSR PC,BRAKR	;ALLOW TYPEOUT AGAIN
	SPUSH ERPROC
	MOV ERPROC,CO+2
	CLR ERPROC
	JSR PC,SAVPPS	;YES - SAVE THE PDLS
	BIS #1,CSPDLP	;INDICATE ERRORSET PUSH
	BIS #1,CPDLP
	MOV #UFUN,CO
	CLR NOR
	BIC #DORF,FLAGS	;NOTE THAT THIS IS NOT A RUN FRAME
	JSR PC,PEVAL
	BEQ ERSET1	;DIDNT OUTPUT
	JSR PC,PRS1	;DID OUTPUT, PRINT IT
	JSR PC,RESPPS
	POP ERPROC
	JMP ERTLN	;THEN ERROR RETURN
ERSET1:		;DIDNT OUTPUT, DO WHAT U WERE GOING TO
	JSR PC,RESPPS
	POP ERPROC
	MOV USER,U
	SPOP BRAKE(U)
	SPOP NOR
	SPOP CO+2
	SPOP CO
	JSR F,CACRES
ERSET2:
	TST NOADDR
	BNE NEWER4
ERSET3:
	MOV 2(P),A
	JSR PC,PRONL	;PRINT ADDR WHERE ERROR OCCURED
	SPACE
NEWER4:	MOV #ERRBUF+6,ERRPT
	.IFNZ ENG&FR
	BIT #FRFLG,LANG
	BEQ NEWER1
	INC ERRPT
	TSTB @ERRPT
	BNE .-10
	INC ERRPT
	.ENDC
NEWER1:	MOVB @ERRPT,D
	BEQ ERTLN
	BGT NEWER2
	BIC #177600,D
	ASL D
	MOV ROTTAB(D),A
	INC NBKTS
	JSR PC,(A)
NEWER3:	INC ERRPT
	BR NEWER1
NEWER2:	JSR PC,TYO
	BR NEWER3
ERRRT:	POP A
	RTT

PPLACE:	MOV FUNLEV,A
	BEQ PPLAC1
.IIF NZ AI,BR PPLAC1
LANGC	<CPRTXT ^\AT LEVEL \>,<
	CPRTXT ^/AU NIVEAU />
	JSR PC,PRDN
LANGC	<PRTXT ^\  LINE \>,<
	PRTXT ^/ LIGNE />
	MOV CPLN,A
	JSR PC,PRDN
LANGC	<PRTXT ^\  IN \>,<
	PRTXT ^/ DE />
	MOV CPP,B
	JSR PC,PPNAME
PPLAC1:	JMP .CRLF

ERTLN:			;ERR RETURN TO LEVEL N
	TST ALEVN
	BEQ ERTL0
ERPO1:
	.IIF NE WADESW,JSR PC,RRPOP
	BIS #ERRF+BRKF,FLAGS
	MOV USER,U
	CLR BRAKE(U)
ERTLN1:	JSR PC,PPLACE
	JMP MLOOP
ERTL0:			;ERR RETURN TO LEVEL 0
	MOV	USER,U
	CLR	BRAKE(U)
ERTL01:
	.IIF NE WADESW,JSR PC,RRPOP
	JSR PC,PPLACE
EXIT:
ERTL2:	TST FUNLEV	;POP UP TO LEVEL 0
	BLE ERTL3
	MOV #ERTL2,PSTOPR
ERTL4:	MOV #PSTP15,A
	MOV A,ERFRET	;SET UP ERROR FRAME RETURN
	MOV A,DOFRET
	JMP (A)
ERTL3:	CLR A	;CLEAR OUT PDLS
	JSR PC,PPTA
	CLR A
	JSR PC,PSTA
	CLR CSPDLP
	CLR CPDLP
	MOV #ERCLR1,A
	MOV #<ERCLR2-ERCLR1>/2,B
	CLR (A)+
	SOB B,.-2
	BIC #EDTIF+ERRF+BRKF,FLAGS
	JMP MLOOP

	;POP RUN AND READ FRAMES
RRPOP:	SPOP C	;SAVE RETURN ADDR
ERTLN2:		BIT #DORF,FLAGS
	BEQ ERTLN4
ERTLN3:	JSR PC,RESPPS
	SPOP B
	BIT #TF7,TFLAGS
	BEQ ERTN32
	MOV B,ERPROC
	BR ERTLN3
ERTN32:	JSR PC,RESEVL
	MOV B,FLAGS
	BR ERTLN2
ERTLN4:	JMP @C

	.STITL ERROR ROUTINES
		; ****  THESE ARE NOW ALPHABETIZED   *****

.IIF NDF MAXELN,MAXELN==0

BRK.R:	MOV USER,U
	MOV BRAKE(U),A
	CLR BRAKE(U)
	JSR PC,BRAKR
	TST A
	BLT PAUSE
BRK.2:
	JSR	PC,BRKMOF	;TURN OFF MUSIC BOX IF HE HAS IT
LANGC	<PRTXT ^\STOPPED\>,<
	PRTXT ^/ARRET/>
	JMP ERTL01

PAUSE:	BIS #BRKF,FLAGS
	SPUSH	MUCWRD	;SO THAT CONTINUE WILL WORK (GROAN)
	JSR	PC,BRKMOF	;TURN OFF MUSIC BOX IF HE HAS IT
	SPOP	MUCWRD
	PRTXT ^\PAUSE \
	JMP ERTLN1

BUG.R:	TST	DEBSW
	BNE	BUG.1	;BR IF DEBUGGING
	DEC NSYBUG
	BGE .+4
	ERROR+FBUG
BUG.1:	PRTXT ^/HELP!!!  SYSTEM BUG VER=/
	MOV #VERNF,A
	JSR PC,PRDN
	JSR PC,.SPACE
	PUSH	E
	SPUSH	U
	MOV	USER,U
	MOV	UTTY(U),E
	TST	TOTN(E)
	BGT	.-4	;WAIT TILL TYO BUF EMPTY
	POP	U
	SPOP	E
	SPOP A
	TST	DEBSW
	BEQ	.+4
BUGBPT:	BPT	;BRK IF IN DEBUG MODE
	MOV 6(P),A
	JSR PC,PRONL
	JMP ERTLN

CTIT.R:	MOV TOPRNM,B
	JMP PPNAME

HNM.R:	MOV #UFUN,A
	JMP PROAB

LDE1.R:	MOV JPLN,CPLN	;MAKE JUMPED-FROM LINE = POINT OF ERROR
WTIB.R:	MOV B,A
	JMP PRDN	;LINE # SHOULD BE IN A

TDE.R:	ASR	E
	MOV	E,A
	JMP	PRDN

PAE.R:	MOV #UFUN,A
	MOV TEMP,B
	RTS PC

PNH1.R:	MOV CPP,B
	MOV #UFUN,A
	RTS PC

TMAP.R:	TST (P)+
	JMP ERRRT

WTA.R:	RTS PC

WTAA.R:	PUSHS A
	RTS PC

WTAB.R:	PUSHS B
	RTS PC
	.STITL	MUSIC PRIMITIVES
	VERN==VERN+%FNAM2

SING:	EXCH (P),2(P)
	JSR	PC,MCHK
	JSR	PC,REVS	;FOR MULTIPLE ARGUMENTS
	MOV	(SP)+,D	;NUMBER OF ARGS
	ASR	D	;IS IT EVEN?
	BCC	SING2
	ERROR+WNA	;WRONG NUMBER OF ARGS
SING2:	MOV	VOICEN,E	;INDEX FOR VOICE (0,2,4 OR 6)
	MOV	VLAST(E),F	;POINTER TO LAST NODE IN VOICE
SING3:	DEC	D
	BGE	SING31
	SEZ
	RTS PC
SING31:	JSR	PC,G2NARG	;DURATION IN B, PITCH IN A
	JSR	PC,SINGNO	;NORMALIZE MIDDLE C TO 0.  ERROR IF NOTE OUT OF RANGE
	TST	B	;DURATION
	BGE	SING7
SING6:	ERROR+DOR	;DURATION OUT OF RANGE
SING7:	CMP	B,#177	;LARGEST LEGAL DURATION (+- 7 BITS)
	BGT	SING6
	ADD	B,VOICLN(E)	;ACCUMULATE TOTAL FOR VOICE
	CMP	B,#1
	BLT	SING3	;IF ZERO THEN GO ON
	BNE	SING8
	NEG	B	;IF 1 THEN SET TO -1 AS FLAG FOR PERFORM
SING8:	SWAB	A
	BIC	#177400,B	;CLEAR TOP HALF
	BIS	A,B	;SET UP 8 BITS PITCH, 8 BITS DURATION IN B
	JSR	PC,ACTSTO	;BUILD ON TO VOICE LIST
	MOV	F,VLAST(E)	;NEW LAST NOTE
	BR	SING3


;NORMALIZE MIDDLE C TO 0
;ERROR IF NOTE OUT OF RANGE.
SINGNO:	ADD	#74,A	;NORMALIZE 0 TO MIDDLE C
	CMP A,#MBTRAP
	BEQ SINGN1
	CMP	A,#MBREST	;SMALLEST VALID PITCH
	BGE	SINGN2
SINGN1:	ERROR+NOG	;NOTE OUT OF RANGE
SINGN2:	CMP	A,#137	;HIGHEST VALID NOTE
	BGT	SINGN1
	RTS	PC
NOMUSIC:
	MOV USER,A
	MOV UTTY(A),E
	BIT #PTBF,TTYST(E)
	BEQ NOMUS1
	MOV #PMBOX,A
	JSR PC,TBCHK
	BEQ NOMU9
	BIC #INITF,(A)
	BR MUSIN
NOMUS1:	MOV	#MBDN,E
	JSR	PC,CLOSE2
	BNE	NOMU9	;BR IF NOT OPEN ANYWAY
	BR	MUSIN	;ELSE CLEAR OUT MUSIC VOICES, ETC.

;TRY TO GET MUSIC BOX AND INITIALIZE
;IF DON'T ALREADY HAVE IT
MCHK:	MOV USER,A
	MOV UTTY(A),E
	BIT #PTBF,TTYST(E)
	BEQ MCHK1
	MOV #PMBOX,A
	JSR PC,TBCHK
	BNE .+4
	ERROR+DNR
	BIT #INITF,(A)
	BNE NOMU9
	BIS #INITF,(A)
	BR MUSIN
MCHK1:	MOV	#MBDN,E
	CMP	A,TTYU(E)
	BEQ	NOMU9	;BR IF ALREADY OPEN
	JSR	PC,OPEN1
MUSIN:	MOV	#100,MUCWRD	;FOR NVOICES 4
	MOV	#MUSBEG,A
MUSIN1:	CLR	(A)+
	CMP	A,#MUSEND
	BLT	MUSIN1
	MOV	#MVOC,A	;CLEAR OUT THE POINTERS IN USER SPACE
	CLR	(A)+
	CLR	(A)+
	CLR	(A)+
	CLR	(A)+
	JSR	PC,MCL	;SET UP DUMMY NODES
	MOV	#6,NVOIC	;NUMBER OF VOICES
NOMU9:	SEZ
	RTS	PC

TBCHK:	SPUSH B
	SPUSH C
	MOV #NPTBOX,B
	MOV #PTBOX0,C
TBCHK1:	CMP USER,(C)+
	BEQ TBCHK2
	ADD #4*2,C
	SOB B,TBCHK1
TBCHSZ:	SPOP C
	SPOP B
	SEZ
	RTS PC
TBCHK2:	MOV #4,B
TBCHK3:	CMPB A,(C)
	BEQ TBCHCZ
	TST (C)+
	SOB B,TBCHK3
	BR TBCHSZ
TBCHCZ:	MOV C,A
	SPOP C
	SPOP B
	CLZ
	RTS PC
			;SET UP DUMMY MUSIC LISTS
MCL:	MOV	#6,F
	CLR	B
	MOV	#LSTR,A
MCL2:	MOV	MVOC(F),TOPS	;FREE MUSIC NODES
	JSR	PC,FRELST
	JSR	PC,GRBAD	;GET A NEW NODE
	BIS	A,C
	CLR	B
	JSR	PC,.STORE
	MOV	C,MVOC(F)	;POINTER TO IT
	MOV	C,VLAST(F)
	CLR	VOICLN(F)
	SUB	#2,F
	BGE	MCL2
	RTS	PC

MCLEAR:	JSR	PC,MCHK
	JSR	PC,MCL
	SEZ
	RTS PC
VLEN:	JSR	PC,MCHK	;OUTPUT LENGTH OF CURENT VOICE
	MOV	VOICEN,B
	MOV	VOICLN(B),B
	JMP	R1NARG

MLEN:	JSR	PC,MCHK
	MOV	#4,D
	MOV	#VOICLN,F
	CLR	B
MLEN1:	MOV	(F)+,A	;GET MAXIMUM VOICE LENGTH
	CMP	A,B
	BLE	MLEN2
	MOV	A,B
MLEN2:	DEC	D
	BNE	MLEN1
	JMP	R1NARG
GTVARG:	JSR	PC,G1NARG
	DEC	B	;TRANSFORM VOICE NUMBER (1,2,3,4) TO INDEX (0,2,4,6)
	ASL	B
	TST	B
	BGE	GTV2
GTV1:	ERROR+IVV	;INVALID VOICE NUMBER
GTV2:	CMP	B,#6
	BGT	GTV1
	RTS	PC

VOICE:	JSR	PC,MCHK
	JSR	PC,GTVARG
	MOV	B,VOICEN
	SEZ
	RTS PC

NVOICES:	JSR	PC,MCHK
	JSR	PC,MCL	;REINITIALIZE
	JSR	PC,GTVARG
	MOV	B,NVOIC	;SET NEW VOICE NUMBER
	SEZ
	RTS PC

MBON:	MOV #MBDN,E
	MOV	NVOIC,A
	ASR	A	;TURN INTO BYTE INDEX
	MOV	A,B
	CMP	#2,A	;IN NVOICES 3,
	BNE	MBON1
	INC	A	;IT IS NECESSARY TO SILENCE 4 VOICES
MBON1:	MOVB	MBSCH(A),D	;CHAR FOR A VOICES, BUT ALL SILENT
	JSR	PC,MUCTYO
	MOV	#MBREST,D
	INC	A
MBON2:	JSR	PC,GTYO	;OUTPUT REST
	SOB	A,MBON2
	MOVB	MBVCH(B),D	;CONTROL CHR  FOR NUMBER OF VOICES
	MOV	D,MUCWRD
	JSR	PC,MUCTYO	;LEAVE BOX READY FOR NOTES
	RTS	PC

;SILENCE MBOX, BUT DON'T CHANGE NUMBER OF VOICES OR ANYTHING
MBOFF:	MOV	MUCWRD,D
	BIC	#177774,D	;LEAVE NUMBER OF VOICES INFO INTACT
	BIS	#100,D
	MOV	D,MUCWRD
	JSR	PC,MUCTYO
	RTS	PC

;CALLED BY BREAK AND PAUSE TO SHUT THE  DAMN THING UP
BRKMOF:	MOV	#MBDN,E
	CMP	U,TTYU(E)
	BNE	BRKMO9
	JSR	PC,MBOFF
	RTS	PC

;CALLED BY CONTINUE TO TURN MBOX BACK ON
BRKMON:	MOV	#MBDN,E
	CMP	U,TTYU(E)
	BNE	BRKMO9
	MOV	MUCWRD,D
	JSR	PC,MUCTYO
BRKMO9:	RTS	PC
			;OUTPUT MUSIC TO THE BOX
PM:	JSR	PC,MCHK
	JSR	PC,MBON
	MOV	NVOIC,A
	MOV	A,F	;USED AS POINTER TO CORRECT VOICE
	ADD	#VOICLN+2,A	;SET UP FLAGS IN VOICLN SLOTS
PM1:	MOV	#-1,-(A)
	CMP	A,#VOICLN
	BGT	PM1
PM2:	JSR	PC,PMCHP	;GRAB DUMMY NODE OF EACH VOICE
	JSR	PC,PMCHP	;NOW SET UP FIRST NODE OF MUSIC
PM21:	TST	-(F)
	TST	F
	BGE	PM2
PM3:	MOV USER,F
	TST BRAKE(F)
	BNE PM7
	CLR	F	;LOOP TO OUTPUT NOTES
PM4:	JSR	PC,PMNXT	;F IS INDEX TO VOICE
	TST	(F)+
	CMP	F,NVOIC	;ONE NOTE FROM EACH VOICE
	BLE	PM4
	CLR	B
	MOV	NVOIC,A	;ADD FLAGS FOR ALL VOICES
	ADD	#VOICLN+2,A
PM5:	ADD	-(A),B
	CMP	A,#VOICLN
	BGT	PM5
	TST	B	;IF ALL FLAGS CLEARED THEN DONE
	BNE	PM3
PM6:	JSR	PC,MBOFF
	JSR	PC,MCL	;REINIT MUSIC VARIABLES
	SEZ
	RTS PC
PM7:	JSR PC,TBREST
	BR PM6
			;OUTPUT ONE NOTE FROM VOICE(F)
PMNXT:	DEC	TEMP	;NOTE COUNTER
	MOV	#MBREST,D
	TST	VOICLN(F)	;IF FLAG CLEARED OUTPUT REST
	BNE	PMNXT2
	JSR PC,TMBTYO
	RTS	PC
PMNXT2:	CMPB	VLAST(F),#1	;IF DUR=1 PLAY A REST
	BEQ	PMNX2A
	MOVB	VLAST+1(F),D	;PITCH
PMNX2A:	JSR	PC,TMBTYO
	DECB	VLAST(F)	;DECREMENT DURATION
	BGT	PMNXT3
	JSR	PC,PMCHP	;IF DUR<=0 SET UP NEXT NODE
	RTS	PC
PMNXT3:	CMPB	D,#MBPERC	;IS THIS A PERCUSSION SOUND?
	BGT	PMNXT4	;NO
	MOVB	#MBREST,VLAST+1(F)	;YES--CHANGE ALL BUT FIRST TO RESTS
PMNXT4:	RTS	PC

PMCHP:	MOV	MVOC(F),C	;SET UP NEXT NODE SKIP IF SUCCESSFUL
	BIC	#170000,C
	BNE	PMCHP1
	CLR	VOICLN(F)	;CLEAR FLAG TO INDICATE NO NEXT NODE
	RTS	PC
PMCHP1:	JSR	PC,.LOADC
	BIC #170000,A
	BIS #LSTR,A
	MOV	A,MVOC(F)
	MOV	B,VLAST(F)	;PUT PITCH,,DURATION IN VLAST SLOT
	JSR	PC,.FREE	;FREE OLD NODE
	RTS	PC

TMBTYO:	SPUSH C
	MOV #PMBOX,C
	JSR PC,TBTYO
	SPOP C
	RTS PC

 	FOO==%FNAM2
	VERN==VERN+%FNAM2
	.STITL TURTLE,DISPLAY, RANDOM DEVICES, AND OTHER CRAP
;CONVERT ADDRESS TO DISPLAY PUSHJ
;ARGUMENT IS AC
.MACR MAKEPJ F
	ASR F
	ADD DRELOC,F
	BIS #DPUSHJ,F
.ENDM

;CONVERT DISPLAY CONTROLLER ADDRESSES TO REAL WORLD ADDRESSES
;	ARG IS AC
.MACR MAKEAD F
	SUB DRELOC,F
	ASL F
.ENDM
	.STITL RANDOM DEVICE CONTROL

.IFNZ AI

ATOD:	JSR PC,G1NARG
	TST B		;IS B NEGATIVE
	BLT ATODLS	;YES, SO NO GOOD
	CMP #7,B	;IS B TOO BIG A CHANNEL NO.?
	BLT ATODLS	;YES ITS BIGGER THEN 7
	ASH #10.,B
	MOV B,ATODB
	TST ATODB
	BPL .-4
	MOV ATODB,B
	BIC #176000,B
	SUB #1000,B
	JMP R1NARG
ATODLS:	ERROR+WTA	;HERE FOR BAD ARG TO ATOD


BITOUT:	JSR PC,G1NARG
	MOV B,DIGO
BITOU1:	SEZ
	RTS PC

RELAY:	JSR PC,G1NARG
	MOV B,F
	JSR PC,G1NARG
	MOV #1,C
	ASH B,C
	TST F
	BEQ RELAY1
	BIS C,DIGO
	BR BITOU1
RELAY1:	BIC C,DIGO
	BR BITOUT

DEVICE==160106	;THE ADDRESS OF THE BUFFER REGISTER
DEVADD==160104	;THE SELECTOR REGISTER

BOXIN:	JSR PC,G1NARG
	JSR PC,RDBOX	;READ THE BOX
	JMP R1NARG

SWITCH:	JSR PC,G2NARG
	CMP A,#15
	BGT SWTWTA
	TST A
	BLT SWTWTA
	JSR PC,RDBOX	;BOX NUMBER IN B, RETURNS THE BOX IN B
	MOV #1,C	;GET THE BIT
	ASH A,C		;SHIFT THE BIT THE NUMBER OF THE SWITCH
	BIT C,B		;IS THE BIT SET
	BNE .+6		;YES
	JMP RTFALS	;RETURN FALS
	JMP RTTRUE	;RETURN TRUE

RDBOX:	TST B		;IS IT NEGATIVE
	BGE .+4
SWTWTA:	ERROR+WTA	;BAD ARG
	CMP B,#3	;TO LARGE BOX NO.
	BGT SWTWTA
	ASH #10.,B	;THE NUMBER IS SHIFTED 10 PLACES
	MOV B,DEVADD	;TELL IT WHICH BOX TO READ
	CLR DEVICE	;TELL IT TO GO
	TST DEVICE	;DATA IN YET
	BPL .-4		;NOT YET
	MOV DEVICE,B	;GET THE DATA INTO B
	COM B		;THE BITS ARE COMPLEMENTED
	RTS PC

;ROUTINE FOR THE EYETURTLE.  WE WANT TO FILL A LOGO ARRAY WITH WHAT APPEARS
;A-TO-D CHANNEL, SAMPLING THAT A-TO-D 720 TIMES IN ONE ROTATION OF THE TURTLES'S
;EYE. THE TURTLE SENDS US A PULSE WHENEVER IT SHOULD BE SAMPLED
EYE:	SPUSH #1	;TELL AMAKE THERE IS ONLY ONE ARG
	SPUSH PS	;SAVE PSW AND PRIORITY
	MOV @S,A	;S POINTS TO ARRAY NAME
	JSR PC,AMAKE	;FIND TOP OF THE ARRAY
	ADD #2,S	;POP STACK
	CMPB 5(B),#260	;TEST TYPE BYTE
	BEQ .+4		;BRANCH IF IT'S AN INTEGER ARRAY
	ERROR+BAT	;BAD ARRAY TYPE
	CMP 10.(B),#720.;IS THE FIRST DIMENSION 720. LONG?
	BGE .+4		;AT LEAST THAT BIG
	ERROR+BAT	;TOO SMALL,TOO BAD
	CRDPOS==5	;USE INTERFACE LINE FIVE
;THE A-TO-D DEVICE BUFFER REFERRED TO ABOVE IS ALSO THE SWITCHBOX ADDRESS
;REGISTER. I DON'T KNOW WHY.
	ADD #12.,B	;B NOW POINTS TO FIRST ENTRY OF ARRAY
	MOV #CRDPOS,D
	ASH #10.,D	;THIS MAKES THE LINE-SELECTION ACCEPTABLE TO ADDRESS BUFFER
	MOV D,ATODB	;AND WE HAVE NOW SELECTED INTERFACE LINE FIVE.
	MOV #720.,C	;WE WANT 720. POINTS
	SPL 7		;LOCK OUT ALL INTERRUPTS
GNDATA:	CLR DEVICE	;TAP THE EYETURTLE ON THE SHOLDER,GET READY FOR A PULSE
	TST DEVICE	;DID WE GET A TIMING PULSE BACK YET?
	BPL .-4		;WAIT FOR THAT PULSE
	TST ATODB	;IS CONVERSION COMPLETE?
	BPL .-4		;NO, WAITî
	MOV ATODB,D	;YES, SO FIRST FUDGE WITH RETURNED VALUE
	BIC #176000,D   ;TO ELIMINATE THE SPURIOUSLY SET
	SUB #1000,D	;HIGH ORDER BITS. ARRAYS ARE DOUBLEWORDS
	TST (B)+	;SO INCREMENT THE POINTER,
	MOV D,(B)+	;AND SHOVE IN THE GOOD DATA
	SOB C,GNDATA	;IF NOT YET 720 POINTS GO GET ANOTHER
	SPOP PS		;RESTORE THE OLD PRIORITY
	SPOP A		;CLEAN THE P-PDL UP
	SEZ		;TELL EVAL THAT NOTHING IS BEING RETURNED
	RTS PC
.ENDC


.IF NE HALFLG
;ORBIT HACK--CALL WITH THE NAME OF ARRAY OF DATA
;THE FORMAT FOR THE DATA IS
;NUMBER OF ATTRACTIVE SOURCES
;NUMBER OF INTEGRATION STEPS PER CALL (<50)
;DT
;OBJECT	XPOS
;	YPOS
;	XVEL
;	YVEL
;	XFORCE
;	YFORCE
;	MINIMUM LEGAL RADIUS
;GRAV SOURCE XPOS
;	YPOS
;	DIST FROM OBJECT
;	FIELD CONSTANT
;THIS LAST BLOCK REPEATED FOR EACH SOURCE

;THE ROUTINE UPDATES THE VARIABLES

HALHACK:	SPOPS	A
	JSR	PC,AMAKE5	;B NOW POINTS TO ARRAY HEADER
	MOV	B,C
	CMP	(C)+,(C)+
	CMP	(C)+,#150001	;TYPE=FLOATING   #DIMS=1
	BEQ	.+4
	ERROR+BAT
	CMP	(C)+,(C)+
	MOV	(C)+,A	;ARRAY SIZE
	LDCFD	(C)+,FA
	LDCFD	(C)+,FB
	SETI
	STCFI	FA,D	;#OF ATTRACTORS
	STCFI	FB,B	;#OF INTEGRATION STEPS
	SETL
	TST	B	;POSITIVE?
	BGT	.+4
	ERROR+DOR
	CMP	B,#50.	;NOT TOO BIG (PIGGY)
	BLE	.+4
	ERROR+DOR
	ASL	D
	ASL	D
	ADD	#10.,D	;SIZE ARRAY SHOULD BE
	CMP	A,D
	BGE	.+4
	ERROR+ROB	;ARRAY TOO SMALL
	SUB	#3,D
	ASL	D
	ASL	D
	ADD	C,D	;POINTS TO LAST DATA WORD
	MOV	C,A
	ADD	#32.,A	;POINTS TO XPOS OF FIRST BODY
	PUSH	A
	SPUSH	D
;A NOW POINTS TO XPOS OF FIRST BODY
;B HAS NUMBER OF STEPS PER CALL
;C POINTS TO DT
;D POINTS TO CONSTANT FOR LAST BODY
;NOW COMPUTE THE FORCE ON THE OBJECT

	SETF
HALOP:	MOV	(P),D
	MOV	2(P),A
HALOP1:	LDF	4(C),FB	;POSITION OF OBJECT
	LDF	8.(C),FC
	SUBF	(A)+,FB	;DX
	SUBF	(A)+,FC	;DY
	STF	FC,FD
	MULF	FD,FD	;DY^2
	STF	FB,FA
	MULF	FA,FA	;DX^2
	ADDF	FD,FA
	JSR	PC,HALSQ	;GET SQRT OF FA INTO FD
	STF	FD,(A)+	;RADIAL DISTANCE FROM SOURCE
	CMPF	28.(C),FD	;IS RADIUS LESS THAN 10?
	CFCC
	BGT	HALERR
	MULF	FD,FA
	LDF	(A)+,FD	;FIELD CONSTANT
	DIVF	FA,FD	;K/(R*R^2)
	MULF	FD,FB	;FX=(ABOVE)*DX
	MULF	FD,FC
	ADDF	20.(C),FB
	STF	FB,20.(C)	;INCREMENT FORCE-X
	ADDF	24.(C),FC	;FORCE-Y
	STF	FC,24.(C)
	CMP	A,D
	BLO	HALOP1	;MORE FORCES?

;NOW DO THE INTEGRATION
	MOV	C,E
	LDF	(C),FB	;DT
HALOP2:	LDF	20.(C),FA
	MULF	FB,FA	;FORCE*DT
	ADDF	12.(C),FA	;V_V+A
	STF	FA,12.(C)
	MULF	FB,FA	;V*DT
	ADDF	4(C),FA	;R_R+V*DT
	STF	FA,4(C)
	CMP	C,E
	BHI	HALOP3
	ADD	#4,C	;NOW DO Y COORDINATE
	BR	HALOP2
HALOP3:	MOV	E,C	;RESTORE POINTER TO DT
	CLRF	20.(C)	;CLEAR THE FORCES
	CLRF	24.(C)
	SOB	B,HALOP
	SETD
	CMP	(P)+,(P)+	;FIX THE STACK
	SEZ
	RTS	PC

HALERR:	SETD
	ERROR+RTB
;SQUARE ROOT ROUTINE RETURN ROOT OF FA IN FD

HALSQ:	JSR	PC,PPUSHT
	STF	FB,-(P)	;SAVE FB
	STF	FA,FD
	DIVF	#40400,FD	;START ITER AT A/2
HALSQ1:	STF	FD,FB
	STF	FA,FD
	DIVF	FB,FD	;A/B
	ADDF	FB,FD
	DIVF	#40400,FD	;(B+A/B)/2
	SUBF	FD,FB
	ABSF	FB	;ERROR
	DIVF	FA,FB
	CMPF	#34000,FB	;ERR LESS THAN 2^(-15) ?
	CFCC
	BLT	HALSQ1
	LDF	(P)+,FB	;
	RTS	PC

.ENDC
.STITL DISPLAY AND TURTLE

;A  BRIEF DESCRIPTION OF WHAT IS LEFT TO BE DONE TO THIS PROGRAM.


;4)	DECIDING WHAT SNAP AND WIPE REALLY ARE GOING TO DO.
;AT THIS TIME, SNAP OUTPUTS THE ENTIRE SCREEN
;AND WIPE ERASES ONLY TOP LEVEL OCCURRENCES OF THE SNAP



;DISPLAY AND TURTLE COMMANDS
	.IFZ <NDISP!NPLOT>
	DLT==0
	DRT==1
	DFD==2
	DBK==3
	DPD==4
	DPU==5
	.ENDC
.IFNZ DDF
	CURY==4		;USED FOR INDEXING OFF CURX FOR
	CURA==10	;PLOTTER AND DISPLAY
	COSA==14
	SINA==20
	RCURX==24
.ENDC
BACK:	GTJUMP GTBACK
	MOV	#"@C,D	;D _ CHAR. TO SEND TO TURTLE
	MOV	#DBK,E	;IN ORDER TO CAUSE 1 STEP OF MOTION
	BR	TURD	;THE TOP BYTE CONTAINS THE CHAR.
LEFT:	GTJUMP GTLEFT
	MOV	#"BA,D	;IF THE NUMBER OF STEPS IS NEGATIVE
	MOV	#DLT,E
	BR	TURD
RIGHT:	GTJUMP GTRIGH
	MOV	#"AB,D	;E CONTAINS THE ADDRESS OF THE PARALLEL
	MOV	#DRT,E	;DISPLAY ROUTINE
	BR	TURD
FORWARD:	GTJUMP GTFORW
	MOV	#"C@,D
	MOV	#DFD,E
;THE MOVE COMMANDS ARE PROCESSED HERE


TURD:
.IFZ FPPF
	JSR	PC,G1NARG	;B_SINGLE PRECISION NUMBER
.IFF
	JSR PC,G1NUM	;FA_FLOATING NUMBER
	BNE .+4
	ERROR+WTAB
.ENDC
	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;DISPLAY, OR REAL TURTLE?
	BEQ	TURD.1
	JMP	(E)		;DISPLAY
	.ENDC
TURD.1:	BIT	#TURTF,DFLAGS
	BNE	TURD.A	;TURTLE
	.IFNZ	NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	TURD.E
	JMP	(E) ;HANDLE PLOTTER COMMAND LIKE DISPLAY
	.ENDC
TURD.E: ERROR+VTD   ;ONLY VALID FOR TURTLE,DSPLY,OR PLTR
TURD.A:
.IFNZ FPPF
	SETI		;IF IT'S A TURTLE CHANGE FLOATING
	STCFI FA,B	;TO AN INTEGER
	SETL
.ENDC
	TST	B
	BGE	TURD.2
	NEG	B	;MAKE NUMBER POSITIVE
	SWAB	D	;AND SWITCH CHARS
;NOW DO THE MOVING
TURD.2:	CMP	E,#DLT	;FOR LEFT OR RIGHT USE FUDGE FACTOR
	BEQ	TURD.0
	CMP	E,#DRT
	BEQ	TURD.0
	BR	TURD.3
TURD.0:	ASL B
	MOV B,A
	MOVB TURF,E	;MULTIPLY BY FIRST BYTE
	MUL E,A
	MOVB TURF+1,E	;DIVIDE BY SECOND
	DIV E,A
TUTE:	BVS TUTER	;OVERFLOW--LOSE.
	MOV A,B
	ASR B
	ADC B		;DIVIDE BY TWO, ROUNDING.
TURD.3:	MOV TURDN,E	;TURTLE DEVICE NUMBER (FOR TYO ROUTINES)
	SUB	#6.,B
	BLT	TURD.5	;NEVER EVEN MAKE IT TO FULL ACCELERATE MODE
	MOV	#10,C
	CLR A		;AGAIN, DIVIDE BY 4 (8)
	DIV #4,A
	MOV	B,F
		;REM.=NUMBER OF STEPS NEEDED BESIDES ACCELERATION
;		AND DECELERATION WHICH CAN'T BE TAKEN IN 8'S
	INC	F	;F_TOTAL NUMBER OF 1 STEPS
	JSR	PC,TUROUT
	ADD	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	MOV A,F	;F _ NUMBER OF 8 STEPS
	INC F
	ADD C,D	;D_CHAR FOR 8 STEPS
	JSR	PC,TUROUT
	SUB	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	SUB	C,D	;D_CHAR FOR 1 STEP
	JSR	PC,TURTYO
	SEZ
TURD.4:	RTS PC

;FOR FEWER THAN 14 STEPS, JUST SEND OUT 1 STEPS
;(IN THE WORS CASE, THIS STUPID ALGORITHM REQUIRES TWICE AS
;MANY CHARS AS THE OPTIMAL ALGORITHM)
TURD.5:	ADD	#6.,B	;RESTORE WHAT WAS SUBTRACTED
	MOV	B,F
	INC F		;MAKE SURE WE DO IT ONCE.
	JSR	PC,TUROUT
	BR	TURB.2
TUTER:	ERROR+TGDZ	;TURTLE GETTING DIZZY

;MORE TURTLE COMMANDS

LAMPON:	MOV	#'!,D
	BR	TURB
LAMPOFF:	MOV	#'",D

TURB:	JSR	PC,TURTST
TURB.1:	MOV	TURDN,E
	JSR	PC,TURTYO
TURB.2:	SEZ
	RTS PC


PENDOWN:	GTJUMP GTPD
	MOV	#'0,D
	MOV	#DPD,E
	BR	TURC
PENUP:	GTJUMP GTPU
	MOV	#'8,D
	MOV	#DPU,E

TURC:	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;TURTLE, OR DISPLAY?
	BEQ	TURC.1
	JMP	(E)
	.ENDC
TURC.1:	BIT	#TURTF,DFLAGS
	BNE	TURB.1
	.IFNZ NPLOT
	BIT #PLOTF,DFLAGS	;USING PLOTTER
	BEQ	TURC.2
	JMP (E)
	.ENDC
	
TURC.2: ERROR+VTD  ;ONLY VALID FOR TURTLE,DISPLAY,OR PLOTTER

TURTS1:	MOV	TURDN,E
TURTST:	BIT	#TURTF,DFLAGS
	BEQ	.+4
	RTS	PC
	ERROR+VTU


TOOT:	JSR	PC,G1NARG
	JSR	PC,TURTS1
	MOV	#"( ,D	;TOOT CHAR IN BOTTOM, NULL IN TOP
	MOV B,A
TOOT.1:	DEC	A	;HOW MANY TIMES TO TOOT
	BLT	TURB.2
	JSR	PC,TURTYO	;SHIP OUT TOOT CHAR
	MOV	#3,F	;THEN FOLLOW IT WITH 3 NULLS
	SWAB	D
	JSR	PC,TUROUT
	SWAB	D	;RETURN TOOT CHAR TO BOTTOM
	BR	TOOT.1

;TURTLE OUTPUT
;CALL WITH CHAR IN D, NUMBER OF TIMES IN F
TURO9:	JSR	PC,TURTYO
TUROUT:	MOV USER,B
	TST BRAKE(B)
	BNE TURDOR
	SOB	F,TURO9
TURDOR:	RTS	PC


TURTYO:	SPUSH C
	MOV #TURT,C
	BIS TURDN,C
	JSR PC,TBTYO
	SPOP C
	RTS PC



TOUCH:	PUSH	A
	JSR	PC,TURTS1
	MOV	#'#,D
	MOV USER,F
	MOV UTTY(F),F
	BIT #PTBF,TTYST(F)
	BNE TOUCH2
	JSR	PC,TBTW
TOUCH3:	POP	A
	BIT	A,D
	BEQ	TOUCH1
	JMP	RTFALS
TOUCH1:	JMP	RTTRUE
TOUCH2:	JSR PC,TURTYO	;SEND THE CHARACTER FOR READING SENSORS
	JSR PC,CTYI	;GET A CHARACTER	
	BIC #TIMAGI,TTYST(E)	;PUT IT BACK INTO LINE MODE IN CASE HE WANTS TO BREAK
	BIS #TILIPM,TTYST(E)
	BR TOUCH3	

FTOUCH:	MOV #20,A
	BR	TOUCH
BTOUCH:	MOV	#4,A
	BR	TOUCH
LTOUCH:	MOV	#10,A
	BR	TOUCH
RTOUCH:	MOV	#40,A
	BR	TOUCH
LFTOUC:	MOV #30,A
	BR TOUCH
RFTOUC:	MOV #60,A
	BR TOUCH
LBTOUC:	MOV #14,A
	BR TOUCH
RBTOUC:	MOV #44,A
	BR TOUCH

;LIGHT--RETURN INTENSITY SEEN BY TURTLE EYE
LIGHT:	.IFNZ NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	LIGHT1
	MOV	PLTCHR,B
	BIC	#177774,B	;ONLY 2 SIGNIFICANT BITS
	JMP	R1NARG
	.ENDC
LIGHT1:	JSR	PC,TURTS1	;CHECK TO SEE IF HE HAS A TURTLE
	MOV	#'#,D
	MOV USER,F
	MOV UTTY(F),E
	BIT #PTBF,TTYST(E)
	BNE LIGHT2
	JSR	PC,TBTW
LIGHT3:	MOV	D,B
	BIC	#177700,B	;ONLY 6 SIGNIFICANT BITS
	JMP	R1NARG
LIGHT2:	JSR PC,TURTYO
	JSR PC,CTYI
	BIC #TIMAGI,TTYST(E)
	BIS #TILIPM,TTYST(E)
	BR LIGHT3



;START TURTLE

.IFNZ DDF
ASSTUR:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4

STARTTURTLE:
	CLR A		;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STARTTURTLE:
.ENDC
	JSR	PC,G1NARG	;WHICH TURTLE
	TST	B
	BGE	.+4
STRTT1:	ERROR+ITN	;INVALID TURTLE NUMBER
	DEC	B
	CMP	B,#NTUR-1
	BGT STRTT1
STRTT2:	MOV USER,F
	MOV UTTY(F),E
	BIT #PTBF,TTYST(E)
	BEQ STRTT3
	MOV #TURT,A	;TYPE OF TURTLE
	ADD B,A		;WHICH TURTLE
	JSR PC,TBCHK	;CHECK TO SEE IF HE HAS IT
	BNE .+4
	ERROR+VTU
	MOV B,TURDN	;TURTLE NUMBERR
	MOV STURF,TURF	;USE TURTLE 1'S FUDGE FACTORS
	TST A
	BLT STRTT4
	PUSH B
	JSR PC,KILLT1	;KILL ANOTHER TURTLE
	JSR PC,KILLPL	;KILL ANOTHER PLOTTER
	POP B
	BR STRTT4
STRTT3:	ASL	B	;TURN INTO WORD INDEX
.IFZ DDF
	.IFNZ NDISP
	PUSH	B
	JSR	PC,KILLD1
	POP	B
	.ENDC
	JSR	PC,KILLT1	;KILL TURTLE IF HE ALREADY HAS ONE
	.IFNZ NPLOT
	JSR	PC,KILLPL
	.ENDC
.IFF
	PUSH B
	TST A		;KILL OTHER DEVICS?
	BLT ASTRT1	;NO
.IIF NZ NDISP, JSR PC,KILLD1
.IIF NZ NPLOT, JSR PC,KILLPL
	JSR PC,KILLT1
ASTRT1:	SPOP B
.ENDC
	MOV	TUDN(B),E
	JSR	PC,OPEN1	;TRY TO OPEN IT
	MOV	E,TURDN	;USER VARIABLE
	MOV	STURF(B),TURF	;TURTLE FUDGE FACTOR
STRTT4:	BIC	#<DISPF+PLOTF>,DFLAGS
	BIS	#TURTF,DFLAGS	;SET FLAG FOR CONTROL OF TURTLE
.IIF NZ DDF, BIS #TURTF,DIVOWN	;SET FLAG FOR OWNING TURTLE
	SEZ
	RTS PC

KILLTURTLE:
KILLT1:	MOV USER,E
	MOV UTTY(E),E
.IIF Z DDF,	BIT	#TURTF,DFLAGS
.IIF NZ DDF,	BIT	#TURTF,DIVOWN
	BEQ	KILLT9	;DOESN'T HAVE A TURTLE
	BIT #PTBF,TTYST(E)
	BNE KILLT3
	MOV	TURDN,E
	JSR	PC,CLOSE2
KILLT3:	BIC	#TURTF,DFLAGS
.IIF NZ DDF, BIC #TURTF,DIVOWN
KILLT9:	SEZ
	RTS	PC

NODEV:	.IFNZ NDISP
	JSR	PC,KILLD1
	.ENDC
	JSR	PC,NOMUSIC
	.IFNZ	NPLOT
	JSR	PC,KILLPL
	.ENDC
	JSR	PC,SLAM	;RELEASE ALL DEVICES FOR THIS USER
	MOV #PGRAB,D
	JSR	PC,LCUGRB
	MOV USER,U
	MOV UTTY(U),E
	BIT #PTBF,TTYST(E)
	BNE KILLT3
	RTS	PC

	.IFNZ   NPLOT
;STARTPLOTTER
.IFNZ DDF
ASSTPL:	CLR C		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM C
	BR .+4
STRTPL:	CLR C		;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STRTPL:
.ENDC
	MOV	#PLTDVN,E
	JSR	PC,OPEN1
.IFNZ DDF
	TST C		;SHOULD WE KILL OTHER DEVICES?
	BLT STRTP1	;NOPE
.ENDC
	JSR	PC,KILLT1   ;KILL TURTLE IF HE HAS ONE
	BIT	#DISPF,DFLAGS
	BEQ	STRTP1
.IIF NZ NDISP,	JSR	PC,KILLD2   ;KILL DISPLAY IF HE HAS ONE
STRTP1: MOV     #PORBEG,F   ;SETT [0 0 0]
	BIS     #PLOTF,DFLAGS     ;SET PLOTTER FLAG
.IFNZ DDF
	BIC #<DISPF+TURTF>,DFLAGS
	BIS #PLOTF,DIVOWN	;SET FLAG FOR OWNING PLOTTER
.ENDC
ZVAR:	CLR (F)+	;CLEAR USER'S PLOTTER VARIABLES
	CMP #POREND,F
	BNE ZVAR
.IIF NZ DDF,	BIS #PENUF,PLPENP	;SET PENUP FLAG IN PLOTTER 
	BIS     #PENUF,DFLAGS     ;START WITH PEN UP
	JSR	PC,ANGCRP	;INIT SINE AND COSINE
	CLR	B
	CLR	C
	JSR     PC,MTO.02     ;MOVE PLOTTER THERE
ZVAR1:	SEZ
	RTS	PC
;KILLPLOTTER
KILLPL:
	MOV	#PLTDVN,E
	JSR	PC,CLOSE2
.IIF NZ DDF, BIC #PLOTF,DIVOWN
	BIC	#PLOTF,DFLAGS  ;ELIM. PLOTTER FLAG
	BR ZVAR1
	.ENDC
;HERE IS WHERE THE DISPLAY PRIMITIVES START.
.IFNZ NDISP

;STARTDISPLAY
;	INITIALIZE EVERYTHING
;	ALLOCATE DISPLAY BUFFERS
.IFNZ DDF
ASTRDI:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4
STARTDISPLAY:	CLR A	;SET FLAG FOR KILLING OTHER DEVICES
.IFF
STARTDISPLAY:
.ENDC


;USE THIS PRIMITIVE TO SPECIFY A LARGE DISPLAY
	JSR	PC,G1NARG	;B _ #.  SHOULD BE 0 OR 1


STRTD0:	SPUSH	B	;THE KILLERS CLOBBER B
.IFNZ DDF
	TST A		;KILL OTHER DEVICES?
	BLT ASTRD1	;NO
.ENDC
	JSR	PC,KILLT1	;GET RID OF TURTLE IF NECSSARY
	.IFNZ	NPLOT
	JSR	PC,KILLPL   ;KILL PLOTTER IF HE HAS ONE
	.ENDC
.IFNZ DDF
ASTRD1:	BIT #DISPF,DIVOWN	;DOES HE ALREADY OWN ONE?
	BEQ ASD1	;YES
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLING DISPLAY
ASD1:
.ENDC

	BIT	#DISPF,DFLAGS	;DOES HE HAVE A DISPLAY?
	BEQ	STRTD1	;USER DOESN'T HAVE A DISPLAY YET
	JSR	PC,KILLD2	;KILL HIS PREVIOUS DISPLAY FIRST

STRTD1:	CLR	E	;GET E = USER NUMBER
	MOV	USER,F
	DIV	#L,E	;E _ QUOTIENT
;IS THIS USER A DISPLAY USER?
;I.E. IS THERE AN ACTUAL DISPLAY CONSOLE
;	ASSOCIATED WITH HIM?
	MOVB	DCONS(E),C	;C _ DISPLAY CONSOLE NUMBER
	BGE	.+4
	ERROR+NDU	;ALAS HE ISN'T A DISPLAY USER.

;NOW WE MUST ALLOCATE HIM A DISPLAY BUFFER
;FIRST DETERMINE WHAT SIZE BUFFER HE IS LOOKING FOR.
	SPOP	B
	JSR	PC,SDSIZE	;B _ SIZE (IN BLOCKS)
	JSR	PC,SDFIND	;A _ DISPLAY BUFFER NUMBER. (ERROR IF NO BUFFER)
	MOV	USER,U
	MOV	U,ASDIS(A)
	MOV	A,DISAS(U)	;SET DISPLAY ASSIGN
	JSR	PC,FLUSH	;AND LET RON SET THE MAP FOR THE DISPLAY 
	JSR	PC,RUNME
	JSR	PC,SDREL	;DRELOC _ RELOCATION (VA TO DISPLAY ADDRESSES)

;SET UP HIS DISPLAY PDL POINTER
	MOV	#<<DPDL_-1>&77777>,D
	ADD	DRELOC,D	;DISPLAY ADDRESS OF PDL
	MOV	D,DISPDL(C)

	MOV	#DORBEG,F	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,D	;LAST WORD
SDLOOP:	CLR	(F)+	;ZERO WORD
	CMP	F,D
	BLE	SDLOOP

.IFNZ DDF
	BIC #<PLOTF+TURTF+PENUF>,DFLAGS	;CLEAR VARIOUS FLAGS
	CLR DPENP		;START WITH THE PENDOWN
	BIS #DISPF,DIVOWN	;SET FLAG FOR OWNING DISPLAY
.ENDC
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY


;SET UP TURTLE VARIABLES
	MOV	#TLIST,D
	MOV	D,TUB
	MAKEPJ	D
	MOV	D,PUSHJT

;SET FIRST 2 WORDS OF DLIST
;AND SET THE BUFFER VARIABLES
	MOV	#DLIST,D
	MOV	#<DRSTXY!DPOP>,(D)+
	MOV	PUSHJT,(D)
	MOV	D,STB	;STATIC AREA BOTTOM
	MOV	D,STT	;STATIC AREA TOP

	ASH	#6,B	;B _ LENGTH OF DISPLAY IN BYTES.
			;USE THIS TO CALCULATE WHERE DYNAMIC AREA ENDS
	ADD	#DSLOT,B
	CLR	-(B)	;SET UP DUMMY FREE AREA
	MOV	B,DYT	;DYNAMIC AREA TOP
	CLR	-(B)
	MOV	B,DYB	;DYNAMIC AREA BOTTOM
	MOV	B,DYR	;DYNAMIC AREA ROVING POINTER

;GET DSTAT, A RANDOM GOODIE THAT THE INTERRUPT ROUTINES USE
;TO START UP DISPLAYS
	MOV	C,D
	ASR	D
	SWAB	D
	MOV	D,DSTAT(C)	;CORRECT POSITION TO MUNG NGCSR

;DRAW THE TURTLE
	PUSH	C
	JSR	PC,ANGCRP	;CALCULATE ANGLE CRAP
	JSR	PC,DR.TUR	;DRAW TURTLE
	SPOP	C

;NOW MAKE A PUSHJ TO THE DISPLAY LIST
;AND STUFF IT INTO THE HARDWARE FIRST LOCATION FOR THIS DISPLAY
	MOV	#DLIST,D
	MAKEPJ	D
	MOV	D,DISREL(C)

;AND LAST BUT NOT LEAST
	JSR	PC,NEWSN2	;SET UP FOR SNAPS TO START HERE
	MOV	#DISREL,NGREL	;JUST IN CASE
	SEZ
	RTS	PC
;SDSIZE
;	CALL WITH A NUMBER IN B. (SHOULD BE 0 OR 1 FOR NOW)
;	RETURNS THE SIZE OF DISPLAY (IN BLOCKS)
SDSIZE:	TST	B
	BGE	.+4
	ERROR+IDN
	CMP	B,#1
	BLE	.+4
	ERROR+IDN
	MOVB	DSIZES(B),B	;** IN BLOCKS **
	RTS	PC


;SDREL
;	COMPUTE THE DISPLAY RELOCATION
;	DRELOC = HOW MUCH TO ADD TO A VA/2 IN ORDER
;		TO TURN IT INTO A DISPLAY ADDRESS
SDREL:	MOV	DISAR(A),D	;STARTING BLOCK OF DISPLAY
	SUB	#<DISBTB+<<DISPPG_-6>&1777>>,D	;DISBTB IS DISREL/64
	ASH	#5,D	;SHIFT IT INTO A WORD RELOCATION
	MOV	D,DRELOC	;DRELOC IS A SLOT VARIABLE
	RTS	PC




;SDFIND
;	FIND A DISPLAY OF THE RIGHT SIZE
;	FIRST TRY TO FIND ONE THAT IS EXACTLY THE RIGHT SIZE
;	IF YOU CAN'T THEN FIND ONE THAT IS TOO BIG
;	RETURNS A = DISPLAY BUFFER NUMBER
;	B = SIZE OF THE DISPLAY BUFFER
SDFIND:	MOV	#-1,D
	MOV	NDISPS,A
	DEC	A
	ASL	A

SDFND1:	BLT	SDFND8	;HAVE RUN OUT OF DISLAYS TO TRY
	TST	ASDIS(A)
	BGE	SDFDEC	;IN USE BY SOMEONE ELSE
;THIS ONE IS FREE, BUT CHECK THE SIZE
	CMP	DLENGT(A),B	;B CONTAINS THE DESIRED SIZE
	BLT	SDFDEC	;TOO SMALL
	BGT	.+4
	RTS	PC	;WE WIN. A = DISPLAY NUMBER
	MOV	A,D	;HOLD ONTO THIS A IN CASE WE DON'T FIND
			;ONE EXACTLY THE RIGHT SIZE
SDFDEC:	SUB	#2,A	;DECREMENT A
	BR	SDFND1

;DIDN'T FIND A DISPLAY BUFFER OF EXACTLY THE RIGHT SIZE
;BUT D MAY CONTAIN ONE THAT WAS TOO BIG
SDFND8:	TST	D
	BGE	.+4
	ERROR+NDV	;NO DISPLAY AVAILABLE
	MOV	D,A	;A _ DISPLAY BUFFER NUMBER
	MOVB	DISDR+1(A),B	;B _ ACTUAL SIZE OF THE DISPLAY
	BIC #177400,B
	INC B
	RTS	PC

;KILLDISPLAY
;	USER WANTS TO GIVE UP HIS DISPLAY
KILLDISPLAY:
KILLD1:
.IIF NZ GTI,CLR GTIDF
.IIF Z DDF,	BIT	#DISPF,DFLAGS
.IIF NZ DDF,	BIT #DISPF,DIVOWN
	BEQ	KILLDR	;USER DOESN'T HAVE DISPLAY
KILLD2:	CLR	A	;GET USER NUMBER
	MOV	USER,B
	MOV	DISAS(B),C	;C _ DISPLAY BUFFER NUMBER
	MOV	#-1,DISAS(B)
	MOV	#-1,ASDIS(C)
	DIV	#L,A
	MOVB	DCONS(A),A
	MOV DSTAT(A),B
	MOV B,NGCSR
	MOV	#-1,DSTAT(A)
	MOV	#DSTOP,DISREL(A)
	BIS #TKSTOP,B
	MOV B,NGCSR
;	JSR	PC,SNZAP	;SET ALL SNAPS TO EMPTY-WORD
	CLR	SNLIST	;CLEAR  SNAPS
.IIF NZ DDF, BIC #DISPF,DIVOWN	;CLEAR DISPLAY FLAG
	BIC	#DISPF,DFLAGS
	JSR	PC,.GCOLL

KILLDR:	RTS	PC
.IFTF
DCHKPL: .IFNZ    NPLOT
	BIT     #PLOTF,DFLAGS      ;USING PLOTTER?
	BEQ	DCHK
	RTS	PC
	.ENDC
DCHK:
.IFF
	ERROR+VTU
.IFT
	BIT	#DISPF,DFLAGS
	BNE	DCHK1
	PUSH	B
	CLR	B	;SPECIFY A SMALL DISPLAY BUFFER
.IFNZ DDF
	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
.ENDC
	JSR	PC,STRTD0	;STARTDISPLAY
	SPOP	B
	RTS	PC
DCHK1:	CMP	NADXY,#20
	BLT	KILLDR	;DON'T BOTHER TRYING TO COMPRESS ADDXY'S
	JSR	PC,DSGC8	;TRY TO COLLAPSE
	BR	KILLDR

.ENDC
TBOX:	JSR PC,NODEV
	MOV #NPTBOX,A
	MOV #PTBOX0,B
TBOX2:	MOV (B),C
	TST C
	BLT TBOX1
	CMP USER,(B)
	BEQ TBOX1
	ADD #5*2,B	;BLOCK IS 5 WORDS LONG
	SOB A,TBOX2
	ERROR+NTB
TBOX1:	MOV USER,(B)+
	CLR E
	CLR A
	INC A
TBOX3:	CMP A,#5
	BEQ TBOX4
	SPUSH A
	SPUSH E
	PRTXT ^\PORT \
	JSR PC,PRDN
	PRTXT ^\: ?\
	JSR PC,QUEST
	SPOP E
	SPOP A
	CMP D,#'P	;IS IT A PLOTTER
	BEQ TPLOT
	CMP D,#'N	;IS IT NULL
	BEQ TNUL
	CMP D,#'C	;IS IT HIS CONSOLE
	BEQ TCON
	CMP D,#'T	;IS IT A TURTLE
	BEQ TTUR
	CMP D,#'M	;IS IT A MUSIC BOX
	BEQ TMUS
	CMP D,#7
	BEQ TBOX6
TMUS:	MOV #PMBOX,(B)+
	INC A
	BR TBOX3
TNUL:	CLR (B)+
	INC A
	BR TBOX3
TCON:	MOV #CONSO,(B)+
	INC A
	BR TBOX3
TTUR:	CMP E,#NTUR
	BLT .+4
	ERROR+ITN
	MOV E,(B)
	BIS #TURT,(B)+
	INC E
	INC A
	BR TBOX3
TPLOT:	MOV #PLOTT,(B)+
	INC A
	BR TBOX3
TBOX4:	MOV USER,U
	MOV UTTY(U),E
	JSR PC,TYIRT
	BIS #PTBF!TIRST!TILIPM,TTYST(E)
	MOV TTYST(E),OTTYST(E)
	MOV #CONSO,C
	JSR PC,TBINIT
	BEQ TBOX5
	SEZ
	RTS PC
TBOX5:	JSR PC,NOTBOX
	ERROR+TDE
TBOX6:	JSR PC,NOTBOX
	ERROR+BRK


NOTBOX:	MOV #NPTBOX,A
	MOV #PTBOX0,B
NTBOX1:	CMP USER,(B)
	BEQ NTBOX2
	ADD #5*2,B
	SOB A,NTBOX1
	SEZ
	RTS PC
NTBOX2:	SPUSH B
	JSR PC,NODEV
	SPOP B
	MOV USER,U
	MOV UTTY(U),E
	BIC #PTBF,TTYST(E)
	MOV #-1,(B)
	SEZ
	RTS PC

.IFNZ DDF

.IFNZ NDISP

CTRDIS:	BIT #DISPF,DIVOWN	;DOES HE OWN A DISPLAY?
	BEQ CTRERR		;NO
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+PLOTF>,DFLAGS
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY
	BIS DPENP,DFLAGS	;SET DISPLAY PEN POSITION
	SEZ
	RTS PC
.ENDC

CTRTUR:	BIT #TURTF,DIVOWN	;DOES HE OWN A TURTLE?
	BNE .+4			;NO,ERROR
CTRERR:	ERROR+VTD
	BIC #<PLOTF+DISPF>,DFLAGS
	BIS #TURTF,DFLAGS	;SET FLAG FOR CONTROLLING TURTLE
	JSR PC,G1NARG		;WHICH TURTLE DOES HE WANT TO CONTROL?
	TST B			;TEST TURTLE NO.
	BGE .+4			;IT'S OKAY SO FAR
CTRER2:	ERROR+ITN		;INVALID TURTLE NUMBER
	DEC B			;TO START TO TURN INTO AN INDEX
	CMP B,#NTUR-1
	BGT CTRER2		;IT WAS TO LARGE
	ASL B			;TURN IT INTO A WORD INDEX
	CMP TURUSE(B),USER	;DOES HE OWN IT?
	BNE CTRERR		;NOPE
	MOV TUDN(B),TURDN	;FOR THE OUTPUT ROUTINES
	MOV STURF(B),TURF
CTRRET:	SEZ
	RTS PC

.IFNZ NPLOT

CTRPLT:	BIT #PLOTF,DIVOWN	;DOES HE OWN THE PLOTTER?
	BEQ CTRERR		;NOPE
	BIT #PLOTF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+DISPF>,DFLAGS
	BIS PLPENP,DFLAGS	;SET PLOTTER PEN POSITION
	BIS #PLOTF,DFLAGS	;SET FLAG FOR CONTROLLING PLOTTER
	SEZ
	RTS PC

.ENDC
.ENDC

.IFNZ <NDISP!NPLOT>


.IFZ FPPF

DBK:	NEG	B
;DISPLAY FORWARD AND BACK
DFD:	MOV	B,C
	CLR	B
	TST	C
	BGE	DFD1	;IF ARG IS NEG,
	COM	B	;SET B = -1
	CLR	A	;CLEAR FLAG
DFD1:	MOV	#CURX,D
	JSR	PC,MULSIN	;PUTS DX IN E,,F
	SDPADD	(D)+,(D)+,E,F	;NEW X
	PUSH	F	;FRACTION PART
	SPUSH	E	;INTEGER PART
	JSR	PC,MULCOS	;DY IS IN E,,F
	SDPADD	(D),(D)+,E,F	;NEW Y
	SPUSH	F
	SPUSH	E
	BR	SETMOV

.IFF

DBK:	NEGF FA
DFD:	
.IFZ DDF
	LDCFD COSA,FB
	MULF FA,FB
	LDCFD CURY,FC
.IFF
	JSR PC,GTCURX		;IS HE CONTROLLING PLOTTER OR DISPLAY?
	LDCFD COSA(F),FB	;COSINE OF ANGLE -> FB
	MULF FA,FB		;DY -> FB
	LDCFD CURY(F),FC	;CURY -> FC
.IFTF
	ADDF FC,FB	;GET NEW Y IN FB
	STCDF FB,-(P)	;PUT NEW Y ON STACK
.IFT
	LDCFD SINA,FB
	MULF FA,FB	;DX IN FB
	LDCFD CURX,FC	;CURRENT X IN FC
.IFF
	LDCFD SINA(F),FB	;SINE OF ANGLE -> FB
	MULF FA,FB		;DX -> FB
	LDCFD (F),FC		;CURX -> FC
.ENDC
	ADDF FC,FB	;GET NEW X IN FB
	STCDF FB,-(P)	;PUT NEW X ON STACK
	BR SETMOV

.ENDC
.IFNZ DDF
	;PUTS THE ADDRESS OF THE CURX OF DISPLAY IN F
	;IF HE OWN A DISPLAY, ELSE PUTS CURX OF PLOTTER IN F
.IFNZ NDISP
GTCURX:	BIT #DISPF,DFLAGS	;DOES HE OWN A DISPLAY?
	BNE DISP		;YES
	MOV #PCURX,F		;PUT ADDRESS OF PCURX IN F
	BR DISP1
DISP:	MOV #DCURX,F		;PUT ADDRESS OF DCURX IN F
DISP1:	RTS PC
.IFF
GTCURX:	MOV #PCURX,F
	RTS PC
.ENDC
.ENDC


.IFZ FPPF


SETX:	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;;NEW X IN B
	CLR	-(SP)	;FRACTION PART OF NEW X
	PUSH	B	;INTEGER PART
	SPUSH	CURY	;NEW Y UNCHANGED
	SPUSH	CURY+2
	BR	SETMOV

SETY:	JSR	PC,DCHKPL
	JSR	PC,G1NARG
	PUSH	CURX	;NEW X UNCHANGED
	SPUSH	CURX+2
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	B	;INTEGER PART OF NEW Y
	BR	SETMOV

SETXY:	GTJUMP GTSXY
	JSR	PC,DCHKPL
	JSR	PC,G2NARG
	CLR	-(SP)	;FRATION PART OF NEW X
	PUSH	B	;INTEGER PART
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	A	;INTEGER PART
SETMOV:	JSR	PC,MOVETO
	RTS PC

SETTURTLE:
	JSR	PC,DCHKPL
	MOV	@S,C
	JSR	PC,LD3NUM	;LOAD D,E,F
SETT1:	PUSH	F	;SAVE NEW ANGLE
	JSR	PC,SPOPT	;POP OFF ARG
	CLR	-(SP)	;FRACTION PART OF NEW X
	SPUSH	D	;INTEGER
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	E
	CLR	A	;A FLAG
	JSR	PC,MOVETO	;MOVE TO NEWX,NEWY
	SPOP	B	;NEW HEADING
	JMP	DRT.HD	;SET HEADING



.IFF
SETX:	JSR PC,DCHKPL
.IFZ DDF
	SPUSH CURY+2
	SPUSH CURY
.IFF
	JSR PC,GTCURX
	SPUSH CURY+2(F)	;PUT CURY ON STACK
	SPUSH CURY(F)
.IFTF
	JSR PC,GARG	;PUT NEWX ON STACK
	BR SETMOV
SETY:	JSR PC,DCHKPL
	JSR PC,GARG	;PUT NEW Y ON STACK
.IFT
	SPUSH CURX+2
	SPUSH CURX
.IFF
	JSR PC,GTCURX
	SPUSH 2(F)	;PUT CURX ON STACK
	SPUSH (F)
.ENDC
	BR SETMOV
SETXY:	GTJUMP GTSXY
	JSR PC,DCHKPL
	JSR PC,GARG	;PUT Y ON
	JSR PC,GARG	;PUT X ON
SETMOV:	JSR PC,MOVETO
	RTS PC

SETTURTLE:
	MOV @S,C
	JSR PC,.GFLST	;FA <- NEWX
	LDD A,B		;FB <- NEWX
	JSR PC,.GFLST	;FA <- NEWY
	BIT #7777,C	;ANY MORE LIST?
	BEQ SETT1	;NO?!
	JSR PC,.LOADC	;GET POINTER TO ANGLE
	BIT #7777,A	;ANY MORE LIST? (SHOULDN'T BE)
	BNE SETT1	;THERE IS??
	MOV #SNUM,A	;TAKE POINTER AND TRY TO
	JSR PC,CONVER	;CONVERT IT TO A SNUM
	BNE .+4
SETT1:	ERROR+WTA
	SPUSH B		;STORE ANGLE
	STCDF FA,-(P)	;STORE NEWY
	STCDF FB,-(P)	;STORE NEWX
SETT2:	JSR PC,DCHKPL
	CLR A		;SET A FLAG
	JSR PC,MOVETO	;MOVE IT
	SPOP B		;POP ANGLE
	JMP DRT.HD

.GFLST:	BIT #7777,C	;GETS FLOATING NUMBER OUT OF LIST
	BEQ SETT1	;EMPTY LIST
	JSR PC,.LOADC	;GET NODE IN A AND B
	MOV A,C		;GET POINTER TO REST OF LIST IN C
	JSR PC,G1NUMS	;GET FNUM POINTED TO BY B INTO FA
	BEQ SETT1
	RTS PC

GARG:	SPOP FNPDL+4	;SO THAT THE JMP WILL WORK BELOW
	SPUSH A		;STORES REGISTERS AND GETS NUMBER IN FA
	SPUSH B
	SPUSH F
	JSR PC,G1NUM	;FA <- FNUM POINTER TO BY B
	BEQ SETT1
	SPOP F		;RESTORE REGISTERS
	SPOP B
	SPOP A
	STCDF FA,-(P)	;PUT FA ON STACK
	JMP @FNPDL+4	;DOES A RTS PC





.ENDC



;CALL WITH NEWX AND NEWY ON THE STACK




MOVETO:	JSR PC,PPOPT	;INSURE ENOPUGH STACK IS IN CORE
	.IFNZ	NPLOT
.IFNZ NDISP
	BIT	#PLOTF,DFLAGS ;USING PLOTTER?
	BEQ	MTO.09   ;IF NOT,SKIP ALL THIS
.ENDC


.IFZ FPPF

	MOV	2(P),C	;INT OF Y
	MOV	4(P),A	;FRACTION Y
	MOV	6(P),B	;INT OF X
	MOV	10(P),D	;FRACTION X
	ASL	A
	ADC	C	;ROUND Y
	ASL	D
	ADC	B	;ROUND X
	CMP	B,#128.   ;CHECK IF EXCEEDS PLOTTER BOUNDS
	BGE	MTO.03
	CMP	B,#-128.
	BLT	MTO.03
	CMP     C,#128.    ;NOW CHECK Y BOUNDS
	BGE	MTO.03
	CMP	C,#-128.
	BLT	MTO.03
	JSR	PC,MTO.02
	JMP	MTO.R
;SEND OUT PLOTTER CHARACTERS

.IFF

	LDCFD 2(P),FA	;LOAD NEWX
	LDCFD 6(P),FB	;LOAD NEWY
	STF FA,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	STF FB,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	SETI
	STCFI FA,B	;PUT NEWX INTO B
	STCFI FB,C	;PUT NEWY INTO C
	SETL
	ASR B		;ROUND NEWX
	ADC B
	ASR C		;ROUND NEWY
	ADC C
	JSR PC,MTO.02	;MOVE IT
	JMP MTO.R	;STORE AWAY NEWX AND NEWY
.IFZ DDF

CHKPL:	CMPF #42000,FC
	CFCC
	BLT MTO.03
	CMPF #142000,FC
	CFCC
	BGT MTO.03
	RTS PC
.ENDC

.ENDC

MTO.02: MOV	#35,D   ;PRIMING CHARACTER
	MOV	#PLTDVN,E
	SPUSH C
	MOV #PLOTT,C
	JSR	PC,TBTYO   ;SEND TO TTY
	JSR	PC,MTO.04	;SEND NEW X TO PLOTTER
	JSR	PC,PLT67
	JSR	PC,TBTYO
	SPOP B
	JSR	PC,MTO.04   ;SEND NEW Y TO PLOTTER
	JSR	PC,PLT67
	JSR	PC,TBTW
	MOV	D,PLTCHR	;PLOTTER WILL SEND BACK SENSING CHAR
	RTS	PC
MTO.03: ERROR+OOB
MTO.04:	MOV	B,D   ;SEND LOW ORDER 6 BITS
	BIC	#177700,D
	JSR	PC,PLT67
	JSR	PC,TBTYO
	MOV	B,D	;SEND REMAINING 2 BITS
	ASL	D
	ASL	D
	SWAB	D
	BIC	#177774,D
	BIT	#PENUF,DFLAGS   ;SEND PENUP INFO
	BEQ	MTO.05
	BIS	#40,D   ;SET PENUP BIT
MTO.05:	RTS	PC

PLT67:	BIT	#40,D	;SET BIT 6 TO COMP OF BIT 7
	BNE	PLT671
	BIS	#100,D
PLT671:	RTS	PC


.ENDC
.IFNZ NDISP

.IFZ FPPF

MTO.09:	MOV SP,F
	TST	(F)+	;POINT TO ARGS
	MOV	(F)+,B	;INTEGER PART OF NEW Y
	MOV	(F)+,C	;FRACTION PART OF NEW Y
	JSR	PC,CHKBND	;CHECK TO SEE IF IN BOUNDS
	MOV	B,E	;ROUNDED NEWY
	MOV	(F)+,B	;INTEGER PART OF NEW X
	MOV	(F),C	;FRACTION PART OF NEW X
	JSR	PC,CHKBND
	MOV	B,D	;ROUNDED NEWX
;GET D_DX AND E_DY
	MOV	#CURX,F
	ASL	(F)+	;FRACTION OF CURX
	ADC	(F)	;ROUND CURX
	SUB	(F)+,D	;DX
	ASL	(F)+
	ADC	(F)
	SUB	(F),E	;DY

.IFF

MTO.09:	MOV P,F		;SO IT CAN DO POPS W/O DISTURBING THE STACK
	TST (F)+	;TO GET AROUND THE PC
	LDCFD (F)+,FA	;GET NEW X
	STF FA,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
	LDCFD (F)+,FB	;GET NEW Y
	STF FB,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
.IIF Z DDF,	MOV #RCURX,F
.IFNZ DDF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	ADD #RCURX,F	;TO TELL WHERE TO PUT ROUNDED FA AND FB
.ENDC 
	JSR PC,ROUND	;ROUND FA AND FB
	SETF
	SUBF (F)+,FA	;FA <- NEWX - CURX
	SUBF (F)+,FB	;FB <- NEWY - CURY
	SETD
	JSR PC,MOD1K	;PERFORM A MODULAR 32K. (ANY BETTER IDEAS?)
	SETI
	STCFI FA,D	;PUT DX IN D
	STCFI FB,E	;PUT DY IN E
	SETL

.ENDC

	BNE	MTO.1	;CHECK FOR DX=DY=0
	TST	D
	BEQ	MTO.R	;JUST RETURN

MTO.1:	BIT	#PENUF,DFLAGS	;IS PEN UP?
	BNE	MTO.PU	;YES

;THE PEN IS DOWN
	SPUSH	DIREC
	JSR	PC,XYDIR	;CALCULATE DIREC
	JSR	PC,DR.LIN	;AND DRAW LINE!!
	SPOP	DIREC

;RETURN.  SET CURX & CURY TO NEWX & NEWY


.ENDC

.IFZ FPPF

MTO.R:	POP	A	;RETURN ADDRESS
	MOV	#CURY+2,B
	SPOP	(B)	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP	-(B)
	SPOP	-(B)
	SPOP	-(B)
	JMP	(A)

.IFF

MTO.R:	POP A
.IFZ DDF
	MOV #CURX,B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE SET OF VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
.ENDC
	SPOP (B)+	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP (B)+
	SPOP (B)+
	SPOP (B)+
	JSR PC,ROUNDER	;ROUND AND PUT IN RCURX AND RCURY
	SEZ
	JMP (A)		;DOES AN RTS!!?

ROUNDER:	;PUTS ROUNDED CURX AND CURY INTO RCURX AND RCURY
.IFZ DDF
	MOV #CURX,B
	MOV #RCURX,F
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
	ADD #RCURX,F	;MAKE F POINT TO RCURX
.ENDC
	LDCFD (B)+,FA	;FA <-CURX
	LDCFD (B)+,FB	;FB <- CURY
	JSR PC,ROUND	;ROUND FA AND FB
	STCDF FA,(F)+	;RCURX <- ROUNDED CURX
	STCDF FB,(F)+	;RCURY <- ROUNDED CURY
	RTS PC

	;ROUNDS FA AND FB
ROUND:	ADDF #40000,FA	;FA <- FA + 1/2
	STCFI FA,-(P)	;INTEGERIZE FA
	BCS EROOB	;TOO BIG
	LDCIF (P)+,FA	;FA <- INTEGER (FA)
	CFCC		;IS FA > 0?
	BGE .+6		;YES
	SUBF #40200,FA	;FA <- FA - 1 (TO ROUND AWAY FROM 0)
	ADDF #40000,FB	;REPEAT SAME PROCESS FOR FB
	STCFI FB,-(P)
	BCS EROOB
	LDCIF (P)+,FB
	CFCC
	BGE .+6
	SUBF #40200,FB
	RTS PC
EROOB:	CMP (P)+,(P)+	;GET RID OF TRASH ON STACK
	ERROR+OOB

MOD1K:	LDD FB,FC
	MODF #34600,FC	;DIVIDES BY 2^16 (FC <- ONLY FRACTIONAL PART)
	CFCC
	BEQ MODK1	;IT WAS ZERO OR UNDERFLOWED
	MULF #43600,FC	;FRACTION * 2^16
	LDD FC,FB	;PUT IT BACK NOW
MODK1:	LDD FA,FC	;NOW DO IT TO FA
	MODF #34600,FC
	CFCC
	BEQ MODK2
	MULF #43600,FC
	LDD FC,FA
MODK2:	RTS PC

.ENDC

.ENDC
.IFNZ NDISP


;THE PEN IS UP
;PUT ADDX AND ADDY COMMANDS INTO DISPLAY LIST
MTO.PU:	SPUSH	#MTO.R	;SO RTS PC'S BELOW WILL WORK (GROAN !!!)
	MOV	STT,A	;POINTER TO TOP OF STATIC DISPLAY ALLOCATION
	CMP	-(A),#ADDY
	BLO	MTO.AD	;PREVIOUS STUFF NOT ADDS ANYWAY
	CMP	-(A),#ADDY	;IS THE NEXT TO LAST DCODE AN ADD,TOO ?
	BLO	MTO.AD	;NO
	CMP	A,SNABOT	;DON'T COMPRESS ACROSS SNAP BOTTOM
	BLO	MTO.AD	;NO
;THERE ARE TWO ADD COMMANDS IN A ROW
	JSR	PC,MTO.AS	;TAKE CARE OF FIRST ADD
	JSR	PC,MTO.AS	;AND SECOND ADD
	BR	MTO.R1


;MTO.AS ADDS THE DELTA X OF AN ADD COMMAND TO THE NEW DX OR DY
MTO.AS:	CMP	(A),#ADDX	;ADDX IS THE BIGGER OF THE ADDS
	BHIS	.+6
	ADD	(A)+,E	;DY
	RTS	PC
	ADD	(A)+,D
	RTS	PC



;HAVE TO EXPAND STATIC AREA AND PUT IN ADD COMMANDS
MTO.AD:	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

MTO.RM:	MOV	A,STT	;A WAS SET IN STXPND
	MOV	PUSHJT,(A)	;DISPLAY JUMP TO TURTLE
MTO.R1:	BIC	#176000,D	;IN CASE EITHER DX OR DY WERE NEGATIVE
	BIC	#176000,E	;CLEAR THE TOP 6 BITS
	BIS	#ADDY,E	;TURN E INTO ADDY COMMAND
	MOV	E,-(A)	;STORE IN DLIST
	BIS	#ADDX,D	;TURN D INTO ADDX COMMAND
	MOV	D,-(A)	;STORE IN DLIST
	CLR DFBCNT
	RTS	PC

.ENDC
.IFNZ <NDISP!NPLOT>

.IFZ FPPF

DLT:	NEG	B

;DISPLAY RIGHT AND LEFT

DRT:	ADD	CURA,B

.IFF

DLT:	NEGF FA
DRT:	SETI
	STCFI FA,B
	SETL
	BCC .+4		;NUMBER TOO LARGE??, NOPE
	ERROR+TGDZ	;TURTLE GETTING DIZZY
.IFZ DDF
	ADD CURA,B
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE VARIABLES
	ADD CURA(F),B	;B <- NEWA + CURA
.ENDC

.ENDC
DRT.HD:	JSR	PC,MOD360	;SET B=B MOD 360
.IIF Z DDF,	MOV	B,CURA
.IFNZ DDF
	JSR PC,GTCURX
	MOV B,CURA(F)	;MOVE NEWLY COMPUTED ANGLE TO CURA
.ENDC

;DRAW THE TURTLE IF IT'S BEING SHOWN
TURDO:	JSR	PC,ANGCRP	;DO ALL THE ANGLE CRAP.
	.IFNZ	   NPLOT
	BIT     #PLOTF,DFLAGS   ;USING PLOTTER?
	BNE	DRTRET	;YES, SO RETURN
	.ENDC
.IFZ NDISP
	ERROR+VTU
.IFF
	BIT	#HIDETF,DFLAGS	;IS THE TURTLE BEING HIDDEN ?
	BNE	DRTRET	;YES. SO RETURN
;THE TURTLE IS BEING SHOWN. SO DRAW THE TURTLE
	JSR	PC,DR.TUR
.ENDC

DRTRET:	SEZ
	RTS	PC


;SETHEAD
;	LIKE RIGHT, EXCEPT SET CURA TO ARGUMENT
SETHEAD:	GTJUMP GTSETH
	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;NUMERIC ARGUMENT IN B
	BR	DRT.HD	;JUMP INTO RIGHT

;WRAPAROUND
.IFNZ NDISP

WRAP:	BIS	#WRAPF,DFLAGS
	BR DRTRET

NOWRAP:	BIC	#WRAPF,DFLAGS
	BR DRTRET

.ENDC

.IFZ FPPF



;HERE
;	OUTPUT A SENTENCE OF CURX,CURY,CURA
HERE:	JSR	PC,DCHKPL
	MOV	#CURX,D
	JSR	PC,PSHINT	;PUSH INTEGER OF CURX ONTO S-PDL
	JSR	PC,PSHINT	;PUSH INTEGER OF CURY
	MOV	(D),B	;CURRENT ANGLE
HERE.1:	JSR	PC,PSHNUM	;PUSH CURRENT ANGLE
HERE.2:	MOV	#3,D	;PUSH 3 ONTO P-PDL
	JMP	SENT.


;XCOR
;	OUTPUT THE X COORDINATE
XCOR:	JSR	PC,DCHKPL
	MOV	#CURX,D
	BR	YCOR1
;YCOR
;	OUTPUT THE Y COORDINATE
YCOR:	JSR	PC,DCHKPL
	MOV	#CURY,D
YCOR1:	JMP	R1INT	;RETURN INTEGER


;HEADING
;	RETURN THE CURRENT ANGLE
HEADING:	JSR	PC,DCHKPL
	MOV	CURA,B
	JMP	R1NARG
	;HOME -- SAME AS SETT [0 0 0]
HOME:	GTJUMP GTHME
	JSR PC,DCHKPL
	JSR PC,SPUSHT
	CLR D
	CLR E
	CLR F
	JMP SETT1

.IFF

HERE:	JSR PC,DCHKPL	;DOES HE OWN DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURX,D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
.ENDC
	JSR PC,WHOPIE	;PUT (F) INTO A NODE, POINTER IN B
	PUSHS B		;STORE POINTER TO FNUMS ON STACK
	JSR PC,WHOPIE	;DO IT AGAIN
	PUSHS B
.IIF Z DDF,	MOV (D),B	;STORE ANGLE (SNUM) ON STACK
.IIF NZ DDF,	MOV (F),B	;PUT ANGLE (SNUM) IN B
	JSR PC,PSHNUM	;PUT SNUM IN B ON S-PDL
	MOV #3,D	;PUSH A FLAG ON	
	JMP SENT.	;CHANGE THE THREE THINGS INTO A SENTENCE

XCOR:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IIF Z DDF,	MOV #CURX,D	;PUT POINTER TO CURRENT X IN D
.IIF NZ DDF,	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	BR YCOR1	;GET NUMBER AND RETURN

YCOR:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURY,D	;PUT POINTER TO CURRENT Y IN D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURY,F	;MAKE F POINT TO CURY
.ENDC
YCOR1:	JSR PC,WHOPIE	;PUT NUMBER INTO A NODE,POINTER RETURNED IN B
	JMP ORTB	;PUT POINTER IN B ON S-PDL

HEADING:JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV CURA,B	;PUT POINTER TO ANGLE IN B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURA,F	;MAKE F POINT TO CURA
	MOV (F),B	;MOVE CURA TO B
.ENDC
	JMP R1NARG	;RETURN B

HOME:	GTJUMP GTHME
	CLR -(P)	;SETTURTLE [0 0 0]
	CLR -(P)
	CLR -(P)
	CLR -(P)
	CLR -(P)
	JMP SETT2	;SET THE TURTLE!

	;TAKES FNUM POINTED TO BY F, AND PUTS IT IN A NODE
	;RETURNS POINTER TO IT IN B
WHOPIE:	SPUSH C
.IFZ DDF
	MOV (D)+,A
	MOV (D)+,B
.IFF
	MOV (F)+,A	;PUT FNUM IN A AND B
	MOV (F)+,B
.ENDC
	JSR PC,GRBAD	;PUT FNUM IN NODE SPACE
	BIS #FNUM,C	;SET APPROPRIATE TYPE
	MOV C,B		;PUT POINTER IN B
	SPOP C
	RTS PC

.ENDC

;PENP
;RETURNS TRUE IF THE PEN IS DOWN
;RETURNS FALSE IF IT IS UP
PENP:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
	BIT #PENUF,DFLAGS	;IS THE PEN UP?
	BNE PENP1	;YES
	JMP RTTRUE	;NO, RETURN TRUE
PENP1:	JMP RTFALS	;YES, RETURN FALSE
.IFNZ NDISP


;	HIDETURTLE
HIDETURTLE:
	GTJUMP GTHIDE
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY??
	BIS	#HIDETF,DFLAGS	;SET THE HIDETURTLE FLAG
	MOV	#DPOP!DSTOP,@TUB
	BR SHOWT9


;	SHOWTURTLE
SHOWTURTLE:
	GTJUMP GTSHOW
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
	BIT	#HIDETF,DFLAGS	;IS TURTLE HIDDEN NOW ?
	BEQ	SHOWT9	;NO, IT'S ALREADY BEING SHOWN
;HAVE TO DRAW THE TURTLE
	BIC	#HIDETF,DFLAGS	;CLEAR THE FLAG FIRST
	JSR	PC,DR.TUR
SHOWT9:	SEZ
	RTS PC

.ENDC


;	DISPLAY PENUP
DPU:	BIS	#PENUF,DFLAGS	;SET PEN UP FLAG
.IFNZ DDF
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING A DISPLAY?
	BEQ DPU1	;NO
	BIS #PENUF,DPENP	;SET PEN UP FLAG IN DISPLAY VARIABLES
	BR DPR			;RETURN
DPU1:	BIS #PENUF,PLPENP	;SET PEN UP FLAG IN PLOTTER VARIABLES
.ENDC
DPU2:	SEZ
	RTS PC


	;SAME AS ABOVE BUT CLEARING PEN UP FLAG
;	DISPLAY PENDOWN
DPD:	BIC	#PENUF,DFLAGS	
.IFNZ DDF
	BIT #DISPF,DFLAGS
	BEQ DPD1
	BIC #PENUF,DPENP
	BR DPR
DPD1:	BIC #PENUF,PLPENP
DPR:
.ENDC
	BR DPU2
.ENDC

.IFNZ NDISP
;CLEARSCREEN--WIPE SCREEN AND RESTORE TURTLE TO [0 0 0]
CLEARSCREEN:	GTJUMP GTCLEA
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
	JSR	PC,WC.1	;WIPE IT CLEAN
	SPUSH DFLAGS
	MOV	#DORBEG,C	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,B	;INCLUDING CURX, CURY AND OTHERS
CSLOOP:	CLR	(C)+
	CMP	C,B
	BLT	CSLOOP

	SPOP DFLAGS
	CLR DFBCNT
	JSR	PC,TURDO	;DO ANGLE CRAP AND DRAW TURTLE IF SHOWN
	MOV	STB,STT
	MOV	PUSHJT,@STB
	JSR	PC,NEWSN2	;RECALCULATE STARTING POINT FOR SNAPS
	SEZ
	RTS PC

.IFZ FPPF

;SNAP

SNAP:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

;FIRST SET UP THE 3 NODE SNAP STRUCTURE ITSELF
	JSR	PC,PSHNUM	;FIRST NUMBER IS DUMMY FOR NOW
.IIF NZ DDF,	MOV	#DCURX,D
.IIF Z DDF,	MOV	#CURX,D
	JSR	PC,GETINT	;INTEGER OF CURX IN B
	SUB	OLDX,B	;TO GET DELTA X
	JSR	PC,PSHNUM	;PUSH ON S-PDL
	JSR	PC,GETINT	;INTEGER OF CURY
	SUB	OLDY,B	;TO GET DELTA-Y
	JSR	PC,PSHNUM
	MOV	#3,D	;NUMBER OF ARGS TO SENTENCE
	JSR	PC,SENT.

.IFF
	;CALCULATES DX AND DY, AND PUTS POINTERS TO THEM ON S-PDL
OLD:	JSR PC,(PC)	;DO THIS TWICE
	SETF
	LDF (D)+,FA	;SECOND TIME IT POINTS TO CURY
	SUBF (F)+,FA	;SECOND TIME POINTS TO OLDY
	STF FA,-(P)	;PUT DX OR DY ON STACK
	SPOP A		;PUT FNUM IN A,,B
	SPOP B
	SETD
	JSR PC,GRBAD	;PUT A,,B IN NODE
	BIS #FNUM,C	;SET TYPE
	SPUSHS C	;PUT POINTER ON S-PDL
	RTS PC


SNAP:	JSR PC,DCHK	;DOES HE OWN ADISPLAY?
	JSR PC,PSHNUM	;PUSH SNAP POINTER
.IIF NZ DDF,	MOV	#DCURX,D	;D POINTS TO CURX
.IIF Z DDF,	MOV	#CURX,D		;DITTO
	MOV #OLDX,F	;E POINTS TO WHERE SNAP IS TAKEN FROM
	JSR PC,OLD	;CALCULATE DX AND DY OF SNAP
	MOV #3,D	;SET FLAG FOR SENTENCE
	JSR PC,SENT.	;MAKE THE THREE THINGS INTO A SENTENCE


.ENDC


;NOW GRAB A NODE FOR THE SNLIST HACKING
	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BNE	SNAP.2
	MOV	#SNUM,A	;FIRST SNAP
	CLR	B	;CREATE SNAP LIST. FIRST NODE IS A DUMMY
	JSR	PC,GRBAD
	BIS	#LIST,C
	MOV	C,SNLIST
SNAP.2:	JSR	PC,.LDP1	;POINTER TO REST OF SNAP LIST
	JSR	PC,GRBAD	;STORE A NODE
	BIS	#LIST,C
	MOV	C,GCP1	;GARBAGE COLLECT PROTECT

;NOW TRANSFER THE DISPLAY CODE (YEAH)
	MOV	SNABOT,D	;BOTTOM OF STUFF TO BE SNAPPED
	JSR	PC,DYXFR	;TRANSFER THE DCODE. SKIP IF SUCCEEDS
	BEQ	SNAP.4	;COULDN'T FIND ENOUGH FREE MEMORY
SNAP.0:	TST	D	;IF 0
	BEQ	SNAP.3	;NO CODE MOVED

;CHECK THAT THIS SNAP WON'T CAUSE DISPLAY PDL OVERFLOW
	TST	-(D)	;POINTER TO SNAP
	CMP	-(D),#<<<DPDLL_-1>&77777>-1>	;DEPTH COUNTER
	BLE	SNAP.1
	CLR	GCP1
	ERROR+STD	;SNAP TOO DEEP

;NOW GO BACK AND PUT THE SNAP ADDRESS IN RIGHT PLACES
SNAP.1:	TST	(D)+	;POINT D TO REF COUNTER
	INC	(D)+	;INC COUNTER THAT SAYS HOW MANY TIMES DISPLAYED
	MOV	GCP1,C	;NOW HACK SNLIST
	MOV	D,A
	JSR	PC,.STP2	;STORE ADDRESS IN 2ND WORD OF NODE
	MOV	C,A	;POINTER TO NODE
	BIC	#170000,A
	BIS	#SNUM,A
	MOV	SNLIST,C
	JSR	PC,.STP1	;STORE NEW NODE POINTER INTO FIRST NODE OF SNLIST

	CLR	GCP1


	MOV	@S,C	;NOW HACK THE SNAP STRUCTURE
	BIC	#170000,C
	BIS	#SNP,C
	MOV	C,@S	;PUT IN RIGHT DATA TYPE
;PUT ADDRESS OF SNAP INTO FIRST OF STRUCTURE
	JSR	PC,.LDP2	;A_POINTER TO FIRST OF STRUCTURE
	MOV	A,C
	CLR	A
	MOV	D,B
	BGE	SNAP.6	;SIGN EXTEND ADDRESS
	COM	A
SNAP.6:	JSR	PC,.STORE	;STORE ADDRESS OF SNAP AS FIRST OF STRUCTURE

;NOW COLLAPSE STATIC AREA AND DISPLAY THE SNAP
	MOV	#SNABOT,A	;MAKE SURE THERE IS ROOM FOR DISPLAY HERE
	JSR	PC,STXPND
	MOV	A,STT
	MAKEPJ	D
	MOV	PUSHJT,(A)
	MOV	D,-(A)
	CLR	-(A)
	CLR DFBCNT
	CLZ
	RTS PC


;SINCE NO DISPLAY CODE WAS MOVED, RETURN EMPTY SNAP
SNAP.3:	MOV	#SNP,@S
	CLR	GCP1
	CLZ
	RTS PC

SNAP.4:	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	SNABOT,D
	JSR	PC,DYXFR	;TRY TO TRANSFER D.CODE AGAIN
	BNE	SNAP.0	;SUCCESS!
SNAP.5:	CLR	GCP1
	ERROR+TML
.IFZ FPPF

;NEWSNAP
;SET UP FOR NEXT SNAP TO START HERE
NEWSNAP:	JSR	PC,DCHK
NEWSN1:
.IIF NZ DDF,	MOV	#DCURX,D	;ENTER HERE AS SUBROUTINE
.IIF Z DDF,	MOV	#CURX,D	;ENTER HERE AS SUBROUTINE
	JSR	PC,GETINT	;GET INTEGER OF CURX IN B
	MOV	B,OLDX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,OLDY

.IFF

NEWSNAP:	JSR PC,DCHK	;DOES HE OWN A DISPLAY?
NEWSN1:	;ENTER HERE AS SUBROUTINE
.IIF NZ DDF,	MOV	#DCURX,D	;GET POINTER TO CURX
.IIF Z DDF,	MOV	#CURX,D		;GET POINTER TO CURX
	MOV #OLDX,B		;GET POINTER TO OLDX
	MOV (D)+,(B)+	;PUT CURX AND CURY INTO OLDX AND OLDY
	MOV (D)+,(B)+
	MOV (D)+,(B)+
	MOV (D)+,(B)+

.ENDC

NEWSN2:	MOV	STT,SNABOT	;RESET SNAP BOTTOM TO TOP OF DISPLAY
	CLR DFBCNT
	SEZ
	RTS	PC	;EITHER RETURN FROM SUBROUTINE , OR JMP NORT

;DISPLAY A SINGLE SNAP

DISPLAY:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP,CURX,CURY
	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY

.IFZ FPPF

	MOV	E,B
	ADD	CURX+2,B
	CLR	C	;FRACTION PART IS 0 (SEE SNAP)
	JSR	PC,CHKBND	;IS NEW X COR IN BOUNDS?
	MOV	F,B
	ADD	CURY+2,B
	JSR	PC,CHKBND	;IS NEW Y COR IN BOUNDS?

.IFF

	MOV F,B		;PUT POINTER TO DY IN B
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	STF FA,FB	;FB <- DY
	MOV E,B		;PUT POINTER TO DX IN B
	JSR PC,G1NUMS	;FA <- DX
	BNE .+4
DIPSEY:	.BUG.		;NO WAY IT SHOULD FAIL EITHER
.IIF NZ DDF,	MOV #DCURX,B	;PUT POINTER TO CURX IN B
.IIF Z DDF,	MOV #CURX,B
	SETF
	ADDF (B)+,FA	;GET NEW XCOR
	ADDF (B)+,FB	;GET NEW YCOR
	SETD
	STF FA,FD	;CHECK TO SEE IF XCOR IS IN BOUNDS
	JSR PC,CHKBND
	STF FB,FD	;CHECK TO SEE IF YCOR IS IN BOUNDS
	JSR PC,CHKBND

.IFTF

;NOW SEE IF THERE'S ENOUGH ROOM IN THE DISPLAY AREA

	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

;FINALLY, WE CAN PLACE THE PUSHJ TO THE SNAP INTO THE DISPLAY LIST
DISRM:	INC	-2(D)	;INCREMENT THE REF COUNTER OF THE SNAP
	MOV	A,STT	;SET STATIC TOP TO HERE IN DLIST
	MOV	PUSHJT,(A)	;PUT PUSHJ TO TURTLE AT TOP OF DLIST
	MAKEPJ D
	MOV	D,-(A)	;PUT IN THE PUSHJ
	CLR	-(A)	;PRECEDE BY A NOP

;NOW, SET CURX AND CURY
.IFT

	ADD	E,CURX+2	;E HAD DX OF THE SNAP
	ADD	F,CURY+2	;F HAS DY OF THE SNAP
.IFF

.IIF NZ DDF,	MOV #DCURX,B	;B <- POINTER TO CURX
.IIF Z DDF,	MOV #CURX,B
	STCDF FA,(B)+	;PUT NEW XCOR INTO CURX
	STCDF FB,(B)+	;PUT NEW YCOR INTO CURY
	JSR PC,ROUNDER	;ROUND CURX,CURY AND PUT INTO RCURX,RCURY

.ENDC

	CLR DFBCNT
D.RET:	JSR	PC,SPOPT	;POP S
	SEZ
	RTS PC

;WIPE A SNAP

WIPE:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP, X,  Y

	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY

.IFNZ FPPF

	MOV F,B		;B <- POINTER TO DY OF SNAP
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	LDD FA,FB	;FB <- DY
	MOV E,B		;B <- POINTER TO DX
	JSR PC,G1NUMS	;FA <- DX
	BEQ DIPSEY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	JSR PC,ROUND	;ROUND FA AND FB
	SETI
	STCFI FA,E	;E <- DX OF THE SNAP
	STCFI FB,F	;F <- DY OF SNAP
	SETL
.ENDC
	BIC	#176000,E	;CLEAR TOP 6 BITS
	BIS	#ADDX,E	;AND TURN INTO ADDX COMMAND
	BIC	#176000,F	;CLEAR TOP 6 BITS
	BIS	#ADDY,F	;TURN INTO ADDY

	MOV	D,B
	TST	-(D)	;POINT D TO SNAP'S REF COUNTER
	MAKEPJ B	;MAKE B INTO DPUSHJ TO SNAP
	MOV	STT,A	;POINTER TO TOP OF DISPLAY LIST
	MOV	STB,C	;POINTER TO BOTTOM OF DLIST

WIPE.L:	CMP	A,C	;ARE WE AT THE BOTTOM YET?
	BLO	D.RET	;YES, SO WE ARE DONE
	CMP	B,-(A)	;IS THE NEXT WORD A PUSHJ?
	BNE	WIPE.L	;NO.  LOOP BACK AND TRY ANOTHER
;YES!  IT IS A PUSHJ
;PUT ADDX AND ADDY COMMANDS INTO DLIST
	INC	NADXY	;NADXY IS ACOUNTER TO TELL WHEN TO COMPRESS
	MOV	F,(A)	;INSERT ADDY MADE FROM DY OF SNAP
	MOV	E,-(A)	;INSERT ADDX MADE FROM DX OF SNAP

	DEC	(D)	;DECREMENT REF COUNTER
	BR	WIPE.L	;AND THEN LOOP BACK TO SEE IF THERE'S ANOTHER
;			PUSHJ TO THIS SNAP


;WIPE THE ENTIRE DISPLAY

WIPECLEAN:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

WC.1:	MOV	STB,A	;POINTER TO BOTTOM OF DISPLAY LIST
	MOV	STT,B	;POINTER TO TOP OF DLIST
	MOV	#100000,E	;SMALLEST DPUSHJ
	MOV	#140000,F	;SMALLEST COMMAND BIGGER THAN PUSHJ

WC.LP:	CMP	B,A	;ARE WE AT BOTTOM YET?
	BLOS	WC.DUN	;YES, WE ARE DONE
	CMP	-(B),E	;IS NEXT WORD DOWN A PUSHJ?
	BLO	WC.LP	;NO, IT'S TOO SMALL
	CMP	(B),F
	BHIS	WC.LP	;NO, IT'S TOO BIG
;THIS WORD IS A PUSHJ
	MOV	(B),D	;MOVE	THE PUSHJ COMMAND INTO D
	MAKEAD D	;TURN INTO PDP-11 ADDRESS
	DEC	-(D)	;DECREMENT SNAP'S REF COUNTER
	BR	WC.LP	;LOOP BACK TO LOOK FOR MORE PUSHJ'S

;NOW PLACE ADDX AND ADDY COMMANDS IN THE DISPLAY LIST
;SO THAT THE TURTLE WILL STAY AT THE SAME PLACE IT WAS BEFORE THE WIPE

.IFZ FPPF

WC.DUN:	MOV	#CURX,D
	JSR	PC,GETINT	;GET INTEGER OF  CURX IN B
	SPUSH	B	;SAVE DX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,E	;PUT DY IN E
	SPOP	D	;PUT DX IN B
.IFF
WC.DUN:
.IIF NZ DDF,	MOV #RDCURX,F	;F <- POINTER TO RCURX
.IIF Z DDF,	MOV #RCURX,F
	LDCFD (F)+,FA	;FA <- RCURX
	LDCFD (F)+,FB	;FB <- RCURY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	SETI
	STCFI FA,D	;F <- RCURX
	STCFI FB,E	;E <- RCURY
	SETL
.ENDC
	MOV	STB,STT
	JSR	PC,MTO.AD	;PUTS THE ADD COMMANDS INTO THE DLIST
	JSR	PC,NEWSN1	;SO THAT SNAPS WILL START HERE

	RTS	PC
.ENDC
.STITL DISPLAY UTILITY ROUTINES

.IFZ FPPF


;CHKBND
;	CHECK BOUNDS.  ERROR IF B IS OFF SCREEN
;	ALSO ROUNDS B,,C
CHKBND:	BIT	#WRAPF,DFLAGS
	BNE	CBRND	;GO AND ROUND
	CMP	B,#200.
	BGE	CBIBIG	;INTEGER PART MAY BE TOO BIG
	CMP	B,#-200.
	BLT	ERROOB	;DUE TO THE FACT THAT FRACTION IS ALWAYS
			;POSITIVE, IF B=-200 THAT GUARANTEES IT IS IN
			;BOUNDS. (I HOPE)
CBRND:	ASL	C
	ADC	B
	RTS	PC
;HERE, THE INTEGER PART IS >= 200.
;SO IF THE FRACTION PART IS NON-ZERO, THAT WILL MEAN THAT THE ENTIRE
;NUMBER IS GREATER THAN 200
CBIBIG:	BGT	ERROOB	;INTEGER>200
	TST	C
	BEQ	CBRND
ERROOB:	ERROR+OOB

.IFF

CHKBND:	BIT #PLOTF,DFLAGS	;IS HE USING PLOTTER?
	BNE CHK1	;YES, IGNORE WRAP FLAG
	BIT #WRAPF,DFLAGS	;IS HE WRAPPING
	BNE CBRND	;YES, DON'T CHECK BOUNDS
CHK1:	CMPF #42110,FD	;IS 200 < FD?
	CFCC
	BLT ERROOB	;YES, ERROR
	CMPF #142110,FD	;IS -200 > FD?
	CFCC
	BGT ERROOB	;YES,ERROR
CBRND:	RTS PC
ERROOB:	ERROR+OOB	;OUT OF BOUNDS

.ENDC
;	CALL WITH D POINTING TO CURX OR CURY.
;	RETURN THE INTEGER OF CURX OR CURY IN B
GETINT:	MOV	(D)+,B	;THE FRACTION PART
	ROL	B
	MOV	(D)+,B	;THE INTEGER PART
	ADC	B	;ROUND
	RTS	PC

.IFNZ NDISP

;STATIC AREA EXPAND.
;	IS THERE ROOM IN STATIC AREA FOR 2 DISPLAY WORDS?
;	RETURN POINTER TO NEW STATIC TOP IN A
STXPND:	PUSH	A
	MOV	@A,A	;ROUTINE IS CALLED WITH ADDRESS OF VARIABLE
	CMP	(A)+,(A)+	;A _ A+4
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN8	;THERE'S ROOM!
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	@(SP)+,A	;AND TRY AGAIN
	CMP	(A)+,(A)+
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN9
	ERROR+TML	;TOO MANY LINES
STXPN8:	TST	(SP)+	;POP OFF A
STXPN9:	RTS	PC

.ENDC


;MOD360
;	OUTPUT B MOD 360 IN B.
;	ALWAYS OUTPUTS A POSITIVE NUMBER
MOD360:
	TST B
	SXT A
	DIV #360.,A	;DIVIDE B BY 360
	TST B		;REM >= 0?
	BGE	M360R
	ADD	#360.,B	;IF REMAINDER WAS NEGATIVE, ADD 360 TO IT
M360R:	RTS	PC


.IFZ FPPF

;MULCOS
;	RETURN A*COSINE OF CURA IN B,,C
MULCOS:	MOV	COSA,F
	BR	MULCS2
;MULSIN
;	RETURN A*SINE OF CURA IN B,,C
MULSIN:	MOV	SINA,F
MULCS2:	CLR	E
	ASL	F	;TURN INTO BOTTOM HALF OF DP NUMBER
	SBC	E	;MAKE E NEG. IF F WAS
	JSR	PC,.DPMUL
	NOP	1
	RTS	PC
.ENDC

;ANGCRP
;	CALCULATE ANGLE CRAP.
;	CALCULATE DIREC, SINA, COSA
ANGCRP:
.IFZ FPPF
	CLR E
.IFZ DDF
	MOV CURA,F	;DIVIDE CURA BY 90.
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	MOV CURA(F),F	;F <- CURX
.ENDC
	DIV #90.,E
	MOV F,C		;THE REMAINDER
	MOV E,F		;THE QUOTIENT
	MOV #90.,E	;THE RIGHT ANGLE
	SUB	C,E	;NOW E = 90.- REMAINDER
	MOV	C,A	;A_REMAINDER
	JSR	PC,SINGET	;D_SIN (A)
	MOV	D,B
	MOV	E,A
	JSR	PC,SINGET
	ASL	F	;F = 0,1,2,3
	ADD	F,PC	;JUMP THROUGH THIS DISPATCH TABLE
	BR	ACR.D
	BR	ACRII	;QUADRANT II
	BR	ACRIII	;QUADRANT III
;FOURTH QUADRANT
	MOV	B,A	;SIN (A)
	MOV	D,B	;SIN (90-A)
	NEG	B	;SINA=-SIN(90-A) IN 4TH QUADRANT
	MOV	A,D	;AND COSA=SIN(A) IN 4TH QUADRANT
	BR	ACR.D

;THE THIRD QUADRANT
ACRIII:	NEG	B	;SINA = -SIN (A) IN 3RD QUADRANT
	NEG	D	;COSA = - SIN (90-A) IN 3RD QUADRANT
	BR	ACR.D

;SECOND QUADRANT
ACRII:	MOV	B,A	;SIN (A)
	MOV	D,B	;SINA = SIN (90-A) IN 2ND QUADRANT
	MOV	A,D
	NEG	D	;COSA = -SIN (A) IN 2ND QUADRANT

;IN THE FIRST QUADRANT
;SINA = SIN (A) AND
;COSA = SIN (90-A)
ACR.D:	MOV	B,SINA
	MOV	D,COSA

;FALLS THROUGH
;FALLS IN

;CLACULATE DIREC FROM STUFF LEFT IN F AND C BY ANGCRP
ANGDIR:	CMP	#45.,C
	ADC	F	;CARRY SET IF C<45
	ASL	F
	ASL	F
	ASL	F
	MOV	F,DIREC
	RTS	PC

;GET SIN (A) INTO D.
;THE SINE TABLE HAS ONLY EVEN ANGLES.  INTERPOLATE ODD ANGLES.
SINGET:	BIT	#1,A	;ODD OR EVEN
	BEQ	AEVEN
	ADD	#<SIN+1>,A	;POINT TO ANGLE AFTER IT
	MOV	(A),D	;SIN (A+1)
	ADD	-(A),D	;PLUS SIN (A-1)
	ROR	D	;DIVIDED BY 2
	RTS	PC
AEVEN:	MOV	SIN(A),D
	RTS	PC

.IFF
	SETI
.IFZ DDF
	LDCIF CURA,FA	;ANGCRP FOR FLOATING DISP
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	LDCIF CURA(F),FA	;FA <- CURA
.ENDC
	SETL
	STF FA,FE	;SAVE ANGLE
	JSR PC,SINDEG	;FA <- SIN (FA)
.IIF Z DDF,	STCDF FA,SINA
.IIF NZ DDF,	STCDF FA,SINA(F)	;SINA <- SINE OF ANGLE
	LDD FE,FA	;GET ANGLE
	JSR PC,COSDEG	;FA <- COS (FA)
.IIF Z DDF,	STCDF FA,COSA
.IIF NZ DDF,	STCDF FA,COSA(F)	;COSA <- COSINE OF ANGLE
	ASL C		;CALCULATE DIRECTION
	ASL C
	MOV C,DIREC
 	RTS PC

SINEF:	JSR PC,G1NUM	;FA <- ARGUMENT
	BNE .+4
	ERROR+WTAB	;WRONG TYPE OF ARG
	JSR PC,SINDEG	;FA <- SINE (FA)
	MOV #FNUM,F	;TELL .FST.1 IT'S AN FNUM
	STCDF FA,-(P)	;PUT SINE ON STACK FOR .FST.1
	JMP .FST.1	;PUT IT INTO A NODE


COSF:	JSR PC,G1NUM	;FA <- ARGUMENT
	BEQ SINEF+6
	JSR PC,COSDEG	;FA <- COSINE (FA)
COSF1:	MOV #FNUM,F	;TELL .FST.1 IT'S AN FNUM
	STCDF FA,-(P)	;PUT COSINE ON STACK FOR .FST.1
	JMP .FST.1	;PUT IT INTO A NODE

SINDEG:	MOV #-1,A
	BR TRIG
COSDEG:	MOV #1,A
TRIG:	MOV #1,B
	TSTF FA
	CFCC
	BGE TRIG1
	NEGF FA
	MUL A,B
TRIG1:	DIVF #41464,FA	;DIVIDE BY 45
	MODD #40200,FA	;SEPERATE FRACTION AND INTEGER
	MODD #37400,FB
	MULF #41000,FB	;MOD 8
	SETI
	STCFI FB,C
	SETL
	ASL C
	ADD C,PC
	BR .TRIG0
	BR .TRIG1
	BR .TRIG2
	BR .TRIG3
	BR .TRIG4
	BR .TRIG5
	BR .TRIG6
	MUL A,B
	BR .TRIG7
.TRIG6:	MUL A,B 
	NEG A
	BR .TRIG0
.TRIG4:	NEG B
	BR .TRIG0
.TRIG3:	NEG B
	MUL A,B
	BR .TRIG7
.TRIG2:	NEG A
	MUL A,B
	BR .TRIG0
.TRIG5:	NEG B
.TRIG1:	NEG A
.TRIG7:	SUBF #40200,FA	;WE WANT 45 - ANGLE
	NEGF FA
.TRIG0:	MULF PI,FA
	MULF #37600,FA	;CONVERT FROM DEGREES TO RADIANS
	LDD FA,FD
	MULF FD,FD
	NEGF FD		;-ANGLE SQUARED INTO FD
	LDCFD #40200,FB	;COUNTING CONSTANT "1"
	STF FB,FF
	TST A
	BLT .TRIG9	;WE WANT SIN
	LDD FB,FA
	CLRF FB
.TRIG9:	LDD FA,FC
	TSTF FD
	CFCC
	BEQ TRIG11
TRIG10:	ADDF FF,FB
	DIVF FB,FC
	ADDF FF,FB
	DIVF FB,FC
	MULF FD,FC
	ADDF FC,FA
	CMPF #41100,FB
	CFCC
	BGE TRIG10
TRIG11:	TST B
	BGE .+4
	NEGF FA
	RTS PC

ATAN:	JSR PC,G1ARG	;ARG IN FA, DOES SEZ IF IT FINDS A NUMBER
	BNE .+4		;DID WE GET A NUMBER?
	ERROR+WTA	;NO
	CLRF FB		;WILL HOLD THE SUM
	CLR A		;A FLAG
	MOV #5,C	;FOR A LOOP
	SETD		;WE WILL BE VERY ACCURATE
	MOV #ATANC0,D	;D POINTS TO CONSTANT TABLE
	MOV #PIFOUR,B	;B POINTS TO PI/4
	TSTF FA		;IS ARG NEGATIVE
	CFCC		;A DREADFUL DEC CROCK
	BGE ATANOK	;ARG NON-NEGATIVE
	ABSF FA		;ARG IS NEGATIVE
	INC A		;SO SET FLAG
ATANOK:	STF FA,FC	;SAVE ARG INTO FC
	CMPF #40200,FA	;#40200 IS A FLOATING 1. IS ARG
	CFCC		;BIGGER THEN 1?
	BGE ATANK1	;YES, NO HACKING NEEDED
			;FOR ARG > 1 A DIFFERENT APPROXIMATION IS USED
	LDCFD (B)+,FB	;B POINTS TO A CONSTANT TO BE ADDED TO THE SUM
	ADDF #40200,FC	;ARG BECOMES ((ARG - 1)/(ARG + 1))
	SUBF #40200,FA	
	DIVF FC,FA	;NEW ARG IS IN FA
	STF FA,FC	;AND ALSO IN FC
ATANK1:	MULF FA,FC	;FC NOW HAS (ARG ** 2)
	STF FC,FE	;FE HOLDS (ARG**2) FOR USE IN THE LOOP
	STF FA,FC	;RESTORE ARG
	BR .+4		;SKIP FIRST INSTRUCTION
ATANLP:	MULF FE,FC	;FC _ (ARG ** (2*I + 1)
	LDF (D)+,FD	;LOAD CONSTANT INTO FD
	MULF FC,FD	;IN THE I'TH LOOP, FC HAS (ARG **(2*I + 1)
	ADDF FD,FB	;ADD IT TO THE SUM
	SOB C,ATANLP	;WE DO THIS FIVE TIMES
	SETI
	LDCIF #180.,FA	;CHANGE TO DEGREES
	SETL
	MULF FB,FA	;GET THE NUMBER OF DEGREES * PI INTO FA
	DIVF PI,FA	;DIVIDE BY PI
	TST A		;WAS ARG NEGATIVE?
	BEQ .+4		;NO, NEVER WAS
	NEGF FA		;YES, SO CHANGE SIGN AGAIN
	JMP COSF1	;RETURN ARG
.ENDC


;XYDIR
;	CALL WITH D=DX, E=DY
;	CALCULATE DIREC BASED ON DX AND DY
XYDIR:	CLR	A	;BUILD INDEX IN A
	TST	D	;IS DX POSITIVE
	BGE	XYDIR1
	NEG	D	;ABSOLUTE VALUE OF DX
	TST	(A)+	;PUT 2 INTO A
XYDIR1:	TST	E	;IS DY POSITIVE
	BGE	XYDIR2
	NEG	E	;ABSOLUTE VALUE OF DY
	INC	A	;INCREMENT INDEX
XYDIR2:	CMP	D,E	;WILL GENERATE CARRY IF D<E
	ROL	A	;PUT CARRY INTO BOTTOM BIT OF INDEX.  AND MULTIPLY REST BY 2
	MOVB	DREC(A),DIREC	;NOW MOVE THE RIGHT THING INTO DIREC
	RTS	PC




.IFNZ NDISP

;DYXFR
;	TRANSFER FROM STATIC AREA TO DYNAMIC AREA
;	THE CODE BEING TRANSFERRED STARTS AT D AND GOES UP TO STT
;	ON RETURN, D POINTS TO THE TRANSFERRED DCODE
;	IF NO CODE WAS TRANSFERRED, THEN D = 0.
;	SKIPS IF THERE'S ROOM FOR TRANSFER
DYXFR:	MOV	STT,E
	SUB	D,E	;LENGTH OF DCODE TO BE MOVED
	BEQ	DYRET	;NOTHING TO BE MOVED
;ALLOCATE STORAGE
;LENGTH OF BLOCK TO BE ALLOCATED IS IN E
DYAL:	ADD	#6,E	;INCREASE LENGTH TO ALLOW FOR REF CNTR, DEPTH CNTR, AND POPJ
	MOV	DYR,B	;INITIALIZE POINTER
	MOV	#1,C	;INITIALIZE FLAG
DYAL1:	MOV	2(B),A	;POINTER TO NEXT FREE BLOCK
	BNE	DYAL2
	DEC	C	;NO NEXT FREE BLOCK--TEST AND SET FLAG
	BNE	DYAL7	;NO MORE ROOM--GO TO EXPAND DY AREA
	MOV	DYB,B	;START AGAIN AT BOTTOM OF LIST
	BR	DYAL1
DYAL2:	MOV	(A),F	;FREE BLOCK FOUND--CHECK LENGTH
	SUB	E,F
	BPL	DYAL4
DYAL3:	MOV	A,B	;BLOCK TOO SHORT--MOVE TO NEXT BLOCK
	BR	DYAL1
DYAL4:	BNE	DYAL5	;BLOCK LONG ENOUGH--IF FILLED EXACTLY
	MOV	2(A),2(B)	;REMOVE BLOCK FROM LIST BY CHANGING POINTERS
DYAL5:	CMP	F,#2	;DONT LEAVE A BLOCK OF LENGTH 2 BYTES
	BEQ	DYAL3
	MOV	F,(A)	;NEW LENGTH OF FREE BLOCK
	MOV	2(B),C	;RESET ROVING POINTER
	BNE	DYAL6	;DONT SET IT TO O
	MOV	DYB,C
DYAL6:	MOV	C,DYR	
	ADD	F,A	;START STORING AT THIS ADDRESS
	BR	DYAL9
DYAL7:	MOV	DYB,A	;ADD NEW BLOCK TO BOTTOM OF LIST
	MOV	2(A),F	;POINTER TO 2ND FREE BLOCK
	SUB	E,A
	CMP	A,STT
	BHI	DYAL8	;THERE IS ENOUGH ROOM IN THE DY AREA
	SEZ
	RTS	PC	;NOT ENOUGH ROOM
DYAL8:	MOV	A,DYB	;NEW BOTTOM OF DY
	MOV	A,DYR	;FIX ROVING POINTER
	MOV	DYB,C	;SET UP NEW LIST BOTTOM
	CLR	(A)+
	MOV	F,(A)+
DYAL9:	SUB	#6,E	;RESTORE LENGTH


;NOW A CONTAINS ADDRESS OF FREE BLOCK
;E CONTAINS NUMBER OF BYTES TO BE TRANSFERRED
;NOW FINALLY YOU GET TO DO THE TRANSFER
;WHILE YOU DO IT, INCREMENT THE REF COUNTER OF ANY PUSHJ'S
DYXFR1:	MOV	#100000,C	;THE CODE FOR DISPLAY PUSHJ
	MOV	#140000,B	;NEXT HIGHER DISPLAY COMMAND
	SPUSH	A	;SAVE POINTER TO DEPTH COUNTER
	CLR	(A)+	;DEPTH_0
	CLR	(A)+	;SET REFERENCE COUNTER TO ZERO
	ASR	E	;E/2 = NUMBER OF WORDS TO BE TRANSFERRED
;PICK UP A WORD.  SEE IF ITS A PUSHJ. AND TRANSFER IT
DYXFR2:	DEC	E	;NUMBER OF WORDS TO BE XFRED
	BLT	DYXFR3
	MOV	(D)+,F	;WORD OF DCODE IN F
	MOV	F,(A)+	;PUT THIS WORD IN ITS NEW PLACE
	CMP	F,C
	BLO	DYXFR2	;NOT A PUSHJ
	CMP	F,B
	BHIS	DYXFR2	;NOT A PUSHJ
;IT IS A PUSHJ
	MAKEAD	F
	INC	-(F)	;INCREMENT THE REF COUNTER
	CMP	-(F),@(SP)	;DEPTH _ MAX (DEPTH OF SUB SNAPS)
	BLE	DYXFR2
	MOV	(F),@(SP)	;DEPTH OF SUB SNAP BIGGEST YET
	BR	DYXFR2	;LOOP BACK

;ALL TRANSFERRING DONE.  END THE BLOCK WITH A POPJ
DYXFR3:	MOV	#DPOPJ,(A)
	SPOP	D	;POINTER TO DEPTH COUNTER
	INC	(D)+
	TST	(D)+	;POINTER TO FIRST D.WORD OF SNAP
	CLZ
	RTS PC	;AND RETURN

;THERE WAS NOTHING TO BE MOVED
DYRET:	CLR	D	;TO SIGNAL THIS FACT
	CLZ
	RTS PC

;DYFREE
;	CALLED DURING GARBAGE COLLECTIONS
;	CALL WITH D POINTING TO REF COUNTER (WORD BEFORE SNAP)
;	FREES THE BLOCK!!
DYFREE:	PUSH	A	;SAVE REGISTERS
	SPUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F

	MOV	#100000,A
	MOV	#140000,B
	MOV	#DPOPJ,C
	JSR	PC,DYF1	;DOES THE FREEING
	JMP	RETF	;RESTORE AC'S AND RETURN TO OUT OF DYFREE

;REAL WORK OF FREEING STARTS HERE.
DYF1:	MOV	D,-(SP)	;SAVE PTR TO 2ND WORD OF BLOCK
	TST	(D)+	;POINT D TO FIRST WORD

;PICK UP EACH WORD OF BLOCK.  IF IT IS A PUSHJ, FREE THAT BLOCK
;CONTINUE UNTIL A POPJ IS REACHED
DYF11:	MOV	(D)+,F	;NEXT WORD
	CMP	F,A
	BLO	DYF11	;NOT PUSHJ OR POPJ
	CMP	F,B
	BHIS	DYF2	;NOT PUSHJ, BUT MAY BE POPJ

;	ITS A PUSHJ
	MAKEAD	F
	DEC	-(F)	;REF COUNTER
	BR DYF11	;LOOK AT NEXT WORD

;IS THE WORD A POPJ
DYF2:	CMP	F,C	;C CONTAINS A POPJ
	BNE	DYF11	;NOT A POPJ.  LOOK AT NEXT WORD
	SPOP	C	;POINTER TO 2ND WORD OF BLOCK
	TST	-(C)	;NOW IT POINTS TO BOTTOM WORD
	SUB	C,D	;LENGTH OF BLOCK
	MOV	D,F


;NOW LINK BLOCK BACK TO FREE CORE
;C/ADDRESS OF BLOCK TO BE LIBERATED
;F CONTAINS LENGTH OF BLOCK

DYLIB:	MOV	DYB,B	;INITIALIZE POINTER TO BOTTOM OF LIST
DYLIB1:	MOV	2(B),A	;NEXT FREE BLOCK
	BEQ	DYLIB3	;AT END OF LIST
	CMP	A,C
	BHI	DYLIB2	;PASSED BLOCK TO BE FREED
	MOV	A,B	;TRY NEXT FREE BLOCK
	BR	DYLIB1
DYLIB2:	MOV	F,D	;CHECK UPPER BOUND
	ADD	C,D	;DO WE COLLAPSE NEW BLOCK WITH NEXT ONE?
	CMP	D,A
	BNE	DYLIB3	;NO
	ADD	(A),F	;YES--NEW LENGTH
	MOV	2(A),2(C)	;NEW POINTER
	CMP	A,DYR	;DID WE JUST SCREW ROVING POINTER?
	BNE	DYLIB4
	MOV	DYB,DYR	;YES--RESET IT
	BR DYLIB4
DYLIB3:	MOV	A,2(C)	;POINTER TO NEXT FREE BLOCK--NO COLLAPSE ON TOP
DYLIB4:	MOV	(B),D	;CHECK LOWER BOUND
	ADD	B,D
	CMP	D,C	;DO WE COLLAPSE WITH BLOCK ON BOTTOM?
	BNE	DYLIB5	;NO
	ADD	F,(B)	;NEW LENGTH OF PREVIOUS BLOCK
	MOV	2(C),2(B)	;NEW POINTER
	BR	DYLIB6
DYLIB5:	MOV	C,2(B)	;POINTER IN PREVIOUS BLOCK--NO COLLAPSE
	MOV	F,(C)	;LENGTH OF BLOCK JUST FREED
DYLIB6:	MOV	C,A	;DID WE JUST FREE BOTTOM BLOCK IN DY?
	SUB	#4,A
	CMP	A,DYB	;NOTE THAT IF CURRENT BLOCK = DYB+4
			;THEN PREVIOUS BLOCK (ADDR IN B) MUST BE DYB
	BNE	DYLIB7	;NO
	ADD	(C),B	;YES--COLLAPSE DY AREA
	CLR	(B)
	MOV	2(C),2(B)	;NEW BOTTOM BLOCK
	MOV	B,DYB
	MOV	B,DYR	;FIX POINTERS
DYLIB7:	RTS	PC


;DSGCF
;	CALLED BY LOGO GARBAGE COLLECTOR WHEN ITS ALL DONE
;	SEE IF EACH SNAP ON THE SNAP LIST WAS MARKED.
;	AND DYFREE THE SNAP IF NOT MARKED AND IT'S REFERENCE COUNTER IS 0

DSGCF:	CLR	F
	BR	DSGC1

DSGC4:	TST	F	;0 IF FIRST TIME THROUGH
	BEQ	DSGC5

;
;CODE FROM DSGC8 - DSGC9 GETS CALLED BY DCHK TO COMPRESS DISPLAY AREA
;
DSGC8:	MOV	STB,A	;COMPRESS ADDX'S AND ADDY'S IN STATIC AREA
	MOV	SNABOT,B	;FIRST DO PART BELOW SNAP BOTTOM
	JSR	PC,ADDSHK
	MOV	C,SNABOT	;C IS NEXT LOCATION TO STORE INTO
	MOV	STT,B	;NOW DO PART ABOVE SNAP BOTTOM
	JSR	PC,ADHK0	;DON'T RECLOBBER C.
	MOV	(A),(C)	;STORE PUSHJ TURTLE, TOO
	MOV	C,STT
	CLR	NADXY

DSGC9:	RTS	PC
DSGC5:	MOV	#<DSGC6-DSGCF1>,F	;NOW CLEAR MARKED BITS
DSGC1:	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BEQ	DSGC8	;OBVIOUSLY DOESN'T HAVE SNAPS

	JSR	PC,.LOADC	;FIRST NODE OF LIST IS DUMMY
DSGC2:	MOV	C,E	;SAVE POINTER TO NODE
DSGC3:	BIT	#7777,A	;LEAVE ADDRESS ONLY
	BEQ	DSGC4	;END OF LIST
	MOV	A,C	;POINTER TO NEXT NODE
	JSR	PC,.LOADC
	ADD	F,PC	;CHOOSE BETWEEN FREEING AND CLEARING

;TRY TO FREE THE SNAP
DSGCF1:	TST	-(B)	;WAS SNAP MARKED?  (B POINTS TO REF COUNT)
	BNE	DSGC2	;EITHER DISPLAYED OR MARKED

;NOT MARKED, AND NOT DISPLAYED ANYWHERE!!
;FREE THIS SNAP
	JSR	PC,.FREE	;CLEAN UP SNLIST
	MOV	E,C	;POINTER TO PREVIOUS NODE OF SNLIST
	JSR	PC,.STP1	;STORE A AS TOP WORD OF PREVIOUS NODE
	MOV	B,D	;POINTER TO SNAP DCODE
	JSR	PC,DYFREE
	BR	DSGC3

DSGC6:	BIC	#100000,-(B)	;CLEAR MARKED BIT
	BR	DSGC3

;ADDS HACK
;	COMPRESS ADDX'S AND ADDY'S STARTING AT LOCATION IN A
;	AND GOING TO LOCATION IN B. (DOESN'T STORE WORD AT LOC IN B)
ADDSHK:	MOV	A,C	;C IS NEXT LOC TO STORE INTO.
ADHK0:	CLR	-(SP)	;FLAG. (NOT IN MIDDLE OF ADD'S)
ADHK1:	CMP	A,B	;ARE WE DONE?
	BHIS	ADFIN	;YES
	MOV	(A)+,D	;NEXT WORD
	CMP	D,#ADDY
	BLO	ADNOT	;NOT AN ADD
	TST	(SP)	;IN MIDDLE OF ADD'S ALREADY ?
	BNE	ADPHS1	;YES
	CLR	E	;NO. THIS IS FIRST ADD
	CLR	F
	INC	(SP)	;SET FLAG
ADPHS1:	CMP	D,#ADDX	;THE BIGGER ADD COMMAND
	BHIS	ADPHSX
;IT IS AN ADDY
	ADD	D,F	;ADD THE DELTA-Y INTO F
	BR	ADHK1	;LOOP BACK
ADPHSX:	ADD	D,E	;ADD THE DELTA-X INTO E
	BR	ADHK1

ADNOT:	TST	(SP)
	BEQ	ADHK2	;NOT END OF ADD'S
	JSR	PC,ADPHSF	;JUST ENDED ADDS.
	CLR	(SP)
ADHK2:	MOV	D,(C)+	;STORE THIS WORD
	BR	ADHK1

ADFIN:	TST	(SP)+	;ALL WORDS PICKED UP
	BEQ	ADHK3
	JSR	PC,ADPHSF	;BUT FIRST FINISH ADDS
ADHK3:	RTS	PC

;ADD PHASE FINISHED.  STORE ADDX E, ADDY F.
ADPHSF:	BIC	#176000,E
	BIC	#176000,F
	BEQ	ADPF1	;DELTA-Y = 0
	BIS	#ADDY,F
	MOV	F,(C)+	;STORE ADDY
ADPF1:	TST	E
	BEQ	ADPF9	;DELTA-X = 0
	BIS	#ADDX,E
	MOV	E,(C)+	;STORE ADDX
ADPF9:	RTS	PC


;MKDC
;	CALLED BY LOGO GARBAGE COLLECTOR DURING MARKING PHASE
;	CALLED WITH B POINTING TO SNAP NODE
MKDC:	TST	SNLIST	;CALLED TO KILL THE DISPLAY?
	BEQ	MKDC.K	;YES
	BIT	#7777,B
	BEQ DSGC9	;EMPTY SNAP
;MARK THE SNAP
	PUSH	A
	SPUSH	B
	JSR	PC,.LOAD	;POINT B TO NODE CONTAINING SNAP ADDR
	TST B
	BEQ MKDC1
	JSR	PC,.LOAD	;B_SNAP ADDRESS
	BIS	#100000,-(B)	;MARK REF COUNTER
MKDC1:	SPOP	B	;RESTORE A AND B
	SPOP	A
	RTS	PC

;CALLED BY KILLDISPLAY
;TURN SNAP INTO EMPTY SNAP
MKDC.K:	SPUSH	A
	SPUSH	B
	SPUSH	C
	MOV	B,C	;POINTER TO DCODE NODE
	CLR	A
	JSR	PC,.STP2
	JMP	RETC



;HERE START THE LINE AND TURTLE DRAWING PROGRAMS

;DR.LIN
;	DRAW A LINE. D=DX, E=DY, OR VICE VERSA.
;	THE DIRECTION CODE FOR THE LINE IS IN DIREC
DR.LIN:	CMP DIREC,ODIREC
	BEQ .+6
	CLR DFBCNT
	JSR	PC,DR.STUP	;SET A=CON, B=AC.
	SPUSH	D
	ADD	STT,D	;D = HOW MANY MORE WORDS IN DLIST
	CMP	D,DYB	;COMPARE TO DY BOTTOM
	BLO	DR.L1	;THERE'S ROOM
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	SPOP	D	;TRY TO FIT LINE AGAIN
	ADD	STT,D
	CMP	D,DYB
	BLO	DR.L2	;THERE'S ROOM!
	ERROR+TML	;TOO MANY LINES

;OKAY, THERE WAS ROOM FOR THE LINE
DR.L1:	TST	(SP)+	;WE HAD PUSHED D UP ABOVE
DR.L2:	MOV	D,STT	;SET STT TO NEW STATIC TOP
	MOV	PUSHJT,(D)	;PUT PUSHJ TURTLE AT TOP
	JSR	PC,DR.ASC	;ASSEMBLE THE DISPLAY CODE
	MOV DIREC,ODIREC
	RTS	PC	;RETURN


;DRAW THE TURTLE
DR.TUR:	PUSH DIREC
	SPUSH DFBCNT
	MOV	#TURSIZ,C	;TURTLE SIZE
.IFZ FPPF
	CLR	B
	JSR	PC,MULCOS	;E,,F _ SIZE * COSA
	ROL	F
	ADC	E	;ROUND
	MOV	E,D
	JSR	PC,MULSIN	;E,,F _ SIZE * SINA
	ROL	F
	ADC	E	;ROUNFD
.IFF
	SETI
	LDCIF C,FA
	SETL
.IIF NZ DDF,	LDCFD DSINA,FB
.IIF Z DDF,	LDCFD SINA,FB
	MULF FA,FB
	ADDF #40000,FB	;ROUND
.IIF NZ DDF,	LDCFD DCOSA,FC
.IIF Z DDF,	LDCFD COSA,FC
	MULF FA,FC
	ADDF #40000,FC
	SETI
	STCFI FB,E
	STCFI FC,D
	SETL
.ENDC

	SPUSH	D
	SPUSH	D
	SUB	E,2(SP)	;NOW SIZE * (COSA - SINA) IS ON STACK
	ADD	E,(SP)	;NOW SIZE * (COSA + SINA) IS ON STACK

	MOV	TUB,TUT	;TUT WILL BE POINTER TO TOP OF TURTLE DLIST SO FAR

;SIDE 1
	ADD	#20,DIREC	;SIDE 1 IS 2*45 DEGREES LEFT OF CURRENT DIRECTION
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 2
	SUB	#30,DIREC	;SIDE 2 IS 3*45 DEGREES RIGHT OF SIDE 1
	MOV	(SP)+,D	;DX IS SIZE * (COSA + SINA)
	MOV	(SP)+,E	;DY IS SIZE * (COSA - SINA)
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 3 HAS THE SAME INCREMENTS AS SIDE 2.
;JUST THE DIRECTION IS DIFFERENT
	MOV	DIREC,B
	SUB	#20,B	;SIDE 3 IS 2*45 DEGREES RIGHT
	BIC	#177707,B	;LEAVE ONLY THE 3 BITS
	SWAB	B	;PUT THE DIREC BITS IN TOP BYTE
	MOV	TUT,C	;POINTS TO WORD ABOVE LAST ONE OF TURTLE DLIST
	MOV	C,A
	SUB	D,C	;SINCE D POINTS TO BOTTOM WORD OF SIDE 2
			;C-D IS NUMBER OF BYTES IN SIDE 2'S DLIST
	ASR	C	;C/2 = NUMBER OF WORDS
DR.TS3:	MOV	(D)+,E	;NEXT WORD OF SIDE 2'S DLIST
	BIC	#34000,E	;CLEAR THE DIRECTION BITS THEREIN
	BIS	B,E	;AND SET THEM FROM THE NEW DIREC IN B
	MOV	E,(A)+	;STORE IN DLIST
	DEC	C	;NUMBER OF WORDS IN SIDE 2'S DLIST
	BGT	DR.TS3	;THERE ARE MORE WORDS

;SIDE 4 IS IDENTICAL TO SIDE 1
;FURTHERMORE, SIDE 1 IS MADE UP OF ONLY ONE WORD
	MOV	@TUB,(A)+	;PUT THE FIRST WORD OF TURTLE INTO TOP WORD
	MOV	#DSTOP!DPOP,(A)

;RESTORE DIREC, THEN RETURN
	SPOP DFBCNT
	POP DIREC
	RTS	PC


;DRAW TURTLE SIDE
;	DRAW ONE SIDE OF THE TURTLE
;	DIREC CONTAINS THE DIRECTION
;	TUT POINTS TO TOP OF TURTLE DISPLAY LIST SO FAR
;	C,D = + OR - DX OR DY
DR.TSD:	BIC	#177707,DIREC	;BITS MAY HAVE BEEN SET BY THE SUBTRACTING
	CLR DFBCNT
	JSR	PC,DR.STUP
	ADD	TUT,D	;D = NEW TOP OF TURTLE
	MOV	D,TUT
	JMP	DR.ASC	;ACTUALLY CREAT THE DISPLAY LIST


;SET UP CON AND AC
;	CALL WITH D,E = + OR - DX OR DY
;	PASSES ON A=FRACTION: MIN (DX/DY,DY/DX)
;		B=ACCUMULATED FRACTION PART SIDEWAYS OF MAIN DIRECT.
;		STARTS AT 1/2
DR.STUP:	TST	D
	BGE	DR.TE	;TEST E
	NEG	D	;MAKE D POSITIVE
;MAKE SURE E IS POSITIVE
DR.TE:	TST	E
	BGE	DR.BIG	;NEXT WE'LL SEE WHICH IS BIGGER
	NEG	E	;MAKE D POSITIVE

;WHICH IS BIGGER
DR.BIG:
	CLR B		;CLEAR LOW WORD OF WHICHEVER NUMBER
	CMP	D,E
	BGT	DR.DBG	;D IS BIGGER
	BEQ	DR.EQ	;THEY ARE THE SAME SIZE

;OTHERWISE, E IS BIGGER
	ASL	E	;SO EAE WON'T OVERFLOW WITH A 16 BIT QUOTIENT
	MOV D,A		;DIVIDE D,,0 BY E
	DIV E,A
	MOV	E,F	;WHICHEVER IS BIGGER IS THE NUMBER OF INCS
	BR	DR.SC4

;THEY ARE THE SAME SIZE
DR.EQ:	MOV	#-1,A	;SET CON = .777...
	MOV	E,F	;NUMBER OF INCS
	BR	DR.SC5

;D IS BIGGER
DR.DBG:	ASL D
	MOV E,A		;DIVIDE E,,0 BY D
	DIV D,A
	MOV	D,F	;NUMBER OF INCS

;NOW PICK UP THE QUOTIENT
DR.SC4:
	ASL	A	;MAKE QUOTIENT 16 BITS
	ASR	F	;SINCE WE DOUBLED IT ABOVE

;NOW SET AC = .1000 = 1/2 IN THIS REPRESENTATION
DR.SC5:	MOV	#100000,B
;FALLS IN!

;CALCULATE THE NEW END POINT OF THE DLIST
;	RETURNS A AND B AS ABOVE
;	C = BIT-POSITION OF LAST BIT OF NEW CODE
;	  (GENERATED BACKWARDS--STORE FROM HERE BACK)
;	D = NUMBER OF MORE WORDS IN DLIST
;	  (WILL BECOME ADDR OF LAST NEW WORD + 2)
;	E = TOP BYTE OF INCR INSTRUCTION, SWAPPED
;	F = # NEW INCREMENTS
DR.NEP:	CLR C		;CLEAR BIT-POSITION
	MOV F,E		;GET # OF INCREMENTS
	SUB DFBCNT,E	;LESS # LEFT OVER
	MOV E,D
	ASH #-3,D	;DIVIDE BY 8
	ASL D
	BIC #177770,E	;REMAINDER IS # BITS IN LAST WORD
	BEQ DR.NE2	;IF 0 THEN = 8 IN PREVIOUS WORD

	MOV #8.,DFBCNT	;ELSE FREE BITS = 8 - # USED
	SUB E,DFBCNT
	TST (D)+	;ADD ONE-WORD FUDGE FACTOR IN THIS CASE
	SPUSH E
	SEC
DR.NE1:	RORB C		;SHIFT FIRST-BIT IN OR RIGHT ONE BIT
	DEC E		;SHIFT IT RIGHT (REMAINDER) PLACES
	BNE DR.NE1
	SPOP E
	BR DR.NE3

;REMAINDER WAS 0:  LAST WORD GETS FILLED UP
DR.NE2:	INC C		;LAST BIT IS LAST IN WORD
	CLR DFBCNT	;NO FREE BITS

DR.NE3:	ADD #DINC_-8,E	;PUT IN "INCREMENT" CODE
	ADD	DIREC,E	;ADD IN THE DIRECTION
	RTS	PC


;ACTUALLY ASSEMBLE THE NEW DISPLAY LIST
;	CALL WITH A=SIDEWAYS/FORWARD, B=1/2 (ACCUM SIDEWAYS),
;	C=FIRST BIT POS., D=POINTER  TO FIRST WORD TO STORE OF DLIST
;	E=TOP HALF OF THE INC MODE INSTRUCTION, F=NUMBER OF INCS
DR.ASC:	SWAB	E	;STUFF IN E WAS IN WRONG HALF
DR.AS0:	ADD	A,B	;CON+AC
	BCC	DR.AS1
	ADD	C,E	;CARRY, SO PUT A 1 INTO DCODE
DR.AS1:	DEC	F	;NUMBER OF INCS
	BLE	DR.ALW	;THIS WAS THE LAST WORD
	CLC
	ROLB	C	;SHIFT BYCNT
	BCC	DR.AS0	;CONTINUE WITH THIS WORD

;THIS WORD DONE
	JSR	PC,DR.SH
	MOV	E,-(D)	;STORE IN DLIST
	BIC	#3777,E	;0 THE COUNT AND BOTTOM BYTE
	MOV	#1,C	;RESET BYCNT
	BR	DR.AS0

;ALL THAT'S LEFT TO DO IS STORE THE BOTTOM WORD OF NEW DLIST
DR.ALW:	MOV -(D),B	;GET WORD TO HOOK
	CLR A		;SET UP BIT TO HOOK FROM
	SEC		;  "
DR.LW1:	ROL A		;  "  OR NEXT BIT TO HOOK FROM
	CLC
	ROLB C		;NEXT BIT TO HOOK INTO
	BCS DR.LW2	;DONE HOOKING
	BIT A,B		;GET BIT
	BEQ DR.LWX
	ADD C,E		;STORE IT
DR.LWX:	CLC		;SET UP FOR ROL A
	BR DR.LW1

DR.LW2:	JSR	PC,DR.SH	;SHOVE TO RIGHT END OF WORD
	MOV	E,(D)	;STORE LAST WORD
	RTS	PC

;SHIFT CODE RIGHT 8 MINUS COUNT TIMES

DR.SH:	PUSH	E
	SWAB E		;GET COUNT OF USED BITS
DR.SH1:	BIC #177770,E	;ISOLATE COUNT
	BEQ	DR.SH2	;DONE
	INC E		;COUNT UP; DONE AT 8 (OR 0)
	CLC
	RORB	(SP)	;MAKE ANOTHER FREE BIT AT LEFT
	BR	DR.SH1
DR.SH2:	POP	E
	RTS	PC

.ENDC
.STITL DISPLAY BUFFERS
CODEND==.
CODENB==<<._-6>&1777>+1
PUREK==<PURE_-11.>&37
HEREK==<._-11.>&37
.IF GT PUREK+16.-HEREK
.IF NZ NDISP
	.=PURE+100000
.ENDC
NCODEB==<<._-6>&1777>-CODENB
.ENDC
.IFNZ NDISP

	DPDL=DSLOT
	TLIST=DPDL+DPDLL
	DLIST=TLIST+TLEN
.ENDC

.IFNZ GTI
.GTIOUT:	JSR PC,G1NARG
	JSR PC,GTOUT
	SEZ
	RTS PC

GTOUT:	JSR F,ACSAV
	MOV #33,A
	JSR PC,GTTYO
	CLR A
	ASL B
	MOV #3,D
GTOUT1:	ASHC #5,A
	BIC #177740,A
	ADD #100,A
	JSR PC,GTTYO
	SOB D,GTOUT1
	JSR F,ACRES
	RTS PC

GTTYO:	JSR F,ACSAV
	MOV A,B
	JSR PC,CTYO1
	JSR F,ACRES
	RTS PC
CLIP:	GTJUMP GTCLP
	ERROR+OGT
.INSRT GTFUN >
.IFZ NTVS!NDISP
HIDETU:	GTJUMP GTHIDE
	ERROR+OGT
SHOWTU:	GTJUMP GTSHOW
	ERROR+OGT
CLEARSCREEN:	GTJUMP GTCLEA
	ERROR+OGT
SNAP:	GTJUMP GTSNP
	ERROR+OGT
DISPLAY:	GTJUMP GTDIS
	ERROR+OGT
.IFZ NPLOT
SETXY:	GTJUMP GTSXY
	ERROR+OGT
HOME:	GTJUMP GTHME
	ERROR+OGT
.ENDC
.ENDC
.ENDC

	.STITL	DISC BLOCKS, NODE SPACE AND TEST LINES
	FOO==%FNAM2
	VERN==VERN+%FNAM2

.IFNZ NDISP

	.=<.!77>+1
DISBTB==<._-6>&1777
DISTPB==<._-6>&1777+1000	;TOP DISPLAY BLOCK
DISREL:	REPT1 8.,DSTOP
DISPDL:	.BLKW 8.
.ENDC
	.=<.!77>+1
DISBFS==<._-6>&1777	;BEGINNING OF FIRST DISPLAY SLOT


VERNF==VERN

.STITL	INITIALIZE THE WORLD!
CORCHK:	ADD #2,(P)
	RTI
SORTER:	MOV SPDLP,P	;FOR STIMULATOR HACKING
	JSR PC,SORT	;JUST DO THE SORT
	HALT
START:	RESET
	MOV SPDLP,P	;SET UP SYSTEM PDL
.IFZ DHON
.IFG NDM
	MOV #DMTT,DM0TBR
.ENDC
.ENDC
	JSR PC,SORT	;SORT SYSTEM OBLIST
	MOV #CORCHK,BEBRV
	.IFNZ NDISP
	MOV #DISREL,NGREL	;SET DISPLAY RELOCATION
	BR .+2
	.ENDC
	MOV #PARREG,A
	MOV #PARCSR,B
	MOV B,C
	MOV #20,D
PARRCK:	MOV #1,(B)+
	MOV C,(A)+	;SKIPPED IF REG NOT THERE
	ADD #2,C
	SOB D,PARRCK
	MOV #MOVON,A
	TST RKCS
	MOV A,(A)
	MOV #100,LKS
	BR LINEKR
.IFZ GUY
	MOV #1666.,PCSTBF	
	MOV #111,PCS
.IFF
	CLR PCSTBF
	MOV #115,PCS
.ENDC
LINEKR:
	JSR PC,SEGSET
	SPL 7
	MOV #1600,KDAR+2
MEMCHK:	INC KDAR+2
	MOV A,20000
	BR MEMCHK
	DEC KDAR+2
	MOV KDAR+2,MEMHGH
	MOV #200,KDAR+2
	MOV #<<<LOGEND+200>_-6>&1777>,PUREAR
	MOV #BEBRK,BEBRV
.IFNZ NTVS
	SUB #202,MEMHGH
	MOV MEMHGH,FONTAR
	MOV #77406,FONTDR
	JSR PC,SYDRBG
	CLR (A)+
	MOV #-10000,(A)+
	MOV FONTAR,D
	CLR C
	ASHC #6,C
	MOV D,(A)+
	MOV FONTDA,(A)+
	MOV FONTDA+2,(A)+
	TST (A)+
	ASH #4,C
	BIS #DREADC,C
	MOV C,(A)
	SPL 0
	TST (A)
	BNE .-2
.ENDC
	MOV #1600,F
	CLR C
	MOV #DISBFS,A
	MOV #1560-DISBFS,B
.IFNZ NDISP
	MOV NDISPS,D
	BEQ SLTAL2
DISAL:	MOV DLENGT(C),E
	CMP E,B
	BGT DISAL1
	MOV A,DISAR(C)
	ADD E,A
	SUB E,B
	BR DISAL2
DISAL1:	MOV F,DISAR(C)
	ADD E,F
DISAL2:	DEC E
	SWAB E
	BIS #6,E
	MOV E,DISDR(C)
	TST (C)+
	SOB D,DISAL
	CMP #DISTPB,F
	BGE .+4
	BPT
.ENDC
SLTAL2:
	.IFNZ TM
	MOV #NLTY,D
	MOV #TTYBBL,E
	MOV #TTYAR,C
TTYAL2:	CMP E,B
	BGT TTYAL1
	MOV A,(C)+
	ADD E,A
	SUB E,B
	SOB D,TTYAL2
	BR SLTAL4
TTYAL1:
	.IF DF NCODEB
	MOV #NCODEB,B
	MOV #CODENB,A
TTYAL3:	CMP E,B
.IIF Z 0,	BGT TTYAL4
.IIF Z 1,	BR TTYAL4
	MOV A,(C)+
	ADD E,A
	SUB E,B
	SOB D,TTYAL3
	BR SLTAL4
TTYAL4:
	.ENDC
TTYAL5:	MOV F,(C)+
	ADD E,F
	SOB D,TTYAL5
SLTAL4:
	.ENDC
	MOV MEMHGH,B
	SUB F,B
	BGT .+4
	BPT
	SPL 0
	CLR A
	DIV NSLOTS,A
	CMP #600,A
	BGT .+6
	MOV #577,A
	MOV A,B
	ASH #6,B	;CHANGE TO BYTES
	ADD #PURE,B	;ADDRESS OF END OF THE WORLDD
	MOV B,ENDWLD	;SAVE END OF WORLD
	SUB #NODESP+<4096.*4>,B	;ANYTHING LEFT FOR ARRAYS?
	BLT SLTAL3	;NOPE, SORRY ABOUT THAT
	MOV B,ASIZE	;WHAT'S LEFT
SLTAL3:	MOV F,B
	CLR C
	MOV NSLOTS,D
SLTAL1:
	MOV B,SLOTAR(C)
	MOV B,F
	CLR E
	ASHC #6,E
	MOV E,SLOTHA(C)
	MOV F,SLOTCA(C)
	ADD A,B
	TST (C)+
	DEC D
	BGT SLTAL1	;DO THIS NSLOTS TIMES
	MOV #SLOTDR,B
	MOV A,C
	MOV #3,D
SLTDRS:	MOV #77406,(B)
	CMP #200,C
	BLE SLTDR1
	TST C
	BGT SLTDR2
	CLR (B)
	BR SLTDR1
SLTDR2:	DEC C
	MOVB C,1(B)
SLTDR1:	SUB #200,C
	TST (B)+
	SOB D,SLTDRS
	ASH #6,A
	MOV A,USLENT
	ASR A
	MOV A,B		;SAVE A POSITIVE WORD COUNT
	NEG B
	MOV B,USWCNT
	ASL A	;DIVIDE BY 200
	SWAB A
	INC A	;ADD 1 TO BE SURE
	MOVB A,USNSEC	;NUMBER OF SECTORS USED BY A SLOT
	TST DEBSW
	BNE NOTIME
GETTIM:	MOV #TYO,PCHR
	MOV #TYI,GCHR
	CPRTXT ^\DATE AND TIME YY/MM/DD HH:MM:SS :\
	MOV #RYEAR+1,C
GETNM1:	CLR B
	CLR F
GETNUM:	JSR PC,TYI
	CMP #177,D
	BEQ GETTIM
	CMP #15,D
	BEQ NOTIM1
	SUB #60,D
	BLT GOTNUM
	CMP #10.,D
	BLE GOTNUM
	INC F
	MUL #10.,B
	ADD D,B
	BR GETNUM
GOTNUM:	CMP #RSEC,C
	BEQ NOTIME
	TST F
	BEQ GETNM1
	CMP #RDAY,C
	BHIS .+4
	DEC B	;YMD ARE ALL INCREMENTED BEFORE TYPEOUT
	MOVB B,-(C)
	BR GETNM1
NOTIM1:	TST F
	BEQ .+4
	MOVB B,-(C)
NOTIME:	MOV FHERT,D
	SPUSH F
	SPUSH #ERBASE
	JSR PC,LSH7
	MOV FHCLUS,D	;FIND CLEAR USER PLACE
	SPUSH F
	SPUSH #DCLRUS
	JSR PC,LSH7
	ADD #<CLSLTL_-7>+1,D
	SPUSH D
	SPUSH F
	SPUSH #DSKRND
	JSR PC,LSH7
.IF Z SITSD
.IIF Z MVONLY,	MOV #7777,D
.IIF NZ MVONLY,.IIF Z RAF,	MOV #4370,D
.IIF NZ MVONLY,.IIF NZ RAF,	MOV #5370,D
.IFF
.IIF Z GUY,	MOV #6777,D
.IIF NZ GUY,MOV #4370,D
.ENDC
	SUB (P),D
	CLR C
	DIV NUSERS,C
	MOV C,A
	MOV A,B
	SUB #2,A	;KLUDGE, THIS IS SIZE OF TYI+EDIT BUFS+SIZE OF SAVE SPACE
	SUB USNSEC,A	;NUMBER OF SECTORS NEEDED FOR SWAPPING
	MOV A,E	;REMAINING IS FOR DISK BLOCKS
	CMP #400,A	;BUT NOT MORE THAN 1000
	BGT .+6
	MOV #377,A	;MAXIMUM
	MOV A,NDBLKS
	CLR U
	MOV NUSERS,C
	SPOP A	;STARTING ADDRESS OF SYS STORAGE
.MACR IADDR AD	;MACRO TO INTIALIZE USER VARIABLES
	MOV A,D
	SPUSH F
	SPUSH AD
	JSR PC, LSH7
	ADD #LUBLK,AD
.ENDM

UVINIT:	MOV ASIZE,UASIZE(U)
	CLR FLSADR(U)
	MOV #-1,SLOTAS(U)
	MOV #-1,DISAS(U)
.IIF Z NINT,	MOV #FRNEWU,FLSRES(U)	;THIS IS A NEW USER
.IIF NZ NINT,	MOV #FRNIU,FLSRES(U)
	IADDR IUSWPD
	ADD USNSEC,A	;FIRST ADDRESS IS SWAPPING AREA
	IADDR IUDBSV	;PLACE TO SAVE DISK BUFFERS WHEN GC'ING
	ADD #4,A	;KLUDGE
	MOV A,@IUDSK
	ADD #LUBLK,IUDSK
	ADD E,A
	ADD #LUBLK,U
	DEC C
	BGT UVINIT
	MOV #MNUSRS,A
	SUB NUSERS,A	;GET NUMBER OF INACTIVE SLOTS
UVINT1:	DEC A	;ANY INACTIVE SLOTS TO FLUSH?
	BLT UVINT2	;NO
	MOV #-1,FLSADR(U)
	ADD #LUBLK,U
	BR UVINT1
UVINT2:	MOV #-1,SLOTAS(U)
	MOV #SYSJOB,FLSADR(U)	;INIT SYS JOB
	CLR UTTY(U)	;PUT IT ON TTY ZERO
	JMP INIT1

CHI:	0		;USED IN STYI
MEMHGH:	0
MOVON:	0

IUSWPD:	USWPAD
IUDBSV:	UDBFSV
IUDSK:	UDSKAD

SORT:	MOV #SOBLST+2,A	;POINTER TO START AT
	MOV #SOBLSU,B	;PLACE TO FINISH
	MOV PC,F	;SET "SOMETHING MOVED" FLAG
SORTUG:	TST F	;DID SOMETHING GET MOVED LAST PASS?
	BEQ SORTDN	;NO, WE ARE DONE
	CLR F	;NOTHING SO FAR THIS PASS
	MOV A,C	;POINTER INTO TABLE
SORTU:	MOV (C)+,D	;START OF SORT UP
	MOV (C),E	;THINGS TO SORT
	ADD #4+SOBLST,D	;GET TO STRING
	ADD #4+SOBLST,E	;FOR BOTH
SORTU3:	CMPB (D),(E)	;COMPARE THE WORDS
	BLT SORTU2	;IN ORDER, GO TO NEXT PAIR
	BEQ SORTU1	;SAME, CHECK NEXT WORD
	INC F	;HAVE TO SWITHC THEM
	MOV -(C),D
	MOV 2(C),(C)+
	MOV D,(C)
SORTU2:	CMP C,B	;ARE WE AT END?
	BNE SORTU	;NO, CONTINUE
	TST -(B)	;YES, NEXT TIME NOT SO FAR
	BR SORTDG	;GO TO DOWNWARD SORT
SORTU1:	TSTB (D)+
	BNE .+6	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
	TSTB (E)+
	BNE .+6
	MOV #ZERO,E
	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTU3	;OK, CONTINUE
	BPT	;BARF, THEY'RE EQUAL????
	BR SORTU3

SORTDG:	TST F	;DID WE MOVE ANY ON THE UP PASS?
	BEQ SORTDN	;NO,DONE
	CLR F	;CLEAR FLAG
	MOV B,C	;SET POINTER
SORTD:	MOV (C),D
	MOV -(C),E
	ADD #4+SOBLST,D
	ADD #4+SOBLST,E
SORTD3:	CMPB (D),(E)
	BGT SORTD2
	BEQ SORTD1
	INC F
	MOV (C)+,D
	MOV (C),-(C)
	MOV D,2(C)
SORTD2:	CMP C,A
	BNE SORTD
	TST (A)+
	BR SORTUG
SORTD1:	TSTB (D)+
	BNE .+6	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
	TSTB (E)+
	BNE .+6
	MOV #ZERO,E
	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTD3
	BPT
	BR SORTD3

SORTDN:	RTS PC
ZERO:	0

FHERT:	.ERDA
FHCLUS:	.CLDA
FONTDA:	.FNDA1
	.FNDA2
LOGEND=.
.IIF P2,PAD ^\LOGEND=\,\.
	.END START
