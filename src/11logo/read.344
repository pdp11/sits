	.STITL READ A STRING
	FOO==%FNAM2
	VERN=VERN+%FNAM2
RDSTR1:	PRCR	;OUTPUT - PTR ON S, SKIP UNLESS EMPTY OR BREAK
RDSTR:	CLR NBKTS
	MOV USER,U
	TST	BRAKE(U)
	BNE RDSTR7
	CMP #TYI,GCHR	;WILL CHARS BE COMING FROM TTY?
	BNE RLINE1	;NO
	MOV PRMTCH,D
	BEQ	RLINE
;	TST ALEVN
;	BEQ RLINE2
	BIT #BRKF,FLAGS
	BEQ RLINE2
	MOV FUNLEV,A
	BEQ RLINE2
	MOV #'L,D
	JSR PC,TYO
	JSR PC,PRDN
	MOV PRMTCH,D
RLINE2:	JSR PC,TYO
RLINE:	TST USER
	BLT RLINE1
	PUSH	U
	MOV	USER,U
	JSR	PC,SLINE
	MOV	#FRTYIH,FLSRES(U)
	JSR	PC,FLUSH
	JSR	PC,RUNME
	POP	U
RLINE1:	JSR PC,BLSTI
RDSTR2:	JSR PC,@GCHR
	TST	BRAKE(U)
	BNE	RDSTR7
	CMP #EOFCHR,D
	BNE RDSTR9
	MOV #TYI,GCHR	;NON-TTY INPUT DONE
	MOV #'],D	;FILL IN MISSING ]'S
	TST NBKTS
RDSR10:	BLE RDSTR4
	JSR PC,BLST
	DEC NBKTS
	BR RDSR10
RDSTR9:	CMP TBKCH,D	;BREAK TYPED?
	BEQ RDSTR7	;YES
	TST NBKTS	;IN A LIST?
	BGT RDSTR3	;YES
	CMP #15,D	;CR?
	BEQ RDSTR4
RDSTR3:	CMP #'[,D
	BNE RDSTR6
	INC NBKTS
RDSTR6:	CMP #'],D
	BNE RDSTR5
	DEC NBKTS
RDSTR5:	JSR PC,BLST
	BR RDSTR2
RDSTR4:	BIC #RBRKF,TFLAGS
	JSR PC,BLSTF
RDSTRR:	RTS PC	;NO CHARS TYPED
	PUSHS TOPS
	CLR TOPS
RDSTSR:	SKPRET
RDSTR7:	BIS #RBRKF,TFLAGS
	RTS PC
	.STITL REQUEST, FILE READ & WRITE
RQUEST:	PUSH #ORT	;INPUT A LIST FROM TTY
RQU1:	PUSH PRMTCH
	JSR PC,INPUTL
	BR RQU5
	MOV E,C	;E POINTS TO LAST NODE OF STRING
	JSR PC,.LOADC	;NEED TO ADD A "]", IS THERE ROOM?
	BIT #177400,B
	BNE RQU2	;YES
	BIS #']*400,B	;NO - PUT A "]" THERE
	JSR PC,.STORE
RQU3:	MOV @S,GNCN
	BIC #170000,GNCN
	JSR PC,RDLST
	POPS TOPS
RQU4:	MOV TOPS,@S
	CLR TOPS
RQUR:	POP PRMTCH
	RTS PC
RQU2:	MOV #'],B
	JSR PC,GRBAD1
	BR RQU3
RQU5:	MOV #LIST,@S
	BR RQUR
INPUTL:	MOV #'<,PRMTCH
	MOV USER,U
	MOV UTTY(U),A
	TST CHARNO(A)
	BEQ .+6
	CLR PRMTCH
	JSR PC,RDSTR
	BR IPUL1
	SKPRET
IPUL1:	BIT #RBRKF,TFLAGS
	BEQ IPUL3
	POP PRMTCH	;THE RETURN
	SPOP PRMTCH	;NOW THE OLD PRMTCH
	ERROR+BRK
IPUL3:	PUSHS #LSTR
	RTS PC
TYPEIN:	JSR PC,RQU1	;INPUT A WORD FROM TTY
	BIT #7777,@S
	BNE TYPIN2
	MOV #LSTR,@S
	JMP ORT
TYPIN2:	JMP FIRST
	PUSH PRMTCH
	JSR PC,INPUTL
	BR RQUR
	MOV @S,GNCN
	BIC #170000,GNCN
TYPIN1:	JSR PC,GNC
	CMP #' ,D
	BEQ TYPIN1
	JSR PC,RDST
	BR RQU4
	BR RQU4
	.IFNZ OFILES
FREAD:	MOV #FNAME,C
	JSR PC,G1FN
FRDER:	ERROR+IFN	;INVALID FILE NAME
	JSR PC,READF
	JSR PC,FILERR
	MOV #READCH,GCHR
	JSR PC,SAVEVL
FRLOOP:	JSR PC,RDSTR
	BR FRLOO2
	CMP #TYI,GCHR
	BEQ FRLOO1
	JSR PC,READ
	BR FRLOOP	;NO TOKENS
	JSR PC,EVLINE
	ERROR+WDW
	POPS A
	BR FRLOOP	;NO OUTPUT - OK
FRLOO1:	TST TOPRNM	;DONE, PROC DEF PENDING?
	BEQ .+6
	JSR PC,END
	MOV #PSNORT,PSTOPR
	JSR PC,RESEVL
	MOV CTP,C
	CLR D
	BIC #RTF+CRF,FLAGS
	JMP PSTOP6
FRLOO2:	BIT #RBRKF,TFLAGS
	BEQ .+4
	ERROR+BRK
	CMP #TYI,GCHR
	BEQ FRLOO1
	BR FRLOOP
FWRITE:	MOV #FNAME,C
	JSR PC,G1FN
	BR FRDER
	JSR PC,WRITEF
	JSR PC,FILERR
	MOV #WRITEC,PCHR
	JSR PC,SHOWAL
	BR .+2
	JSR PC,WRITCU
	MOV #TYO,PCHR
	JSR PC,FILERR
	RTS PC
	.ENDC
	.STITL DELETE, UNDELETE (!!), USE
	.IFNZ OFILES
DELETE:	MOV #FNAME,C
	JSR PC,G1FN
	BR FRDER
	JSR PC,DELETF
	JSR PC,FILERR
	RTS PC
UNDELE:	MOV #FNAME,C
	JSR PC,G1FN
	BR FRDER
	JSR PC,UDELEF
	JSR PC,FILERR
	RTS PC
USE:	MOV #DIRNAM,C
	JSR PC,G1FN
	BR FRDER
	RTS PC
G1FN:		;GET A FILE NAME (4 CHARS)
		;PUT INTO ((C)) AND ((C)+2)
	JSR PC,GNT
CH1FN:	BIT #CRF,FLAGS	;COME HERE IF YOU'VE ALREADY GNT'ED
	BEQ .+4
	ERROR+MFN	;MISSING FILE NAMES
	BIC #7777,A
	CMP #SSTR,A
	BLO G1FN3
	CMP #UFUN,A
	BNE G1FN5
	JSR PC,.LOAD
	BR G1FN4
G1FN3:	MOV #LSTR,A
	JSR PC,CONVER
G1FN2:	RTS PC
G1FN4:	JSR PC,.LOAD
	MOV B,(C)+
	CLR B
	BIT #7777,A
	BEQ G1FN1
	MOV A,B
	JSR PC,.LOAD
G1FN1:	MOV B,(C)
G1FN6:	SKPRET

G1FN5:	BLO G1FN2	;IS IT SFUN OR INFIX?
	ADD #4+SOBLST,B	;YES - NOW IT POINTS TO ASCIZ
	MOV (B)+,(C)+	;GET 1ST TWO CHAR
	CLR (C)	;IN CASE SECOND CHAR IS 0
	TSTB -1(C)	;IS IT?
	BEQ G1FN6	;YES -  DONE
	MOV (B)+,(C)+	;NO - GET NEXT TWO CHARS
	BR G1FN6
FILERR:	JMP .+4(A)
	RTS PC
	ERROR+FNF
	ERROR+DRF
	ERROR+FAE
	ERROR+DFU
	ERROR+IUN
	.ENDC
	.STITLE  READ -

READ:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	CLR RDFLAG
	MOV @S,GNCN
	BIC #170000,GNCN
	CLR F
READA:	JSR PC,RDWRD
	BR READB
	BIS #SEPF,RDFLAG
	JSR PC,CKDOTF
READC:	JSR PC,LISTB
	BIT #SEPF,RDFLAG
	BEQ READA
READB:	BIC #SEPF,RDFLAG	;CHECK SPECIAL CHAR IN D
	JSR PC,CKDOTF	;FIRST CHECK FOR PENDING ":"
	CMP #15,D
	BEQ READR	;C-R
	CMP #'",D
	BEQ READS	;STRING
	CMP #'[,D
	BEQ READL	;LIST
	CMP #'],D
	BNE .+4
	ERROR+COP	;CHAR (]) OUT OF PLACE
	CMP #':,D
	BEQ READD	;DOTS
	BITB #OPERF,DTBL(D)	;IS CHAR AN OPERATOR
	BEQ READA	;NO
	MOVB DTBL2(D),A
	ASL A
	MOV SOBLSU(A),B
		;SET TYPE TO SFUN OR INFIX
	MOV SOBLST(B),A	;THIS CROCK WORKS BECAUSE #SFUN=0
	BIC #-INFIX-1,A	; AND #INFIX=10000
	BR READC
READR:	POPS A
	CLR	TOPS
	TST	F
	BNE	READR1
	JMP RETF
READR1:	MOV A,@S
	JMP SRETF

READS:	JSR PC,GNC
	JSR PC,RDST
	BR .+2	;RDST ALWAYS SKIPS
	BIS #SEPF,RDFLAG
	BR READC
READL:	JSR PC,RDLST
	POPS TOPS
	BIC #SEPF,RDFLAG
	BR READC
READD:	BIS #DOTF,RDFLAG
	BR READA
	.STITLE READ - READ WORD
	;READ CHARS UP THRU NEXT SEPARATOR CHAR.  IF JUST A SEP, RETURN
	;WITH IT IN D.  OTHERWISE NUMBERIFY OR INTERN CHAR STRING,
	;SKIP RETURN WITH TOKEN IN A,,B
RDWRD:	CLRB RDFLAG
	JSR PC,BLSTI
RDWA:	JSR PC,GNC
	JSR PC,GETCHF	;GET FLAGS IN A
	BIT #SEPF,A	;IS THIS CHAR A SEPARATOR?
	BNE RDWB	;YES
	BISB A,RDFLAG
	JSR PC,BLST
	BR RDWA
RDWB:	JSR PC,BLSTF	;FINISH OFF STRING
	RTS PC	;NO CHARS SEEN BEFORE SEP
	BIT #NNUMF,RDFLAG
	BNE RDWC	;NOT A POSSIBLE NUMBER
	MOV TOPS,B
	MOV #LNUM,A
	JSR PC,CONVER	;TRY MAKING A #
	SKPRET	;LOST SO LEAVE AS LSTR
	MOV B,TOPS	;PROTECT FROM GC UNTIL ADDED TO LIST
	SKPRET	;OK
RDWC:	MOV #UFUN,A	;TRY TO INTERN STRING IN TOPS AS A SYSTEM OR USER FUNCTION
	BIT #DOTF,RDFLAG	; UNLESS DOTF ON, THEN AS USER VARIABLE
	BEQ RDWD
	MOV #UVAR,A
	BIC #DOTF,RDFLAG
RDWD:	JSR PC,.INTRN	;RDST COMES HERE ALSO
	BR RDWE
	JSR PC,FRELST
RDWE:	BIC #170000,B
	BIS A,B
	CMP #UFUN,A	;IF WE GOT A UOE
	BHI RDWR	;THEN--
	MOV B,TOPS	;PROTECT THIS NEWLY HATCHED UOE FROM G.C.
RDWR:	SKPRET

GETCHF:		;GET FLAGS FOR CHAR IN D INTO A
	MOV #NNUMF,A
	TSTB D	;CHECK FOR 200 BIT
	BLT .+6
	MOVB DTBL(D),A
	RTS PC
	.STITLE READ - READ STRING
	;READ CHAR UP TO NEXT SPACE OR ] IF INSIDE
	;A LIST.  DONT ALLOW ] OR [.
	; SKIPS UNLESS EMPTY STRING
RDST:	CLRB RDFLAG
	JSR PC,BLSTI
	BR RDSB
RDSA:	JSR PC,GNC
RDSB:	JSR PC,GETCHF
	BIT #SEPF,A
	BEQ RDSE
	CMP #' ,D
	BEQ RDSX
	CMP #'],D
	BEQ RDSC
	CMP #'[,D
	BEQ RDSX
	CMP #15,D
	BEQ RDSX
RDSE:	BISB A,RDFLAG
	JSR PC,BLST
	BR RDSA
RDSC:	TST LISTBD	;ARE WE IN LIST
	BNE RDSX	;YES
RDSD:	ERROR+COP	;CHAR (D) OUT OF PLACE
RDSX:	MOV #LSTR,A
	MOV #LSTR, B
	JSR PC,BLSTF
RDSR:	RTS PC	;EMPTY STRING
	MOV #LSTR,A
	MOV TOPS,B
	BIT #NNUMF,RDFLAG
	BEQ RDWR	;IT IS A POSSIBLE NUMBER
	BIT #SEPF,RDFLAG
	BNE RDWR	;IT HAS A SEP CHAR IN IT
	MOV #ATOM,A
	JMP RDWD	; INTERN IT
	.STITL READ - READ LIST
	;READ THRU MATCHING ] MAKING A LIST AS U GO
RDLST:	CLRB RDFLAG
	JSR PC,SLISTB
RDLA:	JSR PC,GNC
	CMP #' ,D
	BEQ RDLA	;SKIP OVER SPACES
	CMP #'[,D
	BEQ RDLB	;READ A LIST
	CMP #'],D
	BEQ RDLY	;DONE
	JSR PC,RDST	;READ A STRING
	BR .+2	;RDST ALWAYS SKIPS
RDLX:	JSR PC,LISTB	;ADD THIS NODE TO LIST
	CMP #'[,D
	BEQ RDLB
	CMP #'],D	;AT END?
	BNE RDLA	;NO, GET NEXT ELEMENT
RDLY:	JSR PC,FLISTB
	RTS PC
RDLB:	JSR PC,RDLST
	POPS TOPS
	CLR D
	BR RDLX
	.STITLE READ - MISC
CKDOTF:	BIT #DOTF,RDFLAG
	BEQ LISTBR
	BIC #DOTF,RDFLAG
	PUSH A
	SPUSH B
	MOV #SFUN,A
	MOV #$DOTS,B
	JSR PC,LISTB
	JMP RETB
LISTB:	PUSH C
	MOV F,C	;BUILD A LIST, ADD NODE IN A,,B TO
	JSR PC,GRBAD1	;LIST WHOSE LAST NODE PTR IS IN F
	TST F	;CAREFUL - THE FIRST TIME IT IS CALLED, THE
		;POINTER TO THE FIRST NODE IS PUSHED ONTO S
	BNE LISTB1
	PUSHS	C
	BIS #LIST,@S
LISTB1:	MOV C,F
	POP C
LISTBR:	RTS PC
SLISTB:		;START LISTB
	PUSHS F	;SAVE CURRENT LAST NODE PTR
	CLR F
	INC LISTBD
	RTS PC
FLISTB:	TST F
	BNE FLSB1
	PUSHS #LIST
FLSB1:	POPS B	;THIS IS THE OUTPUT
	MOV @S,F	;RESTORE OLD LAST NODE PTR
	MOV B,@S	;THE RESULT
	MOV #LIST,A
	DEC LISTBD
	RTS PC
BLSTI:	CLR NCHR
	CLR E
	CLR TOPS
BLSTI1:	BIS #100000,E
	RTS PC
BLST:		;BUILD STRING - CHAR IN D, USES E
	TST	USER
	BGE	.+6
	JMP	STYO
	PUSH A
	SPUSH B
	SPUSH C
	CMPB #200,D	;CHECK IF NULL CHARACTER
	BEQ BLSTRT
	BIT #177,D	;CHECK IF NULL
	BEQ BLSTRT
	INC NCHR	;WE HAVE A CHAR
	ADD #40000,E
	BGE BLST2	;IS IT  THE SECOND
	MOVB D,TEMP	;NO, 1ST
BLSTRT:	JMP RETC
BLST2:	MOVB D,TEMP+1	;IT IS THE SECOND CHAR
	MOV TEMP,B
	;STORE THE CHARACTERS
BLST3:	JSR PC,BSAN
	BIS #100000,E
	BR BLSTRT
BLSTF:	;FINISH BUILDING STRING, PUT PTR IN TOPS.
		; DONT SKIP IF EMPTY STRING (TOPS=0)
	TST NCHR
	BEQ BSANR	;EMPTY STRING
	ADD #40000,E
	BGE .+4	;IS LAST NODE USED
	SKPRET
	PUSH A
	SPUSH B
	SPUSH C
	MOVB TEMP,B	;YES
	JSR PC,BSAN
BLSTF1:	JMP SRETC
BSAN:	MOV E,C
	MOV #SSTR,A
	JSR PC,GRBAD1
	TST E
	BNE BSAN1
	MOV C,TOPS	;SAVE NEW STRING PTR ON S
	BIS #LSTR,TOPS
BSAN1:	MOV C,E
BSANR:	RTS PC
	.STITL GNC - GET NEXT CHAR
GNC:	PUSH A		;GET NEXT CHAR INTO D
	SPUSH B		;INITIALIZE BY MOVING LSTR PTR INTO GNCN
GNC4:	MOVB GNCN+2,D	;    AND CLEARING TYPE FIELD (#170000)
	MOV GNCN,B	;PUTS CR (=#15) IN D IF NO MORE CHAR
	BLT GNC1	;JUST GOT 2ND CHAR
	BNE GNC3
	MOV #15,D
	JMP RETB	;NONE LEFT
GNC3:	JSR PC,.LOAD	;GET NEXT NODE
	BIS #100000,A	;SET "STILL ANOTHER CHAR" BIT
	MOV A,GNCN
	MOVB B,D	;FOR OUTPUT
	SWAB B
	MOVB B,GNCN+2
GNC2:	TST D
	BEQ GNC4	;IGNORE NULL CHARS
	JMP RETB
GNC1:	BIC #170000,GNCN	;CLEAR "STILL ..." BIT
	BR GNC2
	.STITL PRINT ROUTINES

PRLO:	PUSH A	;PRINT LAST OPERATOR
	SPUSH B
	MOV LO,A
	BEQ EMPTY
	MOV LO+2,B
	BR PRCO1
PRCO:	PUSH A,	;PRINT CURRENT OPERATOR
	SPUSH B
	MOV CO,A
	MOV CO+2,B
	BEQ EMPTY
PRCO1:	SPUSH D
	JSR PC,PROAB
	SPOP D
	JMP RETB
PROAB:	CMP A,#UFUN	;PRINT OPERATOR IN A,B
	BLO PRCO2
	JMP PPNAME	;PRINT PNAME
PRCO2:	MOV B,A	;SYSTEM FUNCTION
	BNE PRCO3
	PRTXT ^\ CR.\
	RTS PC
PRCO3:	ADD #4+SOBLST,A
	BR	PRAS	;PRINT ASCIZ PNAME
NOTPRO:	ERROR+NTP
EMPTY:	PRTXT ^\ EMPTY \
	JMP RETB

ERTAS:
.IFNZ 1
	SPUSH A
	MOV 4(P),A	;GET ADDR OF STRING
	JSR PC,PRAS
	SPOP 2(P)
	SPOP A
	RTS A		;RETURN & RESTORE F
.IFF
	JSR	PC,PRAS
	ASR	A	;CALLED WITH JSR A,
	ADC	A
	ASL	A
	RTS	A
.ENDC

PRAS:	SPUSH	D	;PRINT ASCIZ STRING POINTED TO BY A
	BR	.+6
PRAS1:	JSR	PC,@PCHR
	MOVB	(A)+,D
	BNE	PRAS1
	SPOP	D
	RTS	PC

PRON:	BIC #TF2,TFLAGS	;PRINT OCTAL NO., NO. IN A
	BR PRON1	;CALL-	JSR PC,PRON
PRONL:	BIS #TF2,TFLAGS
PRON1:	PUSH A		;PRON DOESN'T PRINT LEADING ZEROS, PRONL DOES
	SPUSH D
	CLR D
	SEC
	ROL A	;TO TELL WHEN WE ARE DONE
	BR PRON2
PRON3:	CLR D
	ASL A
	BEQ PRON5
	ROL D
	ASL A
	ROL D
	ASL A
PRON2:	ROL D
	BNE PRON4
	BIT #TF2,TFLAGS
	BEQ PRON3
PRON4:	BIS #TF2,TFLAGS
	BIS #60,D
	JSR PC,@PCHR
	BR PRON3
PRON5:	BIS #60,D
	BIT #TF2,TFLAGS
	BNE .+6	;IF NOTHING HAS BEEN TYPED, TYPE A ZERO
	JSR PC,@PCHR
	SPOP D
	SPOP A
	RTS PC
PRDN:	PUSH B		;PRINT DECIMAL NO. IN A
	SPUSH C
	SPUSH D
	CLR C
.IFNZ A1120
	MOV A,MQ
.IFF
	MOV A,B
.IFTF
	BGT PRDN1	;POSITIVE
	BEQ PRDN0	;ZERO
.IFT
	NEG MQ	;IT'S NEGATIVE
.IFF
	NEG B		;NEGATIVE:
.IFTF
	MOV #'-,D	;"-" (ABS VAL)
	JSR PC,@PCHR
PRDN1:	INC C		;COUNT A STORED DIGIT
.IFT
	MOV #10.,DIVIDE	;DIVIDE BY 10
	PUSH AC		;SAVE REMAINDER = NEW DIGIT
	CLR AC
	TST MQ		;QUOTIENT = 0?
.IFF
	CLR A
	DIV #10.,A	;DIVIDE BY 10
	PUSH B		;SAVE REMAINDER = NEW DIGIT
	MOV A,B		;QUOTIENT:  = 0?
.ENDC
	BNE PRDN1	;NO:  GET SOME MORE LOW-ORDER DIGITS
PRDN2:	POP D		;GET SAVED HIGH-ORDER DIGIT
	ADD #'0,D	;ENCODE IT
	JSR PC,@PCHR	;PRINT IT
	DEC C
	BGT PRDN2	;UNTIL NO. DIGITS LEFT = 0
PRDNX:	POP D
	SPOP C
	SPOP B
	RTS PC

PRDN0:	MOV #'0,D	;TYPE "0"
	JSR PC,@PCHR
	BR PRDNX

EMPTY1:	JMP EMPTY
PRS1:	PUSH A	;PRINT TOP ELEMENT OF SS
	SPUSH B
	MOV #IS,A	;COMPUTE RELATIVE S PD PTR
	SUB S,A
	ADD SPRBAO,A
	CMP A,CSPDLP
	BLOS EMPTY1
	MOV @S,B
	SPUSH D
	JSR PC,PNODAB
	SPOP D
	JMP RETB
PNODAB:	MOV B,A
	BIC #7777,A
	CMP #SSTR,A
	BEQ PRS11
	CMP #SNP,A
	BLOS PRS11
	ERROR+INVN	;INVALID NODE
PRS11:	JSR PC,PRDATA
	RTS PC
PRCT:	PUSH A	;PRINT CURRENT TOKEN
	SPUSH B
	SPUSH D
	MOV CT,A
	MOV CT+2,B
	JSR PC,PRTAB
	SPOP D
	JMP RETB
PRTAB:	BIC #7777,A	;PRINT TOKEN IN A,B
	CMP A,#UVAR
	BHIS .+6
	JMP PROAB
	CMP A,#UVAR
	BEQ PRUV
	BR PRDATA
PRATM:	BIS #PQF,FLAGS2	;PRINT ATOM IN A,B
	BR PRUV1
PRUV:	MOVB #':,D	;PRINT USER VARIABLE IN A,B
	JSR PC,@PCHR
PPNAME:	BIC #PQF,FLAGS2	;PRINT PNAME - UOE PTR IN B
PRUV1:	JSR PC,.LOAD
	JMP PRLSTR	;PRINT PNAME
PRDATA:	CMP #INUM,A	;PRINT DATA IN A,B. 7777 FIELD OF A IS 0000
	BEQ PRINUM	;NUMBER
	CMP #SNUM,A
	BEQ PRSNUM
	BIS #PQF,FLAGS2	;SET PRINT QUOTE FLAG
	CMP #ATOM,A
	BEQ PRUV1
	CMP #LSTR,A
	BEQ PRLSTR	;LONG STRING
	CMP #SSTR,A
	BEQ PRSSTR	;SHORT STRING
	BIC #PQF,FLAGS2
	CMP #LIST,A
	BEQ PRLST
.IIF NZ OFILES,	TST DSKNCH
.IIF Z OFILES,	TST WRTFLG
	BEQ	PRSNP	;YES
	PRTXT	^/" /	;OUTPUT EMPTY
	BR	PRSRET
PRSNP:	PRTXT ^\%SNAP%\	;CANT PRINT A SNAP
	BR PRSRET
PRLSTR:	JSR PC,.LOAD	;PRINT LONG STRING
PRSSTR:	JSR PC,PRQQ	;PRINT SHORT STRING
PRSTR2:	MOVB B,D
	JSR PC,PRSPT
PRSTR3:	SWAB B
	MOVB B,D
	JSR PC,PRSPT
PRSTR4:	MOV A,B
	BIC #170000,B
	BEQ PRSRET
	JSR PC,.LOAD
	BR PRSTR2
PRSRET:	RTS PC
PRQQ:	BIT #PQF,FLAGS2	;PRINT ' " ' IF PQF=1
	BEQ PRSRET
	BIT #DPQF,FLAGS2
	BNE PRSRET
	MOVB #'",D
	JMP @PCHR
PRSNUM:	CLR A	;PRINT SNUM
	TST B
	BGE PRINM1
	COM A
	BR PRINM1
PRINUM:	JSR PC,.LOAD	;PRINT INUM
PRINM1:	PUSH C
	MOV E,TMPBLK+2
	MOV F,TMPBLK+4
	JSR PC,.CINST	;CONVERT INUM IN A,,B TO STRING ON P
	MOV TMPBLK+2,E
	MOV TMPBLK+4,F
	MOV P,A
	MOVB (A)+,D
	BNE PRINM3
PRINM2:	MOVB (A)+,D
	BEQ PRINM4
PRINM3:	JSR PC,@PCHR
	BR PRINM2
PRINM4:	INC A	;TO MAKE IT EVEN (??)
	MOV A,P
	POP C
PRSPT2:	RTS PC

PRSPT:	CMPB #200,D
	BEQ PRSPT2
	TSTB D
	BEQ PRSPT2
	BIT #CPTBF,FLAGS2
	BEQ PRSPT1
	CMPB #'%,D
	BNE .+6
	MOV #' ,D
PRSPT1:	JMP @PCHR
PRLST:	PUSH A	;PRINT LIST, PTR IN B
	SPUSH B
	SPUSH C
	TST NBKTS
	BEQ PRL4
	MOV #'[,D
	JSR PC,@PCHR
PRL4:	INC NBKTS
	MOV B,C
PRL1:	SPUSH FLAGS2
	BIT #7777,C	;EMPTY LIST
	BEQ PRL2	;YES, DONE
	BIS #DPQF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
	BR PRL3
PRL6:	SPACE
PRL3:	JSR PC,.LOADC	;GET THIS NODE
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	JSR PC,PRTAB
	BIT #7777,C
	BNE PRL6
PRL2:	DEC NBKTS
	BEQ PRL5
	MOV #'],D
	JSR PC,@PCHR
PRL5:	BIC #DPQF,FLAGS2
	SPOP C	;GET OLD FLAGS2
	BIC #<-DPQF-1>,C	;MASK ALL BUT DPQF
	BIS C,FLAGS2	;AND RESTORE IT
	JMP RETC
PRNODE:	PUSH A	;PRINT NODE POINTED TO BY B
	SPUSH B
	SPUSH D
	JSR PC,.LOAD
	JSR PC,PRON
	SPACE
	MOV B,A
	JSR PC,PRON
	SPOP D
	JMP RETB
	.STITL PRINTOUT (ONCE KNOWN AS SHOW)
SHALPR:		;SHOW ALL PROCEDURES
		;USES A-F
	JSR PC,GNOLEI
SHALP1:	JSR PC,GNOLE
	RTS PC	;DONE
	JSR PC,BURYQ
	BR SHALP1
	JSR PC,PSHOW
	BR SHALP1
	BR SHALP1

	.IFNZ OFILES
RJLCRK:	MOV #LSTALF,E
	JSR PC,CLISTF
	RTS PC
POI:
SHALUF:	MOV #LSTAUF,E
	JSR PC,CLISTF
	RTS PC
SHALUS:	CLR @DBUFAD
	MOV #LSTAUS,E
	JSR PC,CLISTF
	RTS PC
	.ENDC
POTS:
SHALTI:	;SHOW ALL TITLES
	JSR PC,GNOLEI
SHATI1:	JSR PC,GNOLE
	RTS PC
	JSR PC,BURYQ
	BR SHATI1
	JSR PC,SHTITL
	BR .+2
	BR SHATI1

SHOWAL:	JSR PC,SHALPR	;SHOW ALL PROCEDURES
	JSR PC,SHALNA	;SHOW ALL NAMES
	RTS PC

SHOW:	BIT #7777,CT	;ANY TOKENS LEFT
	BNE SHOW00	;YEP
	MOV TOPRNM,B
	BNE SHOW0
	MOV LASTPR,B
	BNE SHOW0
	ERROR+SHW

SHOW00:	JSR PC,GTUOEB
	BR SHOW1	;THE TOKEN ISNT A USER PROC
SHOW0:	JSR PC,PSHOW
	ERROR+PNH	;PROCEDURE NOT HERE
	RTS PC

SHOW1:	CMP #SFUN,A
	BNE SHOWE1
	TST B	;IS IT CR?
	BNE SHOW12	;NO
	MOV TOPRNM,B
	BEQ SHOWE1
	BR SHOW0

SHOW12:	CMP #$ALL,B
	BEQ SHOWAL
	CMP #$FILE,B
	.IFNZ OFILES
	BEQ POFILE
	.ENDC
	.IFZ OFILES
	BEQ .POFILE
	.ENDC
	CMP #$TITLE,B
	BEQ POT
	CMP #$LINE,B
	BEQ POL
	CMP #$INDEX,B
	.IFNZ OFILES
	BEQ POI
	.IFF
	BNE .+6
	JMP .POI
	.ENDC
	CMP #$PROCE,B
	BEQ SHALPR
	CMP #$NAMES,B
	BNE SHOW23
	JMP SHALNA
SHOW23:	.IFNZ OFILES
	CMP #$RJLDS,B
	BEQ RJLCRK
	CMP #$USERS,B
	BEQ SHALUS
	.ENDC
	CMP #$TITLS,B
	BEQ SHALTI
	.IFZ OFILES
	CMP #$TREE,B
	BNE SHOWE1
	JMP .POTREE
	.ENDC
SHOWE1:	ERROR+SHW	;SHOW WHAT??


POT:	MOV TOPRNM,B	;SHOW THIS TITLE
	BNE .+4
	ERROR+OIP	;ONLY IN PROCEDURE
	JSR PC,SHTITL
	.BUG.
	RTS PC

POL:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GEN LINE NO. FROM NEXT TOKEN INTO B
	ERROR+SHW	;SHOW WHAT??
	JSR PC,GTLP	;GET POINTER TO LINE
	ERROR+LDE	;LINE DOESNT EXIST
	JSR PC,.LOADC
	PUSHS B	;FOR PRLN
	JSR PC,PRLN	;PRINT LINE
	PRCR
	POPS C
	RTS PC
	.IFZ OFILES
.POFILE:	JSR PC,EVAL
	ERROR+UELX
	JMP .POI
	.ENDC
	.IFNZ OFILES
POFILE:	JSR PC,GNT	;SEE IF "PO FILE TITLES"
	BIC #7777,A
	CMP #SFUN,A
	BNE POFIL1	;NO
	CMP #$TITLS,B
	BEQ POFTS	;YES!
POFIL1:	MOV #FNAME,C	;NO, "PO FILE (FILE)";
	JSR PC,CH1FN	;CHECK THAT (FILE) IS GOOD FILE NAME
	ERROR+IFN
	BR POFIL2

POF:	MOV #FNAME,C
	JSR PC,G1FN
	ERROR+IFN
POFIL2:	JSR PC,READF
	JSR PC,FILERR
POFIL3:	JSR PC,RNOEOF	;COPY FILE TO EOF
	JSR PC,@PCHR
	BR POFIL3

POFTS:	MOV #FNAME,C	;"PO FILE TITLES (FILE)"
	JSR PC,G1FN	;FILE NAME VALID?
	ERROR+IFN
	JSR PC,READF
	JSR PC,FILERR
	BR POFTS2

POFTS1:	JSR PC,RNOEOF	;LOOK FOR NEXT LINE
	CMP #15,D
	BNE POFTS1
POFTS2:	JSR PC,RNOEOF	;LOOK FOR "TO "
	CMP #'T,D
	BNE POFTS1	;OR NEXT LINE
	JSR PC,RNOEOF
	CMP #'O,D
	BNE POFTS1
	JSR PC,RNOEOF
	CMP #' ,D
	BNE POFTS1
	PRTXT ^/TO /
POFTS3:	JSR PC,RNOEOF	;"TO " FOUND AND ECHOED: COPY REST OF LINE
	JSR PC,@PCHR
	CMP #15,D
	BNE POFTS3
	BR POFTS2	;LOOK FOR NEXT "TO " (NOW ON NEW LINE)

RNOEOF:	;"JSR PC,RNOEOF" = "JSR PC,READCH
	;		    CMP #EOFCHR,D
	;		    BEQ SHOWE"
	JSR PC,READCH
	CMP #EOFCHR,D
	BEQ .+4
	RTS PC
	TST (P)+
	RTS PC
	.ENDC

PSHOW:	;SHOW (B).  SKIP UNLESS (B) NOT A USER PROC
	JSR PC,SHTITL	;SHOW TITLE LINE, SKIPS IF PROC THERE
	RTS PC
	BIT #7777,A
	BEQ PSHOW4
	MOV A,C
	PUSHS #0
PSHOW3:	JSR PC,.LOADC
	MOV A,C
	MOV B,@S
	JSR PC,PRLN
	PRCR
	BIT #7777,C
	BNE PSHOW3
	POPS A
PSHOW4:	PRTXTC ^\END\
	SKPRET

PON:
SHALNA:		;SHOW ALL NAMES
		;USES A-F
	JSR PC,GNOLEI
SHALN1:	JSR PC,GNOLE	;GET NEXT UOE
	RTS PC	;NONE LEFT
	MOV B,F
	JSR PC,.BNDVN
	BR SHALN1	;NO THING FOR THIS UOE
	MOV B,C	;SAVE VALUE PTR
	MOV F,B	;GET UOE PTR
.IIF NZ OFILES,	TST DSKNCH
.IIF Z OFILES,	TST WRTFLG
	BEQ SHALN2	;NO
	TST C		;IS VALUE = "UNBOUND"? (0?)
	BEQ SHALN1	;SKIP THIS ATOM
	SPUSH B
	PRTXT ^/MAKE "/	;YSE
	SPOP B
	JSR PC,PPNAME	;PRINT THE NAME
	PRTXT ^\ (\
SHALN3:	SPACE
	SPUSHS C
	INC NBKTS
	JSR PC,PRS1
	ADD #2,S
.IIF NZ OFILES,	TST DSKNCH
.IIF Z OFILES,	TST WRTFLG
	BEQ SHALN4
	PRTXT ^\ )\
SHALN4:	PRCR
	BR SHALN1
SHALN2:	JSR PC,PRUV	;PRINT THE NAME
	PRTXT ^/ IS/
	TST C		;UNBOUND?
	BNE SHALN3	;NO; GO AHEAD
	PRTXT ^/ UNBOUND./
	BR SHALN4

CONTEN:	;MAKE A LIST OF ALL ATOMS THAT HAVE A PROCEDURE
	JSR PC,SLISTB
	JSR PC,GNOLEI
CONTN1:	JSR PC,GNOLE
	BR CONTN2	;DONE
	JSR PC,BURYQ
	BR CONTN1
	MOV B,D
	JSR PC,.BINDF	;A PROCEDURE
	BR CONTN1	;NOPE
	MOV D,C
	JSR PC,.LOADC	;GET PNAME
	MOV #LSTR,A
	JSR PC,LISTB
	BR CONTN1
CONTN2:	JSR PC,FLISTB
	JMP ORT
SHTITL:		;INPUT - UOE PTR IN B
		;OUTPUT - "SHOWS" TITLE LINE
		;	-A POINTS TO LLP NODE FOR 1ST LINE
		;	- SKIPS UNLESS NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BINDF
	JMP RETC
	MOV A,4(P)
	PRTXT ^\TO \
	MOV 2(P),B
	JSR PC,PPNAME
	MOV 4(P),C
	JSR PC,.LOADC
	MOV A,4(P)	;SAVE PTR TO NEXT NODE
	JSR PC,.LOAD	;#ARGS IN B
	BIT #7777,A	;ANY TOKENS LEFT?
	BEQ SHTI1
	MOV A,C
SHTI2:	SPACE
	JSR PC,.LOADC	;NEXT ARG
	MOV A,C
	JSR PC,PRTAB	;PRINT TOKEN
	BIT #7777,C
	BNE SHTI2
SHTI1:	PRCR
	JMP SRETC
PRLN:	PUSH A	;PRINT PROC LINE ON S
	SPUSH B
	SPUSH C
	SPUSH D
	INC NBKTS	;PRINT OUTER LIST BRACKETS
	BIC #DPQF,FLAGS2	;DO PRINT QUOTE BEFORE STRINGS
	MOV @S,C
	JSR PC,.LOADC	;PRINT LINE #
	MOV A,C
	JSR PC,PRTAB
	BIT #7777,C
	BEQ PRLN3	;DONE
	JSR PC,.LOADC	;CHECK FOR TYPE = SNUM
	MOV A,C	;THIS MEANS 2ND TOKEN IS A CLGN & SHOULDNT PRINT
	BIC #7777,A
	CMP #SNUM,A
	BNE PRLN4
	BR PRLN2
PRLN1:	JSR PC,.LOADC
	MOV A,C
PRLN4:	SPACE
	JSR PC,PRTAB
PRLN2:	BIT #7777,C	;DONE?
	BNE PRLN1	;NO
PRLN3:	DEC NBKTS
	JMP RETD
	.STITL TEXT
TEXTT:	;LISTIFY TEXT OF PROC ON (S)
		;OUTPUT ON S
	JSR F,CACSAV
	JSR PC,LISTIT	;LISTIFY THE TITLE
	ERROR+HNM
	CLR F	;FOR LISTB
	ADD #2,S	;DONT NEED OUTPUT FROM LISTIT ON S
	JSR PC,LISTB	;THE TITLE LINE
	SUB #2,S	;WORK CELL
	BR TEXT2
TEXT1:	JSR PC,.LOADC	;GET NEXT LLP NODE
	MOV A,C	;SAVE PTR TO NEXT ONE
	MOV B,@S	;NPUT TO LISTLN
	JSR PC,LISTLN	;LISTIFY THIS LINE
	.BUG.	;BAD TOKEN IN PROC LINE??
	JSR PC,LISTB	;ADD TO LIST
TEXT2:	BIT #7777,C
	BNE TEXT1	;NOT DONE YET
	ADD #2,S	;POP WORK CELL
	JSR F,CACRES
	SKPRET
LISTIT:	;LISTIFY TITLE LINE OF PROC ON (S)
		;SKIP IF THERE
		;OUTPUT ON S AND IN A,,B.  C POINTS TO LLP NODE FOR 1ST LINE
	JSR F,CACSAV
	JSR PC,GUOEB	;GET UOE PTR FROM S
	BR LIT4	;NONE THERE
	MOV B,D	;SAVE UOE PTR
	CLR TOPS
	JSR PC,.BINDF	;GET PROC BINDING
	BR LIT4	;NONE THERE
			;RETURNS WITH FIRST NODE OF LLP IN A,,B
	JSR PC,.LOADA	;GET 2ND NODE
	MOV A,4(P)	;SAVE PTR TO 3RD NODE IN SAVED C
	JSR PC,.LOADB	;GET #ARGS NODE
LIT1:	PUSHS A
	JSR PC,LTOK	;LISTIFY THE DUMMY ARGS
	BR LIT3	;LOST???
	MOV #LSTR,A	;NOW ADD "TO FOO"
	MOV #$TOTO,B
	JSR PC,GRBAD	;"TO"
	MOV D,B
	JSR PC,.LOADB	;GET PNAME PTR
	MOV @S,A
	BIC #170000,A
	BIS #LSTR,A
	BIS #LIST,C
	MOV C,2(P)
	MOV #LIST,(P)
	MOV C,@S
	JSR PC,GRBAD1	;"FOO"
	JSR F,CACRES
	SKPRET
LIT3:	POPS A
LIT4:	JSR F,CACRES
	RTS PC
LISTLN:	;LISTIFY PROC LINE ON S
		;OUTPUT ON S AND IN A,,B
		;SKIPS UNLESS BAD TOKEN
	JSR F,CACSAV
	MOV @S,C	;GET LLP  IN C
	JSR PC,.LOADC	;GET LINE # NODE
	MOV B,F		;SAVE IT
	MOV A,@S	;SAVE PTR TO REST OF LINE
	MOV A,B
	JSR PC,.LOAD	;GET NEXT TOKEN AND CHECK IF IT IS ALSO SNUM
	BIC #7777,B
	CMP #SNUM,B
	BNE .+6
	MOV A,@S	;IT IS - SKIP OVER IT
	JSR PC,LTOK	;LISTIFY THE REST OF THE TOKENS
	BR LIL1		;LOST
	MOV F,B	;NOW ADD LINE # ON FRONT.  GET IT FROM F
	JSR PC,.CSNLS	;CONVERT SNUM TO LSTR
	BR .+2	;.CSNLS SKIPS
	MOV B,TOPS	;PTR TO LSTR IS IN B - PROTECT FROM G..C.
	MOV @S,A	;PTR TO TOKEN-LISTIFIED
	BIC #170000,A
	BIS #LSTR,A
	JSR PC,GRBAD
	CLR TOPS
	BIS #LIST,C
	MOV C,@S	;OUTPUT ON S
	MOV C,2(P)	;AND IN SAVED A AND B
	MOV #LIST,(P)
	JSR F,CACRES
	SKPRET
LIL1:	POPS A
	JSR F,CACRES
	RTS PC
LTOK:	;LISTIFY TOKEN LIST ON S
		;OUTPUT ON S AND IN A,,B
		;SKIP UNLESS A "BAD" TOKEN IS FOUND
	JSR F,CACSAV
	POPS C	;GET PTR TO TOKEN LIST
	JSR PC,SLISTB
LTOK1:	BIT #7777,C	;ANY TOKENS LEFT
	BEQ LTOKF
	JSR PC,.LOADC	;GET NEXT TOKEN
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	CMP #SNUM,A
	BEQ LTOK1	;IGNORE SNUM'S
	CMP #UFUN,A
	BHI LTOKSF	;MUST BE SFUN OR INFIX
	BEQ LTOKUF	;A USER PROC
	MOV #':,D
	CMP #UVAR,A
	BEQ LTOKCT	;A USER VARIABLE
	MOV #'",D
	CMP #ATOM,A
	BEQ LTOKCT	;A STRING
	BHI LTOKBD
	CMP #LSTR,A
	BNE LTOKAD	;AN INUM OR LIST - OK AS IS
	JSR PC,CONCTL	;AN LSTR, ADD A "
	BR LTOKAD
LTOKBD:	JSR PC,FLISTB	;BAD TOKEN
	POPS A
	JSR F,CACRES
	RTS PC
LTOKUF:	JSR PC,.LOAD	;USER PROC
LTOK3:	MOV #LSTR,A
LTOKAD:	JSR PC,LISTB
	BR LTOK1
LTOKSF:	JSR PC,CVSFLS	;CONVERT SYSTEM FUNCTION TO LSTR
	MOV TOPS,B
	CLR TOPS
	BR LTOK3
LTOKCT:	JSR PC,CONCT
	BR LTOK3
LTOKF:	JSR PC,FLISTB
	MOV A,(P)	;SAVED A
	MOV B,2(P)	;SAVED B
	JSR F,CACRES
	SKPRET
CONCT:	;APPEND CHAR IN D TO BEGINING OF PNAME OF ATOM IN B
		;OUTPUT #LSTR,,PTR IN A,,B
	JSR PC,.LOAD	;GET PNAME PTR
CONCTL:	PUSH C
	MOV B,A
	BIC #170000,A
	BIS #SSTR,A
	MOV D,B
	JSR PC,GRBAD
	MOV C,B
	MOV #LSTR,A
	BIS A,B
	POP C
	RTS PC
CVSFLS:	;CONVERT SFUN NAME TO LSTR
		;INPUT - A,,B SFUN OR INFIX TOKEN IN TOPS
		;OUTPUT -  LSTR PTR IN TOPS
	JSR F,CACSAV
	SPUSH PCHR
	JSR PC,BLSTI
	MOV #BLST,PCHR
	JSR PC,PROAB
	JSR PC,BLSTF
	.BUG.	;CANT HAVE NO CHARS!!
	POP PCHR
	JSR F,CACRES
	RTS PC
	.STITL ILINE & ERSET STUFF
ILINE:	;OUTPUT LAST LINE TYPED IN
	PUSHS ILINEL
	JSR PC,LTOK
	.BUG.	;A BAD TOKEN??
	SKPRET
ERRPRO:	;OUTPUT NAME OF PROC EXTENT AT LAST ERROR
	MOV NPROCL,B
	BEQ ERRPR1
	JSR PC,.LOAD
	PUSHS B
	SKPRET
ERRPR1:	PUSHS #LSTR
	SKPRET
ERRLIN:	;OUTPUT LINE # EXTENT AT LAST ERROR
	MOV NLINEL,B
	BR NTOKE1
ERRTOK:	;OUTPUT TOKEN # EXTENT AT LAST ERROR
	MOV NTOKEL,B
NTOKE1:	JMP R1NARG
ERRLOC:	;OUTPUT ADDR OF LAST ERROR
	MOV LASTER,B
	BR NTOKE1
ERRNUM:	;OUTPUT NO. OF LAST ERROR
	MOV ERRORN,B
	BR NTOKE1
ERRBREAK:	;OUTPUT BRAKE(U)
	MOV BRAKEL,B
	BR NTOKE1
ERRSET:	JSR PC,GTUOEB
	ERROR+HNM
	MOV B,ERPROC
	RTS PC
ERRCLE:	CLR ERPROC
	RTS PC
ERNAME:	;ERASE NAME
	JSR PC,GTUOEB
	BR ERN1
ERN2:	MOV #VBIND,A
	JSR PC,.UNBND
	RTS PC
	RTS PC
ERN1:	CMP #UFUN,A	;AN SFUN OR INFIX?
	BGT .+4
	ERROR+ERW
	JSR PC,CVSFLS
	MOV #ATOM,A
	JSR PC,.OBSCH
	RTS PC
	BR ERN2
	.STITLE ERASE
ERASE:	JSR PC,GTUOEB	;ERASE ...
	BR ERASE1	;NOT A PROCEDURE
	JSR PC,ERPR
ERASER:	ERROR+PNH	;PROCEDURE NOT HERE
	RTS PC

ERASE1:	CMP #SFUN,A
	BNE ERASER
	CMP #$ALL,B
	BEQ ERALL
	CMP #$TRACE,B
	BNE .+6
	JMP ETRACE
	CMP #$.STEP,B
	BNE .+6
	JMP ESTEP
	CMP #$BURY,B
	BNE .+6
	JMP EBURY
	.IFNZ OFILES
	CMP #$FILE,B
	BEQ ERFI
	.ENDC
	CMP #$LINE,B
	BEQ ERLINE
	CMP #$PROCE,B
	BEQ ERALPR
	CMP #$NAMES,B
	BEQ ERALNA
	CMP #$NAME,B
	BEQ ERNAME
ERASE3:	ERROR+ERW	;ERASE WHAT
ERALL:		;ERASE ALL
	CLR TOPRNM
ERALL1:	JSR	PC,ERALPR
	JSR	PC,ERALNA
	JMP ERTL3
ERL:
ERLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GET LINE # IN B
	ERROR+ERW	;ERASE WHAT??
	NEG B		;SO ADLN WILL ERASE IT
	MOV #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	PUSHS C
	JSR PC,ADLN
	ADD #2,S	;POP S
	RTS PC
ERPR:		;ERASE PROCEDURE (B)
	BIC #170000,B
	BIS #UFUN,B
	CMP B,TOPRNM
	BNE .+4
	ERROR+PBE	;PROCEDURE IS BEEN EDITED (UGH!!!)
	MOV #FBIND,A
	JMP .UNBND
ERALPR:		;ERASES ALL PROCEDURES
	TST TOPRNM
	BEQ .+4
	ERROR+PBES	;PROC BEING EDITED
	JSR PC,GNOLEI
	MOV #FBIND,A
ERALP1:	JSR PC,GNOLE	;GET NEXT UOE
	RTS PC	;DONE
	JSR PC,BURYQ
	BR ERALP1
	JSR PC,.UNBND
	BR ERALP1
	BR ERALP1
EAN:
ERALNA:		;ERASE ALL NAMES
	JSR PC,GNOLEI
ERALN1:	JSR PC,GNOLE
	RTS PC	;DONE
	MOV #VBIND,A
	JSR PC,.UNBND
	BR ERALN1	;EVENTUALLY HAVE TO CHECK FOR SVBIND
	BR ERALN1
	.IFNZ OFILES
ERFI:	MOV #FNAME,C
	JSR PC,G1FN
	BR .+4
	BR .+4
	ERROR+IFN
	JSR PC,DELETF
	JSR PC,FILERR
	RTS PC
	.ENDC
	.STITL TRACE
EBURY:	BIC #TF6,TFLAGS
BURY1:	MOV #TPBF,D
	BR TRA3

ESTEP:	BIC #TF6,TFLAGS
STEP1:	MOV #TPSF,D
	BR TRA3
ERTR:
ETRACE:	BIC #TF6,TFLAGS
TRA1:	MOV #TPTF,D
TRA3:	JSR PC,GTUOEB
	BR TRA6
	JSR PC,CSSTF
TRA5:	ERROR+PNH	;PROC NOT HERE
	RTS PC
TRA6:	CMP #SFUN,A
	BNE TRA5
	CMP #$ALL,B
	BEQ .+4
	ERROR+ERW
	JSR PC,GNOLEI
TRA7:	JSR PC,GNOLE
	RTS PC
	CMP #TPBF,D	;UNBURY BURIED PROCS
	BEQ TRA8
	JSR PC,BURYQ	;BUT DON'T TRACE UNTRACE STEP OR UNSTEP THEM.
	BR TRA7
TRA8:	JSR PC,CSSTF
	BR TRA7
	BR TRA7

CSSTF:	JSR PC,.BNDFS
	RTS PC
	MOV B,C	;B POINTS TO LIST OF GOODIES. FIRST IS FLAGS,,#ARGS
	JSR PC,.LDP2
	BIC D,A
	BIT #TF6,TFLAGS
	BEQ TRA2
	BIS D,A
TRA2:	JSR PC,.STP2
	SKPRET

BURYQ:	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	JMP RETC
	JSR PC,.LOADB
	BIT #TPBF,B
	BEQ .+6
	JMP RETC
	JMP SRETC

TRACE:	BIS #TF6,TFLAGS
	BR TRA1
STEP:	BIS #TF6,TFLAGS
	BR STEP1
BURY:	BIS #TF6,TFLAGS
	BR BURY1

STRACS:	BIT #TRACEF,FLAGS2
	BEQ STRT
	SPACE
	BR STRA1
STRACE:	BIT #TRACEF,FLAGS2	;SYSTEM TRACE
	BNE .+4
STRT:	RTS PC
STRA1:	INC NBKTS
	PUSH A
	PRTXT ^/CT=/
	BIC #DPQF,FLAGS2
	JSR PC,PRCT
	PRTXT ^/ CO=/
	JSR PC,PRCO
	PRTXT ^/ S=/
	BIC #DPQF,FLAGS2
	JSR PC,PRS1
	PRCR
	CLR NBKTS
	POP A
	RTS PC

SETSTF:	JSR PC,CKSST
	BIS #TRACEF,FLAGS2	;SET SYSTEM TRACE FLAG
	RTS PC

CLRSTF:	JSR PC,CKSST
	BIC #TRACEF,FLAGS2
	RTS PC

FLEV:	MOV FUNLEV,B	;RETURN USER PROC CALL DEPTH
FLEV1:	JMP R1NARG
NODES:	;OUTPUT NO. OF NODES IN FREE STG LIST
	MOV NNIFSL,B
	BR FLEV1
.STITL	UTILITY ROUTINES

GOODBYE:	MOV USER,U
	JSR PC,RUNME
	CPRTXT ^/AND A PLEASANT DAY TO YOU!/
	BR HELLO2

HELLO:	MOV USER,U
	JSR PC,RUNME	;IN CASE CALLED BY GUN
HELLO2:	PRCR
	MOV #LOCKUS,D
	JSR	PC,LCUGRB
	JSR	PC,NODEV	;FREE ALL DEVICES
	MOV USER,U
	MOV #FRNEWU,FLSRES(U)
	CLR FLSADR(U)
	CLR BRAKE(U)
	MOV	UTTY(U),E
	JSR	PC,UCINIT	;INITIALIZE CONSOLE
	MOV SPDLP,P
	JMP NEXTUS


GUN:	JSR	PC,G1NARG
	TST	B
	BGE	.+4
GUNE:	ERROR+IFN
	CMP	B,NUSERS
	BGE	GUNE
.IFNZ A1120
	MOV	B,MQ
	MOV	#LUBLK,MULTIP
	MOV	MQ,U
.IFF
	MUL #LUBLK,B
	MOV B,U
.ENDC
	CLR	FLSRES(U)
	CLR	FLSADR(U)
	MOV	#GOODBYE,UPC(U)
	MOV PC,BRAKE(U)
	RTS PC


VERSN:	MOV LVERNF,B
	BR	RANDO1
RANDOM:
.IFNZ A1120
	MOV #MQ,A
	MOV RNSEED,(A)+	;GET OLD SEED
	MOV #71275,(A)	;MUL SEED BY GOOD NUMBER!!
	ADD #13713,-(A)	;ADD ANOTHER GOOD NUMBER!! TO LOW ORDER PART
	MOV (A),RNSEED	;THIS IS THE NEW SEED
	CLR -(A)	;CLEAR THE HIGH ORDER PART
	MOV #10.,MULTIP	;MUL LOW ORDER PPART BY 10.
	MOV (A),B	;THE HIGH ORDER PART IS THE DESIRED DIGIT
.IFF
	MOV RNSEED,B	;GET OLD SEED
	MUL #71275,B	;MUL SEED BY GOOD NUMBER!!
	ADD #13713,B	;ADD ANOTHER GOOD NUMBER!! TO LOW ORDER PART
	MOV B,RNSEED	;THIS IS THE NEW SEED
	MOV B,A
	MUL #10.,A	;MULTIPLY IT BY 10
	MOV A,B		;HIGH-ORDER PART IS THE DESIRED DIGIT
.ENDC
	ADD #5,B
RANDO1:	JMP R1NARG
BELL:	MOV #7,D
	BR .+6
CR:	MOV #1,D
	JSR PC,TYO
	RTS PC
DEBUGL:	TST ALEVN
	BEQ DEBUG1
	PRTXTC ^\OFF\
	CLR ALEVN
	JMP ERTL2
DEBUG1:	PRTXTC ^\ON\
	MOV #1,ALEVN
DEBUG2:	RTS PC
SGCF:	JSR PC,CKSST
	BIS #MGCF,FLAGS2
	RTS PC
CGCF:	JSR PC,CKSST
	BIC #MGCF,FLAGS2
	RTS PC
STATUS:	BIT #SSF,FLAGS2
	BNE	STATU2	;IF ON TURN OFF
	JSR PC,TINECH
	JSR PC,RDSTR	;READ A STRING
	BR	STATU2	;EMPTY OR BREAK
	MOV @S,B	;SEE IF EQUAL TO "SECRET
	MOV #SECRET,C
	JSR PC,EQUAL1
	BR STATU1	;NOPE
	BIS #SSF,FLAGS2	;YES
	POPS A	;POINTER TO STRING READ IN
	PRTXTC	^\ON\
	BR	STATU3
STATU1:	POPS	A
STATU2:	PRTXTC	^\OFF\
	BIC	#SSF,FLAGS2
STATU3:	JSR	PC,TIECH
	RTS PC

CKSST:	TST DEBSW
	BNE CKSST1
	BIT #SSF,FLAGS2
	BEQ .+4
CKSST1:	RTS PC
	ERROR+HNM1

SPNF:			;SET PRINT NODES FLAG
	BIS #PNNLF,FLAGS2
	RTS PC
CPNF:	BIC #PNNLF,FLAGS2	;CLEAR IT
	RTS PC

COMT:	.BUG.		;GNT SHOULD SWALLOW ALL COMMENTS;
			; THEY SHOULD NEVER BE SEEN BY EVAL

;EXAMINE AN ABSOLUTE LOCATION
EXAMINE: JSR PC,CKSST	;MAKE SURE USER IS PRIVILEGED
	JSR	PC,GLWANE	;GET A WORD OF ARGUMENT
	ERROR+WTAB
	MOV	#INUM,A
	MOV	#8.-10.,ABASE
	JSR	PC,CONVERT	;CONVERT ARGUMENT TO OCTAL NUMBER IN B
	ERROR+WTAB
	MOV B,C
	JSR PC,.LDP2
	MOV A,B
	BIC #1,B	;MAKE SURE NOT BYTE
	MOV (B),WVALUE	;SAVE CONTENTS FOR VALUE TO OUTPUT
	JSR	PC,PLOCB	;PRINT LOCATION & CONTENTS
	CLR	ABASE
	RTS PC

;DEPOSIT IN AN ABSOLUTE LOCATION
DEPOSIT:	JSR PC,EXAMINE	;PRINT LOCATION
	PUSH B		;SAVE LOCATION
	SPUSH	(B)	;AND FORMER CONTENTS
	JSR PC,RDSTR	;READ A LINE FROM THE TTY
	BR	DEPOS2	;EMPTY
	MOV #INUM,A
	MOV @S,B
	MOV	#8.-10.,ABASE	;MAKE FOLLOWING CONVERSION OCTAL
	JSR PC,CONVERT	;CONVERT TO NUMBER
	ERROR+WTAB	;CONVERSION FAILED
	MOV B,C
	JSR PC,.LDP2	;GET NUMBER BACK IN A
	POP D		;FORMER CONTENTS
	SPOP B		;LOCATION
	MOV A,WVALUE	;SAVE NEW VALUE AS CONTENTS
	MOV A,(B)	;DEPOSIT
	CMP	(B),D
	BEQ	DEPOS1	;BR IF LOCATION NOT CHANGE
	TST USER
	BLE DEPOS1	;IF USER ALREADY ON SYSTEM CONSOLE
	JSR A,SPRINT
	JSR PC,PLOCB	;PRINT LOC AND NEW CONTENTS
	PRTXT ^/ WAS: /
	MOV D,A
	JSR PC,PRON	;PRINT OLD CONTENTS
	PRCR
	SPREND
DEPOS1:	CLR	ABASE	;SET CONVERT BASE BACK TO DECIMAL
	RTS PC		;DONE.
DEPOS2:	POP B
	SPOP B
	BR DEPOS1


;OUTPUT LAST CONTENTS SEEN IN AN EXAMINE OR DEPOSIT
VALUE:	MOV WVALUE,B
	JMP R1NARG
	.STITL ERRORS AND HANDLER
EMTBK:	MOV #SRET,@P	;FAKE IT OUT
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT
ERRBK:	PUSH A
	.IFNZ OFILES
	;	*** RON'S DISC CLEANUP STUFF
	CMP #WRITEC,PCHR	;AM I DOING DISC OUTPPUT?
	BNE ERBK2	;NO
	JSR PC,WRITCU	;CLOSE THE FILE
	JSR PC,DELETF	;DELETE IT
	.ENDC
ERBK2:	MOV #WDIRSW,D
	JSR PC,LCUGRB
	MOV #PGRAB,D
	JSR PC,LCUGRB	;RLEASE PAPER TAPE
.IIF NZ OFILES,	CMP #TYI,GCHR	;IF ERROR OUT OF READ
.IIF Z OFILES,	TST REDFLG
	BEQ ERBK3	;FINISH UP PENDING PROC DEF
.IIF Z OFILES,	CLR FILFLG
	TST TOPRNM
	BEQ ERBK3
	JSR PC,END
ERBK3:	.IFNZ OFILES
	TST FILFLG
	BNE .+6
	CLR DSKNCH
	.ENDC
	.IFZ OFILES
	TST WRTFLG
	BEQ .+6
	JSR PC,WDELBL
	.ENDC
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	MOV 2(P),A
	MOV A,LASTER
	.IFNZ SEG
	MFPI -2(A)	;GET ERROR NUMBER (CROCK!!!)
	MOV (P)+,A
	.IFF
	MOV -2(A),A	;GET ERROR #
	.ENDC
	BIC #177400,A
	MOV A,ERRORN
	CLR NTOKEL
	CLR NLINEL
	MOV CPP,NPROCL
	BEQ ERBK5
	MOV CPLN,NLINEL
	MOV CTN,NTOKEL
ERBK5:	CMP A,#BUG	;DONT ALLOW ERRSET FOR .BUG. OR FBUG
	BEQ ERSET2
	CMP A,#FBUG
	BEQ ERSET2
	TST ERPROC	;ERROR SET ON?
	BEQ ERSET2
	JSR F,CACSAV
	PUSH CO
	SPUSH CO+2
	SPUSH NOR
	MOV USER,U	;SAVE BRAKE STATUS
	SPUSH BRAKE(U)
	CLR BRAKE(U)
	MOV (P),BRAKEL
	BEQ .+6	;IF THERE REALLY WAS A BRAKE PENDING,
	JSR PC,BRAKR	;ALLOW TYPEOUT AGAIN
	SPUSH ERPROC
	MOV ERPROC,CO+2
	CLR ERPROC
	JSR PC,SAVPPS	;YES - SAVE THE PDLS
	BIS #1,CSPDLP	;INDICATE ERRORSET PUSH
	BIS #1,CPDLP
	MOV #UFUN,CO
	CLR NOR
	JSR PC,PEVAL
	BR ERSET1	;DIDNT OUTPUT
	JSR PC,PRS1	;DID OUTPUT, PRINT IT
	JSR PC,RESPPS
	POP ERPROC
	JMP ERTLN	;THEN ERROR RETURN
ERSET1:		;DIDNT OUTPUT, DO WHAT U WERE GOING TO
	JSR PC,RESPPS
	POP ERPROC
	MOV USER,U
	SPOP BRAKE(U)
	SPOP NOR
	SPOP CO+2
	SPOP CO
	JSR F,CACRES
ERSET2:
	MOV 2(P),A
;	BIT #PADERF,FLAGS2
;	BEQ ERBK1
	TST NOADDR
	BNE ERBK1
	JSR PC,PRONL	;PRINT ADDR WHERE ERROR OCCURED
	SPACE
ERBK1:	MOV ERRORN,A
	CMP #FSTNER,A
	BLE NEWERR
	ASL A
	MOV ERTAB(A),A	;POINTS TO LIST FOR THIS ERROR
	JMP @A	;XFER TO LIST
NEWERR:	ASL A
	.IFZ NEWERS
	MOV ERTAB(A),ERRPNT
	.ENDC
	.IFNZ NEWERS
	SPUSH 	B
	SPUSH A
	JSR PC,SYDRBG
	CLR (A)+
	SPOP B
	MOV ERTAB(B),(A)
	SUB ERTAB+2(B),(A)
	ASR (A)+
.IFZ SEG
	MOV #DBUF,(A)+
.IFF
	SPUSH C
	SPUSH F
	MOV USER,F
	MOV SLOTAS(F),C
	MOV #ERRBUF-PURE,(A)
	MOV SLOTHA(C),F
	ADD SLOTCA(C),(A)+
	ADC F
	ASH #4,F
	MOVB F,6(A)
	SPOP F
	SPOP C
.ENDC
	CLR 2(A)
	MOV ERTAB(B),(A)
	ASR (A)
	ADD ERBASE,(A)+
	ADC (A)
	ADD ERBASE+2,(A)+
	TST (A)+
	BISB #DREADC,(A)
	JSR PC,DSKWAI
	MOV #ERRBUF,ERRPNT
	SPOP B
	.ENDC
NEWER1:	MOVB @ERRPNT,D
	BEQ ERTLN
	BGT NEWER2
	BIC #177600,D
	ASL D
	MOV ROTTAB(D),A
	JSR PC,(A)
NEWER3:	INC ERRPNT
	BR NEWER1
NEWER2:	JSR PC,TYO
	BR NEWER3
ERRRT:	POP A
.IIF NZ A1120,	RTI
.IIF NZ A1145,	RTT

PPLACE:	MOV FUNLEV,A
	BEQ PPLAC1
	CPRTXT ^\AT LEVEL \
	JSR PC,PRDN
	PRTXT ^\  LINE \
	MOV CPLN,A
	JSR PC,PRDN
	PRTXT ^\  IN \
	MOV CPP,B
	JSR PC,PPNAME
PPLAC1:	JMP .CRLF

ERTLN:			;ERR RETURN TO LEVEL N
	TST ALEVN
	BEQ ERTL0
	BIS #ERRF+BRKF,FLAGS
	MOV USER,U
	CLR BRAKE(U)
ERTLN1:	JSR PC,PPLACE
	JMP MLOOP
ERTL0:			;ERR RETURN TO LEVEL 0
	MOV	USER,U
	CLR	BRAKE(U)
ERTL01:	JSR PC,PPLACE
EXIT:
ERTL2:	TST FUNLEV	;POP UP TO LEVEL 0
	BLE ERTL3
	MOV #ERTL2,PSTOPR
	JMP PSTP15
ERTL3:	CLR A	;CLEAR OUT PDLS
	JSR PC,PPTA
	CLR A
	JSR PC,PSTA
	CLR CSPDLP
	CLR CPDLP
	MOV #ERCLR1,A
	MOV #<ERCLR2-ERCLR1>/2,B
	CLR (A)+
	DEC B
	BGT .-4
	BIC #EDTIF+ERRF+BRKF,FLAGS
	JMP MLOOP

	.STITL ERROR ROUTINES
		; ****  THESE ARE NOW ALPHABETIZED   *****

.IIF NDF MAXELN,MAXELN==0

BRK.E:
	MOV USER,U
	MOV BRAKE(U),A
	CLR BRAKE(U)
	JSR PC,BRAKR
	TST A
	BLT PAUSE
BRK.2:	PRTXT ^\BREAK\
	JMP ERTL01

PAUSE:	BIS #BRKF,FLAGS
	PRTXT ^\PAUSE \
	JMP ERTLN1

	BEGER BUG
	TST	DEBSW
	BNE	BUG.1	;BR IF DEBUGGING
	DEC NSYBUG
	BGE .+4
	ERROR+FBUG
BUG.1:	PRTXT ^/HELP!!!  SYSTEM BUG VER=/
	MOV #VERNF,A
	JSR PC,PRDN
	JSR PC,.SPACE
	PUSH	E
	SPUSH	U
	MOV	USER,U
	MOV	UTTY(U),E
	TST	TOTN(E)
	BGT	.-4	;WAIT TILL TYO BUF EMPTY
	POP	U
	SPOP	E
	SPOP A
	TST	DEBSW
	BEQ	.+4
BUGBPT:	BPT	;BRK IF IN DEBUG MODE
	ENDER

	BEGER CTIT
	PRTXT ^\YOU ARE ALREADY DEFINING \
	MOV TOPRNM,B
	JSR PC,PPNAME
	ENDER

	BEGER FBUG
	PRTXT ^/FATAL SYSTEM BUG!/
	JMP GOODBY

	BEGER HNM
	MOV #UFUN,A
	JSR PC,PROAB
	PRTXT ^/ HAS NO MEANING./
	ENDER

	BEGER LDE
	MOV JPLN,CPLN	;MAKE JUMPED-FROM LINE = POINT OF ERROR
	PRTXT ^\LINE \
LDE.E1:	MOV B,A
	JSR PC,PRDN	;LINE # SHOULD BE IN A
	PRTXT ^\ DOESN'T EXIST.\
	ENDER

	BEGER PAE
	MOV #UFUN,A
	MOV TEMP,B
	PRTXT ^/PROCEDURE /
	JSR PC,PROAB
	PRTXT ^/ ALREADY EXISTS./
	ENDER


	BEGER PNH
	PRTXT ^/PROCEDURE /
	JSR PC,PRCT
	PRTXT ^/ NOT HERE/
	ENDER

	BEGER PNH1
	MOV CPP,B
	MOV #UFUN,A
	PRTXT ^/PROCEDURE /
	JSR PC,PROAB	;PRINT OPERATOR IN A,,B
	PRTXT ^/ HAS BEEN ERASED!!??/
	ENDER

	BEGER TDE
	PRTXT ^\TTY \
	JMP LDE.E1

	BEGER TMAP
	PRTXT ^\A PROCEDURE CAN'T TAKE MORE THAN 32 ARGS.\
	JMP ERRRT	;RETURN!!
	BEGER WTA
ERWTA:	JSR PC,PRCO
	PRTXT ^/ DOESN'T LIKE /
	JSR PC,PRS1
	PRTXT ^/ AS INPUT./
	ENDER

	BEGER WTAA
	PUSHS A
	BR	ERWTA
	ENDER

	BEGER WTAB
	PUSHS B
	BR	ERWTA
	ENDER
