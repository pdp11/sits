
.IFZ HAL1

;ORBIT HACK--CALL WITH THE NAME OF ARRAY OF DATA
;THE FORMAT FOR THE DATA IS
;NUMBER OF ATTRACTIVE SOURCES
;NUMBER OF INTEGRATION STEPS PER CALL (<50)
;DT
;OBJECT	XPOS
;	YPOS
;	XVEL
;	YVEL
;	XFORCE
;	YFORCE
;	MINIMUM LEGAL RADIUS
;GRAV SOURCE XPOS
;	YPOS
;	DIST FROM OBJECT
;	FIELD CONSTANT
;THIS LAST BLOCK REPEATED FOR EACH SOURCE

;THE ROUTINE UPDATES THE VARIABLES

HALHACK:	SPOPS	A
	JSR	PC,AMAKE5	;B NOW POINTS TO ARRAY HEADER
	MOV	B,C
	CMP	(C)+,(C)+
	CMP	(C)+,#150001	;TYPE=FLOATING   #DIMS=1
	BEQ	.+4
	ERROR+BAT
	CMP	(C)+,(C)+
	MOV	(C)+,A	;ARRAY SIZE
	LDCFD	(C)+,FA
	LDCFD	(C)+,FB
	SETI
	STCFI	FA,D	;#OF ATTRACTORS
	STCFI	FB,B	;#OF INTEGRATION STEPS
	SETL
	TST	B	;POSITIVE?
	BGT	.+4
	ERROR+DOR
	CMP	B,#50.	;NOT TOO BIG (PIGGY)
	BLE	.+4
	ERROR+DOR
	ASL	D
	ASL	D
	ADD	#10.,D	;SIZE ARRAY SHOULD BE
	CMP	A,D
	BGE	.+4
	ERROR+ROB	;ARRAY TOO SMALL
	SUB	#3,D
	ASL	D
	ASL	D
	ADD	C,D	;POINTS TO LAST DATA WORD
	MOV	C,A
	ADD	#32.,A	;POINTS TO XPOS OF FIRST BODY
	PUSH	A
	SPUSH	D
;A NOW POINTS TO XPOS OF FIRST BODY
;B HAS NUMBER OF STEPS PER CALL
;C POINTS TO DT
;D POINTS TO CONSTANT FOR LAST BODY
;NOW COMPUTE THE FORCE ON THE OBJECT

	SETF
HALOP:	MOV	(P),D
	MOV	2(P),A
HALOP1:	LDF	4(C),FB	;POSITION OF OBJECT
	LDF	8.(C),FC
	SUBF	(A)+,FB	;DX
	SUBF	(A)+,FC	;DY
	STF	FC,FD
	MULF	FD,FD	;DY^2
	STF	FB,FA
	MULF	FA,FA	;DX^2
	ADDF	FD,FA
	JSR	PC,HALSQ	;GET SQRT OF FA INTO FD
	STF	FD,(A)+	;RADIAL DISTANCE FROM SOURCE
	CMPF	28.(C),FD	;IS RADIUS LESS THAN 10?
	CFCC
	BGT	HALERR
	MULF	FD,FA
	LDF	(A)+,FD	;FIELD CONSTANT
	DIVF	FA,FD	;K/(R*R^2)
	MULF	FD,FB	;FX=(ABOVE)*DX
	MULF	FD,FC
	ADDF	20.(C),FB
	STF	FB,20.(C)	;INCREMENT FORCE-X
	ADDF	24.(C),FC	;FORCE-Y
	STF	FC,24.(C)
	CMP	A,D
	BLO	HALOP1	;MORE FORCES?

;NOW DO THE INTEGRATION
	MOV	C,E
	LDF	(C),FB	;DT
HALOP2:	LDF	20.(C),FA
	MULF	FB,FA	;FORCE*DT
	ADDF	12.(C),FA	;V_V+A
	STF	FA,12.(C)
	MULF	FB,FA	;V*DT
	ADDF	4(C),FA	;R_R+V*DT
	STF	FA,4(C)
	CMP	C,E
	BHI	HALOP3
	ADD	#4,C	;NOW DO Y COORDINATE
	BR	HALOP2
HALOP3:	MOV	E,C	;RESTORE POINTER TO DT
	CLRF	20.(C)	;CLEAR THE FORCES
	CLRF	24.(C)
	SOB	B,HALOP
	SETD
	CMP	(P)+,(P)+	;FIX THE STACK
	SEZ
	RTS	PC

HALERR:	SETD
	ERROR+RTB
;SQUARE ROOT ROUTINE RETURN ROOT OF FA IN FD

HALSQ:	JSR	PC,PPUSHT
	STF	FB,-(P)	;SAVE FB
	STF	FA,FD
	DIVF	#40400,FD	;START ITER AT A/2
HALSQ1:	STF	FD,FB
	STF	FA,FD
	DIVF	FB,FD	;A/B
	ADDF	FB,FD
	DIVF	#40400,FD	;(B+A/B)/2
	SUBF	FD,FB
	ABSF	FB	;ERROR
	DIVF	FA,FB
	CMPF	#34000,FB	;ERR LESS THAN 2^(-15) ?
	CFCC
	BLT	HALSQ1
	LDF	(P)+,FB	;
	RTS	PC

.ENDC
.IFZ HAL1-1

;ORBIT HACK FOR ORBITS IN VELOCITY SPACE
;CALL TO UPDATE VX,VY,UX,UY,R,A,T BASED ON OLD VALUES AND ZX,ZY,L,U
;ALSO SUPPLY EITHER DA OR DT

;IF DT IS NON-ZERO WILL COMPUTE BASED ON DT

;IF DT IS ZERO COMPUTE BASED ON DA (BUT ADJUST VALUE OF DA TO BE
;NOT SO BIG AS TO GIVE LARGE ERROR

;ARGUMENT TO THIS PRIMITIVE IS A FLOATING POINT ONE-DIMENSIONAL ARRAY

;VALUES IN THE ARRAY ARE, IN ORDER
;DT,DA,T,A,X,Y,R,UX,UY,U,ZX,ZY,VX,VY,L

H.DT=0
H.DA=H.DT+4
H.T=H.DA+4
H.A=H.T+4
H.X=H.A+4
H.Y=H.X+4
H.R=H.Y+4
H.UX=H.R+4
H.UY=H.UX+4
H.U=H.UY+4
H.ZX=H.U+4
H.ZY=H.ZX+4
H.VX=H.ZY+4
H.VY=H.VX+4
H.L=H.VY+4

H.ASIZE=15.

;MAIN LOOP

HALHAC:	JSR PC,H.IN	;CHECK ARRAY TYPE AND SET UP C TO POINT TO 1ST WORD
	SETF	;SET FPP TO FLOATING (NON-DOUBLE)
	JSR PC,H.CDA	;STICK DA IN TEMP

H.HK1:	JSR PC,H.COM	;COMPUTE R,A SIN A, COS A
	LDF H.DT(C),FD	;SEE IF DT=0
	TSTF FD
	CFCC
	BNE H.HK2

	JSR PC,H.ER	;DT=0, CHECK ERROR
	BEQ H.HK1	;NO GOOD. GO BACK
	JSR PC,H.CT	;COMPUTE T BASED ON R, L AND DA
	BR H.HK3

H.HK2:	LDF H.T(C),FC	;DT NON-ZERO, ADD TO OLD T TO GET NEW T
	ADDF FD,FC

H.HK3:	JSR PC,H.ALL	;STORE ALL THE VALUES
	SETD	;RESTORE DOUBLE PRECISION
	SEZ	;SIGNAL NOT OUTPUTTING
	RTS PC
;INIT C TO POINT TO FIRST DATA WORD

H.IN:	SPOPS	A
	JSR	PC,AMAKE5	;B NOW POINTS TO ARRAY HEADER
	MOV	B,C
	CMP	(C)+,(C)+
	CMP	(C)+,#150001	;TYPE=FLOATING   #DIMS=1
	BEQ	.+4
	ERROR+BAT
	CMP	(C)+,(C)+
	MOV	(C)+,A	;ARRAY SIZE
	CMP	A,#H.ASIZE
	BEQ	.+4
	ERROR+BAT
	RTS PC
;COMPUTE DA AND STORE IT IN TEMP
;CALLED WITH C POINTING TO BEGINNING OF ARRAY

;IF DT=0 THEN DA=DA*(SGN L)
;OTHERWISE DA=L*DT/R**2

H.CDA:	LDF H.DT(C),FA
	TSTF FA
	CFCC		;IS DT=0?
	BNE H.CDA1

	LDF H.DA(C),FA	;DT=0
	LDF H.L(C),FB	;L
	TSTF FB
	CFCC
	BGT H.CDAR
	NEGF FA		;IF L<0 NEGATE DA
	BR H.CDAR

H.CDA1:	LDF H.L(C),FB	;COMPUTE DA FOR DT NOT EQUAL TO 0
	MULF FB,FA	;L*DT
	LDF H.R(C),FB	;R
	MULF FB,FB	;SQUARE IT
	DIVF FB,FA	;L*DT/R**2

H.CDAR:	STF FA,TEMP
	RTS PC
;COMPUTE A AND R
;LEAVE A IN FA, R IN FB
;SIN A IN TEMP+4
;COS A IN TEMP+10

;A=OLD A + DA
;R=L/(U-ZX*COS A - ZY*SIN A)

H.COM:	LDF H.A(C),FB	;PREVIOUS A
	LDF TEMP,FA	;DA
	ADDF FB,FA
	JSR PC,H.M360	;REDUCE IT MOD 360
	FPUSH FA
	SPUSH C
	FPUSH FA
	SETD	;SIN ROUTINE NEEDS DOUBLE PRECISION
	JSR PC,SINDEG
	STCDF FA,TEMP+4
	SETF	;RESTORE FOR THE POP
	FPOP FA
	SETD
	JSR PC,COSDEG
	STCDF FA,TEMP+10
	SETF
	POP C

	LDF H.ZX(C),FB	;X COMPONENT OF Z VECTOR
	MULF FA,FB	;ZX*COS A
	LDF TEMP+4,FC	;SIN A
	LDF H.ZY(C),FA
	MULF FA,FC	;ZY*SIN A
	ADDF FC,FB	;ZY*SIN A + ZX*COS A
	LDF H.U(C),FA	;LENGTH OF U VECTOR
	SUBF FB,FA	;U - (ABOVE)
	LDF H.L(C),FB
	DIVF FA,FB	;AND THAT'S R
	FPOP FA		;A
	RTS PC

H.M360:	LDF #42264,FB	;REDUCE A MOD 360
H.M31:	TSTF FA		;IS IT NEGATIVE?
	CFCC
	BGE H.M32
	ADDF FB,FA
	BR H.M31

H.M32:	CMPF FA,FB	;IS IT BIGGER THAN 360?
	CFCC
	BLT H.M3R
	SUBF FB,FA
	BR H.M32

H.M3R:	RTS PC
;COMPUTE THE ERROR TERM
;ENTER WITH A IN FA, R IN FB AND PRESERVE THESE
;ERROR TERM IS (ABS (R-OLD R)) + (ABS DA*R)/67

;IF E>10 SET DA TO DA/1.1 AND SIGNAL TO REDO COMPUTATION
;IF E<6 SET DA TO DA*1.1 AND REDO COMPUTATION

;TO REDO COMPUTATION SET Z BIT ON LEAVING

H.ER:	FPUSH FA
	FPUSH FB
	LDF H.R(C),FC	;OLD R
	SUBF FB,FC
	ABSF FC		;ABS (R -OLDR)
	LDF TEMP,FD	;DA
	MULF FB,FD
	ABSF FD		;ABS(R*DA)
	DIVF #41606,FD	;ABOVE/67
	ADDF FC,FD	;THE ERROR TERM

	CMPF #41040,FD	;COMPARE WITH 10
	CFCC
	BGT H.ER1	;10>ERROR

	LDF H.1.1,FA	;TOO BIG--DIVIDE BY 1.1
	LDF TEMP,FB
	DIVF FA,FB
	STF FB,TEMP
	BR H.ERL

H.ER1:CMPF #40700,FD	;COMPARE WITH 6
	CFCC
	BLT H.ERW	;6<ERROR

	LDF H.1.1,FA	;TOO SMALL--MULTIPLY BY 1.1
	LDF TEMP,FB
	MULF FA,FB
	STF FB,TEMP

H.ERL:	FPOP FB
	FPOP FA
	SEZ		;REDO COMPUTATION
	RTS PC

H.ERW:	FPOP FB		;DON'T REDO COMPUTATION
	FPOP FA
	CLZ
	RTS PC;COMPUTE DT = R**2 * DA/L
;COMPUTE T=T+DT AND LEAVE ANSWER IN FC

H.CT:	FPUSH FB	;SAVE R
	MULF FB,FB	;R**2
	LDF TEMP,FC
	MULF FB,FC	;R**2 * DA
	LDF H.L(C),FB
	DIVF FB,FC	;DT
	LDF H.T(C),FB	;OLD T
	ADDF FB,FC	;NEW T
	FPOP FB
	RTS PC
;SET ARRAY VARIABLES
;FA HAS A, FB HAS R, FC HAS T
;TEMP+4 HAS SIN A
;TEMP+10 HAS COS A

H.ALL:	STF FA,H.A(C)
	STF FB,H.R(C)
	STF FC,H.T(C)
	LDF H.U(C),FA
	LDF TEMP+4,FB
	MULF FA,FB	;U*SIN A
	NEGF FB
	STF FB,H.UY(C)	;UY=-U*SIN A
	LDF TEMP+10,FC
	MULF FA,FC
	NEGF FC
	STF FC,H.UX(C)	;UX=-U*COS A

	LDF H.ZX(C),FA
	ADDF FC,FA	;VX=UX+ZX
	STF FA,H.VX(C)
	LDF H.ZY(C),FA
	ADDF FB,FA	;VY=UY+ZY
	STF FA,H.VY(C)

	LDF H.R(C),FC
	LDF TEMP+4,FA
	MULF FC,FA
	NEGF FA
	STF FA,H.X(C)	;X=-R SIN A

	LDF TEMP+10,FA
	MULF FC,FA
	STF FA,H.Y(C)	;Y=R COS A

	RTS PC

.ENDC
.IFZ HAL1-2
;STRESS MACHINE HACK

.MACRO VERTEX R		; R IS VERTEX NUM BECOMES VERTEX POINTER
.IRP X,<A,C,E>
.IFIDN X,R
MUL #LVENT,R
ADD VERTA,R+1
MOV R+1,R
.ENDC
.ENDM
.IRP X,<B,D>
.IFIDN X,R
MUL #LVENT,R
ADD VERTA,R
.ENDC
.ENDM
.ENDM

.MACRO ROD R		; R IS ROD NUMBER BECOMES ROD POINTER
.IRP X,<A,C,E>
.IFIDN X,R
MUL #LRENT,R
ADD RODA,R+1
MOV R+1,R
.ENDC
.ENDM
.IRP X,<B,D>
.IFIDN X,R
MUL #LRENT,R
ADD RODA,R
.ENDC
.ENDM
.ENDM

.MACRO SIGNS R
BIS #100000,R
.ENDM

.MACRO SIGNC R
BIC #100000,R
.ENDM


;STRESS TAKES THREE ARGUMENTS, VERTEX ARRAY, ROD ARRAY AND CONTROL ARRAY
;ARRAY FORMATS ARE

;VERTEX ARRAY
LVENT==64.

X==0	;COORDS OF VERTEX
Y==X+4
CSIN==Y+4 ;COMPONENTS OF CONSTANT FORCE
CCOS==CSIN+4
RSIN==CCOS+4 ;DIRECTION OF RESTRAINED MOTION
RCOS==RSIN+4
RN0==RCOS+4 ;BEGINS LIST OF ADJOINING RODS--UP TO 10

;ROD ARRAY
LRENT==32.

N1==0    ;1ST VERTEX NEIGHBOR
N2==N1+4  ;2ND VERTEX NEIGHBOR
SST==N2+4  ;COMPONENTS OF THE STRESS
CST==SST+4
RL==CST+4 ;RESTING LENGTH
CL==RL+4 ;CURRENT LENGTH
ELAS==CL+4 ;ELASTICITY
BRK==ELAS+4 ;BREAKING POINT

;CONTROL ARRAY
NCINF==4	;NUMBER OF ENTRIES IN CONTROL ARRAY
ITER==0 ; NUMBER OF ITERATIONS
EPSIL==ITER+4 ;TOLERANCE FOR VERTEX UPDATES
SCALE==EPSIL+4 ;FACTOR FOR AMOUNT OF MOTION PER APPLIED FORCE
RODTL==SCALE+4 ;TOLERANCE FOR ROD UPDATE
;REST OF CONTROL ARRAY IS THE UPDATEQ



HALHACK:	SETF	;SINGLE PRECISION
		SETI	;SHORT INTEGER MODE
	JSR PC,SETPTR		; GETS ARRAY ADDRESSES INTO VERTA, RODA , CONTROL
	JSR PC,INITQ
	BEQ HACKR			; TOO MANY VERTICES TO PUT ON Q
	JSR PC,SIM
	SEZ
HACKR:	RTS PC

SETPTR:	JSR PC,GETARG	;THE ROD ARRAY
	MOV C,RODA	;SAVE POINTER TO 1ST ROD
	JSR PC,GETARG	;THE VERTEX ARRAY
	MOV C,VERTA	;PNTR TO 1ST VERTEX
	ASL A		;GET LENGTH OF VERTEX ARRAY IN BYTES
	ASL A
	MOV A,LVERTA
	JSR PC,GETARG	;THE CONTROL ARRAY, A IS LENGTH IN ENTRIES
;SET THE CONTROL VARIABLES HERE----
	MOV C,CONTRL	;PTR TO CONTROL ARRAY
	LDF ITER(C),FA
	STCFI FA,ITERA	;NUMBER OF ITERATIONS
	SUB #NCINF,A	;NUMBER OF SLOTS LEFT IN CONTROL ARRAY
	ASL A		;NUMBER OF WORDS
	MOV A,QLEN	;LEAVES THE LENGTH OF THE UPDATEQ IN WORDS
	ADD #4*NCINF,C	;C POINTS TO BEGINNING OF UPDATEQ
	MOV C,QA	;QA POINTS TO BEGINNING OF UPDATEQ
	RTS PC

;POP AN ARGUMENT WHICH IS AN ARRAY NAME
;CHECK THE TYPE AND POINT C AT THE FIRST DATA WORD
GETARG:	SPOPS	A
	JSR	PC,AMAKE5	;B NOW POINTS TO ARRAY HEADER
	MOV	B,C
	CMP	(C)+,(C)+
	CMP	(C)+,#FNUM!1	;TYPE=FLOATING   #DIMS=1
	BEQ	.+4
	ERROR+BAT
	CMP	(C)+,(C)+
	MOV	(C)+,A	;ARRAY SIZE
	CMP	(C)+,(C)+
	CMP	(C)+,(C)+	; C NOW POINTS TO 1ST DATA WORD
	RTS	PC


SIM:	TST ITERA		; ANY ITERATIONS LEFT?
	BLE SIMR		; THATS ALL
	DEC ITERA
	JSR PC,GETQ		; A POINTS TO NEXT Q ELEMENT, Z BIT SET IF MT
	BEQ SIMR		; NOTHING ON THE Q
	PUSH A		; PUSH CONTROL PTR
	JSR PC,UPDATE		; UPDATE NEXT Q ELEMENT
	POP A		; POP CONTROL PTR
	BR SIM			; AND LOOP
SIMR:	RTS PC


UPDATE:	TST A			; A IS A Q ELEMENT
	BGE UPD1		; SIGN BIT SAYS ROD OR VERTEX ITS A ROD
	JSR PC,UPVRT		; UPDATE A VERTEX
	BR UPDR			; AND STOP
UPD1:	JSR PC,UPROD		; UPDATE A ROD
UPDR:	RTS PC



UPROD:	MUL #LRENT,A			; A BECOMES ROD PTR
	ADD RODA,B
	MOV B,A
	SPUSH A		; PUSH ROD PTR
	JSR PC,CURLEN		; COMPUTE CURRENT LENGTH AND LEAVE IN FB
	SPOP A		; POP ROD PTR
	STF FB,FC
	SUBF CL(A),FC		; FIND DELTA LENGTH
	ABSF FC			; GET IT POSITIVE
	MOV CONTRL,C
	CMPF RODTL(C),FC		; SEE IF ITS MOVED LESS THAN NOTICEABLE
	CFCC
	BGE UPRODR		; IT HASNT MOVED STOP
	STF FB,CL(A)		; STORE CURRENT LENGTH
	SPUSH A		; POSH ROD PTR
	JSR PC,CSTRESS		; LEAVES STRESS IN FB
	SPOP A		; POP ROD PTR
	CMPF BRK(A),FB		; SEE IF IT HAS REACHED BREAKING STRESS
	CFCC
	BGT UPROD2		; ROD DIDNT BREAK

UPROD1:	CLRF SST(A)		; ROD BROKE ZERO THE STRESS
	CLRF CST(A)
	CLRF ELAS(A)		; AND ZERO THE ELASTICITY
	BR UPROD3

UPROD2:	JSR PC,STRESSV		; ROD IS OK COMPUTE NEW STRESS VECTOR

UPROD3:	LDF N1(A),FB		; PUT PTRS TO NEIGHBORNG VERTICES ON Q
	STCFI FB,B
	SIGNS B			; VERTEX PTRS HAVE TOP BIT SET
	LDF N2(A),FC
	STCFI FC,C
	SIGNS C
	PUSH A
	MOV B,A
	JSR PC,PUTQ
	MOV C,A
	JSR PC,PUTQ
	POP A
UPRODR: RTS PC



CURLEN: LDF N1(A),FB
	STCFI FB,B
	MUL #LVENT,B
	ADD VERTA,B
	LDF X(B),FA
	STF FA,X1
	LDF Y(B),FA
	STF FA,Y1
	LDF N2(A),FB
	STCFI FB,B
	MUL #LVENT,B
	ADD VERTA,B
	LDF X(B),FA
	STF FA,X2
	LDF Y(B),FA
	STF FA,Y2
	JSR PC,DIST		;LEAVES DIST BTWEEN X1 Y1 AND X2 Y2 IN FB
	RTS PC


DIST:	LDF X1,FA
	SUBF X2,FA
	MULF FA,FA
	LDF Y1,FB
	SUBF Y2,FB
	MULF FB,FB
	ADDF FA,FB
	JSR PC,SSQRT		; SQRT OF FB INTO FB
	RTS PC

CSTRESS: LDF CL(A),FB
	SUBF RL(A),FB
	MULF ELAS(A),FB
	DIVF RL(A),FB
	RTS PC


STRESSV: LDF X2,FA
	SUBF X1,FA
	MULF FB,FA
	DIVF CL(A),FA
	STF FA,SST(A)		; SINSTRESS GETS (X2 -X1) * STRESS / CLENGTH
	LDF Y2,FA
	SUBF Y1,FA
	MULF FB,FA
	DIVF CL(A),FA
	STF FA,CST(A)		; COSSTRESS GETS (Y2 - Y1) * STRESS / CLENGTH
	RTS PC
	


UPVRT:	SIGNC A			; VERTEX POINTER CAME WITH SIGN BIT SET
	MUL #LVENT,A		; A BECOMES VERTEX PTR
	ADD VERTA,B
	MOV B,A

NPOS:	CLRF FA			; COMPUTES NEW POSITION OF VERTEX
	CLRF FB			; CLEAR FLOATING REGISTERS FOR FORCE ACCUMULATION
	MOV A,B			; KEEP VERTEX PTR IN A


NPOS1: 	LDF RN0(B),FC		; C CONTAINS NEIGHBOR NUM, B POINTS TO NEXT NEIGHBOR
	CMP (B)+,(B)+		; B POINTS TO NEXT NEIGHBOR	
	STCFI FC,C
	CMP #-1,C
	BEQ NPOS2		; I GOT TO MY LAST NEIGHBOR
	MUL #LRENT,C			; C CONTAINS POINTER TO NEIGHBOR ROD
	ADD RODA,D
	MOV D,C
	LDF N1(C),FC		; D CONTAINS VERTEX NUM OF FIRST NEIGH OF ROD
	STCFI FC,D
	MUL #LVENT,D		; D CONTAINS POINTER TO VERTEX
	ADD VERTA,D
	CMP A,D			; SEE IF THAT VERTEX IS ME
	BEQ ADDFRC		; IF YES ADD FORCES
SUBFRC:	SUBF SST(C),FA		; I AM THE SECOND NEIGH OF ROD C, SUBTRACT X FORCE
	SUBF CST(C),FB		; SUBTRACT Y FORCE
	JMP NPOS1		; LOOP THRU NEIGHBOR RODS
ADDFRC:	ADDF SST(C),FA		; ADD X FORCE
	ADDF CST(C),FB		; ADD Y FORCE
	JMP NPOS1		; LOOP THRU NEIGHBOR RODS

NPOS2:	ADDF CSIN(A),FA		; ADD IN CONSTANT X FORCE
	ADDF CCOS(A),FB		; ADD IN CONSTANT Y FORCE
	LDF RSIN(A),FC		; GET INTEGER OF RESTRAINT SIN
	STCFI FC,D
	CMP D,#3
	BEQ UPVRT1		; I AM NAILED DOWN. GO Q NEIGHBORS THATS ALL
	CMP D,#2
	BEQ NPOSNR		; NO RESTRAINT 
	STF FA,FC		; RESTRAINED SO COMPUTE THE DOT PRODUCT OF
	STF FB,FD		; RESTRAINT AND FORCE
	MULF RSIN(A),FC
	MULF RCOS(A),FD
	ADDF FD,FC		; ANSWER IN FC
	MULF FC,FA		; RESTRAIN THE X FORCE
	MULF FD,FB		; RESTRAIN THE Y FORCE

NPOSNR:	MOV CONTRL,C
	MULF SCALE(C),FA		; MULTIPLY X FORCE BY SCALE TO GET DISTANCE TO MOVE
	MULF SCALE(C),FB		; ALSO Y FORCE
	CLRF FC			; PUT FLOATING ZEROS IN X1 X2
	STF FC,X1
	STF FC,Y1
	STF FA,X2		; PUT DISTANCES IN X2 Y2
	STF FB,Y2	
	JSR PC,DIST		; LEAVES MAGNITUDE OF DISTANCE TO MOVE IN FB
	MOV CONTRL,C
	CMPF EPSIL(C),FB		; SEE IF WE HAVENT MOVED MUCH
	CFCC
	BGE UPVRTR		; NO MOTION, WE ARE DONE
	LDF X(A),FC		; OTHERWISE UPDATE THE X AND Y POSITIONS AND Q NEIGHS
	LDF Y(A),FD		; OLD X AND Y IN FC AND FD
	LDF X2,FA		; DELTA X AND Y IN FA  AND FB
	LDF Y2,FB
	ADDF FA,FC		; NEW X AND Y IN FC AND FD
	ADDF FB,FD
	STF FC,X(A)		; UPDATE X AND Y
	STF FD,Y(A)

UPVRT1:	JSR PC,PUTN		; PUT THE NEIGHBORS ON THE Q
UPVRTR: RTS PC

SSQRT:	TSTF FB
	CFCC
	BEQ SQRTR
	LDF FB,FC
	STEXP FB,D
	LDEXP #0,FB
	ASR D
	ADC D
	ADDF #40000,FB
	BCS .+6
	ADDF #40000,FB
	CLRF FD  
	LDEXP D,FD
	MULF FD,FB
	MOV #4,D
SSQRLP:	LDF FC,FD	;FD <= X
	DIVF FB,FD	;FD <= X/Y
	ADDF FD,FB	;FB <= Y + X/Y
	MULF #40000,FB	;FB <= 1/2 * (Y + X/Y)
	SOB D,SSQRLP
SQRTR:	RTS PC

;STUFF FOR THE UPDATEQ RING BUFFER
;THE START OF THE FIXED ARRAY IS IN QA

INITQ:	CLR QPTR		; QPTR IS WHERE OBJECTS GET ON THE Q
	MOV #-1,UPQPTR		; WHERE WE LOOK FOR WHO TO UPDATE
FORCQ:	CLR A			; A CONTAINS VERTEX NUMBERS
FORCQL:	MOV A,B			; B WILL GET THE VERTEX PTR
	MUL #LVENT,B		; DISTANCE INTO VERTEX ARAY
	CMP B,LVERTA		; SEE IF WE'VE FALLEN OFF THE END OF THE VERTEX ARRAY
	BGT FORCQR		; IF SO WE'RE DONE
	ADD VERTA,B		; GENUIINE POINTER NOW
	LDF CSIN(B),FA		; SEE IF THE CONSTANTFORCE IS ZERO
	TSTF FA			; LOOK AT THE SIN FIRST
	CFCC
	BNE FORCQ1		; GO Q THE VERTEX
	LDF CCOS(B),FA		; CHECK THE COSINE, MAYBE ITS NOT 0
	TSTF FA
	CFCC
	BEQ FORCQD		; THIS VERTEX HAS NO CONSTANT FORCE
FORCQ1:	PUSH A
	SIGNS A			; VERTICES ARE NEGATIVE SIGN MAGNITUDE NUMS ON THE Q
	JSR PC,PUTQ
	POP A
	CLR UPQPTR		;SO THAT WE START PROCESSING AT THE BEGINNING OF THE Q
FORCQD:	INC A			; GET NEXT VERTEX NUM
	BR FORCQL		; LOOP THRU ALL VERTICES
FORCQR:	RTS PC


; PUTQ TAKES ARG IN A PUTS IT ON UPDATEQ


PUTQ:	CMP QPTR,#QLEN		; SEE IF QPTR HAS FALLEN OFF THE END OF THE ARRAY
	BMI PUTQ1		; IT IS OK
	CLR QPTR		; IT FELL OFF, SET IT TO THE BEGINNING
PUTQ1:	CMP QPTR,UPQPTR		; SEE IF WE'RE ABOUT TO WRITE OVER THE UPQPTR
	BEQ PUTQL		; TOO BAD, NO MORE RROM IN Q
	MOV QPTR,B
	ADD QA,B		; B IS NOW THE ADDRESS IN ARRAY
	MOV A,@B		; PUT THE OBJECT NUM ON THE Q
	ADD #2,QPTR		; MOVE PTR ALONG
	CLZ			; WE MANAGED TO PUT SOMEONE ON THE Q
	BR PUTQR		; DONE
PUTQL:	ERROR+RTB	;GENERATE "RESULT TOO BIG" ERROR

PUTQR:	RTS PC

GETQ:	CMP UPQPTR,#QLEN	; SEE IF UPQPTR HAS FALLEN OFF END OF BUFFER
	BMI GETQ1		
	CLR UPQPTR		; IT FELL OFF
GETQ1:	CMP UPQPTR,QPTR		; SEE IF Q IS MT
	BEQ GETQL		; LOST BECAUSE Q WAS MT
	MOV UPQPTR,B
	ADD QA,B		; ADDRESS OF OBJECT NUM IN B
	MOV @B,A		; READ OBJECT NUM INTO A
	ADD #2,UPQPTR		; MOVE POINTER ALONG
	CLZ			; WE DID GET SOMEONE OFF THE Q
	BR GETQR
GETQL:	SEZ			; WE LOST BECAUSE THE Q WAS MT
GETQR:	RTS PC

; PUTS NEIGHBORS OF VERTEX POINTED TO BY A ON Q

PUTN:	LDF RN0(A),FA		; PTR TO A NEIGHBOR ENTRY
	CMP (A)+,(A)+		; A POINTS TO NEXT NEIGHBOR ENTRY
	STCFI FA,B		; INTEGERIZE TO GET NEIGHBOR NUM
	CMP #-1,B		; SEE IF WE HAVE GOTTEN TO LAST NEIGHBOR
	BEQ PUTNR
	PUSH A			
	MOV B,A			; SUBR WANTS ARG IN A
	JSR PC,PUTQ
	POP A
	BR PUTN			; LOOP THRU ALL NEIGHBORS

PUTNR: RTS PC

	
.ENDC
