.STITL SYSTEM PRIMITIVES
	VERN==VERN+%FNAM2

;SINGLE PRECISION ARITHMETIC ROUTINES

UPLUS:	JMP ORT	;UNARY PLUS - NOTHING TO DO
UMINS:	JSR PC,G1IARG	;UNARY MINUS
	DPNEG	B,C
DONBC:	JMP	R1I.BC

SUM:
	EXCH (P),2(P)
	CLR	E
	CLR	F
	MOV	(SP)+,D	;NUMBER OF ARGS
	BLE	DIFF.2	;DONE
SUM.1:	JSR	PC,G1IARG	;GET 1 INTEGER
	DPADD	B,C,E,F
	DEC	D	;COUNTER
	BGT	SUM.1
	BR	DIFF.2	;DONE

DIFF:
	JSR	PC,G2IARG	;GET 2 INTEGERS
	DPSUB	B,C,E,F
DIFF.2:	CMP	E,#100000	;IS ANSWER = 100...00 ?
	BNE	DONEMP
	TST	F	;IF SO , THEN ERROR
	BNE	DONEMP
	ERROR+RTB	;SINCE THAT IS SMALLEST NEG NUMBER
DONEMP:	JMP	R1I.EF

PROD:
	EXCH (P),2(P)
	CLR	E
	MOV	#1,F
	MOV	(SP)+,D	;NUMBER OF ARGS
PROD.1:	DEC	D
	BLT	DONEMP	;DONE
	JSR	PC,G1IARG	;GET ONE ARG IN B
	JSR	PC,.DPMUL
	ERROR+RTB	;RESULT TOO BIG
	BR	PROD.1

MOD:
	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	ERROR+RTB
	BR	DONBC

DIVDE:
DIV.1:	JSR	PC,G2IARG
	JSR	PC,.DPDIV
	ERROR+RTB
	BR	DONEMP


SENTENCE:
	EXCH (P),2(P)
	MOV	(SP),D	;# OF ARGS . DON'T CHANGE FROM D WITHOUT CHANGING SNAP!!!!
	MOV	#ORT,(SP)	;RETURN ADDRESS
SENT.:	CLR	C
	TST	D
SENT.1:	BLE	SENT.R	;RETURN
	MOV	@S,B	;ARGUMENT.  LEAVE ON S-PDL FOR GARBGE COLLECTOR
	MOV	B,A
	BIC	#7777,A	;LEAVE ONLY DATA TYPE
	CMP	#LIST,A
	BEQ	SENT.S	;ARG IS LIST
	CMP	#ATOM,A
	BNE	SENT.2	;ARG IS LSTR OR INUM

;ARG IS AN ATOM
SENT.A:	JSR	PC,.LOAD	;CONVERT ATOM TO LSTR
	MOV	#LSTR,A

SENT.2:	BIS	C,A	;C POINTS TO PREVIOUS STUFF OF SENTENCE
	JSR	PC,GRBAD

SENT.3:	MOV	C,GCPREV	;POINTER TO PREVIOUS STUFF OF SENTENCE
	BIS	#LIST,GCPREV	;GARBAGE COLLECTOR NEEDS RIGHT DATA TYPE
SENT.4:	JSR	PC,SPOPT	;POP S
	DEC	D	;COUNTER
	BR	SENT.1

SENT.S:	BIT	#7777,B	;ARGUMENT IS A LIST
	BEQ	SENT.4	;EMPTY
	TST	C	;0 IF FIRST TIME CALLED
	BEQ	SENS.1	;NO NEED TO COPY
;SECOND OR LATER TIME THROUGH
SENS.2:	JSR	PC,COPYL	;COPY LIST. RETURN POINTER IN B
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;C STILL POINTS TO LAST NODE COPIED
SENS.1:	BIC	#170000,B	;LEAVE POINTER ONLY
	MOV	B,C
	BR	SENT.3

;RETURN.  POINTER TO SENTENCE IN C
SENT.R:	BIS	#LIST,C
	CLR	GCPREV
	PUSHS	C
	RTS	PC



LIST.P:
	EXCH (P),2(P)
	MOV	(SP),D	;COUNT
	MOV	#ORTC,(SP)	;RETURN ADDRESS
LIST1:	CLR	C
LIST.1:	DEC	D	;COUNT
	BLT	LIST.9	;DONE
	MOV	@S,B
	MOV	B,A
	BIC	#7777,A	;LEAVE DATA TYPE ONLY
LIST.2:	BIS	C,A	;POINTER TO REST OF LIST
	JSR	PC,GRBAD
	MOV	C,GCPREV	;PROTECT FROM GARBAGE COLLECTOR
	BIS	#LIST,GCPREV	;GAR. COLL. NEEDS RIGHT DATA TYPE
	JSR	PC,SPOPT
	BR	LIST.1	;GET NEXT ARG

LIST.9:	CLR	GCPREV
	BIS	#LIST,C
	RTS	PC


FPUT:
	CLR	F
	BR	.+6
LPUT:
	MOV	#<LPUT1-FPUT1>,F
	EXCH (P),2(P)
	MOV	(SP),D	;NUMBER OF ARGS
	MOV	#ORTC,(SP)	;RETURN ADDRESS
	DEC	D
	BGT	.+4
	ERROR+UEL	;NEED AT LEAST 2 ARGS
	JSR	PC,GLWARG
	BR	.+4	;LIST
	ERROR+WTA	;FIRST ARG MUST BE LIST
	ADD	F,PC	;CHOOSE BETWEEN LPUT AND FPUT

FPUT1:	MOV	B,A	;POINTS TO ARG
	BIC	#170000,A	;CLEAR DATA TYPE
	JSR	PC,SPOPT
	MOV	@S,B	;FIRST ELEMENT TO BE PUT
	MOV	B,C
	BIC	#7777,C	;THIS DATA TYPE WILL BE SET INTO A
	DEC	D
	BR	LIST.2

LPUT1:	JSR	PC,COPYL	;COPY LIST. RETURN PTR IN B
	MOV	B,GCP1
	JSR	PC,SPOPT	;POP 1ST ARG
	JSR	PC,LIST1	;LIST REST OF ARGS
	TST F
	BEQ LPUT2
	BIC	#170000,C	;POINTER TO THAT LIST
	MOV	C,D	;SAVE IT
	MOV	F,C	;POINTER TO LAST NODE OF COPIED LIST
	JSR	PC,.LDP1
	BIS	D,A	;JOIN COPIED LIST TO LIST OF ARGS
	JSR	PC,.STP1
	MOV	GCP1,C
LPUT2:	CLR	GCP1
	RTS	PC


WORD:
	EXCH (P),2(P)
	CLR	C
	MOV	(SP)+,D	;NUMBER OF ARGS
WORD.1:	BLE	WORDR
	MOV	@S,B	;GET ARG,  BUT LEAVE ON STACK
	CMP	B,#LNUM	;IS ARG NUMBER?
	BLO	WORD.2
	CMP	B,#<LNUM+10000>
	BLO	WORD.N	;NUMBER
WORD.2:	MOV	#LSTR,A
	JSR	PC,CONVERT
	ERROR+WTAB
	BIT	#7777,B	;IS ARG THE EMPTY WORD
	BEQ	WORD.4	;YES

	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3

;SECOND OR LATER ARG
WORD.5:	JSR	PC,CPYSTR	;COPY STRING
WORD.6:	JSR	PC,.LDP1	;LAST NODE OF COPIED STRING
	BIC	#170000,GCPREV	;CLEAR DATA TYPE
	BIS	GCPREV,A	;BIS POINTER TO PREVIOUS STUFF
	JSR	PC,.STP1	;STORE BACK

WORD.3:	BIC	#170000,B
	BIS	#LSTR,B	;GAR. COLL. NEEDS RIGHT DATA TYPE
	MOV	B,GCPREV	;POINTER TO PREVIOUS STUFF
WORD.4:	JSR	PC,SPOPT	;POP S
	DEC	D
	BR	WORD.1

;ARGUMENT IS NUMBER. CONVERT TO STRING
WORD.N:	JSR	PC,.CINLS
	ERROR+WTAB	;PROBABLY MORE THAN 16 BITS
	TST	GCPREV	;IS 0 FIRST TIME THROUGH
	BEQ	WORD.3	;IS FIRST ARG
	BR	WORD.6	;SECOND OR LATER, BUT DON'T RECOPY!!

;RETURN
WORDR:	MOV	GCPREV,C
	BIS	#LSTR,C
	CLR	GCPREV
	JMP	ORTC


FIRST:
	JSR	PC,GLWANE
	BR	F.SENT	;ARG IS SENTENCE

;ARG IS WORD
	JSR	PC,INSTR	;RETURN ONE CHAR IN D
	BNE	.+4	;FOUND A CHAR
F.WTA:	ERROR+WTA	;NO CHARS IN STRING
	TST	(SP)+	;POP OFF CO-ROUTINE LINK
	MOV	D,B
F.STOR:	CLR	F
	JSR	PC,ACTSTO	;STORE THE CHAR.
	POPS C
	BIC #170000,C
	BIS	#LSTR,C	;POINTER TO THE NODE OF THE CHAR
	JMP	ORTNC

F.SENT:	MOV	B,C
	JSR	PC,.LDP2
	JMP	ORTNA


BUTFIRST:
	JSR	PC,GLWANE
	BR	BF.SEN

;ARG IS WORD
BF.W:	JSR	PC,INSTR	;RETURN ONE CHAR
	BEQ	F.WTA	;NO CHARS IN STRING
	TST	(SP)+
;A CONTAINS FIRST 2 CHARS OF THE STRING
;BUT IT MAY ONLY HAVE ONE.
	BIT	#177,A	;IS TOP CHAR OF A 0?
	BEQ BF.W1
	BIT #77400,A
	BEQ	BF.W1	;YES. ONLY ONE CHAR IN A
	CLRB	A	;KILL THE FIRST CHAR
	MOV	A,B
	MOV	C,A	;POINTER TO REST
	JSR	PC,GRBAD
BF.W1:	BIC	#170000,C
	BIS	#LSTR,C
	JMP	ORTNC

;ARG IS SENTENCE
BF.SEN:	MOV	B,C
	JSR	PC,.LDP1	;POINTER TO REST OF SENTENCE
	BIC	#170000,A	;LEAVE ONLY POINTER
	BIS	#SENT,A
	JMP	ORTNA


LAST:
	JSR	PC,GLWANE
	BR	L.SENT	;ARG IS SENTENCE

;ARG IS WORD
	MOV	B,C
	SPUSH	#INSTR1	;ADDRESS OF CO-ROUTINE
	CLR	D
L.W1:	MOV	D,B	;SAVE LAST CHAR
	JSR	PC,@(SP)+	;RETURNS CHAR IN D
	BNE	L.W1	;FOUND ONE
	TST	B	;STRING DONE
	BNE	F.STOR	;STORE THE CHAR AND RETURN
	ERROR+WTA	;NO CHARS FOUND

L.SEN1:	MOV	A,B
;ARG IS SENTENCE
L.SENT:	JSR	PC,.LOAD
	BIT	#7777,A	;LAST NODE OF SENTENCE YET?
	BNE	L.SEN1

L.SRET:	JMP	ORTNB


BUTLAST:
	JSR	PC,GLWANE
	BR	BL.SEN	;ARG IS A SENTENCE

;ARG IS A WORD
	JSR	PC,CPYSTR	;COPY STRING.
	JSR	PC,.LDP2	;LAST NODE OF NEW STRING
	SWAB	A
	BNE	BL.W2	;THE LAST CHARACTER IS REALLY THERE
	CLR	A	;(WE KNOW THE FIST CHAR IS REALLY THERE)
	CMP	B,C	;IS THERE ONLY ONE NODE
	BNE	BL.W1	;MORE TAN ONE NODE
	CLR	B	;ANSWER IS EMPTY WORD
	BR	BL.W3

BL.W2:	CLRB	A	;CLEAR LAST CHAR
BL.W1:	JSR	PC,.STP2	;STORE NODE BACK
BL.W3:	BIS	#LSTR,B	;POINTER TO THE WORD
BL.ORT:	JMP	ORTNB

;ARG IS A SENTENCE
BL.SEN:	JSR	PC,COPYL	;COPY LIST
	MOV	E,C	;POINTS TO NEXT TO LAST NODE
	BEQ	BL.SR	;ANSWER IS EMPTY
	JSR	PC,.LDP1
	BIC	#7777,A
	JSR	PC,.STP1
	MOV	B,C
BL.SR:	BIS	#LIST,C
	JMP	ORTNC


COUNT:
	JSR	PC,GLWARG
	BR	CT.SEN

;ARG IS WORD
	MOV	B,C
	CLR	B
	MOV	#INSTR1,-(SP)	;ADDRESS OF A CO-ROUTINE
CT.W1:	INC	B	;INCREMENT COUNTER
	JSR	PC,@(SP)+	;RETURNS CHAR IN B
	BNE	CT.W1
	DEC	B	;WHEN RETURNS HERE, NO MORE CHARS
CT.ORT:	POPS C
	JMP R1NARG	;C IS A THROW-AWAY

;ARG WAS A SENTENCE
CT.SEN:	MOV	B,C
	JSR	PC,CLE	;RETURNS NUMBER OF LIST ELEMENTS IN B
	BR	CT.ORT


;COPY LIST.
;	CALL WITH B POINTING TO LIST
;	RETURNS B POIOTING TO NEW LIST, C POINTING TO LAST NODE
COPYL:	CLR	E	;WILL POINT TO 2ND NODE FROM LAST
	CLR	F
	BIT #7777,B
	BEQ COPYR1
COPYL1:	BIT	#7777,B
	BEQ	COPYLR	;DONE
	JSR	PC,.LOAD
	MOV	F,E	;LISTB PLACES  LAST NODE PTR INTO F
	JSR	PC,LISTB
	MOV	A,B
	BR	COPYL1

COPYLR:	MOV F,C	;LISTB KEEPS PTR TO LAST NODE OF LIST IN F
	POPS	B	;LISTB KEEPS POINTER TO NEW LIST ON S.
COPYR1:	RTS	PC


;COPY STRING
;CALL WITH B POINTING TO STRING TO BE COPIED,
;ASSUMES THAT INPUT STRING HAS BEEN GARBAGE COLLECT PROTECTED ALREAEDY
;B POINTS TO FIRST NODE OF NEW STRING,  C POINTS TO LAST

CPYSTR:	MOV	#INSTR,A
MAKSTR:	MOV	D,-(SP)
	MOV	E,-(SP)
	MOV	F,-(SP)

	MOV	A,-(SP)	;ADDRESS OF INPUT STRING ROUTINE
	CLR	F

OUTSTR:	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE1	;INPUT STRING DONE

OSTR1:	MOV	D,B	;SAVE CHARACTER
	JSR	PC,@(SP)+	;CALL INPUT STRING CO-ROUTINE
	BEQ	OSTRE2	;INPUT STRING DONE

OSTR2:	SPUSH	A	;SAVE REGISTERS USED BY INPUT STRING
	SWAB	D
	BIS	D,B	;BIS SECOND CHARACTER
	JSR	PC,ACTSTO	;ACTUAL STORE
	SPOP	A
	BR	OUTSTR

;INPUT STRING HAS ENDED
OSTRE2:	JSR	PC,ACTSTO	;STORE CHAR IN B
OSTRE1:	POPS	B	;POINTER TO FIRST NODE OF STRING
	MOV	F,C	;POINTER TO LAST NODE
	BIC	#170000,B
	BIC	#170000,C
.RDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
OSTRR:	RTS	PC


;ACTUALLY STORE OUTPUT NODE
ACTSTO:	MOV	#SSTR,A
	JMP	LISTB


;INPUT STRING
;A CO-ROUTINE THAT HANDS BACK A CHARACTER IN BOTTOM BYTE OF D
;DOES RTS PC WHEN INPUT STRING FINISHED

INSTR:	MOV	B,C
INSTR1:	BIT	#7777,C
	BEQ	OSTRR	;RTS PC
	JSR	PC,.LDP2I
	MOVB	A,D
	BIC	#177600,D	;CLEAR TOP BYTE
	BEQ	INSTR2	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE

INSTR2:	CLRB A
	SWAB	A
	MOV	A,D
	BIC #177600,D
	BEQ	INSTR1	;NULL CHAR
	JSR	PC,@(SP)+	;RETURN TO CO-ROUTINE
	BR	INSTR1

MAKE:	BIC #MMF,FLAGS2
	BR .+10
MMAKE:	BIS #MMF,FLAGS2
	POPS TOPS	;PUT VALUE INTO TOPS
	MOV @S,B
	MOV B,A
	BIC #7777,A
	CMP #ATOM,A	;IS TYPE ATOM?
	BNE MAKE2
MAKE4:	MOV #VBIND,A	;YES< SET VARIABLE BINDING?
	JSR PC,.BIND
	BIT #MMF,FLAGS2	;IS IT MULTIPLE MAKE?
	BEQ MAKE1
	MOV TOPS,@S
	CLR TOPS
	CLR TOPS1
	JMP ORT
MAKE1:	POPS A
	CLR TOPS
	CLR TOPS1
	RTS PC
MAKE2:	CMP #LSTR,A
	BEQ MAKE3
MAKE5:	ERROR+WTAB	;WRONG TYPE OF ARG
MAKE3:	BIT #7777,B
	BEQ MAKE5
	MOV TOPS,@S
	MOV B,TOPS	;FOR .INTRN
	JSR PC,UINTRN	;.INTRN FOR STRINGS THAT MAY INCLUDE NULL CHARS
	BR .+2
	MOV @S,TOPS
	BIS #ATOM,B
	MOV B,TOPS1
	BR MAKE4

DOTS:	JSR PC,GETVAL	;GET VALUE IF IT HAS ONE
	ERROR+HNV	;HAS NO VALUE
	PUSHS B
	CLR TOPS
	JMP ORT

THINGP:	JSR PC,GETVAL	;DOES IT HAVE A VALUE?
	BR THNGPF	;NO
	MOV #TRUE,B	;YES
THNGPX:	JMP ORTB
THNGPF:	MOV #FALSE,B
	BR THNGPX

GETVAL:	JSR PC,GUOEB	;GET UOE PTR FROM S INTO B
	RTS PC		;HAS NO VALUE
	JSR PC,.BNDVN
	RTS PC		;HAS NO VALUE
	TST B
	BNE .+4
	RTS PC		;HAS NO VALUE (UNBOUND LOCAL)
	SKPRET		;RETURN ITS VALUE
GUOEB:	POPS B	;GET UOE OR LSTR IN B FROM S
	MOV B,A	;    SKIP IF UOE
	BIC #7777,A
	CMP #ATOM,A
	BEQ GUOE1
	CMP #LSTR,A
	BEQ GUOE2
	ERROR+WTAB	;.(B). ISWRONG TYPE OF ARG
GUOE2:	MOV B,TOPS
	JSR PC,UOBSCH	;.OBSCH FOR STRINGS THAT HAVE NULL CHARS
	RTS PC	;NOT THERE
GUOE1:	JMP SRET
		;PRINT TOP (C) THINGS ON S
FPRINT:	INC NBKTS	;PRINTS OUTER [,]'S
PRINT:	EXCH (P),2(P)
	JSR	PC,REVS	;DOESNT "
	POP	C
	JSR	PC,TYPE1
	JSR	PC,.CRLF
	RTS PC

TYPE:	EXCH (P),2(P)
	JSR	PC,REVS
	POP	C
	JSR	PC,TYPE1	;PRINT WITHOUT CRLF AT END
	RTS PC

TYPE1:	BIS #DPQF+CPTBF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
			;BUT DO  PRINT % AS BLANK
	JSR PC,PRS1
	POPS A
	DEC C
	BGT	TYPE1
	BIC #DPQF+CPTBF,FLAGS2
	RTS	PC

;PREDICATES

EQUAL:	MOV	S,F
	MOV	(F)+,B	;ARG1.  LEAVE ON STACK FOR GC PROTECTION
	MOV	(F),C	;ARG2
	JSR	PC,EQUAL1
	BR	EQ.F	;RETURNS HERE IF FALSE
	MOV	#TRUE,B
	BR	EQ.RET

EQ.F:	MOV	#FALSE,B
EQ.RET:	ADD	#2,S
	JMP	ORTNB


;COMPARE THE DATA ITEM POINTED TO BY B WITH
;THE DATA ITEM POINTED TO BY C.
;SKIP IF THEY ARE EQUAL
EQUAL1:	MOV #7777,E	;AN OFT-USED CONSTANT
	MOV B,A
	MOV C,D
	BIC E,A
	BIC E,D
	CMP A,D
	BNE WEQUAL
	CMP #LIST,A
	BNE WEQUAL
EQ.LST:	BIC #170000,B
	BIC #170000,C
	CMP B,C
	BEQ EQTRUE
	TST B
	BEQ EQFALS
	TST C
	BEQ EQFALS
	JSR PC,.LOAD
	PUSH A
	JSR PC,.LDP2I
	SPUSH C
	MOV A,C
	JSR PC,EQUAL1
	BR EQ.FF
	POP B
	SPOP C
	BR EQ.LST

	FOR 0
EQUAL1:	CMP	B,C	;ARE THE POINTERS THE SAME
	BEQ	EQTRUE
	MOV	B,A
	JSR	PC,EQ.SUB	;IS ARG1 A WORD?
	BNE	EQ.W1	;A WORD
	JSR	PC,EQ.SB1	;IS ARG2 A WORD?
	BNE	EQFALS	;ARG1 ISN'T WORD, BUT ARG2 IS.
;BOTH ARGS ARE LISTS
EQ.LST:	JSR	PC,.LOAD	;FIRST NODE OF ARG1
	PUSH	A	;SAVE POINTER TO BF
	JSR	PC,.LDP2I	;FIRST NODE OF ARG2
	SPUSH	C	;SAVE POINTER TO BF
	MOV	A,C	;POINTER TO FIRST OF ARG1
;B POINTS TO FIRST ARG2.  C POINTS TO FIRST ARG1.
	JSR	PC,EQUAL1	;ARE THE FIRSTS EQUAL?
	BR	EQ.FF	;NO.  RETURN FALSE
	POP	B	;POINTER TO BF
	SPOP	C	;POINTER TO BF OF OTHER ARG
	BIC	#170000,B
	BIC	#170000,C
	CMP	B,C
	BEQ	EQTRUE
	JSR	PC,EQ.LST	;ARE THE BF'S EQUAL?
EQFALS:	RTS	PC	;NO
EQTRUE:	SKPRET	;YES


EQ.SB1:	MOV	C,A	;IS ARG A WORD?
EQ.SUB:	BIT	E,A	;EMPTY?
	BEQ	EQFALS	;ONE ARG FINISHED
	BIC	E,A
	CMP	#SENT,A
	RTS	PC

;ARG1 IS A WORD
EQ.W1:	JSR	PC,EQ.SB1	;IS ARG2 A WORD?
	BEQ	EQFALS	;NOT A WORD
;FALLS INTO WEQUAL
	.ENDC
	ENDC 0
EQ.FF:	CMP	(SP)+,(SP)+	;POP OFF THE POINTERS TO THE BF'S
	JMP	PPOPT	;DON'T OVERPOP!

;COMPARE TWO WORDS

WEQUAL:	MOV	#INUM,A
	JSR	PC,CONVERT	;TRY CONVERTING ARG TO INUM
	BR	EQ.STR	;NOT NUMERIC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG
	BR	EQFALS	;NOT NUMERIC
	JSR	PC,.LOAD	;A,,B HAVE NUMBER
	MOV	A,D
	MOV	B,F
	JSR	PC,.LOADC
	CMP	A,D	;COMPARE 2 INTEGERS
	BNE	EQFALS
	CMP	B,F
	BNE	EQFALS
	BR	EQTRUE

;ARG NOT NUMERIC.  TRY STRING COMPARE
EQ.STR:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BR EQFALS	;EQUAL NOT DEFINED FOR SNAPS, ETC
	EXCH	B,C
	JSR	PC,CONVERT	;TRY CONVERTING 2ND ARG, TOO
	BR	EQFALS	;NOT SAME TYPE AS FIRST ARG
	CMP	B,C
	BEQ	EQTRUE

;COMPARE TWO STRINGS.  POINTERS IN B AND C.
	MOV	B,GCP1
	MOV	C,GCP2
	SPUSH	#INSTR1
	MOV	B,F
CMPST1:	BIT	E,F	;IS ARG 1 ENDED
	BEQ	CMPSTE	;YES
	SPUSH	A	;SAVE A
	MOV	F,B	;POINTER TO REST OF ARG1
	JSR	PC,.LOAD
	MOV	A,F	;POINTER TO REST OF ARG1
	SPOP	A	;RESTORE A
	BICB #200,B	;IS CHAR REAL OR NULL?
	BEQ	CMPST2	;NULL
	JSR	PC,@(SP)+	;PUTS 1 CHAR OF ARG 2 INTO B
	BEQ	CSFAL1	;ARG 2 ENDED
	CMPB	D,B	;COMPARE CHARS!!
	BNE	CSFALS
CMPST2:	SWAB	B
	BIC #177600,B
	BEQ	CMPST1	;NULL CHAR
	JSR	PC,@(SP)+	;1 CHAR OF ARG 2 IN B
	BEQ	CSFAL1
	CMPB	D,B	;COMPARE CHARS!!
	BEQ	CMPST1
CSFALS:	TST	(SP)+	;POP CO-ROUTINE LINKAGE
CSFAL1:	CLR	GCP1
	CLR	GCP2
EQFALS:	RTS PC

;ARG 1 HAS ENDED
CMPSTE:	JSR	PC,@(SP)+
	BNE	CSFALS	;BUT ARG 2 HASN'T ENDED
	CLR	GCP1
	CLR	GCP2
EQTRUE:	SKPRET	;BOTH ENDED AT THE SAME TIME!!!!

;MORE PREDICATES

GREATR:	JSR PC,CMP2IA
	BGT RTTRUE
RTFALS:	PUSHS #FALSE
RTNCMP:	JMP ORT

LESSP:
LESS:	JSR PC,CMP2IA
	BGE RTFALS
RTTRUE:	PUSHS #TRUE
	BR RTNCMP

GREQ:	JSR PC,CMP2IA
	BGE RTTRUE
	BR RTFALS

LSEQ:	JSR PC,CMP2IA
	BLE RTTRUE
	BR RTFALS

NUMBP:	POPS B
	MOV	#LNUM,A
	JSR	PC,CONVERT
	BR	RTFALS	;COULDN'T CONVERT IT
	BR	RTTRUE

EMPTYP:	POPS B
	BIT	#7777,B
	BEQ	RTTRUE
	BR	RTFALS

LISTP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTTRUE
	BR	RTFALS

WORDP:	POPS B
	BIC	#7777,B
	CMP	#SENT,B
	BEQ	RTFALS
	BR	RTTRUE

;COMPARE TWO INTEGER ARGUMENTS
CMP2IA:	JSR	PC,G2IARG
;COMPARE 2 INTEGERS IN B,,C & E,,F
CMP2I:	CMP	E,B
	BNE	CMP2IR	;CONDITION CODES SET CORRECTLY
	CMP	F,C
	BEQ	CMP2IR
	BHI	CMP2IH
;E,,F < B,,C
	CMP	#0,(PC)
	RTS	PC
CMP2IH:	TST	(PC)
CMP2IR:	RTS	PC


NOT:	JSR	PC,TSTST	;TEST S SKIP IF TRUE
	BR	RTTRUE
	BR	RTFALS

RFPOP:	JSR	PC,SPOPT
	BR	RTFALS

BOTH:	JSR	PC,TSTST
	BR	RFPOP	;FALSE
EITH1:	JSR	PC,TSTST
	BR	RTFALS
	BR	RTTRUE	;BOTH ARE "TRUE !!

EITHER:	JSR	PC,TSTST
	BR	EITH1	;IS 2ND ONE "TRUE?
	JSR	PC,SPOPT	;POP 2ND ARG
	BR	RTTRUE
TEST:	JSR PC,TSTST	;IS TOP OF S "TRUE"?
	BR TES1	;NO, CLEAR FLAG
	BIS #TSTFLG,FLAGS	;YES, SET FLAG
	BR IFR
TES1:	BIC #TSTFLG,FLAGS
	BR IFR
IFTRUE:	BIT #TSTFLG,FLAGS	;FLAG SET?
	BNE IFR	;YES, CONTINUE
IFT1:	CLR CT	;NO, MAKE GNT THINK LINE HAS ENDED
	CLR CT+2
	RTS PC
IFFALS:	BIT #TSTFLG,FLAGS	;FLAG CLEARED?
	BEQ IFR	;YES, CONTINUE
	BR IFT1	;NO STOP
IF:	INC IFLEV
	JSR PC,TSTST	;TEST S, SKIP IF "TRUE"
	BR .+4
	BR IFR
	CLR NOPAR
	JSR PC,STNE
	BR IFR
	BIC #RTF,FLAGS
	DEC IFLEV
IFR:	RTS PC
THEN:	TST IFLEV
	BGT IFR
	ERROR+OOP	;THEN OUT OF PLACE
	BR IFR
ELSE:	DEC IFLEV
	BGE .+4
ELSE1:	ERROR+OOP	;ELSE OUT OF PLACE
	CLR NOPAR
	JSR PC,STNE
	BR IFR
	TST IFLEV
	BLE ELSE1
	BR IFR
STNE:	;SCAN TOO NEXT ELSE, CR OR UNMATCHED );
	;  SET RTF.  SKIP IIF "ELSE"
	JSR PC,GNT
	CMP #$RPAR,B
	BNE STNE4
	DEC NOPAR
	BGE STNE
	BIS #RTF,FLAGS
	RTS PC
STNE4:	CMP #$LPAR,B
	BNE STNE5
	INC NOPAR
	BR STNE
STNE5:	TST NOPAR
	BGT STNE
	CMP #$ELSE,B
	BNE STNE1
	BIS #RTF,FLAGS	;IF "ELSE", SET RTF AND SKIP RETURN
	JMP SRET
STNE1:	BIT #CRF,FLAGS
	BEQ STNE2
STNE3:	BIS #RTF,FLAGS	;IF "CR" SET RTF AND RETURN
	BIC #CRF,FLAGS
	RTS PC
STNE2:	CMP #$IF,CT+2	;IF "IF", LOOK FOR NEXT ELSE!
	BNE STNE
	JSR PC,STNE
	BR STNE3
	BIC #RTF,FLAGS
	BR STNE
TSTST:	MOV	@S,B		;TEST S, SKIP IF TRUE
	CMP	B,#FALSE
	BEQ	TSTF9	;IT'S "FALSE
	MOV	#TRUE,C	;ERROR IF NEITHER "TRUE" OR "FALSE"
	JSR	PC,EQUAL1
	BR	TESTFX	;NOT "TRUE
	JSR	PC,SPOPT
	SKPRET	;"TRUE!!
TESTFX:	MOV	@S,B
	MOV	#FALSE,C
	JSR	PC,EQUAL1
	ERROR+NTF	;NOT "FALSE, EITHER
TSTF9:	JSR	PC,SPOPT
	RTS	PC	;"FALSE!!
REVS:	CMP #1,2(P)	;REVERSES THE TOP ((P)+2) THINGS ON S
	BLT .+4	;IF <2 QUIT
	RTS PC
	CMP #MAXARG,2(P)
	BGE .+4
	.BUG.	;BARF, WHO ASKED REVS TO SWITCH > 32 THINGS?
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV 10.(P),C	;GET # TO BE SWITCHED
REVS5:	MOV S,A	;COMPUTE ADDR OF WORD JUST BEYOND BLOCK
	MOV C,B
	ASL B
	ADD A,B
	CMP #SDLINK,B	;SHOULD WE FORCE A SWAPIN?
	BLO REVS4	;YES
	ASR C
	BEQ REVS1
REVS2:	MOV @A,D
	MOV -(B),(A)+
	MOV D,@B
	DEC C
	BGT REVS2
REVS1:	JMP RETD
REVS4:	JSR PC,SPSWPI	;SWAP S PDL BACK IN
	BR REVS5
.STITL DOUBLE PRECISION INTEGER ARITHMETIC

;INTEGER MULTIPLICATION

;CALL WITH ONE DOUBLE PRECISION ARGUMENT IN B,,C
;AND THE OTHER IN E,,F
;RETURNS PRODUCT IN E,,F.
;ALL OTHER ACCUMULATORS (INCLUDING B,C ARE UNCHANGED)

.DPMUL:	SPUSH	A	;SAVE A
	CLR	A
DVML:	PUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F
	PUSH B		;STUFF ABS(B,,C)
	SPUSH C
	SPUSH E		;AND ABS(E,,F)
	SPUSH F
	CLR	-(SP)	;A FLAG FOR NEG. ARGS
	TST	B	;MAKE SURE ARGS ARE POSITIVE
	BGE	DVML1
	DPNEG	B,C
	DPNEG 10(P),6(P) ;ALSO ON STACK (FOR DIV)
	COM	(SP)
DVML1:	TST	E
	BGE	DVML2
	DPNEG	E,F
	DPNEG 4(P),2(P)
	COM	(SP)
DVML2:	ADD	A,PC	;CHOOSE BETWEEN MUL AND DIV

;DOUBLE PRECISION MULTIPLY (CONT.)

MUL1:	TST	B	;OVERFLOW UNLESS A1*A2=0
	BEQ	MUL2
	TST	E
	BNE	MDV2	;OVERFLOW!
	EXCH	B,E	;WANT ARG1 TO HAVE ZERO HIGH ORDER PART
	EXCH	C,F
MUL2:	CLR	-(SP)	;SET B1 AND B2
	ASL	C
	BCC	.+6
	MOV	#100000,(SP)	;B2
	ASL	F
	BCC	.+6
	ADD	#200,(SP)	;B1 (ALSO CLEARS CARRY)
	ROR	C	;C2
	ROR	F	;C1
;IF B2*A1>0, THEN OVERFLOW
	TST	(SP)
	BGE	MUL3	;B2=0
	TST	E	;A1
	BNE	MDV1	;OVERFLOW

;DOUBLE PRECISION MULTIPLY (CONT.)

;GET A1*C2*(2**16.)
MUL3:
.IFNZ A1120
	MOV #MQ,A
	MOV	C,(A)+	;C2 INTO MQ
	MOV	E,(A)	;A1 INTO MULTIPLY
	BITB	#SIPRBT,EAESR	;SINCE A1*C2 IS HIGH ORDER OF ANSWER
	BEQ	MDV1	;OVERFLOW
	MOV	-(A),ANSWER+2
.IFF
	MOV C,A		;C2*A1
	MUL E,A
	BCS MDV1	;CARRY INTO A IS OVERFLOW
	MOV B,ANSWER+2	;SINCE A1*C2 IS HIGH ORDER OF ANSWER
.IFTF
;GET C1*C2 AND ADD INTO ANSWER
.IFT
	MOV	C,(A)+	;C2 INTO MQ
	MOV	F,(A)	;C1 INTO MULTIPLY
	MOV	-(A),ANSWER	;BOTTOM OF ANSWER _ MQ
	ADD	-(A),ANSWER+2
.IFF
	MOV C,A		;C1*C2
	MUL F,A
	MOV B,ANSWER	;LOW ORDER PARTIAL PRODUCT
	ADD A,ANSWER+2	;ADDED TO A1*C2
.IFTF
	BVS	MDV1	;OVERFLOW
;GET C2*B1*(2**15.) AND ADD INTO ANSWER
	TSTB	(SP)
	BEQ	MUL35	;B1=0
.IFT
	TST	(A)+	;POINT BACK TO MQ
	MOV	C,(A)	;SHIFT C2
	MOV	#15.,ARS
	ADD	(A),ANSWER	;DOUBLE PRECISION ADD
.IFF
	CLR A
	MOV C,B		;GET C2
	ASHC #15.,A	;SHIFT C2 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
.IFTF
	ADC	ANSWER+2
	BVS	MDV1
.IFT
	ADD	-(A),ANSWER+2
.IFF
	ADD A,ANSWER+2
.IFTF
	BVS	MDV1
;NOW GET B2*C1*(2**15.) AND ADD INTO ANSWER
MUL35:	TST	(SP)
	BGE	MUL4
.IFT
	TST	(A)+
	MOV	F,(A)
	MOV	#15.,ARS
	ADD	(A),ANSWER	;DOUBLE PRECISION ADD
.IFF
	CLR A
	MOV F,B		;GET C1
	ASHC #15.,A	;SHIFT C1 LEFT 15 PLACES
	ADD B,ANSWER	;DOUBLE PRECISION ADD
.IFTF
	ADC	ANSWER+2
	BVS	MDV1
.IFT
	ADD	-(A),ANSWER+2
.IFF
	ADD A,ANSWER+2
.ENDC
	BVS	MDV1
;NOW GET B1*B2*(2**30.)
MUL4:	CMP	(SP)+,#100200	;ARE BOTH B1 AND B2 SET
	BNE	MUL5	;NO (PRODUCT IS ZERO, OBVIOUSLY)
	ADD	#40000,ANSWER+2	;1*2**30. + ANSWER
	BVS	MDV2	;OVERFLOW
;PUT ANSWER IN THE RIGHT PLACE
MUL5:	MOV	ANSWER+2,E	;HIGH ORDER PARTS
	MOV	ANSWER,F	;LOW ORDER PARTS
	TST	(SP)+	;NEGATIVE?
	BEQ	MUL6
	DPNEG	E,F
MUL6:	ADD #14,SP	;THROW AWAY E,,F, ABS(B,,C) AND ABS(E,,F)
	JMP	SRETD	;BUT RESTORE THE REST

;OVERFLOW EXITS
MDV1:	TST (SP)+	;POP 2 WORDS + ABS'S
MDV2:	ADD #12,SP	;POP 1 WORD + ABS'S
	JMP	RETF	;RESTORE ALL AC'S AND RTS


;DOUBLE PRECISION DIVIDE
;	DIVIDE E,F BY B,C
;RETURN QUOTIENT IN E,F  AND REMAINDER IN B,C
.DPDIV:	SPUSH	A
	MOV	#<DIV1-MUL1>,A	;ADD TO THE PC IN A WHILE
	JMP	DVML	;INITIALIZATION.

DIV1:	TST	B	;IS DEN = 0, 1, OR DOUBLE PRECISION ?
	BNE	DIV2	;DOUBLE PRECISION
	TST	C
	BLT	DIV2	;DOUBLE PRECISION (SINCE TOP BIT WAS SET)
;DEN IS SINGLE PRECISION
	BEQ	MDV2	;DEN=0. OVERFLOW!
	CMP	C,#1	;IS IT 1?
	BNE	SPDEN1	;NO
	CLR	B
	CLR	C
	BR	DIV10
SPDEN1:	JSR	PC,.SPDEN	;DO THE DIVISION
	BR	DIV10

;DEN IS DOUBLE PRECISION
DIV2:	JSR	PC,CMP2I	;IS NUM < DEN
	BGE	DIV5	;NO
;NUM<DEN. QUOTIENT=0. REM=NUM
DIV4:	MOV	E,B
	MOV	F,C
	CLR	E
	CLR	F
	BR	DIV10

;NUM>=DEN.
DIV5:	PUSH B		;SAVE DENOMINATOR
	SPUSH C
.IFNZ A1120
	MOV	#MQ,A
	MOV	C,(A)	;NORMALIZE DEN
	MOV	B,-(A)
	CLR	NORMAL
	MOV	NORMAL,SHFCNT
	MOV	(A)+,C	;DIVIDE BY TOP WORD OF NORMALIZED DEN
	JSR	PC,.SPDEN	;E,F _ E,F/C
	MOV	F,(A)	;MQ_BOTTOM OF TRIAL QUO
	MOV	E,-(A)	;AC_TOP OF TRIAL QUO
	ADD	#-16.,SHFCNT	;HOW MUCH TO SHIFT QUOTIENT
	MOV	SHFCNT,ARS	;SHIFT THE TRIAL QUOTIENT
.IFF
	MOV B,A		;MOVE B,,C TO A,,B AND NORMALIZE
	MOV C,B
	CLR SHFCNT
DIV5A:	INC SHFCNT	;COUNT A LEFT SHIFT
	ASHC #1,A
	BVC DIV5A	;UNTIL SIGN BIT CHANGES (OVERFLOW)

	ASHC #-1,A	;UNDO LAST SHIFT
	BIC #100000,A	;AND CLEAR SIGN BIT WHICH WAS SET
	DEC SHFCNT	;UNCOUNT THE LAST SHIFT
	MOV A,C		;DIVIDE BY HIGH-ORDER OF NORMED DIVISOR
	JSR PC,.SPDEN	;E,,F _ (E,,F)/(DIVISOR*2^[N-16.])
	MOV E,A		;MOV (QUOTIENT*2^[16.-N]) TO A,,B
	MOV F,B
	ADD #-16.,SHFCNT	;TIMES 2^[N-16.] IS TRIAL QUOTIENT
	ASHC SHFCNT,A
.IFTF
;GET TRIAL NUM_(TRIAL QUOTIENT-1)*DEN. COMPARE WITH TRUE NUM
	POP F		;E,,F _ SAVED DENOMINATOR
	SPOP E
.IFT
	MOV	(A)+,B	;B,C_AC,MQ (TRIAL QUOTIENT)
	MOV	(A),C
.IFF
	MOV B,C		;B,,C _ A,,B (TRIAL QUOTIENT)
	MOV A,B
.ENDC
	SUB	#1,C	;TRY FIRST WITH Q_Q-1
	SBC	B
	BVS	MDV2	;OVERFLOW
	JSR	PC,.DPMUL
	BR	MDV2	;MULTIPLY GOT AN ERROR (HMM!)
;COMPARE NUM TO TEM
	MOV	B,ANSWER+2	;SAVE TRIAL QUO
	MOV	C,ANSWER
;GET TEM-NUM
	MOV	SP,D
	TST	(D)+
	SUB	(D)+,F
	SBC	E
	BVS	MDV2
	SUB	(D)+,E
	BVS	MDV2
;TURN INTO NUM-TEM
	DPNEG	E,F
	MOV	E,B
	MOV	F,C
	MOV	(D)+,F	;E,,F_DEN
	MOV	(D)+,E
DIV6:	TST	B	;NUM-TEM
	BEQ	DIV7
	BGT	DIV75
;ANSWER TOO BIG. TRY ANSWER _ ANSWER - 2
	SUB	#2,ANSWER
	SBC	ANSWER+2
	BVS	MDV2
;THIS MAKE TEM _ TEM + 2*DEN
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	ADD	F,C
	ADC	B
	BVS	MDV2
	ADD	E,B
	BVS	MDV2
	BR	DIV6
DIV7:	TST	C
	BEQ	DIV9	;TRIAL QUOTIENT = QUOTIENT !!
;TEM < NUM. EITHER QUOT=QUOT OR QUOT+1
DIV75:	JSR	PC,CMP2I	;IS REM < DEN
	BGT	DIV9	;YES
DIV8:	ADD	#1,ANSWER	;QUOT _ QUOT + 1
	ADC	ANSWER+2
	BVS	MDV2
	SUB	F,C	;REM _ REM - DEN
	SBC	B
	BVS	MDV2
	SUB	E,B
	BVS	MDV2
DIV9:	MOV	ANSWER+2,E
	MOV	ANSWER,F
DIV10:	TST	(SP)+	;NEG. IF ANSWER SHOULD BE NEG.
	BGE	DIV11
	DPNEG	B,C
	DPNEG	E,F
DIV11:	ADD #14,SP	;POP ABS(E,,F), ABS(B,,C) AND E,,F
	POP	D	;RESTORE D
	CMP	(SP)+,(SP)+	;THROW AWAY B & C
	SPOP	A	;RESTORE A
	SKPRET


;SINGLE PRECISION DENOMINATOR. DOUBLE PRECISION NUMERATOR.
;C=DEN. E,F=NUM. RETURNS C_REM, E,F_QUOTIENT
.SPDEN:	SPUSH	A
	SPUSH	B
	ASL	E	;DOUBLE E,,F
	ASL	F
	ADC	E
.IFNZ A1120
	MOV #MQ,A
	MOV	E,(A)	;MQ_E ("TOP PART")
	CLR	-(A)
	MOV	C,-(A)	;DIVIDE
	TST	(A)+
	MOV	(A)+,B	;REM
	MOV	(A),E	;"TOP PART" OF QUOTIENT
	MOV	F,(A)	;MQ_"BOTTOM PART"
	MOV	B,-(A)	;AC_REM
	MOV	#-1,ARS	;SHIFT IT ALL RIGHT
	MOV	C,-(A)	;DIVIDE
	TST	(A)+
	MOV	(A)+,C	;REMAINDER
	MOV	(A),F	;"BOTTOM PART" OF QUO
.IFF
	MOV E,B		;2E/C
	CLR A
	DIV C,A
	MOV A,E		;2*HIGH-QUOTIENT -> E
	MOV B,A		;(2REM + 2F)/2 /C
	MOV F,B
	ASHC #-1,A
	DIV C,A
	MOV A,F		;LOW-QUOTIENT -> F
	MOV B,C		; REMAINDER -> C
.ENDC
	ASR	E	;HALVE E TO GET PROPER HIGH-QUOTIENT
	BCC	.+6
	BIS #100000,F	;& LOW BIT FROM DOUBLE-E CLOBBERS F'S SIGN BIT
	SPOP	B
	SPOP	A
	RTS	PC
	.STITL CONVERSION ROUTINES


;CONVERT
;CALL WITH DESIRED DATA TYPE IN A
;CALL WITH POINTER TO DATA IN B
;IF CONVERSION SUCCEEDS, RETURN POINTER TO CONVERTED DATA IN B AND
;LEAVE A UNCHANGED.
;
;IF CONVERSION FAILS, LEAVE B UNCHANGED,BUT RETURN ITS DATA TYPE IN A

CONVERT:
	MOV	A,-(SP)	;SAVE A,B,C HERE
	MOV	B,-(SP)
	MOV	C,-(SP)

	BIC	#107777,A	;LEAVE DATA TYPE ONLY
	MOV	B,C
	BIC	#107777,C
	ASR	A	;SHIFT DESTINATION DATA TYPE 3 PLACES
	ASR	A
	ASR	A
	BIS	C,A	;SET SOURCE DATA TYPE IN THE 3 VACATED BITS
	ASR	A	;AND PLACE THE ENTIRE MESS IN BOTTOM 6 BITS
	SWAB	A
;(A IS NOW A 6 BIT DISPATCH ADDRESS)
	MOVB	CNVTBL(A),A	;PICK UP ENTRY FROM TABLE
	BIC	#177400,A	;CLEAR TOP BYTE
	ASL	A		;IT IS A BYTE ADDRESS
	JSR	PC,CNVTOP(A)	;RELATIVE TO CONVERT TOP
	BR	CONV.F	;THE CONVERSION FAILED
	MOV	(SP)+,C
	TST	(SP)+	;DON'T RESTORE B
	MOV	(SP)+,A
	JMP	SRET	;SKIP RETURN

CONV.F:	MOV	(SP)+,C
	MOV	(SP)+,B
	MOV	B,A
	BIC	#7777,A	;DATA TYPE OF ARG LEFT IN A
	TST	(SP)+	;DON'T RESTORE A
	RTS	PC


;CONVERT ROUTINE JUMPS TO THE PROGRAMS HERE

CNVTOP==.	;TOP OF CONVERT ROUTINES

;THE ARGUMENT CAN'T BE CONVERTED TO DESIRED DATA TYPE
.CERR:	RTS	PC

CNVNOP==<.-CNVTOP>/2
;THE ARGUMENT ALREADY HAS THE DESIRED TYPE
.CNOP:	SKPRET

CA2LS==<.-CNVTOP>/2
;CONVERT ATOM TO LSTR
.CATLS:	JSR	PC,.LOAD
	SKPRET

CSN2IN==<.-CNVTOP>/2
;CONVERT SNUM TO INUM.  ASSUME NUMBER IN B, RATHER THAN POINTER
.CSNIN:	CLR	A
	TST	B	;IS NUM NEGATIVE?
	BGE	.+4
	COM	A	;SET TOP PART TO ALL 1'S
	JSR	PC,GRBAD
	BIS	#INUM,C	;C POINTS TO NEW NODE
	MOV	C,B
	SKPRET

;MORE CONVERSION ROUTINES

CSN2LS==<.-CNVTOP>/2
;CONVERT SNUM TO LSTR
.CSNLS:	JSR	PC,.CSNIN	;CONVERT TO INUM FIRST
	NOP	1

CIN2LS==<.-CNVTOP>/2
;CONVERT INUM TO LSTR
.CINLS:	SPUSH	D
	SPUSH	E
	SPUSH	F
	JSR	PC,.LOAD	;A,B HAS NUMBER
	JSR	PC,.CINST	;CONVERT TO STRING ON P-PDL
	CLR	F
	MOV	#SSTR,A
.CINL1:	SPOP	B
	BEQ	.CINL2		;0 MARKS END OF DIGITS
	JSR	PC,LISTB	;PUT NEXT 2 CHARS ONTO LIST
	BR	.CINL1
.CINL2:	POPS	B	;POINTER TO FIRST NODE OF ANSWER
	BIC	#170000,B	;CLEAR DATA TYPE
	BIS	#LSTR,B	;REPLACE BY LSTR
	MOV F,C	;GET PTR TO LAST NODE IN STRING

.SRDEF:	CLR	GCP1
	MOV	(SP)+,F
	MOV	(SP)+,E
	MOV	(SP)+,D
	SKPRET

;GET NEXT CHARACTER IN B
;SKIP UNLESS NO MORE CHARS
.CNXTD:	TST	E	;IS THERE MORE NUMBER LEFT
	BNE	.CNXD1	;YES
	TST	F
	BNE	.CNXD1	;YES
	RTS	PC	;NO
.CNXD1:	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPDIV	;C_REM, E,,F_QUO
	RTS	PC	;DIVIDE GOT AN ERROR
	ADD	#60,C	;TURN TO ASCII
	SKPRET


;CONVERT INUM TO STRING ON P-PDL
.CINST:	MOV	(SP),TEM1	;RETURN ADDRESS
	CLR	(SP)
	MOV	#10,D
	MOV	A,E
	BGE	.CINI1	;NUMBER IS POSITIVE
	DPNEG	E,B	;NUMBER IS NEG
	CLR	D	;FLAG
.CINI1:	MOV	 B,F

.CINI2:	JSR	PC,.CNXTD	;GET NEXT DIGIT IN C
	BR	.CINI5	;NO MORE CHARS
	SWAB	C
	PUSH	C
	JSR	PC,.CNXTD
	BR	.CINI6
	BISB	C,(SP)	;SET NEW CHAR INTO PREVIOUS ONE
	BR	.CINI2

.CINI5:	ADD	D,PC	;NEGATIVE?
	SPUSH	#<55*256.>	;PUSH A MINUS SIGN IN HIGH BYTE
.CINIR:	JMP	@TEM1	;RETURN
	BR	.CINI7

.CINI6:	ADD	D,PC	;NEGATIVE?
	BIS	#55,(SP)	;PUT A MINUS SIGN IN LOW BYTE
	JMP	@TEM1
.CINI7:	TST	(SP)	;WERE ANY CHARACTERS GENERATED?
	BNE	.CINIR	;YES, SO RETURN
	SPUSH	#<60*256.>	;NO, SO PUSH A "0 IN HIGH BYTE
	BR	.CINIR

;MORE CONVERSION ROUTINES

CIN2SN==<.-CNVTOP>/2
;CONVERT INUM TO SNUM.  RETURN NUMBER IN B
.CINSN:	JSR	PC,.LOAD
.IFNZ A1120
	MOV	B,MQ
	MOV	A,AC
	BITB	#SIPRBT,EAESR	;TEST SINGLE PRECISION BIT
	BNE .+4		;ON: SINGLE PRECISION
.IFF
	TST B
	SXT C		;SEE IF B'S SIGN EXTENDED FILLS A.
	CMP A,C
	BEQ .+4		;DOES: SINGLE PRECISION
.ENDC
	RTS	PC	;NOT SINGLE PRECISION
	SKPRET

CLS2SN==<.-CNVTOP>/2
;CONVERT LSTR TO SNUM
.CLSSN:	JSR	PC,.CLSIN	;CONVERT TO INUM FIRST
	RTS	PC	;FAILED
	JSR	PC,.CINSN	;THEN CONVERT TO SNUM
.CLNR:	RTS	PC	;FAILED
	SKPRET

CLS2IN==<.-CNVTOP>/2
;CONVERT LSTR TO INUM
.CLSIN:	BIT	#7777,B	;IS B EMPTY
	BEQ	.CLNR	;CAN'T CONVERT EMPTY
	PUSH	D
	SPUSH	E
	SPUSH	F
	MOV	B,GCP1	;POINT TO INPUT. (GETS CLEARED AT .RDEF & .SRDEF)
	MOV	B,C
	CLR	E
	CLR	F

.CLSS0:	CLR	-(SP)	;A FLAG
	JSR	PC,INSTR1	;GET FIRST CHAR IN D
	BEQ	.CLSS8	;NO CHARS (HMM)
	CMPB	D,#53	;PLUS
	BEQ	.CLSSA
	CMPB	D,#55	;MINUS
	BNE	.CLSS3	;NOT + OR -
	COM	2(SP)	;-1
.CLSSA:	JSR PC,@(SP)+
	BEQ .CLSS8
	BR .+4
.CLSS1:	JSR	PC,@(SP)+	;GET NEXT CHAR INTO D
	BEQ	.CLSS9	;ALL CHARS GOTTEN
.CLSS3:	SPUSH	C	;SAVE C
	SUB	#60,D	;CONVERT FROM ASCII
	BLT	.CLSS7	;NOT DIGIT
	CMPB	D,#10.
	BGE	.CLSS7	;NOT DIGIT
	MOV	#10.,C
	ADD	ABASE,C	;ADD DELTA ARITHMETIC BASE TO C
	CLR	B
	JSR	PC,.DPMUL
	BR	.CLSS7	;TOO BIG
	ADD	D,F	;ADD NEXT DIGIT IN
	ADC	E
	BVS	.CLSS7	;OVERFLOW
	SPOP	C
	BR	.CLSS1

;EITHER A NON-DIGIT CHARACTER WAS FOUND, OR ELSE 
;THERE WAS OVERFLOW
.CLSS7:	CMP	(SP)+,(SP)+	;POP OFF C & CO-ROUTINE LINKAGE
.CLSS8:	TST	(SP)+	;POP OFF FLAG
	JMP	.RDEF

;ALL CHARS GOTTEN.  NUMBER IS IN E,,F
.CLSS9:	TST	(SP)+	;BUT SHOULD IT BE NEG?
	BGE	.CLSSR	;NO
	DPNEG	E,F
.CLSSR:	MOV	E,A
	MOV	F,B
	JSR	PC,GRBAD
	BIS	#INUM,C
	MOV	C,B
	JMP	.SRDEF
	.STITL GET ARGUMENT ROUTINES

;GET 2 SNUM'S OFF OF S PDL
;RETURN TOP ONE IN A, BOTTOM ONE IN B
G2NARG:	JSR	PC,G1NARG	;NUMBER IN B
	MOV	B,A

;GET 1 SNUM OFF OF S PDL
;RETURN IT IN B
G1NARG:	POPS B
G1NAR1:	MOV	A,-(SP)	;ENTER HERE WITH ARG IN B
	MOV	#SNUM,A
	JSR	PC,CONVERT
G1WTA:	ERROR+WTAB	;WRONG TYPE OF ARG
	MOV	(SP)+,A
G1RET:	RTS	PC

;GET ONE LIST OR WORD ARG
;SKIP IF WORD
GLWARG:	MOV	@S,B	;DON'T POP ARG.  LEAVE IT GC PROTECTED
GLWAR1:	MOV	#LSTR,A
	JSR	PC,CONVERT
	BR	GSW1	;NOT WORD
	SKPRET
GSW1:	CMP	A,#SENT
	BNE	G1WTA	;NOT SENTENCE EITHER
GSW2:	RTS	PC

;GET ONE LIST OR WORD.  ERRROR IF EMPTY
GLWANE:	MOV	@S,B
	BIT	#7777,B
	BEQ	G1WTA
	BR	GLWAR1

;RETURN ONE NUMERIC ARGUMENT
;CALL WITH SNUM IN B
R1INT:	JSR	PC,GETINT
R1NARG:	JSR	PC,.CSNIN	;CONVERT SNUM TO INUM
	NOP 1
	JMP ORTB

PSHINT:	JSR	PC,GETINT
;PUSH A NUMBER ONTO THE S-PDL
PSHNUM:	JSR	PC,.CSNIN
	NOP 1
	SPUSHS	B
	RTS	PC


;GET 2 INTEGERS FROM THE S-PDL
G2IARG:	JSR	PC,G1IARG
	MOV	B,E
	MOV	C,F
	JSR	PC,G1IARG
	EXCH	B,E
	EXCH	C,F
	RTS	PC

;GET 1 INTEGER FROM THE S-PDL
G1IARG:	POPS	B
	SPUSH	A	;SAVE A
	MOV	#INUM,A
	JSR	PC,CONVERT
	ERROR+WTAB
	JSR	PC,.LOAD	;INTEGER IN A,,B
	MOV	B,C
	MOV	A,B
	SPOP	A
	RTS	PC

;RETURN 1 INTEGER FROM B,,C
R1I.BC:	MOV	B,A
	MOV	C,B
	BR	R1I.N

;;RETURN 1 INTEGER FROM E,,F
R1I.EF:	MOV	E,A
	MOV	F,B
R1I.N:	JSR	PC,GRBAD
	BIS	#INUM,C
	JMP	ORTC


;GET 1 SNAP
;	RETURN POINTER TO SNAP IN D, DELTA X IN E, DELTA Y IN F
G1SNAP:	MOV	@S,C	;POINTER TO ARG
	BIT	#7777,C	;IS IT EMPTY?
	BEQ	G1RET	;YES. RETURN WITHOUT SKIPPING
	JSR	PC,LD3NUM	;LOAD D,E,F
	SKPRET


;LOAD 3 NUMBERS
;	GROVEL DOWN A LIST OF NUMBERS RETURNING 3 NUMBERS IN D,E,F
;	CALL WITH C POINTING TO LIST
;	IF LIST CONTAINS 1)NON-NUMBERS OR 2)MORE THAN 3 ELEMENTS,
;	THEN ERROR+WTA
LD3NUM:	PUSH	A
	SPUSH	B
	SPUSH	C
	MOV	#7777,D	;AN OFT USED CONSTANT
	MOV	#3,F	;COUNTER
LDN.L:	BIT	D,C	;IS THERE MORE LIST?
	BEQ	LDN.E	;ERROR
	JSR	PC,.LOADC	;LOAD A WITH NEXT ELEMENT
	MOV	A,C
	MOV	#SNUM,A
	JSR	PC,CONVERT
LDN.E:	ERROR+WTA
	SPUSH	B	;PUSH THIS ELEMENT
	DEC	F
	BGT	LDN.L	;LOOP BACK
	BIT	D,C	;IS THE LIST FINISHED?
	BNE	LDN.E	;NO. ERROR
	JMP	RETF	;SKIP RETURN AND RESTORE ALL AC'S!
	.STITL EVAL

EVAL:	JSR PC,GNT
	JSR PC,STRACE
	BIC #DPQF+CPTBF,FLAGS2
	BIC #7777,A
	CMP A,#UFUN
	BLOS EVFUN
	CMP A,#UVAR
	BEQ EVVAR
	CMP A,#SSTR
	BHI .+4
EVWHAT:	.BUG.
	CMP A,#ATOM
	BEQ EVATM
	CMP A,#SNUM
	BEQ EVWHAT
	CMP A,#LSTR
	BLOS EVCON
	CMP A,#LIST
	BNE EVWHAT
EVCON:
EVATM:	PUSHS CT+2
	BR EVI
EVVAR:	BIC #170000,B
	BIS #ATOM,B
	MOV B,D	;SAVE UOE PTR FOR ERROR
	JSR PC,.BINDL
EVVAR2:	ERROR+HNV	;... HAS NO VALUE
	TST B		;NIL?
	BNE EVVAR1		;NO, GOOD
	MOV D,B
	BR EVVAR2
EVVAR1:	PUSHS B
EVI:	JSR PC,GNT	;ABOUT TO OUTPUT A VALUE.
			;BEFORE WE DO, CHECK TO SEE IF
			;NEXT TOKEN IS INFIX WHICH SHOULD GOBBLE IT.
	BIC #7777,A	;IS NEXT TOKEN INFIX?
	CMP #INFIX,A
	BEQ CKPRCD	;YES
EVI1:	BIS #RTF,FLAGS	;SET REPEAT TOKEN FLAG
	BIC #CRF,FLAGS
	JMP SRET
CKPRCD:	TST CO+2	;COMPARE PRECEDENCE
	BEQ EVI2
	MOV CT+2,A
	MOV SOBLST(A),A
	BIC #7777,A
	MOV COF,B
	BIC #7777,B
	CMP A,B	;IS PRECD OF CO >= PRECD NEXT OPER
	BLO EVI1	;YES, > - GIVE OUTPUT TO CO
	BEQ EVI4	;YES, = - CHECK FOR _
		;NO - NEXT TOKEN SHOULD GOBBLE THIS OUTPUT
EVI2:	JSR PC,STRACE
EVI12:	CMP #$BKAR,CT+2	;CHECK FOR SUCCESSIVE _'S
	BNE EVI3		;   "A _"B _0
	CMP #$BKAR,CO+2
	BEQ EVI13
	CMP #$TBKAR,CO+2
	BNE EVI3
EVI13:	MOV #$TBKAR,CT+2
EVI3:	PUSH CO
	SPUSH CO+2
	SPUSH NOR
	MOV CT,CO
	MOV CT+2,CO+2
	MOV CO+2,A	;GET FLAGS
	MOV SOBLST(A),COF
	MOV #1,NOR
	JMP EVW
EVI4:	CMP #$BKAR,CT+2	;PRECD ARE = - IF _ DO RIGHT ONE FIRST
	BEQ EVI2	;IT IS _
	BR EVI1
EVFUN:	BIT #CRF,FLAGS	;CT IS A FUNCTION
	BEQ .+4
	ERROR+UELX	;UNEXPECTED END OF LINE
	CMP #$LPAR,CT+2
	BNE EVF1
	TST CO+2
	BEQ EVF11
	CMP #$DO,CO+2
	BEQ EVF11
	CMP #$LLPAR,CO+2
	BNE EVF1
EVF11:	MOV #$LLPAR,CT+2
EVF1:	PUSH CO
	SPUSH CO+2
	SPUSH NOR
	CMP #$LLPAR,CO+2	;IF CO IS !(, PUSH IFLEV INSTEAD OF NOR
	BNE EVF13
	MOV IFLEV,(P)
	CLR IFLEV
EVF13:	MOV CT,CO
	MOV CT+2,CO+2
	BIC #EDTIF2,FLAGS
EVF2:	CMP A,#UFUN	;IS IT A  USER FUNCTION?
	BLO MFUN	;NO, MACHINE
	MOV #<PREPRI_13.>,COF	;SET PRECD TO PREPRI
	JSR PC,GNASN	;GET NO. OF ARGS IN B
	ERROR+HNM	;... HAS NO MEANING
	MOVB B,B	;CLEAR ANY LEFT HALF FLAGS
	MOV B,NOR
	BNE EVL1
EVXP:	JSR PC,STRACS
	JSR PC,PEVAL	;SET TO EVALUATE THIS USER PROCEDURE
	JMP XNORT	;PEVAL RETURNS  IF THERE WAS NO OUTPUT
	JMP XORT		;SKIPS IF THERE WAS
MFUN:	MOV CO+2,A	;GET FLAGS FOR THIS MACHINE PROCEDURE
	MOV SOBLST(A),A
	MOV A,COF
	SWAB A
	BIC #177774,A
	MOV A,NOR
	BNE EVS	;IS  NO. ARGS = 0?
EVXM:	JMP MEVAL	;YES.  EXECUTE THIS MACHINE PROCEDURE
XNORT:	BIC #EDTIF,FLAGS
	BIT #EDTIF2,FLAGS
	BEQ .+10
	BIS #EDTIF,FLAGS
NORT0:	MOV #EVDNO,A
NORT1:	MOV CO+2,LO+2
	MOV CO,LO
	POP NOR
	SPOP B
	MOV B,CO+2
	SPOP CO
	CMP #$LLPAR,B	;IF POPPED OPER IS !(, IFLEV_NOR, NOR_1	
	BNE NORT3
	MOV NOR,IFLEV
	MOV #1,NOR
NORT3:	CLR COF
	TST B
	BEQ NORT2
	BIT #160000,CO	;IS IT A UFUN
	BNE NORT2
	MOV SOBLST(B),COF
NORT2:	JMP @A
EVDNO:	RTS PC
EVS:	BIT COF,#INFIX	;IS CO INFIX OP
	BEQ EVL	;NO
	JSR PC,CKUI	;CHECK FOR VALID UNARY INFIX +,-
	ERROR+INF1	;INFIX IN WRONG PLACE
	BR EVW
PROC:
	JSR PC,GUOEB	;PEVAL INVOKED VIA "#"
	BR PROC1
	MOV B,@P	;OLD RETURN - POPPED LATER
	JSR PC,.BINDF	;IS A PROC DEFINED
	BR PROC3	;NO
	MOV #UFUN,CO	;YES
	MOV @P,B
PROC2:	CLR TOPS
	MOV B,CO+2
	SPOP B	;GET P BACK IN PHASE
	JMP EVF2
PROC3:	JSR PC,.LOAD	;GET PNAME FOR UOBSCH
PROC1:	MOV B,TOPS
	MOV #SFUN,A
	JSR PC,UOBSCH
	ERROR+HNM	;HAS NO MEANING
	MOV A,CO
	BR PROC2

EVL:	BIT #PTLPF,FLAGS	;WAS PREVIOUS TOKEN A LEFT PAREN
	BEQ EVL1
	BIT #VNAF,COF
	BEQ EVL1
	CLR NOR
EVL1:	JSR PC,GNT
EVW1:	BIS #RTF,FLAGS	;SET RTF
	BIC #CRF,FLAGS
EVW:	JSR PC,EVAL
	BR EVW2
	DEC NOR
	BEQ EVX	;WHEN NOR = 0, WE'VE ENUF INPUTS
	JSR PC,GNT
	TST NOR	;IF NOR < 0 AND NEXT TOKEN IS ")" THEN THE ")" 
	BGE EVW1	;TERMINATES THE ARG SCAN FOR THE CO
	CMP #$RPAR,CT+2
	BNE EVW1
	BIS #RTF,FLAGS
	BIC #CRF,FLAGS
	NEG NOR
	CMP #MAXARG,NOR
	BGE MEVALN
	ERROR+TMAC	;TOO MANY ARGS COMMAND/OPERATION
EVX:	BIT #160000,CO	;IS IT A MACHINE PROCEDURE
	BEQ .+6
	JMP EVXP	;NO
	BIT #VNAF,COF	;MACHINE PROC NOW HAS ITS "STD" NO. OF ARGS.
		;IF IT CAN TAKE A VARIABLE NO., THEN THE "STD" NO. HAS TO 
		;BE PUSHED ON P
	BEQ MEVAL
	MOV COF,A
	SWAB A
	BIC #177774,A
	MOV A,NOR
	BR MEVALN
EVW2:	CMP #$LLPAR,CO+2	;EVAL SHOULD OUTPUT WHEN NOT AT TOP LEVEL
	BEQ EVW		;EXCEPT WHEN CO IS LLPAR
	ERROR+NOU	;WHAT, NO OUTPUT??!!

LLPAR:
LPAR:	JSR PC,GNT
	CMP #$RPAR,CT+2
	BEQ LPAR1
	ERROR+TIP	;TOO MUCH INSIDE PARENS
LPAR1:	SKPRET
RPAR:	BIT #PTLPF,FLAGS
	BEQ .+4
	ERROR+NIP	;NOTHING INSIDE PARENS
	CMP 4(P),#$LLPAR	;IS PENDING COMMAND !(
	BNE RPAR1
RPAR2:	POP A
	MOV (P),IFLEV
	ADD #6,P	;POP !( OFF STACK
	MOV A,(P)
	RTS PC

RPAR1:	ERROR+ERP	;EXTRA RIGHT PAREN
CKUI:	PUSH A
	MOV CO+2,A
	CMP A,#$PLUS	;+
	BNE CKUI1
	MOV #$UPLUS,A
CKUI0:	MOV SOBLST(A),COF
	MOV A,CO+2
	MOV #1,NOR
	JMP SRETA

CKUI1:	CMP A,#$MINUS	;-
	BNE CKUI2
	MOV #$UMINS,A
	BR CKUI0

CKUI2:	POP A
	RTS PC

MEVALN:	PUSH NOR
MEVAL:	JSR PC,STRACS
	MOV CO+2,A	;GET SOE POINTER
	CLR NBKTS
	JSR PC,@2+SOBLST(A)	;JMP ADDR IS IN 2ND WORD
	JMP XNORT
XORT:	MOV #EVI,A
	JMP NORT1

NORT:	RTS PC

ORTNA:	MOV A,@S
	BR SRET
ORTNB:	MOV B,@S
	BR SRET
ORTNC:	MOV C,@S
	BR SRET
ORTND:	MOV D,@S
	BR SRET
ORTNE:	MOV E,@S
	BR SRET
ORTNF:	MOV F,@S
	BR SRET
ORTNP:	MOV	(SP)+,@S
	BR SRET


ORTA:	PUSHS A
	BR SRET
ORTB:	PUSHS B
	BR SRET
ORTC:	PUSHS C
	BR SRET
ORTD:	PUSHS D
	BR SRET
ORTE:	PUSHS E
	BR SRET
ORTF:	PUSHS F
	BR SRET
ORTP==.
ORTSP:	PUSHS	(SP)+
ORT:	BR SRET

RETF:	POP F
	BR RETE1
RETE:	POP E
	BR RETD1
RETD:	POP D
	BR RETC1
RETC:	POP C
	BR RETB1
RETB:	POP B
	BR RETA1
RETA:	POP A
	RTS PC

RETF1:	SPOP F
RETE1:	SPOP E
RETD1:	SPOP D
RETC1:	SPOP C
RETB1:	SPOP B
RETA1:	SPOP A
RET:	RTS PC

SRETF:	POP F
	BR SRETE1
SRETE:	POP E
	BR SRETD1
SRETD:	POP D
	BR SRETC1
SRETC:	POP C
	BR SRETB1
SRETB:	POP B
	BR SRETA1
SRETA:	POP A	;POP A THEN SKIP RETURN
	BR SRET

SRETE1:	SPOP E
SRETD1:	SPOP D
SRETC1:	SPOP C
SRETB1:	SPOP B
SRETA1:	SPOP A	;POP A THEN SKIP RETURN
CKTYP:
SRET:
	.IFZ SEG
	CMP #200,@0(P)	;SKIP RETURN. IS NEXT INST A 'JMP' OR HALT
	BLOS .+6
	ADD #2,@P	;YES, SKIP 2 EXTRA
	.IFF
	SPUSH A
	MOV P,A
	MFPI @2(A)
	CMP #200,(P)+
	BLOS .+10
	ADD #2,2(P)
	SPOP A
	.ENDC
	ADD #2,@P
	RTS PC
	.STITL PROCEDURE EVALUATOR
PEVAL:	JSR PC,CKSTG
	MOV CO+2,B	;FIRST CHECK IF PROC IS THERE
	JSR PC,.BINDF
	ERROR+HNM	;PROCEDURE HAS NO MEANING
	PUSH CPP		;PUSH THE WORLD!
	SPUSH CPSN
	SPUSH CPLN
	SPUSH CLP
	SPUSH CLGN
	SPUSH CTN
	PUSH CTP
	SPUSH FLAGS
	SPUSH CO
	SPUSH CO+2
	SPUSH IFLEV
	SPUSH ERPROC

	;GET ARG LIST - PUT UOE POINTERS AND VALUES FROM THERE ON S
	MOV A,C		;SAVE PTR TO LLP
	JSR PC,.LOAD	;GET FLAGS,,#ARGS
	MOV B,FLAGS
	MOVB B,B
	SPUSH B		;PUSH # ARGS
	BIC #-<TPTF+TPSF>-1,FLAGS
	BNE PEV3
	BIT #TRACEF,FLAGS2
	BEQ PEV6
PEV3:	MOV CO+2,B
	INC FUNLEV
	JSR PC,TINDNT
	DEC FUNLEV
	JSR PC,PPNAME
	PRTXT ^\'S INPUTS: \
	MOV @P,B
PEV6:	SPUSH C		;SAVE FOR BELOW (POINTS TO LASTLINEPTR)
	MOV B,D
	BEQ PEV2	;NO ARGS
	JSR PC,.LOADC
	JSR PC,.LOAD
	SPUSH A		;SAV PTR TO REST OF TITLE LINE
	CMP #SPUSHL,S
	BLOS .+6
	JSR PC,SPSWPO
	MOV D,B
	ASL B
	MOV S,D
	MOV D,E
	SUB B,E
	MOV E,S
	ASR B
PEV7:	MOV (D)+,(E)+
.IIF NZ A1145, SOB B,PEV7
.IFZ A1145
	DEC B
	BGT PEV7
	.ENDC
	MOV @P,A	;GET SAVED LLP PTR
PEV1:	TST FLAGS
	BNE PEV4
	BIT #TRACEF,FLAGS2
	BEQ PEV5
PEV4:	MOV -2(E),B
	MOV B,A
	INC NBKTS
	SPUSH D
	JSR PC,PRTAB
	DEC NBKTS
	SPOP D
	MOV @P,A
PEV5:	JSR PC,.LOADA
	MOV A,@P
	CMP #$COMT,B
	BNE PEV10
PEV12:	BIT #7777,A
	BEQ PEV11
	JSR PC,.LOADA
	CMP #$COMT,B
	BNE PEV12
	BR PEV5
PEV10:	JSR PC,SAVVAR	;SAVE THIS VARIABLE BINDING
	MOV @P,A
	BIT #7777,A
	BEQ PEV11
	TST FLAGS
	BNE PEV10A
	BIT #TRACEF,FLAGS2
	BEQ PEV1
PEV10A:	PRTXT ^/,/
	BR PEV1	;GO DO NEXT ARG

PEV11:	SPOP C		;USED TITLE LINE POINTER
PEV2:	SPOP C		;PTR TO LLP THAT WAS PUSHED WAY ABOVE
	TST FLAGS
	BNE PEV2A
	BIT #TRACEF,FLAGS2
	BEQ PEV2B
PEV2A:	PRCR
PEV2B:	JSR PC,SAVPPS	;SAVE PDL PTRS
	BIS #1,CPDLP	;INDICATES PROC PUSH AS OPPOSED TO A LOCAL PUSH
	MOV CO+2,CPP
	CLR CPLN
	MOV C,CLP
	MOV CPP,B	;GET CPSN IN A
	JSR PC,GNASN
	.BUG.
	MOV A,CPSN
	CLR CO
	CLR CO+2
	CLR IFLEV
	INC FUNLEV
	JMP MLOOP
SAVVAR:	;SAVE IN (D) VARIABLE BINDING OF UOE PT'ED TO BY B
		;GIVE IT NEW VALUE WHICH IS AT (E)
		;USES A,C.  TOPS MUST BE 0
		;BOTH D AND E ARE -()ED
	MOV B,-(D)	;SAVE UOE PTR
	JSR PC,CKSARG	;THIS WILL CHECK SPDL THINGS--
			;NOP IT IF IT SEEMS TO CAUSE TROUBLE.  RWW
	JSR PC,.BNDVN	;NOW GET VARIB. BINDING
	BR SAVV2	;NOT THERE
SAVV1:	MOV -(E),A	;GET NEW VALUE PTR
	MOV B,-(D)	;SAVE OLD VALUE PO[NTER
	MOV A,B
	JSR PC,.LDP1
	BIC #100000,A	;MAKE SURE BINDING NODE SAYS "VBIND"
	JSR PC,.STORE	;STORE NEW BINDING AWAY
	RTS PC

SAVV3:	TST -(E)
	CLR -(D)	;THERE IS NO OLD VALUE POINTER
	RTS PC

SAVV2:	TST -2(E)
	BEQ SAVV3	;IF NEW VALUE = 0, DON'T BOTHER TO CREATE CELL
	MOV #VBIND,A
	CLR B
	JSR PC,GRBAD1
	BR SAVV1

SAVPPS:	POP F	;SAVE P AND S PDL PTRS
	SPUSH CSPDLP
	MOV #SDLINK,A	;COMPUTE RELATIVE S PDL PTR
	SUB S,A
	ADD SPRBAO,A
	MOV A,CSPDLP
	SPUSH CPDLP
	MOV #PDLINK,A	;COMPUTE RELATIVE P PDL PTR
	SUB P,A
	ADD PRBAO,A
	MOV A,CPDLP
	JMP @F

TINDNT:	PUSH A	;TRACE INDENT
	MOV FUNLEV,A
TIND2:	DEC A
	BGT TIND1
	JMP RETA
TIND1:	SPACE
	BR TIND2

LOCAL:	JSR PC,GUOEB	;GET UOE PTR FROM S
	BR .+2
	BR LOC9
	JSR PC,.INTRN
	BR .+2
LOC9:	MOV #SDLINK,F	;MOVE STUFF FROM S TO P PDLS
	SUB S,F
	ADD SPRBAO,F
	MOV CSPDLP,D
	BIC #1,D
	SUB D,F
	ASR F
	MOV F,A
	BLE LOC2
LOC1:	POPS D
	PUSH D
	DEC A
	BGT LOC1
LOC2:	MOV S,D	;NOW STORE AWAY PTR & OLD VALUE
	PUSHS #0
	MOV S,E
	PUSHS #0
	JSR PC,SAVVAR
	MOV F,A	;NOW RETURN STUFF FROM P TO S
	BLE LOC4
LOC3:	POP D
	PUSHS D
	DEC A
	BGT LOC3
LOC4:	MOV #PDLINK,A	;NOW MOVE STUFF FROM P TO S
	SUB P,A
	ADD PRBAO,A
	MOV CPDLP,D
	BIC #1,D
	SUB D,A
	ASR A
	MOV A,F
	BLE LOC6
LOC5:	POP D
	PUSHS D
	DEC A
	BGT LOC5
LOC6:	PUSH #1	;PUSH GOODIES ON P
	SPUSH CSPDLP
	SPUSH CPDLP
	BIC #1,CPDLP	;INDICATE LOCAL PUSH
	BIC #1,CSPDLP
	ADD #4,CSPDLP
	ADD #6,CPDLP
	MOV F,A
	BLE LOC8
LOC7:	POPS D	;NOW RETURN STUFF TO P
	PUSH D
	DEC A
	BGT LOC7
LOC8:	RTS PC


;CHECK (E) FOR VALID DATA TYPE IF CHEKUF ON
CKSARG:	BIT #CHEKUF,FLAGS2
	BNE .+4
	RTS PC

	SPUSH D		;D & E ARE USED
	SPUSH E
	MOV #CKLIST,D	;THIS RUNS THROUGH THE VALID TYPES
	MOV (E),E	;GET THE DATUM
	BIC #7777,E	;ITS TYPE
CKSAR1:	CMP (D)+,E	;IS THIS A VALID TYPE?
	BEQ CKSRET	;AHA! IS!
	TST (D)		;MORE VALID TYPES?
	BNE CKSAR1	;THERE ARE
	.BUG.		;THERE AIN'T--*DIE*

CKSRET:	SPOP E		;WELL AND GOOD--IT'S VALID.
	SPOP D
	RTS PC

.STITL PROC EVAL - "OUTPUT" "STOP"
OUTPUT:	TST FUNLEV
	BGT .+4
	ERROR+OIP	;ONLY IN PROCEDURE
	MOV #PSORT,PSTOPR ;"OUTPUT"
	POPS TOPS1	;SAVE THE OUTPUT
	BR PSTP10
STOP:
PSTOP:	TST FUNLEV
	BGT .+4
	ERROR+OIP	;ONLY IN PROCEDURE
	MOV #PSNORT,PSTOPR	;"STOP" AND "END"
	CLR TOPS1
PSTP10:	BIT #TPTF+TPSF,FLAGS
	BNE PSTP11
	BIT #TRACEF,FLAGS2
	BEQ PSTP15
PSTP11:	JSR PC,TINDNT
	MOV CPP,B
	JSR PC,PPNAME
	MOV TOPS1,B
	BEQ PSTP13
	PRTXT ^\ OUTPUTS \
	INC NBKTS
	JSR PC,PNODAB	;USES A
	DEC NBKTS
	PRCR
	BR PSTP15
PSTP13:	PRTXTC ^\ STOPS.\
PSTP15:	JSR PC,RESPPS	;RESTORE PDLS
	BIT #TF7,TFLAGS	;IF IT WAS AN ERROR SET FRAME, IGNORE IT
	BNE PSTP15
PSTP21:
	SPOP D	;# ARGS SAVED
	BEQ PSTOP4	;NO ARGS
PSTOP3:	POPS E	;GET OLD VARIBLE BINDING
	SPOPS B	;GET NEXT UOE PTR
	TST E
	BNE PSTP31
	MOV #VBIND,A
	JSR PC,.UNBND
	BR .+2
	BR PSTP33
PSTP31:	JSR PC,.BNDVN	;GET VARIB BINDING PTR
	JMP PSTPE1	;NONE THERE
	MOV E,B		;GET OLD VARIB BINDING
	JSR PC,.STORE	;RESTORE OLD BINDING
PSTP33:	DEC D
	BGT PSTOP3
PSTOP4:	BIT #TF3,TFLAGS	;WAS IT A LOCAL PUSH OR PROC PUSH
	BEQ PSTP15	;LOCAL
	CMP #PSORT,PSTOPR	;WAS IT "OUTPUT"
	BNE PSTP42	;NO
	PUSHS TOPS1	;PUT THE OUTPUT BACK ON S
	CLR TOPS
	CLR TOPS1
PSTP42:	POP ERPROC	;PROC, RESTORE REST OF WORLD
	SPOP IFLEV
	SPOP CO+2
	SPOP CO
	SPOP FLAGS
	SPOP CTP
	SPOP CTN
	SPOP CLGN
	POP CLP
	SPOP CPLN
	SPOP CPSN
	SPOP CPP
	DEC FUNLEV	;IF AT TOP LEVEL, ALMOST DONE!
	BLE PSTOP9
PSTP43:	MOV CPP,B
	JSR PC,.BINDF	;MAKE SURE PROC IS IN
	BR PSTPE2	;PROCEDURE ... NOT HERE
	MOV CPP,B	;SEE IF PROC'S CPSN AGREE
	JSR PC,GNASN	;GET CPSN
	BR PSTPE3	;IMPOSSIBLE!!!
	MOV CLP,C
	BIS #TF3,TFLAGS
	CMP A,CPSN
	BEQ PSTP41	;OK
	BIC #TF3,TFLAGS
	MOV CPLN,B	;DON'T AGREE, GO RELOCATE LINE WE WERE IN
	JSR PC,GTLINE
	BR PSTOP5	;LINE NOT THERE
PSTP41:	MOV C,CLP
	JSR PC,.LOADC	;GET LLP NODE
	JSR PC,.LOAD	;GET LINE #
	MOV A,C
	JSR PC,.LOADC	;GET NEXT NODE-SEE IF SNUM (I.E. GEN NO.)
	BIC #7777,A
	CMP #SNUM,A
	BEQ .+4
	CLR B	;NOT SNUM, SO SET GEN NO. TO 0
	CMP B,CLGN	;ARE GEN #'S =?
	BEQ .+4
PSTOP5:	BR PSTPE4	;NO, LINE CHANGED BY EDIT
	BIT #TF3,TFLAGS	;IF PROC WASNT SWAPPED
	BEQ PSTOP8	;THEN CTP IS GOOD
PSTOP9:	CLR D
	MOV CTP,C
	BR PSTOP6
PSTOP8:	MOV CTN,D	;OK, NOW GET NODE NO.
	TST B	;IF B > 0, WE WERE LOOKING GEN NO.
	BEQ PSTOP6
	JSR PC,.LDP1
PSTOP7:	MOV A,C
PSTOP6:	JSR PC,.LOADC
	DEC D
	BGT PSTOP7
	MOV C,CTP
	MOV A,CT
	MOV B,CT+2
	JMP @PSTOPR
PSORT:	SKPRET
PSNORT:	RTS PC

PSTPE1:	JSR PC,CHKER
	.BUG.		;NO VARIABLE BINDING
PSTPE2:	JSR PC,CHKER
	ERROR+PNH1	;POPPED PROCEDURE NOT HERE
PSTPE3:	JSR PC,CHKER
	.BUG.		;PROCEDURE STRUCTURE SCREWED
PSTPE4:	JSR PC,CHKER
	ERROR+LCE	;LINE CHANGED BY EDIT

RESPPS:	SPOP E	;RESTORE P AND S PDLS
	MOV CPDLP,A
	BIC #TF3+TF7,TFLAGS ;SAVE MODE OF PROC/LOCAL PUSH FLAG
	BIT #1,A
	BEQ .+10
	BIS #TF3,TFLAGS
	BIC #1,A	;ALWAYS EVEN
	JSR PC,PPTA	;POP P TO (A)
	POP CPDLP	 ;RESTORE OLD CPDLP
	MOV CSPDLP,A
	BIT #1,A
	BEQ .+10
	BIS #TF7,TFLAGS
	BIC #1,A
	JSR PC,PSTA	;POP S TO (A)
	SPOP CSPDLP	;RESTORE OLD CSPDLP
	JMP @E

CHKER:	BIT #HERRF,FLAGS2  ;THIS IS A TERRIBLE THING TO HAPPEN
	BNE CKHER1	;AND IT'S HAPPENED BEFORE!
	BIS #HERRF,FLAGS2  ;OR IF NOT, "DON'T LET IT HAPPEN AGAIN!"
	RTS PC
CKHER1:	CPRTXT ^/HELP!!  RECURSIVE BUG!/
	JSR PC,PPLACE
	CLR CPP
	CLR FUNLEV
	CLR IFLEV
	CLR FLAGS
	JMP ERTL3	;CLEAN UP THE WORLD

DO:	MOV @S,A	;DO...
	MOV A,B
	BIC #7777,A
	CMP #LIST,A
	BEQ DO1
	ERROR+WTAB
DO1:	JSR PC,BLSTI
	PUSH PCHR
	MOV #BLST,PCHR
	CLR NBKTS
	JSR PC,PNODAB	;CONVERT THING ON S TO STRING ON S
	POP PCHR
	JSR PC,BLSTF
	BR DO3	;EMPTY STRING
	MOV TOPS,@S
DO2:	JSR PC,READ	;CONVERT STRING ON S TO TOKEN LIST ON S
	BR DO4	;NO TOKENS
	JSR PC,SAVEVL
	JSR PC,EVLINE
	BR DO5
	POPS A
	MOV #PSNORT,PSTOPR
	BR DO6
DO5:	POPS A
	MOV A,@S	;GET THE "OUTPUT"
	MOV #ORT,PSTOPR
DO6:	JSR PC,RESEVL
	CLR D
	MOV CTP,C
	JMP	PSTOP6
DO3:	POPS A
DO4:	RTS PC
SAVEVL:	POP F
	PUSH FLAGS
	SPUSH CO
	SPUSH CO+2
	SPUSH NOR
	SPUSH COF
	SPUSH LO
	SPUSH LO+2
	SPUSH CTP
	SPUSH CTN
	JMP @F
RESEVL:	POP F
	SPOP CTN
	SPOP CTP
	SPOP LO+2
	SPOP LO
	SPOP COF
	SPOP NOR
	SPOP CO+2
	SPOP CO
	SPOP B
	BIC #EVIFS,FLAGS
	BIC #-EVIFS-1,B
	BIS B,FLAGS
	JMP @F
	.STITL "TO" ETC.
GTLN:	JSR PC,GTUOEB	;GET LINE # FROM NEXT TOKEN INTO B
	BR .+4
	RTS PC
	MOV #SNUM,A
	JSR PC,CONVER	;MAKE NEXT TOKEN INTO AN SNUM
	RTS PC
	SKPRET
GTLP:	PUSH CPP	;GET LINE PTR OF LINE (B) FOR PROC (TOPRNM)
	MOV TOPRNM,CPP	;LEAVE PTR IN C
	JSR PC,GTLINE
	BR GTLP1
	POP CPP
	SKPRET
GTLP1:	POP CPP
	RTS PC
EDTITL:	TST TOPRNM
	BNE .+4
	ERROR+OIP	;ONLY IN PROCEDURE
	JSR PC,EDITA	;SET UP FOR EDIT BUFFER INSERT
	PUSH PCHR
	MOV #ETYO,PCHR
	MOV TOPRNM,B
	JSR PC,SHTITL	;"PRINT" TITLE LINE INTO EDIT BUFFER
	.BUG.
	JSR PC,EDITE	;CLEAN UP EDIT BUFFER INPUT
	BIS #EDTIF2,FLAGS
	POP PCHR
	RTS PC
EDLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GET LINE # IN B
	ERROR+ELW	;EDIT LINE WHAT
	JSR PC,GTLP	;GET PTR TO THAT LINE
	ERROR+LDE	;LINE (B) DOESNT EXIST
	JSR PC,EDITA
	PUSH PCHR
	MOV #ETYO,PCHR
	JSR PC,.LOADC	;GET PTR TO LINE (IN LLP NODE)
	PUSHS B	;FOR INPUT TO PRLN
	JSR PC,PRLN	;"PRINT" THE LINE TO THE EDIT BUFFER
	POPS B
	JSR PC,EDITE
	POP PCHR
	RTS PC
EDIT2:	CMP #TYI,GCHR
	BNE EDIT3
	CMP #INFIX,A
	BHIS .+4
	ERROR+WTAB
	ERROR+UBL
EDIT3:	JSR PC,CVSFLS
	MOV TOPS,B
	JSR PC,GRBAD
	MOV C,TEMP
	BIS #LIST,C
	MOV C,TOPS2
	BR TO86
EDIT1:	CMP #$TITLE,B
	BEQ EDTITL
	CMP #$LINE,B
	BEQ EDLINE
		;NOT A VALID EDITING COMMAND
	TST B	;IS THIS A CR?
	BEQ .+4
	ERROR+NEC
	BIS #EDITF,FLAGS
	MOV LASTPR,B
	BNE TO0
	ERROR+UELX
EDIT:	BIC #EDTIF,FLAGS
	JSR PC,GTUOEB	;LOOK AT NEXT TOKEN
	BR EDIT1	;NOT A UOE
	BIS #EDITF,FLAGS
	BR TO0
TO:	BIC #EDITF,FLAGS
	JSR PC,GTUOEB	;GET UOE PTR FROM NEXT TOKEN
	BR EDIT2
	BIC #170000,B
	BIS #UFUN,B
	MOV B,TOPS2	;SO THIS "TOTALLY WORTHLESS ATOM WONT BE G.C.
	JSR PC,TITLDF
TO0:	TST TOPRNM
	BEQ TO8
	MOV FNLLP,TMPBLK
	BIT #EDTIF,FLAGS
	BNE TO8
	ERROR+CTIT	;CANT "TO" IN TO
TO8:	MOV B,TEMP
	CLR TOPS
	JSR PC,.BINDF
	BR TO6
	BIT #EDTIF,FLAGS
	BEQ TO84
	CMP TOPRNM,TEMP
	BNE TO85
	MOV TOPS1,A
	BIS #LIST,A
	JSR PC,.STP2
	MOV TOPS1,B
	BR TITED1
TO84:	MOV A,FNLLP
	BIT #EDITF,FLAGS	;IS IT "EDIT"?
	BNE TO5	;YES
	CMP #TYI,GCHR	;IS INPUT FROM TTY?
	BNE .+4
	ERROR+PAE	;YES - PROCEDURE ALREADY EXISTS
TO86:	BIS #SPDF,FLAGS	;NO - SET SKIP PROC DEF. FLAG
	MOV TEMP,TOPRNM
TO81:	BIT #CRF,FLAGS
	BNE TO82
	JSR PC,GNT	;READ TO END OF LINE
	BR TO81
TO82:	CLR TOPS
	CLR TOPS1
	CLR TOPS2
	RTS PC
TO7:	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
	JSR PC,.LOAD
	MOV A,FNLLP
TO5:	MOV TEMP,TOPRNM
	MOV #'>,PRMTCH
	BR TO82
TO6:	BIT #EDTIF,FLAGS	;EDITING TITLE?
	BNE TITED
	BIT #EDITF,FLAGS	;IS IT "EDIT"
	BEQ TO7	;NO
	ERROR+PNH	;YES, PROCEDUTE NOT HERE
TO85:	ERROR+PAE	;PROC (TEMP) ALREADY EXISTS
TITED:	;EDIT THAT TITLE...
	MOV #FBIND,A
	MOV TOPS1,B
	BIS #LIST,B
	JSR PC,GRBAD1
TITED1:	JSR PC,.LOAD
	MOV A,FNLLP
;MAKE NEW PROC POINT TO OLD LINES
	MOV A,C
	MOV TMPBLK,B
	JSR PC,.LOAD
	JSR PC,.STP1
	CMP TEMP,TOPRNM
	BEQ TITED2
	MOV TOPRNM,B
	MOV #FBIND,A
	JSR PC,.UNBND
	.BUG.	;THIS UOE MUST HAVE A PROC BINDING
	MOV TEMP,TOPRNM
TITED2:	BR TO82
GO:	MOV CPLN,JPLN	;SAVE CURRENT LINE # AS LINE JUMPED-FROM
	JSR PC,G1NARG
	MOV B,CPLN
	CLR CLP
	CLR CT
	CLR CT+2
	BIC #RTF,FLAGS
	RTS PC

RETURN:	JSR PC,G1NARG
	MOV B,TMPBLK
	MOV #RETU1,PSTOPR
RETU1:	TST FUNLEV
	BEQ PROCE1
	JSR PC,RESPPS	;RESTORE PDLS
	BIT #TF7,TFLAGS	;WAAS IT AN ERROR FRAME?
	BNE .+6	;YES
	JMP PSTP21	;NO
	POP ERPROC
	MOV TMPBLK,CPLN
	CLR CTN	;SET UP TO RESTART AT BEGINNING OF LINE
	MOV #-1,CPSN
	MOV #RETU2,PSTOPR
	BR PROCE2
RETU2:	CLR CTP
	CLR CLP
	JMP MLOOP
CONTINUE:	MOV #MLOOP,PSTOPR
PROCE2:	TST FUNLEV
	BEQ PROCE1
	MOV CPDLP,A
	BIC #1,A
	JSR PC,PPTA
	MOV CSPDLP,A
	JSR PC,PSTA
	BIC #BRKF,FLAGS
	JMP PSTP43	;TRY RESTARTING
PROCE1:	JMP ERTL3

GTUOEB: 	JSR PC,GNT	;GET UOE PTR FROM NEXT TOKEN IN B
	BIC #7777,A	;SKIP UNLESS NEXT TOKEN NOT UOE.  USES A
	BIT #CRF,FLAGS
	BEQ .+4
	ERROR+UEL	;UNEXPECTED END OF LINE
	CMP #UFUN,A
	BEQ GTU1
	CMP #ATOM,A
	BEQ GTU1
	CMP #LSTR,A
	BNE GTU2
	MOV B,TOPS
	JSR PC,.INTRN
	BR .+2	;INTERN SKIPS
GTU1:	CLR TOPS
	SKPRET
GTU2:	RTS PC
TITLDF:		;INPUT-CURRENT TOKEN LIST VIA GNT
		;OUTPUT-TOPS1  - POINTS TO FIRST NODE OF LLP
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	MOV CT,TEMP
	CLR D
TO3:	JSR PC,GNT
	BIT #CRF,FLAGS
	BNE TO4	;DONE
	BIC #7777,A
	INC D
	CMP #UVAR,A
	BEQ TO3
	ERROR+WIT	;WRONG TYPE OF INPUT TO "TO"
TO4:	CMP #MAXARG,D
	BGE TO9
	ERROR+TMAP	;TOO MANY ARGS (PROCEDURE)
	CLR D	;THIS ERROR RETURNS HERE!!
	CLR TEMP
TO9:	MOV #LIST,A
	MOV A,B
	JSR PC,GRBAD	;ZEROTH NODE IN LLP - PTS TO SWAP INFO
	MOV C,TOPS1	;SAVE - PTR TO LLP
	MOV #SNUM,A
	MOV D,B
	JSR PC,GRBAD2	; - # ARGS NODE
	CLR B
	JSR PC,GRBAD1	; - CPSN NODE (START CPSN AT 0)
	MOV TOPS1,C
	MOV #LIST,A
	MOV A,B
	JSR PC,GRBAD1	;FIRST NODE OF LLP - POINTS TO ARG LIST
	MOV TEMP,A
	BIC #170000,A
	BIS #SNUM,A
	MOV D,B	;# ARGS SAVED ABOVE
	JSR PC,GRBAD2	;FIRST NODE OF LINE 0 (ARG LINE)
	JMP RETD
END:	MOV TOPRNM,B
	BNE .+4
	ERROR+OIPD	;ONLY IN PROCEDURE DEFINITION
	MOV B,LASTPR	;SAVE FOR "PO"
.IFNZ FILES
.IIF NZ OFILES,	TST DSKNCH
.IIF NZ NFILES,TST REDFLG
	BEQ END4
	BIT #SPDF,FLAGS
	BEQ END3
.ENDC
END4:	TST FUNLEV	;DON'T PRINT "FOO DEFINED" IF NOT AT TOP LEVEL
	BEQ END5
	BIT #BRKF,FLAGS
	BEQ END3
END5:	JSR PC,PPNAME
	BIT #SPDF,FLAGS
	BNE END1
	PRTXTC ^\ DEFINED\
END3:	CLR TOPRNM
	BIC #SPDF,FLAGS
	MOV #'?,PRMTCH
END2:	RTS PC
END1:	PRTXTC ^/ SKIPPED/
	BR END3
	.STITL UTILITY - COUNT LIST ELEMENTS
CLE:		;COUNT LIST ELEMENTS
		  ;IN - LIST PTR IN C
		 ;OUT - # OF ELEMENTS IN B
	PUSH A
	SPUSH C
	CLR B
	MOV C,A
CLE1:	BIT #7777,A
	BEQ CLE2
	MOV A,C
	JSR PC,.LDP1
	INC B
	BR CLE1
CLE2:	POP C
	SPOP A
	RTS PC
	.STITL UTILITY - ADD A LINE
ADLN:		;ON S IS A "NEW LINE" INSERT IN PROPER PLACE
		;IN LLP POINTED TO BY FNLLP.
		;IF "NEW LINE" # IS NEG, DELETE THE LINE
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	MOV @S,C
	JSR PC,.LOADC
	MOV B,F	;SAVE LINE #
	BLT ADLN6	;IF < 0, THIS IS A DELETE
	BIC #TF4,TFLAGS
ADLN7:	MOV FNLLP,C
	JSR PC,.LOADC	;SKIP OVER ARG LINE
	MOV C,D
	MOV A,C
	;LOOK DOWN LLP FOR LINE #(@P)
ADLN1:	MOV D,E	;SAVE PTR TO PREDECESSOR IN E
	MOV C,D	;SAVE PTR TO CURRENT IN D
	MOV #LIST,A
	BIT #7777,C
	BEQ ADLN2	;AT END, ADD NEW NODE
	JSR PC,.LOADC
	MOV A,C	;SAVE PTR TO SUCCESSOR IN C
	JSR PC,.LOAD
	CMP B,F
	BLT ADLN1	;NOT THERE YET
	BEQ ADLN3	;FOUND LINE
	MOV D,A	;OTHERWISE, INSERT NEW LINE
ADLN2:	BIT #TF4,TFLAGS	;PASSED IT - IF DELETE
	BNE ADLN5	;ALL DONE
	MOV @S,B	;ADD NEW NODE TO END
	MOV E,C
	JSR PC,GRBAD1
ADLN5:	JMP RETF
ADLN3:	BIT #TF4,TFLAGS	;FOUND LINE NO.  DELETE?
	BEQ ADLN31	;NO
	MOV C,A	;YES
	MOV E,C
	JSR PC,.STP1
	BR ADLN5
		;NOT DELETE, REPLACE THEN CHECK GEN. NO.
ADLN31:	MOV A,E	;SAVE A, POINT TO FIRST TOKEN IN OLD LINE
	MOV @S,A
	MOV D,C	;D POINTS TO RELEVENT LLP NODE
	JSR PC,.STP2	;STORE LINK TO NEW LINE
	TST FUNLEV	;IF AT FUNLEV 0, DON'T BOTHER WITH GEN #
	BEQ ADLN5
	MOV E,C	;E POINTS TO OLD LINE
	JSR PC,.LOADC	;GET NEXT NODE IN OLD LINE(1ST TOKEN OR GEN )
	BIC #7777,A
	CMP #SNUM,A
	BEQ ADLN4
	CLR B
ADLN4:	INC B	;ALREADY HAS GEN NO.
	MOV @S,C
	JSR PC,.LDP1
	BIC #170000,A
	BIS #SNUM,A
	JSR PC,GRBAD1
	BR ADLN5
ADLN6:	NEG F
	BIS #TF4,TFLAGS
	BR ADLN7
	.STITL UTILITY - GET A LINE, GET ARGS
GTLINE:		;GET LLP POINTER OF LINE WHOSE NO. IS IN B
			;FOR PROCEDURE PONTED TO BY "CPP"
			;OUTPUT - LLP PTR WILL BE IN C AND WILL SKIP
	BIS #TF1,TFLAGS
	BR .+10
GNLINE:		;SAME EXCEPT LOOKING FOR LINE WHOSE # IS > # IN B
	BIC #TF1,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	MOV B,D
	MOV CPP,B
	JSR PC,.BINDF	;LOOK FOR PROC BINDING
	.BUG.	;WHAT NO PROC BINDING??!!
	JSR PC,.LOADA
	MOV A,E
GNL1:	BIT #7777,E
	BEQ GNL4	;NONE LEFT
	MOV E,C
	JSR PC,.LOADC	;GET NEXT NODE IN LLP
	MOV A,E
	JSR PC,.LOADB	;GET FIRST NODE OF THAT LINE
	CMP B,D
	BLT GNL1	;NOT THERE YET
	BEQ GNL2	;FOUND IT
	BIT #TF1,TFLAGS	;WENT PAST, WERE WE LOOKING FOR IT?
	BEQ GNL3	;NO, OK
GNL4:	JMP RETE	;YES "NO SUCH LINE NO."
GNL2:	BIT #TF1,TFLAGS	;FOUND IT, LOOKING FOR IT?
	BEQ GNL1	;NO, GET NEXT
GNL3:	MOV C,4(P)	;OUTPUT (C) INTO C
	JMP SRETE
GNASN:		;GET NO. OF ARGS AND CPSN OF USER PROC
		;IN: PROC PTR IN B
		;OUTPUT: CPSN IN A # IN B
		;DONT SKIP IF NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	JMP RETC
	JSR PC,.LOADB
	MOV B,2(P)	;# IN OLD B
	JSR PC,.LOADA
	MOV B,4(P)	;CPSN IN OLD A
	JMP SRETC
	.STITL UTILITY - LOAD AND STORE
.LOADA:	MOV A,B		;(A) -> A,,B
	BR .LOAD
.LOADC:	MOV C,B	;NODE ADDR IN C
		;NODE RETURNED IN A,B
.LOADB:
.LOAD:	BIC #170000,B	;NODE ADDR IN B
	ASL B	;NODE RETURNED IN A,B
	ASL B
	ADD #NODESP,B
	MOV (B)+,A
	MOV @B,B
	RTS PC
.STORE:	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ASL C	;NODE IN A,B IS STORED AT C
	ASL C
	ADD #NODESP,C
	MOV A,(C)+
	MOV B,@C
	SPOP C
	RTS PC

.STP2:		;SAME AS .STP1 EXCEPT STORE IN 2ND WORD OF NODE
	SEC	;THEN RESULT OF ROL'S WILL BE TWO GREATER THAN  .STP1
	BR .+4
.STP1:	CLC	;STORE (A) IN FIRST WORD OF NODE AT C
	SPUSH C	;NODE ADDR IN C
	BIC #170000,C
	ROL C
	ROL C
	ADD #NODESP,C
	MOV A,@C
	SPOP C
	RTS PC

.LDP2:	SEC		;NODE ADDR IN C (TYPE FIELD =0)
	BR .+4		;LOAD 2ND WORD OF NODE INTO A
.LDP1:	CLC		;SAME AS .LDP2 EXCEPT 1ST WORD
	MOV C,A
	BIC #170000,A
	ROL A
	ROL A
	ADD #NODESP,A
	MOV @A,A
	RTS PC

.LDP2I:	MOV C,A	;SAME AS .LDP2 EXCEPT C WILL
	BIC #170000,A	;CONTAIN ADDR OF NEXT NODE
	ASL A
	ASL A
	ADD #NODESP,A
	MOV (A)+,C
	MOV @A,A
	RTS PC
	.STITL UTILITY - BINDING
	;INPUT:	A=TYPE	B=UOE POINTER
	;		TOPS=0 OR TYPE+VALUE POINTER
	;OUTPUT:	A - UCHANGED
	;		B - EITHER UNCHANGED OR VALUE POINTER
	;		C - POINTS TO BINDING NODE, EITHER 
	;		    RELEVANT ONE OR LAST IN BINDING LIST
	;		IF TOPS = 0, SKIPS IF BINDING FOUND
	;		IF TOPS NOT = 0, TOPS WILL BE INSERTED
	;		   AS THE NEW VALUE POINTER (A NEW BINDING
	;		   NODE WILL BE ADDED IF NECESSARY) NEVER SKIPS.
.BINDL:	TST TOPS
	BEQ .BIND
	PUSHS TOPS
	CLR TOPS
	JSR PC,.BIND
	BR .BNDL2
	POPS TOPS
	SKPRET
.BNDL2L:	POPS TOPS
	RTS PC

.BIND:	PUSH D
	SPUSH B
	SPUSH A
	MOV B,A
BINDF1:	MOV A,C
	JSR PC,.LOADC
	MOV A,D
	BIC #7777,D
	CMP @P,D
	BEQ BINDF4	;FOUND IT
	BIT #7777,A
	BNE BINDF1
	TST TOPS	;DIDNT FIND IT
	BEQ BINDF2	;SHOULD ONE BE CREATED?
	SPOP A
	MOV TOPS,B
	JSR PC,GRBAD1
BINDF5:	POP D	;OLD B
BINDF3:	SPOP D
	RTS PC

BINDF2:	POP A	;NO, DONT CREATE NODE
	SPOP B
	BR BINDF3

BINDF4:	TST TOPS	;FOUND, CHANGE VALUE POINTER?
	BEQ BINDF6
	MOV TOPS,A	;YES + DONT SKIP
	JSR PC,.STP2
	POP A
	BR BINDF5

BINDF6:	POP A	;NO, LEAVE VALUE POINTER, BUT SKIP
	POP D	;OLD B
	POP D
	JMP SRET
.UNBND:	PUSH A	;ERASE TYPE (A) FROM UOE (B)
	SPUSH B	;SKIP UNLESS NOT FOUND
	SPUSH C
	SPUSH D
	MOV B,C
.UNB1:	MOV C,D
	MOV B,C
	BIT #7777,C
	BNE .+6
	JMP RETD
	JSR PC,.LOADC
	MOV A,B
	BIC #7777,A
	CMP 6(P),A
	BNE .UNB1
	MOV D,C
	JSR PC,.LDP1
	BIC #7777,A
	BIC #170000,B
	BIS B,A
	JSR PC,.STP1
	JMP SRETD
.BINDF:	MOV #FBIND,A	;GET FUNCTION BINDING, SWAP IN IF NECESSARY
		;PTR TO UOE IN B
		;OUTPUT AS IN .BIND: EXCEPT A,,B = NODE PTD TO BY C
	JSR PC,.BINDL	;LOOK FOR FUNCTION BINDING
	RTS PC	;PROC NOT DEFINED
	JSR PC,.LOADB
	BIT #7777,A	;IS PROC SWAPPED IN?
	BNE BIF1	;YEP
	JSR PC,PSWPIN	;GO GET IT
BIF1:	SKPRET

.BNDVN:		;GET VARIABLE BINDING
			;PTR TO UOE IN B
			;OUTPUT AS IN .BIND
	MOV #VBIND,A
	JSR PC,.BINDL	;LOOK FOR BINDING
	RTS PC		;NOPE
	SKPRET	;FOUND IT

.BNDFS:	MOV #FBIND,A	;SAME AS .BINDF EXCEPT DONT SWAPIN
	JSR PC,.BINDL
	RTS PC
	JSR PC,.LOADB
	SKPRET
	.STITL .INTRN!!
.OBSCH:		;SAME AS .INTRN EXCEPT WONT INSERT IF ENTRY ISNT FOUND
		;(ALSO SEE UOBSCH ON NEXT PAGE)
	BIC #TF5,TFLAGS
	BR .+10
.INTRN:		;(ALSO SEE UINTRN ON NEXT PAGE)
		;INPUT:  TYPE IN A, LSTR IN "TOPS"
		;OUTPUT:  IF TYPE IS UFUN OR SFUN,
		; SEARCH SYSTEM OBLIST FIRST.
		;  IF FOUND THERE, RETURN THAT PTR IN B,
		; MAKING TYPE OF A TO "SFUN".
		;  IF NOT FOUND THERE, AND IF A=UFUN, OR IF TYPE
		;  IS > "UFUN", DO THE LOOKUP IN THE USER OBLIST.
		;  RETURN WITH THE UOE PTR IN B.
		; DONT SKIP IF A NEW ONE HAD TO BE ADDED,
		;  OR IF IN SEARCHING FOR AN SFUN
		;  ONE WAS NOT FOUND.
;*******  NOTE  ********
;A NEW UOE IS "TOTALLY USELESS" AND SO MUST BE PROTECTED FROM G.C.
	BIS #TF5,TFLAGS
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
	CMP #UFUN,A	;IS TYPE SFUN OR UFUN
	BLO INT2	;NO
	JSR PC,SSOL	;YES, SEARCH SYSTEM OBLIST
	BR INT1	;NOT THERE
	MOV #SFUN,4(P)	;SET TYPE TO "SFUN"
	BR INT5

INT1:	CMP #SFUN,A	;IS A = TYPE SFUN
	BEQ INT0	;YES, DONE, DONT SKIP
INT2:	JSR PC,HSSL	;NO, HASH TO AND SEARCH SUBLIST
	BR INT3

INT5:	MOV B,2(P)
	JMP SRETC	;FOUND ATOM

INT3:	BIT #TF5,TFLAGS	;NOT THERE, SHOULD IT BE ADDED
	BEQ INT0	;NO, RETURN AND DONT SKIP
	SPUSH B		;SAVE WORD POINTER TO LAST NODE OF BUCKET
	MOV #BUKTEL,A
	MOV #ATOM,B
	JSR PC,GRBAD	;CONS UP NEW LAST NODE
			;  (STRANGE TYPE LEST GARBAGE COLLECT)
	BIS #LIST,C
	PUSHS C		;SAVE POINTER TO IT, ALSO FOR G.C.
	MOV #ATOM,A
	MOV TOPS,B
	JSR PC,GRBAD2	;CONS UP ATOM NODE; NEW BUCKET NODE PTS TO IT
	MOV C,4(P)	;SO WILL B ON RETURN
	POPS C
	BIC #LIST,C	;GET BACK POINTER TO NEW BUCKET NODE

	MOV #BUKTEL,A
	JSR PC,.STP1	;MAKE IT AN END-OF-BUCKET NODE
	BIS C,A		;OLE & PTR TO IT
	SPOP C		;TO OLD END-OF-BUCKET WORD
	MOV A,(C)

INT0:	JMP RETC


;"UNPURE" .INTRN AND .OBSCH
;BY "UNPURE" IT IS MEANT THAT THE INPUT STRING MAY INCLUDE
;NULL CHARACTERS
;SPECIFICATIONS ARE OTHERWISE IDENTICAL TO .INTRN AND .OBSCH

;ROUTINE TO PURIFY STRING
UINOB:	PUSH A
	PUSH B
	PUSH C
	MOV	TOPS,B
	JSR PC,CPYSTR	;OUTPUT POINTER IN B TO STRING WITH NO NULLS
	BIS #LSTR,B
	MOV	B,TOPS
	POP C
	POP B
	POP A
	RTS PC

UINTRN:	JSR PC,UINOB	;PURIFY STRING
	JMP .INTRN

UOBSCH:	JSR PC,UINOB	;PURIFY STRING
	JMP .OBSCH
	.STITL SEARCH SYSTEM OBLIST
SSOL:		;SEARCH SYSTEM OBLIST
		;INPUT:  C POINTS TO STRING
		;OUTPUT:  SKIP = FOUND AND SOE PTR IN B
		;  NO SKIP = NOT FOUND AND NO CHANGE
		;NULL MUST BE USED AS FILLER CHAR BUT NOT BE IMBEDDED
	PUSH A
	SPUSH B
	SPUSH C		; -> STRING (DESIRED PNAME)
	SPUSH D		; -> CURRENT PNAME
	SPUSH E		; 2^N
	SPUSH F		; -> SYSTEM OBLIST ELEMENT
	MOV SOBP2,E	;GET 2^N
	MOV #SOBLST,F	;GET START OF OBLIST
SSOL1:	ASR E		;HALVE 2^N
	BIT #177776,E	;NOT FOUND IF 2^N = 1
	BEQ SSOL5
	ADD E,F		;ADD 2^N TO OBLIST PTR
	CMP F,SOOMX	;OVERSHOT END OF LIST THEN UNDO ADD
	BHIS SSOL2
	MOV @F,D
	ADD #4+SOBLST,D	;FIND START OF THIS PNAME
	MOV C,A		;AND DESIRED PNAME
SSOL4:	JSR PC,.LOADA	;GET TWO CHARS OF DESIRED
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED:  ADD 2^(N-1)
	BLO SSOL2	;PNAME > DESIRED:  UNADD 2^N AND ADD 2^(N-1)
	SWAB B
	CMPB B,(D)+
	BHI SSOL1	;PNAME < DESIRED
	BLO SSOL2	;PNAME > DESIRED
	BIT #7777,A	;MORE PNAME TO COMPARE?
	BNE SSOL4	;YES
	TSTB B		;MATCHING NULLS FOUND?
	BEQ SSOL3	;FOUND
	TSTB (D)	;AT END OF STRING, IS IT END OF SYS PNAME
	BNE SSOL2	;NO:  TRY ANOTHER (COUNT AS OVERSHOOT)
SSOL3:	MOV (F),F	;POINTER TO OBLIST ELEMENT
	CMP #1,SOBLST(F)	;IS IT AN ABBRVIATION?
	BNE .+6
	MOV 2+SOBLST(F),F	;YES, "EXPAND" IT
	MOV F,10(P)	;YES, SAVE F AS OUTPUT
	JMP SRETF

SSOL5:	JMP RETF

SSOL2:	SUB E,F		;UNADD 2^N
	BR SSOL1
	.STITL HASH AND SEARCH USER SUB-OBLIST
HSSL:		;HASH, THEN SEARCH SUB-LIST
		;INPUT:  C POINTS TO LSTR
		;OUTPUT:  IF NOT FOUND, B IS A WORD POINTER
		;	 TO LAST BUCKET ELEMENT.
		;  IF FOUND, B POINTS TO ATOM CELL, AND RETURN SKIPS.
	PUSH A
	SPUSH B		;PTR TO THIS PNAME
	SPUSH C		;PTR TO DESIRED PNAME
	SPUSH D		;NEXT OLE
	SPUSH E		;THIS OLE
	MOV C,A		;PTR TO STRING
	CLR D		;SUM OF WORDS FOR HASHING
HSSLA:	JSR PC,.LOADA	;GET A TWO-LETTER FRAGMENT
	ADD B,D		;ADD IN
	BIT #7777,A	;MORE FRAGMENTS?
	BNE HSSLA	;YES
	MOV D,B		;CREATE SUM OF ALL CHARS
	SWAB B
	ADD D,B		;IN LOWER BYTE (UPPER WON'T HURT)
.IFNZ A1120
	MOV #MQ,A	;DIVIDE SUM BY A PRIME (CURRENTLY 67.)
	MOV B,(A)	;DIVIDEND IS 0,,SUM
	CLR -(A)
	MOV #HCC,-(A)
	MOV AC,B	;GET REMAINDER = BUCKET #
.IFF
	CLR A
	DIV #HCC,A
.ENDC
	ASL B
	ADD #UHCT,B
	MOV B,E		;RETURN ADDR OF LAST ELEMENT OF BUCKET IF NOT FOUND
	MOV @B,A	;A POINTS TO FIRST OLE NOW
HSSL1:	BIT #7777,A	;END OF BUCKET?
	BNE HSSLB
	MOV E,6(P)	;YES: NOT-FOUND RETURN:
	JMP RETE	;OUTPUT END-OF-BUCKET POINTER IN B

HSSLB:	MOV A,E		;SAVE PTR TO THIS OLE
	JSR PC,.LOADA	;GET THIS OLE
	MOV A,D		;SAVE PTR TO NEXT ONE
	JSR PC,.LOADB	;GET FIRST NODE OF ATOM STRUCTURE
	JSR PC,CSEQ	;CSEQ COMPARES STRINGS AT (B) AND (C)
	BR HSSL2	;NOT EQUAL:  TRY NEXT OLE
	MOV E,A		;EQUAL:
	JSR PC,.LOADA	;OUTPUT ATOM POINTER
	MOV B,6(P)
	JMP SRETE	;SKIP RETURN

HSSL2:	MOV D,A		;NOT FOUND, CHECK NEXT BUCKET ELEMENT
	BIC #LIST,E	;MAKE E A WORD PTR TO FIRST WORD OF PREV. NODE
	ASL E		;IN CASE IT'S THE LAST ONE.
	ASL E
	ADD #NODESP,E
	BR HSSL1
CSEQ:	PUSH A		;COMPARE TWO STRINGS - POINTERS IN B & C
	PUSH B		;SKIP IF EQUAL
	PUSH C		;"NULL" (8-BIT ON) CHARACTERS
	PUSH D		;  DON'T MATCH CORRESPONDING 8-BIT OFF CHARS
	MOV B,D		;SAVE STR 1 PTR
CSEQ1:	BIT #7777,D	;CHECK IF EITHER STRING DONE
	BEQ CSEQ3	;FIRST IS:  IS SECOND?
	BIT #7777,C
	BEQ CSEQ2	;SECOND BUT NOT FIRST:  NOT EQUAL
	MOV D,A
	JSR PC,.LOADA	;GET NEXT NODE OF STR 1: (A) TO A,,B
	MOV A,D	;SAVE POINTER IN D
	JSR PC,.LDP2I	;GET NEXT NODE OF STR 2: (C) TO C,,A
	CMP A,B
	BEQ CSEQ1	;WELL, THESE WORDS MATCH
CSEQ2:	JMP RETD	;STRINGS NOT EQUAL

CSEQ3:	BIT #7777,C	;SEE IF BOTH STRINGS ARE DONE
	BNE CSEQ2	;NOPE, NOT EQUAL
	JMP SRETD	;STRINGS EQUAL
	.STITL MINI SWAPPING
PSWPIN:	BPT
PSWPOT:	BPT
VSWPIN:	BPT
VSWPOT:	BPT
DSVB:	BPT	;DELETE SWAPPED VARIABLE BINDING
	.STITL UTILITY - GRAB NODE ROUTINES
GRBAD2:	SEC	;GRAB A FREE NODE, FILL IT WITH A,,B
			;IF C NOT =0, PUT PTR TO NEW NODE IN WORD 2 OF NODE(C)
			;C ALSO GETS POINTER TO NEW NODE REGARDLESS
	BR .+6
GRBAD:	CLR	C	;SAME AS ABOVE EXCEPT NEW POINTER ALWAYS IN C
GRBAD1:	CLC	;SAME AS ABOVE EXCEPT NEW PTR IN WORD 1
	SPUSH A
	BIC #170000,C
	BEQ GRB2	;C IS ZERO, FORGET STORING NEW NODE PTR
	ROL C
	ROL C
	ADD #NODESP,C	;ELSE MAKE NODE ADDRESS TO STORE AT
GRB2:
;	MOV UNGRAB,A
;	BNE GRB1	;IDLE THEN?
;	JIGGLE
	BIT #MGCF,FLAGS2
	BNE GRB4
	MOV FREE,A
	BNE GRB1
GRB4:	JSR PC,.GCOLL
	MOV FREE,A
	BNE GRB1
	CLR ERPROC	;DISABLE ERRSET IF 0 NODES
	ERROR+NSL	;NO STORAGE LEFT
GRB1:	DEC NNIFSL
	BGE .+4		;NEG NODES LEFT??
	.BUG.
;	CLR UNGRAB
	TST C
	BEQ GRB3
	BIC #170000,A
	BIC #7777,@C
	ADD A,@C
GRB3:	MOV A,C
	JSR PC,.LDP1
	SPUSH A		;CHECK THAT NODE WAS IDLE
	BIC #7777,A
	CMP #IDLE,A
	BEQ .+4
	.BUG.		;GRABBED AN UNIDLE NODE!!!!!
	SPOP A
	BIC #170000,A
	MOV A,FREE
	SPOP A
	JSR PC,.STORE
	RTS PC
	;.STITL UTILITY  -  FREE NODE ROUTINES
.FREE:	SPUSH A	;RETURN NODE IN C TO FREE STORAGE
	SPUSH B
	MOV FREE,A
	BIS #IDLE,A
	CLR B		;MAKE SURE POINTER 2 IS ZERO
	JSR PC,.STORE
	BIC #170000,C
	MOV C,FREE
	INC NNIFSL
	SPOP B
	SPOP A
	RTS PC
FRELST:	BIT #7777,TOPS	;RETURN LIST (TOP-LEVEL ONLY) IN TOPS
			;TO FREE STORAGE
	BNE .+4
	RTS PC
	PUSH A
	SPUSH B
	SPUSH C
	MOV TOPS,C
FRL1:	JSR PC,.LOADC
	JSR PC,.FREE
	BIT #7777,A
	BEQ FRL2
	MOV A,C
	BR FRL1
FRL2:	CLR TOPS
	JMP RETC
