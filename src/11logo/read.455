	.STITL READ A STRING
	FOO==%FNAM2
	VERN=VERN+%FNAM2

RDSTR7:	BIS #RBRKF,TFLAGS
	SEZ
RDSTR8:	RTS PC
RDSTR1:	PRCR	;OUTPUT - PTR ON S, SKIP UNLESS EMPTY OR BREAK
RDSTR:	CLR NBKTS
	MOV USER,U
	TST	BRAKE(U)
	BNE RDSTR7
	CMP #TYI,GCHR	;WILL CHARS BE COMING FROM TTY?
	BNE RLINE1	;NO
	MOV PRMTCH,D
	BEQ	RLINE
;	TST ALEVN
;	BEQ RLINE2
	BIT #BRKF,FLAGS
	BEQ RLINE2
	MOV FUNLEV,A
	BEQ RLINE2
LANGC	<MOV #'L,D>,<
	MOV #'N,D>
	JSR PC,TYO
	JSR PC,PRDN
	MOV PRMTCH,D
RLINE2:	JSR PC,TYO
RLINE:	TST USER
	BLT RLINE1
	PUSH	U
	MOV	USER,U
	JSR	PC,SLINE
	MOV	#FRTYIH,FLSRES(U)
	JSR	PC,FLUSH
	JSR	PC,RUNME
	POP	U
RLINE1:	JSR PC,BLSTI
RDSTR2:	JSR PC,@GCHR
	CMP #TYI,GCHR
	BEQ RDST2A
	CMP #2,D	;NOT FROM TTY: CHANGE ^B TO %
	BNE RDST2A	;(PRINTS AS SPACE STILL)
RDST2A:	TST	BRAKE(U)
	BNE	RDSTR7
	CMP #EOFCHR,D
	BNE RDSTR9
	MOV #TYI,GCHR	;NON-TTY INPUT DONE
	MOV #'],D	;FILL IN MISSING ]'S
	TST NBKTS
RDSR10:	BLE RDSTR4
	JSR PC,BLST
	DEC NBKTS
	BR RDSR10
RDSTR9:	CMP TBKCH,D	;BREAK TYPED?
	BEQ RDSTR7	;YES
	TST NBKTS	;IN A LIST?
	BGT RDSTR3	;YES
	CMP #15,D	;CR?
	BEQ RDSTR4
RDSTR3:	CMP #'[,D
	BNE RDSTR6
	INC NBKTS
RDSTR6:	CMP #'],D
	BNE RDSTR5
	DEC NBKTS
RDSTR5:	JSR PC,BLST
	BR RDSTR2
RDSTR4:	BIC #RBRKF,TFLAGS
	JSR PC,BLSTF
	BEQ RDSTR8
	PUSHS TOPS
	CLR TOPS
RDSTSR:	CLZ
	RTS PC

	.STITL REQUEST, FILE READ & WRITE
RQUEST:
RQU1:	PUSH PRMTCH
	JSR PC,INPUTL
	BEQ RQU5
	MOV E,C	;E POINTS TO LAST NODE OF STRING
	JSR PC,.LOADC	;NEED TO ADD A "]", IS THERE ROOM?
	BIT #177400,B
	BNE RQU2	;YES
	BIS #']*400,B	;NO - PUT A "]" THERE
	JSR PC,.STORE
RQU3:	MOV @S,GNCN
	BIC #170000,GNCN
	JSR PC,RDLST
	POPS TOPS
RQU4:	MOV TOPS,@S
	CLR TOPS
RQUR:	POP PRMTCH
	CLZ
	RTS PC
RQU2:	MOV #'],B
	JSR PC,GRBAD1
	BR RQU3
RQU5:	MOV #LIST,@S
	BR RQUR
INPUTL:	MOV #'<,PRMTCH
	MOV USER,U
	MOV UTTY(U),A
	TST CHARNO(A)
	BEQ .+6
	CLR PRMTCH
	JSR PC,RDSTR
	BNE IPUL2
IPUL1:	BIT #RBRKF,TFLAGS
	BEQ IPUL3
	POP PRMTCH	;THE RETURN
	SPOP PRMTCH	;NOW THE OLD PRMTCH
	ERROR+BRK
IPUL3:	PUSHS #LSTR
	SEZ
IPUL2:	RTS PC
TYPEIN:	JSR PC,RQU1	;INPUT A WORD FROM TTY
	BIT #7777,@S
	BNE TYPIN2
	MOV #LSTR,@S
	RTS PC
TYPIN2:	JMP FIRST
	.STITLE  READ -

READ:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D
	SPUSH E
	SPUSH F
	CLR RDFLAG
	MOV @S,GNCN
	BIC #170000,GNCN
	CLR F
READA:	JSR PC,RDWRD
	BEQ READB
	BIS #SEPF,RDFLAG
	JSR PC,CKDOTF
READC:	JSR PC,LISTB
	BIT #SEPF,RDFLAG
	BEQ READA
READB:	BIC #SEPF,RDFLAG	;CHECK SPECIAL CHAR IN D
	JSR PC,CKDOTF	;FIRST CHECK FOR PENDING ":"
	CMP #15,D
	BEQ READR	;C-R
	CMP #'",D
	BEQ READS	;STRING
	CMP #'[,D
	BEQ READL	;LIST
	CMP #'],D
	BNE .+4
	ERROR+COP	;CHAR (]) OUT OF PLACE
	CMP #':,D
	BEQ READD	;DOTS
	BITB #OPERF,DTBL(D)	;IS CHAR AN OPERATOR
	BEQ READA	;NO
	MOVB DTBL2(D),A
	ASL A
	MOV SOBLSU(A),B
		;SET TYPE TO SFUN OR INFIX
	MOV SOBLST(B),A	;THIS CROCK WORKS BECAUSE #SFUN=0
	BIC #-INFIX-1,A	; AND #INFIX=10000
	ASR B
	BR READC
READR:	POPS A
	CLR	TOPS
	TST	F
	BNE	READR1
	JMP RETF
READR1:	MOV A,@S
	JMP SRETF

READS:	JSR PC,GNC
	JSR PC,RDST
	BIS #SEPF,RDFLAG
	BR READC
READL:	JSR PC,RDLST
	POPS TOPS
	BIC #SEPF,RDFLAG
	BR READC
READD:	BIS #DOTF,RDFLAG
	BR READA
	.STITLE READ - READ WORD
	;READ CHARS UP THRU NEXT SEPARATOR CHAR.  IF JUST A SEP, RETURN
	;WITH IT IN D.  OTHERWISE NUMBERIFY OR INTERN CHAR STRING,
	;SKIP RETURN WITH TOKEN IN A,,B
RDWRD:	CLRB RDFLAG
	JSR PC,BLSTI
RDWA:	JSR PC,GNC
	JSR PC,GETCHF	;GET FLAGS IN A
	BIT #SEPF,A	;IS THIS CHAR A SEPARATOR?
	BNE RDWB	;YES
	BISB A,RDFLAG
	JSR PC,BLST
	BEQ RDWA
RDWB:	JSR PC,BLSTF	;FINISH OFF STRING
	BEQ RDWR+2
	BIT #NNUMF,RDFLAG
	BNE RDWC	;NOT A POSSIBLE NUMBER
	MOV TOPS,B
	MOV #LNUM,A
	JSR PC,CONVER	;TRY MAKING A #
.IFNZ FPPF
	BNE RDWR1
	MOV #FNUM,A
	JSR PC,CONVER	;IT MIGHT BE AN FNUM
.ENDC
	BNE RDWR1
RDWC:	MOV #UFUN,A	;TRY TO INTERN STRING IN TOPS AS A SYSTEM OR USER FUNCTION
	BIT #DOTF,RDFLAG	; UNLESS DOTF ON, THEN AS USER VARIABLE
	BEQ RDWD
	MOV #UVAR,A
	BIC #DOTF,RDFLAG
RDWD:	JSR PC,.INTRN	;RDST COMES HERE ALSO
	BEQ RDWE
	JSR PC,FRELST
RDWE:	BIC #170000,B
	BIS A,B
	CMP #UFUN,A	;IF WE GOT A UOE
	BHI RDWR+2	;THEN--
RDWR1:	MOV B,TOPS	;PROTECT THIS NEWLY HATCHED UOE FROM G.C.
RDWR:	CLZ
	RTS PC

GETCHF:		;GET FLAGS FOR CHAR IN D INTO A
	MOV #NNUMF,A
	TSTB D	;CHECK FOR 200 BIT
	BLT .+6
	MOVB DTBL(D),A
	RTS PC
	.STITLE READ - READ STRING
	;READ CHAR UP TO NEXT SPACE OR ] IF INSIDE
	;A LIST.  DONT ALLOW ] OR [.
	; SKIPS UNLESS EMPTY STRING
RDST:	CLRB RDFLAG
	JSR PC,BLSTI
	BR RDSB
RDSA:	JSR PC,GNC
RDSB:	JSR PC,GETCHF
	BIT #SEPF,A
	BEQ RDSE
	CMP #' ,D
	BEQ RDSX
	CMP #'],D
	BEQ RDSC
	CMP #'[,D
	BEQ RDSX
	CMP #15,D
	BEQ RDSX
RDSE:	BISB A,RDFLAG
	JSR PC,BLST
	BR RDSA
RDSC:	TST LISTBD	;ARE WE IN LIST
	BNE RDSX	;YES
RDSD:	ERROR+COP	;CHAR (D) OUT OF PLACE
RDSX:	MOV #LSTR,A
	MOV #LSTR, B
	JSR PC,BLSTF
	BEQ RDWR+2
	MOV #LSTR,A
	MOV TOPS,B
	BIT #NNUMF,RDFLAG
	BEQ RDWR	;IT IS A POSSIBLE NUMBER
	BIT #SEPF,RDFLAG
	BNE RDWR+2	;IT HAS A SEP CHAR IN IT
	MOV #ATOM,A
	BR RDWD	; INTERN IT
	.STITL READ - READ LIST
	;READ THRU MATCHING ] MAKING A LIST AS U GO
RDLST:	CLRB RDFLAG
	JSR PC,SLISTB
RDLA:	JSR PC,GNC
	CMP #' ,D
	BEQ RDLA	;SKIP OVER SPACES
	CMP #'[,D
	BEQ RDLB	;READ A LIST
	CMP #'],D
	BEQ RDLY	;DONE
	JSR PC,RDST	;READ A STRING
RDLX:	JSR PC,LISTB	;ADD THIS NODE TO LIST
	CMP #'[,D
	BEQ RDLB
	CMP #'],D	;AT END?
	BNE RDLA	;NO, GET NEXT ELEMENT
RDLY:	JSR PC,FLISTB
	RTS PC
RDLB:	JSR PC,RDLST
	POPS TOPS
	CLR D
	BR RDLX
	.STITLE READ - MISC
CKDOTF:	BIT #DOTF,RDFLAG
	BEQ LISTBR
	BIC #DOTF,RDFLAG
	PUSH A
	SPUSH B
	MOV #SFUN,A
	MOV #$DOTS,B
	JSR PC,LISTB
	JMP RETB
LISTB:	PUSH C
	MOV F,C	;BUILD A LIST, ADD NODE IN A,,B TO
	JSR PC,GRBAD1	;LIST WHOSE LAST NODE PTR IS IN F
	TST F	;CAREFUL - THE FIRST TIME IT IS CALLED, THE
		;POINTER TO THE FIRST NODE IS PUSHED ONTO S
	BNE LISTB1
	PUSHS	C
	BIS #LIST,@S
LISTB1:	MOV C,F
	POP C
LISTBR:	RTS PC
SLISTB:		;START LISTB
	PUSHS F	;SAVE CURRENT LAST NODE PTR
	CLR F
	INC LISTBD
	RTS PC
FLISTB:	TST F
	BNE FLSB1
	PUSHS #LIST
FLSB1:	POPS B	;THIS IS THE OUTPUT
	MOV @S,F	;RESTORE OLD LAST NODE PTR
	MOV B,@S	;THE RESULT
	MOV #LIST,A
	DEC LISTBD
	RTS PC

.IFNZ BEE
LISTO:	TST LBUILD	;IS THIS THE FIRST TIME
.ENDC

BLSTI:	CLR NCHR
	CLR E
	CLR TOPS
BLSTI1:	BIS #100000,E
	RTS PC
BLST:		;BUILD STRING - CHAR IN D, USES E
	TST	USER
	BGE	.+6
	JMP	STYO
	PUSH A
	SPUSH B
	SPUSH C
	CMPB #200,D	;CHECK IF NULL CHARACTER
	BEQ BLSTRT
	BIT #177,D	;CHECK IF NULL
	BEQ BLSTRT
	INC NCHR	;WE HAVE A CHAR
	ADD #40000,E
	BGE BLST2	;IS IT  THE SECOND
	MOVB D,TEMP	;NO, 1ST
BLSTRT:	JMP RETC
BLST2:	MOVB D,TEMP+1	;IT IS THE SECOND CHAR
	MOV TEMP,B
	;STORE THE CHARACTERS
BLST3:	JSR PC,BSAN
	BIS #100000,E
	BR BLSTRT
BLSTF:	;FINISH BUILDING STRING, PUT PTR IN TOPS.
		; DONT SKIP IF EMPTY STRING (TOPS=0)
	TST NCHR
	BEQ BSANR	;EMPTY STRING
	ADD #40000,E
	BLT BSANR
	PUSH A
	SPUSH B
	SPUSH C
	MOVB TEMP,B	;YES
	JSR PC,BSAN
BLSTF1:	JMP SRETC
BSAN:	MOV E,C
	MOV #SSTR,A
	JSR PC,GRBAD1
	TST E
	BNE BSAN1
	MOV C,TOPS	;SAVE NEW STRING PTR ON S
	BIS #LSTR,TOPS
BSAN1:	MOV C,E
BSANR:	RTS PC
	.STITL GNC - GET NEXT CHAR
GNC:	PUSH A		;GET NEXT CHAR INTO D
	SPUSH B		;INITIALIZE BY MOVING LSTR PTR INTO GNCN
GNC4:	MOVB GNCN+2,D	;    AND CLEARING TYPE FIELD (#170000)
	MOV GNCN,B	;PUTS CR (=#15) IN D IF NO MORE CHAR
	BLT GNC1	;JUST GOT 2ND CHAR
	BNE GNC3
	MOV #15,D
	JMP RETB	;NONE LEFT
GNC3:	JSR PC,.LOAD	;GET NEXT NODE
	BIS #100000,A	;SET "STILL ANOTHER CHAR" BIT
	MOV A,GNCN
	MOVB B,D	;FOR OUTPUT
	SWAB B
	MOVB B,GNCN+2
GNC2:	TST D
	BEQ GNC4	;IGNORE NULL CHARS
	JMP RETB
GNC1:	BIC #170000,GNCN	;CLEAR "STILL ..." BIT
	BR GNC2
	.STITL PRINT ROUTINES

PRLO:	PUSH A	;PRINT LAST OPERATOR
	SPUSH B
	MOV LO,A
	BEQ EMPTY
	MOV LO+2,B
	BR PRCO1
PRCO:	PUSH A,	;PRINT CURRENT OPERATOR
	SPUSH B
	MOV CO,A
	MOV CO+2,B
	BEQ EMPTY
PRCO1:	SPUSH D
	JSR PC,PROAB
	SPOP D
	JMP RETB
PROAB:	CMP A,#UFUN	;PRINT OPERATOR IN A,B
	BLO PRCO2
	JMP PPNAME	;PRINT PNAME
PRCO2:	MOV B,A	;SYSTEM FUNCTION
	BNE PRCO3
	PRTXT ^\ CR.\
	RTS PC
PRCO3:	ASL A
	ADD #4+SOBLST,A
	BR	PRAS	;PRINT ASCIZ PNAME
NOTPRO:	ERROR+NTP
EMPTY:	PRTXT ^\ EMPTY \
	JMP RETB

ERTAS:	SPUSH D
ERTAS1:	MFPI (A)
	MOVB (P),D
	BEQ ERTAS2
	JSR PC,@PCHR
	MOVB 1(P),D
	BEQ ERTAS2
	JSR PC,@PCHR
	ADD #2,A
	TST (P)+
	BR ERTAS1
ERTAS2:	ADD #2,A
	TST (P)+
	SPOP D
	RTS A


PRAS:	SPUSH	D	;PRINT ASCIZ STRING POINTED TO BY A
	BR	.+6
PRAS1:	JSR	PC,@PCHR
	MOVB	(A)+,D
	BNE	PRAS1
	SPOP	D
	RTS	PC

PRON:	BIC #TF2,TFLAGS	;PRINT OCTAL NO., NO. IN A
	BR PRON1	;CALL-	JSR PC,PRON
PRONL:	BIS #TF2,TFLAGS
PRON1:	PUSH A		;PRON DOESN'T PRINT LEADING ZEROS, PRONL DOES
	SPUSH D
	CLR D
	SEC
	ROL A	;TO TELL WHEN WE ARE DONE
	BR PRON2
PRON3:	CLR D
	ASL A
	BEQ PRON5
	ROL D
	ASL A
	ROL D
	ASL A
PRON2:	ROL D
	BNE PRON4
	BIT #TF2,TFLAGS
	BEQ PRON3
PRON4:	BIS #TF2,TFLAGS
	BIS #60,D
	JSR PC,@PCHR
	BR PRON3
PRON5:	BIS #60,D
	BIT #TF2,TFLAGS
	BNE .+6	;IF NOTHING HAS BEEN TYPED, TYPE A ZERO
	JSR PC,@PCHR
	SPOP D
	SPOP A
	RTS PC
PRDN:	PUSH B		;PRINT DECIMAL NO. IN A
	SPUSH C
	SPUSH D
	CLR C
	MOV A,B
	BGT PRDN1	;POSITIVE
	BEQ PRDN0	;ZERO
	NEG B		;NEGATIVE:
	MOV #'-,D	;"-" (ABS VAL)
	JSR PC,@PCHR
PRDN1:	INC C		;COUNT A STORED DIGIT
	CLR A
	DIV #10.,A	;DIVIDE BY 10
	PUSH B		;SAVE REMAINDER = NEW DIGIT
	MOV A,B		;QUOTIENT:  = 0?
	BNE PRDN1	;NO:  GET SOME MORE LOW-ORDER DIGITS
PRDN2:	POP D		;GET SAVED HIGH-ORDER DIGIT
	ADD #'0,D	;ENCODE IT
	JSR PC,@PCHR	;PRINT IT
	DEC C
	BGT PRDN2	;UNTIL NO. DIGITS LEFT = 0
PRDNX:	POP D
	SPOP C
	SPOP B
	RTS PC

PRDN0:	MOV #'0,D	;TYPE "0"
	JSR PC,@PCHR
	BR PRDNX

EMPTY1:	JMP EMPTY
PRS1:	PUSH A	;PRINT TOP ELEMENT OF SS
	SPUSH B
	MOV #IS,A	;COMPUTE RELATIVE S PD PTR
	SUB S,A
	ADD SPRBAO,A
	CMP A,CSPDLP
	BLOS EMPTY1
	MOV @S,B
	SPUSH D
	JSR PC,PNODAB
	SPOP D
	JMP RETB
PNODAB:	MOV B,A
	BIC #7777,A
	CMP #SSTR,A
	BEQ PRS11
	CMP #SNP,A
	BLOS PRS11
	ERROR+INVN	;INVALID NODE
PRS11:	JSR PC,PRDATA
	RTS PC
PRCT:	PUSH A	;PRINT CURRENT TOKEN
	SPUSH B
	SPUSH D
	MOV CT,A
	MOV CT+2,B
	JSR PC,PRTAB
	SPOP D
	JMP RETB
PRTAB:	BIC #7777,A	;PRINT TOKEN IN A,B
	CMP A,#UVAR
	BHIS .+6
	JMP PROAB
	CMP A,#UVAR
	BEQ PRUV
	BR PRDATA
PRATM:	BIS #PQF,FLAGS2	;PRINT ATOM IN A,B
	BR PRUV1
PRUV:	MOVB #':,D	;PRINT USER VARIABLE IN A,B
	JSR PC,@PCHR
PPNAME:	BIC #PQF,FLAGS2	;PRINT PNAME - UOE PTR IN B
PRUV1:	JSR PC,.LOAD
	JMP PRLSTR	;PRINT PNAME
PRDATA:	CMP #INUM,A	;PRINT DATA IN A,B. 7777 FIELD OF A IS 0000
	BEQ PRINUM	;NUMBER
.IFNZ FPPF
	CMP #FNUM,A
	BEQ PRFNUM
.ENDC
	CMP #SNUM,A
	BEQ PRSNUM
	BIS #PQF,FLAGS2	;SET PRINT QUOTE FLAG
	CMP #ATOM,A
	BEQ PRUV1
	CMP #LSTR,A
	BEQ PRLSTR	;LONG STRING
	CMP #SSTR,A
	BEQ PRSSTR	;SHORT STRING
	BIC #PQF,FLAGS2
	CMP #LIST,A
	BEQ PRLST
	TST WRTFLG
	BEQ	PRSNP	;YES
	PRTXT	^/" /	;OUTPUT EMPTY
	BR	PRSRET
PRSNP:	PRTXT ^\%SNAP%\	;CANT PRINT A SNAP
	BR PRSRET
PRLSTR:	JSR PC,.LOAD	;PRINT LONG STRING
PRSSTR:	JSR PC,PRQQ	;PRINT SHORT STRING
PRSTR2:	MOVB B,D
	JSR PC,PRSPT
PRSTR3:	SWAB B
	MOVB B,D
	JSR PC,PRSPT
PRSTR4:	MOV A,B
	BIC #170000,B
	BEQ PRSRET
	JSR PC,.LOAD
	BR PRSTR2
PRSRET:	RTS PC
PRQQ:	BIT #PQF,FLAGS2	;PRINT ' " ' IF PQF=1
	BEQ PRSRET
	BIT #DPQF,FLAGS2
	BNE PRSRET
	MOVB #'",D
	JMP @PCHR
.IFNZ FPPF
PRFNUM:	PUSH C
	JSR PC,.FLOAD
	MOV #FNUM,C
	BR PRFNM1
.ENDC
PRSNUM:	CLR A	;PRINT SNUM
	TST B
	BGE PRINM1
	COM A
	BR PRINM1
PRINUM:	JSR PC,.LOAD	;PRINT INUM
PRINM1:	PUSH C
.IFNZ FPPF
	 MOV #INUM,C	;SET FLAG FOR INUM ENTRY
.ENDC
PRFNM1:	MOV E,TMPBLK+2
	MOV F,TMPBLK+4
.IFNZ FPPF
	CMP #FNUM,C
	BNE .+8
	JSR PC,.CFNST
	BR .+6
.ENDC
	JSR PC,.CINST	;CONVERT INUM IN A,,B TO STRING ON P
	MOV TMPBLK+2,E
	MOV TMPBLK+4,F
	MOV P,A
	MOVB (A)+,D
	BNE PRINM3
PRINM2:	MOVB (A)+,D
	BEQ PRINM4
PRINM3:	JSR PC,@PCHR
	BR PRINM2
PRINM4:	INC A	;TO MAKE IT EVEN (??)
	MOV A,P
	POP C
PRSPT2:	RTS PC

PRSPT:	CMPB #200,D
	BEQ PRSPT2
	TSTB D
	BEQ PRSPT2
	BIT #CPTBF,FLAGS2
	BEQ PRSPT1
	CMPB #'%,D
	BNE .+6
	MOV #' ,D
PRSPT1:	JMP @PCHR
PRLST:	PUSH A	;PRINT LIST, PTR IN B
	SPUSH B
	SPUSH C
	TST NBKTS
	BEQ PRL4
	MOV #'[,D
	JSR PC,@PCHR
PRL4:	INC NBKTS
	MOV B,C
PRL1:	SPUSH FLAGS2
	BIT #7777,C	;EMPTY LIST
	BEQ PRL2	;YES, DONE
	BIS #DPQF,FLAGS2	;DONT PRINT QUOTE BEFORE STRINGS
	BR PRL3
PRL6:	SPACE
PRL3:	JSR PC,.LOADC	;GET THIS NODE
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	JSR PC,PRTAB
	BIT #7777,C
	BNE PRL6
PRL2:	DEC NBKTS
	BEQ PRL5
	MOV #'],D
	JSR PC,@PCHR
PRL5:	BIC #DPQF,FLAGS2
	SPOP C	;GET OLD FLAGS2
	BIC #<-DPQF-1>,C	;MASK ALL BUT DPQF
	BIS C,FLAGS2	;AND RESTORE IT
	JMP RETC
PRNODE:	PUSH A	;PRINT NODE POINTED TO BY B
	SPUSH B
	SPUSH D
	JSR PC,.LOAD
	JSR PC,PRON
	SPACE
	MOV B,A
	JSR PC,PRON
	SPOP D
	JMP RETB

.IFNZ SYSP
SYSPR:	MOV NUSERS,A
	CLR B
	CLR C
SYSLP1:	SEC
	ROL C
	SOB A,SYSLP1
SYSLP2:	ROR C
	BCC SYSTST
	JSR PC,SENDIT
	BCS SYSNT1
SYSTST:	TST C
	BEQ SYSRET
SYSNTS:	INC B
	CMP B,#16.
	BLE SYSP1
	JSR PC,FLUSH
	JSR PC,RUNME
	CLR B
SYSP1:	CLC
	BR SYSLP2
SYSNT1:	MOV USER,D
	TST BRAKE(D)
	BNE SYSLP3
	INC B
	CMP B,#16.
	BLE .+4
	CLR B
	SEC
	BR SYSLP2
SYSRET:	JSR PC,SPOPT
	SEZ
	RTS PC
SYSLP3:	ERROR+BRK


SENDIT:	SPUSH B		;SAVE B
	SPUSH C		;SAVE C
	MOV USER,C
	MUL #L,B	;CHANGE INDEX TO USER NO.
	MOV UTTY(B),E	;GET RECEIVERS TTY NO.
	TST TIQN(E)	;DOES HE HAVE ANY INPUT?
	BNE SENDF	;YES, DON'T SEND ANYTHING YET
	SPUSH UTTY(C)	;SPUSH SENDERS TTY
	SPUSH E		;PUSH RECEIVERS TTY
	SPUSH FLSRES(B)	;SAVE RECEIVERS OLD FLUSH REASON
	SPUSH B		;PUSH RECIVERS USER NO.
	MOV #200,FLSRES(B)	;MAKE SURE HE DOESN'T RUN
	MOV E,UTTY(C)	;MAKE SENDERS TTY RECEIVERS OLD TTY
	MOV USER,TTYU(E)	;MAKE THE USER OF THAT TTY THE SENDER
	MOV @S,B	;THE THING TO PRINT
	MOV B,A
	BIC #7777,A
	JSR PC,.CRLF	;PRINT CR. MESSAGE CR.
	JSR PC,PRDATA	;PRINT ON RECEIVERS TTY
	JSR PC,.CRLF
	SPOP B		;RESTORE RECEIVERS USER NO.
	SPOP FLSRES(B)	;RESTORE RECEIVERS FLSRES
	SPOP E		;GET RECEIVERS TTY NO.
	MOV E,UTTY(B)	;PUT IT BACK AS HIS TTY
	MOV B,TTYU(E)	;MAKE THE TTY HIS AGAIN
	MOV USER,C	;GET SENDERS USER NO.
	SPOP UTTY(C)	;RESTORE SENDERS TTY NO.
	SPOP C		;RESTORE C AND B
	SPOP B
	CLC
	RTS PC
SENDF:	SPOP C
	SPOP B
	SEC
	RTS PC

SEND:	SPOPS A
	SPOPS B
	SPUSHS A
	SPUSHS B
	JSR PC,G1NARG
	MOV USER,C
SEND1:	JSR PC,SENDIT
	BCC SEND2
	TST BRAKE(C)
	BNE SYSLP3
	BR SEND1
SEND2:	JSR PC,SPOPT
	SEZ
	RTS PC


.ENDC



	.STITL PRINTOUT (ONCE KNOWN AS SHOW)
SHALPR:		;SHOW ALL PROCEDURES
		;USES A-F
	JSR PC,GNOLEI
	BR SHALP2
SHALP1:	JSR PC,.CRLF
SHALP2:	JSR PC,GNOLE
	BEQ SHOWA1
	JSR PC,BURYQ
	BEQ SHALP2
	JSR PC,PSHOW
	BNE .+4
	.BUG.
	CMP PCHR,#TYO
	BNE SHALP2
	BR SHALP1

POTS:
SHALTI:	;SHOW ALL TITLES
	JSR PC,GNOLEI
SHATI1:	JSR PC,GNOLE
	BEQ SHOWA1
	JSR PC,BURYQ
	BEQ SHATI1
	JSR PC,SHTITL
	BR SHATI1

SHOWAL:	JSR PC,SHALPR	;SHOW ALL PROCEDURES
	JSR PC,SHALNA	;SHOW ALL NAMES
	TST WRTFLG	;DON'T SHOW ARRAYS ON WRITE
	BNE .+6
	JSR PC,POARR	;SHOW ALL ARRAYS
SHOWA1:	SEZ
	RTS PC

SHOW:	BIT #7777,CT	;ANY TOKENS LEFT
	BNE SHOW00	;YEP
	MOV TOPRNM,B
	BNE SHOW0
	MOV LASTPR,B
	BNE SHOW0
	ERROR+SHW

SHOW00:	JSR PC,GTUOEB
	BNE SHOW1	;THE TOKEN ISNT A USER PROC
SHOW0:	JSR PC,PSHOW
	BNE SHOWA1
	ERROR+PNH	;PROCEDURE NOT HERE
SHOW1:	CMP #SFUN,A
	BNE SHOWE1
	TST B	;IS IT CR?
	BNE SHOW12	;NO
	MOV TOPRNM,B
	BNE SHOW0
SHOWE1:	ERROR+SHW

SHOW12:	MOV #PODISP,A
SHOW13:	CMP (A)+,B
	BNE SHOW23
	JMP @(A)
SHOW23:	TST (A)+
	TST (A)
	BNE SHOW13
	ERROR+SHW

.IFNZ DDF
CNTRL:	CLR C
	INC C
	BR ALSO2
ALSO:	CLR C
ALSO2:	BIT #7777,CT
	BNE .+4
ALSOWH:	ERROR+WTAB
	JSR PC,GNT
	BIC #7777,A
	CMP #SFUN,A
	BNE ALSOWH
	TST B
	BEQ ALSOWH
.IFNZ ENG
	CMP #$STTUR,B
	BEQ TUR
.IFNZ NDISP
	CMP #$DISPLAY,B
	BEQ DIS
.ENDC
.IFNZ NPLOT
	CMP #$PLOTTER,B
	BEQ PLOT
.ENDC
.ENDC
.IFNZ FR
	CMP #$TORTUE,B
	BEQ TUR
.IFNZ NDISP
	CMP #$ECRAN,B
	BEQ DIS
.ENDC
.IFNZ NPLOT
	CMP #$TRACEUR,B
	BEQ PLOT
.ENDC
.ENDC
	BR ALSOWH
.IFNZ NDISP
DIS:	TST C
	BEQ .+6
	JMP CTRDIS
	JSR PC,EVAL
	BEQ TUR2
	JMP ASTRDI
.ENDC
TUR:	TST C
	BEQ TUR1
	JSR PC,EVAL
	BEQ TUR2
	JMP CTRTUR
TUR1:	JSR PC,EVAL
	BNE .+4
TUR2:	ERROR+WTAB
	JMP ASSTUR
.IFNZ NPLOT
PLOT:	TST C
	BEQ .+6
	JMP CTRPLT
	JMP ASSTPL
.ENDC

.ENDC


POT:	MOV TOPRNM,B	;SHOW THIS TITLE
	BEQ POL1
	JSR PC,SHTITL
	BNE POL2
	.BUG.

POL:	TST TOPRNM
	BNE .+4
POL1:	ERROR+OIP
	JSR PC,GTLN	;GEN LINE NO. FROM NEXT TOKEN INTO B
	BNE .+4
	ERROR+SHW	;SHOW WHAT??
	JSR PC,GTLP	;GET POINTER TO LINE
	JSR PC,.LOADC
	PUSHS B	;FOR PRLN
	JSR PC,PRLN	;PRINT LINE
	PRCR
	POPS C
POL2:	SEZ
POL3:	RTS PC
.POFILE:	JSR PC,EVAL
	BNE .+4
	ERROR+UELX
	JMP .POF

PSHOW:	;SHOW (B).  SKIP UNLESS (B) NOT A USER PROC
	JSR PC,SHTITL	;SHOW TITLE LINE, SKIPS IF PROC THERE
	BEQ POL3
	BIT #7777,A
	BEQ PSHOW4
	MOV A,C
	PUSHS #0
PSHOW3:	JSR PC,.LOADC
	MOV A,C
	MOV B,@S
	JSR PC,PRLN
	PRCR
	BIT #7777,C
	BNE PSHOW3
	POPS A
PSHOW4:	LANGC <PRTXTC ^\END\>,<
	PRTXTC ^/FIN/>
	CLZ
	RTS PC


PON:
SHALNA:		;SHOW ALL NAMES
		;USES A-F
	JSR PC,GNOLEI
SHALN1:	JSR PC,GNOLE	;GET NEXT UOE
	BEQ POL2+2
	MOV B,F
	MOV #VBIND,A
	JSR PC,.BINDL
	BEQ SHALN1	;NO THING FOR THIS UOE
	MOV B,C	;SAVE VALUE PTR
	MOV F,B	;GET UOE PTR
	TST WRTFLG
	BEQ SHALN2	;NO
	TST C		;IS VALUE = "UNBOUND"? (0?)
	BEQ SHALN1	;SKIP THIS ATOM
	SPUSH B
LANGC	<PRTXT ^/MAKE "/>,<
	PRTXT ^/RELIE "/>
	SPOP B
	JSR PC,PPNAME	;PRINT THE NAME
	PRTXT ^\ (\
	BR SHALN3
SHALN2:	JSR PC,PRUV	;PRINT THE NAME
LANGC	<PRTXT ^/ IS/>,<
	PRTXT ^/ EST/>
	TST C		;UNBOUND?
	BEQ SHALN5	;YES; JUST SAY SO
SHALN3:	SPACE
	SPUSHS C
	INC NBKTS
	JSR PC,PRS1
	ADD #2,S
	TST WRTFLG
	BEQ SHALN4
	PRTXT ^\ )\
SHALN4:	PRCR
	BR SHALN1

SHALN5:	PRTXT ^/ UNBOUND./
	BR SHALN4

POARR:	JSR PC,GNOLEI
POARR1:	JSR PC,GNOLE	;GET NEXT UOE
.IFZ <ENG&FR>
	BEQ POARR6
	.IFF
	BNE .+6
	JMP POARR6
.ENDC
	MOV B,F		;PTR TO UOE
	MOV #ABIND,A
	JSR PC,.BINDL	;GET ARRAY BINDING
	BEQ POARR1	;NO BINDING FOUND
	JSR PC,POARR5	;PRINT ARRAY NAME,SIZE,TYPE
	BR POARR1	;LOOK FOR MORE ARRAYS
POARR5:	MOV B,C		;SAVE VALUE PTR
	MOV F,B		;GET UOE PTR
	JSR PC,PPNAME	;PRINT THE NAME
LANGC	<PRTXT ^/ SIZE / >,<
	PRTXT ^/ DIMMENSION />
	MOV C,B	;SAVE VALUE PTR
	PUSH B
	JSR PC,ASIZE2	;PUTS DIMS. OF ARAY IN LIST
	MOV C,B		;PPTR TO LIST
	JSR PC,PRLST	;PRINT IT
	SPACE
	PRTXT ^/ TYPE/
	POP B		;VALUE PTR
	MOV 4(B),B	;TYPE/DIM WORD IN ARRAY HEADER
	BIC #7777,B	;GET THE TYPE
	BEQ POARR2	;TYPE POINTER
	CMP #FNUM,B
	BEQ POARR3	;TYPE FNUM
LANGC	<PRTXT ^/ INTEGER/>,<
	PRTXT ^/ NOMBRE ENTIER/>
	BR POARR4
POARR2: LANGC	<PRTXT ^/ POINTER/>,<
	PRTXT ^/ POINTEUR/>
	BR POARR4
POARR3: LANGC	<PRTXT ^/ FLOATING POINT/>,<
	PRTXT ^/ NOMBRE DECIMAL/>
POARR4:	PRCR		;CARRIAGE RETURN
	SEZ
POARR6:	RTS PC
PO1AR:	JSR PC,GTUOEB
	BEQ .+4
	MOV B,F
	MOV #ABIND,A
	JSR PC,.BINDL
.IFZ <ENG&FR>
	BNE POARR5
	ERROR+UDA
	.IFF
	BEQ .+4
	ERROR+UDA
	JMP POARR5
.ENDC

CONTEN:	;MAKE A LIST OF ALL ATOMS THAT HAVE A PROCEDURE
	JSR PC,SLISTB
	JSR PC,GNOLEI
CONTN1:	JSR PC,GNOLE
	BEQ CONTN2	;DONE
	JSR PC,BURYQ
	BEQ CONTN1
	MOV B,D
	JSR PC,.BINDF	;A PROCEDURE
	BEQ CONTN1	;NOPE
	MOV D,C
	JSR PC,.LOADC	;GET PNAME
	MOV #LSTR,A
	JSR PC,LISTB
	BR CONTN1
CONTN2:	JSR PC,FLISTB
	CLZ
	RTS PC
SHTITL:		;INPUT - UOE PTR IN B
		;OUTPUT - "SHOWS" TITLE LINE
		;	-A POINTS TO LLP NODE FOR 1ST LINE
		;	- SKIPS UNLESS NO PROC
	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BINDF
	BNE .+6
	JMP RETC
	MOV A,4(P)
LANGC	<PRTXT ^\TO \>,<
	PRTXT ^/POUR />
	MOV 2(P),B
	JSR PC,PPNAME
	MOV 4(P),C
	JSR PC,.LOADC
	MOV A,4(P)	;SAVE PTR TO NEXT NODE
	JSR PC,.LOAD	;#ARGS IN B
	BIT #7777,A	;ANY TOKENS LEFT?
	BEQ SHTI1
	MOV A,C
SHTI2:	SPACE
	JSR PC,.LOADC	;NEXT ARG
	MOV A,C
	JSR PC,PRTAB	;PRINT TOKEN
	BIT #7777,C
	BNE SHTI2
SHTI1:	PRCR
	JMP SRETC
PRLN:	PUSH A	;PRINT PROC LINE ON S
	SPUSH B
	SPUSH C
	SPUSH D
	INC NBKTS	;PRINT OUTER LIST BRACKETS
	BIC #DPQF,FLAGS2	;DO PRINT QUOTE BEFORE STRINGS
	MOV @S,C
	JSR PC,.LOADC	;PRINT LINE #
	MOV A,C
	JSR PC,PRTAB
	BIT #7777,C
	BEQ PRLN3	;DONE
	JSR PC,.LOADC	;CHECK FOR TYPE = SNUM
	MOV A,C	;THIS MEANS 2ND TOKEN IS A CLGN & SHOULDNT PRINT
	BIC #7777,A
	CMP #SNUM,A
	BNE PRLN4
	BR PRLN2
PRLN1:	JSR PC,.LOADC
	MOV A,C
PRLN4:	SPACE
	JSR PC,PRTAB
PRLN2:	BIT #7777,C	;DONE?
	BNE PRLN1	;NO
PRLN3:	DEC NBKTS
	JMP RETD
	.STITL TEXT
TEXTT:	;LISTIFY TEXT OF PROC ON (S)
		;OUTPUT ON S
	JSR F,CACSAV
	JSR PC,LISTIT	;LISTIFY THE TITLE
	CLR F	;FOR LISTB
	SPOPS TOPS	;PRESERVE TITLE FROM GC!!!!!
	JSR PC,LISTB	;THE TITLE LINE
	SUB #2,S	;WORK CELL
	BR TEXT2
TEXT1:	JSR PC,.LOADC	;GET NEXT LLP NODE
	MOV A,C	;SAVE PTR TO NEXT ONE
	MOV B,@S	;NPUT TO LISTLN
	JSR PC,LISTLN	;LISTIFY THIS LINE
	JSR PC,LISTB	;ADD TO LIST
TEXT2:	BIT #7777,C
	BNE TEXT1	;NOT DONE YET
	ADD #2,S	;POP WORK CELL
	BR LIL2
LISTIT:	;LISTIFY TITLE LINE OF PROC ON (S)
		;SKIP IF THERE
		;OUTPUT ON S AND IN A,,B.  C POINTS TO LLP NODE FOR 1ST LINE
	JSR F,CACSAV
	JSR PC,GUOEB	;GET UOE PTR FROM S
	BEQ LIT4	;NONE THERE
	MOV B,D	;SAVE UOE PTR
	CLR TOPS
	JSR PC,.BINDF	;GET PROC BINDING
	BEQ LIT4	;NONE THERE
			;RETURNS WITH FIRST NODE OF LLP IN A,,B
	JSR PC,.LOADA	;GET 2ND NODE
	MOV A,4(P)	;SAVE PTR TO 3RD NODE IN SAVED C
	JSR PC,.LOADB	;GET #ARGS NODE
LIT1:	PUSHS A
	JSR PC,LTOK	;LISTIFY THE DUMMY ARGS
	BEQ LIT4	;LOST???
	MOV #LSTR,A	;NOW ADD "TO FOO"
LANGC	<MOV #$TOTO,B>,<
	MOV #$POURX,B>
	JSR PC,GRBAD	;"TO"
	MOV D,B
	JSR PC,.LOADB	;GET PNAME PTR
	MOV @S,A
	MOV A,TOPS
	BIC #170000,A
	BIS #LSTR,A
	BIS #LIST,C
	MOV C,2(P)
	MOV #LIST,(P)
	MOV C,@S
	JSR PC,GRBAD1	;"FOO"
	BR LIL2
LIT4:	ERROR+HNM
LISTLN:	;LISTIFY PROC LINE ON S
		;OUTPUT ON S AND IN A,,B
		;SKIPS UNLESS BAD TOKEN
	JSR F,CACSAV
	MOV @S,C	;GET LLP  IN C
	JSR PC,.LOADC	;GET LINE # NODE
	MOV B,F		;SAVE IT
	MOV A,@S	;SAVE PTR TO REST OF LINE
	MOV A,B
	JSR PC,.LOAD	;GET NEXT TOKEN AND CHECK IF IT IS ALSO SNUM
	BIC #7777,B
	CMP #SNUM,B
	BNE .+6
	MOV A,@S	;IT IS - SKIP OVER IT
	JSR PC,LTOK	;LISTIFY THE REST OF THE TOKENS
	BEQ LIL1		;LOST
	MOV F,B	;NOW ADD LINE # ON FRONT.  GET IT FROM F
	JSR PC,.CSNLS	;CONVERT SNUM TO LSTR
	MOV B,TOPS	;PTR TO LSTR IS IN B - PROTECT FROM G..C.
	MOV @S,A	;PTR TO TOKEN-LISTIFIED
	BIC #170000,A
	BIS #LSTR,A
	JSR PC,GRBAD
	CLR TOPS
	BIS #LIST,C
	MOV C,@S	;OUTPUT ON S
	MOV C,2(P)	;AND IN SAVED A AND B
	MOV #LIST,(P)
LIL2:	JSR F,CACRES
	CLZ
	RTS PC

LIL1:	.BUG.
LTOK:	;LISTIFY TOKEN LIST ON S
		;OUTPUT ON S AND IN A,,B
		;SKIP UNLESS A "BAD" TOKEN IS FOUND
	JSR F,CACSAV
	POPS C	;GET PTR TO TOKEN LIST
	JSR PC,SLISTB
LTOK1:	BIT #7777,C	;ANY TOKENS LEFT
	BEQ LTOKF
	JSR PC,.LOADC	;GET NEXT TOKEN
	MOV A,C	;SAVE PTR TO NEXT
	BIC #7777,A
	CMP #SNUM,A
	BEQ LTOK1	;IGNORE SNUM'S
	CMP #UFUN,A
	BHI LTOKSF	;MUST BE SFUN OR INFIX
	BEQ LTOKUF	;A USER PROC
	MOV #':,D
	CMP #UVAR,A
	BEQ LTOKCT	;A USER VARIABLE
	MOV #'",D
	CMP #ATOM,A
	BEQ LTOKCT	;A STRING
	BHI LTOKBD
	CMP #LSTR,A
	BNE LTOKAD	;AN INUM OR LIST - OK AS IS
	JSR PC,CONCTL	;AN LSTR, ADD A "
	BR LTOKAD
LTOKBD:	JSR PC,FLISTB	;BAD TOKEN
	POPS A
	BR LIL2
LTOKUF:	JSR PC,.LOAD	;USER PROC
LTOK3:	MOV #LSTR,A
LTOKAD:	JSR PC,LISTB
	BR LTOK1
LTOKSF:	JSR PC,CVSFLS	;CONVERT SYSTEM FUNCTION TO LSTR
	MOV TOPS,B
	BR LTOK3
LTOKCT:	JSR PC,CONCT
	BR LTOK3
LTOKF:	JSR PC,FLISTB
	MOV A,(P)	;SAVED A
	MOV B,2(P)	;SAVED B
LIL3:	BR LIL2
CONCT:	;APPEND CHAR IN D TO BEGINING OF PNAME OF ATOM IN B
		;OUTPUT #LSTR,,PTR IN A,,B
	JSR PC,.LOAD	;GET PNAME PTR
CONCTL:	PUSH C
	MOV B,A
	BIC #170000,A
	BIS #SSTR,A
	MOV D,B
	JSR PC,GRBAD
	MOV C,B
	MOV #LSTR,A
	BIS A,B
	POP C
	MOV B,TOPS
	RTS PC
CVSFLS:	;CONVERT SFUN NAME TO LSTR
		;INPUT - A,,B SFUN OR INFIX TOKEN IN TOPS
		;OUTPUT -  LSTR PTR IN TOPS
	JSR F,CACSAV
	SPUSH PCHR
	JSR PC,BLSTI
	MOV #BLST,PCHR
	JSR PC,PROAB
	JSR PC,BLSTF
	BNE .+4
	.BUG.	;CANT HAVE NO CHARS!!
	POP PCHR
	BR LIL3
	.STITL ILINE & ERSET STUFF
ILINE:	;OUTPUT LAST LINE TYPED IN
	PUSHS ILINEL
	JSR PC,LTOK
	BNE ERRPR2
	.BUG.	;A BAD TOKEN??
ERRPRO:	;OUTPUT NAME OF PROC EXTENT AT LAST ERROR
	MOV NPROCL,B
	BEQ ERRPR1
	JSR PC,.LOAD
	PUSHS B
	CLZ
	RTS PC

ERRPR1:	PUSHS #LSTR
ERRPR2:	RTS PC
ERRLIN:	;OUTPUT LINE # EXTENT AT LAST ERROR
	MOV NLINEL,B
	BR NTOKE1
ERRTOK:	;OUTPUT TOKEN # EXTENT AT LAST ERROR
	MOV NTOKEL,B
NTOKE1:	JMP R1NARG
ERRLOC:	;OUTPUT ADDR OF LAST ERROR
	MOV LASTER,B
	BR NTOKE1
ERRNUM:	;OUTPUT NO. OF LAST ERROR
	MOV ERRBUF+4,B
	BR NTOKE1
ERRNAM:	MOV #4,C	;MAX CHARS
	MOV #ERRBUF,B	;POINT TO CHARS
	BEQ ERRPR1	;NEVER AN ERROR!
	JSR PC,BLSTI	;START AN LSTR
ERRNA2:	MOVB (B)+,D	;GET CHAR
	BEQ ERRNA1
	JSR PC,BLST
	SOB C,ERRNA2	;CONTINUE UNLESS DONE
ERRNA1:	JSR PC,BLSTF
	BEQ ERRPR1
	PUSHS TOPS
	CLZ
	RTS PC

ERRBREAK:	;OUTPUT BRAKE(U)
	MOV BRAKEL,B
	BR NTOKE1
ERRSET:	JSR PC,GTUOEB
	BEQ .+4
	ERROR+HNM
	MOV B,ERPROC
	SEZ
	RTS PC
ERRCLE:	CLR ERPROC
ERRC3:	RTS PC
ERNAME:	;ERASE NAME
	JSR PC,GTUOEB
	BEQ ERN2
ERN1:	CMP #UFUN,A	;AN SFUN OR INFIX?
	BGT .+4
	ERROR+ERW
	JSR PC,CVSFLS
	MOV #ATOM,A
	JSR PC,.OBSCH
	BEQ ERRC3
ERN2:	MOV #VBIND,A
	JSR PC,.UNBND
	SEZ
	RTS PC
	.STITLE ERASE
ERASE:	JSR PC,GTUOEB	;ERASE ...
	BNE ERASE1	;NOT A PROCEDURE
	JSR PC,ERPR
	BEQ ERASER
	SEZ
	RTS PC
ERASER:	ERROR+PNH	;PROCEDURE NOT HERE

ERASE1:	MOV #ERSDISP,A
ERASE2:	CMP (A)+,B
	BNE ERASE4
	JMP @(A)
ERASE4:	TST (A)+
	TST (A)
	BNE ERASE2
ERASE3:	ERROR+ERW	;ERASE WHAT
ERALL:	JSR	PC,ERALPR
	JSR	PC,ERALNA
	JSR PC,ERARAS
	JMP ERTL3
ERL:
ERLINE:	TST TOPRNM
	BNE .+4
	ERROR+OIP
	JSR PC,GTLN	;GET LINE # IN B
	BEQ ERASE3
	NEG B		;SO ADLN WILL ERASE IT
	MOV #SNUM,A
	JSR PC,GRBAD
	BIS #LIST,C
	PUSHS C
	JSR PC,ADLN
	ADD #2,S	;POP S
ERL1:	SEZ
	RTS PC
ERPR:		;ERASE PROCEDURE (B)
	BIC #170000,B
	BIS #UFUN,B
	CMP B,TOPRNM
	BNE .+4
	ERROR+PBE	;PROCEDURE IS BEEN EDITED (UGH!!!)
	MOV #FBIND,A
	JMP .UNBND
ERALPR:		;ERASES ALL PROCEDURES
	TST TOPRNM
	BEQ ERALP2
	MOV TOPRNM,B
	BR ERPR
ERALP2:	JSR PC,GNOLEI
	MOV #FBIND,A
ERALP1:	JSR PC,GNOLE	;GET NEXT UOE
	BEQ ERL1+2
	JSR PC,BURYQ
	BEQ ERALP1
	JSR PC,.UNBND
	BR ERALP1
EAN:
ERALNA:		;ERASE ALL NAMES
	JSR PC,GNOLEI
ERALN1:	JSR PC,GNOLE
	BEQ ERL1+2
	MOV #VBIND,A
	JSR PC,.UNBND
	BR ERALN1	;EVENTUALLY HAVE TO CHECK FOR SVBIND
ERFI:	JSR PC,EVAL
	BEQ ERINX1
	JMP .DELETE
ERINDX:	JSR PC,EVAL
	BNE .+4
ERINX1:	ERROR+UELX
	JMP .DELI
	.STITL TRACE
EBURY:	BIC #TF6,TFLAGS
BURY1:	MOV #TPBF,D
	BR TRA3

ESTEP:	BIC #TF6,TFLAGS
STEP1:	MOV #TPSF,D
	BR TRA3
ERTR:
ETRACE:	BIC #TF6,TFLAGS
TRA1:	MOV #TPTF,D
TRA3:	JSR PC,GTUOEB
	BNE TRA6
	JSR PC,CSSTF
	BNE TRA11
TRA5:	ERROR+PNH	;PROC NOT HERE
TRA6:	CMP #SFUN,A
	BNE TRA5
	.IFNZ ENG
	CMP #$ALL,B
	BEQ TRA10
	.ENDC
	.IFNZ FR
	CMP #$TOUT,B
	BEQ TRA10
	.ENDC
	ERROR+ERW
TRA10:	JSR PC,GNOLEI
TRA7:	JSR PC,GNOLE
	BEQ TRA9
	CMP #TPBF,D	;UNBURY BURIED PROCS
	BEQ TRA8
	JSR PC,BURYQ	;BUT DON'T TRACE UNTRACE STEP OR UNSTEP THEM.
	BEQ TRA7
TRA8:	JSR PC,CSSTF
	BR TRA7

CSSTF:	JSR PC,.BNDFS
	BEQ TRA9
	MOV B,C	;B POINTS TO LIST OF GOODIES. FIRST IS FLAGS,,#ARGS
	JSR PC,.LDP2
	BIC D,A
	BIT #TF6,TFLAGS
	BEQ TRA2
	BIS D,A
TRA2:	JSR PC,.STP2
	CLZ
TRA9:	RTS PC
TRA11:	SEZ
	RTS PC

BURYQ:	PUSH A
	SPUSH B
	SPUSH C
	JSR PC,.BNDFS
	BEQ BURYQ1
	JSR PC,.LOADB
	BIT #TPBF,B
	BEQ .+6
BURYQ1:	JMP RETC
	JMP SRETC

TRACE:	BIS #TF6,TFLAGS
	BR TRA1
STEP:	BIS #TF6,TFLAGS
	BR STEP1
BURY:	BIS #TF6,TFLAGS
	BR BURY1

STRACS:	BIT #TRACEF,FLAGS2
	BEQ TRA9
	SPACE
	BR STRA1
STRACE:	BIT #TRACEF,FLAGS2	;SYSTEM TRACE
	BEQ TRA9
STRA1:	INC NBKTS
	PUSH A
	PRTXT ^/CT=/
	BIC #DPQF,FLAGS2
	JSR PC,PRCT
	PRTXT ^/ CO=/
	JSR PC,PRCO
	PRTXT ^/ S=/
	BIC #DPQF,FLAGS2
	JSR PC,PRS1
	PRCR
	CLR NBKTS
	POP A
	RTS PC

SETSTF:	BIS #TRACEF,FLAGS2	;SET SYSTEM TRACE FLAG
	SEZ
	RTS PC

CLRSTF:	BIC #TRACEF,FLAGS2
	SEZ
	RTS PC

FLEV:	MOV FUNLEV,B	;RETURN USER PROC CALL DEPTH
FLEV1:	JMP R1NARG
NODES:	;OUTPUT NO. OF NODES IN FREE STG LIST
	MOV NNIFSL,B
	BR FLEV1
.STITL	UTILITY ROUTINES

GOODBYE:	MOV USER,U
	JSR PC,RUNME
LANGC	<CPRTXT ^/AND A PLEASANT DAY TO YOU!/>,<
	CPRTXT ^/BONNE JOURNEE/>
	BR HELLO2

HELLO:	MOV USER,U
	JSR PC,RUNME	;IN CASE CALLED BY GUN
HELLO2:	PRCR
	MOV #LOCKUS,D
	JSR	PC,LCUGRB
	JSR	PC,NODEV	;FREE ALL DEVICES
	MOV USER,U
	MOV #FRNEWU,FLSRES(U)
	CLR FLSADR(U)
	CLR BRAKE(U)
	MOV	UTTY(U),E
	JSR	PC,UCINIT	;INITIALIZE CONSOLE
	MOV SPDLP,P
	JMP NEXTUS


GUN:	JSR	PC,G1NARG
	TST	B
	BGE	.+4
GUNE:	ERROR+IFN
	CMP	B,NUSERS
	BGE	GUNE
	MUL #LUBLK,B
	MOV B,U
	CLR	FLSRES(U)
	CLR	FLSADR(U)
	MOV	#GOODBYE,UPC(U)
	MOV PC,BRAKE(U)
	SEZ
	RTS PC


VERSN:	MOV LVERNF,B
	BR	RANDO1
RANDOM:
	MOV RNSEED,B	;GET OLD SEED
	MUL #71275,B	;MUL SEED BY GOOD NUMBER!!
	ADD #13713,B	;ADD ANOTHER GOOD NUMBER!! TO LOW ORDER PART
	MOV B,RNSEED	;THIS IS THE NEW SEED
	MOV B,A
	MUL #10.,A	;MULTIPLY IT BY 10
	MOV A,B		;HIGH-ORDER PART IS THE DESIRED DIGIT
	ADD #5,B
RANDO1:	JMP R1NARG
BELL:	MOV #7,D
	BR .+6
CR:	MOV #1,D
	JSR PC,TYO
	SEZ
	RTS PC
DEBUGL:	TST ALEVN
	BEQ DEBUG1
	PRTXTC ^\OFF\
	CLR ALEVN
	JMP ERTL2
DEBUG1:	PRTXTC ^\ON\
	MOV #1,ALEVN
DEBUG2:	SEZ
	RTS PC
SGCF:	JSR PC,CKSST
	BIS #MGCF,FLAGS2
	SEZ
	RTS PC
CGCF:	JSR PC,CKSST
	BIC #MGCF,FLAGS2
	SEZ
	RTS PC
STATUS:	BIT #SSF,FLAGS2
	BNE	STATU2	;IF ON TURN OFF
	JSR PC,TINECH
	JSR PC,RDSTR	;READ A STRING
	BEQ	STATU2	;EMPTY OR BREAK
	MOV @S,B	;SEE IF EQUAL TO "SECRET
	MOV #SECRET,C
	JSR PC,EQ.TXT
	BEQ STATU1	;NOPE
	BIS #SSF,FLAGS2	;YES
	POPS A	;POINTER TO STRING READ IN
	PRTXTC	^\ON\
	BR	STATU3
STATU1:	POPS	A
STATU2:	PRTXTC	^\OFF\
	BIC	#SSF,FLAGS2
STATU3:	JSR	PC,TIECH
	SEZ
	RTS PC

CKSST:	TST DEBSW
	BNE CKSST1
	BIT #SSF,FLAGS2
	BEQ .+4
CKSST1:	RTS PC
	ERROR+HNM1

SPNF:			;SET PRINT NODES FLAG
	BIS #PNNLF,FLAGS2
	SEZ
	RTS PC
CPNF:	BIC #PNNLF,FLAGS2	;CLEAR IT
	SEZ
	RTS PC

COMT:	.BUG.		;GNT SHOULD SWALLOW ALL COMMENTS;
			; THEY SHOULD NEVER BE SEEN BY EVAL

;EXAMINE AN ABSOLUTE LOCATION
EXAMINE: JSR PC,CKSST	;MAKE SURE USER IS PRIVILEGED
	JSR	PC,GLWANE	;GET A WORD OF ARGUMENT
	BEQ DEPO1
	MOV	#INUM,A
	MOV	#8.-10.,ABASE
	JSR	PC,CONVERT	;CONVERT ARGUMENT TO OCTAL NUMBER IN B
	BEQ DEPO1
	MOV B,C
	JSR PC,.LDP2
	MOV A,B
	BIC #1,B	;MAKE SURE NOT BYTE
	MOV (B),WVALUE	;SAVE CONTENTS FOR VALUE TO OUTPUT
	JSR	PC,PLOCB	;PRINT LOCATION & CONTENTS
	CLR	ABASE
	RTS PC

;DEPOSIT IN AN ABSOLUTE LOCATION
DEPOSIT:	JSR PC,EXAMINE	;PRINT LOCATION
	PUSH B		;SAVE LOCATION
	SPUSH	(B)	;AND FORMER CONTENTS
	JSR PC,RDSTR	;READ A LINE FROM THE TTY
	BEQ	DEPOS2	;EMPTY
	MOV #INUM,A
	MOV @S,B
	MOV	#8.-10.,ABASE	;MAKE FOLLOWING CONVERSION OCTAL
	JSR PC,CONVERT	;CONVERT TO NUMBER
	BNE .+4
DEPO1:	ERROR+WTAB	;CONVERSION FAILED
	MOV B,C
	JSR PC,.LDP2	;GET NUMBER BACK IN A
	POP D		;FORMER CONTENTS
	SPOP B		;LOCATION
	MOV A,WVALUE	;SAVE NEW VALUE AS CONTENTS
	MOV A,(B)	;DEPOSIT
	CMP	(B),D
	BEQ	DEPOS1	;BR IF LOCATION NOT CHANGE
	TST USER
	BLE DEPOS1	;IF USER ALREADY ON SYSTEM CONSOLE
	JSR A,SPRINT
	JSR PC,PLOCB	;PRINT LOC AND NEW CONTENTS
	PRTXT ^/ WAS: /
	MOV D,A
	JSR PC,PRON	;PRINT OLD CONTENTS
	PRCR
	SPREND
DEPOS1:	CLR	ABASE	;SET CONVERT BASE BACK TO DECIMAL
	RTS PC		;DONE.
DEPOS2:	POP B
	SPOP B
	BR DEPOS1


;OUTPUT LAST CONTENTS SEEN IN AN EXAMINE OR DEPOSIT
VALUE:	MOV WVALUE,B
	JMP R1NARG
	.STITL ERRORS AND HANDLER
EMTBK:	MOV #SRET,@P	;FAKE IT OUT
	RTT
ERRBK:	PUSH A
ERBK2:	MOV #WDIRSW,D
	JSR PC,LCUGRB
	MOV #PGRAB,D
	JSR PC,LCUGRB	;RLEASE PAPER TAPE
	TST REDFLG
	BEQ ERBK3	;FINISH UP PENDING PROC DEF
	CLR FILFLG
	TST TOPRNM
	BEQ ERBK3
	JSR PC,END
ERBK3:	TST WRTFLG
	BEQ .+6
	JSR PC,WDELBL
	MOV #TYI,GCHR
	MOV #TYO,PCHR
	MOV 2(P),A
	MOV A,LASTER
	MFPI -2(A)	;GET ERROR NUMBER (CROCK!!!)
	MOV (P)+,A
	BIC #177400,A
	CMP A,ERRORN	;SAME OLD ERROR?
	BEQ ERBK4
	MOV A,ERRORN
	ASL A
	SPUSH 	B
	SPUSH A
	JSR PC,SYDRBG
	CLR (A)+
	SPOP B
	MOV ERTAB(B),(A)
	SUB ERTAB+2(B),(A)
	ASR (A)+
	SPUSH C
	SPUSH F
	MOV USER,F
	MOV SLOTAS(F),C
	MOV #ERRBUF-PURE,(A)
	MOV SLOTHA(C),F
	ADD SLOTCA(C),(A)+
	ADC F
	ASH #4,F
	MOVB F,6(A)
	SPOP F
	SPOP C
	CLR 2(A)
	MOV ERTAB(B),(A)
	ASR (A)
	ADD ERBASE,(A)+
	ADC (A)
	ADD ERBASE+2,(A)+
	TST (A)+
	BISB #DREADC,(A)
	JSR PC,DSKWAI
	MOV #ERRBUF,ERRPT
	SPOP B
	MOV ERRORN,A
ERBK4:	CLR NTOKEL
	CLR NLINEL
	MOV CPP,NPROCL
	BEQ ERBK5
	MOV CPLN,NLINEL
	MOV CTN,NTOKEL
ERBK5:	CMP A,#BUG	;DONT ALLOW ERRSET FOR .BUG. OR FBUG
	BEQ ERSET3
	CMP A,#FBUG
	BEQ ERSET3
	TST ERPROC	;ERROR SET ON?
	BEQ ERSET2
	JSR F,CACSAV
	PUSH CO
	SPUSH CO+2
	SPUSH NOR
	MOV USER,U	;SAVE BRAKE STATUS
	SPUSH BRAKE(U)
	CLR BRAKE(U)
	MOV (P),BRAKEL
	BEQ .+6	;IF THERE REALLY WAS A BRAKE PENDING,
	JSR PC,BRAKR	;ALLOW TYPEOUT AGAIN
	SPUSH ERPROC
	MOV ERPROC,CO+2
	CLR ERPROC
	JSR PC,SAVPPS	;YES - SAVE THE PDLS
	BIS #1,CSPDLP	;INDICATE ERRORSET PUSH
	BIS #1,CPDLP
	MOV #UFUN,CO
	CLR NOR
	BIC #DORF,FLAGS	;NOTE THAT THIS IS NOT A RUN FRAME
	JSR PC,PEVAL
	BEQ ERSET1	;DIDNT OUTPUT
	JSR PC,PRS1	;DID OUTPUT, PRINT IT
	JSR PC,RESPPS
	POP ERPROC
	JMP ERTLN	;THEN ERROR RETURN
ERSET1:		;DIDNT OUTPUT, DO WHAT U WERE GOING TO
	JSR PC,RESPPS
	POP ERPROC
	MOV USER,U
	SPOP BRAKE(U)
	SPOP NOR
	SPOP CO+2
	SPOP CO
	JSR F,CACRES
ERSET2:
	TST NOADDR
	BNE NEWER4
ERSET3:
	MOV 2(P),A
	JSR PC,PRONL	;PRINT ADDR WHERE ERROR OCCURED
	SPACE
NEWER4:	MOV #ERRBUF+6,ERRPT
	.IFNZ ENG&FR
	BIT #FRFLG,LANG
	BEQ NEWER1
	INC ERRPT
	TSTB @ERRPT
	BNE .-10
	INC ERRPT
	.ENDC
NEWER1:	MOVB @ERRPT,D
	BEQ ERTLN
	BGT NEWER2
	BIC #177600,D
	ASL D
	MOV ROTTAB(D),A
	INC NBKTS
	JSR PC,(A)
NEWER3:	INC ERRPT
	BR NEWER1
NEWER2:	JSR PC,TYO
	BR NEWER3
ERRRT:	POP A
	RTT

PPLACE:	MOV FUNLEV,A
	BEQ PPLAC1
LANGC	<CPRTXT ^\AT LEVEL \>,<
	CPRTXT ^/AU NIVEAU />
	JSR PC,PRDN
LANGC	<PRTXT ^\  LINE \>,<
	PRTXT ^/ LIGNE />
	MOV CPLN,A
	JSR PC,PRDN
LANGC	<PRTXT ^\  IN \>,<
	PRTXT ^/ DE />
	MOV CPP,B
	JSR PC,PPNAME
PPLAC1:	JMP .CRLF

ERTLN:			;ERR RETURN TO LEVEL N
	TST ALEVN
	BEQ ERTL0
ERPO1:
	.IIF NE WADESW,JSR PC,RRPOP
	BIS #ERRF+BRKF,FLAGS
	MOV USER,U
	CLR BRAKE(U)
ERTLN1:	JSR PC,PPLACE
	JMP MLOOP
ERTL0:			;ERR RETURN TO LEVEL 0
	MOV	USER,U
	CLR	BRAKE(U)
ERTL01:
	.IIF NE WADESW,JSR PC,RRPOP
	JSR PC,PPLACE
EXIT:
ERTL2:	TST FUNLEV	;POP UP TO LEVEL 0
	BLE ERTL3
	MOV #ERTL2,PSTOPR
ERTL4:	MOV #PSTP15,A
	MOV A,ERFRET	;SET UP ERROR FRAME RETURN
	MOV A,DOFRET
	JMP (A)
ERTL3:	CLR A	;CLEAR OUT PDLS
	JSR PC,PPTA
	CLR A
	JSR PC,PSTA
	CLR CSPDLP
	CLR CPDLP
	MOV #ERCLR1,A
	MOV #<ERCLR2-ERCLR1>/2,B
	CLR (A)+
	SOB B,.-2
	BIC #EDTIF+ERRF+BRKF,FLAGS
	JMP MLOOP
.ERPOP:	PRTXT ^\ERPOP TO\
	TST FUNLEV
	BLE ERTL3
	MOV #ERPO1,PSTOPR
	BR ERTL4

	;POP RUN AND READ FRAMES
RRPOP:	SPOP C	;SAVE RETURN ADDR
ERTLN2:		BIT #DORF,FLAGS
	BEQ ERTLN4
ERTLN3:	JSR PC,RESPPS
	SPOP B
	BIT #TF7,TFLAGS
	BEQ ERTN32
	MOV B,ERPROC
	BR ERTLN3
ERTN32:	JSR PC,RESEVL
	MOV B,FLAGS
	BR ERTLN2
ERTLN4:	JMP @C

	.STITL ERROR ROUTINES
		; ****  THESE ARE NOW ALPHABETIZED   *****

.IIF NDF MAXELN,MAXELN==0

BRK.R:	MOV USER,U
	MOV BRAKE(U),A
	CLR BRAKE(U)
	JSR PC,BRAKR
	TST A
	BLT PAUSE
BRK.2:
	JSR	PC,BRKMOF	;TURN OFF MUSIC BOX IF HE HAS IT
LANGC	<PRTXT ^\BREAK\>,<
	PRTXT ^/ARRET/>
	JMP ERTL01

PAUSE:	BIS #BRKF,FLAGS
	SPUSH	MUCWRD	;SO THAT CONTINUE WILL WORK (GROAN)
	JSR	PC,BRKMOF	;TURN OFF MUSIC BOX IF HE HAS IT
	SPOP	MUCWRD
	PRTXT ^\PAUSE \
	JMP ERTLN1

BUG.R:	TST	DEBSW
	BNE	BUG.1	;BR IF DEBUGGING
	DEC NSYBUG
	BGE .+4
	ERROR+FBUG
BUG.1:	PRTXT ^/HELP!!!  SYSTEM BUG VER=/
	MOV #VERNF,A
	JSR PC,PRDN
	JSR PC,.SPACE
	PUSH	E
	SPUSH	U
	MOV	USER,U
	MOV	UTTY(U),E
	TST	TOTN(E)
	BGT	.-4	;WAIT TILL TYO BUF EMPTY
	POP	U
	SPOP	E
	SPOP A
	TST	DEBSW
	BEQ	.+4
BUGBPT:	BPT	;BRK IF IN DEBUG MODE
	MOV 6(P),A
	JSR PC,PRONL
	JMP ERTLN

CTIT.R:	MOV TOPRNM,B
	JMP PPNAME

HNM.R:	MOV #UFUN,A
	JMP PROAB

LDE1.R:	MOV JPLN,CPLN	;MAKE JUMPED-FROM LINE = POINT OF ERROR
WTIB.R:	MOV B,A
	JMP PRDN	;LINE # SHOULD BE IN A

TDE.R:	ASR	E
	MOV	E,A
	JMP	PRDN

PAE.R:	MOV #UFUN,A
	MOV TEMP,B
	RTS PC

PNH1.R:	MOV CPP,B
	MOV #UFUN,A
	RTS PC

TMAP.R:	TST (P)+
	JMP ERRRT

WTA.R:	RTS PC

WTAA.R:	PUSHS A
	RTS PC

WTAB.R:	PUSHS B
	RTS PC
