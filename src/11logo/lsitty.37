.SBTTL LSI TTY INTERRUPT ROUTINES
			;TTY RECIEVER INTERRUPT HANDLER
LSTINT:	SAVE A
	MOVB LSRBUF,A
	BIC #177600,A
	CMPB A,#'G-100	;CTRL G?
	BEQ LSBRAK
	CMPB A,#'Z-100	;CTRL Z?
	BEQ LSPAUS
	CMP LSINN,#LSBUFL	;BUFFER FULL?
	BEQ RTTAL		;IF SO, THIS CHAR LOSES
	INC LSINN	;IF NOT, 1 MORE CHARACTER
	CMP LSINZ,LSINBE	;TIME TO WRAP PTR?
	BLO 2$		;NO
	MOV #LSINBF,LSINZ	;YES
2$:	MOVB A,@LSINZ	;GRAB BYTE FROM TTY INTO INPUT BUFFER
	INC LSINZ	;UPDATE PTR
RTTA:	REST A
	RTT
RTTAL:	INC LSILSC	;ONE MORE LOST CHARACTER
	BR RTTA

LSBRAK:	MOV #1,BRAKE	;SIGNAL LOGO THAT THERE'S A BREAK
BRRET:	MOV #1,LSIBRK	;AND SIGNAL LSITTY CODE AS WELL
	BR RTTA

LSPAUS:	MOV #-1,BRAKE	;SIGNAL LOGO THAT THERE'S A PAUSE
	BR BRRET

LSTONT:	TST LSOTN	;ANY MORE CHARS?
	BEQ 3$		;IF NOT, DONE
	MOVB @LSOTA,LSXBUF	;XMIT CHAR
	DEC LSOTN	;CHAR JUST FINISHED BEING OUTPUT, DEC COUNTER
	INC LSOTA	;AND UPDATE PTR TO NEXT CHAR TO GO
	CMP LSOTA,#LSOTBF+LSBUFL	;TIME TO WRAP?
	BLO 2$		;NO
	MOV #LSOTBF,LSOTA	;YES
2$:	RTT
3$:	BIC #100,LSXCSR	;DISABLE INTERUPTS
	RTT

.SBTTL LSI EMULATOR TRAP ROUTINE
;HERE WE IMPLEMENT SOME PSEUDO-SITS SYSTEM CALLS, NOTABLY BYTI/O AND SOME
;TTY INVOKES

LSIEMT:	MOV P,LSEMTP	;SAVE PTR TO TOP OF STACK
	SAVE <A,B,C>
	MOV LSEMTP,A
	MOV (A),A	;GET PTR TO WORD AFTER EMT INSTR
	MOV -2(A),A	;GRAB EMT INSTR
	BIC #177600,A	;CLEAR ALL BUT DISPATCH #
	ASL A		;=>WORD OFFSET
	JSR PC,@LSETAB(A)	;DISPATCH
	REST <C,B,A>
LSTEMP:	RTT

LSLOSE:	BPT		;PLACE FOR WAYWARD PSEUDO-SITS SYSTEM CALLS
	RTS PC
.SBTTL TTY INVOKS
			;LSIEMT IS TRAPPED TO BY PSEUDO-SITS SYSTEM CALLS,
			;AND DISPATCHES HERE THRU LSETAB
			;LSEMTB HOLDS PTR TO IMMEDIATELY POST-TRAP TOP OF STACK
			;LSINVK CAN CLOBBER A, B, C
LSINVK:	MOV LSEMTP,A
	TST 4(A)	;SYSTEM-FUNCTION BIT SET ON INVOK 1ST ARG?
	BPL 1$		;NO, CONTINUE
2$:	BR LSLOSE	;YES, FAIL

1$:	CMPB 4(A),#2	;TTY INVOK?
	BEQ 3$
	CMPB 4(A),#3	;TTY INVOK?
	BNE 2$		;IF NOT, FAIL
3$:	MOVB 5(A),B	;GET FUNCTION BYTE FROM 1ST INVOK ARG
	BIC #177740,B
	ASL B
	JMP @LSITAB(B)	;DISPATCH TO APPROPRIATE ROUTINE

;INVOK DISPATCH ROUTINES ARE CALLED FROM LSINVK THRU LSITAB
;CALLED WITH IMMEDIATELY POST-TRAP STACK PTR IN A
;THESE ROUTINES REFORM THE STACK SO IT'LL BE THE RIGHT THING WHEN THE $INVOK RETURNS
;MAY CLOBBER A,B,C


			;.TTMOV ROUTINE
LSTTMV:	MOV 6(A),LSITTS	;MOVE 2ND INVOK ARG TO LSITTS
			;OTHERS ENTER HERE TO FLUSH 3 INVOK ARGS FROM MID-STACK
LSSTF3:	ADD #4,A	;POINT TO WORD UNDER RETURN PSW
1$:	MOV -(A),6(A)	;MOVE THE UPPER PART OF THE STACK DOWN 3 WORDS
	CMP A,P
	BHI 1$
	ADD #6,P	;POP 3 WDS TO NEW STACK TOP
	RTS PC


			;.TTBIS ROUTINE
LSTTBS:	BIS 6(A),LSITTS	;SET LSITTS BITS AS SPECIFIED BY 2ND INVOK ARG
	BR LSSTF3	;AND FLUSH INVOK'S 3 ARGS FROM MID-STACK


			;.TTBIC ROUTINE
LSTTBC:	BIC 6(A),LSITTS	;CLEAR LSITTS BITS AS SPECIFIED BY 2ND INVOK ARG
	BR LSSTF3	;AND FLUSH INVOK'S 3 ARGS FROM MID-STACK


			;.TTRD ROUTINE
LSTTRD:	MOV LSITTS,10(A)	;CLOBBER INVOK'S 2ND STACKED ARG WITH LSITTS
LSTTR1:	JMP LSSTF2	;AND FLUSH 2 ARGS FROM MID-STACK


			;.TTCNO ROUTINE
LSTTCN:	BIT #.TTWRT,LSITTS	;WRITE MODE?
	BEQ 1$		;IF NOT, READ LSCHNO FOR USER
	CMP 6(A),LSCHMX	;IF SO, IS INTENDED NEW LSCHNO REASONABLE
	BGT 2$		;IF NOT, NOOP
	TST 6(A)
	BMI 2$
	MOV 6(A),LSCHNO	;2ND INVOK ARGF BECOMES NEW LSCHNO
	BR LSSTF3	;FLUSH 3 ARGS FROM MID-STACK

2$:	RTS PC

1$:	MOV LSCHNO,6(A)	;CLOBBER INVOK'S 2ND STACKED ARG WITH LSCHNO
	BR LSTTR1

LSTTPK:	TST LSINN	;ANY CHARS?
	BNE 1$		;YES
	MOV #-1,10(A)	;NO, RETURN -1 IN LIEU OF STACKED TTYCAP
	BR LSTTR1
1$:	MOVB @LSINA,10(A)	;WE'VE GOT A CHAR, RETURN IT
	CLRB 11(A)
	BR LSTTR1
.SBTTL LSITYI AND LSITYO
;THESE ARE IN LIEU OF SITS TYI & TYO, NOT *LOGO* TYI & TYO
			;PUT NEXT INPUT BUFFER CHAR INTO A
LSITYI:	TST LSIBRK	;BREAK?
	BNE 2$		;IF SO, RETURN IMMEDIATELY
	TST LSINN	;ANYONE HOME?
	BNE 3$		;IF NOT, WAIT
	JSR PC,INCHK	;DO AN INCREMENT OF CHECKING WHILE WAITING
	BR LSITYI
3$:	MOVB @LSINA,A	;GET CHAR
	BIC #177600,A	;FIX HI BYTE, JUST IN CASE
	INC LSINA	;ADVANCE PTR
	CMP LSINA,LSINBE	;TIME TO WRAP?
	BLO 1$		;NO
	MOV #LSINBF,LSINA	;YES
1$:	DEC LSINN	;1 LESS CHAR IN INPUT BUFFER
	CLZ		;SIGNAL NO BREAK
	RTS PC
2$:	CLR A
	RTS PC		;RETURN WITH Z SET

			;PUT BYTE FROM B INTO OUTPUT BUFFER
LSITYO:	TST LSIBRK	;BREAK?
	BNE 2$		;IF SO,RETURN IMMEDIATELY
	CMP LSOTN,#LSBUFL	;OUTPUT BUFFER FULL?
	BEQ LSITYO	;IF SO, WAIT
	MOVB B,@LSOTZ	;PUT BYTE INTO BUFFER (MUST BE DONE *BEFORE* INC'ING LSOTN!!)
	INC LSOTN	;INDICATE ONE MORE BYTE IN BUFFER
	INC LSOTZ	;ADVANCE PTR
	CMP LSOTZ,#LSOTBF+LSBUFL	;TIME TO WRAP?
	BLO 1$		;NO
	MOV #LSOTBF,LSOTZ	;YES
1$:	BIS #100,LSXCSR	;ENABLE INTERUPT TO BE SURE CHAR GETS OUT
2$:	RTS PC

.SBTTL LSI BYTI
;LSBYTI IS CALLED THRU A DISPATCH TABLE (LSETAB) FROM LSIEMT, WHERE
;PSEUDO-SITS SYSTEM CALLS TRAP TO.
;LEAVES BYTE ON STACK WHERE $BYTI'ER EXPECTS IT.
;CLOBBERS A,B (THO LSIEMT WILL RESTORE THEM TO THEIR PRE-TRAP VALUES)
;LSBYTI RTNS DISPATCHED THRU LSBIDS MAY CLOBBER A,B
;LSBYTI ACT PRETTY MUCH LIKE SITS BYTI, USING LSITTS AS THE TTY STATUS WD
;NOTE, HOWEVER:
;		1) CTRL Y ISN'T IMPLEMENTED HERE. RATHER, THE PREVIOUS TYPED
;		LINE IS BY DEFAULT IN THE EDIT BUFFER (IN FACT THERE IS
;		NO EDIT BUFFER, JUST THE OLD LINE BUFFER) AND ALL LINE-
;		INPUT BYTI'S ARE IN EDIT MODE (NO .TIEDM BIT)
;
;		2) IF BACKSPACEABLE TTY (LSTVEE=1), RUBOUTS AND CTRL W'S WORK
;		THE RIGHT WAY, AND CTRL S AND CTRL D EDIT COMMANDS ARE FLUSHED.
;
;		3) SOME TTY MODE BITS AREN'T IMPLEMENTED HERE

LSBYTI:	JSR PC,LSRSET	;RESET TTY BUFFERS IF BREAK OCCURRED
	BIT #.TLIPM,LSITTS	;LINE INPUT MODE?
	BEQ LSNLIM		;NO
	TST LSBYLP	;YES, IS THERE A LINE PENDING FROM A PREVIOUS .TLIPM BYTI?
	BNE LSBRTC	;IF SO, JUST RETURN A CHAR FROM LINBUF
	INC LSBYLP	;IF NOT, THERE IS NOW--MAKE FLAG NONZERO
LSBLLL:	JSR PC,LSITYI	;GET NEXT INPUT-BUFFER BYTE INTO A
	BEQ LSBYDN	;IF INTERRUPTED BY A BREAK, RETURN IMMEDIATELY
	JSR PC,LSBIUC	;UPPER-CASIFY A IF APPROPRIATE
	ASL A
	JSR PC,LSBIDP	;DISPATCH ON CHAR, SEZ IFF UNQUOTED CR
	CMP #15,A		;IS IT A CR?
	BEQ 7$
	CMP LSCLNN,#LSLINL	;IF NOT, IS LSCLIN FULL?
	BNE LSBLLL	;IF NOT, KEEP GOING

7$:	MOV #LSLINL/2,A	;STASH CURRENT LINE IN OLD LIN BUF TOO
	MOV #LSCLIN,B
1$:	MOV (B)+,LSLINL-2(B)
	SOB A,1$
	MOV LSCLNA,LSOLNA	;STASH POINTERS AS WELL
	ADD #LSLINL,LSOLNA
	MOV LSCLNZ,LSOLNZ
	ADD #LSLINL,LSOLNZ
	MOV LSCLNN,LSOLNN	;AND # OF BYTES

LSBRTC:	MOVB @LSCLNA,A	;GRAB NEXT BYTE FROM LINBUF
	DEC LSCLNN
	TST LSCLNN	;ANY MORE BYTES?
	BLE LSBYNM	;NO
	INC LSCLNA	;YES, INC PTR
	CMP LSCLNA,#LSCLIN+LSLINL	;TIME TO WRAP?
	BLO 1$
	MOV #LSCLIN,LSCLNA	;YES
1$:	CMPB A,#15	;END OF LINE?
	BNE LSBYDN	;IF NOT, GO FINISH UP

LSBYNM:	CLR LSBYLP	;NO MORE PENDING LINE
	CLR LSCLNN	;NO MORE BYTES IN CUR LIN BUF
	MOV #LSCLIN,LSCLNA	;REINIT PTRS
	MOV #LSCLIN,LSCLNZ
	
LSBYDN:	MOV LSEMTP,B	;PTR TO STACKED TRAP RETURN ADDR
	MOV A,4(B)	;BYTI'S RETURN VALUE REPLACES BYTI'S (IGNORED) ARG ON STACK
	BIC #4,2(B)	;CLZ FOR RETURN PSW
	RTS PC

LSNLIM:	JSR PC,LSITYI	;GET NEXT INPUT-BUFFER BYTE INTO A
	JSR PC,LSBIUC	;UPPER-CASIFY A IF APPROPRIATE
	CMP #37,A	;IS IT CONTROLIFY?
	BNE LSBYDN
	BIT #.TICTM,LSITTS	;CONTROLIFY?
	BEQ LSBYDN	;NOPE
	JSR PC,LSITYI	;GET NEXT
	JSR PC,LSBIUC
	BIC #100,A
	BR LSBYDN		; (DEPENDING ON LSITTS BITS) VALUE IN A

LSBIDP:	CMP #100,A		;CONTROL?
	BHI 1$			;YES, DISPATCH
	CMP #376,A		;RUBOUT?
	BNE 2$
	JMP LSBIRU		;YUP
2$:	JMP LSBINO
1$:	JMP @LSBIDS(A)

LSBIDS:	LSBINO,LSBINO,LSBINO,LSBI.C,LSBI.D,LSBINO,LSBINO,LSBINO	;0-7
	LSBINO,LSBINO,LSBINO,LSBINO,LSBINO,LSBINO,LSBI.N,LSBINO	;10-17
	LSBINO,LSBI.Q,LSBI.R,LSBI.S,LSBINO,LSBINO,LSBINO,LSBI.W	;20-27
	LSBINO,LSBINO,LSBINO,LSBINO,LSBINO,LSBINO,LSBINO,LSBIUP	;30-37

			;CONVERT BYTE IN A TO UPPER CASE IF .TICVM SET
LSBIUC:	BIT #.TICVM,LSITTS	;=> UPPER CASE MODE?
	BEQ 1$
	CMP A,#141	; < a ?
	BLT 1$
	CMP A,#172	; > z ?
	BGT 1$
	BIC #40,A	;NO, UPPER CASIFY
1$:	RTS PC


LSRSET:	TST LSIBRK	;IF BREAK OCCURRED, RESET THE TTY BUFFERS
	BEQ 1$		;IF NOT, NOOP
	CLR LSIBRK	;DON'T WANT TO DO THIS AGAIN
	MOV #LSINBF,LSINA	;RESET ALL TTY STUFF
	MOV #LSINBF,LSINZ
	CLR LSINN
	MOV #LSOTBF,LSOTA
	MOV #LSOTBF,LSOTZ
	CLR LSOTN
	MOV #LSCLIN,LSCLNA
	MOV #LSCLIN,LSCLNZ
	CLR LSCLNN
	MOV #LSOLIN,LSOLNA
	MOV #LSOLIN,LSOLNZ
	CLR LSOLNN
	CLR LSBYLP
1$:	RTS PC

;ALL BYTI DISPATCH ROUTINES ARE CALLED FROM LSBYTI THRU LSBIDS, OR FROM OTHER
;BYTI DISPATCH ROUTINES.
;ALL BYTI DISPATCH ROUTINES ARE CALLED WITH BYTE*2 IN A.
;BYTI DISPATCH ROUTINES MAY CLOBBER A,B
;ONLY THE ROUTINE FOR AN UNQUOTED CR SHOULD RETURN WITH Z SET.

			;NORMAL MODE. RETURNS BYTE IN LSCLIN IF .TLIPM SET,
			; OR IN A IF .TLIPM CLEARED. ECHOS CHAR IFF .TIECM SET.
LSBINO:	ASR A		;=>BACK TO RIGHT-JUSTIFIED BYTE
	MOVB A,@LSCLNZ	;YES, STICK IN IN THE LINE BUFFER
	INC LSCLNZ	;ADVANCE  PTR
	CMP LSCLNZ,#LSCLIN+LSLINL	;WRAP?
	BLO 1$		;NO
	MOV #LSCLIN,LSCLNZ	;YES
1$:	INC LSCLNN	;INC COUNTER
LSBIN1:	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ LSBIN2		;NO, ALL DONE
	BIT #.TIMGO,LSITTS	;ECHO ONLY WORKS IF NOT IN IMAGE OUT MODE
	BNE LSBIN2
	TST LSTVEE	;TV-TYPE TTY?
	BNE 5$		;IF SO, WE DON'T CARE ABOUT RUBOUTS

	TST LSRIP	;RUBOUT IN PROGRESS?
	BEQ 5$		;NO
	CLR LSRIP	;YES, BUT NO
	MOV #'\*2,B	;TYPE BACKSLASH
	JSR PC,LSBONO

5$:	MOV A,B		;SET UP ARG IN B FOR ECHO
	JSR PC,LSBOD	;AND DISPATCH THRU BYTO'S TABLE TO ECHO
LSBIN2:	RTS PC


			;RUBOUT ROUTINE
LSBIRU:	JSR PC,LSRUBO	;PUT LAST CHAR, IF ANY, IN A, FLUSHING FROM LSCLIN
	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ LSBIR4		;NO, GO HOME
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BNE LSBIR4		;YES, LIKEWISE
			;LSBI.W ENTERS HERE
LSBIR1:	TST LSTVEE	;BACKSPACE/ERASABLE CONSOLE?
	BEQ LSBIR5	;NO, SHIT
	TST A		;WAS THERE A CHAR TO RUB OUT?
	BMI LSBIR4		;NO, NOOP
	MOV #10*2,B	;BSPER CHAR
	JSR PC,LSBOBE	;TYPE BACKSPACE/ERASE
LSBIR4:	RTS PC

LSBIR5:	TST A		;WAS THERE A CHAR TO RUB OUT?
	BMI LSNMRB	;NO
LSBIR2:	TST LSRIP	;YES, IS RUBOUT IN PROGRESS? (LSBI.S & LSBI.D ENTER HERE)
	BNE 4$		;YES
	INC LSRIP	;NO, NOW IT IS
	MOV #'\*2,B
	JSR PC,LSBONO	;TYPE BACKSLASH
4$:	MOV A,B		;SET UP ARG IN B FOR LSBODS
	ASL B
	JSR PC,LSBOD	;ECHO RUBBED CHARACTER
	CLZ
	RTS PC

LSNMRB:	TST LSRIP	;NOTHING LEFT TO RUB. RUBOUT IN PROGRESS?
	BEQ 5$		;NO, NOOP
	CLR LSRIP	;YES, BUT NO LONGER
	MOV #'\*2,B	;TYPE BACKSLASH
	JSR PC,LSBONO
5$:	CLZ
	RTS PC


			;CTRL W ROUTINE
LSBI.W:
	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ 4$		;NO, GO TO SILENT LOOP
	BIT #.TIMGO,LSITTS	;IMAGE OUT?
	BNE 4$		;YES, GO TO SILENT LOOP

	JSR PC,LSRUBO	;PUT LAST CHAR IN A (IF ANY, ELSE -1=>A), FLUSHING FROM BUFFER
	JSR PC,LSBIR1	;BORROW LSBIRU CODE FOR ECHOING, ETC
2$:	JSR PC,LSRUB1	;RUBOUT AGAIN, UNLESS NONE LEFT, **OR WORD BOUNDARY**
	BEQ 3$
	JSR PC,LSBIR1	;IF NOT, GO ON
	BR 2$
3$:	RTS PC
	
4$:	JSR PC,LSRUBO	;SILENT LOOP--RUBOUT WORD WITHOUT ECHOING
5$:	JSR PC,LSRUB1	
	BNE 5$
	RTS PC

			;CTRL C ROUTINE
LSBI.C:	JSR PC,LSEBTI	;GET NEXT BYTE FROM EDIT BUFFER, IF ANY, INTO LSCLIN AND A
	BEQ LSRTSX		;IF NONE, NOOP
	JMP LSBIN1	;DO PROPER ECHOING


			;CTRL N ROUTINE
LSBI.N:	JSR PC,LSEBTI	;GET NEXT BYTE,IF ANY,FROM EDIT BUFER INTO LSCLIN AND A
	BEQ LSRTSX		;IF NOTHING LEFT, QUIT
	JSR PC,LSBIN1	;ECHO
	TSTB LSBOUN(A)	;WORD BOUNDARY CHAR?
	BEQ LSBI.N		;IF NOT, GO ON
LSRTSX:	CLR A		;MAKE SURE NO LEFT OVER CR HERE
	RTS PC
			;CTRL R ROUTINE
LSBI.R:	JSR PC,LSEBTI	;GET NEXT BYTE, IF ANY, FROM EDIT BUFFER INTO LSCLIN AND A
	BEQ LSRTSX		;IF NOTHING LEFT, QUIT
	JSR PC,LSBIN1	;ECHO CHARACTER
	BR LSBI.R	;AND GO ON TO NEXT


			;CTRL D ROUTINE
LSBI.D:	TST LSTVEE	;GOOD TTY?
	BEQ 3$		;IF NOT, PROCEED
	JMP LSBINO	;IF SO, WE DON'T WANT A CTRL D EDIT CHAR, TREAT AS NORMAL
	
3$:	JSR PC,LSEBI1	;GET NEXT BYTE FROM EDIT BUFFER, IF ANY, INTO A
	BEQ LSRTSX		;IF NONE, NOOP
	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ LSRTSX		;IF NOT, ALL DONE
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BNE LSRTSX		;IF SO, ALL DONE
	JMP LSBIR2	;USE RUBOUT CODE TO ECHO SKIPPED CHAR PROPERLY

			;CTRL S ROUTINE
LSBI.S:	TST LSTVEE	;GOOD TTY?
	BEQ 3$		;IF NOT, PROCEED
	JMP LSBINO	;IF SO, WE DON'T WANT A CTRL S EDIT CHAR, TREAT AS NORMAL

3$:	JSR PC,LSEBI1	;GET NEXT BYTE FROM EDIT BUFFER, IF ANY, INTO A
	BEQ LSRTSX		;IF NONE, GIVE UP
	BIT #.TIECM,LSITTS	;ECHO MODE?
	BEQ 4$		;IF NOT, SKIP THE ECHO
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BNE 4$		;IF SO, SKIP THE ECHO
	JSR PC,LSBIR2	;USE RUBOUT CODE TO ECHO SKIPPED CHAR PROPERLY
4$:	TSTB LSBOUN(A)	;DID WE JUST SKIP A WORD BOUNDARY CHAR?
	BEQ 3$		;IF NOT, CONTINUE
2$:	RTS PC


			;UPARROW ROUTINE
LSBIUP:	BIT #.TICTM,LSITTS	;CONTROLIFY MODE?
	BNE 1$		;IF SO, PROCEED
	JMP LSBINO	;IF NOT, JUST RETURN CHAR IN A

1$:	JSR PC,LSITYI	;GET NEXT INPUT-BUFFER BYTE INTO A
	JSR PC,LSBIUC	;UPPER-CASIFY IF APPROPRIATE
	BIC #100,A	;CONTROLIFY THE CHARACTER
	ASL A
	JMP LSBIDP	;AND REDISPATCH


			;CONTROL Q ROUTINE
LSBI.Q:	JSR PC,LSITYI	;GET NEXT INPUT-BUFFER BYTE INTO A
	JSR PC,LSBIUC	;UPPER-CASIFY IF APPROPRIATE
	ASL A
	JMP LSBINO	;AND TREAT IT AS A NORMAL CHARACTER, WHATEVER IT IS

			;(NOT A DISPATCH ROUTINE)
			;FLUSH LAST CHAR FROM LSCLIN, PUTTING IT IN A
			;IF NO CHAR THERE, RETURN WITH Z SET & -1 IN A
LSRUBO:	TST LSCLNN	;ANYTHING LEFT TO RUB OUT?
	BEQ LSRBLU	;NO, RETURN WITH -1 IN A
	MOV LSCLNZ,A
	MOVB -1(A),A	;GET LAST BYTE INTO A
	BIC #177400,A
	BR LSRUB2

LSRUB1:	TST LSCLNN	;LIKE LSRUBO BUT FAILS ON WORD-BOUNDARY CHAR AS WELL
	BEQ LSRBLU	; AS WHEN NO CHAR LEFT IN BUFFER
	MOV LSCLNZ,A
	MOVB -1(A),A
	BIC #177400,A
	TSTB LSBOUN(A)	;BOUNDARY CHAR?
	BNE LSRBLU	;YES, LOSE

LSRUB2:	DEC LSCLNN	;ONE LESS CHAR IN LINBUF
	DEC LSCLNZ	;RETREAT PTR
	CMP LSCLNZ,#LSCLIN	;BKWDS WRAP?
	BHIS 2$		;NO
	MOV #LSCLIN+LSLINL,LSCLNZ	;YES
2$:	CLZ
	RTS PC
LSRBLU:	MOV #177777,A
	SEZ
	RTS PC



			;(NOT A DISPATCH ROUTINE)
			;READ CHAR FROM EDIT BUF INTO A
			;RETURN WITH Z SET IFF NOTHING THERE
LSEBI1:	TST LSOLNN	;ANY CHARS LEFT?
	BEQ 1$		;IF NOT, RETURN WITH Z SET
	MOVB @LSOLNA,A	;GET NEXT CHAR INTO A
	BIC #177400,A
	CMP A,#15	;CR?
	BEQ 1$		;IF SO, RETURN WITH Z SET
	DEC LSOLNN	;DEC COUNTER
	INC LSOLNA	;ADVANCE POINTER
	CMP LSOLNA,#LSOLIN+LSLINL	;WRAP?
	BNE 1$		;NO, RETURN WITH Z CLR
	MOV #LSOLIN,LSOLNA	;YES, RETURN WITH Z CLR
1$:	RTS PC


			;(NOT A DISPATCH ROUTINE)
LSEBTI:	JSR PC,LSEBI1	;PUT NEXT CHAR, IF ANY, FROM EDIT BUFFER INTO A
	BNE 2$		;IF SOMETHING WAS THERE, PROCEED
1$:	RTS PC		;ELSE, RETURN WITH Z SET

2$:	CMP LSCLNN,#LSLINL	;BUFFER FULL?
	BEQ 1$		;IF SO, RETURN WITH Z SET
	MOVB A,@LSCLNZ	;PUT CHAR INTO CURRENT LINE BUFFER
	INC LSCLNN	;INC COUNTER
	INC LSCLNZ	;ADVANCE PTR
	CMP LSCLNZ,#LSCLIN+LSLINL	;TIME TO WRAP?
	BNE 3$		;NO, RETURN WITH Z CLEAR
	MOV #LSCLIN,LSCLNZ	;YES, RETURN WITH Z CLEAR
3$:	RTS PC



.SBTTL LSBYTO
;LSBYTO IS DISPATCHED THRU LSETAB FROM LSIEMT, WHICH PSEUDO-SITS CALLS TRAP TO
;LSBYTO MAKES LSIEMT EMULATE SITS $BYTO, USING LSITTS AS TTY STATUS WORD
;A,B ARE CLOBBERED (BUT RESTORED TO PRE-TRAP STATE BY LSIEMT)
;$BYTO'S 2 ARGS ARE FLUSHED FROM MID-STACK BEFORE RETURN
LSBYTO:	JSR PC,LSRSET	;RESET TTY BUFFERS IF BREAK OCCURRED
	MOV LSEMTP,A	;GET PTR TO IMMED POST-TRAP TOP OF STACK
	MOV 6(A),B	;GET CHAR TO BYTO
	BIC #177400,B
	BIT #.TTEDM,4(A)	;WRITE INTO "EDIT" (OLD LINE) BUFFER?
	BNE LSEBTO	;YES
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BEQ 1$		;NO, PROCEED
	JSR PC,LSITYO	;YES, JUST SPIT IT OUT
	BR LSBTO1
1$:	JSR PC,LSBOD	;DISPATCH
LSBTO1:	BIC #4,2(A)	;CLZ FOR TRAP RETURN
			;(OTHERS ENTER HERE TO FLUSH 2 EMT ARGS FROM MID-STACK)
LSSTF2: ADD #4,A	;POINT TO WORD UNDER RETURN PSW
1$:	MOV -(A),4(A)	;FLUSH THE 2 $BYTO ARGS FROM MID-STACK
	CMP A,P
	BHI 1$
	CMP (P)+,(P)+	;POP 2 WDS TO NEW STACK TOP
	RTS PC

LSEBTO:	BIT #.TERST,LSITTS	;RESET "EDIT" (OLD LINE) BUFFER?
	BEQ 1$		;NO
	CLR LSOLNN	;YES, NO CHARS IN BUFFER
	MOV #LSOLIN,LSOLNA	;INIT PTRS
	MOV #LSOLIN,LSOLNZ
	BIC #.TERST,LSITTS	;DON'T WANT TO DO THIS AGAIN
	BR 3$
1$:	CMP LSOLNN,#LSLINL	;OLD LINE BUFFER FULL?
	BEQ LSBTO1		;OH WELL, NOTHING CAN BE DONE ABOUT THAT
3$:	MOVB B,@LSOLNZ	;PUT CHAR IN BUFFER
	INC LSOLNZ	;ADVANCE PTR
	CMP LSOLNZ,#LSOLIN+LSLINL	;WRAP?
	BLO 2$
	MOV #LSOLIN,LSOLNZ
2$:	INC LSOLNN	;INC COUNTER
	BR LSBTO1


;LSBLKO IS TO $BLKO AS LSBYTO IS TO $BYTO
LSBLKO:	JSR PC,LSRSET	;RESET TTY BUFFER IF BREAK OCCURRED
	SAVE <D,E>
	MOV LSEMTP,A	;GET PTR TO IMMEDIATELY POST-TRAP TOP OF STACK
	MOV 10(A),E	;GET PTR TO BYTES TO XFER
	MOV 6(A),D	;GET NEG # OF BYTES TO XFER
	NEG D		;MAKE # POSITIVE
	BEQ 1$
	BPL 2$		;(WE HOPE)
	BPT		;ONLY $BLKO, NOT .BLKO, SO MISTAKE CRAPS OUT HERE
2$:	MOVB (E)+,B	;GET NEXT BYTE
	BIT #.TIMGO,LSITTS	;IMAGE OUT MODE?
	BEQ 4$		;NO, PROCEED
	JSR PC,LSITYO	;YES, JUST TYPE IT
	BR 5$
4$:	JSR PC,LSBOD	;AND BYTO IT
5$:	TST LSIBRK	;IF BREAK, FLUSH THE REST
	BNE 3$
	SOB D,2$	;IF NOT, GO BACK FOR MORE, IF ANY
1$:	REST <E,D>
3$:	JMP LSSTF3	;FLUSH THE 3 BLKO ARGS & RETURN	

LSBODS:	LSBON.,LSBO.A,LSBON.,LSBON.,LSBON.,LSBON.,LSBON.,LSBOFL
	LSBOBE,LSBOTB,LSBOLF,LSBON.,LSBOFF,LSBOCR,LSBON.,LSBON.
	LSBON.,LSBON.,LSBON.,LSBON.,LSBON.,LSBON.,LSBON.,LSBON.
	LSBON.,LSBOBS,LSBOUP,LSBON.,LSBOHD,LSBOHU,LSBOCL,LSBOCF

LSBOUN:	.BYTE 0,0,0,0,0,0,0,0
	.BYTE 0,1,1,0,1,1,0,0	;CR,LF,FF,TAB
	.BYTE 0,0,0,0,0,0,0,0
	.BYTE 0,0,0,0,0,0,0,0
	.BYTE 1,0,0,0,0,0,0,0	;SPACE
	.BYTE 1,1,1,1,0,1,0,1	;(,),*,+,-,/
	.BYTE 0,0,0,0,0,0,0,0
	.BYTE 0,0,0,0,1,1,1,0	;<,=,>
	.BLKB 30
	.BYTE 0,0,0,0,0,1,1,1	;[,\,]
	.BLKB 40

;THIS ROUTINE REPLACES THE LARGE DISPATCH TABLE
LSBOD:	ASL B
	CMP #100,B
	BLE LSBONO
	JMP @LSBODS(B)

;BYTO DISPATCH ROUTINES ARE CALLED FROM LSBYTO THRU LSBODS,
;AND FROM VARIOUS BYTI DISPATCH ROUTINES, EITHER DIRECTLY OR THRU LSBODS.
;ALL BYTO DISPATCH ROUTINES ARE CALLED WITH CHAR*2 IN B.
;BYTO DISPATCH ROUTINES MAY CLOBBER B, BUT *NOT* A.

			;NORMAL CHAR BYTO DISPATCH ROUTINE
LSBONO:	ASR B		;NORMALIZE CHARACTER
	JSR PC,LSITYO	;AND OUTPUT IT
	INC LSCHNO	;ONE MORE CHARACTER IN LINE
	BR LSEOL


			;TAB ROUTINE
LSBOTB:	ASR B
	JSR PC,LSITYO	;OUTPUT THE TAB
	BIC #7,LSCHNO	;RAISE CHAR COUNT TO NEXT HIGEST MULTIPLE OF EIGHT
	ADD #10,LSCHNO
;FALL THOUGH TO LSEOL

LSEOL:	CMP LSCHNO,LSCHMX	;SEE IF WE'VE COME TO THE END OF THE LINE
	BLT LSEOL2	;IF NOT, ALL DONE
			;THIS PART IS THE ACTUAL BYTO DISPATCH CR ROUTINE
LSBOCR:	MOV #15,B
	JSR PC,LSITYO	;TYPE CR
	MOV #12,B
	JSR PC,LSITYO	;TYPE LF
	CLR LSCHNO	;NO CHARS ON NEW TYPED LINE
	TST LSTVEE	;DO WE NEED TO WORRY ABOUT PAGE BOTTOM, CLR EOL'S?
	BEQ LSEOL2	;NO, DONE
	INC LSLNNO	;ONE MORE LINE ON PAGE
	CMP LSLNNO,LSLNMX	;END OF PAGE?
	BLT LSEOL1	;NO, DONE
	MOV #35,B	;HOME UP
	JSR PC,LSITYO
LSEOL1:	MOV #36,B	;CLEAR EOL
	JSR PC,LSITYO
	CLR LSLNNO	;NO MORE LINES
LSEOL2:	RTS PC


			;UNSPECIAL CONTROL CHARS ROUTINE
LSBON.:	MOV B,C		;SAVE B,
	MOV #'^,B	;TYPE UPARROW,
	JSR PC,LSITYO
	INC LSCHNO	;1 MORE CHAR ON THIS TYPED LINE
	JSR PC,LSEOL	;SEE ABOUT EOL, EOP
	MOV C,B
	ASR B
	BIS #100,B	;DECONTROLIFY CHAR,
	JSR PC,LSITYO	;AND TYPE IT
	INC LSCHNO	;1 MORE CHAR
	BR LSEOL	;SEE ABOUT EOL, EOP AGAIN


			;CTRL A ROUTINE
LSBO.A:	MOV #12,B	;CTRLA A PRINTS AS CR
	JSR PC,LSITYO
	CLR LSCHNO	;NO MORE CHARS ON TYPED LINE
	RTS PC

			;LINEFEED ROUTINE
LSBOHU:
LSBOLF:	CMP LSLNNO,LSLNMX	;ARE WE ON THE LAST LINE?
	BEQ 1$		;IF SO, NOOP
	ASR B		;NORMALIZE THE LF
	JSR PC,LSITYO	;TYPE THE LF
	INC LSLNNO	;1 MORE LINE
1$:	RTS PC


			;CURSOR-UP ROUTINE
LSBOUP:	TST LSLNNO	;ALREADY AT THE TOP?
	BEQ 1$		;IF SO, NOOP
	ASR B		;NORMALIZE THE CHAR
	JSR PC,LSITYO	;TYPE IT
	DEC LSLNNO	;1 LESS LINE
1$:	RTS PC


			;FORMFEED ROUTINE
LSBOFF:	ASR B		;NORMALIZE FF
	JSR PC,LSITYO	;TYPE IT
	CLR LSCHNO	;NO MORE CHARS ON LINE
	CLR LSLNNO	;NO MORE LINES ON PAGE
	RTS PC
;THESE SPECIAL-CHARACTER ROUTINES ASSUME CONSOLE WHICH IS, OR BEHAVES LIKE, A DATAPOINT.


			;ROUTINE FOR CTRL CHARS WHICH HAVE NO EFFECT OF
			; CURSOR POSITION, BUT WHICH ARE ONLY SPECIAL TO TV-TYPE CONSOLE

LSBOCF:		;CLEAR EOF
LSBOCL:		;CLEAR EOL
LSBOFL:		;FLASH (BELL)
	TST LSTVEE	;TV-TYPE TERMINAL?
	BEQ LSBOX2
LSBOX1:	ASR B		;IF SO,
	JSR PC,LSITYO	; OUTPUT CHAR
	RTS PC
LSBOX2:	BR LSBON.	;IF NOT, TREAT AS NORMAL CTRL CHAR


			;ROUTINE FOR BACKSPACE
LSBOBS:	TST LSTVEE	;TV-TYPE TERMINAL?
	BEQ LSBON.		;IF NOT, TREAT AS NONSPECIAL CONTROL CHAR
	TST LSCHNO	;IF SO, BACKSPACE
	BEQ LSRTS
	DEC LSCHNO
	BR LSBOX1

			;ROUTINE FOR BACKSPACE/ERASE
LSBOBE:	TST LSTVEE
	BEQ LSBON.
	TST LSCHNO
	BEQ LSRTS
	DEC LSCHNO
	ASR B
	JSR PC,LSITYO	;BACKSPACE
	MOV #36,B	;CLEAR EOL
	JSR PC,LSITYO
LSRTS:	RTS PC
			;ROUTINE FOR HOME-DOWN
LSBOHD:	TST LSTVEE	;TV-TYPE TERMINAL?
	BEQ 1$		;IF NOT, TREAT AS NOSPECIAL CONTROL CHAR
	MOV LSLNMX,LSLNNO	;IF SO, CURSOR WILL MOVE TO BOTTOM LINE,
	CLR LSCHNO	;1ST CHAR POSITION
	RTS PC

1$:	BR LSBON.

LSTIG:	BIC #.TLIPM,LSITTS		;FLUSH LINE MODE
	MOV #LSINBF+LSTBFL,LSINBE	;RESET BUFFER END
	RTS PC

LSTRES:	BIS #.TLIPM,LSITTS
	MOV #LSINBF,LSINA
	MOV #LSINBF,LSINZ
	CLR LSINN
	MOV #LSINBF+LSBUFL,LSINBE
	RTS PC
