	.STITL DISPLAY AND TURTLE
	.PRINT /BEGIN TURTLE FILE
/
	VERN==VERN+%FNAM2

;A  BRIEF DESCRIPTION OF WHAT IS LEFT TO BE DONE TO THIS PROGRAM.


;4)	DECIDING WHAT SNAP AND WIPE REALLY ARE GOING TO DO.
;AT THIS TIME, SNAP OUTPUTS THE ENTIRE SCREEN
;AND WIPE ERASES ONLY TOP LEVEL OCCURRENCES OF THE SNAP


FOR NDISP


;CONVERT ADDRESS TO DISPLAY PUSHJ
;	ARGUMENT IS AC
.MACR	MAKEPJ	F
	SUB	#DISREL,F
	ASR	F
	BIS	#DPUSHJ,F
.ENDM

;CONVERT DISPLAY CONTROLLER ADDRESSES TO REAL WORLD ADDRESSES
;	ARG IS AC
.MACR	MAKEAD	F
	ASL	F
	ADD	#DISREL,F
.ENDM

.ENDC
ENDC NDISP
;DISPLAY AND TURTLE COMMANDS
	.IFZ NDISP
	DLT==0
	DRT==1
	DFD==2
	DBK==3
	DPD==4
	DPU==5
	.ENDC

BACK:	MOV	#"@C,D	;D _ CHAR. TO SEND TO TURTLE
	MOV	#DBK,E	;IN ORDER TO CAUSE 1 STEP OF MOTION
	BR	TURD	;THE TOP BYTE CONTAINS THE CHAR.
LEFT:	MOV	#"BA,D	;IF THE NUMBER OF STEPS IS NEGATIVE
	MOV	#DLT,E
	BR	TURD
RIGHT:	MOV	#"AB,D	;E CONTAINS THE ADDRESS OF THE PARALLEL
	MOV	#DRT,E	;DISPLAY ROUTINE
	BR	TURD
FORWARD:	MOV	#"C@,D
	MOV	#DFD,E
;THE MOVE COMMANDS ARE PROCESSED HERE

TURD:	JSR	PC,G1NARG	;B_SINGLE PRECISION NUMBER
	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;DISPLAY, OR REAL TURTLE?
	BEQ	TURD.1
	JMP	(E)		;DISPLAY
	.ENDC
TURD.1:	BIT	#TURTF,DFLAGS
	BNE	TURD.A	;TURTLE
	ERROR+VTD	;ONLY VALID IF YOU HAVE TURTLE OR DISPLAY
TURD.A:	TST	B
	BGE	TURD.2
	NEG	B	;MAKE NUMBER POSITIVE
	SWAB	D	;AND SWITCH CHARS
;NOW DO THE MOVING
TURD.2:	CMP	E,#DLT	;FOR LEFT OR RIGHT USE FUDGE FACTOR
	BEQ	TURD.0
	CMP	E,#DRT
	BEQ	TURD.0
	BR	TURD.3
TURD.0:	ASL B
	MOV	B,MQ
	MOV	TURF,A
	MOVB	A,MULTIP
	SWAB	A
	MOVB	A,DIVIDE
	ROLB SR+1	;WOULD YOU BELIEVE
	BVS TUTER	;THAT'S HOW YOU CHECK FOR EAE OVERFLOW?
	MOV MQ,B
	ASR B
	BCC .+4
	INC B
TURD.3:	MOV TURDN,E	;TURTLE DEVICE NUMBER (FOR TYO ROUTINES)
	SUB	#6.,B
	BLT	TURD.5	;NEVER EVEN MAKE IT TO FULL ACCELERATE MODE
	MOV	#10,A
	MOV	B,MQ	;GET REM & QUOT OF ARGUMENT-14 / 8
	MOV	#4,DIVIDE	;8
	MOV	AC,F	;REM.=NUMBER OF STEPS NEEDED BESIDES ACCELERATION
;			AND DECELERATION WHICH CAN'T BE TAKEN IN 8'S
	INC	F	;F_TOTAL NUMBER OF 1 STEPS
	JSR	PC,TUROUT
	ADD	A,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TBTYO
	MOV	MQ,F	;F_NUMBER OF 8 STEPS
	ADD	A,D	;D_CHAR FOR 8 STEPS
	JSR	PC,TUROUT
	SUB	A,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TBTYO
	SUB	A,D	;D_CHAR FOR 1 STEP
	JSR	PC,TBTYO
TURD.4:	JMP	NORT

;FOR FEWER THAN 14 STEPS, JUST SEND OUT 1 STEPS
;(IN THE WORS CASE, THIS STUPID ALGORITHM REQUIRES TWICE AS
;MANY CHARS AS THE OPTIMAL ALGORITHM)
TURD.5:	ADD	#6.,B	;RESTORE WHAT WAS SUBTRACTED
	MOV	B,F
	JSR	PC,TUROUT
	BR	TURB.2
TUTER:	ERROR+TGDZ	;TURTLE GETTING DIZZY

;MORE TURTLE COMMANDS

LAMPON:	MOV	#'!,D
	BR	TURB
LAMPOFF:	MOV	#'",D

TURB:	JSR	PC,TURTST
TURB.1:	MOV	TURDN,E
	JSR	PC,TBTYO
TURB.2:	JMP	NORT


PENDOWN:	MOV	#'0,D
	MOV	#DPD,E
	BR	TURC
PENUP:	MOV	#'8,D
	MOV	#DPU,E

TURC:	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;TURTLE, OR DISPLAY?
	BEQ	TURC.1
	JMP	(E)
	.ENDC
TURC.1:	BIT	#TURTF,DFLAGS
	BNE	TURB.1
	ERROR+VTD	;ONLY VALID IF YOU HAVE A TURTLE OR A DISPLAY

TURTS1:	MOV	TURDN,E
TURTST:	BIT	#TURTF,DFLAGS
	BEQ	.+4
	RTS	PC
	ERROR+VTU


TOOT:	JSR	PC,G1NARG
	JSR	PC,TURTS1
	MOV	#"( ,D	;TOOT CHAR IN BOTTOM, NULL IN TOP
	MOV B,A
TOOT.1:	DEC	A	;HOW MANY TIMES TO TOOT
	BLT	TURB.2
	JSR	PC,TBTYO	;SHIP OUT TOOT CHAR
	MOV	#3,F	;THEN FOLLOW IT WITH 3 NULLS
	SWAB	D
	JSR	PC,TUROUT
	SWAB	D	;RETURN TOOT CHAR TO BOTTOM
	BR	TOOT.1

;TURTLE OUTPUT
;CALL WITH CHAR IN D, NUMBER OF TIMES IN F
TURO9:	JSR	PC,TBTYO
TUROUT:	MOV USER,B
	TST BRAKE(B)
	BNE TURDOR
	DEC	F
	BGE	TURO9
TURDOR:	RTS	PC


TOUCH:	PUSH	A
	JSR	PC,TURTS1
	MOV	#'#,D
	JSR	PC,TBTW
	POP	A
	BIT	A,D
	BEQ	TOUCH1
	JMP	RTFALS
TOUCH1:	JMP	RTTRUE

FTOUCH:	MOV #20,A
	BR	TOUCH
BTOUCH:	MOV	#4,A
	BR	TOUCH
LTOUCH:	MOV	#10,A
	BR	TOUCH
RTOUCH:	MOV	#40,A
	BR	TOUCH
LFTOUC:	MOV #30,A
	BR TOUCH
RFTOUC:	MOV #60,A
	BR TOUCH
LBTOUC:	MOV #14,A
	BR TOUCH
RBTOUC:	MOV #44,A
	BR TOUCH

;START TURTLE

STURF:	.BYTE 101.,36.,101.,36.	;TURTLE FUDGE FACTORS FOR LEFT AND RIGHT
;	MULTIPLY BY EVEN BYTE AND DIVIDE BY ODD BYTE


STARTTURTLE:
	JSR	PC,G1NARG	;WHICH TURTLE
	TST	B
	BGE	STRTT1
	ERROR+ITN	;INVALID TURTLE NUMBER
STRTT1:	DEC	B
	CMP	B,#1
	BLE	STRTT2
	ERROR+ITN
STRTT2:	ASL	B	;TURN INTO WORD INDEX
	.IFNZ NDISP
	PUSH	B
	JSR	PC,KILLD1
	POP	B
	.ENDC
	JSR	PC,KILLT1	;KILL TURTLE IF HE ALREADY HAS ONE
	TST	TURUSE(B)	;IS THE TURTLE HE WANTS FREE?
	BLT	STRTT3	;YES
	ERROR+TNA	;TURTLE NOT AVAILABLE
STRTT3:	MOV	USER,TURUSE(B)	;CLAIM THIS TURTLE
	MOV	TUDN(B),TURDN	;TURTLE DEVICE NUMBER FOR TYO ROUTINES
	MOV	STURF(B),TURF	;TURTLE FUDGE FACTOR
	BIC	#DISPF,DFLAGS
	BIS	#TURTF,DFLAGS
	JMP	NORT

KILLTURTLE:
	SPUSH	#NORT
KILLT1:	CMP	USER,TURUSE	;DOES HE HAVE A TURTLE
	BNE	KILLT2	;NOT TURTLE 1
	COM	TURUSE	;MAKE IT NEGATIVE TO INDICATE IT'S FREE
	BR	KILLT3
KILLT2:	CMP	USER,TURUSE+2
	BNE	KILLT9	;DOESN'T HAVE A TURTLE
	COM	TURUSE+2
KILLT3:	BIC	#TURTF,DFLAGS
KILLT9:	RTS	PC

NODEV:	JSR	PC,KILLT1	;RELEASE ALL DEVICES FOR THIS USER
	.IFNZ NDISP
	JSR	PC,KILLD1
	.ENDC
	JSR	PC,NOMU1
	JSR	E,LCUGRB
	PGRAB
	RTS	PC
;HERE IS WHERE THE DISPLAY PRIMITIVES START.
	FOR NDISP

;STARTDISPLAY
;	INITIALIZE EVERYTHING
;	ALLOCATE DISPLAY BUFFERS
STARTDISPLAY:	PUSH #NORT
STRTD0:	JSR	PC,KILLT1	;GET RID OF TURTLE IF NECSSARY
	BIT	#DISPF,DFLAGS	;DOES HE HAVE A DISPLAY?
	BEQ	STRTD1	;USER DOESN'T HAVE A DISPLAY YET
	JSR	PC,KILLD2	;KILL HIS PREVIOUS DISPLAY FIRST

STRTD1:	MOV	USER,MQ	;FIND USER'S DISPLAY CONSOLE NUMBER
	MOV	#L,DIVIDE	;LENGTH OF USER BLOCK
	MOV	MQ,A	;USER NUMBER
	MOVB	DCONS(A),A
	BGE	.+4
	ERROR+NDU	;NOT A DISPLAY USER

	MOV	#DORBEG,C	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,B	;LAST WORD
SDLOOP:	CLR	(C)+	;ZERO WORD
	CMP	C,B
	BLE	SDLOOP

	ASL	A	;MAKE INTO WORD INDEX
	MOV	A,DISNUM
	MOV	STLIST(A),C	;THIS USERS TURTLE DISPLAY AREA
	MOV	C,TUB	;TURTLE BOTTOM
	MAKEPJ	C
	MOV	C,PUSHJT	;PUSHJ TO TURTLE

	MOV	SDWD1(A),DISREL(A)	;FIRST WORD FOR DISPLAY
	MOV	DISREL(A),D	;PUSHJ TO START OF DLIST
	MAKEAD	D
;LATER ADD IN A POP
	MOV	#DRSTXY!DPOP,(D)+	;FIRST WORD OF DLIST
	MOV	C,(D)	;PUSHJT IN 2ND WORD

;SET UP BUFFER VARIABLES
	MOV	D,STB	;STATIC AREA BOTTOM
	MOV	D,STT	;STATIC AREA TOP
	TST	-(D)	;POINT D BACK TO FIRST WORD
	ADD	#DLEN,D
	CLR	-(D)	;SET UP DUMMY FREE AREA
	MOV	D,DYT	;(DYNAMIC AREA TOP)
	CLR	-(D)	;AT THE TOP OF DYNAMIC AREA
	MOV	D,DYB	;DYNAMIC AREA BOTTOM
	MOV	D,DYR	;DYNAMIC AREA ROVING POINTER

	MOV	SDPDLP(A),DPDLP(A)	;SET DISPLAY PDL POINTER

	JSR	PC,ANGCRP	;GET DIREC, SINA, COSA
	JSR	PC,DR.TUR	;DRAW THE TURTLE
	JSR	PC,NEWSN2	;SET UP FOR NEW SNAP
	MOV	#DISREL,NGREL	;SET THE RELOCATION, JUST IN CASE
	MOV	DISNUM,A
	MOV	A,B
	ASR	B
	SWAB	B	;CORRECT POSITION TO MUNG NGCSR
	MOV	B,DSTAT(A)
	BIS	#DISPF,DFLAGS
	RTS PC

;KILLDISPLAY
;	USER WANTS TO GIVE UP HIS DISPLAY
KILLDISPLAY:
	MOV	#NORT,-(SP)	;ENTER HERE FROM EVAL
KILLD1:	BIT	#DISPF,DFLAGS
	BEQ	KILLDR	;USER DOESN'T HAVE DISPLAY
KILLD2:	MOV	DISNUM,A
	MOV DSTAT(A),B
	MOV B,NGCSR
	MOV	#-1,DSTAT(A)
	MOV	#DSTOP,DISREL(A)
	BIS #TKSTOP,B
	MOV B,NGCSR
;	JSR	PC,SNZAP	;SET ALL SNAPS TO EMPTY-WORD
	CLR	SNLIST	;CLEAR  SNAPS
	BIC	#DISPF,DFLAGS
	JSR	PC,.GCOLL

KILLDR:	RTS	PC

DCHK:	BIT	#DISPF,DFLAGS
	BNE	DCHK1
	BR STRTD0
DCHK1:	CMP	NADXY,#20
	BLT	KILLDR	;DON'T BOTHER TRYING TO COMPRESS ADDXY'S
	JSR	PC,DSGC8	;TRY TO COLLAPSE
	BR	KILLDR

DBK:	NEG	B
;DISPLAY FORWARD AND BACK
DFD:	MOV	B,C
	CLR	B
	TST	C
	BGE	DFD1	;IF ARG IS NEG,
	COM	B	;SET B = -1
	CLR	A	;CLEAR FLAG
DFD1:	MOV	#CURX,D
	JSR	PC,MULSIN	;PUTS DX IN E,,F
	SDPADD	(D)+,(D)+,E,F	;NEW X
	SPUSH	F	;FRACTION PART
	SPUSH	E	;INTEGER PART
	JSR	PC,MULCOS	;DY IS IN E,,F
	SDPADD	(D),(D)+,E,F	;NEW Y
	SPUSH	F
	SPUSH	E
	BR	SETMOV

SETX:	JSR	PC,DCHK
	JSR	PC,G1NARG	;;NEW X IN B
	CLR	-(SP)	;FRACTION PART OF NEW X
	SPUSH	B	;INTEGER PART
	SPUSH	CURY	;NEW Y UNCHANGED
	SPUSH	CURY+2
	BR	SETMOV

SETY:	JSR	PC,DCHK
	JSR	PC,G1NARG
	SPUSH	CURX	;NEW X UNCHANGED
	SPUSH	CURX+2
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	B	;INTEGER PART OF NEW Y
	BR	SETMOV

SETXY:	JSR	PC,DCHK
	JSR	PC,G2NARG
	CLR	-(SP)	;FRATION PART OF NEW X
	SPUSH	B	;INTEGER PART
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	A	;INTEGER PART
SETMOV:	JSR	PC,MOVETO
	JMP	NORT

SETTURTLE:
	SPUSH	#NORT
	JSR	PC,DCHK
	MOV	@S,C
	JSR	PC,LD3NUM	;LOAD D,E,F
SETT1:	SPUSH	F	;SAVE NEW ANGLE
	JSR	PC,SPOPT	;POP OFF ARG
	CLR	-(SP)	;FRACTION PART OF NEW X
	SPUSH	D	;INTEGER
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	E
	CLR	A	;A FLAG
	JSR	PC,MOVETO	;MOVE TO NEWX,NEWY
	SPOP	B	;NEW HEADING
	JMP	DRT.HD	;SET HEADING

;CALL WITH NEWX AND NEWY ON THE STACK


MOVETO:	MOV	SP,F
	TST	(F)+	;POINT TO ARGS
	MOV	(F),B	;INTEGER PART OF NEW Y
	JSR	PC,CHKBND	;CHECK TO SEE IF IN BOUNDS
	MOV	4(F),B	;INTEGER PART OF NEW X
	JSR	PC,CHKBND
;GET D_DX AND E_DY
	MOV	(F)+,E	;INTEGER OF NEWY
	MOV	(F)+,B	;FRACTION
	MOV	(F)+,D	;INTEGER OF NEWX
	MOV	(F),C	;FRACTION
	MOV	#CURX,F
	ROL	B
	ADC	E	;ROUND DY
	ROL	C
	ADC	D	;ROUND DX
	ROL	(F)+	;FRACTION OF CURX
	ADC	(F)	;ROUND CURX
	SUB	(F)+,D	;DX
	ROL	(F)+
	ADC	(F)
	SUB	(F),E	;DY
	BNE	MTO.1	;CHECK FOR DX=DY=0
	TST	D
	BEQ	MTO.R	;JUST RETURN

MTO.1:	BIT	#PENUF,DFLAGS	;IS PEN UP?
	BNE	MTO.PU	;YES

;THE PEN IS DOWN
	SPUSH	DIREC
	JSR	PC,XYDIR	;CALCULATE DIREC
	JSR	PC,DR.LIN	;AND DRAW LINE!!
	SPOP	DIREC

;RETURN.  SET CURX & CURY TO NEWX & NEWY
MTO.R:	SPOP	A	;RETURN ADDRESS
	MOV	#CURY+2,B
	SPOP	(B)
	SPOP	-(B)
	SPOP	-(B)
	SPOP	-(B)
	JMP	(A)


;THE PEN IS UP
;PUT ADDX AND ADDY COMMANDS INTO DISPLAY LIST
MTO.PU:	SPUSH	#MTO.R	;SO RTS PC'S BELOW WILL WORK (GROAN !!!)
	MOV	STT,A
	CMP	-(A),#ADDY
	BLO	MTO.AD	;PREVIOUS STUFF NOT ADDS ANYWAY
	CMP	-(A),#ADDY	;IS THE NEXT TO LAST DCODE AN ADD,TOO ?
	BLO	MTO.AD	;NO
	CMP	A,SNABOT	;DON'T COMPRESS ACROSS SNAP BOTTOM
	BLO	MTO.AD	;NO
;THERE ARE TWO ADD COMMANDS IN A ROW
	JSR	PC,MTO.AS	;TAKE CARE OF FIRST ADD
	JSR	PC,MTO.AS	;AND SECOND ADD
	BR	MTO.R1


;MTO.AS ADDS THE DELTA X OF AN ADD COMMAND TO THE NEW DX OR DY
MTO.AS:	CMP	(A),#ADDX	;ADDX IS THE BIGGER OF THE ADDS
	BHIS	.+6
	ADD	(A)+,E	;DY
	RTS	PC
	ADD	(A)+,D
	RTS	PC


;HAVE TO EXPAND STATIC AREA AND PUT IN ADD COMMANDS
MTO.AD:	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

MTO.RM:	MOV	A,STT	;A WAS SET IN STXPND
	MOV	PUSHJT,(A)	;DISPLAY JUMP TO TURTLE
MTO.R1:	BIC	#176000,D	;IN CASE EITHER DX OR DY WERE NEGATIVE
	BIC	#176000,E	;CLEAR THE TOP 6 BITS
	BIS	#ADDY,E	;TURN E INTO ADDY COMMAND
	MOV	E,-(A)	;STORE IN DLIST
	BIS	#ADDX,D	;TURN D INTO ADDX COMMAND
	MOV	D,-(A)	;STORE IN DLIST
	CLR DFBCNT
	RTS	PC

DLT:	NEG	B

;DISPLAY RIGHT AND LEFT

DRT:	SPUSH	#NORT
	ADD	CURA,B
DRT.HD:	JSR	PC,MOD360	;SET B=B MOD 360
	MOV	B,CURA

;DRAW THE TURTLE IF IT'S BEING SHOWN
TURDO:	JSR	PC,ANGCRP	;DO ALL THE ANGLE CRAP.

	BIT	#HIDETF,DFLAGS	;IS THE TURTLE BEING HIDDEN ?
	BNE	DRTRET	;YES. SO RETURN
;THE TURTLE IS BEING SHOWN. SO DRAW THE TURTLE
	JSR	PC,DR.TUR

DRTRET:	RTS	PC


;SETHEAD
;	LIKE RIGHT, EXCEPT SET CURA TO ARGUMENT
SETHEAD:	JSR	PC,DCHK
	SPUSH	#NORT
	JSR	PC,G1NARG	;NUMERIC ARGUMENT IN B
	BR	DRT.HD	;JUMP INTO RIGHT

;WRAPAROUND

WRAP:	BIS	#WRAPF,DFLAGS
	JMP	NORT

NOWRAP:	BIC	#WRAPF,DFLAGS
	JMP	NORT


;HERE
;	OUTPUT A SENTENCE OF CURX,CURY,CURA
HERE:	JSR	PC,DCHK
	MOV	#CURX,D
	JSR	PC,PSHINT	;PUSH INTEGER OF CURX ONTO S-PDL
	JSR	PC,PSHINT	;PUSH INTEGER OF CURY
	MOV	(D),B	;CURRENT ANGLE
HERE.1:	JSR	PC,PSHNUM	;PUSH CURRENT ANGLE
HERE.2:	SPUSH	#3	;PUSH 3 ONTO P-PDL
	JSR PC,SENTENCE
	.BUG.
	SKPRET


;XCOR
;	OUTPUT THE X COORDINATE
XCOR:	JSR	PC,DCHK
	MOV	#CURX,D
	BR	YCOR1
;YCOR
;	OUTPUT THE Y COORDINATE
YCOR:	JSR	PC,DCHK
	MOV	#CURY,D
YCOR1:	JMP	R1INT	;RETURN INTEGER


;HEADING
;	RETURN THE CURRENT ANGLE
HEADING:	JSR	PC,DCHK
	MOV	CURA,B
	JMP	R1NARG
	;HOME -- SAME AS SETT [0 0 0]
HOME:	SPUSH #NORT
	JSR PC,DCHK
	JSR PC,SPUSHT
	CLR D
	CLR E
	CLR F
	JMP SETT1


;	HIDETURTLE
HIDETURTLE:
	JSR	PC,DCHK
	BIS	#HIDETF,DFLAGS	;SET THE HIDETURTLE FLAG
	MOV	#DPOP!DSTOP,@TUB
	JMP	NORT


;	SHOWTURTLE
SHOWTURTLE:
	JSR	PC,DCHK
	BIT	#HIDETF,DFLAGS	;IS TURTLE HIDDEN NOW ?
	BEQ	SHOWT9	;NO, IT'S ALREADY BEING SHOWN
;HAVE TO DRAW THE TURTLE
	BIC	#HIDETF,DFLAGS	;CLEAR THE FLAG FIRST
	JSR	PC,DR.TUR
SHOWT9:	JMP	NORT


;	DISPLAY PENUP
DPU:	BIS	#PENUF,DFLAGS
	JMP	NORT


;	DISPLAY PENDOWN
DPD:	BIC	#PENUF,DFLAGS
	JMP	NORT

;CLEARSCREEN--WIPE SCREEN AND RESTORE TURTLE TO [0 0 0]
CLEARSCREEN:	JSR	PC,DCHK
	JSR	PC,WC.1
	MOV	DFLAGS,-(SP)	;SO THIS LOSER WONT GET ZEROED BELOW (HO HUM)
	MOV	#DORBEG,C	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,B
CSLOOP:	CLR	(C)+
	CMP	C,B
	BLT	CSLOOP

	MOV	(SP)+,DFLAGS	;RESTORE
	CLR DFBCNT
	JSR	PC,TURDO	;DO ANGLE CRAP AND DRAW TURTLE IF SHOWN
	MOV	STB,STT
	MOV	PUSHJT,@STB
	JSR	PC,NEWSN2

	JMP	NORT


;SNAP

SNAP:	JSR	PC,DCHK

;FIRST SET UP THE 3 NODE SNAP STRUCTURE ITSELF
	JSR	PC,PSHNUM	;FIRST NUMBER IS DUMMY FOR NOW
	MOV	#CURX,D
	JSR	PC,GETINT	;INTEGER OF CURX IN B
	SUB	OLDX,B	;TO GET DELTA X
	JSR	PC,PSHNUM	;PUSH ON S-PDL
	JSR	PC,GETINT	;INTEGER OF CURY
	SUB	OLDY,B	;TO GET DELTA-Y
	JSR	PC,PSHNUM
	MOV	#3,D	;NUMBER OF ARGS TO SENTENCE
	JSR	PC,SENT.

;NOW GRAB A NODE FOR THE SNLIST HACKING
	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BNE	SNAP.2
	MOV	#SNUM,A	;FIRST SNAP
	CLR	B	;CREATE SNAP LIST. FIRST NODE IS A DUMMY
	JSR	PC,GRBAD
	BIS	#LIST,C
	MOV	C,SNLIST
SNAP.2:	JSR	PC,.LDP1	;POINTER TO REST OF SNAP LIST
	JSR	PC,GRBAD	;STORE A NODE
	BIS	#LIST,C
	MOV	C,GCP1	;GARBAGE COLLECT PROTECT

;NOW TRANSFER THE DISPLAY CODE (YEAH)
	MOV	SNABOT,D	;BOTTOM OF STUFF TO BE SNAPPED
	JSR	PC,DYXFR	;TRANSFER THE DCODE. SKIP IF SUCCEEDS
	BR	SNAP.4	;COULDN'T FIND ENOUGH FREE MEMORY
SNAP.0:	TST	D	;IF 0
	BEQ	SNAP.3	;NO CODE MOVED

;CHECK THAT THIS SNAP WON'T CAUSE DISPLAY PDL OVERFLOW
	TST	-(D)	;POINTER TO SNAP
	CMP	-(D),#<DPDLL/2>	;DEPTH COUNTER
	BLE	SNAP.1
	CLR	GCP1
	ERROR+STD	;SNAP TOO DEEP

;NOW GO BACK AND PUT THE SNAP ADDRESS IN RIGHT PLACES
SNAP.1:	TST	(D)+	;POINT D TO REF COUNTER
	INC	(D)+	;INC COUNTER THAT SAYS HOW MANY TIMES DISPLAYED
	MOV	GCP1,C	;NOW HACK SNLIST
	MOV	D,A
	JSR	PC,.STP2	;STORE ADDRESS IN 2ND WORD OF NODE
	MOV	C,A	;POINTER TO NODE
	BIC	#170000,A
	BIS	#SNUM,A
	MOV	SNLIST,C
	JSR	PC,.STP1	;STORE NEW NODE POINTER INTO FIRST NODE OF SNLIST

	CLR	GCP1


	MOV	@S,C	;NOW HACK THE SNAP STRUCTURE
	BIC	#170000,C
	BIS	#SNP,C
	MOV	C,@S	;PUT IN RIGHT DATA TYPE
;PUT ADDRESS OF SNAP INTO FIRST OF STRUCTURE
	JSR	PC,.LDP2	;A_POINTER TO FIRST OF STRUCTURE
	MOV	A,C
	CLR	A
	MOV	D,B
	BGE	SNAP.6	;SIGN EXTEND ADDRESS
	COM	A
SNAP.6:	JSR	PC,.STORE	;STORE ADDRESS OF SNAP AS FIRST OF STRUCTURE

;NOW COLLAPSE STATIC AREA AND DISPLAY THE SNAP
	MOV	#SNABOT,A	;MAKE SURE THERE IS ROOM FOR DISPLAY HERE
	JSR	PC,STXPND
	MOV	A,STT
	MAKEPJ	D
	MOV	PUSHJT,(A)
	MOV	D,-(A)
	CLR	-(A)
	CLR DFBCNT
	JMP	ORT


;SINCE NO DISPLAY CODE WAS MOVED, RETURN EMPTY SNAP
SNAP.3:	MOV	#SNP,@S
	CLR	GCP1
	JMP	ORT

SNAP.4:	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	SNABOT,D
	JSR	PC,DYXFR	;TRY TO TRANSFER D.CODE AGAIN
	BR	SNAP.5	;COULDN'T, SO ERROR
	BR	SNAP.0	;SUCCESS!
SNAP.5:	CLR	GCP1
	ERROR+TML


;NEWSNAP
;SET UP FOR NEXT SNAP TO START HERE
NEWSNAP:	JSR	PC,DCHK
	MOV	#NORT,-(SP)	;ENTER HERE FROM LOGO
NEWSN1:	MOV	#CURX,D	;ENTER HERE AS SUBROUTINE
	JSR	PC,GETINT	;GET INTEGER OF CURX IN B
	MOV	B,OLDX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,OLDY
NEWSN2:	MOV	STT,SNABOT	;RESET SNAP BOTTOM TO TOP OF DISPLAY
	CLR DFBCNT
	RTS	PC	;EITHER RETURN FROM SUBROUTINE , OR JMP NORT

;DISPLAY A SINGLE SNAP

DISPLAY:	JSR	PC,DCHK

	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP,CURX,CURY
	BR	D.RET	;RETURNS HERE IF ARG IS EMPTY
	MOV	E,B
	ADD	CURX+2,B
	JSR	PC,CHKBND	;IS NEW X COR IN BOUNDS?
	MOV	F,B
	ADD	CURY+2,B
	JSR	PC,CHKBND	;IS NEW Y COR IN BOUNDS?

;NOW SEE IF THERE'S ENOUGH ROOM IN THE DISPLAY AREA
	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

;FINALLY, WE CAN PLACE THE PUSHJ TO THE SNAP INTO THE DISPLAY LIST
DISRM:	INC	-2(D)	;INCREMENT THE REF COUNTER OF THE SNAP
	MOV	A,STT	;SET STATIC TOP TO HERE IN DLIST
	MOV	PUSHJT,(A)	;PUT PUSHJ TO TURTLE AT TOP OF DLIST
	MAKEPJ D
	MOV	D,-(A)	;PUT IN THE PUSHJ
	CLR	-(A)	;PRECEDE BY A NOP

;NOW, SET CURX AND CURY
	ADD	E,CURX+2	;E HAD DX OF THE SNAP
	ADD	F,CURY+2	;F HAS DY OF THE SNAP

	CLR DFBCNT
D.RET:	JSR	PC,SPOPT	;POP S
	JMP	NORT	;RETURN

;WIPE A SNAP

WIPE:	JSR	PC,DCHK
	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP, X,  Y

	BR	D.RET	;RETURNS HERE IF ARG IS EMPTY
	BIC	#176000,E	;CLEAR TOP 6 BITS
	BIS	#ADDX,E	;AND TURN INTO ADDX COMMAND
	BIC	#176000,F	;CLEAR TOP 6 BITS
	BIS	#ADDY,F	;TURN INTO ADDY

	MOV	D,B
	TST	-(D)	;POINT D TO SNAP'S REF COUNTER
	MAKEPJ B	;MAKE B INTO DPUSHJ TO SNAP
	MOV	STT,A	;POINTER TO TOP OF DISPLAY LIST
	MOV	STB,C	;POINTER TO BOTTOM OF DLIST

WIPE.L:	CMP	A,C	;ARE WE AT THE BOTTOM YET?
	BLO	D.RET	;YES, SO WE ARE DONE
	CMP	B,-(A)	;IS THE NEXT WORD A PUSHJ?
	BNE	WIPE.L	;NO.  LOOP BACK AND TRY ANOTHER
;YES!  IT IS A PUSHJ
;PUT ADDX AND ADDY COMMANDS INTO DLIST
	INC	NADXY	;NADXY IS ACOUNTER TO TELL WHEN TO COMPRESS
	MOV	F,(A)
	MOV	E,-(A)

	DEC	(D)	;DECREMENT REF COUNTER
	BR	WIPE.L	;AND THEN LOOP BACK TO SEE IF THERE'S ANOTHER
;			PUSHJ TO THIS SNAP


;WIPE THE ENTIRE DISPLAY

WIPECLEAN:
	SPUSH	#NORT
WC.1:	MOV	STB,A	;POINTER TO BOTTOM OF DISPLAY LIST
	MOV	STT,B	;POINTER TO TOP OF DLIST
	MOV	#100000,E	;SMALLEST DPUSHJ
	MOV	#140000,F	;SMALLEST COMMAND BIGGER THAN PUSHJ

WC.LP:	CMP	B,A	;ARE WE AT BOTTOM YET?
	BLOS	WC.DUN	;YES, WE ARE DONE
	CMP	-(B),E	;IS NEXT WORD DOWN A PUSHJ?
	BLO	WC.LP	;NO, IT'S TOO SMALL
	CMP	(B),F
	BHIS	WC.LP	;NO, IT'S TOO BIG
;THIS WORD IS A PUSHJ
	MOV	(B),D	;MOVE	THE PUSHJ COMMAND INTO D
	MAKEAD D	;TURN INTO PDP-11 ADDRESS
	DEC	-(D)	;DECREMENT SNAP'S REF COUNTER
	BR	WC.LP	;LOOP BACK TO LOOK FOR MORE PUSHJ'S

;NOW PLACE ADDX AND ADDY COMMANDS IN THE DISPLAY LIST
;SO THAT THE TURTLE WILL STAY AT THE SAME PLACE IT WAS BEFORE THE WIPE
WC.DUN:	MOV	#CURX,D
	JSR	PC,GETINT	;GET INTEGER OF  CURX IN B
	SPUSH	B	;SAVE DX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,E	;PUT DY IN E
	SPOP	D	;PUT DX IN B
	MOV	STB,STT
	JSR	PC,MTO.AD	;PUTS THE ADD COMMANDS INTO THE DLIST
	JSR	PC,NEWSN1	;SO THAT SNAPS WILL START HERE

	RTS	PC
.STITL DISPLAY UTILITY ROUTINES

;CHKBND
;	CHECK BOUNDS.  ERROR IF B IS OFF SCREEN
CHKBND:	BIT	#WRAPF,DFLAGS
	BEQ	CHKBN1
	RTS	PC
CHKBN1:	CMP	B,#200.
	BGT	ERROOB
	CMP	B,#-200.
	BLT	ERROOB
	RTS	PC
;THE NUMBER IS OUT OF BOUNDS
ERROOB:	ERROR+OOB


	.ENDC
	ENDC NDISP
;	CALL WITH D POINTING TO CURX OR CURY.
;	RETURN THE INTEGER OF CURX OR CURY IN B
GETINT:	MOV	(D)+,B	;THE FRACTION PART
	ROL	B
	MOV	(D)+,B	;THE INTEGER PART
	ADC	B	;ROUND
	RTS	PC
	FOR NDISP

;STATIC AREA EXPAND.
;	IS THERE ROOM IN STATIC AREA FOR 2 DISPLAY WORDS?
;	RETURN POINTER TO NEW STATIC TOP IN A
STXPND:	PUSH	A
	MOV	@A,A	;ROUTINE IS CALLED WITH ADDRESS OF VARIABLE
	CMP	(A)+,(A)+	;A _ A+4
	CMP	A,DYB
	BLO	STXPN8	;THERE'S ROOM!
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	@(SP)+,A	;AND TRY AGAIN
	CMP	(A)+,(A)+
	CMP	A,DYB
	BLO	STXPN9
	ERROR+TML	;TOO MANY LINES
STXPN8:	TST	(SP)+	;POP OFF A
STXPN9:	RTS	PC


;MOD360
;	OUTPUT B MOD 360 IN B.
;	ALWAYS OUTPUTS A POSITIVE NUMBER
MOD360:	MOV	#MQ,A
	MOV	B,(A)	;MQ_NUMBER
	MOV	#360.,DIVIDE
	MOV	-(A),B	;REMAINDER
	BGE	M360R
	ADD	#360.,B	;IF REMAINDER WAS NEGATIVE, ADD 360 TO IT
M360R:	RTS	PC



;MULCOS
;	RETURN A*COSINE OF CURA IN B,,C
MULCOS:	MOV	COSA,F
	BR	MULCS2
;MULSIN
;	RETURN A*SINE OF CURA IN B,,C
MULSIN:	MOV	SINA,F
MULCS2:	CLR	E
	ASL	F	;TURN INTO BOTTOM HALF OF DP NUMBER
	SBC	E	;MAKE E NEG. IF F WAS
	JSR	PC,.DPMUL
	NOP	1
	RTS	PC


;ANGCRP
;	CALCULATE ANGLE CRAP.
;	CALCULATE DIREC, SINA, COSA
ANGCRP:	MOV	CURA,A	;THE CURRENT ANGLE
	MOV	#90.,E
	MOV	#MQ,F
	MOV	A,(F)	;THE DIVIDEND
	TST	-(F)
	MOV	E,-(F)	;THE DIVISOR = 90.
	TST	(F)+
	MOV	(F)+,C	;THE REMAINDER
	MOV	(F),F	;THE QUOTIENT
	SUB	C,E	;NOW E = 90.- REMAINDER
	MOV	C,A	;A_REMAINDER
	JSR	PC,SINGET	;D_SIN (A)
	MOV	D,B
	MOV	E,A
	JSR	PC,SINGET
	ASL	F	;F = 0,1,2,3
	ADD	F,PC	;JUMP THROUGH THIS DISPATCH TABLE
	BR	ACR.D
	BR	ACRII	;QUADRANT II
	BR	ACRIII	;QUADRANT III
;FOURTH QUADRANT
	MOV	B,A	;SIN (A)
	MOV	D,B	;SIN (90-A)
	NEG	B	;SINA=-SIN(90-A) IN 4TH QUADRANT
	MOV	A,D	;AND COSA=SIN(A) IN 4TH QUADRANT
	BR	ACR.D

;THE THIRD QUADRANT
ACRIII:	NEG	B	;SINA = -SIN (A) IN 3RD QUADRANT
	NEG	D	;COSA = - SIN (90-A) IN 3RD QUADRANT
	BR	ACR.D

;SECOND QUADRANT
ACRII:	MOV	B,A	;SIN (A)
	MOV	D,B	;SINA = SIN (90-A) IN 2ND QUADRANT
	MOV	A,D
	NEG	D	;COSA = -SIN (A) IN 2ND QUADRANT

;IN THE FIRST QUADRANT
;SINA = SIN (A) AND
;COSA = SIN (90-A)
ACR.D:	MOV	B,SINA
	MOV	D,COSA

;FALLS THROUGH
;FALLS IN

;CLACULATE DIREC FROM STUFF LEFT IN F AND C BY ANGCRP
ANGDIR:	CMP	#45.,C
	ADC	F	;CARRY SET IF C<45
	ASL	F
	ASL	F
	ASL	F
	MOV	F,DIREC
	RTS	PC

;GET SIN (A) INTO D.
;THE SINE TABLE HAS ONLY EVEN ANGLES.  INTERPOLATE ODD ANGLES.
SINGET:	BIT	#1,A	;ODD OR EVEN
	BEQ	AEVEN
	ADD	#<SIN+1>,A	;POINT TO ANGLE AFTER IT
	MOV	(A),D	;SIN (A+1)
	ADD	-(A),D	;PLUS SIN (A-1)
	ROR	D	;DIVIDED BY 2
	RTS	PC
AEVEN:	MOV	SIN(A),D
	RTS	PC


;BEAUTIFUL SINE TABLE IN WHOOPIE FORMAT


SIN:

	0	;0 DEGREES
	2167	;2 DEGREES
	4355	;4 DEGREES
	6541	;6 DEGREES
	10720	;8 DEGREES
	13072	;10 DEGREES
	15234	;12 DEGREES
	17367	;14 DEGREES
	21510	;16 DEGREES
	23615	;18 DEGREES
	25707	;20 DEGREES
	27763	;22 DEGREES
	32017	;24 DEGREES
	34034	;26 DEGREES
	36027	;28 DEGREES
	40000	;30 DEGREES
	41724	;32 DEGREES
	43623	;34 DEGREES
	45474	;36 DEGREES
	47315	;38 DEGREES
	51106	;40 DEGREES
	52646	;42 DEGREES
	54352	;44 DEGREES
	56023	;46 DEGREES
	57437	;48 DEGREES
	61015	;50 DEGREES
	62335	;52 DEGREES
	63615	;54 DEGREES
	65035	;56 DEGREES
	66214	;58 DEGREES
	67331	;60 DEGREES
	70404	;62 DEGREES
	71413	;64 DEGREES
	72357	;66 DEGREES
	73255	;68 DEGREES
	74107	;70 DEGREES
	74674	;72 DEGREES
	75412	;74 DEGREES
	76062	;76 DEGREES
	76463	;78 DEGREES
	77016	;80 DEGREES
	77301	;82 DEGREES
	77514	;84 DEGREES
	77660	;86 DEGREES
	77754	;88 DEGREES
	77777	;90 DEGREES

;XYDIR
;	CALL WITH D=DX, E=DY
;	CALCULATE DIREC BASED ON DX AND DY
XYDIR:	CLR	A	;BUILD INDEX IN A
	TST	D	;IS DX POSITIVE
	BGE	XYDIR1
	NEG	D	;ABSOLUTE VALUE OF DX
	TST	(A)+	;PUT 2 INTO A
XYDIR1:	TST	E	;IS DY POSITIVE
	BGE	XYDIR2
	NEG	E	;ABSOLUTE VALUE OF DY
	INC	A	;INCREMENT INDEX
XYDIR2:	CMP	D,E	;WILL GENERATE CARRY IF D<E
	ROL	A	;PUT CARRY INTO BOTTOM BIT OF INDEX.  AND MULTIPLY REST BY 2
	MOVB	DREC(A),DIREC	;NOW MOVE THE RIGHT THING INTO DIREC
	RTS	PC
DREC:	.BYTE 10
	.BYTE 0
	.BYTE 20
	.BYTE 30
	.BYTE 60
	.BYTE 70
	.BYTE 50
	.BYTE 40
	.EVEN


;DYXFR
;	TRANSFER FROM STATIC AREA TO DYNAMIC AREA
;	THE CODE BEING TRANSFERRED STARTS AT D AND GOES UP TO STT
;	ON RETURN, D POINTS TO THE TRANSFERRED DCODE
;	IF NO CODE WAS TRANSFERRED, THEN D = 0.
;	SKIPS IF THERE'S ROOM FOR TRANSFER
DYXFR:	MOV	STT,E
	SUB	D,E	;LENGTH OF DCODE TO BE MOVED
	BEQ	DYRET	;NOTHING TO BE MOVED
;ALLOCATE STORAGE
;LENGTH OF BLOCK TO BE ALLOCATED IS IN E
DYAL:	ADD	#6,E	;INCREASE LENGTH TO ALLOW FOR REF CNTR, DEPTH CNTR, AND POPJ
	MOV	DYR,B	;INITIALIZE POINTER
	MOV	#1,C	;INITIALIZE FLAG
DYAL1:	MOV	2(B),A	;POINTER TO NEXT FREE BLOCK
	BNE	DYAL2
	DEC	C	;NO NEXT FREE BLOCK--TEST AND SET FLAG
	BNE	DYAL7	;NO MORE ROOM--GO TO EXPAND DY AREA
	MOV	DYB,B	;START AGAIN AT BOTTOM OF LIST
	BR	DYAL1
DYAL2:	MOV	(A),F	;FREE BLOCK FOUND--CHECK LENGTH
	SUB	E,F
	BPL	DYAL4
DYAL3:	MOV	A,B	;BLOCK TOO SHORT--MOVE TO NEXT BLOCK
	BR	DYAL1
DYAL4:	BNE	DYAL5	;BLOCK LONG ENOUGH--IF FILLED EXACTLY
	MOV	2(A),2(B)	;REMOVE BLOCK FROM LIST BY CHANGING POINTERS
DYAL5:	CMP	F,#2	;DONT LEAVE A BLOCK OF LENGTH 2 BYTES
	BEQ	DYAL3
	MOV	F,(A)	;NEW LENGTH OF FREE BLOCK
	MOV	2(B),C	;RESET ROVING POINTER
	BNE	DYAL6	;DONT SET IT TO O
	MOV	DYB,C
DYAL6:	MOV	C,DYR	
	ADD	F,A	;START STORING AT THIS ADDRESS
	BR	DYAL9
DYAL7:	MOV	DYB,A	;ADD NEW BLOCK TO BOTTOM OF LIST
	MOV	2(A),F	;POINTER TO 2ND FREE BLOCK
	SUB	E,A
	CMP	A,STT
	BHI	DYAL8	;THERE IS ENOUGH ROOM IN THE DY AREA
	RTS	PC	;NOT ENOUGH ROOM
DYAL8:	MOV	A,DYB	;NEW BOTTOM OF DY
	MOV	A,DYR	;FIX ROVING POINTER
	MOV	DYB,C	;SET UP NEW LIST BOTTOM
	CLR	(A)+
	MOV	F,(A)+
DYAL9:	SUB	#6,E	;RESTORE LENGTH


;NOW A CONTAINS ADDRESS OF FREE BLOCK
;E CONTAINS NUMBER OF BYTES TO BE TRANSFERRED
;NOW FINALLY YOU GET TO DO THE TRANSFER
;WHILE YOU DO IT, INCREMENT THE REF COUNTER OF ANY PUSHJ'S
DYXFR1:	MOV	#100000,C	;THE CODE FOR DISPLAY PUSHJ
	MOV	#140000,B	;NEXT HIGHER DISPLAY COMMAND
	SPUSH	A	;SAVE POINTER TO DEPTH COUNTER
	CLR	(A)+	;DEPTH_0
	CLR	(A)+	;SET REFERENCE COUNTER TO ZERO
	ASR	E	;E/2 = NUMBER OF WORDS TO BE TRANSFERRED
;PICK UP A WORD.  SEE IF ITS A PUSHJ. AND TRANSFER IT
DYXFR2:	DEC	E	;NUMBER OF WORDS TO BE XFRED
	BLT	DYXFR3
	MOV	(D)+,F	;WORD OF DCODE IN F
	MOV	F,(A)+	;PUT THIS WORD IN ITS NEW PLACE
	CMP	F,C
	BLO	DYXFR2	;NOT A PUSHJ
	CMP	F,B
	BHIS	DYXFR2	;NOT A PUSHJ
;IT IS A PUSHJ
	MAKEAD	F
	INC	-(F)	;INCREMENT THE REF COUNTER
	CMP	-(F),@(SP)	;DEPTH _ MAX (DEPTH OF SUB SNAPS)
	BLE	DYXFR2
	MOV	(F),@(SP)	;DEPTH OF SUB SNAP BIGGEST YET
	BR	DYXFR2	;LOOP BACK

;ALL TRANSFERRING DONE.  END THE BLOCK WITH A POPJ
DYXFR3:	MOV	#DPOPJ,(A)
	SPOP	D	;POINTER TO DEPTH COUNTER
	INC	(D)+
	TST	(D)+	;POINTER TO FIRST D.WORD OF SNAP
	SKPRET	;AND RETURN

;THERE WAS NOTHING TO BE MOVED
DYRET:	CLR	D	;TO SIGNAL THIS FACT
	SKPRET

;DYFREE
;	CALLED DURING GARBAGE COLLECTIONS
;	CALL WITH D POINTING TO REF COUNTER (WORD BEFORE SNAP)
;	FREES THE BLOCK!!
DYFREE:	PUSH	A	;SAVE REGISTERS
	SPUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F

	MOV	#100000,A
	MOV	#140000,B
	MOV	#DPOPJ,C
	JSR	PC,DYF1	;DOES THE FREEING
	JMP	RETF	;RESTORE AC'S AND RETURN TO OUT OF DYFREE

;REAL WORK OF FREEING STARTS HERE.
DYF1:	MOV	D,-(SP)	;SAVE PTR TO 2ND WORD OF BLOCK
	TST	(D)+	;POINT D TO FIRST WORD

;PICK UP EACH WORD OF BLOCK.  IF IT IS A PUSHJ, FREE THAT BLOCK
;CONTINUE UNTIL A POPJ IS REACHED
DYF11:	MOV	(D)+,F	;NEXT WORD
	CMP	F,A
	BLO	DYF11	;NOT PUSHJ OR POPJ
	CMP	F,B
	BHIS	DYF2	;NOT PUSHJ, BUT MAY BE POPJ

;	ITS A PUSHJ
	MAKEAD	F
	DEC	-(F)	;REF COUNTER
	BR DYF11	;LOOK AT NEXT WORD

;IS THE WORD A POPJ
DYF2:	CMP	F,C	;C CONTAINS A POPJ
	BNE	DYF11	;NOT A POPJ.  LOOK AT NEXT WORD
	SPOP	C	;POINTER TO 2ND WORD OF BLOCK
	TST	-(C)	;NOW IT POINTS TO BOTTOM WORD
	SUB	C,D	;LENGTH OF BLOCK
	MOV	D,F


;NOW LINK BLOCK BACK TO FREE CORE
;C/ADDRESS OF BLOCK TO BE LIBERATED
;F CONTAINS LENGTH OF BLOCK

DYLIB:	MOV	DYB,B	;INITIALIZE POINTER TO BOTTOM OF LIST
DYLIB1:	MOV	2(B),A	;NEXT FREE BLOCK
	BEQ	DYLIB3	;AT END OF LIST
	CMP	A,C
	BHI	DYLIB2	;PASSED BLOCK TO BE FREED
	MOV	A,B	;TRY NEXT FREE BLOCK
	BR	DYLIB1
DYLIB2:	MOV	F,D	;CHECK UPPER BOUND
	ADD	C,D	;DO WE COLLAPSE NEW BLOCK WITH NEXT ONE?
	CMP	D,A
	BNE	DYLIB3	;NO
	ADD	(A),F	;YES--NEW LENGTH
	MOV	2(A),2(C)	;NEW POINTER
	CMP	A,DYR	;DID WE JUST SCREW ROVING POINTER?
	BNE	DYLIB4
	MOV	DYB,DYR	;YES--RESET IT
	BR DYLIB4
DYLIB3:	MOV	A,2(C)	;POINTER TO NEXT FREE BLOCK--NO COLLAPSE ON TOP
DYLIB4:	MOV	(B),D	;CHECK LOWER BOUND
	ADD	B,D
	CMP	D,C	;DO WE COLLAPSE WITH BLOCK ON BOTTOM?
	BNE	DYLIB5	;NO
	ADD	F,(B)	;NEW LENGTH OF PREVIOUS BLOCK
	MOV	2(C),2(B)	;NEW POINTER
	BR	DYLIB6
DYLIB5:	MOV	C,2(B)	;POINTER IN PREVIOUS BLOCK--NO COLLAPSE
	MOV	F,(C)	;LENGTH OF BLOCK JUST FREED
DYLIB6:	MOV	C,A	;DID WE JUST FREE BOTTOM BLOCK IN DY?
	SUB	#4,A
	CMP	A,DYB	;NOTE THAT IF CURRENT BLOCK = DYB+4
			;THEN PREVIOUS BLOCK (ADDR IN B) MUST BE DYB
	BNE	DYLIB7	;NO
	ADD	(C),B	;YES--COLLAPSE DY AREA
	CLR	(B)
	MOV	2(C),2(B)	;NEW BOTTOM BLOCK
	MOV	B,DYB
	MOV	B,DYR	;FIX POINTERS
DYLIB7:	RTS	PC


;DSGCF
;	CALLED BY LOGO GARBAGE COLLECTOR WHEN ITS ALL DONE
;	SEE IF EACH SNAP ON THE SNAP LIST WAS MARKED.
;	AND DYFREE THE SNAP IF NOT MARKED AND IT'S REFERENCE COUNTER IS 0

DSGCF:	CLR	F
	BR	DSGC1

DSGC4:	TST	F	;0 IF FIRST TIME THROUGH
	BEQ	DSGC5

;
;CODE FROM DSGC8 - DSGC9 GETS CALLED BY DCHK TO COMPRESS DISPLAY AREA
;
DSGC8:	MOV	STB,A	;COMPRESS ADDX'S AND ADDY'S IN STATIC AREA
	MOV	SNABOT,B	;FIRST DO PART BELOW SNAP BOTTOM
	JSR	PC,ADDSHK
	MOV	C,SNABOT	;C IS NEXT LOCATION TO STORE INTO
	MOV	STT,B	;NOW DO PART ABOVE SNAP BOTTOM
	JSR	PC,ADHK0	;DON'T RECLOBBER C.
	MOV	(A),(C)	;STORE PUSHJ TURTLE, TOO
	MOV	C,STT
	CLR	NADXY

DSGC9:	RTS	PC
DSGC5:	MOV	#<DSGC6-DSGCF1>,F	;NOW CLEAR MARKED BITS
DSGC1:	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BEQ	DSGC8	;OBVIOUSLY DOESN'T HAVE SNAPS

	JSR	PC,.LOADC	;FIRST NODE OF LIST IS DUMMY
DSGC2:	MOV	C,E	;SAVE POINTER TO NODE
DSGC3:	BIT	#7777,A	;LEAVE ADDRESS ONLY
	BEQ	DSGC4	;END OF LIST
	MOV	A,C	;POINTER TO NEXT NODE
	JSR	PC,.LOADC
	ADD	F,PC	;CHOOSE BETWEEN FREEING AND CLEARING

;TRY TO FREE THE SNAP
DSGCF1:	TST	-(B)	;WAS SNAP MARKED?  (B POINTS TO REF COUNT)
	BNE	DSGC2	;EITHER DISPLAYED OR MARKED

;NOT MARKED, AND NOT DISPLAYED ANYWHERE!!
;FREE THIS SNAP
	JSR	PC,.FREE	;CLEAN UP SNLIST
	MOV	E,C	;POINTER TO PREVIOUS NODE OF SNLIST
	JSR	PC,.STP1	;STORE A AS TOP WORD OF PREVIOUS NODE
	MOV	B,D	;POINTER TO SNAP DCODE
	JSR	PC,DYFREE
	BR	DSGC3

DSGC6:	BIC	#100000,-(B)	;CLEAR MARKED BIT
	BR	DSGC3

;ADDS HACK
;	COMPRESS ADDX'S AND ADDY'S STARTING AT LOCATION IN A
;	AND GOING TO LOCATION IN B. (DOESN'T STORE WORD AT LOC IN B)
ADDSHK:	MOV	A,C	;C IS NEXT LOC TO STORE INTO.
ADHK0:	CLR	-(SP)	;FLAG. (NOT IN MIDDLE OF ADD'S)
ADHK1:	CMP	A,B	;ARE WE DONE?
	BHIS	ADFIN	;YES
	MOV	(A)+,D	;NEXT WORD
	CMP	D,#ADDY
	BLO	ADNOT	;NOT AN ADD
	TST	(SP)	;IN MIDDLE OF ADD'S ALREADY ?
	BNE	ADPHS1	;YES
	CLR	E	;NO. THIS IS FIRST ADD
	CLR	F
	INC	(SP)	;SET FLAG
ADPHS1:	CMP	D,#ADDX	;THE BIGGER ADD COMMAND
	BHIS	ADPHSX
;IT IS AN ADDY
	ADD	D,F	;ADD THE DELTA-Y INTO F
	BR	ADHK1	;LOOP BACK
ADPHSX:	ADD	D,E	;ADD THE DELTA-X INTO E
	BR	ADHK1

ADNOT:	TST	(SP)
	BEQ	ADHK2	;NOT END OF ADD'S
	JSR	PC,ADPHSF	;JUST ENDED ADDS.
	CLR	(SP)
ADHK2:	MOV	D,(C)+	;STORE THIS WORD
	BR	ADHK1

ADFIN:	TST	(SP)+	;ALL WORDS PICKED UP
	BEQ	ADHK3
	JSR	PC,ADPHSF	;BUT FIRST FINISH ADDS
ADHK3:	RTS	PC

;ADD PHASE FINISHED.  STORE ADDX E, ADDY F.
ADPHSF:	BIC	#176000,E
	BIC	#176000,F
	BEQ	ADPF1	;DELTA-Y = 0
	BIS	#ADDY,F
	MOV	F,(C)+	;STORE ADDY
ADPF1:	TST	E
	BEQ	ADPF9	;DELTA-X = 0
	BIS	#ADDX,E
	MOV	E,(C)+	;STORE ADDX
ADPF9:	RTS	PC


;MKDC
;	CALLED BY LOGO GARBAGE COLLECTOR DURING MARKING PHASE
;	CALLED WITH B POINTING TO SNAP NODE
MKDC:	TST	SNLIST	;CALLED TO KILL THE DISPLAY?
	BEQ	MKDC.K	;YES
	BIT	#7777,B
	BEQ	DSGC9	;EMPTY SNAP
;MARK THE SNAP
	PUSH	A
	SPUSH	B
	JSR	PC,.LOAD	;POINT B TO NODE CONTAINING SNAP ADDR
	JSR	PC,.LOAD	;B_SNAP ADDRESS
	BIS	#100000,-(B)	;MARK REF COUNTER
	SPOP	B	;RESTORE A AND B
	SPOP	A
	RTS	PC

;CALLED BY KILLDISPLAY
;TURN SNAP INTO EMPTY SNAP
MKDC.K:	SPUSH	A
	SPUSH	B
	SPUSH	C
	MOV	B,C	;POINTER TO DCODE NODE
	CLR	A
	JSR	PC,.STP2
	JMP	RETC



;HERE START THE LINE AND TURTLE DRAWING PROGRAMS

;DR.LIN
;	DRAW A LINE. D=DX, E=DY, OR VICE VERSA.
;	THE DIRECTION CODE FOR THE LINE IS IN DIREC
DR.LIN:	CMP DIREC,ODIREC
	BEQ .+6
	CLR DFBCNT
	JSR	PC,DR.STUP	;SET A=CON, B=AC.
	SPUSH	D
	ADD	STT,D	;D = HOW MANY MORE WORDS IN DLIST
	CMP	D,DYB	;COMPARE TO DY BOTTOM
	BLO	DR.L1	;THERE'S ROOM
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	SPOP	D	;TRY TO FIT LINE AGAIN
	ADD	STT,D
	CMP	D,DYB
	BLO	DR.L2	;THERE'S ROOM!
	ERROR+TML	;TOO MANY LINES

;OKAY, THERE WAS ROOM FOR THE LINE
DR.L1:	TST	(SP)+	;WE HAD PUSHED D UP ABOVE
DR.L2:	MOV	D,STT	;SET STT TO NEW STATIC TOP
	MOV	PUSHJT,(D)	;PUT PUSHJ TURTLE AT TOP
	JSR	PC,DR.ASC	;ASSEMBLE THE DISPLAY CODE
	MOV DIREC,ODIREC
	RTS	PC	;RETURN


;DRAW THE TURTLE
DR.TUR:	PUSH DIREC
	SPUSH DFBCNT
	MOV	#TURSIZ,C	;TURTLE SIZE
	CLR	B
	JSR	PC,MULCOS	;E,,F _ SIZE * COSA
	ROL	F
	ADC	E	;ROUND
	MOV	E,D
	JSR	PC,MULSIN	;E,,F _ SIZE * SINA
	ROL	F
	ADC	E	;ROUNFD

	SPUSH	D
	SPUSH	D
	SUB	E,2(SP)	;NOW SIZE * (COSA - SINA) IS ON STACK
	ADD	E,(SP)	;NOW SIZE * (COSA + SINA) IS ON STACK

	MOV	TUB,TUT	;TUT WILL BE POINTER TO TOP OF TURTLE DLIST SO FAR

;SIDE 1
	ADD	#20,DIREC	;SIDE 1 IS 2*45 DEGREES LEFT OF CURRENT DIRECTION
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 2
	SUB	#30,DIREC	;SIDE 2 IS 3*45 DEGREES RIGHT OF SIDE 1
	MOV	(SP)+,D	;DX IS SIZE * (COSA + SINA)
	MOV	(SP)+,E	;DY IS SIZE * (COSA - SINA)
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 3 HAS THE SAME INCREMENTS AS SIDE 2.
;JUST THE DIRECTION IS DIFFERENT
	MOV	DIREC,B
	SUB	#20,B	;SIDE 3 IS 2*45 DEGREES RIGHT
	BIC	#177707,B	;LEAVE ONLY THE 3 BITS
	SWAB	B	;PUT THE DIREC BITS IN TOP BYTE
	MOV	TUT,C	;POINTS TO WORD ABOVE LAST ONE OF TURTLE DLIST
	MOV	C,A
	SUB	D,C	;SINCE D POINTS TO BOTTOM WORD OF SIDE 2
			;C-D IS NUMBER OF BYTES IN SIDE 2'S DLIST
	ASR	C	;C/2 = NUMBER OF WORDS
DR.TS3:	MOV	(D)+,E	;NEXT WORD OF SIDE 2'S DLIST
	BIC	#34000,E	;CLEAR THE DIRECTION BITS THEREIN
	BIS	B,E	;AND SET THEM FROM THE NEW DIREC IN B
	MOV	E,(A)+	;STORE IN DLIST
	DEC	C	;NUMBER OF WORDS IN SIDE 2'S DLIST
	BGT	DR.TS3	;THERE ARE MORE WORDS

;SIDE 4 IS IDENTICAL TO SIDE 1
;FURTHERMORE, SIDE 1 IS MADE UP OF ONLY ONE WORD
	MOV	@TUB,(A)+	;PUT THE FIRST WORD OF TURTLE INTO TOP WORD
	MOV	#DSTOP!DPOP,(A)

;RESTORE DIREC, THEN RETURN
	SPOP DFBCNT
	POP DIREC
	RTS	PC


;DRAW TURTLE SIDE
;	DRAW ONE SIDE OF THE TURTLE
;	DIREC CONTAINS THE DIRECTION
;	TUT POINTS TO TOP OF TURTLE DISPLAY LIST SO FAR
;	C,D = + OR - DX OR DY
DR.TSD:	BIC	#177707,DIREC	;BITS MAY HAVE BEEN SET BY THE SUBTRACTING
	CLR DFBCNT
	JSR	PC,DR.STUP
	ADD	TUT,D	;D = NEW TOP OF TURTLE
	MOV	D,TUT
	JMP	DR.ASC	;ACTUALLY CREAT THE DISPLAY LIST


;SET UP CON AND AC
;	CALL WITH D,E = + OR - DX OR DY
;	RETURNS A=FRACTION: MIN (DX/DY,DY/DX)
;		B=ACCUMULATED FRACTION PART SIDEWAYS OF MAIN DIRECT.
;		STARTS AT 1/2
DR.STUP:	TST	D
	BGE	DR.TE	;TEST E
	NEG	D	;MAKE D POSITIVE
;MAKE SURE E IS POSITIVE
DR.TE:	TST	E
	BGE	DR.BIG	;NEXT WE'LL SEE WHICH IS BIGGER
	NEG	E	;MAKE D POSITIVE

;WHICH IS BIGGER
DR.BIG:	MOV	#MQ,A
	CLR	(A)	;START TO SET UP DIVISION
	CMP	D,E
	BGT	DR.DBG	;D IS BIGGER
	BEQ	DR.EQ	;THEY ARE THE SAME SIZE

;OTHERWISE, E IS BIGGER
	ASL	E	;SO EAE WON'T OVERFLOW WITH A 16 BIT QUOTIENT
	MOV	D,-(A)	;HIGH ORDER DIVIDEND
	MOV	E,-(A)	;AND E IS THE DIVISOR
	MOV	E,F	;WHICHEVER IS BIGGER IS THE NUMBER OF INCS
	BR	DR.SC4

;THEY ARE THE SAME SIZE
DR.EQ:	MOV	#-1,A	;SET CON = .777...
	MOV	E,F	;NUMBER OF INCS
	BR	DR.SC5

;D IS BIGGER
DR.DBG:	ASL D
	MOV	E,-(A)	;HIGH ORDER DIVIDEND
	MOV	D,-(A)	;AND D IS THE DIVISOR
	MOV	D,F	;NUMBER OF INCS

;NOW PICK UP THE QUOTIENT
DR.SC4:	ADD	#4,A	;POINT A TO QUOTIENT
	MOV	(A),A	;SET CON TO THE QUOTIENT
	ASL	A	;MAKE QUOTIENT 16 BITS
	ASR	F	;SINCE WE DOUBLED IT ABOVE

;NOW SET AC = .1000 = 1/2 IN THIS REPRESENTATION
DR.SC5:	MOV	#100000,B
;FALLS IN!!!!!--RJL	THAT'S RIGHT--RLH


;CALCULATE THE NEW END POINT OF THE DLIST
;	RETURNS A AND B AS ABOVE
;	C = BIT-POSITION OF LAST BIT OF NEW CODE
;	  (GENERATED BACKWARDS--STORE FROM HERE BACK)
;	D = NUMBER OF MORE WORDS IN DLIST
;	  (WILL BECOME ADDR OF LAST NEW WORD + 2)
;	E = TOP BYTE OF INCR INSTRUCTION, SWAPPED
;	F = # NEW INCREMENTS
DR.NEP:	CLR C		;CLEAR BIT-POSITION
	MOV F,E		;GET # OF INCREMENTS
	SUB DFBCNT,E	;LESS # LEFT OVER
	MOV E,D
	ASR D		;DIVIDE BY 8
	ASR D
	BIC #1,D	;TIMES 2 IS # NEW WORDS
	BIC #177770,E	;REMAINDER IS # BITS IN LAST WORD
	BEQ DR.NE2	;IF 0 THEN = 8 IN PREVIOUS WORD

	MOV #8.,DFBCNT	;ELSE FREE BITS = 8 - # USED
	SUB E,DFBCNT
	TST (D)+	;ADD ONE-WORD FUDGE FACTOR IN THIS CASE
	MOV E,-(SP)	;SAVE COUNT
	SEC
DR.NE1:	RORB C		;SHIFT FIRST-BIT IN OR RIGHT ONE BIT
	DEC E		;SHIFT IT RIGHT (REMAINDER) PLACES
	BNE DR.NE1
	MOV (SP)+,E	;GET COUNT BACK
	BR DR.NE3

;REMAINDER WAS 0:  LAST WORD GETS FILLED UP
DR.NE2:	INC C		;LAST BIT IS LAST IN WORD
	CLR DFBCNT	;NO FREE BITS

DR.NE3:	ADD #DINC_-8,E	;PUT IN "INCREMENT" CODE
	ADD	DIREC,E	;ADD IN THE DIRECTION
	RTS	PC


;ACTUALLY ASSEMBLE THE NEW DISPLAY LIST
;	CALL WITH A=SIDEWAYS/FORWARD, B=1/2 (ACCUM SIDEWAYS),
;	C=FIRST BIT POS., D=POINTER  TO FIRST WORD TO STORE OF DLIST
;	E=TOP HALF OF THE INC MODE INSTRUCTION, F=NUMBER OF INCS
DR.ASC:	SWAB	E	;STUFF IN E WAS IN WRONG HALF
DR.AS0:	ADD	A,B	;CON+AC
	BCC	DR.AS1
	ADD	C,E	;CARRY, SO PUT A 1 INTO DCODE
DR.AS1:	DEC	F	;NUMBER OF INCS
	BLE	DR.ALW	;THIS WAS THE LAST WORD
	CLC
	ROLB	C	;SHIFT BYCNT
	BCC	DR.AS0	;CONTINUE WITH THIS WORD

;THIS WORD DONE
	JSR	PC,DR.SH
	MOV	E,-(D)	;STORE IN DLIST
	BIC	#3777,E	;0 THE COUNT AND BOTTOM BYTE
	MOV	#1,C	;RESET BYCNT
	BR	DR.AS0

;ALL THAT'S LEFT TO DO IS STORE THE BOTTOM WORD OF NEW DLIST
DR.ALW:	MOV -(D),B	;GET WORD TO HOOK
	CLR A		;SET UP BIT TO HOOK FROM
	SEC		;  "
DR.LW1:	ROL A		;  "  OR NEXT BIT TO HOOK FROM
	CLC
	ROLB C		;NEXT BIT TO HOOK INTO
	BCS DR.LW2	;DONE HOOKING
	BIT A,B		;GET BIT
	BEQ DR.LWX
	ADD C,E		;STORE IT
DR.LWX:	CLC		;SET UP FOR ROL A
	BR DR.LW1

DR.LW2:	JSR	PC,DR.SH	;SHOVE TO RIGHT END OF WORD
	MOV	E,(D)	;STORE LAST WORD
	RTS	PC

;SHIFT CODE RIGHT 8 MINUS COUNT TIMES

DR.SH:	SPUSH	E
	SWAB E		;GET COUNT OF USED BITS
DR.SH1:	BIC #177770,E	;ISOLATE COUNT
	BEQ	DR.SH2	;DONE
	INC E		;COUNT UP; DONE AT 8 (OR 0)
	CLC
	RORB	(SP)	;MAKE ANOTHER FREE BIT AT LEFT
	BR	DR.SH1
DR.SH2:	SPOP	E
	RTS	PC

.STITL DISPLAY BUFFERS

.IF2
	PAD ^\START OF BUFFERS\,\.
.ENDC

	DISREL=.	;DISPLAY RELOCATION

;FIRST WORD OF EACH DISPLAY IS HERE
	REPT1	10,DSTOP

;THE DISPLAY PDL POINTERS FOLLOW
	DPDLP=.
	REPT1 10,-1

;THE DISPLAY PDL'S GO HERE
	DPDL=.
	.=.+SDPDLL	;SAVE A BLOCK OF CORE FOR PDL'S

;THE BODY OF THE DISPLAY LISTS GO HERE
	DLIST=.
	.=.+SDLEN	;SAVE A BLOCK OF CORE FOR DISPLAY LISTS

;THE TURTLE DISPLAY LISTS GO HERE
	TLIST=.
	.=.+STLEN	;SAVE A BLOCK OF CORE FOR THE TURTLES

;AND THAT IS THE END OF THE DISPLAY LIST BUFFERS
	DLTOP=.-1
	.ENDC
	ENDC NDISP
