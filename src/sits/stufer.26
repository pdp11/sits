	.TITLE STUFFER
.MACRO DCS NAME,VAL
NAME==VAL
.ENDM

.INSRT SITS;SITSS SYMS
.INSRT SITS;SITMAC >
.=400
PDL:
	.BLKW 10	;INTERRUPT PROCESS PDL
INPDL:
FLSBUF:	.BLKW 100
FLSBFE::
LSTCHR:	0
FLSEND:	0
	.BLKW 30
FLSPDL::
LDRLK:	.ASCII /STUFF IT!/
LDRLKE::
.EVEN
LSICAP:	0		;CAPABILITY TO LSI
TTYNUM:	5		;TTY NUMBER OF THE LSI
FILCAP:	0		;CAP TO FILE
DONFLG:	0
CONMOD:	0		;IF NON ZERO WE SHOULD RESTART INSTEAD OF DYING
TXT==TEXTBG		;BEGINNING OF TEXT
.MACRO TYPEIT TEXT
	MOV #TXT,-(P)
	MOV #<-<<.LENGTH ^ÔEXT¬>+1>>,-(P)
	MOV #2,-(P)
	.BLKO
.IF2
FOO==.
.=TXT
.ASCII ÔEXTŠ.BYTE 15
TXT==.
.=FOO
.ENDC
.ENDM

.MACRO ERROR TEXT
	BNE .+<11*2>
	TYPEIT ^ÔEXTŠ	BPT
.ENDM


START:	MOV #PDL,P
	SAVE <,,#.SPKIL*400+1>
	$INVOK		;KILL EXTRAS
	CLR CONMOD
	SAVE <,#.TLIPM!.TIRST!.TORST!.TIECM!.TICVM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;SET THE TTY STATUS FOR THIS TERMINAL
	SAVE <#-1,TTYNUM,#.TTCAP*400>
	.INVOK		;CREATE THE LSI CAPABILITY
	ERROR <LSI PORT IN USE>
	REST LSICAP
	SAVE <,#33503,#.TTSPD*400>
	MOVB LSICAP,(P)	;SET IN LSI CAP NUMBER
	.INVOK		;SET SPEED TO 9600, 8 BITS, NO PARITY
	BNE 1$	;START LOAD
	TYPEIT <CANT SET SPEED, CONTINUING ANYWAY>
1$:	SAVE <#TYIFLS>
	$FORK		;GO GOBBLE ALL INPUT FROM LSI
STARTL:	SAVE <,#.TIMGI!.TIMGO.!.TIRST!.TORST,#.TTMOV*400>
	MOVB LSICAP,(P)	;SET THE LINE TO IMAGE IN AND OUT
	$INVOK
	SAVE <#1,LSICAP>	;SEE IF WE ARE TALKING TO THE TAPE PROGRAM
	$BYTO
	SAVE <#0,#60.>
	$SLEEP
	MOV #FLSBUF,A	;BEG OF FLUSH BUFFER, END IS IN B ALREADY
1$:	MOV #LDRLK,C	;INCANTATION TO LOOK FOR
2$:	CMPB (A)+,(C)+	;SAME?
	BNE 3$
	CMP #LDRLKE,C	;HAPPY?
	BNE 2$
	TYPEIT <TALKING TO TAPE, LSI READYîEND WORDS OF WISDOM TO TAPE WITH ALT:î>	
	SAVE <,#.TIRST!.TIECM!.TICVM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;RESET TTY INTO CHARACTER AT A TIME MODE

9$:	SAVE #2
	$BYTI
	CMP (P),#33
	BEQ 8$	
	SAVE LSICAP
	$BYTO
	BR 9$
8$:	TST (P)+
	SAVE <,#.TLIPM!.TIRST!.TORST!.TIECM!.TICVM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;SET THE TTY STATUS FOR THIS TERMINAL
	TYPEIT <îNOW FILE NAME:î>
	JMP GETLIN
3$:	CMP FLSEND,A
	BHI 1$
	CLR LSTCHR	
	SAVE <,#4,#.TBRAK*400>	;TRANSMIT BREAK ON LINE
	MOVB LSICAP,(P)
	$INVOK		;CAUSE THE BREAK TO HAPPEN
	SAVE <#15,LSICAP>	;TRANSMIT CR.
	$BYTO		;SEND IT
	MOV #10.,A	;10 ITERATIONS OF SLEEPING FOR 1/10 SEC
WAIT1:	CMP #'@,LSTCHR
	BEQ GOTCHR
	SAVE <#0,#6>	;TAKE A SNOOZE
	$SLEEP		;ZZZZZZ
	SOB A,WAIT1	;WAIT AWAY
	TYPEIT <NO RESPONSE FROM LSI11 TRY AGAIN?>
	SAVE <,#.TIRST!.TIECM!.TICVM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;RESET TTY INTO CHARACTER AT A TIME MODE
	SAVE #2		;INPUT CHARACTER
	$BYTI		;GET IT
	SAVE <,#.TLIPM!.TIRST!.TORST!.TIECM!.TICVM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;SET THE TTY STATUS FOR THIS TERMINAL
	CMPB (P)+,#'Y	;YES?
	BEQ STARTL	;TRY IT AGAIN
	BPT
	BR STARTL
GOTCHR:	TYPEIT <LSI READY>
GETLIN:	MOV #LINBUF,A	;LINE BUFFER
	MOV #LINLEN,B	;LENGTH OF BUFFER
CHRLOP:	SAVE #2		;READ CHARACTER
	$BYTI		;GET BYTE
	CMPB (P),#15	;CR?
	BEQ GETFIL	;DONE
	CMPB (P),#33	;ALT?
	BNE 1$
	MOVB (P)+,CONMOD	;SET CONTINUE MODE
	BR CHRLOP
1$:	MOVB (P)+,(A)+	;GO PUT IT INTO BUFFER
	SOB B,CHRLOP	;OUTPUT IT
	TYPEIT <LINE TOO LONG, RETRY>
	BR GETLIN	;TRY TRY AGAIN
GETFIL:	CLRB (A)	;MAKE SURE IT IS ZERO
	MOV #LINBUF,F	;POINTER TO THE BUFFER
	SUB F,A		;GET THE CHARACTER COUNT
	DEC A		;ONE LESSU
	MOV #LINBUF+1,C	;POINTER TO THE BUFFER+1 FOR PARSE FOR ";
DSKLOP:	CMPB (C)+,#';	;PARSE FOR ;
	BEQ FNDDSK	;FOUND DISK SPEC.
DSKLP1:	SOB A,DSKLOP
	MOV #4,D	;THE BASE CAPABILITY
	BR MUTFIL	;GO TO THE MUTATE DIRECTLY
FNDDSK:	MOVB -2(C),D	;GET THE CHARACTER BEFORE ;
	BIC #177400,D	;LOSING REGISTER CRUD
	SUB #'0,D	;TURN IT INTO NUMBER IF IT IS ONE
	BMI DSKLP1	;KEEP ON TRYING
	CMP D,#4	;IS IT TO BIG?
	BHI DSKLP1	;KEEP TRYING
	ADD #10,D	;GET THE START TO BE THAT DISK'S ROOT
	MOV C,F		;POINTER TO THE BUFFER
MUTFIL:	SAVE <#-1,,D>	;COPY THE STARTING CAPABILITY
	BIS #.CPYCP,(P)
	.INVOK		;TRY TO COPY IT
	BNE 1$
	TYPEIT <CANT COPY DEFAULT, RETYPE>
	BR GETLIN	;GET LINE AGAIN
1$:	REST FILCAP	;CAP TO FILE
	SAVE <#0,F,FILCAP>	;MUTATE IT
	BIS #.FAMU,(P)
	.INVOK		;AWAY
	BNE 2$		;WON
	TYPEIT <CANT MUTATE TO FILE, RETYPE NAME>
	BR GETLIN
2$:	SAVE #INTPRS	;START PROCESS AT INTPRS
	$FORK		;FOR DETECTING A QUIT SIGNAL
	SAVE <,#.TIRST!.TIECM!.TICVM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;RESET TTY INTO CHARACTER AT A TIME MODE
	SAVE <#LSILOD,#-LSILEN,LSICAP>	;OUTPUT LOAD COMMAND
	$BLKO		;SEND IT TO LSI
.IFZ 105
LLOP:	SAVE LSICAP	;LOOP UNTIL L SEEN
	$BYTI
	CMPB (P)+,#'L	;L YET?
	BNE LLOP	;NOPE
.ENDC
	SAVE <#0,#3*60.>
	$SLEEP
	SAVE <#LSIBOT,#-LSIBLN,LSICAP>	;OUTPUT THE ABSOLUTE LOADER
	$BLKO		;GOT IT
.IFZ 105
ATLOP:	SAVE LSICAP	;WAIT FOR @ TO COME BACK
	$BYTI
	CMPB (P)+,#'@
	BNE ATLOP	;NOT YET
	SAVE <#'P,LSICAP>	;OUTPUT P FOR PROCEDE
	$BYTO		;AND SEND IT
PLOP:	SAVE LSICAP	;WAIT FOR P
	$BYTI
	CMPB (P)+,#'P
	BNE PLOP
.IFF
	SAVE <#0,#3*60.>
	$SLEEP
.ENDC
	SAVE <#3400,,#27*400+377,#.CRWRT+1>	;GET PAGE BELOW FILE PAGE
	$MAP		;MAP IT IN
	CLR A		;PAGE COUNTER FOR MAPS
	CLR C		;NUMBER OF BYTES WE ARE WORKING ON
MAPLOP:	SAVE <#177400,A,FILCAP,#.CRRD+1>	;MAP IN THE FILE (AS MUCH AS POSSIBLE
	MOVB #27,3(P)	;PAGE IS TOP PAGE IN CORE
	$MAP		;SHOULDN'T LOSE
	INC A		;SO THAT WE GET THE NEXT PAGE
	MOV #20000,B	;THE LENGTH OF A PAGE
BLKLOP:	CMP C,B		;MORE THAN A PAGE WORTH TO DO?
	BGE SNDPAG	;SEND THE PAGE, AND CONTINUE
	TSTB 160000(C)	;PADDING FOR BLOCK?
	BNE 3$		;NO
	INC C		;NEXT BYTE
	BR BLKLOP
3$:	CMP C,#20000-4	;COUNT ON THIS PAGE?
	BLE 1$		;YES, EVERYTHING IS OKAY
	MOV C,D		;COPY POINTER
	ADD #140000,D	;POINT TO PREVIOUS PAGE TO COPY DATA
2$:	MOVB 20000(D),(D)+	;PUT THE BYTE AWAY
	CMP D,#160000	;AT END OF PAGE?
	BLO 2$		;NO
	BR SNDPAG	;SEND THIS PAGE, WE WILL CHECK LENGTH NEXT TIME
1$:	MOVB 160003(C),D	;GET THE TOP BYTE OF THE LENGTH
	SWAB D		;PUT INTO TOP BYTE
	BIC #377,D	;CLEAR LOW BYTE
	BISB 160002(C),D	;SET IN LOW PART OF LENGTH
	ADD D,C		;ADD TO BYTE COUNT TO SEND
	INC C		;ONE FOR THE CHECKSUM
	CMP D,#6	;DONE?
	BNE BLKLOP	;NO, CONTINUE
LODDON:	MOV C,B		;THE NUMBER OF BYTES TO SEND
	MOV #-1,DONFLG	;SAY WE ARE DONE
SNDPAG:	NEG B		;NUMBER OF BYTES TO SEND
	SAVE <#160000,B,LSICAP>	;SEND BYTES
	$BLKO		;BLOCKOUT
	SUB #20000,C	;MAKE IT 1 PAGE LESS
	TST DONFLG	;DONE?
	BEQ MAPLOP	;NO
	TYPEIT <FINISHED!!!>
	SAVE <,,LSICAP>
	BIS #.DELCP,(P)
	$INVOK
	TST CONMOD
	BEQ DONE
	JMP START
DONE:	BPT
	0
INTPRS:	MOV #INPDL,P
	SAVE <,#.TIRST!.TIECM!.TICTM,#<.TTMOV*400>+2>
	$INVOK		;SET TTY TO CHARACTER AT A TIME
WAITI:	SAVE #2		;GET CHAR
	$BYTI
	CMPB (P)+,#'Q	;CTL-Z?
	BNE WAITI	;NOPE
	BPT
	BR WAITI

SNOOZE:	SAVE <#0,#60.>	;TAKE A SNOOZE
	$SLEEP		;ZZZZZZ
	RTS PC

TYIFLS:	MOV #FLSPDL,P
	MOV #FLSBUF,B
2$:	SAVE LSICAP	;READ UNTIL YOU GET AN @
	$BYTI		;READ CHARACTER
	MOVB (P),(B)+
	MOVB (P),LSTCHR
	SAVE <#2>
	$BYTO		;LET GUY KNOW WHAT'S GOING ON
	MOV B,FLSEND
	CMP #FLSBFE,B
	BHI 2$
	BR TYIFLS





LINBUF:	.BLKW 60
LINLEN==.-LINBUF
LSILOD:	.ASCII /177560L/
LSILEN==.-LSILOD
.EVEN
LSIBOT:
WAITIN==240	;CONTINUE FOR OUR VERSION
.INSRT BEE;ABS >
	.BLKW 10	;SO TAPE GETS HAPPY
LSIBLN==.-LSIBOT
.EVEN
TEXTBG==.
.END START
