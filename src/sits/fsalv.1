	.TITLE "SALVAGER" FOR THE SITS FILE SYSTEM
	.STITL PARAMETERS
	.ABS

;WHEN INITING THE MOVING HEAD DISK
;RUG WANTS BLOCKS 0,4-23, AND 54-217 ON DISK 0
;LOGO WANTS 100-1100 FOR SWAPPING ON DISK 1

;WHEN INITING THE FIXED HEAD DISK
;RUG WANTS BLOCKS 0,4-23, AND 54-217
;LOGO WANTS 500-1777 FOR SWAPPING



	A=%0
	B=%1
	C=%2
	D=%3
	E=%4
	F=%5
	P=%6
	PC=%7
	.XCREF A,B,C,D,E,F,P,PC

	DISKWR==3
	DISKRD==5
	DISKWC==7
	WCERR==1

	TBUFLN==100

	SWB=177570	;DATA SWITCHES

	RKER=177402	;MOVING HEAD DISK REGS
	RKCS=177404
	RKWC=177406
	RKBA=177410
	RKDA=177412

	PLATR1==20000
	PLATR2==40000
	PLATR3==60000

	DSKS=177460	;FIXED HEAD DISK REGS
	DSKWC=177462
	DSKCA=177464
	DSKA=177466
	DSKAE=177470
	DSKDBR=177472

	NRETRY==30

;STACK FRAME OFFSETS
	FFBCKP==0	;BY DEFINITION; POINTS TO PREV. STACK FRAME
	FENTRP==FFBCKP+2	;ORIG. ADDR OF THIS ENTRY; FOR ALFORD
	FNXNTRY==FENTRP+2	;NEXT ENTRY OF PUSHED DIRECTORY
	FDDESC==FNXNTRY+2	;DESCRIPTOR OFFSET IN THIS ENTRY
	FDBYTES==FDDESC+2	;DESCRIPTOR LENGTH
	FENTRY==FDBYTES+2	;START OF ACTUAL ENTRY

;ENTRY TYPES (TIMES 2 FOR DISPATCHING)
;A TYPE AS SEEN HERE, * 1000, = A TYPE AS IN TYPE FIELD
	PARENT==0
	DIREC==2
	FILE==4
;	LAST==6	
	SELF==10
	LINK==12
	ALFORQ==14
	BITS==16

;BITS IN FLAG BYTE
	MFISTB==1	;BLOCK EXISTS BIT (EOF POINTS TO EXISTING BLOCK)
	TYPEM==177761	;TYPE FIELD MASK
	SHRB==20	;SHARED BLOCK FLAGS (DON'T CLEAR IN BIT TABLE)
	ACCB==100	;ACCESS CODES EXIST
	EOFB==200	;EOF, DATE-TIME EXISTS	

;DESCRIPTOR BYTE TYPES
	DTYPEF==300	;TYPE-OF-DESCRIPTOR-BYTE FIELD
	DTSKP==0	;SKIP N AND GRAB 1 BLOCK
	DTCNT==100	;GRAB N+1 BLOCKS
	DTHOL==140	;HOLE OF N+1 BLOCKS
	DTSADR==200	;GRAB N+1 BLOCKS STARTING AT X (SET ADDR)
	DTSKCT==300	;SKIP N1 AND GRAB N2+1 BLOCKS
	DTCNTF==77	;FOR FIRST THREE TYPES, THE N FIELD
	DTSCSK==70	;FOR SKIP/COUNT, THE SKIP FIELD N1
	DTSCCT==7	; "      "    , THE COUNT FIELD N2
	.STITL MACROS
.MACRO	FPUSH X
	.XLIST
	MOV X,(F)+
	.LIST
.ENDM

.MACRO	PUSH X
	.XLIST
	MOV X,-(P)
	.LIST
.ENDM

.MACRO	POP X
	.XLIST
	MOV (P)+,X
	.LIST
.ENDM

.MACRO	TEXT X
	.XLIST
	.ASCII /X/
	.BYTE 0
	.EVEN
	.LIST
.ENDM

.MACRO	TYPEIT X
	.XLIST
	JSR F,TXTYPE
	TEXT ^/X/
	.LIST
.ENDM

.MACRO	ERROR X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/ERROR--'X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	ENTERR X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/ERROR--ENTRY /
	MOV ENTRYP,B
	JSR PC,NAMOUT
	TYPEIT ^/X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	BUG X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/BUG--'X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	MSG X
	.XLIST
	JSR PC,ERRORX
	TYPEIT ^/X/
	JSR PC,@(P)+
	.LIST
.ENDM

.MACRO	FLTEXT X
	.XLIST
	.IRPC XC,^/X/
	.IFNZ .LENGTH ^/X/,-<.IRPCN+1>
		.LIST
		.BYTE ''XC
		.XLIST
	.IFF
		.LIST
		.BYTE 200+''XC
		.XLIST
	.ENDC
	.ENDM
	.LIST
.ENDM
	.STITL SET TRAP VECTORS TO HALT
.=0
.REPT 100
.XLIST
.+2
HALT
.LIST
.ENDR
	.STITL VARIABLES AND THINGS
	.=1000
	JMP SALV
	.=2000
WORLD==.
NDISK:	0	;NEW DISK POSITION
NBLOKS:	0	;COUNT OF BLOCKS IN FILE
DSCEOF:	0	;END OF DISK DESCRIPTOR FILE
TOFIND:	0	;ADDR OF ENTRY NAME TO BE FOUND
DRIDND:	0	;POINTER TO THE END OF THE CREATED DIRID TABLE
DIREND:	0	;END OF DIRECTORY (AS SET BY LOADIR)
FBACKP:	0	;POINTS TO PARENT ENTRY OF THIS DIRECTORY
NEXTF:	0	;POINTS TO NEXT AVAILABLE F-STACK FRAME
ENTRYP:	0	;POINTS TO CURRENT ENTRY IN CURRENT DIRECTORY
NXNTRY:	0	;TO NEXT ENTRY IN CURR. DIR.
ETYPE:	0	;TYPE * 2 OF THIS ENTRY
NBYTES:	0	;LENGTH OF ENTRY
FLAGS:	0	;RANDOM FLAGS IN ENTRY
DDESCR:	0	;OFFSET OF DISC BLOCK DESCRIPTOR
DBYTES:	0	;LENGTH OF DESCRIPTOR
DSCEND:	0	;POINTS TO END OF DESCRIPTOR
		;(CAN BE FOUND BY FTYPE)

VN:	0	;SLOT FOR VERSION NUMBER, IN ALFORD.
OENTRY:	0	;PTS TO PREV. ENTRY IN CURR. DIR., FOR ALPH. ORD.
OTYPE:	0	;IS IT A PARENT OR SELF ENTRY
OFLAGS:	0	;HAS IT A VERSION NUMBER
OVN:	0	;ITS VERSION NUMBER

BITFND:	0	;BIT FOUND SET IN BITTABLE 2 BY CKBIT2
BITLIM:	0	;FIRST !BYTE! AFTER END OF BIT TABLE
BITSAT:	0	;HOW MUCH OF BIT TABLE YOU'VE TRANSFERRED SO FAR
DIRCNG:	0	;HAS THE DIRECTORY BEEN MODIFIED
DISKIO:	0	;DIRECTION OF TRANSFER (DISKRD OR DISKWR)
BLOKNO:	0	;BLOCK NUMBER OF CURRENT DISK BLOCK
BLKLIM:	0	;FIRST BLOCK NO. NOT ON DISK
RNG01F:	.BYTE 0	;FLAGS FOR BCOMP, TO MANAGE GROUPING OF BITS
RNG10F:	.BYTE 0	; THAT DISAGREE IN OLD AND NEW BIT TABLES.
		;0 = NO SEQUENCE, 1 = SINGLETON,
		;2 = SEQ OPEN, BE SURE TO CLOSE IT
RANYBQ:	0	;STAYS 0 IF NO BAD BITS SEEN.
WCHDSK:	0	;WHICH PLATTER: 0=FIXED  20000=REMOVABLE
BLOKDO:	0	;WHAT TO DO WHEN DMARCH SAYS "BLOCK # N"
RETRYS:	0	;# RETRYS LEFT BEFORE COMPLAINT
RETRYV:	0	;# VERIFY RETRYS "    "
DSKERR:	0	;DISK ERROR WORD
ERNTRYP:0	;POINTS TO LAST STACKED ENTRY VISITED BY BACKTRACE
BKFBKP:	0	;BACKTRACE'S STACK POINTER AS IT TRACES BACK

NCHR:	0	;NUMBER OF CHARS IN TYPEIN BUFFER
TBUFPT:	0	;PTR INTO BUFFER: FILLING AND EMPTYING
RUBING:	0	;NON-0 MEANS RUBBING OUT CHARS


TRNSLE:	-1000	;TRANSFER LENGTH
DOWHAT:	0	;ADDRESS OF DISPATCH TABLE FOR ENTRY TYPES

	.SBTTL DISPATCH TABLES
CKTAB1:	CKPAR	;DISPLATCH TABLE FOR PASS 1 (FIND SHARED BLOCKS)
	CKDIR
	CKFILE
	CKLAST
	CKSELF
	CKLINK
	ALFORD	;YES, CHECK ALPHABETICAL ORDER
	SETB12	;SET BIT TABLE 1, "OVERFLOW" TO TABLE 2

CKTAB2:	C2PAR	;DISPATCH TABLE FOR PASS 2 (MARK FILES SHARING BLOCKS)
	C2DIR
	C2FILE
	C2LAST
	C2SELF
	C2LINK
	SKPPNM	;SKIP PAST THE NAME
	CKBIT2	;SET DON'T DELETE FLAGS IF TABLE 2 SET


LOADX:	LODSKP
	LODCNT
	LODSAD
	LODSC

RTSPC:	RTS PC

BITSE:	FLTEXT ^/BITS/	;NAME OF BIT TABLE FILE
DESCRE:	FLTEXT ^/DESCR/	;NAME OF DISK DESCRIPTOR FILE
DIRIDE:	FLTEXT ^/DIRID/
	.EVEN

TBUF:	.=.+TBUFLN
	0	;JUST IN CASE
	.STITL !THE! !SALVAGER!!!
SALV:	RESET		;INIT THE BUSS
	MOV #WORLD,P	;INIT THE STACK POINTER
	JSR PC,ITYI	;INIT THE TYI
	TYPEIT ^/_SALV /	;_ MAKES A CRLF
	MOV #%FNAM2,B
	JSR PC,DECOUT
SALV2:	TYPEIT ^/_*/
SALV5:	JSR PC,TYI1
	CMP #'U-100,A	;CTL-U DOUBLE COPY UP
	BNE .+6
	JMP CNTLU
	CMP #'D-100,A	;CTL-D DOUBLE COPY DOWN
	BNE .+6
	JMP CNTLD
	CMP #'C-100,A	;CTL-C MEANS COPY
	BNE .+6
	JMP COPY
	CMP #'F-100,A	;CTL-F MEANS FORMAT
	BNE .+6
	JMP FRMT
	CMP #'I,A
	BEQ INIT0
	CMP #'C,A
	BEQ CHECK0
	CMP #'F,A	;FIXED HEAD BLOCK 0 INIT
	BEQ FXB0I0
	SUB #'0,A	;IS IT A NUMBER?
	BLT SALVQ	;NOPE, NOT THAT EITHER
	CMP #'9-'0,A	;MAYBE
	BLE SALVQ	;NOPE
	ASH #13.,A	;PUT IT INTO THE RIGHT PLACE
	MOV A,WCHDSK	;SET THE VARIABLE
	BR SALV5
SALVQ:	TYPEIT ^/ ?/
	BR SALV2

FXB0I0:	TYPEIT ^/IXED HEAD DISK BLOCK 0 INIT_SURE? /
	JSR PC,TYI1
	CMP #' ,A
	BEQ GOFXB0
	CMP #'Y,A
	BNE SALVQ
GOFXB0:	JSR PC,CRLF
	JMP FXINIT

INIT0:	TYPEIT ^/NIT_SURE?/
	JSR PC,TYI1
	CMP #' ,A
	BEQ GOINIT
	CMP #'Y,A
	BNE SALVQ
GOINIT:	JSR PC,CRLF
	JMP INITD

CHECK0:	TYPEIT ^/HECK_/
	JMP CHECK

	.STITL WRITE OUT AN INITIAL BLOCK 0 ON FIXED HEAD DISK.
FXINIT:	MOV #FHIDIR,A	;POINT TO THE IMAGE
	MOV #DSKBUF,B	;WHERE TO PUT IT
	MOV #<<FHIDIZ-FHIDIR>/2>,C	;THE LENGTH IN WORDS
	MOV #2000,D	;THE LENGTH OF A DISK BLOCK
	MOV (A)+,(B)+	;COPY IT
	SOB C,.-2
	CLR (B)+	;CLEAR OUT THE REST
	SOB D,.-2
	PUSH WCHDSK	;SAVE THE DISK
	CLR BLOKNO	;WRITE BLOCK 0
	MOV #-1,WCHDSK	;SAY THE FIXED DISK
	JSR PC,DSKWR1	;WRITE IT
	POP WCHDSK
	JMP SALV2	;ALL DONE, THIS DISK CAN'T WRITE-CHECK.


	.STITL CHECK THE FILE SYSTEM
CHECK2:	MOV #FBASE,F
	MOV F,NEXTF
	MOV F,FBACKP
	MOV F,ERNTRYP
	MOV #-1,BLKLIM	;ALLOW ANY BLOCK # TILL YOU GET THE BIT TABLE
	MOV #DIR,B	;LOAD ROOT STARTING HERE
	MOV #46,BLOKNO
	JSR PC,DSKRED	;GET FIRST BLOCK OF HEADER
	MOVB DIR+1,FLAGS	;GET ROOT HEADER FLAGS
	MOV #DIR,B	;GET THE END OF THE DIRECTORY
	ADD 6(B),B	;ADD THE EOF WORD TO THE POINTER
	MOV B,DIREND	;SAY IT IS THE END OF THE DIRECTORY
	MOV #DIR,ENTRYP	;POINT TO THE SELF ENTRY
	JSR PC,TYPEWD	;GET READY TO PUSH IT ONTO THE F STACK
	JSR PC,SKIPVN	;MAKE SURE THERE IS A DIRID
	ADD #10,E	;SKIP EOF AND DATE TIME
	JSR PC,SKPACC	;SKIP THE ACCES CODES
	JSR PC,SKPNAM	;SKIP THE NAME
	JSR PC,ATDESC	;ALL SET TO STACK
	MOV #DIR+14,A
	MOV #DIR+4,B	;KLUDGE FIRST DIRECTORY ENTRY
	MOV DDESCR,C
	ADD #DIR,C	;POINT TO THE FIRST OF DESCR.
CHECK1:	MOVB (A)+,(B)+	;COPY IT
	CMP A,C
	BLO CHECK1
	MOVB #200,(B)+
	MOVB #46,(B)+
	CLRB (B)+	;FAKE DESCRIPTOR
	CLRB (B)+
	BIC #1,B	;ROUND IT
	MOVB B,DIR	;FAKE LENGTH
	BIC #EOFB*400,DIR	;ELIMINATED THE EOF WORD
	JSR PC,TYPEWD
	JSR PC,SKIPVN
	JSR PC,SKPACC
	JSR PC,SKPNAM
	JSR PC,ATDESC
	JSR PC,PSHDIR	;SET UP BASE OF F-STACK
	MOV #-1,BLKLIM	;ALLOW ANY BLOCK #
	JSR PC,LOADIR	;GET WHOLE ROOT DIRECTORY
	MOV #BITSE,TOFIND
	JSR PC,FINDE	;FIND BITS FILE
	BEQ CKSYS1
	ERROR ^/NO BITS FILE/
CKSYS1:	MOV #FSTBLK,BLOKDO
	JSR PC,EDMARCH
	MOV DSKBUF,BLKLIM	;FIRST WORD OF FILE IS DISK LENGTH
	JSR PC,DESRF	;SET UP DESCRIPTOR FILE
	MOV #DIRIDE,TOFIND	;FIND THE DIRECTORY ID TABLE
	JSR PC,FINDE
	BEQ CKSYS2	;GO IT
	ERROR ^/NO DIRID FILE/
CKSYS2:	MOV #DIRBUF,DRIDND	;POINT TO THE START OF THE DIRID BUFFER
	RTS PC

DESRF:	MOV #DESCRE,TOFIND
	JSR PC,FINDE	;FIND DISK DESCRIPTOR FILE
	BEQ CKSYS4
	ERROR ^/NO DISK DESCRIPTOR/
CKSYS4:	JSR PC,L1BLKF	;LOAD 1-BLOCK FILE
	MOV B,DSCEOF	;L1BLKF RETURNS EOF ADDR IN B
	MOV #DSKBUF+2,E	;START AFTER THE BASE YEAR
	MOV #2,D	;2 SWAP AREAS
SRES1:	MOV (E)+,BLOKNO ;AREA STARTING AT BLOCK NO.
	MOV (E)+,C	;SO MANY BLOCKS
	BEQ SRES3	;NO BLOCKS
SRES2:	JSR PC,BTADR	;SET BIT FOR ONE BLOCK
	BISB A,DBITS2(B)
	INC BLOKNO
	SOB C,SRES2
SRES3:	SOB D,SRES1

SRES4:	CMP E,DSCEOF	;RESERVED BLOCKS WORDS TO END OF FILE
	BNE CKIT1	;EOF: BIT TABLE ALL SET!
	RTS PC
CKIT1:	BLO SRES5
	ERROR ^/DISK DESCRIPTOR EOF OUT OF SYNC?/
SRES5:	MOV (E)+,B	;WORD OFFSET IN BIT TABLE
	MOV (E)+,A	;MASK OF RESERVED BLOCKS
	BIS A,DBITS2(B)	;SET WHOLE WORD
	BR SRES4


CHECK:	MOV #DBITS1,A	;CLEAR BOTH BIT TABLES
	MOV #20000,B	;2*4K WORDS
	CLR (A)+
	SOB B,.-2
	JSR PC,CHECK2
	TYPEIT ^\CHECKING DISK \
	MOV #DIR,B
	JSR PC,NAMOUT
	JSR PC,CRLF
CKIT:	MOV #CKTAB1,DOWHAT	;CHECK THE WORLD PASS 1!
	JSR PC,DOROOT
	MOV #DBITS2,A	;GET ALL THE USED BLOCKS -> TABLE 1
	MOV #DBITS1,B
	MOV #10000,C	;EACH TABLE 4K WORDS LONG
	BIS (A)+,(B)+	;.OR. TABLE 2 INTO TABLE 1
	SOB C,.-2
	MOV #CKTAB2,DOWHAT	;CHECK FOR SHARED BLOCKS!
	JSR PC,DOROOT
			;FINALLY:
		;1:  COMPARE BIT TABLE 1 WITH DISK.
	MOV BLKLIM,A	;GET LENGTH OF BIT TABLE IN BYTES
	DEC A		;(JUST FOR DMARCHING)
	ASH #-3,A
	INC A		;FIRST BYTE AFTER BIT TABLE
	BIC #160000,A	;CLEAR SIGN EXTEND
	MOV A,BITLIM

	MOV #BITSE,TOFIND
	JSR PC,FINDE

	MOV #BITSRD,BLOKDO
	JSR PC,BITSIO	;READ IN THE BIT TABLE INTO TABLE 2

	CLR RANYBQ
	CLR C		;DO THE COMPARE: STOP WHEN BLOCK NO. = BLKLIM
	CLR RNG01F	;ASSERT NO 0->1 OR 1->0 (CLRS BOTH FLAGS)
	MOV #DBITS1,D
	MOV #DBITS2,E

BCOMP1:	MOV (D),A
	MOV (E),B
	BIC (E)+,A	;GET DBITS1 - 2: MARKING A "FREE" BLOCK
	BIC (D)+,B	;GET DBITS2 - 1: MARKED BUT NOT FOUND

	MOV #20,F
BCOMP2:	ASHC #-1,A	;RIGHT SHIFT ONE BOTH
	BCC .+10
	JSR PC,BAD10	;FOUND A 2-1 (1 -> 0)
	BR BCOMP4

	TST B
	BGE .+10
	JSR PC,BAD01	;FOUND A 1-2 (0 -> 1) BAD NEWS
	BR BCOMP4

	JSR PC,BCGOOD

BCOMP4:	INC C		;COUNT THE BLOCK
	CMP C,BLKLIM	;EXIT IF ALL BLOCKS DONE ON DISK
	BHIS BCOMP3
	SOB F,BCOMP2
	BR BCOMP1

BCOMP3:	JSR PC,BCGOOD
	TYPEIT ^/_DISK /
	MOV #FBASE+FENTRY,B
	JSR PC,NAMOUT
	TYPEIT ^/ REFRESHED_/
	TST RANYBQ	;CHANGED ANY BITS?
	BEQ CKSYSX
	TYPEIT ^/WRITE BIT TABLE?  /
	JSR PC,TYI1
	CMP #'Y,A
	BEQ .+6		;DO IT
NWRITE:	BPT		;NO GOOD
	BR .-2
WRITEB:	JSR PC,CRLF

		;2:  STORE TABLE 1 AS NEW BIT TABLE
	MOV #BITSWR,BLOKDO
	JSR PC,BITSIO	;WRITE OUT NEW BIT TABLE


	TYPEIT ^/WRITTEN_/

;HERE CAUSE A CHECK OF THE DIRID TABLE



CKSYSX:				;THE FOLLOWING CODE IS A KLUDGE
	TYPEIT ^/SCAN?/
	JSR PC,TYI1
	CMP #'Y,A
	BNE NOSCAN
.IFZ 105
;SCAN DISK A TRACK AT A TIME FOR BAD BLOCKS
	MOV WCHDSK,-(P)	;BLOCK TO START WITH
;THE TOP OF THE STACK IS ALWAYS THE FIRST BLOCK THAT MIGHT HAVE AN ERROR
TRKLOP:	MOV #1,RKCS	;RESET THE WORLD
	MOV (P),RKDA
	MOV #DSKBUF,RKBA
	MOV #-24.*256.,RKWC	;A WHOLE TRACK
	MOV #4405,RKCS	;READ, BUT DON'T INCREMENT ADDRESS
			;AND STOP ON SOFT ERROR
	TSTB RKCS
	BPL .-4		;WAIT FOR THE TRANSFER TO FINISH
	TST RKCS	;IS THERE ANY ERROR?
	BLT ERRLOP	;YES, CHECK IT OUT
	MOV RKDA,(P)
	BR TRKLOP
ERRLOP:	MOV #256.,C	;NUMBER OF TIMES TO DO THIS
	BIT #100,RKER	;IS IT THE END OF THE DISK?
	BNE NOSCN1	;YES, DONE
	PUSH (P)	;RECOPY THE DISK ADDRESS
ERLP2:	MOV #1,RKCS
	MOV #-256.,RKWC		
	MOV #4405,RKCS	;READ BUT DONT INC
	TSTB RKCS
	BPL .-4
	TST RKCS	;ERROR
	BGE ERLP1	;NO
	BIT #100,RKER	;END OF DISK?
	BNE NOSCN1	;YES
	TYPEIT ^/_SCAN ERROR RKDA=/
	MOV RKDA,B
	JSR PC,OCTOUT
	JSR PC,CRLF
	TYPEIT ^/RKER=/
	MOV RKER,B
	JSR PC,OCTOUT
	JSR PC,CRLF
ERLP1:	MOV RKDA,(P)	;GET NEW 
	SOB C,ERLP2
	TST (P)+
	JMP TRKLOP
NOSCN1:	ADD #4,P	;POP ARGS
.ENDC
	CLR -(P)
SCANLP:	CMP #313*12.,(P)
	BEQ SCANL1
	MOV (P),B
	JSR PC,DBFRED
	INC (P)
	BR SCANLP
SCANL1:	TST (P)+
NOSCAN:	JMP SALV2
;GIVEN A LAST-CHAR-FLAGGED STRING IN (A)+,
;FIND A FILE WITH THAT NAME.
FINDE:	MOV #DIR,ENTRYP
FINDE1:	JSR PC,FIND
	BEQ FOUNDE
FIND1:	RTS PC

FIND:	JSR PC,TYPEWD
	JSR PC,SKIPVN
	BIT #EOFB,FLAGS
	BEQ .+6
	ADD #10,E
	BIT #ACCB,FLAGS
	BEQ .+6
	JSR PC,SKPACC
	MOV TOFIND,C
	JSR PC,CMPNAM
	BEQ FIND1
	CMP NXNTRY,DIREND
	BEQ NFOUND
	BLO FINDE2
	ENTERR ^/ OVERSHOT DIRECTORY END/
	BPT
FINDE2:	MOV NXNTRY,ENTRYP
	BR FIND

FOUNDE:	JSR PC,ATDESC
	SEZ
	RTS PC

NFOUND:	CLZ
	RTS PC

FILLEN:	MOV #CNTBKN,BLOKDO
	CLR A
	CLR B
	JSR PC,EDMARCH
	MOV A,B
	RTS PC

CNTBKN:	INC A
	RTS PC




LENFIL:	MOV #CNTBLK,BLOKDO
	CLR A
	CLR NBLOKS
	JSR PC,EDMARCH
	MOV NBLOKS,B
	BNE .+4
	RTS PC		;LENGTH OF 0-BLOCK FILE IS 0
	MOV ENTRYP,A	;POINT TO ENTRY
	ADD #4,A	;POINT TO EOF WORD
	MOV (A)+,C	;GET THE PAGE NO.
	MOV (A)+,D	;GET THE BYTE COUNT
	ASH #3,D	;GET IT LINED UP
	ASHC #-13.,C	;GET THE NUMBER OF BLOCKS
	BIT #MFISTB,FLAGS	;BLOCK EXIST?
	BEQ .+4
	INC D
	CMP D,B		;THE SAME?
	BEQ LENFL2	;YES
	ENTERR ^/ BAD LENGTH FILE/
LENFL2:	RTS PC

CNTBLK:	INC NBLOKS	;COUNT A BLOCK
	RTS PC
	;DMARCH ROUTINE TO GET THE FIRST BLOCK OF A FILE
FSTBLK:	MOV #DSKBUF,B
	JSR PC,DSKRED
	ADD #6,P	;CROCK!!!
			;POP OUT OF FSTBLK, DOBLOK, @LOADX(B), DMARCH
	RTS PC		;BACK TO JSR PC,DMARCH


L1BLKF:	MOV #L1BLK,BLOKDO	;LOAD A ONE-BLOCK FILE
	JSR PC,EDMARCH
	MOV ENTRYP,D	;POINT TO THE ENTRY
	MOV 6(D),B	;GET THE EOF
	ADD #DSKBUF,B
	RTS PC		;B POINTS TO END OF FILE

L1BLK:	MOV #ER1BLK,BLOKDO
	MOV #DSKBUF,B
	JSR PC,DSKRED
	RTS PC

ER1BLK:	ERROR ^/DESCR FILE TOO LONG/
	BPT
	BR .-2
BITSIO:	JSR PC,EDMARCH	;CALLED BEFORE AND AFTER BCOMP
	CMP BITSAT,BITLIM	;TO I/O THE BIT TABLE
	BLO .+4
	RTS PC
	ERROR ^/BIT TABLE TOO SHORT/
	RTS PC


BITSRD:	MOV #DSKBUF,B	;READ IN FIRST BLOCK OF BIT TABLE
	JSR PC,DSKRED

	PUSH C
	MOV #777,C	;BLT 1000-1 WORDS
	MOV #DSKBUF+2,A	;SKIPPING BLKLIM WORD
	MOV #DBITS2,B
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	MOV #1776,BITSAT	;WE'VE READ IN THIS MANY BYTES
	MOV #BITSR2,BLOKDO	;NEXT BLOCK, DO THIS
	RTS PC

BITSR2:	CMP BITSAT,BITLIM	;READ IN NEXT BLOCK IF NOT OVERSHOT
	BLO BITSR3
	ERROR ^/BIT TABLE TOO LONG/

BITSR3:	MOV #DSKBUF,B
	JSR PC,DSKRED

	PUSH C
	MOV #1000,C	;BLT 1000 WORDS
	MOV #DSKBUF,A
	MOV #DBITS2,B
	ADD BITSAT,B	;TO CURRENT PLACE IN BIT TABLE 2
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	ADD #2000,BITSAT	;WE READ IN THIS MANY MORE BYTES
	RTS PC

BITSWR:	MOV BLKLIM,DSKBUF	;WRITE FIRST BLOCK OF BIT TABLE:
				;FIRST WORD IS # BLOCKS ON DISK
	PUSH C
	MOV #777,C
	MOV #DBITS1,A	;BLT TABLE 1 TO DSKBUF+2, 1000-1 WORDS
	MOV #DSKBUF+2,B
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	MOV #DSKBUF,B
	JSR PC,DSKWRT	;WRITE THE BLOCK

	MOV #1776,BITSAT	;THIS MANY BYTES TRANSFERED
	MOV #BITSW2,BLOKDO	;DO THIS TO NEXT BLOCK
	RTS PC

BITSW2:	CMP BITSAT,BITLIM	;WRITE NEXT BLOCK UNLESS OVERSHOT
	BLO BITSW3
	ERROR ^/BIT TABLE TOO LONG/

BITSW3:	PUSH C
	MOV #1000,C	;NOW BLT 1000 MORE WORDSG OUT
	MOV #DBITS1,A
	ADD BITSAT,A	;FROM WHERE YOU LEFT OFF
	MOV #DSKBUF,B
	MOV (A)+,(B)+
	SOB C,.-2
	POP C

	MOV #DSKBUF,B
	JSR PC,DSKWRT	;WRITE THE BLOCK

	ADD #2000,BITSAT	;YOU'VE DONE THIS MANY MORE BYTES NOW
	RTS PC
	;COMPLAIN ABOUT OLD BIT TABLE
BAD01:	JSR PC,CLOS10
	JSR PC,OPEN01
	RTS PC

BAD10:	JSR PC,CLOS01
	JSR PC,OPEN10
	RTS PC

BCGOOD:	JSR PC,CLOS01
	JSR PC,CLOS10
	RTS PC


OPEN01:	TSTB RNG01F	;IS THIS RANGE ALREADY OPEN?
	BNE OPN01B
	JSR PC,BBFOUN
	JSR PC,RNGEDG	;NO, TYPE ITS OPENING NUMBER
	INCB RNG01F	;ASSERT JUST OPENED
	RTS PC
OPN01B:	CMPB #2,RNG01F
	BGE .+6
	INCB RNG01F	;ASSERT LONG RANGE
	RTS PC		;(OR ALREADY LONG RANGE)

OPEN10:	TSTB RNG10F	;IS THIS RANGE OPEN?
	BNE OPN10B
	JSR PC,BBFOUN	;BAD BIT FOUND: SET RANYBQ ("ANY BADBIT?")
	JSR PC,TAB	;NO, GO TO 1->0 COLUMNL
	JSR PC,RNGEDG	;AND TYPE ITS OPENING NUMBER
	INCB RNG10F	;ASSERT NOW JUST OPENED
	RTS PC
OPN10B:	CMPB #2,RNG10F
	BGE .+6
	INCB RNG10F	;NEW LONG RANGE
	RTS PC

BBFOUN:	TST RANYBQ	;FIRST BAD BIT?
	BEQ .+4
	RTS PC		;NO
	TYPEIT ^/_0 -> 1  1 -> 0_/
	INC RANYBQ	;NO MORE FIRST BAD BITS.
	RTS PC

CLOS01:	DECB RNG01F	;IS THIS RANGE MORE THAN 1 LONG?
	BLE CLS01B	;NO, JUST CLEAR IT.
	TST RANYBQ
	BNE .+4
	BPT		;SHOULDN'T CLOSE IF NOT OPENED!!
	TYPEIT ^/  TO_/	;ELSE STATE IT'S A LONG RANGE
	DEC C
	JSR PC,RNGEDG	;AND IT ENDS 1 BEFORE HERE
	INC C
CLS01B:	CLRB RNG01F	;AND CLEAR IT
	RTS PC

CLOS10:	DECB RNG10F	;IS THIS RANGE MORE THAN JUST BEGUN?
	BLE CLS10B	;NO, JUST CLEAR ITL
	TST RANYBQ
	BNE .+4
	BPT		;NOT IF NOT OPENED!
	JSR PC,TAB	;ELSE (IN 1->0 COLUMN)
	TYPEIT ^/  TO_/	;STATE IT'S A LONG RANGE
	JSR PC,TAB
	DEC C
	JSR PC,RNGEDG	;AND IT ENDS 1 BEFORE HERE
	INC C
CLS10B:	CLRB RNG10F	;AND CLEAR IT
	RTS PC


TAB:	TYPEIT ^/        /	;6 SPACES + 2 FOR MARGIN
	RTS PC

RNGEDG:	PUSH A
	PUSH B
	MOV C,B		;TYPE OUT BLOCK NUMBER IN C
	JSR PC,OCTOUT	;(MAY BE DIDDLED)
	JSR PC,CRLF
	POP B
	POP A
	RTS PC
	.STITL CRUNCH A DIRECTORY
DOROOT:	JSR PC,DODIRA	;DO THE DIRECTORY AS USUAL
	MOV DOWHAT,A	;EXCEPT WHEN IT COROUTINES BACK
			;AFTER DOING THE HEADER,
	JSR PC,@BITS(A)	;ALSO SET/CHECK THE HEADER'S BLOCK BITS.
	JSR PC,@(P)+	;NOW RETURN TO DODIRA
	RTS PC		;AND WHEN IT RETURNS, YOU'RE ALL DONE.

DODIR:	JSR PC,DODIRA	;DO THE DIRECTORY
	JSR PC,@(P)+	;DOING NOTHING EXTRA AFTER THE HEADER
	RTS PC		;AND DONE

DODIRA:	JSR PC,LOADIR	;USES PUSHED ENTRY ON F-STACK,
			;SETS DIREND
	MOV #DIR,ENTRYP
	JSR PC,TYPEWD	;SETS E,TYPE,NBYTES,NXNTRY,FLAGS,DSCEND
	CMP #SELF,ETYPE	;HEADER ENTRY?
	BEQ DODIR1
	ENTERR ^/ FIRST BUT NOT SELF ENTRY, GIVING UP ON THIS DIR/	;UGH, GROSSLY CLOBBERED
	JMP DODONE
DODIR1:	MOV DOWHAT,A	
	JSR PC,@SELF(A)	;PROCESS THE HEADER
	JSR PC,@(P)+	;COROUTINE WITH NEXT LEVEL UP--
			;ASK TO DO AFTER THE HEADER.
DODIR2:	MOV NXNTRY,ENTRYP
	JSR PC,TYPEWD
	CMP #PARENT,ETYPE
	BEQ DODIR3
	ENTERR ^/ SECOND BUT NOT PARENT, GIVING UP ON THIS DIR/
	JMP DODONE
DODIR3:	MOV DOWHAT,A
	JSR PC,@PARENT(A)	;PROCESS PARENT HEATER

DOENTRY::	CMP NXNTRY,DIREND
	BNE .+6
	JMP DODONE	;HIT END OF DIRECTORY
	BLO DOENT3
	ENTERR ^/ OVERSHOT DIRECTORY END/
	BPT
	BR .-2

DOENT3:	MOV ENTRYP,OENTRY	;SAVE LAST ENTRY POINTER
	JSR PC,TYPEWD	;GET LAST ENTRY'S TYPE AND FLAGS AGAIN!
	MOV ETYPE,OTYPE	;SAVE THEM
	MOV FLAGS,OFLAGS

	MOV NXNTRY,ENTRYP	;NOW FOR NEXT ENTRY!!
	JSR PC,TYPEWD
	CMP #SELF,ETYPE
	BNE DOENT2	;CAN'T HAVE TWO HEADERS
	ENTERR ^/ IS 2ND SELF ENTRY/
	BR DODONE	;PRETEND END OF DIR
DOENT2:	CMP #PARENT,ETYPE
	BNE DOENT4
	ENTERR ^/ IS 2ND PARENT ENTRY/
	BR DODONE
DOENT4:	MOV DOWHAT,A	;CHECK ALPHABETICAL ORDER (ON PASS 1)
	JSR PC,@ALFORQ(A)	;ALWAYS SKIPS VERSION NUMBER,EOF,AND ACCESS CODES
	JSR PC,SKPACC
	MOV DOWHAT,A
	ADD ETYPE,A	;DISPATCH ON TYPE OF ENTRY
	JSR PC,@(A)	;PROCESS THIS ENTRY
	JMP DOENTRY

DODONE:	JSR PC,PUTDIR	;IF DIRECTORY MODIFIED, REWRITE IT.
	RTS PC
	.STITL PASS 1 CRUNCH-ENTRY ROUTINES
CKSELF:	BIT #EOFB,FLAGS
	BNE CKSLF3
	ERROR ^/NO EOF IN SELF ENTRY/
	RTS PC
CKSLF3:	MOV FBACKP,D
	MOV D,C
	ADD #FENTRY+4,C	;POINT TO THE DIRECTORY ENTRY
	JSR PC,SKIPVN
	ADD #10,E	;SKIP THE  EOF AND DATE
	JSR PC,CMPNAM	;NAMES THE SAME?
	BEQ CKSLF1	;YES
CKSLF2:	ERROR ^/SELF ENTRY DOESN'T DESCRIBE SELF/
	RTS PC
CKSLF1:	JSR PC,ATDESC
	MOV #3,D	;THE COUNT
CKSLF4:	CMPB (C)+,(E)+	;BETTER BE 3 BYTE DESR.
	BNE CKSLF2
	SOB D,CKSLF4	;CHECK THEM ALL
	RTS PC

CKPAR:	BIT #EOFB,FLAGS	;IS THERE A EOF
	BEQ CKPAR4	;NO,GOOD
	ERROR ^/PARENT HAS EOF BIT/
	RTS PC
CKPAR4:	BIT #ACCB,FLAGS	;ARE THERE ACCESS CODES
	BEQ CKPAR5
	ERROR ^/PARENT HAS ACCESS CODE/
	RTS PC
CKPAR5:	MOV FBACKP,D	;GET OWN DIRECTORY ENTRY (ON STACK)
	MOV (D),C	;GET THE 
	MOV C,D		;COPY IT
	ADD #FENTRY+4,C	;GET NAME FROM ENTRY
	JSR PC,SKIPVN	;SKIP THE VERSION NUMBER
CKPAR3:	JSR PC,CMPNAM	;(COMPARE NAMES IN (C)++ AND (E)++)
	BNE CKPAR2	;NOT THE SAME
	JSR PC,ATDESC	;SET DDESCR (=OFFSET), DBYTES FOR HEADER DESCR
			;(DESCRIBES PARENT)
	BVS CKPWIN
	CMPB (E),#200	;IS IT SET ADDRESS DESC.
	BEQ CKPAR6	;YES
	ERROR ^/BAD DESCRIPTOR IN PARENT/		
	RTS PC
CKPAR6:	MOV D,C
	ADD #FENTRY,C	;GO TO START OF ENTRY
	ADD FDDESC(D),C	;AND TO START OF DESCRIPTOR
	JSR PC,CMPDSR	;ARE THE DESCRIPTORS THE SAME
	BEQ CKPWIN	;SAME, WE ARE WINNERS
CKPAR2:	ERROR ^/PARENT ENTRY DOES NOT DESCRIBE PARENT/
CKPWIN:	RTS PC

SKPPNM:	JSR PC,SKIPVN
	BIT #EOFB,FLAGS
	BEQ .+6
	ADD #10,E
	JSR PC,SKPACC
	JSR PC,SKPNAM
	RTS PC

C2PAR:	JSR PC,SKIPVN
	JSR PC,SKPNAM
	JSR PC,ATDESC
	RTS PC

C2SELF:	JSR PC,SKIPVN
	ADD #10,E
	JSR PC,SKPACC
	JSR PC,SKPNAM
	JSR PC,ATDESC
	RTS PC

C2LINK:
CKLINK:	ENTERR ^/ IS A LINK; FEATURE NOT IMPLEMENTED/
	RTS PC

C2LAST:
CKLAST:	ENTERR ^/ IS A LAST, FEATURE FLUSHED/
	RTS PC


C2FILE:
CKFILE:	BIT #EOFB,FLAGS
	BNE CKFIL1
	ERROR ^/NO EOF IN FILE ENTRY/
CKFIL1:	JSR PC,ATDESC	;SET DDESCR AND DBYTES FOR DESCRIPTOR
	BVC .+4
	RTS PC		;GIVE UP IF ATDESC DOES
	JSR PC,LENFIL	;CHECK FOR REASONABLE LENGTH OF FILE
	MOV DOWHAT,A
	JSR PC,@BITS(A)	;SET BITS IN TABLE 1; IF SET, SET TABLE 2
	RTS PC		;ALL DONE!!

C2DIR:
CKDIR:	BIT #EOFB,FLAGS
	BEQ CKDIR1
	ERROR ^/EOF IN DIRECTORY ENTRY/
	RTS PC
CKDIR1:	BIT #ACCB,FLAGS
	BEQ CKDIR2
	ERROR ^/ACCESS CODES IN DIRECTORY ENTRY/
	RTS PC
CKDIR2:	MOV ENTRYP,A	;POINT TO ENTRY
	CMP #-1,2(A)	;IS IT A WINNER?
	BEQ FOO69
	MOV #-1,2(A)
	INC DIRCNG
FOO69:
	JSR PC,ATDESC	;DDESCR AND DBYTES
	BVC .+4
	RTS PC		;GIVE UP IF ATDESC DOES
	MOV DOWHAT,A
	JSR PC,@BITS(A)	;SET BITS
	JSR PC,PUTDIR	;REWRITE DIRECTORY IF MODIFIED
	JSR PC,PSHDIR	;PUSH THIS ENTRY ONTO THE F-STACK
	JSR PC,DODIR	;CRUNCH THE DIRECTORY
	JSR PC,POPDIR	;POP ENTRY
	JSR PC,LOADIR	;RELOAD CURRENT DIRECTORY
	RTS PC

	.STITL WALK-THROUGH-AN-ENTRY ROUTINES
TYPEWD:	;GIVEN AN ENTRYP, GETS TYPE, NBYTES, NXNTRY, FLAGS, AND DSCEND
	;AND SETS E POINTING TO THE VERSION NUMBER OR DIRID
	MOV ENTRYP,E
	MOVB (E)+,C	;SET UP THE NUMBER OF BYTES
	MOVB C,NBYTES	;SET IN NUMBER OF BYTES
	MOVB (E)+,A	;GET FLAGS BYTE
	MOV A,B		;COPY IT
	BIC #TYPEM,A	;GET JUST TYPE
	MOV A,ETYPE
	ADD ENTRYP,C	;POINT TO NEXT ENTRY
	CMP C,DIREND
	BLOS TYPEW2
	ENTERR ^/ OVERFLOWS DIRECTORY/
	MOV DIREND,C	;MAKE NXNTRY = DIREND
TYPEW2:	MOV C,DSCEND	;SET UP DESCRIPTOR END POINTER
	INC C
	BIC #1,C	;ROUND IT UP
	MOV C,NXNTRY
	MOV B,FLAGS
	RTS PC

SKPNAM:	JSR PC,EBYTE	;GET BYTE OF ENTRY
	BVS NAMERR	;COMPLAIN ON ENTRY OVERFLOW
	TSTB A		;IS THE CHAR FLAGGED?
	BGE SKPNAM	;SKIP TO NEGATIVE BYTE (LAST OF NAME)
	RTS PC


CMPDSR:	MOV #3,B	;THE NUMBER OF BYTES
CMPDS1:	JSR PC,EBYTE
	BVS CMPDS2	;NO BYTE
	CMPB (C)+,A	;IS IT THE SAME
	BNE CMPDS2	;NO
	SOB B,CMPDS1
	SEZ
	RTS PC
CMPDS2:	CLZ
	RTS PC

CMPNAM:	JSR PC,EBYTE
	BVS NAMERR
	CMPB (C)+,A
	BNE CMPNMF	;MISMATCH
	TSTB A
	BGE CMPNAM	;200 BIT ENDED BOTH NAMES
	SEZ
	RTS PC		;RETURN WITH Z-BIT SET
CMPNMF:	TSTB A
	BLT .+6
	JSR PC,SKPNAM
	CLZ
	RTS PC
NAMERR:	ENTERR ^/: NAME OVERFLOWS ENTRY/
	CLZ
	RTS PC

ALFCMP:	JSR PC,EBYTE	;GET BYTE OF FIRST NAME
	TSTB (C)	;HAS THE SECOND ENDED
	BLT ALFCM1	;YES
	CMPB (C)+,A	;ARE THE BYTES THE SAME
	BEQ ALFCMP	;NO
	PUSH A
	BLT .+6
	JSR PC,SKPNAM
	POP A		;HAS FIRST ENDED
	BMI ALFCM2	;YES
	CMPB -(C),A	;COMPARE THEM
	RTS PC
ALFCM2:	BIC #177600,A	;GET THE CHARACTER
	CMPB -(C),A	;CMP THEM
	RTS PC
ALFCM1:	PUSH A		;SAVE IT
	BLT .+6		;YES
	JSR PC,SKPNAM	;SKIP THE REST OF THE NAME
	CMPB (C),(P)+	;ARE THEY THE SAME
	RTS PC


SKIPVN:	JSR PC,EBYTE
	BVS SKPVNE
	JSR PC,EBYTE
	BVC SKPVN1
SKPVNE:	ENTERR ^/: VN OVERFLOWS ENTRY/
SKPVN1:	RTS PC

SKPACC:	BIT #ACCB,FLAGS	;ACCESS SHOULD NOT APPEAR AT FIRST
	BNE .+4
	RTS PC
SKPAC2:	JSR PC,EBYTE	;GOOD ACCESS CODES COME IN THREES
	BVS SKPACE
	JSR PC,EBYTE
	BVS SKPACE
	JSR PC,EBYTE
	BVS SKPACE
	TSTB A	;NEG. THIRD BYTE IS LAST TRIPLET
	BGE SKPAC2
	RTS PC
SKPACE:	ENTERR ^/: ACCESS OVERFLOWS ENTRY/
	RTS PC

ATDESC:	MOV E,DDESCR
	SUB ENTRYP,DDESCR	;GET OFFSET OF DESCRIPTOR IN ENTRY
	MOV DSCEND,DBYTES
	SUB E,DBYTES	;AND LENGTH OF DESCRIPTOR
	BLT .+4
	RTS PC
	ENTERR ^/: NO ROOM FOR DESCRIPTOR/
	SEV
	RTS PC

EBYTE:	MOVB (E)+,A	;GET A BYTE OF ENTRY
	CMP DSCEND,E	;COMPLAIN ON OVERFLOW
	BHIS .+4
	SEV
	RTS PC
	;THIS ENTRY MUST FOLLOW THE LAST IN ALPHABETICAL ORDER


ALFSR1:	POP C
	MOV NXNTRY,ENTRYP
ALFSRT:	CMP ENTRYP,DIREND
	BEQ ALFSR2
	JSR PC,TYPEWD
	MOV ENTRYP,OENTRYP
	PUSH C
	JSR PC,ALFCMP
	BGT ALFSR1
	POP C
ALFSR2:	RTS PC



ALFORD:	JSR PC,SKIPVN
	BIT #EOFB,FLAGS
	BEQ .+6
	ADD #10,E	;POINT AFTER EOF WORD
	JSR PC,SKPACC	;SKIP ACCESS CODES
	CMP #SELF,OTYPE ;DON'T COMPARE IF LAST ENTRY WAS HEADER
	BNE ALFOR5	;OTHERWISE DO COMPARE
ALFRET:	JSR PC,SKPNAM	;SKIP THE NAME
	RTS PC
ALFOR5:	CMP #PARENT,OTYPE	;DONT COMPARE IF LAST WAS PARENT
	BEQ ALFRET
ALFOR1:	MOV OENTRY,C	;LAST NAME TO THE STARTING LINE
	TST (C)+	;(SKIP TYPE AND FLAGS)
	MOV (C)+,OVN	;GET OLD VERSION NUMBER
	CMP OTYPE,#DIREC	;IS IT A DIRECTORY?
	BNE .+10		;NO , THEN GOOD VERSION NUMBER
	MOV #-1,OVN	;NO REAL VERSION NUMBER, JUST DIRID
	BIT #EOFB,OFLAGS	;EOF?
	BEQ .+6
	ADD #10,C	;SKIP THEM
	BIT #ACCB,OFLAGS	;ARE THERE ACCESS CODES
	BEQ ALFOR2	;NO
ALFOR3:	ADD #2,C	;SKIP FIRST WORD	
	TSTB (C)+	;IS THIS THE LAST
	BMI ALFOR3	;NO
ALFOR2:	JSR PC,ALFCMP	;WHICH IS BIGGER
	BEQ ALFOR4	;THE SAME, CHECK THE VERSION NUMBERS	
	BGT .+4		;THE OLD ENTRY WAS BIGGER!!!!!!
	RTS PC
ALFOR6:	ERROR ^/ENTRY OUT OF ORDER/
	RTS PC
ALFOR4:	MOV ENTRYP,A	;POINT TO THE START OF THIS ENTRY
	TST (A)+	;SKIP HEADER
	MOV (A)+,VN	;GET THE VERSION NUMBER
	CMP ETYPE,#DIREC	;IS IT A DIRECTORY
	BEQ ALFOR6	;IF IT IS, THEN THE VERSION # IS -1, AND AT LEASE EQUAL TO
			;PREVIOUS ONE
	CMP OVN,VN
	BGE ALFOR6	;OLD >= NEW NO GOOD
	RTS PC

	.STITL PUSH AND POP DIRECTORY STACK
PSHDIR:	MOV NEXTF,F	;GET NEXT SLOT
	MOV FBACKP,(F)	;SAVE BACK POINTER FROM HERE
	MOV F,FBACKP	;AND BACK POINTER TO HERE
	TST (F)+
	FPUSH ENTRYP	;FOR ALPHABETIZING
	FPUSH NXNTRY	;WHEN DONE WITH THIS DIRECTORY ENTRY
	FPUSH DDESCR	;OFFSET OF DESCRIPTOR IN SAVED ENTRY
	FPUSH DBYTES	;LENGTH OF DESCRIPTOR
	MOV ENTRYP,E
	MOV NBYTES,A
	INC A
	ROR A		;PUSH ENTRY BY WORDS
PSHDR2:	FPUSH (E)+	;NEXT WORD OF ENTRY
	SOB A,PSHDR2
	CMP F,#FEND-100
	BHIS .+10
	MOV F,NEXTF	;NEXT SLOT IS AFTER THE ENTRY
	RTS PC
	ERROR ^/OVERPUSH/
	BPT
	RTS PC

POPDIR:	CMP #FBASE,FBACKP
	BLO POPDR2
	BUG ^/OVERPOP?/
POPDR2:	MOV FBACKP,F	;ENTRY IS POPPED
	MOV F,NEXTF	;FREE POPPED SLOT
	MOV (F),FBACKP	;STEAL BACK POINTER OUT OF POPPED ENTRY
	CMP F,ERNTRYP	;POPPED BACK TO ERRORSTUMP?
	BHI POPDR4	;ERRORSTUMP STILL BELOW YOU
	BEQ POPDR3	;SAW OFF ERRORLIMB AS YOU CLIMB BACK.
	BUG ^/ERRORLIMB LEFT HANGING??/
POPDR3:	MOV FBACKP,ERNTRYP	;MOVE IT DOWN THE STACK
POPDR4:	MOV FENTRP(F),ENTRYP	;GET OLD ENTRYP FOR ALPHABETICALS
	MOV FNXNTRY(F),NXNTRY	;AND NEXT ENTRYP
	RTS PC		;I THINK ALL THE REST PUSHED HAS BEEN USED.
	.STITL DISK-BLOCK FUNNIES (LOAD/REWRITE, SET/CHECK BIT TABLE)
;ALWAYS DO LOADIR, PUTDIR IN MATCHED PAIRS:
;LOADIR (DODIR)
;PUTDIR  (CKDIR.1)
; LOADIR (DODIR)
; PUTDIR (DODONE)
;LOADIR  (CKDIR.2)
;PUTDIR (DODONE)
;ETC.
;NOT NESTED PAIRS.  PUT THE DIR WHENEVER YOU'RE ABOUT TO LOAD ANOTHER
;AS AT CKDIR AND DODONE.
;THIS MAKES DIRCNG ACT PROPERLY AT PUTDIR.

PUTDIR:	TST DIRCNG	;REWRITE DIRECTORY IF MODIFIED
	BNE .+4
	RTS PC

	TYPEIT ^/REWRITING DIR /
	PUSH A
	JSR PC,BACKTR
	JSR PC,CRLF
	POP A

	MOV #DIRBLW,BLOKDO	;REWRITE DIRECTORY
	JSR PC,IODIR
	CLR DIREND
	RTS PC

LOADIR:	CLR DIRCNG	;USED IN NEXT PUTDIR
	MOV #DIRBLR,BLOKDO	;LOAD A DIRECTORY
	JSR PC,IODIR
	MOV DIR+6,B
	ADD #DIR,B
	MOV B,DIREND
	RTS PC

IODIR:				;FOR EACH BLOCK, LOAD OR PUT IT.
	MOV FBACKP,E	;GET DESCRIPTOR FROM PUSHED ENTRY
	MOV E,D		;SETUP DESCRIPTOR
	ADD #FENTRY,D
	ADD FDDESC(E),D
	MOV FDBYTES(E),E
	JSR PC,DMARCH	;CRUNCH DESCRIPTOR!!
	MOV FBACKP,E
	RTS PC


SETB12:	;SET BITS IN BIT TABLE 1;
	;IF ONE ALREADY SET, SET IT IN BIT TABLE 2.
	MOV #BTS12,BLOKDO	;DO THIS FOR EACH BLOCK
	JSR PC,EDMARCH
	RTS PC

CKBIT2:	;CHECK BIT TABLE 2; IF ONE SET, RETURN NOT-EQUAL
	MOV #BTT2,BLOKDO	;FOR EACH BLOCK
	CLR BITFND	;IF ZERO ON RETURN, FILE OK.
	JSR PC,EDMARCH
	MOV ENTRYP,A
	INC A		;SET UP TO MUNG REAL FLAG BYTE
	TST BITFND
	BNE CKBIT3
	BITB #SHRB,(A)	;NO SHARED BLOCKS: CAREFUL-CLEAR NODELF
	BNE .+4
	RTS PC		;ALREADY CLEAR, DONE
	BICB #SHRB,(A)	;ELSE CLEAR IT AND SAY DIR. MODIFIED
	INC DIRCNG
	TYPEIT ^/ENTRY /
	MOV ENTRYP,B
	JSR PC,NAMOUT
	TYPEIT ^/ NO LONGER SHARES BLOCKS, IS DELETABLE_/
	RTS PC
CKBIT3:	BITB #SHRB,(A)  ;SHARED BLOCKS: SET DON'T DELETE THEM FLAG
	BEQ .+4
	RTS PC		;ALREADY SET
	BISB #SHRB,(A)
	INC DIRCNG	;DIRECTORY CHANGED
	RTS PC
EDMARCH: MOV ENTRYP,D
	ADD DDESCR,D
	MOV DBYTES,E
	JSR PC,DMARCH	;DMARCH THIS ENTRY
	RTS PC

;DMARCH NEEDS (WHAT TO DO WITH EACH BLOCK) IN BLOKDO,
;	(ADDR OF DISK BLOCKS DESCRIPTOR) IN D,
;	AND (# BYTES OF DESCR) IN E.
DMARCH:	CLR BLOKNO
	TST E		;ANY DESCRIPTOR?
	BNE DNEXT	;YES
	RTS PC
DNEXT:	MOVB (D)+,C	;BYTE OF DESCRIPTOR
	MOV C,B
	BIC #-DTYPEF-1,B
	ASH #-5,B
	JSR PC,@LOADX(B)	;CRUNCH DESCR BYTE
	SOB E,DNEXT
	RTS PC

;LOADX DISPATCHES TO THESE 4 ROUTINES
LODSKP:	BIC #-DTCNTF-1,C	;GET COUNT FIELD FOR SKIP
	BNE .+4		;"SKIP 0" = .BYTE 0; NO-OP, SPECIAL CASE.
	RTS PC
	ADD C,BLOKNO	;SKIP N BLOCKS
	JSR PC,DOBLOK	;CRUNCH ONE BLOCK
	RTS PC

LODCNT:	BIC #-DTCNTF-1,C	;GET COUNT FIELD
	INC C		;GET N+1 BLOCKS
	CMP C,#40	;IS IT MORE THAN 32 BLOCKS?
	BLE LODCT2	;NO, IS JUST GRAB DESCR.
	SUB #40,C	;IS A HOLE TYPE, GET THE NUMBER OF BLOCKS IN HOLE
	ADD C,NBLOKS	;INCREMENT COUNT OF BLOCKS
	RTS PC		;RETURN, NOTHING TO DO
LODCT2:	JSR PC,DOBLOK	;CRUNCH ONE BLOCK AFTER ANOTHER
	SOB C,LODCT2	;UNTIL N+1
	RTS PC

LODSAD:	CMP #3,E	;THREE BYTES LEFT?
	BGT LSADER	;NO, COMPLAIN
	MOVB (D)+,BLOKNO	;FROM NEXT TWO BYTES,
	MOVB (D)+,BLOKNO+1	;SET UP BLOCK NUMBER
	SUB #2,E
	BIC #-DTCNTF-1,C	;GET THE NUMBERS
	INC C
	BR LODCT2	;AND CRUNCH N+1 BLOCKS (N IN FIRST BYTE)
LSADER:	ENTERR ^/(?): NO ROOM FOR DESC. SET-ADDR/
	RTS PC

LODSC:	MOV C,B
	BIC #-DTSCSK-1,B
	ASH #-3,B	;SKIP N1 BLOCKS
	ADD B,BLOKNO
	BIC #-DTSCCT-1,C	;AND CRUNCH ONLY N2+1 BLOCKS
	BR LODCNT

DOBLOK:	CMP BLOKNO,BLKLIM	;IS IT ON THE DISK?
	BHIS DOBLER
	JSR PC,@BLOKDO
	INC BLOKNO
	RTS PC

DOBLER:	JSR PC,ERRORX
	TYPEIT ^/ERROR--BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ NOT ON DISK; /
	JSR PC,ENTOUT
	JSR PC,@(P)+
	RTS PC

ENTOUT:	TYPEIT ^/ENTRY = /
	MOV ENTRYP,B
	JSR PC,NAMOUT
	RTS PC
RFBLK:	CMP #DISKWC,DISKIO
	BEQ RFBLK1
	MOV TRNSLE,DSKWC	;THE TRANSFER LENGTH
	MOV B,DSKCA	;THE BUSS ADRESS
	CLR A
	MOV BLOKNO,B
	ASHC #9.,A	;GET THE EXTENSION BITS
	MOV B,DSKA	;THE DISK ADRESS
	MOV A,DSKAE	;THE EXTENSION BITS
	MOV DISKIO,DSKS	;THE FUNCTION
	TSTB DSKS
	BGE .-4
RFBLK1:	POP B
	POP A
	TST DSKS
	BLT DBERR
	RTS PC


DBLERR:	ERROR ^/DIRECTORY TOO LONG/
	RTS PC
DIRBLR:	MOV #DBLERR,BLOKDO	;DIR'S ARE ONE BLOCK
	MOV #DIR,B
DSKRED:	MOV #DISKRD,DISKIO
DSKBLK:	MOV #NRETRY,RETRYS
DSKBL1:	MOV BLOKNO,SWB
	PUSH A
	PUSH B
	TST WCHDSK	;IS IT A RK11 DISK
	BMI RFBLK	;NOPE
	MOV TRNSLE,RKWC	;TRANSFER LENGTH
	MOV B,RKBA	;CORE ADDR
	MOV BLOKNO,B	;GET DISK ADDR
	ASL B		;DOUBLE IT:  2 SECTORS/BLOCK
	CLR A
	DIV #12.,A	;12 SECTORS/TRACK-SURFACE
	ASH #4,A
	ADD A,B		;ALL DONE FOR FIXED PLATTER
	ADD WCHDSK,B
	MOV B,RKDA	;DISK ADDR
	MOV DISKIO,RKCS	;START TRANSFER
	TSTB RKCS
	BGE .-4		;WAIT
	POP B
	POP A
	TST RKCS
	BLT DBERR
	RTS PC

DBERR:	DEC RETRYS
	BGT DSKBL1
DBERR2:	SUB #2,P	;CREATE A CELL
	PUSH A
	PUSH B
	TYPEIT ^/DISK /
	MOV WCHDSK,B
	ASH #-13.,B
	BIC #177770,B
	JSR PC,OCTOUT
	TYPEIT ^/ ERROR ACCESSING BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TST WCHDSK
	BMI DBERR3
	TYPEIT ^/_RKER = /
	MOV RKER,B
DBERR4:	MOV #1,RKCS	;POWER CLEAR THE DISK
	JSR PC,OCTOUT
	JSR PC,CRLF
	TYPEIT ^/(I)GNORE, (T)RY AGAIN OR (R)EWRITE_?/
	JSR PC,TYI1	;GET A CHAR
	MOV A,4(P)	;THE CELL CREATED ABOVE
	POP B
	POP A
	CMP #'I,(P)
	BNE .+6
	MOV #RTSPC,(P)
	CMP #'T,(P)
	BNE .+6
	MOV #DBERR5,(P)
	CMP #'R,(P)
	BNE .+6
	MOV #DSKWRT,(P)
	BITB #177,1(P)
	BEQ .+4
	JMP @(P)+
	BPT
	BR .-2


DBERR5:	CMP #DISKWC,DISKIO
	BEQ .+6
	JMP DSKBLK
	MOV #DISKWR,DISKIO
	JSR PC,DSKBLK
	MOV #DISKWC,DISKIO
	JMP DSKBLK


DBERR3:	SUB #2,P	;CREATE A WORK CELL
	PUSH A
	PUSH B
	TYPEIT ^/_DAE=/
	MOV DSKAE,B
	JSR PC,OCTOUT
	JSR PC,CRLF
	TYPEIT ^/DCS=/
	MOV DSKS,B
	BR DBERR4


DIRBLW:	MOV #DBLERR,BLOKDO
	MOV #DIR,B
DSKWRT:	PUSH A
	PUSH B
	TYPEIT ^/WRITING BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	JSR PC,CRLF
	POP B
	POP A
	MOV #3,RETRYV
DSKWR1:	MOV #DISKWR,DISKIO
	JSR PC,DSKBLK
	MOV #DISKWC,DISKIO
	JSR PC,DSKBLK
	BVS .+4
	RTS PC
	DEC RETRYV
	BGT DSKWR1
	JMP DBERR2

DBFRED:	PUSH BLOKNO
	MOV B,BLOKNO
	MOV #DSKBUF,B
	JSR PC,DSKRED
	POP BLOKNO
	RTS PC

DBFWRT:	PUSH BLOKNO
	MOV B,BLOKNO
	MOV #DSKBUF,B
	JSR PC,DSKWRT
	POP BLOKNO
	RTS PC

	.STITL COPY DISK IN FILE FORMAT

NDSKWR:	MOV #DSKBUF,B	;BLOCK TO WRITE IS IN DSKBUF
NDKWR1:	PUSH BLOKNO	;SAVE OLD BLOKNO
	PUSH WCHDSK	;SAVE OLD DISK
	MOV NDISK,WCHDSK	;MOV DISK TO WRITE ON TO WCHDSK
	MOV A,BLOKNO	;MOVE BLOCK TO WRITE ON INTO BLOKNO
	JSR PC,DSKWR1	;DO THE WRITE
	POP WCHDSK	;RESTORE OLD DISK
	POP BLOKNO	;RESOTORE ALD BLOCK NO
	RTS PC

NDSKRD:	MOV #DSKBUF,B	;BLOCK IS READ INTO DSKBUF
NDKRD1:	PUSH BLOKNO	;SAVE OLD BLOCK NO.
	PUSH WCHDSK	;SAVE OLD DISK
	MOV NDISK,WCHDSK	;NDISK IS THE DISK TO READ FROM
	MOV A,BLOKNO	;A CONTAINS BLOCK NO. TO BE READ
	JSR PC,DSKRED	;READ THE BLOCK
	POP WCHDSK	;RESTORE THE WORLD
	POP BLOKNO
	RTS PC

BREAD:	JSR PC,DBFRED	;THIS IS WHERE TO $G IN RUG;
	BPT 		;SET B TO BLOKNO FIRST.

BWRITE:	JSR PC,DBFWRT	;(SIM)
	BPT
BTADR:	MOV BLOKNO,B	;BLOKNO -> BIT TABLE BYTE OFFSET, BIT IN BYTE
BTADR1:	PUSH B
	BIC #177770,B
	MOV #1,A
	ASH B,A		;BIT IN BYTE
	POP B
	ASH #-3,B
	BIC #160000,B	;BYTE OFFSET
	RTS PC

BTSET1:	JSR PC,BTADR
	BISB A,DBITS1(B)
	RTS PC


BTSTST:	PUSH B
	JSR PC,BTADR1
	BITB A,DBITS1(B)
	BEQ BTST1
	POP B
	CLZ
	RTS PC
BTST1:	POP B
	SEZ
	RTS PC


BTSET:	PUSH B
	JSR PC,BTADR1
	BISB A,DBITS1(B)
	POP B
	RTS PC


BTS12:	;BIT TABLE SET
	JSR PC,BTADR
	BITB A,DBITS1(B)  ;1 CLEAR?
	BEQ BTS0.
	BISB A,DBITS2(B)  ;NO,SET 2
	RTS PC		;DONE
BTS0.:	BITB A,DBITS2(B)  ;1 CLEAR: 2 SET?
	BNE BTS01
	BISB A,DBITS1(B)  ;NO, JUST SET 1
	RTS PC
BTS01:	JSR PC,ERRORX	;1 CLEAR, 2 SET: RESERVED BLOCK
	TYPEIT ^/ERROR--BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ RESERVED; /
	JSR PC,ENTOUT
	JSR PC,@(P)+
	RTS PC

BTT2:	;BIT TABLE 2 TEST
	JSR PC,BTADR
	BITB A,DBITS2(B)  ;2 SET?
	BNE .+4
	RTS PC		;NO, GOOD
	JSR PC,ERRORX	;FILE HAS SHARED BLOCK.
	TYPEIT ^/ERROR--BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ SHARED; /
	JSR PC,ENTOUT
	JSR PC,@(P)+
	INC BITFND
	RTS PC
	.STITL ERROR ROUTINES
ERRORX:	PUSH A
	JSR PC,ERFROM	;TYPE ADDRESS OF ERROR CALL
	POP A
	JSR PC,@(P)+	;CALL BACK TO TYPE ERROR MESSAGE
	PUSH A
	JSR PC,CRLF
	JSR PC,BACKTR	;PRINT BACK TRACE OF DIRECTORY TREE
	.IFZ 1
	TYPEIT ^/_GO ON?  /
	JSR PC,TYI1
	CMP #15,A
	BEQ ERRX1
	CMP #'Y,A
	BNE ERRX2
	.ENDC
	JSR PC,CRLF
ERRX1:	POP A
	RTS PC
ERRX2:	BPT
	JMP SALV

TXTYPE:	PUSH A
TXTYP2:	MOVB (F)+,A	;TYPE MESSAGE
	BEQ TXTYP3
	CMP #'_,A
	BNE .+6
	MOV #15,A	;PRINT CRLF FOR _
	JSR PC,TYPE
	BR TXTYP2
TXTYP3:	INC F		;RETURN-ADDR IS TO AFTER STRING
	BIC #1,F
	POP A
	RTS F


BACKTR:	TYPEIT ^/IN DIR /
	CMP #FBASE,NEXTF
	BNE BKTR0
	TYPEIT ^/(NIL)/
	RTS PC		;NO BACKTRACE
BKTR0:	PUSH B
	MOV #FBACKP,BKFBKP  
BKTR1:	MOV @BKFBKP,B	;CLIMB DOWN TREE TO A BRANCH YOU'VE SEEN BEFORE
	MOV B,BKFBKP
	ADD #FENTRY,B
	JSR PC,NAMOUT	;TYPE DIRECTORY NAME
	CMP BKFBKP,ERNTRYP	;FOUND OLD ERRORSTUMP?
	BEQ BKTR2
	MOV #'<,A	;NO, KEEP GOING
	JSR PC,TYPE
	BR BKTR1
BKTR2:	MOV FBACKP,ERNTRYP	;YES, DONE; MAKE THIS THE ERRORTWIG.
	POP B	  ;;;WHEN POPDIR POPS THE ERRORLIMB IT SAWS IT OFF.
	RTS PC


ERFROM:	PUSH B
	MOV 6(P),B	;GET ERROR RETURN ADDRESS:  A PUSH A,
			;ANOTHER JSR AND A PUSH B ARE ON TOP OF IT NOW
	SUB #4,B	;GET REAL JSR PC,ERRORX ADDR.
	JSR PC,OCTOUT
	MOV #' ,A
	JSR PC,TYPE
	POP B
	RTS PC

OCTOUT:	PUSH C
	MOV #6,C
	CLR A
	ASHC #1,A	;FIRST DIGIT IS TOP BIT
OCOLUP:	ADD #'0,A
	JSR PC,TYPE
	CLR A
	ASHC #3,A
	SOB C,OCOLUP	;PRINT 6 DIGITS
	POP C
	RTS PC


DECOUT:	PUSH C
	CLR C		;0 DIGITS SO FAR
	TST B
	BEQ DECOT0	;TYPE 0
DECOT1:	INC C		;NEXT DIGIT:
	CLR A
	DIV #10.,A
	PUSH B		;PUSH REMAINDER
	MOV A,B		;# 10'S TO B
	BNE DECOT1	;UNTIL NO 10'S
DECOT2:	POP A		;POP A REMAINDER
	ADD #'0,A	;ENCODE IT
	JSR PC,TYPE
	SOB C,DECOT2	;TYPE ALL THE REMAINDERS
	POP C
	RTS PC

DECOT0:	MOV #'0,A	;TYPE '0
	JSR PC,TYPE
	POP C
	RTS PC


NAMOUT:	PUSH C
	PUSH (B)+	;SAVE FLAGS WORD
	MOV #16.,C	;CURTAIL AFTER 16 LETTERS
	PUSH (B)+
	BITB #EOFB,3(P)
	BEQ .+6
	ADD #10,B
	BITB #ACCB,3(P)
	BEQ NAMOU2
NAMOU6:	ADD #2,B
	TSTB (B)+
	BMI NAMOU6
NAMOU2:	MOVB (B)+,A
	JSR PC,TYPE
	TSTB A
	BLT NAMOU3
	SOB C,NAMOU2
	TYPEIT ^/.../	;NAME CURTAILED
	BR NAMOU4	;DON'T LOOK FOR VN

NAMOU3:	BIT #4*400,2(P)	;HAVE WE A VERSION NO. TO PRINT?
	BEQ NAMOU4
	TST (P)		;IS IT A VALID ONE?
	BLE NAMOU4	;NO
	TYPEIT ^/ #/	;YES
	POP B
	JSR PC,DECOUT	;(TYPE NUMBER)
	BR NAMOU5

NAMOU4:	POP C
NAMOU5:	POP C
	POP C
	RTS PC
	.STITL INITIALIZE THE DISK
ROTMID:	.BYTE ENDP-ROTMID,DIREC+1	;RUG'S POINT DIRECTORY
	2
	FLTEXT ^/./
	.BYTE 200,45,0
ENDP==.
	.EVEN
BITBEG==.
	.BYTE BITEND-BITBEG,FILE+200	;BITS FILE IS IN WHOLE BLOCKS
	.WORD -1,0,2000,-1,-1
	FLTEXT ^/BITS/
	.BYTE DTSKP+47
BITEND==.
	.EVEN

DESBEG==.
	.BYTE DESEND-DESBEG,FILE+201	;DISK DESCRIPTOR FILE
	.WORD -1,0
DESLEN:	0				;LENGTH OF DESCRIPTOR PUT HERE
	.WORD -1,-1
	FLTEXT ^/DESCR/
	.BYTE DTSKP+50
DESEND==.
	.EVEN
DRBEG==.
	.BYTE DREND-DRBEG,FILE+201	;DIRID FILE
	.WORD -1,0,6,-1,-1
	FLTEXT ^/DIRID/
	.BYTE DTSKP+44
DREND==.
	.EVEN
ROTEND:

RUGBEG:
	.BYTE RUGND-RUGBEG,SELF+201
	.WORD 2,0,0,-1,-1
	FLTEXT ^/./
	.BYTE 200,45,0
RUGND==.
	.EVEN
RUGEND::
COPY:	TYPEIT ^/_MASS COPY FROM:	/
	JSR PC,DECIN
	BNE .+6
COPY1:	JMP SALVQ
	CMP B,#3
	BHI COPY1
	ASH #13.,B
	MOV B,WCHDSK
	TYPEIT ^/TO:	/
	JSR PC,DECIN
	BEQ COPY1
	CMP B,#3
	BHI COPY1
	ASH #13.,B
	MOV B,NDISK
	JSR PC,BACKUP
SLV2:	JMP SALV2

CNTLU:	TYPEIT <DOUBLE DENSITY MASS COPY UP?>
	CLR WCHDSK
	MOV #40000,NDISK
DDMCPY:	JSR PC,TYI1
	CMP #'Y,A
	BNE SLV2
	JSR PC,BACKUP
	ADD #20000,WCHDSK
	ADD #20000,NDISK
	JSR PC,BACKUP
	JMP SALV2

CNTLD:	TYPEIT <DOUBLE DENSITY MASS COPY DOWN?>
	CLR NDISK
	MOV #40000,WCHDSK
	BR DDMCPY
BACKUP:	MOV #-14000,TRNSLE	;LENGTH OF A CYLINDER
	MOV #203.,E	;NUMBER OF CYLINDERS ON A DISK
	CLR BLOKNO	;START AT BLOCK 0
BCKUP1:	MOV #DSKBUF,B	;WHERE TO PUT DATA
	JSR PC,DSKRED	;READ A CYLINDER
	MOV BLOKNO,A	;WHERE TO PUT IT
	JSR PC,NDSKWR	;WRITE IT ON THE OTHER DISK
	ADD #12.,BLOKNO	;GET THE NEXT CYLINDER
	SOB E,BCKUP1	;DO IT FOR ALL THE CYLINDERS
	MOV #-1000,TRNSLE	;RESTORE THE BLOCK LENGTH
	RTS PC
FMTER:	TYPEIT <ERROR TRYING TO FORMAT DISK>
	JMP SALV2

FFCMPE:	TYPEIT <FF COMPARE ERRORî>
	INC A
	CMP #10.,A
	BLT .+4
	RTS PC
	TYPEIT <I GIVE UPî>
	JMP SALVQ

FRMT:	JSR PC,FORMAT
	JMP SALV2


FORMAT:	TYPEIT <FORMAT?>
	JSR PC,TYI1
	CMP #'Y,A
	BNE NOFMT
	CLR B
	MOV #313*2,D
FFLP1:	MOV #12.,C
FFLP2:	MOV B,DSKBUF
	MOV #77776,DSKBUF+2
	MOV WCHDSK,RKDA
	BIS B,RKDA
	MOV #-2,RKWC	;LARGE NEGATIVE NUMBER=>OVERFLOW ENDS XFER
	MOV #DSKBUF,RKBA
	MOV #2003,RKCS
	TSTB RKCS
	BPL .-4
	TST RKCS
	BMI FMTER
	INC B
	SOB C,FFLP2
	BIC #17,B
	ADD #20,B
	SOB D,FFLP1
	CLR A
	CLR B
	MOV #313*2,D
FFLP3:	MOV #12.,C
FFLP4:	MOV WCHDSK,RKDA
	BIS B,RKDA
	MOV #-2,RKWC	;LARGE NEGATIVE NUMBER=>OVERFLOW ENDS XFER
	MOV #DSKBUF,RKBA
	MOV #2005,RKCS
	TSTB RKCS
	BPL .-4
	TST RKCS
	BMI FMTER
	CMP B,DSKBUF
	BEQ FFLP5
	JSR PC,FFCMPE
FFLP5:	CMP #77776,DSKBUF+2
	BEQ FFLP6
	JSR PC,FFCMPE
FFLP6:	INC B
	SOB C,FFLP4
	BIC #17,B
	ADD #20,B
	SOB D,FFLP3
NOFMT:	JSR PC,CRLF
	RTS PC

INITD:	JSR PC,FORMAT
	MOV #-1,BLKLIM
	MOV #DBITS1,A
	MOV #20000,B
	CLR (A)+	;CLEAR 2*4K WORDS (BOTH BIT TABLES)
	SOB B,.-2
	MOV #760,DBITS1+4	;MARK BLOCKS 44-50
	MOV #4604,BLKLIM	;NO. BLOCKS ON DISK
	TST WCHDSK	;IS IT THE FIXED DISK
	BPL XDESCR	;NOPE
	MOV #2000,BLKLIM
XDESCR:	JSR PC,CLRBUF
	MOV #DSKBUF,D

BASEYR:	TYPEIT ^/_BASE YEAR:  /
	JSR PC,ITYI	;RESET TYI BUFFER
	JSR PC,DECIN
	BEQ BASEYX	;NO NUMBER TYPED IN--NO GOOD
	CMP #15,A	;FOLLOWING CHAR = CR?
	BNE BASEYX
	MOV B,(D)+	;# IS BASE YEAR
	BR AREA1
BASEYX:	TYPEIT ^/ ?/	;BAD SYNTAX
	BR BASEYR

AREA1:	JSR PC,AREAN
	TYPEIT ^/1/	;BACK FOR "SWAP AREA 1:  "
	JSR PC,@(P)+	;CONTINUE
	BVS AREA1	;BAD SYNTAX:  "?" ALREADY TYPED
	BNE AREA2	;# BLOCKS = 0?
	CMP (D)+,(D)+	;YES, JUST CR TYPED: SKIP AREA 2
	BR RESRVD

AREA2:	JSR PC,AREAN
	TYPEIT ^/2/	;BACK FOR "SWAP AREA 2:  "
	JSR PC,@(P)+	;CONTINUE
	BVS AREA2
RESRVD:	TYPEIT ^/_RESERVED:  /
	JSR PC,ITYI

	JSR PC,RANGIN
	BVS RSRVX1	;BAD RANGE SYNTAX
	CMP #15,A	;CR AFTER FIRST RANGE?
	BEQ RSRVCR
	CMP #',,A	;COMMA AFTER FIRST RANGE?
	BNE RSRVX1	;MUST BE ONE OR THE OTHER
	TST B
	BEQ RSRVX1	;NO RANGE FOLLOWED BY COMMA NO GOOD
	JSR PC,SETMSK	;SET BITS AND MAKE OFFSET/MASK FOR THIS RANGE
	BR RESRVC

RSRVCR:	TST B
	BEQ DESCWR	;NO RANGE ON LINE -> ALL DONE.
	JSR PC,SETMSK	;CRUNCH RANGE
	BR RESRVD	;ANOTHER LINE OF "RESERVED:  "

RSRVX1:	TYPEIT ^/ ?/	;LINE SYNTAX  NO GOOD
	BR RESRVD	;TRY LINE AGAIN


RESRVC:		;AFTER A COMMA:
	JSR PC,RANGIN
	BVS RSRVX2	;BAD RANGE SYNTAX
	TST B
	BEQ RSRVX2	;AFTER A COMMA YOU MUST HAVE A RANGE
	CMP #15,A
	BEQ RSVCR2	;ENDED WITH CR
	CMP #',,A
	BNE RSRVX2	;MUST HAVE EITHER THAT OR COMMA
	JSR PC,SETMSK	;CRUNCH RANGE
	BR RESRVC	;ANOTHER RANGE ON THIS LINE

RSVCR2:	JSR PC,SETMSK	;CRUNCH RANGE
	BR RESRVD	;ANOTHER LINE

RSRVX2:	TYPEIT ^/ ?_BAD SYNTAX AFTER COMMA/
	BR RESRVD	;TRY LINE AGAIN


DESCWR:	SUB #DSKBUF,D
	MOV D,DESLEN		;SAVE THE DESRIPTOR LENGTH
	MOV #50,B
	JSR PC,DBFWRT	;WRITE BLOCK 50:  DESCR FILE DONE
XBITS:	JSR PC,CLRBUF
	MOV BLKLIM,DSKBUF	;NO. BLOCKS ON DISK
	MOV #777,C		;BLT 1000-1 WORDS INTO DSKBUF+2
	MOV #DBITS1,A
	MOV #DSKBUF+2,B
	MOV (A)+,(B)+
	SOB C,.-2
	MOV #47,B	;WRITE THIS FILE
	JSR PC,DBFWRT	;STILL ONLY ALLOW 17760 BLOCKS ON DISK

XROOT:	JSR PC,CLRBUF
	MOV #DSKBUF+1,B
	MOVB #SELF+201,(B)+	;ROOT HAS WORD LEFT FOR LENGTH
	MOV #1,(B)+		;SET IN THE DIRID
	ADD #10,B		;SKIP EOF, AND DATE AND TIME
	JSR PC,GETNAM		;GET NAME OF DISK
	MOVB #200,(B)+
	MOVB #46,(B)+		;SAY BLOCK 46
	TSTB (B)+		;THE LENGTH OF ROOT
	MOV B,A
	SUB #DSKBUF,A
	MOVB A,DSKBUF	;HEADER LENGTH BYTE
	INC B
	BIC #1,B	;ROUND IT
	MOV #DSKBUF+14,C	;SKIP HEADER AND DIRID
	MOVB DSKBUF,F		;COPY THE LENGTH
	SUB #10,F	;THE EOF AND DATE/TIME DONT EXIST
	MOVB F,(B)+	;SET IN THE LENGTH INTO PARENT ENTRY
	MOVB #PARENT+1,(B)+	;SET IN THE TYPE
	MOV #1,(B)+	;AND DIRID
	SUB #3,F	;SKIP THE HEADER AND DIRID
	ASR F		;TURN INTO WORD COUNT
	MOV (C)+,(B)+	;COPY THE ENTRY
	SOB F,.-2
	MOV #ROTMID,A
	MOV #<ROTEND-ROTMID>/2,C
	MOV (A)+,(B)+	;FILL IN POINT, BITS AND DESCR ENTRIES (FIXED)
	SOB C,.-2
	SUB #DSKBUF,B	;NUMBER OF BYTES INROOT
	MOV B,DSKBUF+6
	MOV #46,B
	JSR PC,DBFWRT

XPOINT:	MOVB DSKBUF,F		;THE LENGTH OF THE SELF ENTRY
	SUB #10,F		;NO EOF/DATE/TIME
	MOV F,E			;THE NUMBER OF WORDS TO TRANSFER
	INC E
	ASR E
	MOV #DIR,C		;PLACE TO SAVE ENTRY
	MOV #DSKBUF+14,B	;POINTER TO NAME OF ROOT
	MOV #<PARENT+1>*400,(C)	;SAVE THE TYPE
	ADD F,(C)+		;SET IN THE LENGTH
	MOV #1,(C)+		;SET IN THE DIRID
	DEC E			;DONT TRANSFER THE HEADER EITHER
	DEC E
	MOV (B)+,(C)+		;COPY THE ENTRY
	SOB E,.-2
	JSR PC,CLRBUF
	MOV #DSKBUF,B		;THE PLACE TO CONSTRUCT POINT
	MOV #RUGBEG,A
	MOV #<RUGEND-RUGBEG>/2,C	;THE LENGTH OF STARTING ENTRY
	MOV (A)+,(B)+		;COPY THE SELF ENTRY
	SOB C,.-2
	MOVB DIR,C		;THE LENGTH OF NEW ENTRY
	INC C
	BIC #1,C
	MOV C,F
	ASR C
	MOV #DIR,A		;POINT TO IT
	MOV (A)+,(B)+		;COPY THE PARENT ENTRY
	SOB C,.-2
	INC F
	BIC #1,F
	MOVB DSKBUF,E
	ADD E,F
	INC F
	BIC #1,F
	MOV F,DSKBUF+6
	MOV #45,B
	JSR PC,DBFWRT
DIRINT:	JSR PC,CLRBUF
	MOV #DSKBUF,B
	MOV #3,(B)+
	MOV #1,(B)+
	MOV #2,(B)+
	MOV #44,B
	JSR PC,DBFWRT
INITDX:	JMP SALV2
CLRBUF:	MOV #DSKBUF,A
	MOV #1000,B	;512 WORD IN BUFFER
	CLR (A)+
	SOB B,.-2
	RTS PC

GETNAM:	TYPEIT ^/_DISK NAME:  /
	JSR PC,ITYI
GETNM2:	JSR PC,TYI
	CMPB #15,A	;CR ENDS NAME
	BEQ GETNMR
	MOVB A,(B)+	;NEXT CHAR OF HEADER ENTRY
	BR GETNM2
GETNMR:	MOV #12,A	;ECHO CRLF
	JSR PC,TYPE
	TSTB -(B)	;FLAG PREVIOUS CHAR AS LAST CHAR OF NAME
	BISB #200,(B)+
	RTS PC
DECIN:	CLR B		;Z IF NO DIGITS TYPED;
	JSR PC,DECDIG	;# IN B, END CHAR IN A
	BNE DECIN2
	SEZ		;NO NUMBER
	RTS PC
DECIN2:	JSR PC,DECDIG
	BNE DECIN2
	CLZ		;NON-DIGIT SEEN
	RTS PC

DECDIG:	JSR PC,TYI	;Z IF NOT DIGIT;
	CMP #'0,A	;CHAR IN A, ACCUM'ED # IN B
	BGT DECDGX
	CMP #'9,A
	BLT DECDGX
	SUB #'0,A
	MUL #10.,B
	ADD A,B
	CLZ		;THIS WAS A DIGIT
	RTS PC
DECDGX:	SEZ
	RTS PC		;NOT A DIGIT


RANGIN:			;GET A RANGE, C = STARTING BLOCK, B = # BLOCKS
			;SET V IF BAD SYNTAX
	JSR PC,OCTIN
	BEQ RANGE0	;NO RANGE
	MOV B,C		;FIRST BLOCK OF GROUP GOES IN C
	CMP #'-,A	;ONE BLOCK OR GROUP?
	BEQ RANGI2
	MOV #1,B	;JUST ONE NUMBER- LENGTH OF GROUP IS 1
	RTS PC
RANGE0:	CLR B		;NO RANGE:
	CLR C
	RTS PC		;FIRST NUMBER NOT TYPED--B=0 IS FLAG

RANGI2:	JSR PC,OCTIN	;GET LAST BLOCK NUMBER
	BEQ RANGIX	;BAD SYNTAX--NO END #
	SUB C,B		;MAKE B NUMBER OF BLOCKS
	INC B		;FROM FIRST AND LAST BLOCKS
	BLT RANGIX	;FIRST MUST NOT BE > LAST
	RTS PC
RANGIX:	SEV		;BAD RANGE SYNTAX
	RTS PC


OCTIN:	CLR B		;Z IF NO DIGITS; # IN B, BREAK CHAR IN A
	JSR PC,OCTDIG
	BNE OCTIN2
	SEZ		;NO NUMBER
	RTS PC
OCTIN2:	JSR PC,OCTDIG
	BNE OCTIN2
	CLZ		;NON-DIGIT SEEN
	RTS PC

OCTDIG:	JSR PC,TYI	;Z IF NOT A DIGIT;
	CMP #'0,A	;CHAR IN A, ACCUM'ED # IN B
	BGT OCTDGX
	CMP #'7,A
	BLT OCTDGX
	SUB #'0,A
	ASH #3,B
	ADD A,B
	CLZ		;WE GOT A DIGIT
	RTS PC
OCTDGX:	SEZ		;NOT A DIGIT
	RTS PC
AREAN:	TYPEIT ^/_SWAP AREA /
	JSR PC,@(P)+	;GO BACK TO TYPE SWAP AREA #
	TYPEIT ^/:  /	;HELLO AGAIN
	JSR PC,ITYI
	JSR PC,RANGIN
	BVS AREANX	;BAD RANGE SYNTAX
	CMP #15,A	;MUST BE CR AFTER RANGE
	BNE AREANX
	JSR PC,SETAREA	;SET RANGE IN BIT TABLE AND DESCR FILE
	RTS PC		;IF B = 0 BLOCKS IT WAS JUST CR;
			;Z IS SET AND CALLER WILL GO TO RESRVD.
AREANX:	TYPEIT ^/ ?/	;SYNTAX BAD
	SEV
	RTS PC


SETAREA: MOV C,(D)+	;GIVEN A GROUP OF BLOCK, FIRST ONE IN C,
	MOV B,(D)+	;# OF BLOCKS IN B, PUT THEM IN DESCR AND
	BNE .+4		;SET THEIR BITS IN DBITS1
	RTS PC		;BUT IF B = 0 DON'T BOTHER
	MOV C,BLOKNO
	MOV B,C		;GOOD PLACE FOR COUNTER

SETAR2:	CMP BLOKNO,BLKLIM
	BHIS NDISKX	;BLOCK FELL OFF DISK:  FATAL ERROR
	JSR PC,BTADR	;BLOKNO -> BIT IN A, BYTE OFFSET IN B
	BITB A,DBITS1(B)
	BEQ .+6
	JSR PC,BALRES	;BLOCK ALREADY RESERVED
	BISB A,DBITS1(B)	;RESERVE THE BLOCK
	INC BLOKNO	;LOOP TO NEXT BLOCK
	SOB C,SETAR2	;COUNT OUT # OF BLOCKS
	RTS PC
SETMSK:	MOV C,BLOKNO	;GIVEN A GROUP OF BLOCKS, SET UP OFFSET/MASK PAIRS
	MOV B,C		;IN DESCR AND RESERVE THE BLOCKS IN DBITS1
	BR SETMS3	;THERE SHOULD BE NO B=0 CASES

SETMS2:	BIT #17,BLOKNO	;RUNNING INTO NEW MASK WORD?
	BNE SETMS4
	TST (D)+	;YES, BE DONE WITH OLD ONE,
SETMS3:	JSR PC,OFFSET	;MAKE NEW OFFSET WORD
SETMS4:	CMP BLOKNO,BLKLIM
	BHIS NDISKX	;BLOCK FELL OFF DISK--FATAL ERROR
	JSR PC,BTADR	;BLOKNO -> BIT IN A, BYTE OFFSET IN B
	BITB A,DBITS1(B)	;BLOCK RESERVED?
	BEQ .+6
	JSR PC,BALRES	;"BLOCK N ALREADY RESERVED"
	BISB A,DBITS1(B)	;RESERVE THE BLOCK
	BIT #10,BLOKNO	;ODD BYTE?
	BEQ .+4
	SWAB A		;IF ODD TEN THEN PUT IN ODD BYTE
	BIS A,(D)	;SET NEW BIT IN MASK

	INC BLOKNO
	SOB C,SETMS2
	TST (D)+	;END LAST MASK WORD
	CMP D,#DSKBUF+2000
	BHIS DESCRX	;DESCR OVERFLOW--FATAL
	RTS PC


OFFSET:	CMP D,#DSKBUF+1776
	BHIS DESCRX	;DESCR FILE OVERFLOW--FATAL ERROR
	MOV BLOKNO,A
	ASH #-3,A	;BLOCK # -> BYTE OFFSET
	BIC #1,A	;-> WORD OFFSET IN BIT TABLE
	MOV A,(D)+	;MAKES OFFSET WORD OF DESCR FILE
	RTS PC

DESCRX:	TYPEIT ^/_DESCR FILE OVERFLOWED_/
	HALT		;INITD NO GOOD
	BR .-2



BALRES:	PUSH A		;BLOCK ALREADY RESERVED
	PUSH B
	TYPEIT ^/_BLOCK /
	MOV BLOKNO,B
	JSR PC,OCTOUT
	TYPEIT ^/ ALREADY RESERVED_/
	POP B
	POP A
	RTS PC


NDISKX:	TYPEIT ^/_BLOCK NOT ON DISK_/
	HALT		;INITD NO GOOD
	.STITL TYI & TYO
CRLF:	MOV #15,A
	JSR PC,TYPE
	RTS PC

ECHO:	TST RUBING	;RUBBING OUT CHARS?
	BEQ TYPE
	PUSH A		;YES, LEAVE RUBBING MODE
	MOV #'\,A
	JSR PC,TYPE
	CLR RUBING
	POP A

TYPE:	TSTB %TPS
	BPL TYPE
	MOVB A,%TPB
	CMP #15,A
	BEQ .+4
	RTS PC
	PUSH A
	MOV #12,A
	JSR PC,TYPE
	CLR A
	JSR PC,TYPE
	JSR PC,TYPE
	POP A
	RTS PC

TYI1:	TSTB %TKS
	BPL TYI1
	MOVB %TKB,A
	BIC #177600,A
	CMP #'G-100,A	;BELL?
	BEQ TYIRUG
	CMP #'Z-100,A	;^Z?
	BEQ TYIRUG
	CMP #'A+40,A
	BGT TYI2
	CMP #'Z+40,A
	BLT TYI2
	SUB #40,A
TYI2:	CMP #177,A	;RUBOUT?
	BNE .+6
	SEV
	RTS PC		;IF RUBOUT THEN 1) SET V 2) DON'T ECHO
	JSR PC,ECHO	;ECHO
	RTS PC
TYIRUG:	BPT
	BR TYI1

ITYI:	CLR NCHR
	RTS PC

TYI:	DEC NCHR	;ONE LESS CHAR TO READ
	BLT TYLINE	;IF IT'S THERE
	MOVB @TBUFPT,A	;THEN HERE IT IS
	INC TBUFPT
	RTS PC

TYLINE:	CLR NCHR	;OUT OF CHARS: GET A NEW LINE
	CLR RUBING	;NOT RUBBING OUT
	MOV #TBUF,TBUFPT	;READ INTO BUFFER
TYLIN2:	CMP #TBUFLN,NCHR	;ROOM IN BUFFER?
	BLOS LINERR
	JSR PC,TYI1	;GET A CHAR
	BVS TYLRBO	;RUBOUT
	MOVB A,@TBUFPT	;STORE CHAR
	INC TBUFPT
	INC NCHR	;ONE MORE CHAR IN BUFFER
	CMP #15,A	;CR?
	BNE TYLIN2	;NO, KEEP LISTENING
	MOV #TBUF,TBUFPT  ;YES, BUFFER READY: FEED HIM THE FIRST CHAR
	BR TYI

TYLRBO:	DEC NCHR	;RUB IT OUT: ONE LESS CHAR
	BLT TYLINE	;NO CHARS TO RUB OUT: RESET LINE
	DEC TBUFPT
	TST RUBING	;ALREADY IN RUBBING MODE?
	BNE TYLRB2	;YES
	MOV #'\,A
	JSR PC,TYPE
	INC RUBING
TYLRB2:	MOVB @TBUFPT,A	;TYPE RUBBED OUT CHAR
	JSR PC,TYPE
	TST NCHR	;FIRST CHAR RUBBED OUT?
	BNE TYLIN2	;NO, DONE WITH RUBOUT
	MOV #'\,A	;YES, CLOSE RUBBING MODE
	JSR PC,TYPE
	BR TYLINE

LINERR:	TYPEIT ^/ ?_TYI BUFFER FULL, TRY IT ALL OVER/
	BPT
	JMP SALV2


PATLOC:
PATCH:	.=.+400

;*************
;FIXED HEAD DISK BLOCK 0 BOOTSTRAP FOR LOGO AND RUG
;
FHIDIR:	MOV #DSKAE,B
	CLR (B)
	MOV #4000,-(B)
	MOV #120000,-(B)
	MOV #160000,-(B)
	MOV #DISKRD,-(B)
	TSTB (B)
	BPL .-2
	CMP #177000,@#SWB
	BEQ .+6
	JMP @#120000	;CLEAR SWITCHES TO GET RUG
	JMP @#120002	;LEAVE SWITCHES UP FOR LOGO
FHIDIZ:
;*************

	FBASE=<.!1777>+1
	FEND==FBASE+4000
	DBITS1=50000
	DBITS2=DBITS1+20000
	DIR=DBITS2+20000
	DIRBUF==DIR+20000
 	DSKBUF=DIR+20000

.END SALV
