.TITLE TAPE GOBBLER
VERN==%FNAM2
.INSRT SITS;SITMAC >
.INSRT RJL;FLOPDF >
.MACRO TYPE STRING
	JSR F,TYPES
	.ASCIZ /STRING/
	.EVEN
.ENDM
.=0
.REPT 100
	.+2
	0
.ENDR
.=300
	JMP START
.=500
PDL:	0
.=600
PATCH:
PAT:	.BLKW 200

TKS=177560
TKB=TKS+2
TPS=TKB+2
TPB=TPS+2
;FLOPPY DISK DATA AREA
FLOPPY:	0	;IF NON-ZERO WE HAVE A FLOPPY DISK CONTROLLER
RETRYS:	0	;NUMBER OF RETRYS LEFT
NRETRY==10.	;NUMBER OF TIMES TO TRY
DISKIO:	0	;FUNCTION TO PERFORM
 DISKWR==1	;WRITE
 DISKRD==2	;READ
 DISKWC==3	;WRITE CHECK
FLOPTR:	0	;CURRENT TRACK ADDRESS
FLOPRT:	0	;WHERE THE DISK REALLY IS
FLOPSC:	0	;CURRENT SECTOR
FLOPNS:	0	;NEW SECTOR NUMBER
FLOPWC:	0	;UNEXPIRED PART OF WORD COUNT
FLOPCA:	0	;CORE ADDRESS
INITCM:	0	;COMMADN TO INIT CONTROLLER WITH
NSECS:	26.	;NUMBER OF SECTORS/TRACK
SECBLS:	3	;SHIFT TO GO FROM BLOCK TO SECTOR
SECSIZ:	128.	;NUMBER OF BYTES IN SECTOR
SECSZW:	64.	;SECTOR SIZE IN WORDS
ERRDAT:	0	;DATA FROM LAST ERROR
ERRST:	0	;TYPE OF LAST ERROR
TRNSLE:	-1000	;TRANSFER LENGTH
WCHDSK:	0	;WHICH DISK
BLOKNO:	0	;BLOCK NUMBER OF CURRENT DISK BLOCK
CURDIR:	0	;BLOCK NUMBER OF CURRENT DIRECTORY
ENTRY:	.BLKW 32.	;CURRENT ENTRY
ENTRYE:	0	;POINTER TO END OF ENTRY
TEND:	0		;CURRENT END OF TAPE BARFER
BOOTIN:	0	;IF NON-ZERO WE HAVE READ IN A BOOT PROGRAM
MEMTOP:	0
DEFALT:	.ASCIZ /./	;DEFAULT DIRECTORY STRING
	.BLKB 50.
	.EVEN

FNBFNO==2	;FILE NUMBER
FNBVER==4	;VERSION NUMBER
FNBFN==6	;BEG OF NAME

VEROFF==2	;VERSION IN ENTRY
NAMOFF==4	;FIRST POSSIBLE PLACE FOR NAME
EOFOFF==6	;PALCE FOR LOW ORDER EOF WORD

MFEOFB==100000	;EOF, TIME+DATE PRESENT
MFACCB==40000	;ACCESS CODES PRESENT

MFDIRE==1000	;DIRETORY ENTRY
MFFILE==2000	;FILE ENTRY
NAMBUF:	.BLKW 20
FNBBLK:	.BLKB FNBFN+20.	;OUR ONE FILE NAME BLOCK FOR GENERAL USE
BITBLK:
.=BITBLK+FNBVER
	-1
.=BITBLK+FNBFN
	.ASCII /BIT/
	.BYTE 'S+200
	.EVEN
BITBNO:	0		;BLOCK NUMBER OF BIT TABLE

CMDTAB:	.REPT 200
	CMDER
	.ENDR

.MACRO CMD CHAR,DISP
	.=CMDTAB+<2*<CHAR>>
	DISP
.ENDM
	CMD '?,CMDQ
	CMD '!,WRTBOO
	CMD 'A-100,STFIT
	CMD 'B,READBT
	CMD 'D,DELFIL
	CMD 'F,FILDIR
	CMD 'F-100,FILDIR	;FOR HACKERS
	CMD 'O-100,DELFIL	;LIKEWISE
	CMD 'Q,QUIT
	CMD 'R,READ
	CMD 'S,SETDIR
	CMD 'T,TEST
	CMD 'W,WRITET
	CMD 'W-100,WRTBOO
.=CMDTAB+400	;MUST BE AT END OF ALL THE CMD MACRO CALLS



START:	RESET
	MOV #PDL,P
	TYPE <TAPE.>
	MOV #VERN,B
	JSR PC,PRDN
	TYPE <
>
	MOV #MEMEND,4
	CLR A
1$:	TST (A)+
	BR 1$
MEMEND:	SUB #40,A	;MAKE ROOM FOR DDT
	MOV A,MEMTOP
	MOV #NOFLOP,4
	CLR FLOPPY	;IF CLEAR, NO FLOPPY DISK CONTROLLER
	TST SMSCSR	
	MOV PC,FLOPPY
NOFLOP:	MOV #6,4
RSTART:	MOV #PDL,P
	JSR PC,DSKOFF
	TYPE <
Ok boss, what now??
>
	JSR PC,TYIC
	ASL A
	JMP @CMDTAB(A)

CMDER:	TYPE <Nope! try ? for help
>
	JMP RSTART

CMDQ:	TYPE <Commands are:
!  or <cntl>w Write out floppy disk boot program.
?  Print this stuff.
B  Boot. Read in floppy disk bootstrap program from (C)assette or (F)loppy.
D  Delete file from floppy.
F  Files. Print file directory from floppy.
Q  Quit. Die a horrible death.
R  Read a program from (c)assette or (f)loppy.
S  Set floppy directory.
T  Test cassette.
W  Write program onto (c)assette or (f)loppy.
      (Type C or F when asked. to read from paper tape, use C.)
>
	JMP RSTART
QUIT:	HALT
	JMP RSTART
STFIT:	TYPE <STUFF IT!>	;FOR STUFFER
	JMP RSTART


IGNFLG:	0
ZEROC:	0

READ:	TYPE <
Read from (C)assette or (F)loppy?  >
	JSR PC,TYIC
	CMP #'F,A
	BNE READTP
	JMP READF
READTP:	CMP #'C,A
	BEQ READT1
	JMP RSTART
READT1:	TYPE <
Type space to start reading tape.
>
	JSR PC,TYIC
	CMP #40,A	
	BEQ 1$
	TYPE <That's not a space.
>	
	JMP RSTART
1$:	MOV #TSTART,TEND
	CLR BOOTIN
;LOOK FOR START OF ABS LOADER TYPE OF TAPE
	CLR IGNFLG
ABSLK:	CLR ZEROC
ABSLKZ:	JSR PC,READC
	TST B		;ZERO?
	BEQ ABSLK1	;COUNT EM UP
	CMP #351,B	;ABS LOADER
	BEQ ABSLK2	;GO IGNORE ABS LOADER
	CMP #1,B	;BEG OF ABS LOADER BLOCK?
	BNE ABSLK	;NOPE, IGNORE IT
	TST IGNFLG	;IGNORING A LOADER?
	BEQ ABSFND	;NOPE, DON'T NEED TO BE CAREFUL
	CMP #10.,ZEROC
	BGT ABSLK	;NOT 10 ZEROS BEFORE, SO IGNORE
	BR ABSFND	;FOUND FIRST BLOCK THEN
ABSLK1:	INC ZEROC
	BR ABSLKZ
ABSLK2:	TST IGNFLG	;ALREADY TOLD HIM?
	BNE ABSLK	;YUP
	TYPE <Ignoring abs loader
>
	INC IGNFLG
	BR ABSLK

	;;LOOK FOR BEG OF A BLOCK
R.LD2:	MOV TEND,LASTB
	CLR A
	JSR PC,READC
	DECB B
	BEQ ABSFND
	CMP #65,B	;IS IT A STOP CODE?
	BNE R.LD2	;NOPE
	TYPE <Ready for next tape when you are.
Type space to continue.
>
	JSR PC,TYI
	BR R.LD2
ABSFND:	MOV #1,B
	MOV B,A		;SET CHECKSUM ALSO
	JSR PC,PUTC	;PUT THE 1 IN THE TAPE BUFFER
R.LD24:	JSR PC,READCS

	JSR PC,R.GWRD
	MOV E,D
	SUB #4,D
	CMP #2,D
	BEQ R.JMP
	JSR PC,R.GWRD
	MOV E,C

R.LD3:	JSR PC,READCS
	BGE R.LD3
	TSTB A
	BEQ R.LD2
R.BAD:	TYPE <Got a checksum error, back up to last block then type a space.
>
	MOV LASTB,TEND
	JSR PC,TYI
	BR R.LD2


READC:	INCB TKS
1$:	TSTB TKS
	BPL 1$
	MOVB TKB,B
	ADD B,A
	BIC #177400,B
	DEC D
	RTS PC

READCS:	JSR PC,READC
PUTC:	MOVB B,@TEND
	INC TEND
	CMP TEND,MEMTOP
	BLO 1$
	TYPE <Tape too long for me to remember.
>
	JMP RSTART
1$:	TST D
	RTS PC

R.GWRD:	JSR PC,READCS
	MOV B,E
	JSR PC,READCS
	SWAB B
	BIS B,E
	RTS PC

R.JMP:	JSR PC,R.GWRD
	JSR PC,READCS
	TSTB A
	BNE R.BAD
	TYPE <Ok, that's the end
>
	JMP RSTART

R.TMP:	.WORD 0
LASTB:	0


CGET:	INC TKS
TYI:	TSTB TKS
	BPL TYI
	MOV TKB,A
	RTS PC

WRITET:	CMP #TSTART,TEND
	BLO WRTT1
	TYPE <
Ya gotta read it before you can write it
>
WRTT1:	TST BOOTIN
	BEQ WRTT2
	TYPE <
No, that's a bootstrap program you read in>
	JMP RSTART
WRTT2:	TYPE <Write onto (C)assette or (F)loppy?  >
	JSR PC,TYIC
	CMP #'F,A
	BNE 1$
	JMP WRITEF
1$:	CMP #'C,A
	BEQ 2$
	JMP CMDER

2$:	TYPE <Start tape recording, then type space
>
	JSR PC,TYI
	MOV #MAGIC,B
	MOV #MAGICE,C
	JSR PC,TYPEB
;THEN WAIT FOR THE LOAFER TO BE HAPPY
	JSR PC,WAITL
	MOV #ABSBOT,B
	MOV #ABSBEE,C
	JSR PC,TYPEB	;OUTPUT ABS LOADER
	JSR PC,WAITL	;WAIT FOR CORE TO GET CLEARED
	MOV #TSTART,B
	MOV TEND,C
	JSR PC,TYPEB	;NOW BLAST OUT THE REAL THING
	JSR PC,TYI
	JMP RSTART

WAITL:	MOV #10.,A
1$:	SOB B,1$	;65K LOOPS = .3 SEC
	SOB A,1$	;SO THIS IS 6 SECONDS
	RTS PC

TEST:	TYPE <(R)ecord or (P)layback?
>
	JSR PC,TYIC
	CMP #'R,A
	BEQ TESTR
	CMP #'P,A
	BEQ TESTP
	JMP RSTART

TESTR:	TYPE <Start tape recording then type a space
>
	JSR PC,TYI	
	MOV #100000,A		;WILL WRITE OUT 32K CHARS IN ASCENDING SEQUENCE
1$:	JSR PC,TYO
	INC A
	BNE 1$
	TYPE <Ok, now rewind the tape>
	JMP TEST

TESTP:	TYPE <Start tape playing back
>
	CLR ERRORS
	MOV #100400,B
1$:	JSR PC,TYI
	CMPB A,B
	BEQ 2$
	TYPE <E>
	INC ERRORS
	BIC #377,B
	BIS A,B		;TRY TO RESYNC BY ASSUMING THIS CHAR IS CORRECT
2$:	INC B
	BNE 1$

	TST ERRORS
	BNE 3$
	TYPE <No errors, congrats K1000
>	
	BR 4$
3$:	TYPE <
CALIS!! GOT >
	MOV ERRORS,B
	JSR PC,PRDN
	TYPE < ERRORS
>
6$:	JSR PC,TYI
	CMP #'P,A
	BNE 6$
	JSR PC,TYI
	CMP #'E,A
	BNE 6$
4$:	TYPE <TYPE ! TO RESTART PROGRAM
>
5$:	JSR PC,TYIC
	CMP #'!,A
	BNE 5$
	JMP TEST

ERRORS:	0



TYIC:	JSR PC,TYI
	BIC #177600,A
	CMP #'a,A	;LOWER CASE?
	BGT 1$		;NOPE
	CMP #'z,A
	BLT 1$
	SUB #40,A	;MAKE UPPER
1$:	

TYO:	TSTB TPS
	BPL TYO
	MOVB A,TPB
	RTS PC

TYPEB:	MOVB (B)+,A
	JSR PC,TYO
	CMP B,C
	BLO TYPEB
	RTS PC


TYPES:	SAVE A
1$:	MOVB (F)+,A
	BEQ 2$
	JSR PC,TYO
	BR 1$
2$:	INC F
	BIC #1,F
	REST A
	RTS F


MAGIC:	.ASCII /177560L/
MAGICE:
	.EVEN


ABSBOT:
WAITIN==240	;KEEP GOING FOR OUR VERSION
.INSRT RJL;HHABS >
	.BLKW 20.	;SO THERE WILL BE AT LEAST 10. ZEROS BEFORE THE REAL THING
ABSBEE::
.EVEN


READBT:	TYPE <
READ BOOTSTRAP FROM (C)ASSETTE OR (F)LOPPY?  >
	JSR PC,TYIC
	CMP #'C,A
	BEQ REDBTT
	CMP #'F,A
	BNE READBT
	JMP REDBTF

REDBTT:	TYPE <TYPE SPACE TO START READING BOOTSTRAP PROGRAM TAPE
>
	JSR PC,TYIC
	CMP #40,A	
	BEQ 1$
	TYPE <THAT'S NOT A SPACE
>	
	JMP RSTART
1$:	MOV #TSTART,A
	MOV A,TEND
2$:	CLR (A)+
	CMP A,MEMTOP
	BNE 2$

;LOOK FOR START OF ABS LOADER TYPE OF TAPE
	CLR LASTB	;LAST BYTE LOADED
	CLR IGNFLG
BABSLK:	CLR ZEROC
BABSLZ:	JSR PC,READC
	TST B		;ZERO?
	BEQ BABSL1	;COUNT EM UP
	CMP #351,B	;ABS LOADER
	BEQ BABSL2	;GO IGNORE ABS LOADER
	CMP #1,B	;BEG OF ABS LOADER BLOCK?
	BNE BABSLK	;NOPE, IGNORE IT
	TST IGNFLG	;IGNORING A LOADER?
	BEQ BABSFN	;NOPE, DON'T NEED TO BE CAREFUL
	CMP #10.,ZEROC
	BGT BABSLK	;NOT 10 ZEROS BEFORE, SO IGNORE
	BR BABSFN	;FOUND FIRST BLOCK THEN
BABSL1:	INC ZEROC
	BR BABSLZ
BABSL2:	TST IGNFLG	;ALREADY TOLD HIM?
	BNE BABSLK	;YUP
	TYPE <IGNORING ABS LOADER
>
	INC IGNFLG
	BR BABSLK

	;;LOOK FOR BEG OF A BLOCK
D.LD2:	MOV TEND,LASTB
	CLR A
	JSR PC,READC
	DECB B
	BNE D.LD2
BABSFN:	MOV #1,A	;SET CHECKSUM
D.LD24:	JSR PC,READC	;IGNORE ZERO
	JSR PC,D.GWRD
	MOV E,D
	SUB #4,D
	CMP #2,D
	BEQ D.JMP
	JSR PC,D.GWRD
	MOV E,C

D.LD3:	JSR PC,READC
	BGE D.LD4
	TSTB A
	BEQ D.LD2
D.BAD:	TYPE <GOT A CHECKSUM ERROR, TRY AGAIN I GUESS.
>
	JMP RSTART
D.LD4:	MOVB B,TSTART(C)
	INC C
	CMP C,MEMTOP
	BLO 2$
	TYPE <DO YOU REALLY EXPECT ME TO REMEMBER ALL THAT?
>
	JMP RSTART
2$:	CMP C,LASTB
	BLOS 1$
	MOV C,LASTB
1$:	BR D.LD3

D.JMP:	JSR PC,D.GWRD
	JSR PC,READC
	TSTB A
	BNE D.BAD
	MOV PC,BOOTIN
	TYPE <OK, THAT'S THE END
>
	JMP RSTART

D.GWRD:	JSR PC,READC
	MOV B,E
	JSR PC,READC
	SWAB B
	BIS B,E
	RTS PC




D.TMP:	.WORD 0


WRTBOO:	TST BOOTIN		;HAVE WE GOT A BOOT PROGRAM IN?
	BNE WRTBO1		;YUP
	TYPE <
Ya gotta read it before ya can write it, bunky
>
	JMP RSTART
WRTBO1:	TYPE <
Dump out boot program?  >
	JSR PC,TYIC
	CMP #'Y,A
	BEQ WRTBO2
	JMP RSTART
WRTBO2:	CMP TSTART+40,#111111	;SIGNATURE OF THE BOOT PROGRAM
	BEQ 1$
	TYPE <Silly, that's not the boot program!
>	
	JMP RSTART
1$:	TYPE <
What program name to boot?>
	MOV #TSTART+40,B
	JSR PC,STRING
	JSR PC,DSKNUM
	JSR PC,DISKON		;TURN ON THE DISK
	MOV #-4000,TRNSLE	;THAT'S THE TRANSFER LENGTH
	CLR BLOKNO
	MOV #TSTART,B	;PLACE WHERE CODE STARTS
	MOV #DISKWR,DISKIO	;WRITE
	JSR PC,DSKBLK	;DO IT
	MOV #111111,TSTART+40	;RESTORE BOOT LOAD TAG
	JSR PC,DSKOFF
	JMP RSTART

DSKNUM:	TYPE <DISK NUMBER?  >	
	JSR PC,TYIC
	TYPE <
>	
	SUB #60,A
	BLT DSKNUM
	CMP #4,A
	BLE DSKNUM
	MOV A,WCHDSK
	RTS PC


STRING:	CLR (B)		;SET THE NONE FLAG
	SAVE B
2$:	JSR PC,TYIC
	CMP #177,A
	BEQ 1$
	CMP #15,A	;CR?
	BEQ 3$		;YUP, END OF NAME
	MOVB A,(B)+
	BR 2$

3$:	CLRB (B)+	;SET END FLAG ON NAME
	TYPE <>
	INC (P)
	CMP (P)+,B	
	RTS PC

1$:	CMP (P),B	;RUBOUT AT BEG?
	BEQ 3$		;YES, RETURN
	MOVB -(B),A
	JSR PC,TYO
	BR 2$

DISKON:	SAVE <A,B,C,E,F>
	TST FLOPPY	;DO WE HAVE ONE?
	BEQ 3$
6$:	MOV #-1,FLOPRT
	BIS #SMSRSB!SMSPWR,SMSCSR	;RESET CONTROLLER AND POWER DRIVES ON
	CLR A		;FOR TIMER
	MOV #10.,B	;ALSO
8$:	BIT #SMSFDO,SMSCSR	;IS IT RESET YET?
	BEQ 9$
	SOB A,8$	;WAIT
	SOB B,8$	;A LONG TIME
7$:	TYPE <DISK WON'T POWER ON OR NO DISK IN DRIVE
TYPE P WHEN DISK IS OK
>
	HALT
	BR 6$
9$:	MOV #SMSCSR,F	;THE CONTROL REGISTER
	MOV #SMSDBF,E	;THE DATA BUFFER
	MOV #10.,C
1$:	MOV #SMSSTS,A	;GET STATUS
	JSR PC,DCMD	;ISSUE REQUEST FOR STATUS
	JSR PC,CMD2	;SECOND BYTE IGNORED
	JSR PC,GETST	;GET THE STATUS
			;IF WE GET BACK WITHOUT ERROR IT WILL BE DISK STATUS
	BIT #SMSDNR,A	;READY?
	BEQ 2$		;YUP
	SOB B,1$
	SOB C,1$
	BR 7$
2$:	MOV #SMSSEK,A
	JSR PC,DCMD
	CLR A
	JSR PC,CMD2
	JSR PC,GETST
	JSR PC,GETDEN
	REST <F,E,C,B,A>
	RTS PC
3$:	TYPE <TOUGH LUCK, YOU HAVEN'T GOT A FLOPPY DISK!>	
	JMP RSTART

DSKOFF:	TST FLOPPY
	BEQ 1$
	CLR SMSLGT
	BIS #SMSRSB,SMSCSR
	BIC #SMSPWR,SMSCSR
1$:	RTS PC



GETDEN:	MOV #SMSCSR,F
	MOV #SMS128,INITCM
	MOV #26.,NSECS
	MOV #3,SECBLS
	MOV #128.,SECSIZ
	MOV #64.,SECSZW
	JSR PC,GETDE1
	BNE 1$
	MOV #SMS512!SMSDBL,INITCM
	MOV #16.,NSECS
	MOV #1,SECBLS
	MOV #512.,SECSIZ
	MOV #256.,SECSZW
	JSR PC,GETDE1
1$:	RTS PC

GETDE1:	JSR PC,SETDEN
	MOV #SMSRID,A		;TRY TO READ THE ID
	JSR PC,DCMD
	JSR PC,CMD2
1$:	BIT #SMSXFW,SMSCSR
	BEQ 1$
	TST SMSCSR		;ERROR?
	BLT 2$			;YES, TRY FOR DOUBLE DENSITY
3$:	JSR PC,GETBYT
	JSR PC,GETBYT
	MOV #30.,A
4$:	BIT #SMSXFW,SMSCSR	;READY TO XFR?
	BNE 5$			;YUP
	SOB A,4$		;WAIT
	CLR A			;SINGLE DENSITY ONLY CONTROLER
	BR 6$
5$:	JSR PC,GETBYT
6$:	CLZ
	RTS PC
2$:	JSR PC,GETBYT		;GET THE ERROR BYTE
	SEZ
	RTS PC

GETBYT:	BIT #SMSXFW,SMSCSR
	BEQ GETBYT
	MOV SMSDBF,A
	RTS PC

SETDEN:	MOV #SMSCSR,F
	MOV #SMSRST!SMSINI,A
	JSR PC,DCMD
	MOV INITCM,A
	JSR PC,CMD2
1$:	BIT #SMSFDO,SMSCSR	;SINGLE DENSITY CONTROLLER GETS RESET
	BNE 1$			;WAIT FOR IT TO COME BACK
	RTS PC


;DISK ROUTINES FOR THE FLOPPY DISK
DSKBLK:	JSR F,ACSAV
	MOV B,FLOPCA	;SAVE STARTING CORE ADDRESS
	MOV TRNSLE,FLOPWC	;STARTING WORD COUNT
	MOV BLOKNO,B	;THE BLOCK NUMBER
	CLR A
	ASHC SECBLS,A	;8 SECTORS/BLOCK
	DIV NSECS,A	;26 SECTORS/TRACK
	INC A
	MOV A,FLOPTR	;TRACK
	INC B		;SECTORS ARE NUMBERED FUNNY
	MOV B,FLOPSC	;SECTOR
	MOV #SMSCSR,F	;THE CONTROL REGISTER
	MOV #SMSDBF,E	;THE DATA BUFFER

DSKBL1:	TST FLOPWC	;ANY WORDS LEFT TO XFER?
	BNE 1$		;YUP
	JSR F,ACRES
	RTS PC
1$:


	MOV #NRETRY,RETRYS	;SET RETRYS FOR THIS SECTOR
DSKBL2:	JSR PC,FLPSEK
	BEQ FLPERR
	JSR PC,SECMUN
	CMP #DISKWR,DISKIO	;WRITE?
	BEQ FLOPWR
.IFZ 105			;WRITE CHECK NOT USED
	CMP #DISKWC,DISKIO	;WRITE CHECK?
	BEQ FLOPCM
.ENDC
	CMP #DISKRD,DISKIO	;READ?
	BEQ FLOPRD
2$:	HALT			;??????
	BR 2$

FLOPWR:	MOV #SMSWRT!SMSHTB,A	;TRANSFER BLOCK TO BUFFER
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
2$:	BIT #SMSXFW,(F)		;WAITING YET?
	BEQ 2$
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
1$:	MOVB (A)+,(E)
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	MOV #SMSWRT!SMSBTD,A	;TRANFER BUFFER TO THE DISK
	JSR PC,DCMD
	MOV FLOPNS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	BR FLPSEC		;DONE WITH THIS SECTOR	

FLPERR:	BR FLPERX

FLOPRD:	MOV #SMSRED!SMSDTB,A	;TRANFER DISK TO BUFFER
	JSR PC,DCMD
	MOV FLOPNS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	MOV #SMSRED!SMSBTH,A	;TRANSFER BUFFER TO HOST
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
2$:	BIT #SMSXFW,(F)		;WAITING YET?
	BEQ 2$
1$:	MOVB (E),(A)+
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	BR FLPSEC		;DONE WITH THIS SECTOR	

.IFZ 105
FLOPCM:	MOV #SMSRED!SMSDTB,A	;TRANFER DISK TO BUFFER
	JSR PC,DCMD
	MOV FLOPNS,A		;THIS SECTOR
	JSR PC,CMD2
	JSR PC,GETST		;GET STATUS OF THE TRANSFER
	BEQ FLPERR
	MOV #SMSRED!SMSBTH,A	;TRANSFER BUFFER TO HOST
	JSR PC,DCMD	
	JSR PC,CMD2		;SECOND BYTE IGNORED
	MOV FLOPCA,A		;BUFFER ADDRESS
	MOV SECSIZ,B		;# OF BYTES/SECTOR	
2$:	BIT #SMSXFW,(F)		;WAITING YET?
	BEQ 2$
1$:	CMPB (E),(A)+
	BNE FLPERC
	SOB B,1$
	JSR PC,GETST		;CHECK FOR ERROR
	BEQ FLPERR		;GOT ERROR THIS TIME
	BR FLPSEC
.ENDC

FLPERC:	DEC B		;ONE LESS BYTE
	BEQ 2$	;ERROR ON LAST BYTE
1$:	MOV (E),A	;TO EMPRY BUFFER
	SOB B,1$
2$:	JSR PC,GETST
	BR FLPERR	;NOW DO THE ERROR

FLPSEC:	ADD SECSZW,FLOPWC		;TRANSFERED 64. WORDS
	BEQ 1$			;DONE TRANSFER
	ADD SECSIZ,FLOPCA	;OR 128. BYTES
	INC FLOPSC		;OR ONE SECTOR
	CMP NSECS,FLOPSC		;OVER TRACK BOUNDARY?
	BGE 1$
	MOV #1,FLOPSC
	INC FLOPTR
1$:	JMP DSKBL1		;GO CONTINUE THE TRANSFER



FLPERX:	DEC RETRYS		;TIME TO GIVE UP?
	BGE 1$
2$:	TYPE <TOO MANY ERRORS, (I)GNORE OR (R)ETRY OR (Q)UIT? >
	JSR PC,TYIC
	CMP #'I,A
	BEQ FLPSEC	
	CMP #'Q,A
	BNE 3$
	JMP RSTART
3$:	CMP #'R,A
	BNE 2$
	BR RECAL	;SEEK TO ZERO AND RETRY
1$:	MOV ERRST,A
	ASL A
	JMP @.+4(A)
	DSKBL2		;STRANGE, ERROR DISAPPEARED???
	BADER		;COMMAND ERROR IS BAD
	DRERR		;DRIVE ERROR
	OPRERR		;OPERATION ERROR

BADER:	TYPE <SOFTWARE ERROR>
1$:	HALT
	BR 1$

DRERR:	TYPE <FIX DRIVE AND TYPE A SPACE
>
	JSR PC,TYIC
	JMP DSKBL2

OPRERR:	BIT #SMSHPE,ERRDAT	;SEEK ERROR?
	BEQ OPRER1			;NOPE
RECAL:	SAVE FLOPTR
	CLR FLOPTR
	JSR PC,FLPSEK
	REST FLOPTR
OPRER1:	JMP DSKBL2		;TRY AGAIN
SECMUN:	SAVE <A,B>
	BIT #SMSDBL,INITCM	;DOUBLE DENSE?
	BNE 2$
	MOV FLOPTR,B		;NEW IS HARDER
	DEC B
	MUL #3,B		;SECTORS ARE OFFSET BY 6 FOR EACH TRACK
	CLR A
	ADD FLOPSC,B
	DEC B
	DIV #13.,A
	ASL B
	INC B
	CMP #13.,FLOPSC
	ADC B
	BR 3$
2$:	MOVB FLOPSC,B
	MOVB DBLSCM(B),B
3$:	MOV B,FLOPNS
	REST <B,A>
	RTS PC

DBLSCM:	.BYTE 0,1,5,9.,13.,2,6,10.,14.,3,7,11.,15.,4,8.,12.,16.,0

FLPSEK:	CMP FLOPTR,FLOPRT
	BEQ FLPSE3
FLPSE1:	MOV #SMSSEK,A		;ENTER HERE TO SKIP THE ABOVE TEST
	JSR PC,DCMD
	MOV FLOPTR,A
	MOV A,FLOPRT
	JSR PC,CMD2		;SEEK TO TRACK	
	JSR PC,GETST		;GET STATUS OF THE SEEK
FLPSE2:	RTS PC
FLPSE3:	CLZ
	RTS PC

;ROUTINES TO INTRACT WITH THE DISK ON A LOW LEVEL

;GET THE STATUS OF THE SELECTED DISK
REQST:	MOV #SMSSTS,A	;GET STATUS
	JSR PC,DCMD	;ISSUE REQUEST FOR STATUS
	JSR PC,CMD2	;SECOND BYTE IGNORED
	JSR PC,GETST	;GET THE STATUS
			;IF WE GET BACK WITHOUT ERROR IT WILL BE DISK STATUS
	RTS PC

;ISSUE THE FIRST COMMAND BYTE (IN A), ORING IN THE DISK NUMBER
DCMD:	SAVE A		;SAVE THE COMMAND BYTE
	MOV (F),A	;GET THE CSR
	BIC #-<SMSFDO!SMSCMW!SMSDNE!SMSBSY!SMSXFW>-1,A	;CLEAR USELESS BITS
	CMP #SMSCMW!SMSDNE,A	;IS IT IN A GOOD STATE?
	BEQ 1$
	TYPE <CONTROLLER NOT IN GOOD STATE TO GET COMMAND
>
	JSR PC,FLOPER
	HALT
1$:	MOV WCHDSK,A
	ASH #3,A
	BIS (P)+,A
	MOV A,SMSCMD	;GIVE COMMAND
	RTS PC

;ISSUE THE SECOND BYTE OF A COMMAND
CMD2:	SAVE <A,B>		;SAVE THE COMAND BYTE
	MOV #20,B
2$:	MOV (F),A	;GET THE CSR
	BIC #-<SMSFDO!SMSCMW!SMSDNE!SMSBSY!SMSXFW>-1,A	;CLEAR USELESS BITS
	CMP #SMSCMW,A	;IS IT IN A GOOD STATE?
	BEQ 1$
	SOB B,2$
	TYPE <CONTROLLER NOT READY FOR SECOND BYTE
>
	JSR PC,FLOPER
	HALT
1$:	REST <B,SMSCMD>	;GIVE IT THE BYTE
	RTS PC

GETST:	CLR A	;TO TIME OUT
1$:	BIT #SMSST1!SMSST0,(F)	;STATUS AVAILABLE?
	BNE 2$
	SOB A,1$
	TYPE <TIMED OUT WAITING FOR STATUS
>
	JSR PC,FLOPER
	HALT
2$:	BIT #SMSERR,(F)	;ERROR?
	BNE 3$		;YUP
	BIT #SMSXFW,(F)	;WAITING TO TRANSFER?
	BNE 4$
	TYPE <STATUS AVAILABLE BUT NOT WAITING FOR XFR????
>
	JSR PC,FLOPER
	HALT
4$:	MOV SMSDBF,A	;GOBBLE STATUS
	CLZ
	RTS PC

3$:	JSR PC,ERRGBL	;GOBBLE ERROR STATUS
	JSR PC,FLOPER
	SEZ
	RTS PC

ERRGBL:	BIT #SMSST1!SMSST0,(F)	;ANYTHING THERE?
	BEQ ERRGB1		;NOPE, KEEP OLD ERROR
	MOVB 1(F),A		;GET NEW ERROR TYPE
	BIC #177774,A		;FLUSH EXTRA STUFF
	MOV A,ERRST
	BIT #SMSXFW,(F)		;WAITING FOR XFR?
	BNE 1$
	TYPE <STATUS AVAILABLE BUT NOT WAITNG FOR XFR????
>	
	JSR PC,FLOPER
	HALT			;TO AVOID RECURSIVE LOOP
1$:	MOV SMSDBF,ERRDAT
ERRGB1:	RTS PC

;GENERAL ERROR PRINTOUT ROUTINE
FLOPER:	SAVE <A,B,C,D,E,F>
	TYPE <
ERROR CSR: >
	MOV SMSCSR,A
	JSR PC,PRONL
	TYPE < TRK: >
	MOV FLOPTR,A
	JSR PC,PRONB
	TYPE < SEC: >
	MOV FLOPSC,A
	JSR PC,PRONB
	JSR PC,ERRGBL	;GOBBLE UP THE ERROR STATUS IS THERE IS ONE
			;OTHERWISE LEAVE BEHIND THE OLD STATUS	
	TYPE < ETYP: >
	MOV ERRST,A	;THE BITS THAT GIVE THE TYPE OF ERROR
	TYPE < EDAT: >
	JSR PC,PRONB
	MOV ERRDAT,A
	JSR PC,PRONB
	TYPE <
>
	MOV ERRST,A
	ASL A
	JMP @.+4(A)
	NOERR
	CMDERR
	DRVERR
	OPERR

NOERR:	TYPE <  NO ERROR AVAILABLE
>
	JMP FLOPE1

CMDERR:	TYPE < CMD ERR: >
	BIT #SMSITA,ERRDAT
	BEQ 1$
	TYPE <INVALID TRACK  >
1$:	BIT #SMSISA,ERRDAT
	BEQ 2$
	TYPE <INVALID SECTOR  >
2$:	BIT #SMSIBS,ERRDAT
	BEQ 3$
	TYPE <INVALID BUFFER SPEC>
3$:	TYPE <
>
	JMP FLOPE1

DRVERR:	TYPE < DRIVE ERROR: >
	BIT #SMSDNR,ERRDAT
	BEQ 1$
	TYPE <DRIVE NOT READY  >
1$:	BIT #SMSDUS,ERRDAT
	BEQ 2$
	TYPE <DRIVE UNSAFE  >
2$:	BIT #SMSDWP,ERRDAT
	BEQ 3$
	TYPE <WRITE PROTECTED  >
3$:	BIT #SMSNAM,ERRDAT
	BEQ 4$
	TYPE <NO ADDRESS MARKS  >
4$:	BIT #SMSSIP,ERRDAT
	BEQ 5$
	TYPE <SEEK IN PROGRESS>
5$:	TYPE <
>
	JMP FLOPE1

OPERR:	TYPE <OP ERROR:  >
	BIT #SMSRWA,ERRDAT
	BEQ 1$
	TYPE <READ/WRITE ABORT  >
1$:	BIT #SMSHPE,ERRDAT
	BEQ 2$
	TYPE <HEAD POS ERR  >
2$:	BIT #SMSDAM,ERRDAT
	BEQ 3$
	TYPE <DATA ADDRESS MARK MISSING  >
3$:	BIT #SMSDOV,ERRDAT
	BEQ 4$
	TYPE <OVERRUN  >
4$:	BIT #SMSSUR,ERRDAT
	BEQ 5$
	TYPE <SECTOR UNRECOVERABLE  >
5$:	BIT #SMSCRC,ERRDAT
	BEQ 6$
	TYPE <CRC ERR  >
6$:	BIT #SMSRWC,ERRDAT
	BEQ 7$
	TYPE <READ/WRITE COMPLETE  >
7$:	BIT #SMSDDR,ERRDAT
	BEQ 8$
	TYPE <DELETED DATA>
8$:	TYPE <
>

FLOPE1:	REST <F,E,D,C,B,A>
	RTS PC


;GENERAL PRINT NUMBER ROUTINE
;CALL WITH A CLEAR, NUMBER TO BE PRINTED IN B
;MINIMUM NUMBER OF DIGITS TO PRINT IN C
;AND RADIX TO PRINT IN (=< 10.) IN D
PRN:	DIV D,A
	SAVE <B,#PRNDIG>
	MOV A,B
	CLR A
	DEC C
	BGT PRN
	TST B
	BNE PRN
	RTS PC		;RETURN TO PRNDIG

PRNDIG:	REST D		;DIGIT TO PRINT
	ADD #60,D
	SAVE A
	MOV D,A
	JSR PC,TYO
	REST A
	RTS PC
	
;PRINT A DECIMIAL NUMBER IN B
PRDN:	SAVE <A,B,C,D>
	MOV #10.,D
	CLR A
	CLR C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC

PRONL:	SAVE <A,B,C,D>
	MOV #8.,D
	MOV A,B
	CLR A
	MOV #6,C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC

PRONB:	SAVE <A,B,C,D>
	MOV #8.,D
	MOV A,B
	CLR A
	MOV #3,C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC



;SEARCH THE DIRECTORY FOR THE FILE POINTED
;TO BY THE FNB IN B
;RETURN IN A A POINTER TO WHERE WE SHOULD PUT A NEW FILE OF THIS NAME,
;AND IN B A POINTER TO THE "EXACT" MATCH IF ONE WAS FOUND.
;IF THE FNB HAS NO VERSION NUMBER OR A SPECIFIC VERSION NUMBER,
;THEN THE DIRECTORY ENTRY MUST HAVE THE SAME FOR AN EXACT MATCH
;IF THE FNB HAS < FOR A VERSION NUMBER, THE FIRST FILE
;WITH A VERSION NUMBER IS AN EXACT MATCH. IF THE FNB HAS
;> AS A VERSION NUMBER, THEN THE LAST FILE WITH THE RIGHT
;NAME AND A VERSION NUMBER IS AN EXACT MATCH. NOTE THAT
;> AND < NEVER EXACT MATCH TO A FILE WITH NO VERSION NUMBER,
;AND A FILE WITH NO VERSION NUMBER NEVER EXACT MATCHES A FILE
;WITH ONE
;THE VERSION NUMBER OF THE EXACT MATCH IS RETURNED IN C
;AND Z IS SET IF NO EXACT MATHC IS FOUND
;CRETURNS WITH POINTER TO ENTRY IN B, IF FOUND
DIRSER:	JSR F,ACSAV
	CLR 2(P)	;RETURNED B
	MOV B,E		;COPY FNB POINTER
	MOV #1,FNBFNO(E)	;FIRST FILE (WE SKIP THE SELF ENTRY)
	MOV #DIR,A
	MOV EOFOFF(A),F	;POINTER TO END OF DIRECTORY
	ADD A,F		;REAL END POINTER NOW
	MOV (A),B	;FIRST WORD OF SELF ENTRY
	INC B		;ROUND OFF BYTE COUNT
	BIC #177401,B	;BYTE COUNT
	ADD B,A		;SKIP SELF
;AND THEN SKIP THE PARENT ENTRY TOO
DIRSE1:	INC FNBFNO(E)	;NEXT FILE
	MOV (A),B	;GET FIRST WORD OF ENTRY
	INC B		;ROUND OFF BYTE COUNT
	BIC #177401,B	;GET BYTE COUNT
	ADD B,A		;GO TO NEXT ENTRY
	MOV A,(P)	;SAVE FOR CALLER
	CMP A,F		;ARE WE AT OR PAST THE END?
	BHIS DIRSE2	;YUP, RETURN TO CALLER
	JSR PC,NAMCMP	;COMPARE THE FILE NAMES
	BGT DIRSE1	;HAVEN'T GONE FAR ENOUGH YET
	BLT DIRSE2	;WE'VE GONE TOO FAR
	MOV FNBVER(E),D	;MATCHED FILE NAMES, GET VERSION FROM FNB
	INC D		;WAS IT NO VERSION?
	BGE DIRSE4	;YES, OR POSITIVE VERSION
	CMP #-1,C	;NO VERSION ON THE DIR ENTRY?
	BEQ DIRSE1	;THEN IT CAN'T MATCH < OR >
	MOV A,2(P)	;THIS A REAL MATCH FOR <, AND A POSSIBLE FOR >
	MOV C,4(P)	;SO SAVE IT
	INC D		;WAS IT >?
	BEQ DIRSE1	;SEE IF WE CAN FIND A BIGGER ONE
DIRSE2:	CMP #-2,FNBVER(E)	;IS IT >?
	BNE 1$		;NOPE
	DEC FNBFNO(E)	;CORRECT FILE NUMBER
1$:	JSR F,ACRES	;RESTORE THE CLOBBERED RESGISTERS
	TST B		;SET Z IF NO EXACT MATCH
	RTS PC
DIRSE4:	DEC D		;COMPENSATE FOR TEST
	CMP D,C		;BOTH HAVE VERSIONS OR NO VERSION
	BGT DIRSE1	;FNB VERSION > FOUND VERSION, KEEP TRYING	
	BLT DIRSE2	;FNB VERSION < FOUND, GIVE UP
	MOV A,2(P)	;EXACT MATCH
	MOV C,4(P)	;PREPARE TO RETURN
	BR DIRSE2
;COMPARE THE NAME IN A FNB WITH THE NAME IN A DIRECTORY AN DECIDE
;IF THEY ARE GREATER, EQUAL OR LESS
;POINTER TO FNB IS IN E, POINTER TO DIR IS IN A
NAMCMP:	SAVE <#0,A,B,E>
	MOV A,B		;COPY DIRECTORY POINTER
	ADD #FNBFN,E	;POINT TO FILE NAME IN FILE NAME BLOCK
	MOV VEROFF(A),C	;GET VERSION NUMBER TO RETURN TO CALLER
	ADD #NAMOFF,A	;POINT TO POTENTIAL NAME
	BIT #MFEOFB,(B)	;ARE THERE TIEM DATE ETC?
	BEQ 1$		;NOPE
	ADD #10,A	;SKIP STUFF
1$:	BIT #MFACCB,(B)	;ACCESS CODES?
	BEQ NAMCM2	;NOPE
NAMCM1:	ADD #3,A	;SKIP ONE SET OF CODES
	TSTB -1(A)	;LAST?
	BLT NAMCM1	;KEEP GOING
NAMCM2:	CMPB (A)+,(E)+	;COMPARE CHARACTERS
	BNE NAMCM3	;NOT EQUAL, GO FINISH UP
	TSTB -1(A)	;DID THEY BOTH END?
	BGE NAMCM2	;NOPE
NAMCM4:	REST <E,B,A>
	TST (P)+	;SET CONDITION CODES
	RTS PC
NAMCM3:	MOVB -(A),A	;GET LAST CHAR FROM DIRECTORY
	MOV A,B		;COPY IT
	MOVB -(E),E	;GET LAST FROM FNB
	BIC #177600,A	;FLUSH CRAP
	BIC #177600,E	;LIKEWISE
	DEC 6(P)	;ASSUME FNB IS LESS
	CMP E,A		;WHICH IS GREATER?
	BLT NAMCM4	;ASSUMED RIGHT	
	BGT NAMCM5	;DIRETORY IS LESS
	TST B		;TEST SIGN EXTENDED DIRECTORY CHARACTER
	BGE NAMCM4	;DIRETORY ENDED FIRST, FNB IS BIGGER
NAMCM5:	MOV #1,6(P)	;DIRECTORY ENTRY IS SMALLER THAN FNB
	BR NAMCM4

ACSAV:	SAVE <E,D,C,B,A>
	JMP (F)

ACRES:	TST (P)+
	REST <A,B,C,D,E>
	RTS F


DIR:	.BLKW 512.	;PLACE TO STORE DIRECTORY
BITS:	.BLKW 100.	;PLACE TO STORE BIT TABLE
BITSE::

;READ BIT TABLE, GET CURRENT DIR INTO DIR BUFFER
DINIT:	MOV #46,CURDIR	;SET TO ROOT
	MOV #-1000,TRNSLE
	MOV #BITBLK,B
	JSR PC,LOOKFL
1$:	CLR A		;BLOCK ZERO
	JSR PC,GETBLK	;GET DISK BLOCK NUMBER
	MOV B,BLOKNO
	MOV B,BITBNO	;SAVE FOR LATER WRITING OUT
	MOV #DIR,B
	JSR PC,DSKRED
	MOV #DIR,A
	MOV #BITS,B
	MOV (A),C
	MOV (A)+,(B)+
2$:	MOV (A)+,(B)+
	CMP B,#BITSE
	BLO 3$
	TYPE <Bit table too long>
	JMP RSTART
3$:	SUB #16.,C
	BGE 2$
	MOV #DEFALT,A
4$:	MOV #FNBBLK,B	;USE THE REGULAR BLOCK
	JSR PC,FNBSET	;SET IT UP
	BEQ 5$	;AT END OF DEFAULT STRING THEN
	SAVE A
	JSR PC,LOOKFL	;LOOK IT UP
	MOV ENTRY,B
	BIC #170777,B
	CMP #MFDIRE,B
	BEQ 9$
	TYPE <Entry not a directory>
	JMP RSTART
9$:	CLR A		;BLOCK ZERO
	JSR PC,GETBLK
	MOV B,CURDIR	;SET IT UP AS CURRENT DIR
	REST A
	BR 4$	;GO TRY FOR MORE
5$:	MOV CURDIR,BLOKNO
	MOV #DIR,B
	JSR PC,DSKRED	;READ IN THE ROOT DIR
	RTS PC		;WE'VE GOT WHERE WE'RE GOING

DSKRED:	MOV #DISKRD,DISKIO
	JMP DSKBLK

DSKWRT:	MOV #DISKWR,DISKIO
	JMP DSKBLK

GETBLK:	JSR F,ACSAV
	MOV A,B
	MOV #ENTRY,A
	MOV (A),C
	BIC #177400,C
	ADD A,C
	MOV C,ENTRYE
	MOV (A),C
	ADD #4,A
	BIT #MFEOFB,C
	BEQ 1$
	ADD #10,A
1$:	BIT #MFACCB,C
	BEQ 3$
2$:	ADD #2,A
	TSTB (A)+
	BLT 2$
3$:	TSTB (A)+
	BGE 3$
	MOV #-1,E
GETLOP:	INC E
	CMP A,ENTRYE
	BLO 1$
	MOV #-1,E
	BR GTGOT
1$:	MOVB (A)+,C
	MOV C,D
	BIC #177700,D
	BIC #177477,C
	ASH #-5,C
	JMP @.+4(C)
	GTSKIP
	GTGET
	GTSET
	GTSKG

GTSKIP:	ADD D,E		;SKIP
	CLR F	;GRAB ONE
	BR GTGRBN

GTGET:	MOV D,F
GTGRBN:	DEC B
	BLT GTGOT
	DEC F
	BLT GETLOP
	INC E
	BR GTGRBN

GTSET:	MOV D,F
	MOVB (A)+,E
	SWAB E
	BIC #377,E
	BISB (A)+,E
	SWAB E
	BR GTGRBN

GTSKG:	MOV D,F
	ASH #-3,D
	ADD D,E
	BIC #70,F
	BR GTGRBN

GTGOT:	MOV E,2(P)
	JSR F,ACRES
	RTS PC

LOOKUP:	JSR F,ACSAV
	MOV CURDIR,BLOKNO
	MOV #DIR,B
	JSR PC,DSKRED	;READ IN THE CURRENT DIRECTORY
	MOV 2(P),B	;GET BACK THE FNB POINTER
	JSR PC,DIRSER	;SEARCH THE DIRECTORY
	MOV C,4(P)	;VERSION NUMBER TOO
	MOV B,2(P)	;RETURN RESULT TO CALLER
	BEQ LOOKU1		;SEARCH FAILED
	JSR PC,COPENT	;COPY ENTRY INTO ENTRY
LOOKU1:	JSR F,ACRES
	TST B
	RTS PC

;COPY ENTRY POINTED TO BY B TO ENTRY
COPENT:	SAVE <A,B,C>
	MOV #ENTRY,A	;COPY TO ENTRY
	MOV (B),C	;HEADER WORD
	ADD #2,C
	BIC #177400,C
2$:	MOVB (B)+,(A)+
	SOB C,2$
	REST <C,B,A>
	RTS PC

FNBSET:	JSR F,ACSAV
1$:	MOVB (A)+,C	;GET CHAR FROMM SOURCE STRING
	BEQ FNBSE1	;END OF STRING
	CMP #40,C	;SPAVE?
	BEQ 1$	;IGNORE IT
	MOV #-1,D	;NO VERSION NUMBER YET
	ADD #FNBFN,B	;POINTER TO FILE NAME
	MOV B,F		;SAVE A COPY
2$:	CMP #'#,C	;VERSION NUMBER?
	BEQ FNBSEN
	CMP #'>,C	;GREATEST?
	BEQ FNBSEG
	CMP #'<,C	;LEAST?
	BEQ FNBSEL
	CMP #' ,C	;END OF NAME?
	BEQ FNBSEE
	MOVB C,(B)+	;SAVE IT AWAY
	MOVB (A)+,C	;GET NEXT ONE
	BNE 2$		;PROCESS UNLESS IT IS END
FNBSEE:	MOV D,FNBVER-FNBFN(F)	;SAVE VERSION NUMBER
	CMP B,F		;ANY CHAR IN NAME?
	BNE 1$
	TYPE <Null name>
	JMP RSTART
1$:	BISB #200,-(B)	;SET END MARKER
	DEC A
	MOV A,(P)	;INDICATE WHAT'S BEEN PROOCESSED
	JSR F,ACRES
	CLZ		;NOT DONE YET
	RTS PC

FNBSE1:	JSR F,ACRES
	SEZ		;NOTHING LEFT
	RTS PC

FNBSEG:	MOV #-2,D	;VERSION NUMBER
	BR FNBSEX
FNBSEL:	MOV #-3,D	;LEAST VERSION
FNBSEX:	TSTB (A)	;END OF STRING?
	BEQ FNBSEE	;YUP, OK
	CMPB #40,(A)	;END OF NAMEZ?
	BEQ FNBSEE	;YES, OK
	TYPE <^/< or > not last char in name>
	JMP RSTART

FNBSEN:	CLR D
1$:	MOVB (A)+,C
	BEQ FNBSEE	;END OF VERSION #
	CMP #40,C
	BEQ FNBSEE	;END OF #
	SUB #60,C	;CONVERT
	BLT 2$		;LOSER
	CMP #9.,C
	BLT 2$
	MUL #10.,D
	ADD C,D
	BR 1$

2$:	TYPE <Bad version number>
	JMP RSTART

LOOKFL:	SAVE B
	JSR PC,LOOKUP
	BNE 1$		;IT WORKED, GO WIN
	REST B
	JSR PC,FNBTYP	;GO TYPE FILE NAME
	TYPE <  not found>
	JMP RSTART
1$:	TST (P)+
	RTS PC

FNBTYP:	JSR F,ACSAV
	ADD #FNBFN,B
1$:	MOVB (B)+,A
	BLT 2$		;LAST CHAR?
	JSR PC,TYO	;TYOE ONE
	BR 1$	;GO GET NEXT
2$:	JSR PC,TYO	;TYPE LAST ONE
	MOV 2(P),B	;GET POINTER BACK
	MOV FNBVER(B),B	;GET VERSION NUMBER
	CMP #-1,B	;NONE?
	BEQ 3$		;DONE THEN
	MOV #'>,A
	CMP #-2,B
	BEQ 4$
	MOV #'<,A
	CMP #-3,B
	BEQ 4$
	MOV #'#,A
	JSR PC,TYO
	JSR PC,PRDN
3$:	JSR F,ACRES
	RTS PC
4$:	JSR PC,TYO
	BR 3$

SETDIR:	JSR PC,DSKNUM
	TYPE <
Default dir:  >
	MOV #DEFALT,B
	JSR PC,STRING
	JSR PC,DISKON	;TEST THAT WE HAVE A FLOPPY DISK
	JSR PC,DINIT	;GO CHECK IT OUT
	JMP RSTART



FILDIR:	JSR PC,DISKON
	JSR PC,DINIT
	MOV #DIR,F
	MOV F,E
	ADD 6(E),F	;GET THE END POINTER FOR THE DIR
FILDI1:	TYPE <
>
	MOV E,D		;COPY POINTER TO CURRENT ENTRY
	MOV (D)+,B	;GET FLAG WORD
	MOV B,C
	BIC #170777,C	;CLEAR NONSENSE
	ASH #-8.,C
	JMP @.+4(C)
	FILPRP		;PARENT
	FILPRD		;DIR
	FILPRF		;FILE
	FILPRL		;LOSER
	FILPRS		;SELF
	FILPRL		;LINK (LOSER)
	FILPRL		;LOSER
	FILPRL		;LOSER

FILPRL:	TYPE <Bad entry
>
	JMP RSTART

FILPRP:	MOV (E),A
	INC A
	BIC #177401,A
	ADD A,E
	CMP E,F
	BLO FILDI1
	JMP RSTART

FILPRD:	TYPE <I >
FILPRS:	MOV (D)+,C	;SAVE VERN
	BIT #MFEOFB,B
	BEQ 1$
	ADD #10,D
1$:	BIT #MFACCB,B
	BEQ 3$
2$:	ADD #2,D
	TSTB (D)+
	BLT 2$
3$:	MOVB (D)+,A
	JSR PC,TYO
	TSTB A
	BGE 3$
	MOV C,B		;VERSION #
	BLT FILPRP
	MOV #'#,A
	JSR PC,TYO
	JSR PC,PRDN
	BR FILPRP
	
FILPRF:	TYPE <  >
	BR FILPRS


WRITEF:	JSR PC,DISKON
	JSR PC,DINIT
	JSR PC,FNG
	CMP #-3,FNBBLK+FNBVER	;<?
	BNE 3$
	TYPE ^/Can't create <, use # or >/
	JMP RSTART
3$:	JSR PC,LOOKUP	;DOES IT ALREADY EXIST?
	BEQ WRTF1	;NOPE, GO CREATE
	CMP #-2,FNBBLK+FNBVER	;>?
	BEQ 2$
	TYPE <
File already exists, delete first
>
	JMP RSTART
2$:	INC C
	MOV C,FNBBLK+FNBVER
	INC FNBBLK+FNBFNO
WRTF1:	CMP #-2,FNBBLK+FNBVER	;> AND NONE FOUND?
	BNE 1$
	MOV #1,FNBBLK+FNBVER	;YUP, SET IT TO 1
	INC FNBBLK+FNBFNO
1$:	MOV #ENTRY,A
	MOV #MFEOFB!MFFILE!414,(A)+	;BASIC INFO ABOUT FILE
	MOV FNBBLK+FNBVER,(A)+	;VERSION NUMBER
	CMP (A)+,(A)+		;SKIP EOF WORDS
	MOV #-1,(A)+		;CLEAR TIME+DATE
	MOV #-1,(A)+
	MOV #FNBBLK+FNBFN,A	;FILE NAME
	MOV #ENTRY+14,B	;GOES HERE
2$:	INC ENTRY		;KEEP LENGTH RIGHT
	MOVB (A)+,(B)+
	BGE 2$
	MOV TEND,A	;END OF THING WE'VE LOADED
	SUB #TSTART,A	;LENGTH OF THING
	MOV A,C		;COPY
	BIC #160000,C	;EXCESS OF 4K
	MOV C,ENTRY+6
	MOV A,C
	ASH #-13.,C
	BIC #177770,C	;4K'S
	MOV C,ENTRY+4
	ASR A		;NUMBER OF WORDS
	BIC #100000,A
	ADD #777,A	;ROUND UP
	BIC #777,A	;TO EVEN # OF BLOCKS
	NEG A
	MOV A,TRNSLE	;THIS WILL BE TRANSFER LENGTH
	NEG A
	ASH #-9.,A	;NUMBER OF BLOCKS
	MOV A,C
	DEC C
	BIS #200,C	;SET AND COUNT	
	MOVB C,(B)+	;NOW ALL WE NEED IS AN ADDRESS
	MOV #BITS+2,F
BITLOK:	MOV A,C		;NUMBER OF BLOCKS NEEDED
	MOV F,D		;SAVE START
1$:	TSTB (F)+	;8 FREE?
	BNE BITLOK	;NOPE, ABORT
	SUB #8.,C	;ENOUGH?
	BGE 1$		;NOPE

	SUB #BITS+2,F
	ASH #3,F	;CONVERT TO BLOCKS
	CMP F,BITS	;OVER END?
	BLT 2$
	TYPE <Not enough room
>
	JMP RSTART
2$:	MOV D,F
	MOV A,C
	ASH #-3,C
	BEQ 4$		;LESS THAN 8 BLOCKS
3$:	MOVB #377,(F)+
	SOB C,3$
4$:	MOV A,C
	BIC #177770,C
	BISB BMT(C),(F)+
	SUB #BITS+2,D
	ASH #3,D	;CONVERT BYTE NUMBER TO BLOCK NUMBER
	MOV D,BLOKNO	;NOW STUFF IS READY TO GO
	MOVB D,(B)+
	SWAB D
	MOVB D,(B)+
	ADD #3,ENTRY	;NOW ENTRY IS READY TO GO

DIRPUT:	MOV DIR+6,A	;DIR EOF
	MOV A,B		;COPY
	MOV ENTRY,C
	INC C
	BIC #177401,C	;ENTRY LENGTH
	ADD C,B		;NEW DIR END
	CMP #2000,B	;TOO LONG?
	BGT 4$
	TYPE <No room in dir
>
	JMP RSTART
4$:	MOV B,DIR+6	;NEW EOF
	ADD #DIR,A
	ADD #DIR,B
	MOV #DIR,D
	MOV FNBBLK+FNBFNO,E
5$:	MOV (D),F
	INC F
	BIC #177401,F
	ADD F,D
	SOB E,5$
	MOV B,F
	SUB C,F
6$:	CMP F,D
	BEQ 9$
	MOV -(F),-(B)
	BR 6$
9$:	ASR C
	MOV #ENTRY,F
7$:	MOV (F)+,(D)+
	SOB C,7$

;WHEW!

;NOW DIR IS READY TO GO TOO

	MOV #TSTART,B
	JSR PC,DSKWRT	;THE LENGTH WAS PREVIOUSLY SET
			;AS WAS THE BLOCK NUMBER
	MOV #-1000,TRNSLE	;NORMAL LENGTH
	MOV CURDIR,BLOKNO
	MOV #DIR,B
	JSR PC,DSKWRT	;WRITE OUT DIR
	MOV BITBNO,BLOKNO
	MOV #BITS,B
	JSR PC,DSKWRT	;WRITE OUT BIT TABLE
	JMP FILDIR

BMT:	.BYTE 0,1,3,7,17,37,77,177

FNG:	TYPE <
File name:  >
	MOV #NAMBUF,B
	JSR PC,STRING	;GO GET A STRING
	BEQ FNG	
	MOV #NAMBUF,A
	MOV #FNBBLK,B
	JSR PC,FNBSET
	BEQ FNG
	RTS PC

DELFIL:	TYPE <
Delete file!>
	JSR PC,DISKON
	JSR PC,DINIT
	JSR PC,FNG
	JSR PC,LOOKFL
	MOV B,A		;SAVE POINTER
	MOV (A),C	;GET HEADER WORD
	INC C
	BIC #177401,C
	MOV C,D
	ASR D
	MOV #ENTRY,F
1$:	MOV (A)+,(F)+
	SOB D,1$
	MOV DIR+6,F
	SUB C,DIR+6	
	MOV B,A		;POINTER TO ENTRY AGAIN
	ADD C,A		;POINT PAST ENTRY
	MOV DIR+6,C
	ADD #DIR,C
2$:	CMP B,C
	BEQ 3$
	MOV (A)+,(B)+	;COPY DOWN
	BR 2$		;GO TILL WE GET TO THE END
3$:	MOV #-1000,TRNSLE
	MOV CURDIR,BLOKNO
	MOV #DIR,B
	JSR PC,DSKWRT	;WRITE OUT THE NEW DIR
CLRBIT:	CLR A		;START WITH BLOCK ZERO
1$:	JSR PC,GETBLK	;GET REAL BLOCK NUMBER
	TST B
	BLT 2$		;DONE
	MOV B,C
	CLR D
	ASHC #-3,C
	ASH #-13.,D
	BIC #177770,D
	BICB BITTB(D),BITS+2(C)
	INC A
	BR 1$
2$:	MOV #BITS,B
	MOV BITBNO,BLOKNO
	JSR PC,DSKWRT
	JMP RSTART
BITTB:	.BYTE 1,2,4,10,20,40,100,200

READF:	CLR BOOTIN
	JSR PC,DISKON
	JSR PC,DINIT
	JSR PC,FNG
	JSR PC,LOOKFL
	MOV ENTRY+6,B	;LOW ORDER PART OF LENGTH
	ASH #3,B	;MUNG
	MOV ENTRY+4,A	;HIGH ORDER PART
	ASHC #-3,A	;GET COUNT IN BYTES
	TST A		;SHOULD BE NO HIGH PART
	BNE 1$
	MOV B,A
	ADD #TSTART,A	;GET END
	BCS 1$		;OVER THE TOP
	CMP A,MEMTOP
	BLO 2$		;OK, IT FITS
1$:	TYPE <
Sorry, program too long to fit
>
	JMP RSTART
2$:	MOV A,TEND
	CLR A		;BLOCK COUNTER
	MOV #TSTART,F	;CORE COUNTER
	MOV #-1000,TRNSLE
3$:	JSR PC,GETBLK	;GET BLOCK NUMBER
	MOV B,BLOKNO
	MOV F,B
	JSR PC,DSKRED	;READ IN BLOCK
	INC A		;NEXT BLOCK
	ADD #2000,F
	CMP F,TEND	;PAST THE END?
	BLOS 3$		;NOPE
	JMP RSTART

REDBTF:	JSR PC,DISKON
	MOV #-4000,TRNSLE	;JUST ONE TRACK
	CLR BLOKNO
	MOV #TSTART,B
	JSR PC,DSKRED
	MOV PC,BOOTIN
	MOV #111111,TSTART+40	;RESTORE THE FLAG
	JMP RSTART

TSTART:
.MACRO PRAD A,B
	.PRINT /A'B/
.ENDM
.IIF P2, PRAD <END=>,\TSTART
	.END START
