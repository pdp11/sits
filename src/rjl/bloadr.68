.TITLE FLOPPY DISK LOADER
VERNUM==%FNAM2
.INSRT SITS;SITMAC >
.INSRT RJL;FLOPDF >

.MACRO TYPE STRING
	JSR F,TYPES
	.ASCIZ /STRING/
	.EVEN
.ENDM

TKS==177560
TKB==TKS+2
TPS==TKB+2
TPB==TPS+2

;DEFINITIONS FOR SITS FILE SYSTEM
FILTYP==2000
DIRTYP==1000

EOFB==100000
ACCB==40000
LSTB==400

VERN==2



.REPT 60
	.+2
	HALT
.ENDR
.=0
	240
	BR 300
.=40
BOOTNM:	111111		;THIS IS WHERE THE FILE NAME GETS STORED
			;FOR AUTO LOAD ON BOOT
.=300
	JMP START	;FOR RESTART
	JMP DUMPME	;START HERE TO DUMP BOOT TO DISK

PAT:	.BLKW 200
DISKN:	0



START:	RESET
	CLR SMSLGT	;TURN OUT THE LIGHTS AS YOU COME IN
	MOV #PDL,P
	MOV #MEMCHK,4
	CLR A
1$:	TST (A)+
	BR 1$

MEMCHK:	TST -(A)
	MOV A,TOPPNT	;REAL TOP
	SUB #40,A	;FOR DDT
	MOV A,MEMTOP	;LAST LOCATION THAT DOESN'T GIVE ERROR
	MOV #PDL,P
	MOV #6,4

;NOW, ARE WE LOADED FROM THE DISK OR FROM PAPER TAPE?
	CMP #111111,BOOTNM	;MAGIC MARKER
	BNE 1$		;IF NOT = WE WERE LOADED FROM DISK
	JMP DUMPME	;LOADED FROM TAPE, MAYBE DUMP TO DISK
1$:	MOV #LOADNM,B	;POINTER TO NAME TO LOAD
	MOV @TOPPNT,A	;POINTER TO FILE NAME IF THIS IS
			;A MAGIC CHAIN LOAD
	BEQ 2$
3$:	CMP A,TOPPNT	;AVOID NON EX ERROR
	BHIS 2$		;IGNORE PASSED NAME IF IT IS A LOSER
	MOVB (A)+,(B)+
	BNE 3$
	CMP #LOADNM+1,B	;WAS THERE A NON-NULL NAME?
	BEQ 2$		;NOPE
	BR LOADFL	;GO LOAD IT
2$:	MOV #BOOTNM,A
	TSTB (A)		;IS THERE A FILE TO AUTO BOOT?
	BNE 3$		;YUP, GO DO THAT

NAMGT:	MOV #PDL,P
	BIS #SMSRSB,SMSCSR	;RESET CONTROLLER TO UNLOAD HEAD
	BIC #SMSPWR,SMSCSR	;LET IT REST
	TYPE <BLOADR.>
	MOV #VERNUM,B
	JSR PC,PRDN
	TYPE <
What would you like to load?  >
	MOV #LOADNM,F
NAMLOP:	JSR PC,TYI	;GET AND ECHO A CHAR
	CMP #15,A	;CR?
	BEQ NAMEGE	;END OF NAME
	CMP #177,A	;RUB OUT?
	BEQ NAMRB
	MOVB A,(F)+
	BR NAMLOP

NAMRB:	CMP #LOADNM,F
	BEQ NAMGT
	MOVB -(F),A
	JSR PC,TYO
	BR NAMLOP

NAMEGE:	TYPE <
>
	CMP #LOADNM,F
	BEQ NAMGT
	CLRB (F)
;FALL IN TO LOADFL

;FALLS IN FROM GOBBLING THE NAME
LOADFL:	CLR BOOTNM		;TO PREVENT INFINITE LOSSAGE
	CLR @TOPPNT		;LIKEWISE
	JSR PC,DISKON
	MOV #LOADNM,F
1$:	MOVB (F)+,A
	BEQ 2$
	CMPB (F),#';
	BNE 1$	
	BIC #177600,A
	SUB #60,A
	BLT BADNM
	CMP #4,A
	BLE BADNM
	MOV A,DISKN
	MOV #46,DIR
	BR 9$			;SINCE HE TYPED N; DON'T SEARCH FOR .
2$:	MOV #46,DIR
	MOVB #'.+200,FILEN	;LOOK FOR THE . DIR
	MOV #-1,FILNUM		;WITH NO VERSION #
	JSR PC,LOOKUP
	BNE 8$
	TYPE <. dir not found
>
	BR 9$
8$:	MOV CURBLK,DIR
9$:	MOV #LOADNM,F	;THE NAME STRING
LOADNX:	MOV #FILEN,E	;PLACE TO COPY FILE NAME TO
	MOV #-1,FILNUM	;NO NUMBER
1$:	MOVB (F)+,A
	BNE 2$
	TYPE <No name????
>
	JMP NAMGT
2$:	CMP #40,A
	BEQ 1$
3$:	BICB #200,-1(E)
	BIS #200,A
	MOVB A,(E)+
	MOVB (F)+,A
	BEQ LOADF
	CMPB #40,A
	BEQ LOADD
	CMPB #';,A
	BEQ LOADRT
	CMPB #'#,A
	BEQ LOADNU
	CMP #'>,A
	BEQ LOADGT
	CMP #'<,A
	BEQ LOADLT
	BR 3$

LOADRT:	MOVB -(E),A
	BR LOADNX	;PROCESS NEXT PART OF STRING

BADNM:	TYPE <Bad file name
>
	JMP NAMGT


LOADGT:	MOV #-2,FILNUM
	BR LOADL1

LOADLT:	MOV #-3,FILNUM
LOADL1:	TSTB (F)
	BEQ LOADF
	CMPB #40,(F)
	BNE BADNM
LOADD:	TSTB (F)	;AT END OF STRING?
	BEQ LOADF	;YUP, LOAD A FILE
1$:	CMPB #40,(F)	;SPACE NEXT?
	BNE LOADD1
	INC F
	BR LOADD
LOADD1:	JSR PC,LOOKUP
	JSR PC,CHKFND
	CMP #DIRTYP,ETYPE	;IS IT A DIR?
	BEQ 1$
	JSR PC,TYPNAM
	TYPE < is not a directory.
>
	JMP NAMGT
1$:	MOV CURBLK,DIR	;SET DIRECTORY
	JMP LOADNX

LOADNU:	CLR B
LOADN1:	MOVB (F)+,A
	BEQ LOADN2
	CMP #40,A
	BEQ LOADN3
	SUB #60,A
	BLT BADNM
	CMP #9.,A
	BLT BADNM
	MUL #10.,B
	ADD A,B
	BR LOADN1
LOADN2:	MOV B,FILNUM
	BR LOADF
LOADN3:	MOV B,FILNUM
	BR LOADD



LOADF:	JSR PC,LOOKUP
	JSR PC,CHKFND
	CMP #FILTYP,ETYPE	;IS IT A FILE?
	BEQ 1$
	TYPE <That's not a file...
>
	JMP NAMGT
1$:	;;LOOK FOR BEG OF A BLOCK
	CLR BUFCNT	;THERE ARE NO VALID BYTES IN THE BUFFER
	CLR LASTB
	MOV #PROG,A
2$:	CLR (A)+
	CMP A,MEMTOP
	BNE 2$
D.LD2:	CLR A
	JSR PC,READC
	DECB B
	BNE D.LD2
BABSFN:	MOV #1,A	;SET CHECKSUM
D.LD24:	JSR PC,READC	;IGNORE ZERO
	JSR PC,D.GWRD
	MOV E,D
	SUB #4,D
	CMP #2,D
	BEQ D.JMP
	JSR PC,D.GWRD
	MOV E,C

D.LD3:	JSR PC,READC
	BGE D.LD4
	TSTB A
	BEQ D.LD2
D.BAD:	TYPE <Checksum error!
>
	JMP NAMGT
D.LD4:	MOVB B,PROG(C)
	INC C
	CMP C,MEMTOP
	BLO 2$
	TYPE <Program is too large to load.
>
	JMP NAMGT
2$:	CMP C,LASTB
	BLOS 1$
	MOV C,LASTB
1$:	BR D.LD3

D.JMP:	JSR PC,D.GWRD
	JSR PC,READC
	TSTB A
	BNE D.BAD
	BIS #SMSRSB,SMSCSR	;RESET CONTROLLER
	BIC #SMSPWR,SMSCSR	;AND TURN OFF DISK
;HERE WE HAVE TO BLT THE STUFF DOWN AND THEN START IT
	MOV MEMTOP,A
	SUB #LOOPL,A
	MOV A,B
	MOV #LOOP,C
	MOV #LOOPL/2,D
1$:	MOV (C)+,(B)+
	SOB D,1$
	JMP (A)		;GO START THE LOOP

;THIS IS MAGIC POSITION INDPENDANT CODE
LOOP:	MOV @#LASTB,A
	MOV #PROG,B
	CLR C
1$:	MOV (B)+,(C)+
	CMP C,A
	BLOS 1$
	JMP (E)
LOOPL==.-LOOP

D.GWRD:	JSR PC,READC
	MOV B,E
	JSR PC,READC
	SWAB B
	BIS B,E
	RTS PC

D.TMP:	.WORD 0

LOOKUP:	SAVE <A,B,C,D,E,F>
	MOV DIR,A
	MOV #DIRBUF,B
	JSR PC,DSKRED	;READ IN THE CURRENT DIRECTORY
	MOV #DIRBUF,A
	MOV 6(A),F	;LENGHT OF THE DIR
	ADD A,F		;THIS IS END OF THE DIR
	CLR E		;FLAG FOR FOUND FILE
	MOV (A),D	;LENGTH OF ENTRY
	INC D		;EVEN IT OUT
	BIC #177401,D
	ADD D,A
LOOKLP:	MOV (A),D
	INC D
	BIC #177401,D
	BEQ LOOKEN	;IF DIRECTORY IS A LOSER GIVE UP
	ADD D,A
	CMP #DIRBUF+2000,D	;ANOTHER LOSS CHECK
	BLOS LOOKEN	;RAN OFF THE END!
	CMP A,F
	BHIS LOOKEN
	MOV A,C
	MOV #FILEN,B
	ADD #VERN+2,C
	BIT #EOFB,(A)	;IS THERE TIME +DATE INFO THERE?
	BEQ 1$
	ADD #10,C
1$:	BIT #ACCB,(A)	;ACCESS CODES?
	BEQ 2$
3$:	ADD #3,C	;SKIP ONE SET
	TSTB -1(C)	;LAST?
	BLT 3$		;NOPE
2$:	CMPB (C)+,(B)+	;SAME?
	BNE LOOKLP	;NOPE, TRY NEXT ENTRY
	TSTB -1(B)	;END?
	BGE 2$		;NOPE
	CMP FILNUM,VERN(A)	;SAME VERSION #?
	BEQ LOKFND	;WIN!
	CMP #-1,VERN(A)	;VERSION # ON THIS FILE?
	BEQ LOOKLP	;NO, IGNORE
	CMP #-3,FILNUM	;LOOKING FOR <?
	BEQ LOKFND	;THEN THIS IS WHAT WE WANT
	CMP #-2,FILNUM	;LOOKING FOR >?
	BNE LOOKLP	;NOPE
	MOV A,E		;LOOKING FOR >, THIS MIGHT BE IT
	BR LOOKLP	;BUT TRY NEXT

LOOKEN:	MOV E,A		;DID WE FIND ANYTHING?
	BEQ LOKLOS	;LOST
LOKFND:	MOV A,B		;THIS IS THE WINNING ENTRY
	MOV (A),C	;LENGTH OF ENTRY
	BIC #170777,C
	MOV C,ETYPE
	MOV (A),C
	INC C
	BIC #177401,C
	ASR C
	MOV #ENTRY,D
1$:	MOV (A)+,(D)+	;COPY ENTRY
	SOB C,1$
	MOV #ENTRY,A	;POINTER TO ENTRY
	MOV A,B		;COPY
	ADD #VERN+2,B
	BIT #EOFB,(A)
	BEQ 2$
	ADD #10,B
2$:	BIT #ACCB,(A)
	BEQ 4$
3$:	ADD #3,B
	TSTB -1(B)
	BLT 3$
4$:	TSTB (B)+
	BGE 4$
	MOV B,ENTRYP	;POINTER INTO DESC PART OF ENTRY
	CLR BLOCKN	;BLOCK NUMBER WE ARE AT IN FILE
	JSR PC,GETDES	;GET COORESPONDING DISK BLOCK NUMBER
	REST <F,E,D,C,B,A>
	CLZ
	RTS PC

LOKLOS:	REST <F,E,D,C,B,A>
	SEZ
	RTS PC

CHKFND:	BNE 1$
	TYPE <Entry >
	JSR PC,TYPNAM
	TYPE < not found
>
	TST (P)+	;CRUFTY NON-LOCAL
	JMP NAMGT	;TRY ALL OVER AGAIN
1$:	RTS PC

TYPNAM:	SAVE <A,B>
	MOV #FILEN,B
1$:	MOVB (B)+,A
	JSR PC,TYO
	TSTB A
	BGE 1$
	REST <B,A>
	RTS PC

READC:	DEC BUFCNT
	BLT READC1
	MOVB @BUFPNT,B
	ADD B,A		;CHECKSUM
	INC BUFPNT	
	BIC #177400,B
	DEC D
	RTS PC

READC1:	SAVE <A,B>
	JSR PC,GETDES	;SET UP CURBLK
	MOV CURBLK,A
	MOV #DSKBUF,B
	JSR PC,DSKRED
	INC BLOCKN
	MOV #DSKBUF,BUFPNT
	MOV #2000,BUFCNT
	REST <B,A>
	BR READC

.IFZ 105	;FOR DEBUGGING ONLY
RKCS=177404
RKWC=177406
RKCA=177410
RKDA=177412
RKREAD==5
;CALL WITH DISK BLOCK NUMBER IN A
;CORE ADDRESS TO READ INTO IN B
;READS ONE BLOCK
;FOR THE MOMENT, THIS IS FOR THE RK11 (!)
DSKRED:	MOV #150000,MEMTOP	;KLUDGE FOR DEBUGGING WITH RUG
	MOV #-1000,RKWC
	MOV B,RKCA
	MOV A,B
	CLR A
	ASL B
	DIV #12.,A
	ASH #4,A
	BIS A,B
	MOV DISKN,A
	ASH #13.,A
	BIS A,B
	MOV B,RKDA
	MOV #RKREAD,RKCS
1$:	TSTB RKCS
	BPL 1$
	TST RKCS
	BGE 2$
	HALT
2$:	RTS PC
.ENDC

;READ A BLOCK FROM THE DISK
;DISK BLOCK NUMBER IN A, CORE ADDRESS IN B
;THIS IS THE VERSION FOR THE FLOPPY DISK
DSKRED:	SAVE <A,B,C,D,E,F>
	MOV B,TEMPCA	;SAVE CORE ADDRESS
	MOV B,F		;CORE ADDRESS SITS THERE
	MOV A,D		;COPY DISK ADDRESS
	ASH #3,D	;8 SECTORS PER BLOCK
	CLR C
	DIV #26.,C	;LEAVING TRACK IN C, SECTOR IN D
	INC D		;EXCEPT SECTORS ARE FUNNY HERE
	INC C		;AND SO ARE TRACKS
	MOV D,TEMPSC	;SAVE DISK ADDRESS
	MOV #8.,E	;COUNT OF SECTORS TO GET
DSKRE1:	JSR PC,SECMUN	;GET REAL SECTOR TO USE
	MOV #10.,NRETRY	;COUNT OF TIMES TO RETRY
DSKRE2:	MOV #SMSSEK,A
	JSR PC,DCMDWA
	MOV C,A
	JSR PC,CMDWAI	
	JSR PC,GETST
	BEQ DSKREE
	MOV #SMSRED!SMSDTB,A
	JSR PC,DCMDWA
	MOV REALSC,A
	JSR PC,CMDWAI
	JSR PC,GETST
	BEQ DSKREE
	MOV #SMSRED!SMSBTH,A
	JSR PC,DCMDWA
	JSR PC,CMDWAI
	MOV #128.,A
1$:	MOVB SMSDBF,(F)+
	SOB A,1$
	JSR PC,GETST
	BEQ DSKREB
	INC D
	CMP #27.,D	;GONE OVER THE TOP?
	BGT 2$		;NOPE
	MOV #1,D
	INC C
2$:	DEC E
	BEQ 9$
	JMP DSKRE1
9$:	REST <F,E,D,C,B,A>
	RTS PC

DSKREB:	SUB #128.,F
DSKREE:	JSR PC,ERRTYP	;TYPE OUT THE ERROR
	DEC NRETRY
	BGT DSKRE2
	TYPE <I give up!
>
	JMP START


SECMUN:	SAVE <A,B>
	MOV C,B			;NEW IS HARDER
	DEC B
	MUL #3,B		;SECTORS ARE OFFSET BY 6 FOR EACH TRACK
	CLR A
	ADD D,B
	DEC B
	DIV #13.,A
	ASL B
	INC B
	CMP #13.,D
	ADC B
	MOV B,REALSC
	REST <B,A>
	RTS PC



REALSC:	0
TEMPBE:	0
TEMPSC:	0
TEMPCA:	0

GETDES:	SAVE <A,B,C,D,E,F>
	MOV ENTRYP,A
	MOV BLOCKN,B
	MOV #-1,E
GETLOP:	INC E
	MOVB (A)+,C
	MOV C,D
	BIC #177700,D
	BIC #177477,C
	ASH #-5,C
	JMP @.+4(C)
	GTSKIP
	GTGET
	GTSET
	GTSKG

GTSKIP:	ADD D,E		;SKIP
	CLR F	;GRAB ONE
	BR GTGRBN

GTGET:	MOV D,F
GTGRBN:	DEC B
	BLT GTGOT
	DEC F
	BLT GETLOP
	INC E
	BR GTGRBN

GTSET:	MOV D,F
	MOVB (A)+,E
	SWAB E
	BIC #377,E
	BISB (A)+,E
	SWAB E
	BR GTGRBN

GTSKG:	MOV D,F
	ASH #-3,D
	ADD D,E
	BIC #70,F
	BR GTGRBN

GTGOT:	MOV E,CURBLK
	REST <F,E,D,C,B,A>
	RTS PC
DUMPME:	MOV #PDL,P
	JSR PC,DISKON		;POWER UP THE DISK
	TYPE <Do you want to write me onto the disk? >
	JSR PC,TYI
	TYPE <
>
	CMP #'Y,A
	BEQ 1$
	CLR BOOTNM
	JMP START
1$:	TYPE <
Name to auto load:  >
	MOV #BOOTNM,F
2$:	JSR PC,TYI
	CMP #15,A
	BEQ DUMPM1
	CMP #177,A
	BEQ 3$
	MOVB A,(F)+
	BR 2$

3$:	CMP #BOOTNM,F
	BEQ 1$
	MOVB -(F),A
	JSR PC,TYO
	BR 2$

DUMPM1:	CLRB (F)	;TERMINATOR
	TYPE <>
	MOV #1,SECTOR
	MOV #1,TRACK
5$:	TYPE <Disk number?>	
	JSR PC,TYI
	TYPE <
>	
	SUB #60,A
	BLT 5$
	CMP #4,A
	BLE 5$
	MOV A,DISKN
	CLR E	;PLACE WHERE CODE STARTS
;FALLS THOUGH TO NEXT PAGE
;FALLS IN
WLOOP:	MOV #10.,NRETRY
WRTSEC:	MOV #SMSSEK,A
	JSR PC,DCMDWA	;DO A SEEK ON THE RIGHT DISK
	MOV TRACK,A
	JSR PC,CMDWAI
	JSR PC,GETST
	BEQ WRTERR
	MOV #SMSHTB!SMSWRT,A
	JSR PC,DCMDWA	;HOST TO BUFFER TRANSFER, SECOND BYTE IGNORED
	JSR PC,CMDWAI
9$:	BIT #SMSXFW,SMSCSR
	BEQ 9$
	MOV #128.,D	;BYTES/SECTOR
1$:	MOVB (E)+,SMSDBF
	SOB D,1$
	JSR PC,GETST
	BEQ WRTERR
	MOV #SMSBTD!SMSWRT,A
	JSR PC,DCMDWA
	MOV SECTOR,A
	JSR PC,CMDWAI
	JSR PC,GETST
	BEQ WRTERR
	ADD #2,SECTOR
	CMP #27.,SECTOR
	BGT WLOOP
	BNE 2$
	MOV #2,SECTOR
	BR WLOOP		
2$:	TYPE <Well, that's done with
>
	JMP START


DISKON:	BIS #SMSRSB!SMSPWR,SMSCSR	;RESET CONTROLLER AND POWER DRIVES ON
	CLR A		;FOR TIMER
	MOV #30.,B	;ALSO
1$:	BIT #SMSFDO,SMSCSR	;IS IT RESET YET?
	BEQ 2$
	SOB A,1$	;WAIT
	SOB B,1$	;A LONG TIME
	TYPE <Disk won't power on or no disk in drive
>
	HALT
	BR DISKON
2$:	RTS PC


WRTERR:	JSR PC,ERRTYP
	JMP START

ERRTYP:	TYPE <Disk error: >
	MOV ERRCSR,B
	JSR PC,PRONL
	TYPE <  >
	MOV ERRST,B
	JSR PC,PRONB
	TYPE <
>
	RTS PC
	
DCMDWA:	SAVE A
	MOV DISKN,A
	ASH #3,A
	BIS (P)+,A
CMDWAI:	BIT #SMSCMW,SMSCSR
	BEQ CMDWAI
	MOV A,SMSCMD
	RTS PC

GETST:	BIT #SMSXFW,SMSCSR
	BEQ GETST
	TSTB SMSCSR	;IS DONE SET?
	BLT 1$		;YUP
	TYPE <Gulp, got to getst with smsxfw set and done not set!
>
	HALT
	JMP START
1$:	TST SMSCSR	;ERROR?
	BGT GETST1
	MOV SMSCSR,ERRCSR
	MOV SMSDBF,ERRST
	SEZ
	RTS PC

GETST1:	MOV SMSDBF,A
	CLZ
	RTS PC


	



NRETRY:	0
SECTOR:	0
TRACK:	0
ERRCSR:	0
ERRST:	0
;GENERAL PRINT NUMBER ROUTINE
;CALL WITH A CLEAR, NUMBER TO BE PRINTED IN B
;MINIMUM NUMBER OF DIGITS TO PRINT IN C
;AND RADIX TO PRINT IN (=< 10.) IN D
PRN:	DIV D,A
	SAVE <B,#PRNDIG>
	MOV A,B
	CLR A
	DEC C
	BGT PRN
	TST B
	BNE PRN
	RTS PC		;RETURN TO PRNDIG

PRNDIG:	REST D		;DIGIT TO PRINT
	ADD #60,D
	SAVE A
	MOV D,A
	JSR PC,TYO
	REST A
	RTS PC
	
;PRINT A DECIMIAL NUMBER IN B
PRDN:	SAVE <A,B,C,D>
	MOV #10.,D
	CLR A
	CLR C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC

PRONL:	SAVE <A,B,C,D>
	MOV #8.,D
	CLR A
	MOV #6,C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC

PRONB:	SAVE <A,B,C,D>
	MOV #8.,D
	CLR A
	MOV #3,C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC





TYI:	TSTB TKS
	BPL TYI
	MOV TKB,A
	BIC #177600,A
	CMP #'a,A	;LOWER CASE?
	BGT 1$		;NOPE
	CMP #'z,A
	BLT 1$
	SUB #40,A	;MAKE UPPER
1$:

TYO:	TSTB TPS
	BPL TYO
	MOVB A,TPB
	RTS PC

TYPES:	SAVE A
1$:	MOVB (F)+,A
	BEQ 2$
	JSR PC,TYO
	BR 1$
2$:	INC F
	BIC #1,F
	REST A
	RTS F

CODEND::	;THIS IS WHERE THE STUFF TO DUMP ENDS
.IIF GT CODEND-17776,.PRINT /LONGER THAN 4K, GASP!/
.MACRO PRAD A,B
.PRINT /A IS B/
.ENDM
PRAD CODEND,\CODEND
;FOLLOWING THINGS ARE NOT DUMPED TO DISK CAUSE THE DON'T NEED ANY INITIAL VALUES
.=.+300
PDL:
;VARIABLES
LASTB:	0		;LAST PLACE LOADED
MEMTOP:	0		;ADDRESS OF LAST EXTANT MEMORY WORD
TOPPNT:	0		;REAL LAST MEM WORD POINTER
DIR:	0		;BLOCK NUMBER OF CURRENT DIR
LOADNM:	.BLKB 64.	;PATH TO LOAD
	0		;CROCK, THIS IS PART OF FILEN
FILEN:	.BLKB 16.	;ELEMENT OF PATH
FILNUM:	0		;VERSION NUMBER OF FILE
ETYPE:	0		;TYPE OF SELECTED ENTRY
ENTRY:	.BLKW 32.	;SELECTED ENTRY
ENTRYP:	0		;POINTER TO DESC IN ENTRY
BLOCKN:	0		;RELATIVE BLOCK NUMBER
CURBLK:	0		;REAL BLOCK NUMBER
BUFPNT:	0		;POINTER INTO DISK BUFFER
BUFCNT:	0		;COUNT OF BYTES LEFT IN BUFFER
DSKBUF:
DIRBUF:	.BLKW 512.	;DISK AND DIR BUF ARE THE SAME THING

PROG:	;THIS IS WHERE WE STORE THE PROGRAM UNTIL WE'VE LAODED IT ALL

	.END 0		;THIS THING STARTS AT 0
