	The SGTL/SMS floppy disk interface provides single density, IBM
compatible floppy disk storage. It consists of an SMS FDO300 Floppy Disk
drive micro-controller interfaced to the LSI-11 by means of a quad-high
board designed by Ron Lebel.
	The quad high board which connects to the LSI-11 bus actually
has four relativly independant sections. There is a 128 word by 16 bit
ROM which contains the intial bootstrap code, a power-up control/line
frequency clock, an interface to the SMS microcontroller and a lights
register to control the "in use" lights on the floppy disk drives.
The device appears to the LSI-11 programmer as 4 words of registers;
ordinarily these start at 177200; also there are the 128 words of ROM
which start at 173000. The line clock interupts, when enabled, though
vector 100; the SMS interface can interupt, normally through vector 270.
	Here are the definitions of the 4 registers and trap vectors:

SMSCSR==177200		;THE CSR FOR THE SMS TO PDP11 INTERFACE
SMSDBF==SMSCSR+2	;THE DATA BUFFER BYTE
SMSCMD==SMSDBF+2	;THE COMMAND BUFFER BYTE
SMSLGT==SMSCMD+2	;LIGHT REGISTER
SMSBRV==270		;TRAP VECTOR ADDRESS
CLKBRV==100	;CLOCK TRAP ADDRESS

	Here are the PROM definitions. The last word of the PROM, by
convention, is the system configuration word. Currently, only one bit
of that word is used, the 50/60HZ bit:

SMSPRM==173000	;PROM ADDRESS
SMSPRE==173376	;LAST PROM ADDRESS (CONFIGURATION WORD)
 SMS60H==1	;IF THIS BIT IS ONE, MACHINE IS 60HZ, ELSE 50HZ


	The first of the four words, the control status register, indicates
the state of the floppy disk control, and provides some miscelaneous control
bits:

;STATUS BITS IN CSR
SMSERR==100000	;ERROR IN LAST OPERATION	read only
SMSRSB==40000	;RESET BIT			write only
SMSPWR==4000	;POWER ON DISK DRIVES		read/write
SMSCLE==2000	;CLOCK INTERUPT ENABLE		read/write
SMSST1==1000	;STAT ID BIT 1			read only
SMSST0==400	;STAT ID BIT 0			read only
SMSDNE==200	;DONE				read only
SMSINT==100	;INT ENABLE			read/write
SMSBSY==40	;BUSY				read only
SMSCMW==20	;WAITING FOR A COMMAND BYTE	read only
SMSDDR==10	;DATA DIRECTION			read only
SMSFDO==4	;FDC ON				read only
SMSXFW==1	;WAITING FOR XFR		read only

	If the SMSRSB is set, the SMS microcontroller board is reset.
This will cause it to seek the first ready drive it finds to track
zero, and otherwise initialize the world. The power to the disk drive
motors is controlled by a solid state relay; SMSPWR must be set to
turn the motors on. Note that the controller will not reset if the
drives are not powered. When the controller has reset the SMSFDO
bit will go OFF (not on!), as will the SMSDNE and SMSCMW bits.
The SMSST1 and SMSST0 bits are the status bits returned from the
microcontroller, further described below. SMSDNE indicates that
the micro controller has finished the last operation commanded; this
does not imply that that it is ready for another command byte.
SMSDDR indicates wheather the microcontroller is waiting to read
a byte from the LSI or have a byte read from it; normally this bit
is not used. It is only valid when either SMSXFW or SMSCMW is asserted.
SMSCMW indicates that the controller is waiting for a command byte; this
can be either the first or second byte of a command. SMSBSY indicates that
the controller has fully acepted a command and has not yet
completed it. SMSXFR indicates the controller is waiting to transfer
a data byte through the SMSDBF register. The SMSCLE bit, if set, will
cause the line time interrupt to occur once each power line cycle.
	Now here is how you program this kludge: first, the drives
must be powered on and the controller reset; do this by setting SMSPWR
and SMSRSB. Then wait for SMSFDO to go off; if it doesn't go off, there
is no disk in any drive. This operation should only be performed
when the drives were previously powered down. The way a command is
sent to the microcontroller is to place the first command byte
into the SMSCMD register, wait for SMSCMW to come back on, then place
the second byte. Here are the command byte definitions:

SMSRST==0	;RESET COMMAND, SECOND BYTE IGNORED

	The SMSRST command just resets the controller in the same way that
the SMSRSB does. The SMSRST command is the only one that does not return
any status information when it is done.
	Except for SMSRST all commands must specify the drive number (0-3)
in the first byte. The drive number is shifted by three bits and ORed
with the first command byte code. When any command other than SMSRST
is done the micro controller returns a status byte. This byte MUST
be read before attempting to send a new command. The SMSERR bit
is set if the status byte is reporting an error. The SMSST1 and SMSST0
tell which of 3 possible types of status/error byte is being returned;
if they are both zero, no status byte is available.

;STATUS BITS IN STATUS BYTE
;COMMAND STATUS
;SMSST1=0 SMSST0=1
SMSITA==2	;INVALID TRACK ADDRESS
SMSISA==4	;INVALID SECTOR ADDRESS
SMSIBS==10	;INVALID BUFFER SPEC
;DISK DRIVE STATUS
;SMSST1=1 SMSST0=0
SMSDNR==1	;DRIVE NOT READY
SMSDUS==2	;DRIVE UNSAFE
SMSDWP==4	;DRIVE WRITE PROTECTED
SMSNAM==10	;NO ADDRESS MARKS FOUND
SMSSIP==40	;SEEK IN PROGRESS
;OPERATION STATUS
;SMSST1=1 SMSST0=1
SMSRWA==1	;READ/WRITE ABORTED
SMSHPE==2	;HEAD POSITIONING ERROR
SMSDAM==4	;DATA ADDRESS MARK MISSING
SMSDOV==10	;DATA OVERRUN
SMSSUR==20	;SECTOR UNRECOVERABLE
SMSCRC==40	;CRC ERROR
SMSRWC==100	;READ/WRITE COMPLETE
SMSDDR==200	;DELETED DATA READ

	More commands:
SMSSEK==1	;SEEK, OR WITH DISK DRIVE_3, SECOND BYTE TRACK ADDRESS

	The SMSSEK command must be used to position the disk heads
before attempting to read or write data. After sending the second byte
(the track number to seek to), wait for SMSXFR to be set. At this point,
SMSERR will be set if an error has occured; in any case, SMSDBF will
contain the status information for the last operation. Only when the
operation status has been read will the seek continue past one track.
After reading the status byte, more commands can be sent, including
seeks on other drives.

	Data moving commands:

SMSRED==2	;READ, OR WITH DISK DRIVE_3 AND:
 SMSDTB==100	 ;DISK TO BUFFER BIT
 SMSBTH==200	 ;BUFFER TO HOST BIT
		  ;SECOND BYTE ON READ IS SECTOR
SMSWRT==4	;WRITE, OR WITH DISK DRIVE_3 AND:
 SMSBTD==100	 ;BUFFER TO DISK
 SMSHTB==200	 ;HOST TO BUFFER
		  ;SECOND BYTE ON WRITE IS SECTOR
SMSWRD==5	;WRITE WITH DELETED DATA MARK, OTHERWISE SAME AS WRITE

	Due to limitations of the LSI-11 and the SGTL interface,
all data moving must be done by way of the buffer internal to the
microcontroller. E.g. to read a sector, first the sector must be
read from the disk to the buffer (SMSRED with the SMSDTB bit set)
then the data must be read from the buffer to the host (SMSRED
with SMSBTH set). Of course, in the write case first the data
must be put in the buffer then actually written to the disk.
Except for this limitation reading and writing data is very
straightforward. It should be noted that once started, buffer
operations can proceed with the full speed of the LSI-11.
As with all commands, reads and writes, weather to the disk or
to the buffer, return status when done. In the case of a buffer operation,
this means AFTER reading or writing the 128 data bytes for the
sector.







SMSRID==3	;READ NEXT SECTOR ID, OR WITH DISK DRIVE_3, SECOND BYTE IGNORED
SMSFMT==6	;FORMAT THE TRACK THE HEADS ARE OVER
		 ;OR WITH DISK DRIVE_3, SECOND BYTE IS TRACK ADDRESS TO WRITE ON DISK
SMSSTS==7	;READ STATUS, OR WITH DISK DRIVE_3, SECOND BYTE IGNORED
