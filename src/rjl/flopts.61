.TITLE FLOPPY DISK DIAGNOSTIC
VERN==%FNAM2
.INSRT SITS;SITMAC >
.INSRT RJL;FLOPDF >

.MACRO TYPE STRING
	JSR F,TYPES
	.ASCIZ /STRING/
	.EVEN
.ENDM

.MACRO ACSAV
	SAVE <A,B,C,D,E,F>
.ENDM

.MACRO ACRES
	REST <F,E,D,C,B,A>
.ENDM

TKS==177560
TKB==TKS+2
TPS==TKB+2
TPB==TPS+2
TKBRV=60
CLKTV=100
EMTTV=30

.=0
.REPT 100
	.+2
	0
.ENDR

.=300
	JMP START
.=SMSTV
	SMSBRK
	340
.=CLKTV
	CLKBRK
	340
.=EMTTV
	EMTBRK
	0
.=TKBRV
	TKBRK
	340

.=500
PDL:
PAT:	.BLKW 200
DISK:	0	;SELECTED DISK
ERRAD:	0	;PLACE TO STORE ADDRESS OF ERROR
ERRDAT:	0	;PLACE TO STORE DATA BYTE ON ERROR
ERRST:	0	;PALCE TO STORE TYPE OF ERROR DATA
TRACK:	0	;TRACK BEING HACKED
SECTOR:	0	;SECTOR BEING HACKED
SECINC:	0	;SPACEING BETWEEN SECTORS
FUNC:	0	;FUNCTION TO CALL
SEEKRD:	READS	;DISPATCH FOR SEEK TEST
TIME:	0	;INC'ED BY CLKBRK
	0
;FOLLOWING 5 WORDS MUST BE IN ORDER
TICKS:	0	;1/60 SECS
SEX:	0
MINS:	0
HOURS:	0
	0	;OVERFLOW AFTER 60 (!) HOURS
CLKWAI:	0	;IF NON-ZERO CLOCK INT IS LEGAL
INTWAI:	0	;IF NON-ZERO SMS INTERUPT IS LEGAL
SECBUF:	.BLKB 128.	;SECTOR BUFFER
TRKPT:	TRKTB
SECPT:	SECTB
RETRYS:	0	;COUNT OF TRYS SO FAR
TRKTB:	.BYTE 60.,7.,40.,73.,20.,22.,53.,0.,33.,66.,13.,46.,26.,59.
	.BYTE 6.,39.,72.,19.,55.,52.,32.,65.,12.,45.,2.,25.,58.,5.
	.BYTE 38.,71.,18.,51.,31.,64.,11.,35.,44.,24.,57.,4.,37.,70.
	.BYTE 17.,50.,30.,63.,68.,10.,43.,76.,23.,56.,3.,36.,15.,69.
	.BYTE 16.,49.,29.,62.,9.,48.,28.,42.,61.,8.,41.,74.,21.,54.
	.BYTE 1.,34.,67.,14.,47.,75.,27.
TRKTBE::
SECTB:	.BYTE 1.,2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,12.,13.,14.,15.
	.BYTE 16.,17.,18.,19.,20.,21.,22.,23.,24.,25.,26.
SECTBE::
	.EVEN
PASSCN:	0			;PASS COUNT
ZEROS::			;START OF STUFF TO ZERO ON START OF TEST
SERTAB:	.BLKW 77.*26.		;SOFT ERROR COUNT ON THIS SECTOR
HARDTB:	.BLKW 77.*26.		;HARD ERROR COUNT ON THIS SECTOR
SEKETB:	.BLKW 77.		;SEEK ERRORS ON THIS TRACK
SERCNT:	0			;COUNT OF SOFT ERRORS
HARDCN:	0			;COUNT OF HARD ERRORS
SEKECN:	0			;COUNT OF SEEK ERRORS
RETRY:	0			;RETRYS BEFORE HARD ERROR
ZEROE::		;END OF STUFF TO ZERO
HRDRTY==10.			;HOW BIG TO LET RETRY GET BEFORE HARD ERROR
HLT==EMT
STAT==HLT+1

START:	MOV #PDL,P
	MOV #SMSCSR,F		;COMMONLY USED CONSTANT
LOOP:	BIS #SMSRSB,(F)

	RESET			;TURN OFF THE DISK
	MTPS #0			;ENABLE INTERUPTS
	TYPE <
FLOPTS.>
	MOV #VERN,B
	JSR PC,PRDN
	TYPE <
Whaduhyawant?  >
	JSR PC,TYI
	TYPE <
>
	CMP #'F,A
	BNE 1$
	JSR PC,FORMAT
	JMP LOOP
1$:	CMP #'?,A
	BNE 2$
	JSR PC,CMDS
	JMP LOOP
2$:	CMP #'R,A
	BNE 3$
	JSR PC,READ
	JMP LOOP
3$:	CMP #'W,A
	BNE 4$
	JSR PC,WRITE
	JMP LOOP
4$:	CMP #'S,A
	BNE 5$
	JSR PC,SEEK
	JMP LOOP
5$:	CMP #'T,A
	BNE 6$
	JSR PC,TEST
	JMP LOOP
6$:	CMP #'P,A
	BNE 7$
	JSR PC,PERRS
	JMP LOOP
7$:	CMP #'C,A
	BNE 8$
	JSR PC,CHECK
	JMP LOOP

8$:	CMP #'0,A
	BHI 9$
	CMP #'3,A
	BLO 9$
	SUB #'0,A
	MOV A,DISK
	JMP LOOP

9$:	CMP #'L,A
	BNE 10$
	JSR PC,PRETTY
	JMP LOOP
10$:	TYPE <Nope, try ? for help>
	JMP LOOP

CMDS:	TYPE <Commands are:
0,1,2,3 Select disk drive to use
C  Check disk that should have pattern on it (continues)
F  Format
L  Pretty lights
P  Print error counts so far
Q  Should intterupt test
R  Read disk
S  Random seeks+reads (continues)
T  Write, read, seek  (continues)
W  Write patern on disk, read it back
>
	RTS PC

PRETTY:	MOV #10.,A
1$:	MOV #10000.,B	;ABOUT 1/20 SECOND
	SOB B,.
	SOB A,1$
	MOV C,SMSLGT
	INC C
	BR PRETTY	


ITEST:	BIS #SMSPWR!SMSRSB,(F)	;RESET THE WORLD AND POWER UP
	CLR A
	MOV #30.,B
1$:	BIT #SMSFDO,(F)
	BEQ 9$
	SOB A,1$
	SOB B,1$
	TYPE <Disk won't turn on????
>
	BR ITEST
9$:	BIT #SMSDNE,(F)
	BNE 2$
	TYPE <Controller not done?
>
	BR ITEST
2$:	BIT #SMSCMW,(F)
	BNE 8$
	TYPE <Controller not ready?
>
	BR ITEST
8$:	CLR D
6$:	JSR PC,REQST	;GET DISK STATUS
	BIT #SMSDNR,A	;DRIVE READY?
	BEQ 7$		;READY?
	SOB D,6$
	TYPE <Drive not ready?
>
	HLT
7$:
INTTST:	MOV PC,INTWAI		;SAY WE EXPECT AN INTERUPT
	BIS #SMSINT,(F)		;TRY TO CAUSE ONE
	240
	240
	TST INTWAI		;INT ROUTINE CLEARS INTWAI
	BEQ 1$
	TYPE <Failed to interupt
>
	STAT
	CLR INTWAI
1$:	BIC #SMSINT,(F)
PROMTS:	MOV #PROM,A
	MOV #173000,B
	MOV #177,C
1$:	CMP (A)+,(B)+
	BNE 3$
	SOB C,1$
	BR CLKTST
3$:	TYPE <Prom not correct?
>



CLKTST:	CLR TIME
	CLR TIME+2
	MOV PC,CLKWAI
	BIS #SMSCLE,(F)	;ENABLE CLOCK
	CLR A
1$:	TST TIME
	BNE 2$
	SOB A,1$
	TYPE <Clock didn't interupt
>
2$:	BIS #100,TKS	;ENABLE INTERUPT FOR QUIT
	MOV #ZEROS,A
3$:	CLR (A)+
	CMP #ZEROE,A
	BNE 3$
	RTS PC

TKBRK:	ACSAV
	MOV TKB,A
	BIC #177600,A
	CMP #'a,A
	BHI 3$
	CMP #'z,A
	BLO 3$
	SUB #40,A
3$:	CMP #'P,A
	BNE 1$
	JSR PC,PERRS
	BR 5$
1$:	CMP #'Q,A
	BNE 2$
	JMP START
2$:
5$:	ACRES
	RTT











FORMAT:	JSR PC,ITEST	;MAKE SURE THE WORLD IS ALIVE
	TYPE <Format disk?  >
	JSR PC,TYI
	CMP #'Y,A
	BEQ 1$
	RTS PC
1$:	MOV #76.,E	;TRACK COUNTER
FORMA1:	MOV E,TRACK	;FOR ERROR PRINTOUT
	MOV #SMSSEK,A	;FIRST SEEK TO TRACK
	JSR PC,DCMD	;ON SELECTED DISK
	MOV E,A		;TRACK ADDRESS
	JSR PC,CMD2	;ISSUE SECOND BYTE OF COMMAND
	JSR PC,GETST	;GET STATUS OF COMMAND
	BNE FORMA2
	HLT
FORMA2:	JSR PC,REQST	;GET DISK STATUS
	BIT #SMSSIP,A	;SEEK STILL GOING?
	BNE FORMA2	;YUP, WAIT FOR IT TO END

	MOV #SMSFMT,A	;FORMAT THIS TRACK
	JSR PC,DCMD
	MOV E,A		;LABEL THE TRACK CORRECTLY
	JSR PC,CMD2
	JSR PC,GETST	;GET STATUS OF OPERATION
	BNE 1$
	HLT
1$:	DEC E
	BGE FORMA1	;DO NEXT TRACK
	RTS PC		;DONE FORMATTING


;READ THE WHOLE DISK, NOT CHECKING THE DATA
;THIS IS TO FIND BAD HEADERS ON A DISK, ETC.
READ:	JSR PC,ITEST 	;MAKE SURE THE WORLD IS ALIVE
	MOV #READS,FUNC
	MOV #2,SECINC
	JSR PC,ITER	;PERFORM READS ON EVERY SECTOR
	RTS PC


WRITE:	JSR PC,ITEST		;MAKE SURE THE WORLD IS ALIVE
	CLR PASSCN
1$:	INC PASSCN
	JSR PC,WRITEP		;WRITE AND CHECK PATTERN
	BR 1$

WRITEP:	MOV #WRTPAT,FUNC	;WRITE PATTERN ON THE DISK
	MOV #2,SECINC	;HOPEFULLY CAN WRITE WHOLE TRACK IN 2 PASSES
	JSR PC,ITER
CHECKP:	MOV #REDPAT,FUNC	;READ AND CHECK THE PATTERN
	JSR PC,ITER
	RTS PC

WRTPAT:	SAVE <A,B,C,D>
	MOV #SECBUF,A
	MOV TRACK,B
	MOV SECTOR,C
	MOV #64.,D
1$:	MOVB B,(A)+
	MOVB C,(A)+
	INC B
	INC C
	SOB D,1$
	REST <D,C,B,A>
	JSR PC,WRITES	;WRITE OUT THE SECTOR
	RTS PC

REDPAT:	JSR PC,READS	;READ THE SECTOR
	SAVE <A,B,C,D>
	MOV #SECBUF,A
	MOV TRACK,B
	MOV SECTOR,C
	MOV #64.,D
1$:	CMPB B,(A)+
	BNE REDERR
	CMPB C,(A)+
	BNE REDERR
	INC B
	INC C
	SOB D,1$
REDPA1:	REST <D,C,B,A>
	RTS PC

REDERR:	TYPE <Got a data error
>
	BR REDPA1

;ROUTINE TO ITERATE OVER THE WHOLE DISK CALLING THE ROUTINE IN FUNC
;FOR EVERY SECTOR, INCREMENTING BY SECINC BETWEEN SECTORS
;SECINC MUST BE 1, 2, 13 OR 26
ITER:	CLR TRACK
	MOV #77.,D	;TRACK COUNTER
ITER1:	MOV #26.,E	;SECTOR COUNTER
	MOV #1,SECTOR
ITER2:	JSR PC,@FUNC
	ADD SECINC,SECTOR
	CMP #27.,SECTOR
	BGT 1$
	SUB #25.,SECTOR
1$:	SOB E,ITER2
	INC TRACK
	SOB D,ITER1
	RTS PC

;READ THE CURRENT SECTOR INTO SECBUF
;USE TWO ALTERNATE TECHNIQUES TO READ FROM THE BUFFER
READS:	SAVE <A,B,C>
	CLR RETRYS
	JSR PC,SEEKT	;SEEK TO TRACK
READRT:	INC RETRYS
	CMP #8,RETRYS
	BGE 2$
	REST <C,B,A>
	CLZ
	RTS PC
2$:	MOV #SMSRED!SMSDTB,A	;READ INTO BUFFER
	JSR PC,DCMD
	MOV SECTOR,A
	JSR PC,CMD2
1$:	TSTB (F)
	BPL 1$		;WAIT FOR DONE
	JSR PC,GETST	;GET STATUS WHEN DONE
	BEQ READER	;GO PROCESS READ ERROR
	MOV #SMSRED!SMSHTB,A	;READ BUFFER INTO US
	JSR PC,DCMD
	JSR PC,CMD2	;SECOND BYTE DOESN'T MATTER

READFS:	MOV #SECBUF,A
	MOV #SMSDBF,B
	MOV #16.,C
1$:	.REPT 8.
	MOVB (B),(A)+
	.ENDR
	SOB C,1$
	BIT #SMSST1!SMSST0,(F)	;STATUS NOW AVAILABLE?
	BNE 2$
	TYPE <Fast mode read lost
>
	HLT
2$:	JSR PC,GETST
	BNE 3$
	HLT
3$:	REST <C,B,A>
	CLZ
	RTS PC

;THERE ARE TWO TYPES OF ERRORS WE WILL TRY TO RECOVER FROM:
;SEEK ERRORS AND READ ERRORS.( INCLUDING CRC, DAM AND SUR)
; ALL OTHERS KILL US DEAD
READER:	CMP #3,ERRST	;OPERATION ERROR?
	BNE BADER	;NOPE
	BIT #SMSHPE!SMSDAM!SMSSUR,ERRDAT	;"SEEK" TYPE ERROR?
	BNE READSE	;YUP
	BIT #SMSCRC,ERRDAT	;SIMPLE CRC?
	BNE REDCRC	;YUP
BADER:	HLT

READSE:	STAT
	JSR PC,SEEKER	;PROCESS A SEEK ERROR
	BR REDCR1	;SEEK ER IS ALSO SOFT ERR
REDCRC:	STAT
REDCR1:	JSR PC,SOFERR	;PROCESS A SOFT ERROR
	BR READRT

SOFERR:	MOV TRACK,B
	MUL #26.,B
	ADD SECTOR,B
	DEC B
	ASL B
	INC SERTAB(B)
	INC SERCNT
	CMP #8,RETRYS
	BGT 1$
	INC HARDTB(B)
	INC HARDCN
1$:	RTS PC

SEEKER:	MOV TRACK,A
	ASL A
	INC SEKETB(A)
	INC SEKECN
	SAVE TRACK
	CLR TRACK
	JSR PC,SEEKT
	REST TRACK
	JMP SEEKT

;WRITE A SECTOR, USING TWO ALTERNATE BUFFER TRANSFER TECHNIQUES
WRITES:	SAVE <A,B,C>
	JSR PC,SEEKT	;SEEK TO TRACK
	MOV #SMSWRT!SMSHTB,A	;TRANSFER TO BUFFER
	JSR PC,DCMD
	JSR PC,CMD2	;SECOND BYTE IGNORED
2$:	BIT #SMSXFW,(F)	;READY TO TRANSFER?
	BEQ 2$
	MOV #SECBUF,A
	MOV #SMSDBF,B
	MOV #16.,C
1$:	.REPT 8
	MOVB (A)+,(B)
	.ENDR
	SOB C,1$
	BIT #SMSST1!SMSST0,(F)	;STATUS SHOULD BE AVAILABLE
	BNE WRTS1	;GO GET IT
	TYPE <Fast host to buffer transfer lost
>
	HLT

WRTS1:	JSR PC,GETST
	BNE 1$
	HLT
1$:	CLR RETRYS
WRTRT:	INC RETRYS
	CMP #8,RETRYS
	BGE 2$
	HLT
2$:	MOV #SMSWRT!SMSBTD,A
	JSR PC,DCMD
	MOV SECTOR,A
	JSR PC,CMD2
	JSR PC,GETST
	BEQ WRTER
	REST <C,B,A>
	RTS PC

;ONLY TYPE OF ERROR WE TRY TO RECOVER ON WRITE IS SEEK
WRTER:	CMP #3,ERRST	;OP ERROR?
	BNE BADWER
	BIT #SMSHPE!SMSDAM!SMSSUR,ERRDAT	;SEEK TYPE OF ERROR?
	BEQ BADWER	;NOPE
	STAT		;TYPE ERROR INFO
	JSR PC,SEEKER	;PROCESS SEEK ERROR
	JSR PC,SOFERR	;KEEP ERROR COUNT
	BR WRTRT

BADWER:	HLT

;SEEK TO THE CURRENT TRACK ADDRESS
SEEKT:	MOV #SMSSEK,A
	JSR PC,DCMD
	MOV TRACK,A
	JSR PC,CMD2
	JSR PC,GETST
	BNE 1$
	HLT
1$:	JSR PC,REQST	;GET STATUS OF DRIVE
	BIT #SMSSIP,A	;STILL SEEKING?
	BNE 1$
	RTS PC	

;SEEK AROUND ON THE DISK
;USING SOMEWHAT RANDOM PATTERN
SEEK:	MOV #READS,SEEKRD
	CLR PASSCN
	JSR PC,ITEST
1$:	INC PASSCN
	JSR PC,SEEKTS
	BR 1$

SEEKTS:	MOV #1,SECINC
	MOV #SEEKR,FUNC
	MOV #TRKTB,TRKPT
	MOV #SECTB,SECPT
	JSR PC,ITER	;WE WILL COVER THE WHOLE DISK
	RTS PC

SEEKR:	MOVB @TRKPT,TRACK
	MOVB @SECPT,SECTOR
	INC TRKPT
	CMP #TRKTBE,TRKPT
	BHI 1$
	MOV #TRKTB,TRKPT
	INC SECPT
1$:	JSR PC,@SEEKRD	;HACK THE SECTOR
	RTS PC


;TRY VARIOUS THINGS
TEST:	CLR PASSCN
	JSR PC,ITEST
1$:	INC PASSCN
	JSR PC,WRITEP	;WRITE THE DISK	
	MOV #REDPAT,SEEKRD
	JSR PC,SEEKTS	;RANDOM READS CHECKING PATTERN	
	BR 1$

CHECK:	CLR PASSCN
	JSR PC,ITEST
1$:	INC PASSCN
	JSR PC,CHECKP
	BR 1$	

;ROUTINES TO INTRACT WITH THE DISK ON A LOW LEVEL

;GET THE STATUS OF THE SELECTED DISK
REQST:	MOV #SMSSTS,A	;GET STATUS
	JSR PC,DCMD	;ISSUE REQUEST FOR STATUS
	JSR PC,CMD2	;SECOND BYTE IGNORED
	JSR PC,GETST	;GET THE STATUS
	BNE 1$
	HLT
1$:	RTS PC

;ISSUE THE FIRST COMMAND BYTE (IN A), ORING IN THE DISK NUMBER
DCMD:	SAVE A		;SAVE THE COMMAND BYTE
	MOV (F),A	;GET THE CSR
	BIC #-<SMSFDO!SMSCMW!SMSDNE!SMSBSY!SMSXFW>-1,A	;CLEAR USELESS BITS
	CMP #SMSCMW!SMSDNE,A	;IS IT IN A GOOD STATE?
	BEQ 1$
	TYPE <Controller not in good state to get command
>
	HLT
1$:	MOV DISK,A
	ASH #3,A
	BIS (P)+,A
	MOV A,SMSCMD	;GIVE COMMAND
	RTS PC

;ISSUE THE SECOND BYTE OF A COMMAND
CMD2:	SAVE <A,B>		;SAVE THE COMAND BYTE
	MOV #30,B
2$:	MOV (F),A	;GET THE CSR
	BIC #-<SMSFDO!SMSCMW!SMSDNE!SMSBSY!SMSXFW>-1,A	;CLEAR USELESS BITS
	CMP #SMSCMW,A	;IS IT IN A GOOD STATE?
	BEQ 1$
	SOB B,2$
	TYPE <Controller not ready for second byte
>
	HLT
1$:	REST <B,SMSCMD>	;GIVE IT THE BYTE
	RTS PC


GETST:	CLR A	;TO TIME OUT
GETST1:	BIT #SMSST1!SMSST0,(F)	;STATUS AVAILABLE?
	BNE GETST2
	SOB A,GETST1
	TYPE <Timed out waiting for status
>
	HLT
GETST2:	BIT #SMSERR,(F)	;ERROR?
	BNE 3$		;YUP
	BIT #SMSXFW,(F)	;WAITING TO TRANSFER?
	BNE 4$
	TYPE <Status available but not waiting for xfr????
>
	HLT
4$:	MOV SMSDBF,A	;GOBBLE STATUS
	CLZ
	RTS PC

3$:	JSR PC,ERRGBL	;GOBBLE ERROR STATUS
	SEZ
	RTS PC

ERRGBL:	BIT #SMSST1!SMSST0,(F)	;ANYTHING THERE?
	BEQ ERRGB1		;NOPE, KEEP OLD ERROR
	MOVB 1(F),A		;GET NEW ERROR TYPE
	BIC #177774,A		;FLUSH EXTRA STUFF
	MOV A,ERRST
	BIT #SMSXFW,(F)		;WAITING FOR XFR?
	BNE 1$
	TYPE <Status available but not waitng for xfr????
>	
	HALT			;TO AVOID RECURSIVE LOOP
1$:	MOV SMSDBF,ERRDAT
ERRGB1:	RTS PC

;GENERAL ERROR PRINTOUT ROUTINE
EMTBRK:	REST <ERRAD,>	;POP THE ADDRESS AND PS
	ACSAV
	TYPE <
Error @ >
	MOV ERRAD,A
	TST -(A)
	JSR PC,PRONL
	TYPE <  CSR: >
	MOV SMSCSR,A
	JSR PC,PRONL
	TYPE < TRK: >
	MOV TRACK,A
	JSR PC,PRONB
	TYPE < SEC: >
	MOV SECTOR,A
	JSR PC,PRONB
	JSR PC,ERRGBL	;GOBBLE UP THE ERROR STATUS IS THERE IS ONE
			;OTHERWISE LEAVE BEHIND THE OLD STATUS	
	TYPE < ETYP: >
	MOV ERRST,A	;THE BITS THAT GIVE THE TYPE OF ERROR
	JSR PC,PRONB
	TYPE < EDAT: >
	MOV ERRDAT,A
	JSR PC,PRONB
	TYPE <
>
	MOV ERRST,A
	ASL A
	JMP @.+4(A)
	NOERR
	CMDERR
	DRVERR
	OPERR

NOERR:	TYPE <  No error available
>
	JMP EMTBR1

CMDERR:	TYPE < Cmd err: >
	BIT #SMSITA,ERRDAT
	BEQ 1$
	TYPE <Invalid track  >
1$:	BIT #SMSISA,ERRDAT
	BEQ 2$
	TYPE <Invalid sector  >
2$:	BIT #SMSIBS,ERRDAT
	BEQ 3$
	TYPE <Invalid buffer spec>
3$:	TYPE <
>
	JMP EMTBR1

DRVERR:	TYPE < DRIVE ERROR: >
	BIT #SMSDNR,ERRDAT
	BEQ 1$
	TYPE <Drive not ready  >
1$:	BIT #SMSDUS,ERRDAT
	BEQ 2$
	TYPE <Drive unsafe  >
2$:	BIT #SMSDWP,ERRDAT
	BEQ 3$
	TYPE <Write protected  >
3$:	BIT #SMSNAM,ERRDAT
	BEQ 4$
	TYPE <No address marks  >
4$:	BIT #SMSSIP,ERRDAT
	BEQ 5$
	TYPE <Seek in progress>
5$:	TYPE <
>
	JMP EMTBR1

OPERR:	TYPE <Op error:  >
	BIT #SMSRWA,ERRDAT
	BEQ 1$
	TYPE <Read/write abort  >
1$:	BIT #SMSHPE,ERRDAT
	BEQ 2$
	TYPE <Head pos err  >
2$:	BIT #SMSDAM,ERRDAT
	BEQ 3$
	TYPE <Data address mark missing  >
3$:	BIT #SMSDOV,ERRDAT
	BEQ 4$
	TYPE <Overrun  >
4$:	BIT #SMSSUR,ERRDAT
	BEQ 5$
	TYPE <Sector unrecoverable  >
5$:	BIT #SMSCRC,ERRDAT
	BEQ 6$
	TYPE <Crc err  >
6$:	BIT #SMSRWC,ERRDAT
	BEQ 7$
	TYPE <Read/write complete  >
7$:	BIT #SMSDDR,ERRDAT
	BEQ 8$
	TYPE <Deleted data>
8$:	TYPE <
>

EMTBR1:	MOV ERRAD,A
	BIT #1,-(A)
	BNE 1$
	HALT
1$:	ACRES
	JMP @ERRAD



SMSBRK:	TST INTWAI	;IS MAIN PROGRAM WAITING FOR THIS?
	BEQ 1$		;NOPE, UGH
	CLR INTWAI
	RTT

1$:	TYPE <Spurious disk interupt
>
	HLT

CLKBRK:	TST CLKWAI	;IS MAIN PROGRAM WAITING FOR THIS?
	BEQ 1$		;NOPE
	INC TIME
	BNE 2$
	INC TIME+2
2$:	SAVE A
	MOV #TICKS,A
4$:	INC (A)
	CMP #60.,(A)
	BNE 3$
	CLR (A)+
	BR 4$			
3$:	REST A
	RTT

1$:	TYPE <Spurious clock interupt
>
	HLT

PERRS:	ACSAV
	TYPE <
Pass: >
	MOV PASSCN,B
	JSR PC,PRDN
	TYPE < @ >
	JSR PC,PRTIME
	TYPE <
Error counts:
Hard: >	
	MOV HARDCN,B
	JSR PC,PRDN
	TYPE < soft: >
	MOV SERCNT,B
	JSR PC,PRDN
	TYPE < seek: >
	MOV SEKECN,B
	JSR PC,PRDN	
	TYPE <
>
	ACRES
	RTS PC




PRTIME:	MOV HOURS,B
	JSR PC,PRDN
	TYPE <:>
	MOV MINS,B
	JSR PC,PRDN
	TYPE <:>
	MOV SEX,B
	JSR PC,PRDN
	RTS PC

;GENERAL PRINT NUMBER ROUTINE
;CALL WITH A CLEAR, NUMBER TO BE PRINTED IN B
;MINIMUM NUMBER OF DIGITS TO PRINT IN C
;AND RADIX TO PRINT IN (=< 10.) IN D
PRN:	DIV D,A
	SAVE <B,#PRNDIG>
	MOV A,B
	CLR A
	DEC C
	BGT PRN
	TST B
	BNE PRN
	RTS PC		;RETURN TO PRNDIG

PRNDIG:	REST D		;DIGIT TO PRINT
	ADD #60,D
	SAVE A
	MOV D,A
	JSR PC,TYO
	REST A
	RTS PC
	
;PRINT A DECIMIAL NUMBER IN B
PRDN:	SAVE <A,B,C,D>
	MOV #10.,D
	CLR A
	CLR C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC

PRONL:	SAVE <A,B,C,D>
	MOV #8.,D
	MOV A,B
	CLR A
	MOV #6,C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC

PRONB:	SAVE <A,B,C,D>
	MOV #8.,D
	MOV A,B
	CLR A
	MOV #3,C
	JSR PC,PRN
	REST <D,C,B,A>
	RTS PC





TYI:	TSTB TKS
	BPL TYI
	MOV TKB,A
	BIC #177600,A
	CMP #'a,A	;LOWER CASE?
	BGT 1$		;NOPE
	CMP #'z,A
	BLT 1$
	SUB #40,A	;MAKE UPPER
1$:

TYO:	TSTB TPS
	BPL TYO
	MOVB A,TPB
	RTS PC		;NOP THIS TO SLOW DOWN TYO
	SAVE A
	MOV #1000.,A
	SOB A,.
	REST A
	RTS PC

TYPES:	SAVE A
1$:	MOVB (F)+,A
	BEQ 2$
	JSR PC,TYO
	BR 1$
2$:	INC F
	BIC #1,F
	REST A
	RTS F

PROM:
.INSRT RJL;35BOOT PROM
.END START

