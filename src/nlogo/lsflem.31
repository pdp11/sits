.SBTTL Emulator User's Guide
;
;Floating Point Processor Quasi-Emulator Caveats:
;
;	This code emulates the PDP11/45 Floating Point Instruction Set
;for the LSI-11. The emulator behaves like the real thing in all respects
;except for the following:
;
;	1) Double Presision
;
;	Double precision floating mode is not implemented as such.
;The emulator will pretend to have double precision (when the approp-
;riate bit of the pseudo-FPS is set) by doing extra increments/decrements in
;auto-inc/dec modes, etc. But the low half of a double precision operand will
;always be treated as zero; the low half of a double precision result will
;always be set to zero. Also, the MODF product will always be a 32-bit number
;(24 bits of precision).
;
;
;	2) FPS and FEC
;
;	The mode bits (other than FD and FL) and the error bit of the
;pseudo-FPS can be read and written (by STFPS and LDFPS), but are otherwise
;ignored by the emulator, which proceeds as though they were zero.  The
;FEC and Exception Address will always be read as zero.
;
;
;	3)Stack
;
;	Since the emulator makes use of the stack, several words above the top
;of the stack are clobbered by the emulator routine.  Also, a floating in-
;struction which is supposed to deposit an integer in P will leave P unchanged
;under the emulator, but will otherwise (eg floating condition codes) behave
;normally.  These discrepancies will be of no concern to those who use the stack
;as Nature intended.
;
;TO USE 1145 FLOATING POINT INSTRUCTIONS IN A PROGRAM ON THE LSI11, SIMPLY
;ASSEMBLE THIS FILE ALONG WITH THE PROGRAM. IN ORDER TO ENABLE THE EMULATOR,
;YOUR PROGRAM MUST PUT #FLEMT IN TRAP VECTOR 10, #0 IN TRAP VECTOR 12, #FLFIS
;IN TRAP VECTOR 244, AND #0 IN TRAP VECTOR 246.
.SBTTL FLOATING ERROR HANDLER
;********* !!
;NOTE!!!! ALL FLOATING INSTRUCTIONS THAT MIGHT CAUSE UNDERFLOW HAD BETTER USE F
FLFIS:	BIT #1,2(P)	;IS C (DIVIDE BY ZERO) SET?
	BNE 1$		;YES, LOSER
	BIT #10,2(P)	;IS N (UNDERFLOW) CLEAR?
	BEQ 1$		;YES, MUST BE OVERFLOW (LOSER)
	CMP (F)+,(F)+	;FLUSH TOP THING ON STACK
	CLR (F)		;SET RESULT TO ZERO	
	CLR 2(F)
	BIC #17,2(P)	;FLUSH OLD CC'S
	BIS #4,2(P)	;SET THE Z BIT
1$:	RTI
DC FLOATB,200
DC FLINTB,100
.SBTTL  LSI-11  11/45 FLOATING POINT PROCESSOR QUASI-EMULATOR

FLEMT:	MOV A,FLREGA	;SAVE REGISTERS
	MOV #FLREGB,A
	MOV B,(A)+
	MOV C,(A)+
	MOV D,(A)+
	MOV E,(A)+
	MOV F,(A)+
	MOV P,(A)
	ADD #4,(A)+	;AS IT WOULD BE IF NOT FOR THE TRAP
	MOV (P),(A)	;PC

	MOV #FLARGS,F	;FLOATING OPERANDS STACK POINTER
	MOV FLREPC,A	;PC
	SUB #2,A	;POINT TO OFFENDING INSTRUCTION
	MOV (A),A	;INSTRUCTION IN A
	MOV #170000,B
	XOR B,A	;COMPLEMENT TOP 4 BITS
	BIT #170000,A	;ALL ZEROS (ONES ORIGINALLY?)
	BEQ FLEMT1	;YUP,OK
	JMP FLEMT2	;NOPE, NOT A FLOATING INSTRUCTION
FLEMT1:	MOV A,B		;COPY FLOATING INSTR
	CLRB B		;LEAVE ONLY OPCODE BITS,
	SWAB B		; IN LOW BYTE
	ASL B		;CONVERT TO WORD OFFSET
	JSR PC,@FLINST(B)	;DISPATCH TO EMULATE INSTR.

	MOV FLREPC,(P)
	MOV #FLREGF+2,A
	MOV -(A),F
	MOV -(A),E
	MOV -(A),D
	MOV -(A),C
	MOV -(A),B
	MOV -(A),A

	RTI

FLEMT2:	HALT		;USUAL BAD-OPCODE HANDLER STARTS HERE

FLINST:	FLINS0		;INSTRUCTION EMULATOR ROUTINES DISPATCH
	FLINS1
	FLMUL
	FLMOD
	FLADD
	FLLDF
	FLSUB
	FLCMP
	FLSTF
	FLDIV
	FLSEX
	FLSTC
	FLSCF
	FLLEX
	FLLDC
	FLLCF
FLINS0:	MOV A,B
	BIT #300,B	;SPECIAL DECODE?
	BEQ FLSB01
	BIC #177477,B	;LEAVE ONLY LAST 2 OPCODE BITS
	ASH #-5,B
	JSR PC,@FLIN1(B)
	RTS PC
FLSB01:	BIC #177760,B	;LEAVE ONLY LAST 4 BITS
	ASL B	;=> OFFSET
	JSR PC,@FLIN2(B)
	RTS PC

FLIN2:	FLCFC
	FLSEF
	FLSEI
	.BLKW 6
	FLSED
	FLSEL

FLIN1=	.-2
	FLLFP
	FLSFP
	FLSTS

FLINS1:	MOV A,B
	BIC #177477,B	;LEAVE ONLY LAST 2 OPCODE BITS
	ASH #-5,B	;=> OFFSET
	JSR PC,@FLIN3(B)	;GO TO IT
	RTS PC

FLIN3:	FLCLR
	FLTST
	FLABS
	FLNEG	
.SBTTL SOURCE/DESTINATION ROUTINE

;THIS ROUTINE PUSHES A SOURCE OPERAND ONTO THE OPERAND STACK,
;OR POPS A RESULT FROM THE STACK TO A DESTINATION.
;CALLED WITH INSTR. IN A,
;OPERAND STACK POINTER IN F,
;OPERAND LENGTH (IN BYTES) IN E,
;INTEGER/FLOATING FLAG IN D
;CLOBBERS B,C,E

FLOPER:	MOV A,B		;COPY INSTR
	MOV B,C		;AGAIN
	BIC #177770,B	;LEAVE ONLY REGISTER BITS
	ASL B		; *2
	BIC #177707,C	;CLEAR ALL BUT MODE BITS
	ASH #-2,C	;AND CONVERT TO DISPATCH INDEX
	JSR PC,@FLMODE(C)	;DO THE RIGHT THING
	RTS PC

FLMODE:	.WORD FLREG
	.WORD FLAREG
	.WORD FLINC
	.WORD FLAINC
	.WORD FLDEC
	.WORD FLADEC
	.WORD FLIND
	.WORD FLAIND
.SBTTL ADDRESS MODE ROUTINES

;THESE ARE CALLED WITH REG# * 2 IN B,
;FIXED/FLOAT FLAG IN D (0=>FLOAT,1=>FIXED),
;OPERAND LENGTH (BYTES) + SRC/DST FLAG (0=>SRC,20=>DST) IN E,
;OPERAND STACK PTR IN F.
;F IS UPDATED, B,C AND E CAN BE CLOBBERED.
;OPERAND/RESULT IS PUSHED/POPPED FROM OPERAND STACK.

FLREG:	TST D		;INTEGER OR FLOATING THING?
	BEQ FLACC	;IF FLOATING, REG# DESIGNATES FL. ACC.
	ADD #FLREGS,B	;PTR TO SELECTED REGISTER
	BIC #17,E	;FORCE LENGTH TO 1 WORD
	ADD #2,E
	JSR PC,FLXFER	;DISPATCH TO XFER ROUTINE
	CLZ
	RTS PC


FLACC:	CMP B,#6*2	;P OR PC?
	BGE FLACC1	;IF SO, IT AIN'T FLOATING
	ASL B		;=> FLACS INDEX
	ADD #FLACS,B	;=> FLACS POINTER
	BIT #20,E	;COMING OR GOING?
	BEQ 1$		;ACC IS SOURCE
	MOV #24,E	;ACC IS DEST, FORCE LENGTH TO 2 WDS
1$:	JSR PC,FLXFER
	CLZ
	RTS PC
FLACC1:	SEZ
	RTS PC


FLAREG:	ADD #FLREGS,B	;POINTER TO REGISTER
	MOV (B),B	;INDIRECT
	JSR PC,FLXFER	;AND XFER
	CLZ
	RTS PC


FLIND:	ADD #FLREGS,B	;PTR TO REGISTER
	MOV @FLREPC,C	;GET INDEX
	ADD #2,FLREPC	;ADVANCE PC
	MOV (B),B	;INDIRECT
	ADD C,B	;ADD INDEX
	JSR PC,FLXFER	;AND XFER
	CLZ
	RTS PC


FLAIND:	ADD #FLREGS,B	;PTR TO REGISTER
	MOV @FLREPC,C	;GET INDEX
	ADD #2,FLREPC	;ADVANCE PC
	MOV (B),B	;INDIRECT
	ADD C,B		;ADD INDEX
	MOV (B),B	;AND INDIRECT AGAIN
	JSR PC,FLXFER	;NOW XFER
	CLZ
	RTS PC
FLINC:	ADD #FLREGS,B	;PTR TO REGISTER
	MOV B,C		;COPY IT
	MOV (B),B	;INDIRECT
	CMP C,#FLREPC	;PC?
	BNE FLINC1	;NO, PROCEED
	BIC #17,E	;YES, FORCE LENGTH TO 1 WORD
	ADD #2,E
FLINC1:	JSR PC,FLXFER	;XFER
	BIC #20,E	;LENGTH ONLY IN E
	CMP C,#FLREGP	;P?
	BNE FLINC2
	JSR PC,@FLPOPS(E)	;YES, POP FROM MID-STACK
FLINC2:	ADD E,(C)	;POSTINCREMENT REGISTER
	CLZ
	RTS PC


FLAINC:	ADD #FLREGS,B	;PTR TO REGISTER
	MOV B,C		;COPY IT
	MOV @(B),B	;INDIRECT
	JSR PC,FLXFER	;XFER
	BIC #20,E	;LEAVE ONLY LENGTH
	CMP C,#FLREGP	;P?
	BNE FLAIN1	;IF NOT, PROCEED
	JSR PC,FLPOPS(E)	;IF SO, POP RIGHT #
FLAIN1:	ADD #2,(C)	;AND POSTINCREMENT
	CLZ
	RTS PC


FLDEC:	ADD #FLREGS,B	;POINTER TO SAVED REG
	CMP B,#FLREPC	;PC?
	BEQ FLDEC1
	MOV E,C		;NO, COPY LENGTH+SRC/DST SWITCH
	BIC #20,C	; AND LEAVE ONLY LENGTH
	SUB C,(B)	;PREDECREMENT REGISTER
	CMP B,#FLREGP	;P?
	BNE FLDEC2	;IF NOT, PROCEED
	JSR PC,@FLPUSH(C)	;IF SO, PREPARE TO PUSH INTO MID-STACK
FLDEC2:	MOV (B),B	;INDIRECT
	JSR PC,FLXFER	;XFER
	CLZ
	RTS PC
FLDEC1:	SUB #2,FLREPC	;PREDECREMENT PC
	BIC #17,E	;FORCE LENGTH TO 1 WORD
	ADD #2,E
	BR FLDEC2	;AND PROCEED NORMALLY


FLADEC:	ADD #FLREGS,B	;POINTER TO SAVED REG
	SUB #2,(B)	;PREDECREMENT REGISTER
	MOV E,C		;COPY LENGTH + SRC/DST SWITCH
	BIC #20,C	;LEAVE ONLY LENGTH
	CMP B,#FLREGP	;P?
	BNE FLADE1	;IF NOT, PROCEED
	JSR PC,@FLPUSH(C)	;PREPARE TO PUSH INTO MID-STACK
FLADE1:	MOV @(B),B	;INDIRECT
	JSR PC,FLXFER	;XFER
	CLZ
	RTS PC	
.SBTTL XFER ROUTINES
FLXFER:	MOV B,FLOLDB	;SAVE ARG PTR FOR POSSIBLE REUSE
	JSR PC,@FLXFRS(E)	;AND DISPATCH TO XFER ROUTINE
	RTS PC

FLXFR1:	MOV FLOLDB,B	;REINSTATE ARG PTR
	JSR PC,@FLXFRS(E)
	RTS PC


;THESE ROUTINES TRANSFER THE APPROPRIATE NUMBER OF WORDS TO OR
;FROM THE ARGUMENT STACK.
;CALLED WITH POINTER TO SRC/DST IN B,OPERAND STACK PTR IN F,
;FIXED/FLOAT FLAG IN D.
;B IS CLOBBERED, F IS UPDATED.
FLXFRS=	.-2		;DISP TAB. OFFSET= SRC/DST FLAG (0=>SRC,
	.WORD FLXF1S	; 1=>DST) + SRC/DST LENGTH (BYTES)
	.WORD FLXF2S
	.WORD 0
	.WORD FLXF4S
	.BLKW 4
	.WORD FLXF1D
	.WORD FLXF2D
	.WORD 0
	.WORD FLXF4D

FLXF1S:	TST D		;FIXED OR FLOAT?
	BEQ FLX1
	MOV (B)+,-(F)	;FIXED, PUSH LOW WORD,
	SXT -(F)	; EXTEND SIGN INTO HI
	RTS PC
FLX1:	CLR -(F)	;FLOAT,CLEAR LOW WORD,
	MOV (B)+,-(F)	; PUSH HI
	RTS PC

FLXF2S:
FLXF4S:	SUB #4,F	;PUSH 2 OR 4 WORDS
	MOV (B)+,(F)
	MOV (B)+,2(F)
	RTS PC

FLXF1D:	TST D		;FLOAT OR FIXED?
	BEQ FLX1
	BIT #FLINTB,FPS...	;FIXED, SHORT OR LONG?
	BNE FLX2
	TST (F)+	;SHORT, IGNORE HI WORD
	MOV (F)+,(B)+	;AND XFER LO
	RTS PC
FLX2:	MOV (F)+,(B)+	;FLOATING OR FIXED DOUBLE,
	TST (F)+	; XFER HI WORD AND FLUSH LO
	RTS PC

FLXF2D:	MOV (F)+,(B)+	;POP 2 WORDS
	MOV (F)+,(B)+
	RTS PC

FLXF4D:	MOV (F)+,(B)+	;POP 4 WORDS
	MOV (F)+,(B)+
	CLR (B)+
	CLR (B)+
;THESE ROUTINES TRANSFER A NUMBER BETWEEN AN ACCUMULATOR AND
;THE OPERAND STACK.
;CALLED WITH EMULATED INSTRUCTION IN A, OPERAND STACK PTR IN F.
;CLOBBERS B.
FLACI:	MOV A,B		;COPY INSTRUCTION
	BIC #177477,B	;CLEAR ALL BUT ACC BITS
	ASH #-4,B	;=> FLACS OFFSET
	MOV B,FLACCX	;SAVE
	SUB #4,F
	MOV FLACS(B),(F)	;PUSH FROM ACCUMULATOR
	MOV FLACS+2(B),2(F)
	RTS PC

FLACO:	MOV A,B		;COPY INSTRUCTION
	BIC #177477,B	;CLEAR ALL BUT ACC BITS
	ASH #-4,B	;=> FLACS OFFSET
	BR FLACO2
FLACO1:	MOV FLACCX,B	;ENTER HERE IF ALREADY COMUPUTED
FLACO2:	MOV (F)+,FLACS(B)	;POP INTO ACCUMULATOR
	MOV (F)+,FLACS+2(B)
	RTS PC
.SBTTL PUSH/POP ROUTINES
;THESE ROUTINES PUSH/POP THE APPROPRIATE NUMBER OF WORDS FROM
;MID-STACK. WHEN ONE OF THESE ROUTINES IS ENTERED, THERE ARE
;SEVERAL WORDS ABOVE THE PRE-TRAP TOP-OF-STACK. THESE WORDS GET
;SHIFTED UP OR DOWN TO COMPENSATE FOR THE MID-STACK XFER.
FLPOPS=	.-2		;DISP TAB. OFFSET=ARGUMENT LENGTH(BYTES)
	.WORD FLPOP1
	.WORD FLPOP2
	.WORD 0
	.WORD FLPOP4

FLPOP1:	SAVE A		;POP 1 WORD
	MOV FLREGP,A	;A HAS PTR TO WORD BELOW NXT WRD TO SHIFT DOWN
FLPP1:	MOV -(A),2(A)	;SHIFT DOWN 1 WORD
	CMP A,P		;TILL CURRENT TOP OF STACK IS ENCOUNTERED
	BHI FLPP1
	TST (P)+	;NEW TOP OF STACK
	REST A
	RTS PC

FLPOP2:	SAVE A		;SAME AS ABOVE, BUT FOR TWO WORDS
	MOV FLREGP,A
FLPP2:	MOV -(A),4(A)
	CMP A,P
	BHI FLPP2
	CMP (P)+,(P)+
	REST A
	RTS PC

FLPOP4:	SAVE A		;SAME, AGAIN, BUT FOR FOUR WORDS
	MOV FLREGP,A
FLPP4:	MOV -(A),8.(A)
	CMP A,P
	BHI FLPP4
	ADD #8.,P
	REST A
	RTS PC
FLPUSH=	.-2		;DISP TAB FOR PUSHING
	.WORD FLPSH1
	.WORD FLPSH2
	.WORD 0
	.WORD FLPSH4

FLPSH1:	SAVE A		;MAKE ROOM FOR 1 WRD 2 B PUSHED IN MID-STACK
	TST -(P)	;POINT TO NEW TOP OF STACK
	MOV P,A		;A POINTS TO NEXT WORD TO BE SHIFTED TO
FLPH1:	MOV 2(A),(A)+	;SHIFT UP 1 WORD
	CMP A,FLREGP	;UNTIL NEW PRE-TRAP TOP OF STACK IS ENCOUNTERED
	BLO FLPH1
	REST A
	RTS PC

FLPSH2:	SAVE A		;SAME AS ABOVE, BUT FOR 2 WORDS
	CMP -(P),-(P)
	MOV P,A
FLPH2:	MOV 4(A),(A)+
	CMP A,FLREGP
	BLO FLPH2
	REST A
	RTS PC

FLPSH4:	SAVE A		;SAME AGAIN, BUT FOR 4 WORDS
	SUB #8.,P
	MOV P,A
FLPH4:	MOV 8.(A),(A)+
	CMP A,FLREGP
	BLO FLPH4
	REST A
	RTS PC
.SBTTL INSTRUCTION EMULATOR ROUTINES
FLLDF:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	JSR PC,FLOPER	;PUSH SOURCE ONTO STACK
	BEQ FLLDF1	;(IF ADDR SPEC WAS OK)
	JSR PC,FLTX	;TEST IT,SETTING FCC'S
	JSR PC,FLACO	;AND XFER TO ACCUMULATOR
FLLDF1:	RTS PC


FLSTF:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	ADD #20,E	;=> DESTINATION MODE
FLSTF1:	JSR PC,FLACI	;PUSH ACC ONTO STACK (FLSCF ENTERS HERE)
	JSR PC,FLOPER	;AND XFER TO DESTINATION
	RTS PC

FLMUL:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	JSR PC,FLACI	;PUSH ACC ONTO STACK
	JSR PC,FLOPER	;AND THEN STACK THE SRC ARG
	BEQ FLMUL1	;(IF ADDR SPEC WAS OK)
	FMUL F		;PERFORM THE OPERATION
	JSR PC,FLCCS	;COPY CCS INTO FCCS
	JSR PC,FLACO1	;POP THE RESULT INTO DST ACC
FLMUL1:	RTS PC

FLADD:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	JSR PC,FLACI	;PUSH ACC ONTO STACK
	JSR PC,FLOPER	;AND THEN STACK THE SRC ARG
	BEQ FLADD1	;(IF ADDR SPEC WAS OK)
.IFNZ 0
	JSR PC,FUCKAD
.IFF
	FADD F		;PERFORM THE OPERATION
.ENDC
	JSR PC,FLCCS	;COPY CCS INTO FCCS
	JSR PC,FLACO1	;POP THE RESULT INTO DST ACC
FLADD1:	RTS PC

FLSUB:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	JSR PC,FLACI	;PUSH ACC ONTO STACK
	JSR PC,FLOPER	;AND THEN STACK THE SRC ARG
	BEQ FLSUB1	;(IF ADDR SPEC WAS OK)
.IFNZ 0
	TST (F)		;ZERO?
	BEQ 1$		;YES, DON'T NEGATE
	SAVE A
	MOV #100000,A	;COMPLEMENT THE TOP BIT
	XOR A,(F)	;XOR IT IN
	REST A
1$:	JSR PC,FUCKAD
.IFF
	FSUB F		;SUBTRACT TO COMPARE
.ENDC
	JSR PC,FLCCS	;COPY CCS INTO FCCS
	JSR PC,FLACO1	;POP THE RESULT INTO DST ACC
FLSUB1:RTS PC

.IFNZ 0
FUCKAD:	TST (F)		;FIRST ARG ZERO?
	BNE 1$		;NOPE
	CMP (F)+,(F)+	;YUP, JUST POP IT
	BR 3$
1$:	TST 4(F)	;SECOND ARG ZERO?
	BNE 2$		;NOPE
	MOV (F),4(F)
	MOV 2(F),6(F)
	CMP (F)+,(F)+
3$:	TST (F)
	RTS PC
2$:	FADD F
	RTS PC
.ENDC

FLDIV:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	JSR PC,FLACI	;PUSH ACC ONTO STACK
	JSR PC,FLOPER	;AND THEN STACK THE SRC ARG
	BEQ FLDIV1	;(IF ADDR SPEC WAS OK)
	BIT #77600,(P)	;IS THE DIVISOR ZERO?
	BEQ FLDIV1	;IF SO, NOOP
	FDIV F
	JSR PC,FLCCS	;COPY CCS INTO FCCS
	JSR PC,FLACO1	;POP THE RESULT INTO DST ACC
FLDIV1:	RTS PC		


FLCLR:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	CLR -(F)	;PUSH A ZERO
	CLR -(F)
	ADD #20,E	;=> DESTINATION MODE
	JSR PC,FLOPER	;DUMP ZERO INTO DEST
	BEQ FLCLR1
	BIS #4,FPS...	;SET FZ
	BIC #13,FPS...	;CLR FN,FC,FV
FLCLR1:	RTS PC


FLNEG:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	SAVE E		;WILL USE AGAIN
	JSR PC,FLOPER	;GET NEGATEE(E?)
	BEQ FLNEG1	;IF BAD ADDR SPEC,IGNORE
	MOV #100000,B
	XOR B,(F)	;COMPLEMENT SIGN BIT
	JSR PC,FLTX	;AND TEST RESULT, SETTING FCC'S
	REST E
	ADD #20,E	;DESTINATION MODE
	JSR PC,FLXFR1	;TRANSFER NEGATED # BACK
FLNEG1:	RTS PC
FLABS:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	SAVE E
	JSR PC,FLOPER	;GET SOURCE
	BEQ FLABS1	;IF ADDR SPEC OK
	BIC #100000,(F)	;MAKE SURE IT'S POSITIVE
	BIC #17,FPS...	;TAKE CARE OF FCC'S
	BIT #77600,(F)	;ZERO?
	BNE FLABS2
	BIS #4,FPS...	;FZ
FLABS2:	REST E
	ADD #20,E	;=> DESTINATION MODE
	JSR PC,FLXFR1
FLABS1:	RTS PC


FLCMP:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	JSR PC,FLOPER	;STACK THE SRC ARG
	BEQ FLCMP1	;(IF THE ADDR SPEC WAS OK)
	JSR PC,FLACI	;AND THEN PUSH ACC ONTO STACK
.IFNZ 0
	TST (F)
	BEQ 1$
	SAVE A
	MOV #100000,A	;COMPLEMENT THE TOP BIT
	XOR A,(F)	;XOR IT IN
	REST A
1$:	JSR PC,FUCKAD
.IFF
	FSUB F		;SUBTRACT TO COMPARE
.ENDC
	JSR PC,FLCCS	;COPY CCS INTO FCCS
FLCMP1:	RTS PC		;RETURN WITHOUT CHANGING OPERAND VALUES


FLTST:	JSR PC,FLFLMD	;SET UP D,E MODE FLAGS
	JSR PC,FLOPER	;PUSH ARGUMENT ONTO OPERAND STACK
	BEQ FLTST1	;(IF ADDR SPEC WAS OK)
	JSR PC,FLTX	;AND TEST IT, SETTING FCC'S
FLTST1:	RTS PC		;RETURN WITH OPERAND UNCHANGED


FLLEX:	MOV #1,D	;FLOAT/FIXED FLAG => FIXED
	MOV #2,E	;2-BYTE SOURCE OPERAND MODE
	JSR PC,FLACI	;STACK THE SPECIFIED ACCUMULATOR
	JSR PC,FLOPER	;PUSH ARGUMENT ONTO OPERAND STACK
	TST (F)+	;GET EXPONENT
	MOV (F)+,B
	ADD #200,B	;CONVERT TO EXCESS-200
	BIC #177400,B
	ASH #7,B	;GET IT IN PLACE
	BIC #77600,(F)	;CLEAR ITS EXPONENT
	BIS B,(F)	;AND REPLACE IT WITH (B)
	JSR PC,FLTX	;TEST NEW # SETTING FCC'S
	JSR PC,FLACO1	;AND PUT NEW # BACK IN ACC
	RTS PC

FLSEX:	JSR PC,FLACI	;GET ACCUMULATOR CONTENTS
	MOV (F)+,B	;GET TOP WORD, WITH EXPONENT
	TST (F)+
	ASH #-7,B	;RIGHT-JUSTIFY EXPONENT
	BIC #177400,B	;AND ISOLATE IT
	SUB #200,B	;EXCESS-200 => 2'S COM
	MOV B,-(F)	;STACK IT
	MOV B,-(F)	; TWICE, ONE OR THE OTHER WILL XFER
	JSR PC,FLTXI	;TEST IT, SETTING CC'S AND FCC'S
	MOV #1,D	;FLOAT/INTEGER FLAG => INTEGER
	MOV #22,E	;2-BYTE DEST OPERAND MODE
	JSR PC,FLOPER	;AND XFER EXPONENT TO DEST
	RTS PC
FLLCF:	JMP FLLDF	;SAME THING DUE TO EMULATOR CONSTRAINTS


FLSCF:	CLR D		;FLOAT/FIXED FLAG => FLOAT
	BIT #FLOATB,FPS...	;DOUBLE MODE?
	BEQ FLSCF1
	MOV #24,E	;YES, SO DEST IS *NOT* DOUBLE MODE
	JMP FLSTF1	;SAME FROM HERE ON IN
FLSCF1:	MOV #30,E	;FIXED MODE, SO DEST IS DOUBLE
	JMP FLSTF1	;SAME


FLLFP:	MOV #1,D	;FLOAT/FIXED FLAG => FIXED
	MOV #2,E	;1-WORD SOURCE
	JSR PC,FLOPER	;GET IT
	MOV 2(F),FPS...	;STASH IT
	RTS PC


FLSFP:	MOV #1,D	;FLOAT/FIXED FLAG => FIXED
	MOV #22,E	;1-WORD DEST
	MOV FPS...,-(P)	;MAKE FPS BOTH HI AND LO, SINCE
	MOV FPS...,-(P)	;ONE OR THE OTHER WILL BE XFERED
	JSR PC,FLOPER
	RTS PC


FLSEF:	BIC #FLOATB,FPS...	;FLOATING MODE
	RTS PC


FLSEI:	BIC #FLINTB,FPS...	;INTEGER MODE
	RTS PC


FLSED:	BIS #FLOATB,FPS...	;DOUBLE MODE
	RTS PC


FLSEL:	BIS #FLINTB,FPS...	;LONG MODE
	RTS PC


FLCFC:	MOV FPS...,B	;GET FPS
	BIC #177760,B	;LEAVE ONLY FCC'S
	MOV FLREGP,C
	BIS B,-2(C)	;SET APPROPRIATE CC BITS OF SAVED PSW
	COM B
	BIC #177760,B
	BIC B,-2(C)	;AND CLEAR APPROPRIATE BITS
	RTS PC


FLSTS:	MOV #1,D	;FIXED/FLOAT FLAG => FIXED
	MOV #24,E	;2-WORD DESTINATION
	CLR -(F)	;WELL,THERE IS NO FLEMT FEC
	CLR -(F)	;SO WE MIGHT AS WELL RETURN ZEROS
	JSR PC,FLOPER
	RTS PC
FLLDC:	JSR PC,FLINMD	;SET UP D,E MODE FLAGS
	JSR PC,FLOPER	;GET INTEGER
	MOV (F)+,C
	MOV (F)+,D
	MOV #31.,E	;SHIFT COUNTER
	CLR B		;SIGN
	TST C		;POSITIVE?
	BPL FLLDC1
	NEG D		;IF NOT, NEGATE IT
	ADC C
	NEG C
	MOV #100000,B	;AND SET SIGN
FLLDC1:	ASHC #1,C	;SHIFT LEFT
	BMI FLLDC2	;FOUND A 1?
	SOB E,FLLDC1	;IF NOT, KEEP LOOKING
	CLR -(F)	;HERE, # WAS ZERO
	CLR -(F)
	BIC #13,FPS...
	BIS #4,FPS...	;SET FZ
	JSR PC,FLACO	;AND XFER ZERO
	RTS PC
FLLDC2:	ADD #200,E	;E IS EXPONENT, => EXCESS-200
	ASH #7,E	;GET IT IN PLACE
	ADD B,E		;AND ADD SIGN
	ASHC #-8.,C	;GET FRACTION IN PLACE
	BIC #177600,C	;CLEAR PLACE FOR SIGN/EXP
	ADD E,C		;ADD THEM
	MOV D,-(F)	;STACK NUMBER
	MOV C,-(F)
	JSR PC,FLTX	;SET FCC'S
	JSR PC,FLACO	;AND XFER
	RTS PC
FLSTC:	JSR PC,FLACI	;GET CONVERTEE
	MOV (F),E	;GET HI WD, WITH SIGN AND EXP
	ASH #-7,E	;RIGHT-JUSTIFY EXP
	BIC #177400,E	;AND ISOLATE IT
	SUB #200,E	;EXCESS-200 => 2'S COMP
	BLE FLSTCZ	;IF NONPOS EXP, GO FORCE A ZERO
	MOV (F),C	;ELSE, GET FRACTION
	MOV 2(F),D
	ASHC #7,C	;LEFT-JUSTIFY
	BIS #40000,C	;INSERT IMPLICIT HIGH BIT
	BIC #100000,C	;AND CLEAR SIGN BIT
FLSTC1:	SUB #32.,E	;WE'VE IMPLICITLY ASL'D 31 BITS,
	BGT FLSTCV	;MAKE SURE EXP < 2,
	INC E		;FINISH ADJUSTING FOR ASL 31,
	ASHC E,C	;AND SHIFT ACCORDING TO EXPONENT
	BVS FLSTCV
	TST (F)		;TEST SIGN OF THE FLOATING NUMBER
	BPL 1$		;IS WAS POSITIVE
	NEG D		;AND NEGATE IF -
	ADC C
	NEG C
1$:	BIT #FLOATB,FPS...	;SHORT MODE OR LONG?
	BNE FLSTC2	;IF LONG, PROCEED
	TST D		;ELSE CHECK FOR SHORT OVERFLOW
	BMI FLSTC3	;C MUST BE SIGN FOR D
	TST C
	BEQ FLSTC2
	BR FLSTCV
FLSTC3:	COM C
	BNE FLSTCV
FLSTC2:	MOV C,E		;GET THE TOP WORD
	SWAB E		;GET THE TOP BYTE
	MOVB E,E	;GET ONLY THIS BYTE
	TST E		;IS IT 0?
	BEQ 1$		;YES, OKAY
	COM E		;-1?
	BNE FLSTCV	;OVERFLOW
1$:	MOV D,-(F)	;STACK INTEGER
	MOV C,-(F)
	JSR PC,FLTXI	;TEST INTEGER, SET CC'S AND FCC'S
	BR FLSTC4

FLSTCZ:	BIS #4,FPS...	;SET FZ
	BIC #13,FPS...
	MOV FLREGP,C
	BIS #4,-2(C)	;AND Z
	BIC #13,-2(C)
	BR FLSTC5

FLSTCV:	BIS #1,FPS...	;SET FC
	BIC #16,FPS...
	MOV FLREGP,C
	BIS #1,-2(C)	;AND C
	BIC #16,-2(C)
FLSTC5:	CLR -(F)
	CLR -(F)

FLSTC4:	JSR PC,FLINMD	;SET UP D,E MODE FLAGS
	ADD #20,E	;DESTINATION MODE
	JSR PC,FLOPER	;XFER INTEGER TO DEST
	RTS PC
FLMOD:	JSR PC,FLFLMD	;SET D,E MODE FLAGS
	JSR PC,FLACI	;GET ACC
	JSR PC,FLOPER	;GET SRC OPERAND
	BEQ FLMOD3	;IF ADDR SPEC WAS OK
	FMUL F		;MULTIPLY
	JSR PC,FLCCS	;AND SET FCC'S
	MOV (F),E	;GET HI WORD, WITH EXP
	ASH #-7,E	;RIGHT-JUSTIFY EXP
	BIC #177400,E	;AND ISOLATE IT
	SUB #200,E	;EXCESS-200 => 2'S COMPLEMENT
	BGT FLMOD1
	CLR -(F)	;NONPOS EXP, INT PART ZERO
	CLR -(F)
	BR FLMOD2
FLMOD1:	MOV #377,C	;SET UP MASK
	MOV #177777,D
	NEG E
	ASHC E,C	;SHIFT INTO PLACE
	MOV 2(F),-(F)	;COPY INTEGERIZEE
	MOV 2(F),-(F)
	BIC C,(F)	;AND FLUSH FRACTION BITS
	BIC D,2(F)
FLMOD2:
.IFNZ 0
	TST (F)
	BEQ 1$
	SAVE A
	MOV #100000,A	;COMPLEMENT THE TOP BIT
	XOR A,(F)	;XOR IT IN
	REST A
1$:	JSR PC,FUCKAD
.IFF
	FSUB F		;SUBTRACT TO COMPARE
.ENDC
	SUB #4,F	;POINT TO INTEGER AGAIN
	SAVE FLACCX
	BIS #4,FLACCX	;MAKE ACC # ODD
	JSR PC,FLACO1	;AND XFER INTEGER
	REST FLACCX
	JSR PC,FLACO1	;NOW XFER FRACTION TO ORIGINAL ACC
FLMOD3:	RTS PC
.SBTTL INSTRUCTION AUXILIARY ROUTINES
FLFLMD:	CLR D		;SET UP FLAG FOR FLOAT, IE NON-INTEGER
	BIT #FLOATB,FPS...	;AND DETERMINE WHETHER 2 WDS OR 4
	BNE FLFLM1
	MOV #4,E	;2 WDS
	RTS PC
FLFLM1:	MOV #10,E	;4 WDS
	RTS PC

FLINMD:	MOV #1,D	;SET UP FLAG FOR INTEGER MODE
	BIT #FLINTB,FPS...	;AND DETERMINE WHETHER 1 OR 2 WDS
	BNE FLINM1
	MOV #2,E	;1 WORD
	RTS PC
FLINM1:	MOV #4,E	;2 WDS
	RTS PC


;TEST FLOATING ARGUMENT ON OPERAND STACK, SET FCC'S ACCORDINGLY
FLTX:	BIC #17,FPS...	;CLEAR FCC'S
	BIT #77600,(F)		;TEST THE OP-STACK RESULT EXPONENT
	BEQ FLTX1
	TST (F)		;TEST OP-STACK RESULT SIGN
	BMI FLTX2
	RTS PC
FLTX1:	BIS #4,FPS...	;SET FZ
	RTS PC
FLTX2:	BIS #10,FPS...	;SET FN
	RTS PC


;TEST INTEGER ARGUMENT ON OPERAND STACK, SET CC'S AND FCC'S
FLTXI:	BIC #17,FPS...	;CLEAR FCC'S
	SAVE A
	MOV FLREGP,A
	BIC #17,-2(A)	;AND CC'S
	TST (F)
	BEQ FLTXI1
	BMI FLTXI2
	REST A
	RTS PC
FLTXI1:	TST 2(F)	;TOP WORD ZERO, HOW 'BOUT BOTTOM?
	BNE FLTXI3
	BIS #4,FPS...	;SET FZ
	BIS #4,-2(A)	;AND Z
FLTXI3:	REST A
	RTS PC
FLTXI2:	BIS #10,FPS...	;SET FN
	BIS #10,-2(A)	;AND N
	REST A
	RTS PC

;COPY CURRENT CC'S INTO FCC'S
FLCCS:	MFPS C		;GET BYTE FROM PSW
	BIC #177760,C	;CLEAR ALL BUT CC'S
	BIS C,FPS...	;SET APPROPRIATE FCC'S
	COM C
	BIC #177760,C
	BIC C,FPS...	;AND CLEAR APPROPRIATE ONES
	RTS PC

